/* UCHARS */
#endif /* _MACHDEP_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tiffdefs.h ===
/* @(#)tiffdefs.h	1.4	(Pixar - RenderMan Division)	5/30/90 */
/*	tiffdefs.h	1.12	89/04/25	*/

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

#ifndef _TIFFDEFS_
#define	_TIFFDEFS_
/*
 * Tag Image File Format (TIFF)
 *
 * Based on Rev 5.0 from:
 *    Developer's Desk		Window Marketing Group
 *    Aldus Corporation		Microsoft Corporation
 *    411 First Ave. South	16011 NE 36th Way
 *    Suite 200			Box 97017
 *    Seattle, WA  98104	Redmond, WA  98073-9717
 *    206-622-5500		206-882-8080
 */
#define	TIFF_VERSION	42

#define	TIFF_BIGENDIAN		0x4d4d
#define	TIFF_LITTLEENDIAN	0x4949

typedef	struct {
	unsigned short tiff_magic;	/* magic number (defines byte order) */
	unsigned short tiff_version;	/* TIFF version number */
	unsigned long  tiff_diroff;	/* byte offset to first directory */
} TIFFHeader;

/*
 * TIFF Image File Directories are comprised of
 * a table of field descriptors of the form shown
 * below.  The table is sorted in ascending order
 * by tag.  The values associated with each entry
 * are disjoint and may appear anywhere in the file
 * (so long as they are placed on a word boundary).
 *
 * If the value is 4 bytes or less, then it is placed
 * in the offset field to save space.  If the value
 * is less than 4 bytes, it is left-justified in the
 * offset field.
 */
typedef	struct {
	unsigned short tdir_tag;	/* see below */
	unsigned short tdir_type;	/* data type; see below */
	unsigned long  tdir_count;	/* number of items; length in spec */
	unsigned long  tdir_offset;	/* byte offset to field data */
} TIFFDirEntry;

typedef	enum {
	TIF_BYTE = 1,		/* 8-bit unsigned integer */
	TIF_ASCII = 2,		/* 8-bit bytes w/ last byte null */
	TIF_SHORT = 3,		/* 16-bit unsigned integer */
	TIF_LONG = 4,		/* 32-bit unsigned integer */
	TIF_RATIONAL = 5		/* 64-bit fractional (numerator+denominator) */
#ifdef DESIGN_VER
,	TIF_SBYTE = 6,		/* 8-bit signed twos complement integer*/
	TIF_UNDEFINED = 7,	/* 8-bit byte that may contain anything*/
	TIF_SSHORT = 8,		/* 16-bit twos complement integer*/
	TIF_SLONG = 9,		/* 32-bit twos complement integer*/
	TIF_SRATIONAL = 10,	/* 64-bit fractional SLONG's */
	TIF_FLOAT = 11,		/* single precision IEEE format */
	TIF_DOUBLE = 12		/* double precision IEEE format */
#endif
} TIFFDataType;

/*
 * TIFF Tag Definitions.
 *
 * Those marked with a + are obsoleted by revision 5.0
 */
#define	TIFFTAG_SUBFILETYPE		254	/* subfile data descriptor */
#define	    FILETYPE_REDUCEDIMAGE	0x1	/* reduced resolution version */
#define	    FILETYPE_PAGE		0x2	/* one page of many */
#define	    FILETYPE_MASK		0x4	/* transparency mask */
#define	TIFFTAG_OSUBFILETYPE		255	/* +kind of data in subfile */
#define	    OFILETYPE_IMAGE		1	/* full resolution image data */
#define	    OFILETYPE_REDUCEDIMAGE	2	/* reduced size image data */
#define	    OFILETYPE_PAGE		3	/* one page of many */
#define	TIFFTAG_IMAGEWIDTH		256	/* image width in pixels */
#define	TIFFTAG_IMAGELENGTH		257	/* image height in pixels */
#define	TIFFTAG_BITSPERSAMPLE		258	/* bits per channel (sample) */
#define	TIFFTAG_COMPRESSION		259	/* data compression technique */
#define	    COMPRESSION_NONE		1	/* dump mode */
#define	    COMPRESSION_CCITTRLE	2	/* CCITT modified Huffman RLE */
#define	    COMPRESSION_CCITTFAX3	3	/* CCITT Group 3 fax encoding */
#define	    COMPRESSION_CCITTFAX4	4	/* CCITT Group 4 fax encoding */
#define	    COMPRESSION_LZW		5	/* Lempel-Ziv  & Welch */
#define	    COMPRESSION_NEXT		32766	/* NeXT 2-bit RLE */
#define	    COMPRESSION_CCITTRLEW	32771	/* #1 w/ word alignment */
#define	    COMPRESSION_PACKBITS	32773	/* Macintosh RLE */
#define	    COMPRESSION_THUNDERSCAN	32809	/* ThunderScan RLE */
#define	    COMPRESSION_PICIO		32900	/* old Pixar picio RLE */
#define	    COMPRESSION_SGIRLE		32901	/* Silicon Graphics RLE */
#define	TIFFTAG_PHOTOMETRIC		262	/* photometric interpretation */
#define	    PHOTOMETRIC_MINISWHITE	0	/* min value is white */
#define	    PHOTOMETRIC_MINISBLACK	1	/* min value is black */
#define	    PHOTOMETRIC_RGB		2	/* RGB color model */
#define	    PHOTOMETRIC_PALETTE		3	/* color map indexed */
#define	    PHOTOMETRIC_MASK		4	/* holdout mask */
#define	    PHOTOMETRIC_DEPTH		32768	/* z-depth data */
#define	TIFFTAG_THRESHHOLDING		263	/* +thresholding used on data */
#define	    THRESHHOLD_BILEVEL		1	/* b&w art scan */
#define	    THRESHHOLD_HALFTONE		2	/* or dithered scan */
#define	    THRESHHOLD_ERRORDIFFUSE	3	/* usually floyd-steinberg */
#define	TIFFTAG_CELLWIDTH		264	/* +dithering matrix width */
#define	TIFFTAG_CELLLENGTH		265	/* +dithering matrix height */
#define	TIFFTAG_FILLORDER		266	/* +data order within a byte */
#define	    FILLORDER_MSB2LSB		1	/* most significant -> least */
#define	    FILLORDER_LSB2MSB		2	/* least significant -> most */
#define	TIFFTAG_DOCUMENTNAME		269	/* name of doc. image is from */
#define	TIFFTAG_IMAGEDESCRIPTION	270	/* info about image */
#define	TIFFTAG_MAKE			271	/* scanner manufacturer name */
#define	TIFFTAG_MODEL			272	/* scanner model name/number */
#define	TIFFTAG_STRIPOFFSETS		273	/* offsets to data strips */
#define	TIFFTAG_ORIENTATION		274	/* +image orientation */
#define	    ORIENTATION_TOPLEFT		1	/* row 0 top, col 0 lhs */
#define	    ORIENTATION_TOPRIGHT	2	/* row 0 top, col 0 rhs */
#define	    ORIENTATION_BOTRIGHT	3	/* row 0 bottom, col 0 rhs */
#define	    ORIENTATION_BOTLEFT		4	/* row 0 bottom, col 0 lhs */
#define	    ORIENTATION_LEFTTOP		5	/* row 0 lhs, col 0 top */
#define	    ORIENTATION_RIGHTTOP	6	/* row 0 rhs, col 0 top */
#define	    ORIENTATION_RIGHTBOT	7	/* row 0 rhs, col 0 bottom */
#define	    ORIENTATION_LEFTBOT		8	/* row 0 lhs, col 0 bottom */
#define	TIFFTAG_SAMPLESPERPIXEL		277	/* samples per pixel */
#define	TIFFTAG_ROWSPERSTRIP		278	/* rows per strip of data */
#define	TIFFTAG_STRIPBYTECOUNTS		279	/* bytes counts for strips */
#define	TIFFTAG_MINSAMPLEVALUE		280	/* +minimum sample value */
#define	TIFFTAG_MAXSAMPLEVALUE		281	/* maximum sample value */
#define	TIFFTAG_XRESOLUTION		282	/* pixels/resolution in x */
#define	TIFFTAG_YRESOLUTION		283	/* pixels/resolution in y */
#define	TIFFTAG_PLANARCONFIG		284	/* storage organization */
#define	    PLANARCONFIG_CONTIG		1	/* single image plane */
#define	    PLANARCONFIG_SEPARATE	2	/* separate planes of data */
#define	TIFFTAG_PAGENAME		285	/* page name image is from */
#define	TIFFTAG_XPOSITION		286	/* x page offset of image lhs */
#define	TIFFTAG_YPOSITION		287	/* y page offset of image lhs */
#define	TIFFTAG_FREEOFFSETS		288	/* +byte offset to free block */
#define	TIFFTAG_FREEBYTECOUNTS		289	/* +sizes of free blocks */
#define	TIFFTAG_GRAYRESPONSEUNIT	290	/* gray scale curve accuracy */
#define	    GRAYRESPONSEUNIT_10S	1	/* tenths of a unit */
#define	    GRAYRESPONSEUNIT_100S	2	/* hundredths of a unit */
#define	    GRAYRESPONSEUNIT_1000S	3	/* thousandths of a unit */
#define	    GRAYRESPONSEUNIT_10000S	4	/* ten-thousandths of a unit */
#define	    GRAYRESPONSEUNIT_100000S	5	/* hundred-thousandths */
#define	TIFFTAG_GRAYRESPONSECURVE	291	/* gray scale response curve */
#define	TIFFTAG_GROUP3OPTIONS		292	/* 32 flag bits */
#define	    GROUP3OPT_2DENCODING	0x1	/* 2-dimensional coding */
#define	    GROUP3OPT_UNCOMPRESSED	0x2	/* data not compressed */
#define	    GROUP3OPT_FILLBITS		0x4	/* fill to byte boundary */
#define	TIFFTAG_GROUP4OPTIONS		293	/* 32 flag bits */
#define	    GROUP4OPT_UNCOMPRESSED	0x2	/* data not compressed */
#define	TIFFTAG_RESOLUTIONUNIT		296	/* units of resolutions */
#define	    RESUNIT_NONE		1	/* no meaningful units */
#define	    RESUNIT_INCH		2	/* english */
#define	    RESUNIT_CENTIMETER		3	/* metric */
#define	TIFFTAG_PAGENUMBER		297	/* page numbers of multi-page */
#define	TIFFTAG_COLORRESPONSEUNIT	300	/* color scale curve accuracy */
#define	    COLORRESPONSEUNIT_10S	1	/* tenths of a unit */
#define	    COLORRESPONSEUNIT_100S	2	/* hundredths of a unit */
#define	    COLORRESPONSEUNIT_1000S	3	/* thousandths of a unit */
#define	    COLORRESPONSEUNIT_10000S	4	/* ten-thousandths of a unit */
#define	    COLORRESPONSEUNIT_100000S	5	/* hundred-thousandths */
#define	TIFFTAG_COLORRESPONSECURVE	301	/* RGB response curve */
#define	TIFFTAG_SOFTWARE		305	/* name & release */
#define	TIFFTAG_DATETIME		306	/* creation date and time */
#define	TIFFTAG_ARTIST			315	/* creator of image */
#define	TIFFTAG_HOSTCOMPUTER		316	/* machine where created */
#define	TIFFTAG_PREDICTOR		317	/* prediction scheme w/ LZW */
#define	TIFFTAG_WHITEPOINT		318	/* image white point */
#define	TIFFTAG_PRIMARYCHROMATICITIES	319	/* primary chromaticities */
#define	TIFFTAG_COLORMAP		320	/* RGB map for pallette image */
/* tags 32995-32999 are private tags registered to SGI */
#define	TIFFTAG_MATTEING		32995	/* alpha channel is present */
#define	TIFFTAG_SGICOLORMAP		32996	/* SGI colormap indicator */
/* tags 33300-33309 are private tags registered to Pixar */
#define TIFFTAG_PIXAR0                  33300
#define TIFFTAG_PIXAR1                  33301
#define TIFFTAG_PIXAR2                  33302
#define TIFFTAG_PIXAR3                  33303
#define TIFFTAG_PIXAR4                  33304
#define TIFFTAG_PIXAR5                  33305
#define TIFFTAG_PIXAR6                  33306
#define TIFFTAG_PIXAR7                  33307
#define TIFFTAG_PIXAR8                  33308
#define TIFFTAG_PIXAR9                  33309
#ifdef DESIGN_VER
#define TIFFTAG_MODELPIXELSCALE			33550
#define TIFFTAG_MATRIX					33920
#define TIFFTAG_MODELTIES				33922
#define TIFFTAG_MODELTRANS				34264
#define TIFFTAG_GEOKEYDIR				34735
#define TIFFTAG_GEODOUBLE				34736
#define TIFFTAG_GEOASCII				34737
#endif
#endif /* _TIFFDEFS_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tifpch.cpp ===
//-----------------------------------------------------------------------------
// --------------------
// File ....: tifpch.cpp
// --------------------
// Author...: Tom Hudson
// Date ....: Feb. 20, 1996
// Descr....: TIF File I/O Module Precompiled Header generator
//
// History .: Feb. 20, 1996 - Created this file
//            
//-----------------------------------------------------------------------------

//-- Includes -----------------------------------------------------------------

#include <Max.h>
#include <bmmlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tifrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tif.rc
//
#define IDS_TIF                         1
#define IDS_TIF_FILE                    2
#define IDS_BITMAP_IO                   3
#define IDS_UNKNOWN                     4
#define IDS_READ_ERROR                  5
#define IDS_WRITE_ERROR                 6
#define IDS_TIF_DESC                    7
#define IDD_ABOUT                       101
#define IDD_TARGA_CONTROL               102
#define IDD_TIF_CONTROL                 102
#define IDC_16BITS                      1000
#define IDC_24BITS                      1001
#define IDC_COMPRESS                    1003
#define IDC_32BITS                      1004
#define IDC_AUTHORNAME                  1005
#define IDC_JOBNAME                     1006
#define IDC_MONOCHROME                  1006
#define IDC_COMMENTS1                   1007
#define IDC_COLOR                       1007
#define IDC_COMMENTS2                   1008
#define IDC_COMMENTS3                   1009
#define IDC_COMMENTS4                   1010
#define IDC_DITHER                      1011
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif.cpp ===
//-----------------------------------------------------------------------------
// --------------------
// File ....: tif.cpp
// --------------------
// Author...: Tom Hudson
// Date ....: Feb. 20, 1996
// Descr....: TIF File I/O Module
//
// History .: Feb. 20 1996 - Started
//

//-- Includes -----------------------------------------------------------------

#include <Max.h>
#include <bmmlib.h>
#include "pixelbuf.h"
#include "tif.h"
#include "tifrc.h"

// Some handy macros:

#define TIFWRITE(ptr,sz) ((fwrite((void *)ptr, sz, 1, stream)!=1) ? 0:1)

//#include <stdarg.h>

//-----------------------------------------------------------------------------
//-- File Class

class File {
     public:
        FILE *stream;
        File(const TCHAR *name, const TCHAR *mode) { stream = _tfopen(name,mode); }
        ~File() { Close(); }
        void Close() { if(stream) fclose(stream); stream = NULL; }
     };

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
     switch (fdwReason) {
         case DLL_PROCESS_ATTACH:
              if (hInst)
                 return(FALSE);
              hInst = hDLLInst;
              break;
         case DLL_PROCESS_DETACH:
              hInst  = NULL;
              break;
         case DLL_THREAD_ATTACH:
              break;
         case DLL_THREAD_DETACH:
              break;
     }
     return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// TIF Class Description

class TIFClassDesc:public ClassDesc {
     public:
        int           IsPublic     ( ) { return 1; }
        void         *Create       ( BOOL loading=FALSE) { return new BitmapIO_TIF; }
        const TCHAR  *ClassName    ( ) { return GetString(IDS_TIF); }
        SClass_ID     SuperClassID ( ) { return BMM_IO_CLASS_ID; }
        Class_ID      ClassID      ( ) { return Class_ID(TIFCLASSID,0); }
        const TCHAR  *Category     ( ) { return GetString(IDS_BITMAP_IO);  }
};

static TIFClassDesc TIFDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
     return GetString(IDS_TIF_DESC); 
}

DLLEXPORT int LibNumberClasses ( ) { 
     return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
     switch(i) {
        case  0: return &TIFDesc; break;
        default: return 0;        break;
     }
}

__declspec( dllexport ) ULONG LibVersion ( )  { 
     return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

BitmapIO_TIF::BitmapIO_TIF() {
	loadStorage = saveStorage = NULL;
	inStream = NULL;
	// Init user data
    UserData.version = TIFVERSION;
	UserData.saved = FALSE;
	UserData.writeType = WRITE_COLOR;
#ifdef ALLOW_COMPRESSION
	UserData.compressed = TRUE;
#endif //ALLOW_COMPRESSION
	}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::LongDesc()

const TCHAR *BitmapIO_TIF::LongDesc()  {
     return GetString(IDS_TIF_FILE);
}
     
//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::ShortDesc()

const TCHAR *BitmapIO_TIF::ShortDesc() {
     return GetString(IDS_TIF);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::LoadConfigure()

BOOL BitmapIO_TIF::LoadConfigure ( void *ptr ) {
     TIFUSERDATA *buf = (TIFUSERDATA *)ptr;
     if (buf->version == TIFVERSION) {
        memcpy((void *)&UserData,ptr,sizeof(TIFUSERDATA));
        return (TRUE);
     } else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::SaveConfigure()

BOOL BitmapIO_TIF::SaveConfigure ( void *ptr ) {
     if (ptr) {
 		UserData.saved = TRUE;
        memcpy(ptr,(void *)&UserData,sizeof(TIFUSERDATA));
        return (TRUE);
     } else
        return (FALSE);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::EvaluateConfigure()

DWORD BitmapIO_TIF::EvaluateConfigure ( ) {
      return (sizeof(TIFUSERDATA));
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     switch (message) {
        
        case WM_INITDIALOG: 
             CenterWindow(hWnd,GetParent(hWnd));
             return 1;
        

        case WM_COMMAND:
             switch (LOWORD(wParam)) {
                case IDOK:              
                case IDCANCEL:
                     EndDialog(hWnd,1);
                     break;
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::ShowAbout()

void BitmapIO_TIF::ShowAbout(HWND hWnd) {
     DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_ABOUT),
        hWnd,
        (DLGPROC)AboutCtrlDlgProc,
        (LPARAM)0);
}


//-----------------------------------------------------------------------------
// *> ControlCtrlDlgProc()
//

BOOL BitmapIO_TIF::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     static BOOL forced = FALSE;

     switch (message) {
        
        case WM_INITDIALOG: {
      
             CenterWindow(hWnd,GetParent(hWnd));
			 SetCursor(LoadCursor(NULL,IDC_ARROW));

             InitCommonControls();
             
             if (!UserData.saved)
                ReadCfg();

			 CheckDlgButton(hWnd,IDC_MONOCHROME,UserData.writeType == WRITE_MONO ? TRUE : FALSE); 
			 CheckDlgButton(hWnd,IDC_COLOR,UserData.writeType == WRITE_COLOR ? TRUE : FALSE); 
#ifdef ALLOW_COMPRESSION
			 CheckDlgButton(hWnd,IDC_COMPRESS,UserData.compressed); 
#endif //ALLOW_COMPRESSION
             return 1;
             
        }

        case WM_COMMAND:

             switch (LOWORD(wParam)) {
                
                case IDOK: {
                     if(IsDlgButtonChecked(hWnd,IDC_MONOCHROME))
					 	UserData.writeType = WRITE_MONO;
					 else
                     if(IsDlgButtonChecked(hWnd,IDC_COLOR))
					 	UserData.writeType = WRITE_COLOR;

#ifdef ALLOW_COMPRESSION
                     UserData.compressed = IsDlgButtonChecked(hWnd,IDC_COMPRESS) ? TRUE : FALSE;
#endif //ALLOW_COMPRESSION

  					WriteCfg();
                    EndDialog(hWnd,1);
					 }
                     break;

                case IDCANCEL:
                     EndDialog(hWnd,0);
                     break;
        
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// *> ControlDlgProc
//

static BOOL CALLBACK ControlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {
     static BitmapIO_TIF *bm = NULL;
     if (message == WM_INITDIALOG) 
        bm = (BitmapIO_TIF *)lParam;
     if (bm) 
        return (bm->Control(hWnd,message,wParam,lParam));
     else
        return(FALSE);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::Control()

BOOL BitmapIO_TIF::ShowControl(HWND hWnd, DWORD flag ) {
     return (
        DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_TIF_CONTROL),
        hWnd,
        (DLGPROC)ControlDlgProc,
        (LPARAM)this)
     );
}


//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::GetImageInfo()

BMMRES BitmapIO_TIF::GetImageInfo ( BitmapInfo *fbi ) {
     
     //-- Get File Header
     
     File file(fbi->Name(), _T("rb"));

     if(!(inStream = file.stream))
		return (ProcessImageIOError(fbi));

     tif=TIFFReadHdr(inStream);
     if(tif==NULL) {
		DebugPrint("TIFFReadHdr failed\n");
		return (ProcessImageIOError(fbi,BMMRES_BADFILEHEADER));
		}
     td = &tif->tif_dir;

     /* Fill in appropriate info slots */

     nsamp = td->td_samplesperpixel;
     fbi->SetWidth(td->td_imagewidth);
     fbi->SetHeight(td->td_imagelength);
     fbi->SetAspect(1.0f);
     //fbi->SetGamma(1.0f);
     fbi->SetFirstFrame(0);
     fbi->SetLastFrame(0);
	 int type = BMM_NO_TYPE;

     switch (td->td_photometric) {
     	case 0:  case 1:
			if(td->td_bitspersample == 1)
	     		type = BMM_LINE_ART;
			else
     			type = BMM_GRAY_8;
     		break;
     	case 2:
     		type = (td->td_samplesperpixel==4) ? BMM_TRUE_32 : BMM_TRUE_24;
     		break;
     	case 3:
			type = BMM_PALETTED;
     		break;
     	}

     if(type == BMM_NO_TYPE) {
		DebugPrint("Unknown TIF type\n");
		return (ProcessImageIOError(fbi,GetString(IDS_UNKNOWN)));
		}

	 fbi->SetType(type);

     return BMMRES_SUCCESS;
}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::Load()

BitmapStorage *BitmapIO_TIF::Load(BitmapInfo *fbi, Bitmap *map, BMMRES *status) {

	//-- Initialize Status Optimistically

	*status = BMMRES_SUCCESS;

	//-- Make sure nothing weird is going on

	if(openMode != BMM_NOT_OPEN) {
		*status = ProcessImageIOError(fbi,BMMRES_INTERNALERROR);
		return NULL;
	}

     openMode = BMM_OPEN_R;
     loadMap  = map;
     
     BitmapStorage *s = ReadTIFFile(fbi, map->Manager(), status);

     if(!s)
        return NULL;

     //-- Set the storage's BitmapInfo

     s->bi.CopyImageInfo(fbi);

     return s;
}

//-----------------------------------------------------------------------------
// *> BitmapIO_TIF::ReadTIFFile()
//
//    Load a TIF file, returning the storage location

BitmapStorage *BitmapIO_TIF::ReadTIFFile(BitmapInfo *fbi, BitmapManager *manager, BMMRES *status) {

     BitmapStorage *s = NULL;

     File file(fbi->Name(), _T("rb"));

     if(!(inStream = file.stream)) {
		*status = ProcessImageIOError(fbi);
        return NULL;
	}

	int res=1;

     tif = TIFFReadHdr(inStream);
     if (tif==NULL) {
		*status = ProcessImageIOError(fbi,BMMRES_BADFILEHEADER);
		return(0);
	}

     td = &tif->tif_dir;
	
#ifdef DESIGN_VER
	 GTIFF * gtif = GeoTIFFRead(td);
	 if (gtif)
	 {
		GeoTableItem * data = new GeoTableItem;
		
		data->m_geoInfo = true;
//		GeoTIFFCoordSysName(gtif, UserData.name);
		data->m_matrix = GeoTIFFModelTransform(gtif);
		data->m_names.AddName(const_cast<TCHAR *>(fbi->Name()));
		GeoTIFFExtents(data, gtif);
		TheManager->Execute(0, (ULONG)(fbi->Name()), (ULONG)(data), 0);
	 }
#endif

     nsamp = td->td_samplesperpixel;
     if (nsamp>4)
		nsamp = 4;	
     width = td->td_imagewidth;
	 height = td->td_imagelength;
	 fbi->SetWidth(width);
     fbi->SetHeight(height);
     fbi->SetAspect(1.0f);
     //fbi->SetGamma(1.0f);
     fbi->SetFirstFrame(0);
     fbi->SetLastFrame(0);

     load_alpha = (td->td_samplesperpixel==4) ? TRUE : FALSE;

     /* allocate decompression buffer memory */
     PixelBuf8 lbuf(tif->tif_scanlinesize);
     loadbuf = lbuf.Ptr();

     switch (td->td_photometric) {
     	case 0:
		case 1:
            if(td->td_bitspersample == 1) {
	     		fbi->SetType(BMM_LINE_ART); 	
		 		s = TifReadLineArt(fbi, manager); 
				}
			else {
     			fbi->SetType(BMM_GRAY_8); 	
     			s = TifReadGrayScale(fbi, manager); 
				}
     		break;
     	case 2:
     		fbi->SetType(BMM_TRUE_32);
     		if (td->td_planarconfig==PLANARCONFIG_SEPARATE)
     			s = TifReadPlanarRGB(fbi, manager);
     		else 
     			s = TifReadChunkyRGB(fbi, manager);
     		break;
     	case 3:
			fbi->SetType(BMM_PALETTED);
     		s = TifReadColPal(fbi, manager); 
     		break;
     	}

#ifdef DESIGN_VER
	 GeoTIFFClose(gtif);
#endif
     TIFFClose(tif);
     if(s)
        return s;

     //-- If we get here, something went wrong!

	*status = ProcessImageIOError(fbi,GetString(IDS_READ_ERROR));
     return NULL;

}

// Our TIF loader functions:

BitmapStorage *BitmapIO_TIF::TifReadLineArt(BitmapInfo *fbi, BitmapManager *manager) {
 
     //-- Create a storage for this bitmap ------------------------------------

     BitmapStorage *s = BMMCreateStorage(manager,BMM_LINE_ART);

     if(!s)
        return NULL;

     if (s->Allocate(fbi,manager,BMM_OPEN_R)==0) {
        bail_out:
        if(s) {
           delete s;
           s = NULL;
        }
        return NULL;
     }

	uchar byte;
	int nbyte,bytesperrow,x,y,photo,bps,nmax;
	
	bytesperrow = tif->tif_scanlinesize;
	photo = td->td_photometric;
	bps = td->td_bitspersample;
	if (bps!=1) {
		DebugPrint("Bad bits per sample\n");
		goto bail_out;
		}

	nmax = (1<<bps)-1;

    PixelBuf line64(width);

	for (y = 0; y<height; y++)  {
		if (TIFFReadScanline(tif, loadbuf, y, 0)<0) 
			goto bail_out;
        BMM_Color_64 *l64=line64.Ptr();
		x = 0;
		for (nbyte=0; nbyte<bytesperrow; nbyte++) {
			unsigned char mask;
			unsigned int c;
			int nsh;
			byte = loadbuf[nbyte];
			mask = nmax<<(8-bps);
			for (nsh=8-bps; nsh>=0; nsh-=bps, mask>>=bps, ++l64) {
				c = (byte&mask)>>nsh;  
				c = (c*255)/nmax;
				if (photo==0) c = 255-c;
				l64->r = l64->g = l64->b = c ? 0xffff : 0;
				l64->a = 0;
				if (++x == width) break;
				}
			}
        if(s->PutPixels(0,y,width,line64.Ptr())!=1)
            goto bail_out;
		}
	return s;
	}

BitmapStorage *BitmapIO_TIF::TifReadGrayScale(BitmapInfo *fbi, BitmapManager *manager) {
     
	 //-- Create a storage for this bitmap ------------------------------------

     BitmapStorage *s = BMMCreateStorage(manager,BMM_GRAY_8);

     if(!s)
        return NULL;

     if (s->Allocate(fbi,manager,BMM_OPEN_R)==0) {
        bail_out:
        if(s) {
           delete s;
           s = NULL;
        }
        return NULL;
     }

	uchar byte;
	int nbyte,bytesperrow,x,y,photo,bps,nmax;
	
	bytesperrow = tif->tif_scanlinesize;
	photo = td->td_photometric;
	bps = td->td_bitspersample;
	if (bps>8||bps==3||bps==5||bps==7) {
		DebugPrint("Bad bits per sample\n");
		goto bail_out;
		}

	nmax = (1<<bps)-1;

    PixelBuf line64(width);

	int accum = 0;
	int acc_ix = 0;

	for (y = 0; y<height; y++)  {
		if (TIFFReadScanline(tif, loadbuf, y, 0)<0) 
			goto bail_out;
        BMM_Color_64 *l64=line64.Ptr();
		x = 0;
		for (nbyte=0; nbyte<bytesperrow; nbyte++) {
			unsigned char mask;
			unsigned int c;
			int nsh;
			byte = loadbuf[nbyte];

			mask = nmax<<(8-bps);
			for (nsh=8-bps; nsh>=0; nsh-=bps, mask>>=bps) {
				c = (byte&mask)>>nsh;  
				c = (c*255)/nmax;
				if (photo==0) c = 255-c;
				accum += c;
				acc_ix++;
				if(acc_ix == td->td_samplesperpixel) {
					l64->r = l64->g = l64->b = (WORD)accum << 8;
					l64->a = 0;
					l64++;
					x++;
					accum = acc_ix = 0;
					}
				if (x >= width) break;
				}
			if (x >= width) break;
			}
        if(s->PutPixels(0,y,width,line64.Ptr())!=1)
            goto bail_out;
		}
	return s;
	}

static void PutColorComponent(BMM_Color_64 *ptr, int component, int width, BYTE *data) {
	UWORD *work = ((UWORD *)ptr) + component;
	for(int i = 0; i < width; ++i, work+=4, data++)
		*work = *data << 8;
	}

BitmapStorage *BitmapIO_TIF::TifReadPlanarRGB(BitmapInfo *fbi, BitmapManager *manager) {

	 //-- Create a storage for this bitmap ------------------------------------

     BitmapStorage *s = BMMCreateStorage(manager, BMM_TRUE_32);

     if(!s)
        return NULL;

     if(nsamp == 4)
        fbi->SetFlags(MAP_HAS_ALPHA);

     if (s->Allocate(fbi,manager,BMM_OPEN_R)==0) {
        bail_out:
        if(s) {
           delete s;
           s = NULL;
        }
        return NULL;
     }

    PixelBuf line64(width);

	int y,isamp;

	for (isamp=0; isamp<nsamp; isamp++) {
		for (y = 0; y<height; y++)  {
			if (TIFFReadScanline(tif, loadbuf, y, isamp)<0)
				goto bail_out;
			s->GetPixels(0,y,width,line64.Ptr());			
			PutColorComponent(line64.Ptr(), isamp, width, loadbuf);
			if(s->PutPixels(0,y,width,line64.Ptr())!=1)
				goto bail_out;
			}
		}
	return s;
	}

BitmapStorage *BitmapIO_TIF::TifReadChunkyRGB(BitmapInfo *fbi, BitmapManager *manager) {

	 //-- Create a storage for this bitmap ------------------------------------

     BitmapStorage *s = BMMCreateStorage(manager, BMM_TRUE_32);

     if(!s)
        return NULL;

     if(nsamp == 4)
        fbi->SetFlags(MAP_HAS_ALPHA);

     if (s->Allocate(fbi,manager,BMM_OPEN_R)==0) {
        bail_out:
        if(s) {
           delete s;
           s = NULL;
        }
        return NULL;
     }

    PixelBuf line64(width);

	uchar *scanptr;
	int x,y;
	for (y = 0; y<height; y++)  {
		if (TIFFReadScanline(tif, loadbuf, y, 0)<0)
			goto bail_out;
        BMM_Color_64 *l64=line64.Ptr();
		scanptr = loadbuf;
		for(x = 0; x < width; ++x, ++l64) {
			l64->r = *scanptr++ << 8;
			l64->g = *scanptr++ << 8;
			l64->b = *scanptr++ << 8;
			if(nsamp == 4)
				l64->a = *scanptr++ << 8;
			else
				l64->a = 0;
			}
		if(s->PutPixels(0,y,width,line64.Ptr())!=1)
			goto bail_out;
		}
	return s;
	}

void BitmapIO_TIF::ScrunchColorMap(BMM_Color_48 *colpal) {
	int npal,i;
	npal = 1<<td->td_bitspersample;
	for (i=0; i<npal; i++) {
		colpal[i].r = td->td_redcolormap[i];
		colpal[i].g = td->td_greencolormap[i];
		colpal[i].b = td->td_bluecolormap[i];
		}
	}

BitmapStorage *BitmapIO_TIF::TifReadColPal(BitmapInfo *fbi, BitmapManager *manager) {
	 //-- Create a storage for this bitmap ------------------------------------

     BitmapStorage *s = BMMCreateStorage(manager, BMM_PALETTED);

     if(!s)
        return NULL;

     if (s->Allocate(fbi,manager,BMM_OPEN_R)==0) {
        bail_out:
        if(s) {
           delete s;
           s = NULL;
        }
        return NULL;
     }

    PixelBuf8 line8(width);

	int x,y,bps,shft;
	BMM_Color_48 cmap[256];
	uchar byte,mask,*pbuf;

	bps = td->td_bitspersample;
	mask = (1<<bps)-1;
	ScrunchColorMap(cmap);
	s->SetPalette(0, 256, cmap);
	for (y = 0; y<height; y++)  {
		if (TIFFReadScanline(tif, loadbuf, y, 0)<0)
			goto bail_out;
		if (bps==4||bps==2||bps==1) {
			shft = -1;
			pbuf = loadbuf;
			for (x=0; x<width; x++) {
				if (shft<0) {
					byte = *pbuf++;
					shft = 8-bps;
					}
				line8[x] = (byte>>shft)&mask;
				shft-=bps;
				if (shft<0) {
					byte = *pbuf++;
					shft = 8-bps;
					}
				}
			if(s->PutIndexPixels(0,y,width,line8.Ptr())!=1)
				goto bail_out;
			}
		else {
			if(s->PutIndexPixels(0,y,width,loadbuf)!=1)	// 8 bits -- just use load buffer
				goto bail_out;
			}
		}
	return s;
	}


//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::OpenOutput()

BMMRES BitmapIO_TIF::OpenOutput(BitmapInfo *fbi, Bitmap *map) {

	if (openMode != BMM_NOT_OPEN)
		return (ProcessImageIOError(fbi,BMMRES_INTERNALERROR));
		
	if (!map)
		return (ProcessImageIOError(fbi,BMMRES_INTERNALERROR));
		
	//-- Check for Default Configuration -----------------
	
	if (!UserData.saved)
		ReadCfg();
	
    //-- Save Image Info Data

    bi.CopyImageInfo(fbi);    

    this->map   = map;
    openMode    = BMM_OPEN_W;

    return BMMRES_SUCCESS;

}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::Write()
//

BMMRES BitmapIO_TIF::Write(int frame) {
     
	//-- If we haven't gone through an OpenOutput(), leave

	if (openMode != BMM_OPEN_W)
		return (ProcessImageIOError(&bi,BMMRES_INTERNALERROR));

	//-- Resolve Filename --------------------------------

	TCHAR filename[MAX_PATH];

	if (frame == BMM_SINGLEFRAME) {
		_tcscpy(filename,bi.Name());
	} else {
		if (!BMMCreateNumberedFilename(bi.Name(),frame,filename))
			return (ProcessImageIOError(&bi,BMMRES_NUMBEREDFILENAMEERROR));
	}
	
     //-- Create Image File -------------------------------
     
     File file(filename, _T("wb"));
     
     if (!file.stream)
		return (ProcessImageIOError(&bi));

	// Below this line formatted for Tom's editor (sorry.)

	outStream = file.stream;

	// Find out what kind of output file we're dealing with

	saveStorage = map->Storage();
	if(!saveStorage)
		return (ProcessImageIOError(&bi,BMMRES_INTERNALERROR));

	int result = SaveTIF(file.stream);

	switch(result) {
		case TIF_SAVE_OK:
			return BMMRES_SUCCESS;
		case TIF_SAVE_WRITE_ERROR:
		default:
			return (ProcessImageIOError(&bi,GetString(IDS_WRITE_ERROR)));
		}

}

/** If this is 1, does horizontal differencing before LZW encode **/
int  hordif = 0; 

/* an actual tiff file header - with defaults in place */

static struct tiffhead ctiff =		/* an actual tiff file header */
{									/* with defaults in place */
	0X4949,42,8L,17,
	254,KPLONG,1L,0L,				/* defaulted */
	256,KPLONG,1L,0L,
	257,KPLONG,1L,0L,
	258,KPSHORT,1L,0,0,
	259,KPSHORT,1L,5,0,		 /* defaulted to LZW */
	262,KPSHORT,1L,0,0,
	266,KPSHORT,1L,1,0,			 /* defaulted */
	273,KPLONG,0L,0L,
	274,KPSHORT,1L,1,0,			 /* defaulted */
	277,KPSHORT,1L,0,0,
	278,KPSHORT,1L,0,0,
	279,KPLONG,0L,0L,
	282,KPRATIONAL,1L,0L,
	283,KPRATIONAL,1L,0L,
	284,KPSHORT,1L,0,0,
	296,KPSHORT,1L,1,0,	  	/* defaulted */
	317,KPSHORT,1L,1,0,	  	/* predictor:  defaulted */
	0L,							/* mark end of header */
	1L,1L,1L,1L,  				/* the aspect rationals */
	8,8,8,8						/* BitsPerSample for color */
	};

/* fill in the blanks in the tiff header */

void
BitmapIO_TIF::MakeTiffhead() {
	long work;

	ctiff.ImageWidth.val	= (long)(width);		/* image width */
	ctiff.ImageLength.val = (long)(height);		/* image height */
	ctiff.RowsPerStrip.val= rps;					/* rows per strip */
	ctiff.Predictor.val=(hordif?2:1);

	work = 10L;						 /* 10 bytes at start of header */ 
	work += (long)(ctiff.tags * 12);	/* + 12 bytes/tag */
	work += 4L;						 /* long 0 at end of header */
	ctiff.XResolution.val = work;		/* where xres1 can be found */
	work += 8L;						 /* two longs (xres1 & xres2) */
	ctiff.YResolution.val = work;		/* where yres1 can be found */
	work += 8L;						 /* two longs (yres1 & yres2) */

	if (UserData.writeType == WRITE_COLOR)				/* color tiff */
		{
		ctiff.BitsPerSample.n = write_alpha?4L:3L;
		ctiff.BitsPerSample.val = (short)work;	 /* where 8,8,8 can be found */
		ctiff.Photometric.val = 2;
		work += write_alpha?8L:6L;		 /* 3 shorts (rbits, gbits, bbits) */
		}
	else									/* greyscale tiff */
		{
		ctiff.BitsPerSample.n = 1L;
		ctiff.BitsPerSample.val = 8;		/* 8 bit greyscale */
		ctiff.Photometric.val = 1;
		}

	ctiff.StripOffsets.n = (long)blocks; /* # of entries in table */
	ctiff.StripOffsets.val = work;		 /* where the offset table starts */
	work += (long)(blocks*4);			    /* 4 byte offset for each line */
	
	ctiff.StripByteCounts.n = (long)blocks; /* # of entries in the table */
	ctiff.StripByteCounts.val = work;	/* where the byte count table starts */
 
	return;					 
	}

/*-----------------------------------------------------------
 * LZW Encoding.
-------------------------------------------------------------*/

#define	 MAXCODE(n)			((1 << (n)) - 1)
#define	SetMaxCode(v) {	lzw_state.lzw_maxcode = (v)-1; }

#ifdef ALLOW_COMPRESSION
/* Reset encoding state at the start of a strip. */
int BitmapIO_TIF::LZWPreEncode(void) {
	lzw_state.lzw_flags = 0;
	lzw_state.lzw_hordiff = hordif?LZW_HORDIFF8:0;
	lzw_state.lzw_stride = spp;
	lzw_state.enc_ratio = 0;
	lzw_state.enc_checkpoint = CHECK_GAP;
	lzw_state.lzw_nbits = BITS_MIN;
	SetMaxCode(MAXCODE(BITS_MIN)+1);
	lzw_state.lzw_free_ent = CODE_FIRST;
	lzw_state.lzw_bitoff = 0;
	lzw_state.lzw_bitsize = (BLOCKSIZE << 3) - (BITS_MAX-1);
	ClearHash();		/* clear hash table */
	lzw_state.lzw_oldcode = -1;	/* generates CODE_CLEAR in LZWEncode */
	return (1);
	}
#endif //ALLOW_COMPRESSION

#define REPEAT4(n, op)		\
    switch (n) {		\
    default: { int i; for (i = n-4; i > 0; i--) { op; } } \
    case 4:  op;		\
    case 3:  op;		\
    case 2:  op;		\
    case 1:  op;		\
    case 0:  ;			\
    }


static void
horizontalDifference8(register char *cp, register int cc, register int stride)
	{
	if (cc > stride) {
		cc -= stride;
		cp += cc - 1;
		do {
			REPEAT4(stride, cp[stride] -= cp[0]; cp--)
			cc -= stride;
			} while (cc > 0);
		}
	}

static void
horizontalDifference16(register short *wp, register int wc, register int stride)
	{
	if (wc > stride) {
		wc -= stride;
		wp += wc - 1;
		do {
			REPEAT4(stride, wp[stride] -= wp[0]; wp--)
			wc -= stride;
			} while (wc > 0);
		}
	}

#ifdef ALLOW_COMPRESSION
/* Encode a scanline of pixels.
 * Uses an open addressing double hashing (no chaining) on the 
 * prefix code/next character combination.  We do a variant of
 * Knuth's algorithm D (vol. 3, sec. 6.4) along with G. Knott's
 * relatively-prime secondary probe.  Here, the modular division
 * first probe is gives way to a faster exclusive-or manipulation. 
 * Also do block compression with an adaptive reset, whereby the
 * code table is cleared when the compression ratio decreases,
 * but after the table fills.  The variable-length output codes
 * are re-sized at this point, and a CODE_CLEAR is generated
 * for the decoder. 
 */
int BitmapIO_TIF::LZWEncode(uchar *bp,	int cc )	{
	register long fcode;
	register int h, c, ent, disp;

	/* XXX horizontal differencing alters user's data XXX */
	switch (lzw_state.lzw_hordiff) {
		case LZW_HORDIFF8:
			horizontalDifference8((char *)bp, cc, (int)lzw_state.lzw_stride);
			break;
		case LZW_HORDIFF16:
			horizontalDifference16((short *)bp, cc/2, (int)lzw_state.lzw_stride);
			break;
		}

	ent = lzw_state.lzw_oldcode;
	if (ent == -1 && cc > 0) {
		PutNextCode( CODE_CLEAR);
		ent = *bp++; cc--; lzw_state.enc_incount++;
		}
	while (cc > 0) {
		c = *bp++; cc--; lzw_state.enc_incount++;
		fcode = ((long)c << BITS_MAX) + ent;
		h = (c << HSHIFT) ^ ent;	/* xor hashing */
		if (lzw_state.enc_htab[h] == fcode) {
			ent = lzw_state.enc_codetab[h];
			continue;
			}
		if (lzw_state.enc_htab[h] >= 0) {
			/*
			 * Primary hash failed, check secondary hash.
			 */
			disp = HSIZE - h;
			if (h == 0)
				disp = 1;
			do {
				if ((h -= disp) < 0)
					h += HSIZE;
				if (lzw_state.enc_htab[h] == fcode) {
					ent = lzw_state.enc_codetab[h];
					goto hit;
					}
				} while (lzw_state.enc_htab[h] >= 0);
			}
		/*
		 * New entry, emit code and add to table.
		 */
		PutNextCode(ent);
		ent = c;
		
		lzw_state.enc_codetab[h] = lzw_state.lzw_free_ent++;
		lzw_state.enc_htab[h] = fcode;
		if (lzw_state.lzw_free_ent == CODE_MAX-1) {
			/* table is full, emit clear code and reset */
			lzw_state.enc_ratio = 0;
			ClearHash();
			lzw_state.lzw_free_ent = CODE_FIRST;
			PutNextCode(CODE_CLEAR);
			SetMaxCode(MAXCODE(lzw_state.lzw_nbits = BITS_MIN)+1);
		} else {
			if (lzw_state.enc_incount >= lzw_state.enc_checkpoint)
				ClearBlock();
			/*
			 * If the next entry is going to be too big for
			 * the code size, then increase it, if possible.
			 */
			if (lzw_state.lzw_free_ent > lzw_state.lzw_maxcode) {
				lzw_state.lzw_nbits++;
				SetMaxCode(MAXCODE(lzw_state.lzw_nbits)+1);
				}
			}
		hit:
			;
		}
	lzw_state.lzw_oldcode = ent;
	return (1);
	}

/*
 * Finish off an encoded strip by flushing the last
 * string and tacking on an End Of Information code.
 */
int BitmapIO_TIF::LZWPostEncode(void){
	if (lzw_state.lzw_oldcode != -1)
		PutNextCode(lzw_state.lzw_oldcode);
	PutNextCode(CODE_EOI);
	return (1);
	}

void BitmapIO_TIF::PutNextCode(int c)	{
	register long r_off;
	register int bits, code = c;
	register uchar *bp;

	r_off = lzw_state.lzw_bitoff;
	bits = lzw_state.lzw_nbits;
 	/* Get to the first byte. */
	bp = comp_buf + (r_off >> 3);
	r_off &= 7;
	/*
	 * Note that lzw_bitoff is maintained as the bit offset
	 * into the buffer w/ a right-to-left orientation (i.e.
	 * lsb-to-msb).  The bits, however, go in the file in
	 * an msb-to-lsb order.
	 */
	bits -= (8 - r_off);
	*bp = (*bp & lmask[r_off]) | (code >> bits);
	bp++;
	if (bits >= 8) {
		bits -= 8;
		*bp++ = code >> bits;
		}
	if (bits)
		*bp = (code & rmask[bits]) << (8 - bits);
	/*
	 * enc_outcount is used by the compression analysis machinery
	 * which resets the compression tables when the compression
	 * ratio goes up.  lzw_bitoff is used here (in PutNextCode) for
	 * inserting codes into the output buffer.  tif_rawcc must
	 * be updated for the mainline write code in TIFFWriteScanline()
	 * so that data is flushed when the end of a strip is reached.
	 * Note that the latter is rounded up to ensure that a non-zero
	 * byte count is present. 
	 */
	lzw_state.enc_outcount += lzw_state.lzw_nbits;
	lzw_state.lzw_bitoff += lzw_state.lzw_nbits;
	rawcc = (lzw_state.lzw_bitoff + 7) >> 3;
	}

/*
 * Check compression ratio and, if things seem to
 * be slipping, clear the hash table and reset state.
 */

void BitmapIO_TIF::ClearBlock(void) {
	register long rat;

	lzw_state.enc_checkpoint = lzw_state.enc_incount + CHECK_GAP;
	if (lzw_state.enc_incount > 0x007fffff) {	/* shift will overflow */
		rat = lzw_state.enc_outcount >> 8;
		rat = (rat == 0 ? 0x7fffffff : lzw_state.enc_incount / rat);
		} 
	else
		rat = (lzw_state.enc_incount << 8) / lzw_state.enc_outcount; /* 8 fract bits */
	if (rat <= lzw_state.enc_ratio) {
		lzw_state.enc_ratio = 0;
		ClearHash();
		lzw_state.lzw_free_ent = CODE_FIRST;
		PutNextCode(CODE_CLEAR);
		SetMaxCode(MAXCODE(lzw_state.lzw_nbits = BITS_MIN)+1);
		} 
	else
		lzw_state.enc_ratio = rat;
	}

/*  Reset code table. */

void BitmapIO_TIF::ClearHash() {
	register int *htab_p = lzw_state.enc_htab+HSIZE;
	register long i, m1 = -1;

	i = HSIZE - 16;
 	do {
		*(htab_p-16) = m1;
		*(htab_p-15) = m1;
		*(htab_p-14) = m1;
		*(htab_p-13) = m1;
		*(htab_p-12) = m1;
		*(htab_p-11) = m1;
		*(htab_p-10) = m1;
		*(htab_p-9) = m1;
		*(htab_p-8) = m1;
		*(htab_p-7) = m1;
		*(htab_p-6) = m1;
		*(htab_p-5) = m1;
		*(htab_p-4) = m1;
		*(htab_p-3) = m1;
		*(htab_p-2) = m1;
		*(htab_p-1) = m1;
		htab_p -= 16;
		} while ((i -= 16) >= 0);
   for (i += 16; i > 0; i--)
		*--htab_p = m1;
	}
#endif //ALLOW_COMPRESSION

int BitmapIO_TIF::WriteTIF(FILE *stream) {
	long	offsets= ctiff.StripOffsets.val,packw;
	long	counts = ctiff.StripByteCounts.val;
	WORD y, j, k, l;
	unsigned long grey;
	int nstrip = 0;

	y = 0;

	do {
		rawcc = 0;
#ifdef ALLOW_COMPRESSION
		if (UserData.compressed)
			LZWPreEncode();
#endif //ALLOW_COMPRESSION
		for (j=0; j<rps; j++) {

			/* get a row and prepare for encoding */
			GetOutputPixels(0,y++,width,scanline); // Get gamma-corrected pixels

			/* remove the desired sample */
			if (UserData.writeType == WRITE_COLOR) {				/* color tiff */
				int index = 0;
				scanptr = scanline;
				for(k = 0; k < width; ++k, ++scanptr) {
					WORD *pixel = (WORD *)scanptr;
					for(l = 0; l < spp; ++l)
						shortstrip[index++] = pixel[l] >> 8;
					}
				packw = width*spp;
				}
			else {									/* grey scale tiff */
				scanptr = scanline;
				for (k=0; k<width; k++, ++scanptr) {
					grey = (unsigned long)scanptr->r * 30L;		/* 30% red */
					grey+= (unsigned long)scanptr->g * 59L;		/* 59% green */
					grey+= (unsigned long)scanptr->b * 11L;		/* 11% blue */
					grey/= 100L;
					shortstrip[k] = (BYTE)(grey >> 8);
					}
				packw = width;
				}
#ifdef ALLOW_COMPRESSION
			if (UserData.compressed)
				LZWEncode(shortstrip, packw);
			else {
#endif //ALLOW_COMPRESSION
				memcpy(comp_buf+rawcc,shortstrip,packw);
				rawcc+= packw;
#ifdef ALLOW_COMPRESSION
				}
#endif //ALLOW_COMPRESSION
			if (y == height) break;
			}

#ifdef ALLOW_COMPRESSION
		if (UserData.compressed)
			LZWPostEncode();
#endif //ALLOW_COMPRESSION

		fseek(stream, 0L, SEEK_END);
		long filehold = ftell(stream);

		long kount = rawcc;

		if (!TIFWRITE(comp_buf, kount)) return(-1);
		fseek(stream, offsets, SEEK_SET);
		if (!TIFWRITE(&filehold, 4))	 return(-1);

		fseek(stream, counts, SEEK_SET);
		if (!TIFWRITE(&kount, 4))		return(-1);
		offsets+=4;	counts+=4;
		}	while (y != height);

	return((int)blocks);
	}

int
BitmapIO_TIF::SaveTIF(FILE *stream) {
	unsigned short i, work, ret=1;
	uchar	 spaces[8];

	width = map->Width();
	height = map->Height();

//	themap = map;
	write_alpha = (UserData.writeType == WRITE_COLOR && map->HasAlpha()) ? TRUE : FALSE;
	ctiff.PlanarConfiguration.val = 1;	/* chunky */
	spp =(UserData.writeType == WRITE_COLOR)?(write_alpha?4:3):1;  
	ctiff.SamplesPerPixel.val = spp;

	/* allocate memory for work areas */

	PixelBuf64 sline(width);
	scanline = sline.Ptr();
	PixelBuf8 sstrip(spp * width);
	shortstrip = sstrip.Ptr();
	PixelBuf8 cbuf((BLOCKSIZE*3)/2);
	comp_buf = cbuf.Ptr();

	/*
	 * rows per strip must be carefully chosen - especially in light
	 * of RGB images. Assuming a worse case scenario wrt/packing bits,
	 * (ie: a single plane receives NO compression due to the complexity
	 * of the image) there might be 512 * RPS bytes in a strip; assuming
	 * the use of a targa or vision16 sized image (512 X 486). The
	 * value of the image width (512) times the rows per strip must
	 * NOT exceed the BLOCKSIZE definition. If this happens, the
	 * potential exists to corrupt memory.
	 */

	rps = BLOCKSIZE/(width*spp);						/* nice default value */
	if (rps==0)
		return TIF_SAVE_WRITE_ERROR;

	blocks = ((height+rps-1)/rps);

	if (blocks==1) { /* want at least 2 blocks */
		int bsize = (width*height+1)/2;
		rps = bsize/(width*spp);
		blocks = ((height+rps-1)/rps);
		}

#ifdef ALLOW_COMPRESSION
	if (UserData.compressed)
		ctiff.Compression.val = 5;	  		/* LZW */
	else
#endif //ALLOW_COMPRESSION
		ctiff.Compression.val = 1;				/* set for no compression */

	for (i=0; i<8; i++)
		spaces[i] = 0;							/* filler for strip data */

	/* construct tiff file header */
	MakeTiffhead();

	work = sizeof(struct tiffhead);

	if (UserData.writeType == WRITE_MONO)
		work -= 8;			/* if grey, BitsPerSample.val is not an offset */
	else if (spp==3)
		work -=2;		/* no alpha component */

	/* write header */
	if (!TIFWRITE(&ctiff, work))	{
		ret = TIF_SAVE_WRITE_ERROR;
		goto tif_save_abort;
		}

	for (i = 0; i < blocks; i++)
		if (!TIFWRITE(&spaces, 8)) {
			ret = TIF_SAVE_WRITE_ERROR;
			goto tif_save_abort;
			}

	if (WriteTIF(stream) != blocks)
		ret = TIF_SAVE_WRITE_ERROR;

	tif_save_abort:

	if (ret != 1)	 {
		/* invalidate tiff file */
		fseek(stream, 0L, SEEK_SET);
		char *invalid = "INVALID";
		TIFWRITE(invalid,7);
		}

	return(ret);
	}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::GetCfgFilename()
//

void BitmapIO_TIF::GetCfgFilename( TCHAR *filename ) {
	_tcscpy(filename,TheManager->GetDir(APP_PLUGCFG_DIR));
	int len = _tcslen(filename);
	if (len) {
		if (_tcscmp(&filename[len-1],_T("\\")))
			_tcscat(filename,_T("\\"));
	}   
	_tcscat(filename,TIFCONFIGNAME);   
}

//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::ReadCfg()
//

BOOL BitmapIO_TIF::ReadCfg() {
	
	TCHAR filename[MAX_PATH];
	GetCfgFilename(filename);

	//-- Open Configuration File
	
	File file(filename, _T("rb"));
	
	if (!file.stream)
		return (FALSE);
	
	fseek(file.stream,0,SEEK_END);
	DWORD size = (DWORD)ftell(file.stream);
	
	if (size) {

		fseek(file.stream,0,SEEK_SET);
		
		//-- Allocate Temp Buffer
		
		BYTE *buf = (BYTE *)LocalAlloc(LPTR,size);
		
		if (!buf)
			return (FALSE);
		
		//-- Read Data Block and Set it
		
		BOOL res = FALSE;
		
		if (fread(buf,1,size,file.stream) == size)
			res = LoadConfigure(buf);
		
		LocalFree(buf);
	
		return (res);
	
	}
	
	return (FALSE);
}
	
//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::WriteCfg()
//

void BitmapIO_TIF::WriteCfg() {
 
	TCHAR filename[MAX_PATH];
	GetCfgFilename(filename);
	
	//-- Find out buffer size
	
	DWORD size = EvaluateConfigure();
	
	if (!size)
		return;
	
	//-- Allocate Temp Buffer
	
	BYTE *buf = (BYTE *)LocalAlloc(LPTR,size);
	
	if (!buf)
		return;
	
	//-- Get Data Block and Write it
	
	if (SaveConfigure(buf)) {   
		File file(filename, _T("wb"));
		if (file.stream) {
			fwrite(buf,1,size,file.stream);
		}
	}
	
	LocalFree(buf);
	
}


//-----------------------------------------------------------------------------
// #> BitmapIO_TIF::Close()
//

int  BitmapIO_TIF::Close( int flag ) {
     if(openMode != BMM_OPEN_W)
        return 0;
     return 1;
}

//-- EOF: TIF.cpp -----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_cfax.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)tiff_ccittfax.c	1.2 2/19/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * CCITT Groups 3 & 4 Facsimile-compatible
 * Compression Scheme Support.
 */
#include "tiffio.h"

TIFFInitCCITTFax3(tif)
	TIFF *tif;
{

	TIFFError(tif->tif_name,
            "CCITT Group 3 encoding not supported");
	return (0);
}

TIFFInitCCITTFax4(tif)
	TIFF *tif;
{

	TIFFError(tif->tif_name,
	    "CCITT Group 4 encoding not supported");
	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif.h ===
//-----------------------------------------------------------------------------
// --------------------
// File ....: tif.h
// --------------------
// Author...: Tom Hudson
// Date ....: Feb 1996
// Descr....: TIF File I/O Module
//
// History .: Feb. 20, 1996 - Started file
//            
//-----------------------------------------------------------------------------

// Uncomment the following when LZW compression is OK'd
//#define ALLOW_COMPRESSION

// Need to bracket the C-based library stuff with an explicit declaration:
#ifdef	__cplusplus
extern "C" {
#endif

#include "tif_port.h"
#include "tiffio.h"

// TIF library functions
extern TIFF * TIFFReadHdr( FILE *fd );

#ifdef	__cplusplus
	}
#endif

#ifdef DESIGN_VER
#include "gtiffio.h"
#endif

// Pack all the tif structs
#pragma pack(1)

#define TIFCLASSID 0xfc12

#define DLLEXPORT __declspec(dllexport)

#define TIFVERSION 102		// 101 = Original release
							// 102 = No-compression fix 7/5/96

#define TIFCONFIGNAME _T("tif.cfg")

#define BLOCKSIZE       (long)65536      // changed from 16384 DS 2/15/99

#define KPBYTE        (short)1   /* tag type defs */
#define KPASCII       (short)2
#define KPSHORT       (short)3
#define KPLONG        (short)4
#define KPRATIONAL    (short)5

/* LZW decode parameters */

#define BITS_MIN    9           /* start with 9 bits */
#define BITS_MAX    12          /* max of 12 bit strings */

/* packbits encode parameters */

#define     BASE            0
#define     LITERAL         1
#define     RUN             2
#define     LITERAL_RUN     3

/* predefined codes for LZW compression */

#define CODE_CLEAR  256         /* code to clear string table */
#define CODE_EOI    257         /* end-of-information code */
#define CODE_FIRST  258         /* first free code entry */
#define	CODE_MAX	MAXCODE(BITS_MAX)
#define HSIZE       11252       /* 80% occupancy */
/* #define HSIZE       9001  */      /* 80% occupancy */

struct tag        /* one element in a tiff header - type: LONG */
{
    short tagn;   /* tag id number */
    short type;   /* 1=byte, 2=ascii, 3=short, 4=long, 5=rational (2 longs) */
    long  n;      /* number of values to follow */
    long  val;    /* the value (if n=1) or an offset to table of values */
};

struct stag       /* one element in a tiff header - type: SHORT */
{
    short tagn;   /* tag id number */
    short type;   /* 1=byte, 2=ascii, 3=short, 4=long, 5=rational (2 longs) */
    long  n;      /* number of values to follow */
    short val;    /* the value (if n=1) or an offset to table of values */
    short junk;   /* junk value for filler */
};

struct tiffhead    /* structure for our TIFF Version 5.0 header */
{
    short order;                    /* byte order in file = II for Intel */
    short version;                  /* TIFF magic number is always 42   */
    long offset1;                   /* offset of 1st sub directory = 8 */
    short tags;                     /* number of entries in directory */
    struct tag NewSubfileType;      /* tag254 = 0 */
    struct tag ImageWidth;          /* tag256 = pixels/line */
    struct tag ImageLength;         /* tag257 = lines/image */
    struct stag BitsPerSample;      /* tag258 = 8 or offset to rbits */
    struct stag Compression;        /* tag259 = 1 for none, 5 for LZW */
    struct stag Photometric;        /* tag262 = 1 for grey, 2 for rgb */
    struct stag FillOrder;          /* tag266 = 1 (for Aldus PageMaker) */
    struct tag StripOffsets;        /* tag273 = offset of strip offsets */
    struct stag Orientation;        /* tag274 = 1 (for Aldus PageMaker) */
    struct stag SamplesPerPixel;    /* tag277 = 1 for grey, 3 for rgb */
    struct stag RowsPerStrip;       /* tag278 = 1 */
    struct tag StripByteCounts;     /* tag279 = offset of byte count table */
    struct tag XResolution;         /* tag282 = offset of xres1 */
    struct tag YResolution;         /* tag283 = offset of yres1 */
    struct stag PlanarConfiguration;/* tag284 = 1 for rgbrgbrgb... */
    struct stag ResolutionUnit;     /* tag296 = 1 for undefined */
    struct stag Predictor;          /* tag317 = 1 for none, 2 for LZW */
    long offsetn;                   /* offset of next subdirectory = 0 */
    long xres1,xres2,yres1,yres2;   /* x & y aspect */
    short rbits,gbits,bbits,abits;   /* bits per pixel of red, green, blue */
};

#define CHECK_GAP	10000		/* enc_ratio check interval */

static	uchar	 rmask[9] =
	{ 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff };
static	uchar lmask[9] =
    { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };
#undef HSIZE
#define	HSIZE		5003		/* 80% occupancy */
#define	HSHIFT		(8-(16-12))

/* LZW decompression status structure */
#define	LZW_HORDIFF4	0x01		/* hor. diff w/ 4-bit samples */
#define	LZW_HORDIFF8	0x02		/* hor. diff w/ 8-bit samples */
#define	LZW_HORDIFF16	0x04		/* hor. diff w/ 16-bit samples */
#define	LZW_HORDIFF32	0x08		/* hor. diff w/ 32-bit samples */
#define	LZW_RESTART	0x01		/* restart interrupted decode */

struct encode {
	int checkpoint;		/* point at which to clear table */
	long	ratio;			/* current compression ratio */
	long incount;		/* (input) data bytes encoded */
	long outcount;		/* encoded (output) bytes */
	int htab[HSIZE];		/* hash table */
	short	codetab[HSIZE];		/* code table */
   };

typedef struct {
	int  lzw_oldcode;			/* last code encountered */
	BYTE lzw_hordiff;
	WORD lzw_flags;
	WORD lzw_nbits;				/* number of bits/code */
	WORD lzw_stride;		/* horizontal diferencing stride */
	int   lzw_maxcode;			/* maximum code for lzw_nbits */
	long	lzw_bitoff;			 	/* bit offset into data */
	long	lzw_bitsize;			/* size of strip in bits */
	int	lzw_free_ent;			/* next free entry in hash table */
	union {
		struct encode enc;
		} u;
	} LZWState;

#define	enc_checkpoint	u.enc.checkpoint
#define	enc_ratio	u.enc.ratio
#define	enc_incount	u.enc.incount
#define	enc_outcount	u.enc.outcount
#define	enc_htab	u.enc.htab
#define	enc_codetab	u.enc.codetab

// Stop packing
#pragma pack()

//-----------------------------------------------------------------------------
//-- TIF data Structure -------------------------------------------------------
//

#define WRITE_MONO 0
#define WRITE_COLOR 1

#ifdef DESIGN_VER
typedef struct _tifuserdata {
     DWORD  version;
	 BOOL	saved;
     BYTE   writeType;
	 BOOL	geoInfo;
	 Matrix3 matrix;
} TIFUSERDATA;
#else
typedef struct _tifuserdata {
     DWORD  version;
	 BOOL	saved;
     BYTE   writeType;
#ifdef ALLOW_COMPRESSION
     BYTE   compressed;
#endif //ALLOW_COMPRESSION
} TIFUSERDATA;
#endif

// Reasons for TIF load failure:

#define TIF_SAVE_OK					1
#define TIF_SAVE_WRITE_ERROR		0

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class BitmapIO_TIF : public BitmapIO {
    
     private:
     
        Bitmap *loadMap;
		BitmapStorage *loadStorage;
		BitmapStorage *saveStorage;
        FILE   *inStream;
        FILE   *outStream;
		
		BOOL load_alpha;
		int nsamp;	// Number of samples per pixel
		int width, height;
		BYTE *loadbuf;
		TIFF *tif;
		TIFFDirectory *td;

        TIFUSERDATA   UserData;

        //-- This handler's private functions

        BitmapStorage *ReadTIFFile( BitmapInfo *fbi, BitmapManager *manager, BMMRES *status);
		BitmapStorage *LoadTIFStuff(BitmapInfo *fbi, BitmapManager *manager );
     	BitmapStorage *TifReadLineArt(BitmapInfo *fbi, BitmapManager *manager);
     	BitmapStorage *TifReadGrayScale(BitmapInfo *fbi, BitmapManager *manager);
     	BitmapStorage *TifReadPlanarRGB(BitmapInfo *fbi, BitmapManager *manager);
     	BitmapStorage *TifReadChunkyRGB(BitmapInfo *fbi, BitmapManager *manager);
		void ScrunchColorMap(BMM_Color_48 *colpal);
    	BitmapStorage *TifReadColPal(BitmapInfo *fbi, BitmapManager *manager);

		// Write stuff:
		unsigned short rps, spp;
		long rawcc;
		int blocks;
		LZWState lzw_state;
		BYTE *comp_buf, *shortstrip;
		BMM_Color_64 *scanline, *scanptr;
		BOOL write_alpha;
		void MakeTiffhead();
 		int SaveTIF(FILE *stream);
		int WriteTIF(FILE *stream);
		int LZWPreEncode(void);
		int LZWEncode(uchar *bp, int cc );
		int LZWPostEncode(void);
		void PutNextCode(int c);
		void ClearBlock(void);
		void ClearHash();

        void           GetCfgFilename     ( TCHAR *filename );
        BOOL           ReadCfg            ( );
        void           WriteCfg           ( );

     public:
     
        //-- Constructors/Destructors
        
                       BitmapIO_TIF       ( );
                      ~BitmapIO_TIF       ( ) {}

        //-- Number of extemsions supported
        
		#ifndef DESIGN_VER
        int            ExtCount           ( )       { return 1;}
		#else
		int            ExtCount           ( )       { return 2;}
		#endif // DESIGN_VER
        
        //-- Extension #n (i.e. "3DS")
        
		#ifndef DESIGN_VER
        const TCHAR   *Ext                ( int n ) { return _T("tif"); }
		#else
		const TCHAR   *Ext                ( int n ) { return (n==1) ? _T("tiff") : _T("tif"); }
		#endif // DESIGN_VER
        
        //-- Descriptions
        
        const TCHAR   *LongDesc           ( );
        const TCHAR   *ShortDesc          ( );

        //-- Miscelaneous Messages
        
        const TCHAR   *AuthorName         ( )       { return _T("Tom Hudson");}
        const TCHAR   *CopyrightMessage   ( )       { return _T("Copyright 1996 Yost Group");}
        UINT           Version            ( )       { return (100);}

        //-- Driver capabilities
        
        int            Capability         ( )       { return BMMIO_READER    | 
                                                             BMMIO_WRITER    | 
                                                             BMMIO_EXTENSION |
															 BMMIO_CONTROLWRITE; }
        
        //-- Driver Configuration
        
        BOOL           LoadConfigure      ( void *ptr );
        BOOL           SaveConfigure      ( void *ptr );
        DWORD          EvaluateConfigure  ( );
        
        //-- Show DLL's "About..." box
        
        void           ShowAbout          ( HWND hWnd );  

        //-- Show DLL's Control Panel
        
        BOOL           ShowControl        ( HWND hWnd, DWORD flag );

        //-- Return info about image
        
        BMMRES         GetImageInfo       ( BitmapInfo *fbi );        

        //-- Image Input
        
        BitmapStorage *Load               ( BitmapInfo *fbi, Bitmap *map, BMMRES *status);

        //-- Image Output
        
        BMMRES         OpenOutput         ( BitmapInfo *fbi, Bitmap *map );
        BMMRES         Write              ( int frame );
        int            Close              ( int flag );
  
        //-- This handler's specialized functions
        
        BOOL           Control            ( HWND ,UINT ,WPARAM ,LPARAM );
        
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_clse.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)tiff_close.c	1.6 4/25/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 */
#include "tiffio.h"
#include "tif_misc.h"

TIFFClose(tif)
	TIFF *tif;
{
#ifdef NEEDED
	static char module[] = "TIFFClose";
	TIFFDirEntry *dir = NULL;
#endif /* NEEDED */

#ifdef DO_WRITE
	if (tif->tif_mode != O_RDONLY)
		/*
		 * Flush buffered data and directory (if dirty).
		 */
		TIFFFlush(tif);
#endif

	if (tif->tif_cleanup)
		(*tif->tif_cleanup)(tif);
	TIFFFreeDirectory(tif);
	if (tif->tif_rawdata)
		free(tif->tif_rawdata);
	(void) close(tif->tif_fd);
#ifdef applec
	if (tif->tif_mode & O_RDWR)
		mac_typefile(tif->tif_name, MAC_TIFF_TYPE);
#endif
	free((char *)tif);
	return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tiffio.h ===
/* @(#)tiffio.h	1.5	(Pixar - RenderMan Division)	5/16/90 */
/*	tiffio.h	1.14	89/04/25	*/

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

#ifndef _TIFFIO_
#define	_TIFFIO_


#include "compat.h"
#include "tiffdefs.h"

/*
 * TIFF I/O Library Definitions.
 */

/*
 * Internal format of a TIFF directory entry.
 */
typedef	struct {
	u_short td_subfiletype;
	u_short	td_imagewidth, td_imagelength;
	u_short	td_bitspersample;
	u_short	td_compression;
	u_short	td_photometric;
	u_short	td_threshholding;
	u_short	td_orientation;
	u_short	td_samplesperpixel;
	u_short	td_predictor;
	u_long	td_rowsperstrip;
	u_long	td_minsamplevalue, td_maxsamplevalue;	/* maybe float? */
	float	td_xresolution, td_yresolution;
	u_short	td_resolutionunit;
	u_short	td_planarconfig;
	float	td_xposition, td_yposition;
	u_long	td_group3options;
	u_long	td_group4options;
	u_short td_pagenumber;
	u_short	td_grayresponseunit;
	u_short	td_colorresponseunit;
	u_short	td_matteing;
	u_short	*td_grayresponsecurve;	/* u_short for now (maybe float?) */
	u_short	*td_redresponsecurve;	/* u_short for now (maybe float?) */
	u_short	*td_greenresponsecurve;	/* u_short for now (maybe float?) */
	u_short	*td_blueresponsecurve;	/* u_short for now (maybe float?) */
	u_short	*td_redcolormap;
	u_short	*td_greencolormap;
	u_short	*td_bluecolormap;
#ifdef notdef
/* not yet used/supported */
	float	td_whitepoint[2];
	float	td_primarychromaticities[6];
#endif
	char	*td_documentname;
	char	*td_artist;
	char	*td_datetime;
	char	*td_hostcomputer;
	char	*td_imagedescription;
	char	*td_make;
	char	*td_model;
	char	*td_software;
	char	*td_pagename;
	u_long	td_fieldsset[2];	/* bit vector of fields that are set */
	u_long	td_stripsperimage;
	u_long	td_nstrips;		/* size of offset & bytecount arrays */
	u_long	*td_stripoffset;
	u_long	*td_stripbytecount;
#ifdef DESIGN_VER
	double	*td_modpixelscale;
	double	*td_matrix;
	u_short td_modtiescount;
	double	*td_modties;
	double	*td_modtrans;
	u_short *td_geokeydir;
	double	*td_geodouble;
	char	*td_geoascii;
#endif
} TIFFDirectory;

/*
 * Field flags used to indicate fields that have
 * been set in a directory, and to reference fields
 * when manipulating a directory.
 */
/* multi-entry fields */
#define	FIELD_IMAGEDIMENSIONS		0
#define	FIELD_CELLDIMENSIONS		1		/* XXX */
#define	FIELD_RESOLUTION		2
#define	FIELD_POSITION			3
/* single-entry fields */
#define	FIELD_SUBFILETYPE		4
#define	FIELD_BITSPERSAMPLE		5
#define	FIELD_COMPRESSION		6
#define	FIELD_PHOTOMETRIC		7
#define	FIELD_THRESHHOLDING		8
#define	FIELD_FILLORDER			9		/* XXX */
#define	FIELD_DOCUMENTNAME		10
#define	FIELD_IMAGEDESCRIPTION		11
#define	FIELD_MAKE			12
#define	FIELD_MODEL			13
#define	FIELD_ORIENTATION		14
#define	FIELD_SAMPLESPERPIXEL		15
#define	FIELD_ROWSPERSTRIP		16
#define	FIELD_MINSAMPLEVALUE		17
#define	FIELD_MAXSAMPLEVALUE		18
#define	FIELD_PLANARCONFIG		19
#define	FIELD_PAGENAME			20
#define	FIELD_GRAYRESPONSEUNIT		21
#define	FIELD_GRAYRESPONSECURVE		22
#define	FIELD_GROUP3OPTIONS		23
#define	FIELD_GROUP4OPTIONS		24
#define	FIELD_RESOLUTIONUNIT		25
#define	FIELD_PAGENUMBER		26
#define	FIELD_COLORRESPONSEUNIT		27
#define	FIELD_COLORRESPONSECURVE	28
#define	FIELD_STRIPBYTECOUNTS		29
#define	FIELD_STRIPOFFSETS		31
#define	FIELD_WHITEPOINT			32
#define	FIELD_PRIMARYCHROMATICITIES			33
#define	FIELD_COLORMAP			34
#define FIELD_PREDICTOR			35
#define FIELD_ARTIST			36
#define FIELD_DATETIME			37
#define FIELD_HOSTCOMPUTER		38
#define FIELD_SOFTWARE			39
#define	FIELD_MATTEING			40
#ifndef DESIGN_VER
#define	FIELD_LAST			FIELD_MATTEING
#else
#define FIELD_MODELPIXELSCALE	41
#define FIELD_MATRIX			42
#define FIELD_MODELTIES			43
#define FIELD_MODELTRANS		44
#define FIELD_GEOKEYDIR			45
#define FIELD_GEODOUBLE			46
#define FIELD_GEOASCII			47
#define FIELD_LAST			FIELD_GEOASCII
#endif

#define	TIFFFieldSet(tif, field) \
    ((tif)->tif_dir.td_fieldsset[field/32] & (1L<<(field&0x1f)))
#define	TIFFSetFieldBit(tif, field) \
    ((tif)->tif_dir.td_fieldsset[field/32] |= (1L<<(field&0x1f)))

typedef	struct {
	char	*tif_name;		/* name of open file */
	FILEHNDL	tif_fd;			/* open file descriptor */
	short	tif_mode;		/* open mode (O_*) */
	short	tif_flags;
#define	TIFF_DIRTYHEADER	0x1	/* header must be written on close */
#define	TIFF_DIRTYDIRECT	0x2	/* current directory must be written */
#define	TIFF_BUFFERSETUP	0x4	/* data buffers setup */
#define	TIFF_BEENWRITING	0x8	/* written 1+ scanlines to file */
#define	TIFF_SWAB		0x10	/* byte swap file information */
	u_long	tif_diroff;		/* file offset of current directory */
	long	tif_nextdiroff;		/* file offset of following directory */
	TIFFDirectory tif_dir;		/* internal rep of current directory */
	TIFFHeader tif_header;		/* file's header block */
	int	tif_typeshift[6];	/* data type shift counts */
	long	tif_typemask[6];	/* data type masks */
	long	tif_row;		/* current scanline */
	int	tif_curstrip;		/* current strip for read/write */
	long	tif_curoff;		/* current offset for read/write */
/* compression scheme hooks */
	int	(*tif_stripdecode)();	/* strip decoding routine (pre) */
	int	(*tif_decoderow)();	/* scanline decoding routine */
	int	(*tif_stripencode)();	/* strip encoding routine (pre) */
	int	(*tif_encoderow)();	/* scanline encoding routine */
	int	(*tif_encodestrip)();	/* strip encoding routine (post) */
	int	(*tif_seek)();		/* position within a strip routine */
	int	(*tif_cleanup)();	/* routine called to cleanup state */
	char	*tif_data;		/* compression scheme private data */
/* input/output buffer */
	long	tif_scanlinesize;	/* # of bytes in a scanline */
	char	*tif_rawdata;		/* raw data buffer */
	long	tif_rawdatasize;	/* # of bytes in raw data buffer */
	char	*tif_rawcp;		/* current spot in raw buffer */
	long	tif_rawcc;		/* bytes unread from raw buffer */
} TIFF;

#ifndef NULL
#define	NULL	0
#endif

	/* Declarations of libtiff routines. */
 
#if defined (__STDC__) || defined (KINETIX_TIFF_CHANGES)
 
extern TIFF *TIFFOpen(char *name, char *mode);
extern int TIFFClose(TIFF *tiff);
#ifdef __MACH__		/* really NeXT */
extern int TIFFSetField(TIFF *tif, int tag, ...);
extern int TIFFGetField(TIFF *tif, int tag, ...);
#else
extern int TIFFSetField(TIFF *tif, u_short tag, ...);
extern int TIFFGetField(TIFF *tif, u_short tag, ...);
#endif /* __MACH__ */
extern int TIFFReadDirectory(TIFF *tif);
extern int TIFFWriteDirectory(TIFF *tif);
extern int TIFFReadScanline(TIFF *tif, u_char *buf, u_int row, u_int sample);
extern int TIFFWriteScanline(TIFF *tif, u_char *buf, u_int row, u_int sample);
extern int TIFFFlush(TIFF *tif);
 
#else   /* __STDC__ */
 
extern  TIFF *TIFFOpen();
 
#endif  /* __STDC__ */

#include "tif_misc.h"

#endif /* _TIFFIO_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_crle.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)tiff_ccittrle.c	1.2 2/19/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * CCITT Group 3 1-D Modified Huffman
 * Run Length Encoding Compression Support
 */
#include "tiffio.h"

TIFFInitCCITTRLE(tif)
	TIFF *tif;
{
	TIFFError(tif->tif_name, "CCITT Group 3 1-D encoding not supported");
	return (0);
}

TIFFInitCCITTRLEW(tif)
	TIFF *tif;
{

	TIFFError(tif->tif_name, "CCITT Group 3 1-D encoding not supported");
	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_flsh.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)tiff_flush.c	1.5 4/25/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 */
#include "tiffio.h"

#ifdef KINETIX_TIFF_CHANGES
    extern int TIFFFlushData (TIFF *tif);
#endif

TIFFFlush(tif)
	TIFF *tif;
{

	if (tif->tif_mode != O_RDONLY) {
		if (tif->tif_rawcc > 0 && !TIFFFlushData(tif))
			return (0);
		if ((tif->tif_flags & TIFF_DIRTYDIRECT) &&
		    !TIFFWriteDirectory(tif))
			return (0);
	}
	return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_dump.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)dumpmode.c	1.2	(Pixar - RenderMan Division)	5/5/89";
/* static char sccsid[] = "@(#)tiff_dumpmode.c	1.7 4/25/89"; */
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * "Null" Compression Algorithm Support.
 */
#include "tiffio.h"

static	int DumpModeEncode(), DumpModeDecode(), DumpModeSeek();

/*
 * Initialize dump mode.
 */
TIFFInitDumpMode(tif)
	register TIFF *tif;
{
	tif->tif_decoderow = DumpModeDecode;
	tif->tif_encoderow = DumpModeEncode;
	tif->tif_seek = DumpModeSeek;
	return (1);
}

/*
 * Encode a scanline of pixels.
 */
static
DumpModeEncode(tif, pp, cc)
	register TIFF *tif;
	u_char *pp;
{

#ifdef DO_WRITE
	if (tif->tif_rawcc + cc > tif->tif_rawdatasize)
		if (!TIFFFlushData(tif))
			return (-1);
	bcopy(pp, tif->tif_rawcp, cc);
	tif->tif_rawcp += cc;
	tif->tif_rawcc += cc;
#endif
	return (1);
}

/*
 * Decode a scanline of pixels.
 */
static
DumpModeDecode(tif, buf, cc)
	TIFF *tif;
	u_char *buf;
{
	TIFFDirectory	*td = &tif->tif_dir;

	if (tif->tif_rawcc < cc) {
		TIFFError(tif->tif_name,
		    "DumpModeDecode: Not enough data for scanline %d",
		    tif->tif_row);
		return (0);
	}
	bcopy(tif->tif_rawcp, buf, cc);

	if (td->td_bitspersample > 8 && td->td_bitspersample <= 16 &&
                        (tif->tif_flags & TIFF_SWAB))
		TIFFSwabArrayOfShort((u_short *)buf, cc/2);

	return (DumpModeSeek(tif, 1));
}

/*
 * Seek forwards nrows in the current strip.
 */
static
DumpModeSeek(tif, nrows)
	register TIFF *tif;
	int nrows;
{

	tif->tif_rawcp += nrows * tif->tif_scanlinesize;
	tif->tif_rawcc -= nrows * tif->tif_scanlinesize;
	return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_lzw.c ===
#include "tif_port.h"

#define xDO_WRITE

#ifndef lint
static char sccsid[] = "@(#)lzw.c	1.3	(Pixar - RenderMan Division)	5/5/89";
/* static char sccsid[] = "@(#)tiff_lzw.c	1.7 4/25/89"; */
#endif
/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 * Rev 5.0 Lempel-Ziv & Welch Compression Support
 *
 * This code is derived from the compress program whose code is
 * derived from software contributed to Berkeley by James A. Woods,
 * derived from original work by Spencer Thomas and Joseph Orost.
 *
 * The original Berkeley copyright notice appears below in its entirety.
 */
#include "tiffio.h"
#include <assert.h>

#define MAXCODE(n)	((1 << (n)) - 1)
/*
 * The TIFF spec specifies that encoded bit strings range
 * from 9 to 12 bits.  This is somewhat unfortunate in that
 * experience indicates full color RGB pictures often need
 * ~14 bits for reasonable compression.
 */
#define	BITS_MIN	9		/* start with 9 bits */
#define	BITS_MAX	12		/* max of 12 bit strings */
/* predefined codes */
#define	CODE_CLEAR	256		/* code to clear string table */
#define	CODE_EOI	257		/* end-of-information code */
#define CODE_FIRST	258		/* first free code entry */
#define	CODE_MAX	MAXCODE(BITS_MAX)
#ifdef notdef
#define	HSIZE		9001		/* 91% occupancy */
#define	HSHIFT		(8-(16-13))
#else
#define	HSIZE		5003		/* 80% occupancy */
#define	HSHIFT		(8-(16-12))
#endif

/*
 * NB: The 5.0 spec describes a different algorithm than Aldus
 *     implements.  Specifically, Aldus does code length transitions
 *     one code earlier than should be done (for real LZW).
 *     Earlier versions of this library implemented the correct
 *     LZW algorithm, but emitted codes in a bit order opposite
 *     to the TIFF spec.  Thus, to maintain compatibility w/ Aldus
 *     we interpret MSB-LSB ordered codes to be images written w/
 *     old versions of this library, but otherwise adhere to the
 *     Aldus "off by one" algorithm.
 *
 * Future revisions to the TIFF spec are expected to "clarify this issue".
 */
#define	SetMaxCode(sp, v) {			\
	(sp)->lzw_maxcode = (v)-1;		\
	if ((sp)->lzw_flags & LZW_COMPAT)	\
		(sp)->lzw_maxcode++;		\
}

/*
 * Decoding-specific state.
 */
struct decode {
	short	prefixtab[HSIZE];	/* prefix(code) */
	u_char	suffixtab[CODE_MAX+1];	/* suffix(code) */
	u_char	stack[HSIZE-(CODE_MAX+1)];
	u_char	*stackp;		/* stack pointer */
	int	firstchar;		/* of string associated w/ last code */
};

/*
 * Encoding-specific state.
 */
struct encode {
	int checkpoint;		/* point at which to clear table */
#define CHECK_GAP	10000		/* enc_ratio check interval */
	long	ratio;			/* current compression ratio */
	long incount;		/* (input) data bytes encoded */
	long outcount;		/* encoded (output) bytes */
	int htab[HSIZE];		/* hash table */
	short	codetab[HSIZE];		/* code table */
};

/*
 * State block for each open TIFF
 * file using LZW compression/decompression.
 */
typedef	struct {
	int	lzw_oldcode;		/* last code encountered */
	u_char	lzw_hordiff;
#define	LZW_HORDIFF4	0x01		/* hor. diff w/ 4-bit samples */
#define	LZW_HORDIFF8	0x02		/* hor. diff w/ 8-bit samples */
#define	LZW_HORDIFF16	0x04		/* hor. diff w/ 16-bit samples */
#define	LZW_HORDIFF32	0x08		/* hor. diff w/ 32-bit samples */
	u_char	lzw_flags;
#define	LZW_RESTART	0x01		/* restart interrupted decode */
#define	LZW_COMPAT	0x02		/* read old bit-reversed codes */
	u_short	lzw_nbits;		/* number of bits/code */
	u_short	lzw_stride;		/* horizontal diferencing stride */
	int	lzw_maxcode;		/* maximum code for lzw_nbits */
	long	lzw_bitoff;		/* bit offset into data */
	long	lzw_bitsize;		/* size of strip in bits */
	int	lzw_free_ent;		/* next free entry in hash table */
	union {
		struct	decode dec;
		struct	encode enc;
	} u;
} LZWState;
#define	dec_prefix	u.dec.prefixtab
#define	dec_suffix	u.dec.suffixtab
#define	dec_stack	u.dec.stack
#define	dec_stackp	u.dec.stackp
#define	dec_firstchar	u.dec.firstchar

#define	enc_checkpoint	u.enc.checkpoint
#define	enc_ratio	u.enc.ratio
#define	enc_incount	u.enc.incount
#define	enc_outcount	u.enc.outcount
#define	enc_htab	u.enc.htab
#define	enc_codetab	u.enc.codetab

/* masks for extracting/inserting variable length bit codes */
static	u_char rmask[9] =
    { 0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff };
static	u_char lmask[9] =
    { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };


#if USE_PROTOTYPES
static	int LZWPreEncode(TIFF*);
static	int LZWEncode(TIFF*, u_char*, int);
static	int LZWPostEncode(TIFF*);
static	int LZWDecode(TIFF*, u_char*, int);
static	int LZWPreDecode(TIFF*);
static	int LZWCleanup(TIFF*);
static	int GetNextCode(TIFF*);
static	void PutNextCode(TIFF*, int);
static	void cl_block(TIFF*);
static	void cl_hash(LZWState*);
#else
static	int LZWPreEncode(), LZWEncode(), LZWPostEncode();
static	int LZWDecode(), LZWPreDecode();
static	int LZWCleanup();
static	int GetNextCode();
static	void PutNextCode();
static	void cl_block();
static	void cl_hash();
#endif

#ifdef __STDC__
#include <stdlib.h>
#endif


#ifdef KINETIX_TIFF_CHANGES
    #pragma optimize ("g", off) // Global optimizer will kill this poor old code
#endif



TIFFInitLZW(tif)
	TIFF *tif;
{
	tif->tif_stripdecode = LZWPreDecode;
	tif->tif_decoderow = LZWDecode;
	tif->tif_stripencode = LZWPreEncode;
	tif->tif_encoderow = LZWEncode;
	tif->tif_encodestrip = LZWPostEncode;
	tif->tif_cleanup = LZWCleanup;
	return (1);
}

static
LZWCheckPredictor(tif, sp)
	TIFF *tif;
	LZWState *sp;
{
	TIFFDirectory *td = &tif->tif_dir;

 switch (td->td_predictor) { 
	case 1:
		break;
	case 2:
		sp->lzw_stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?
		    td->td_samplesperpixel : 1);
		if (td->td_bitspersample == 8) {
			sp->lzw_hordiff = LZW_HORDIFF8;
			break;
		}
		if (td->td_bitspersample == 16) {
			sp->lzw_hordiff = LZW_HORDIFF16;
			break;
		}
		TIFFError(tif->tif_name,
    "Horizontal diff Predictor not supported with %d-bit samples",
		    td->td_bitspersample);
		return (0);
	default:
		TIFFError(tif->tif_name, "\"Predictor\" value %d not supported",
		    td->td_predictor);
		return (0);
	}
	return (1);
}

/*
 * LZW Decoder.
 */

/*
 * Setup state for decoding a strip.
 */
static
LZWPreDecode(tif)
	TIFF *tif;
{
	register LZWState *sp = (LZWState *)tif->tif_data;
	register int code;
	if (sp == NULL) {
		tif->tif_data = alloc(sizeof (LZWState));
		if (tif->tif_data == NULL) {
			TIFFError("LZWPreDecode",
			    "No space for LZW state block");
			return (0);
		}
		sp = (LZWState *)tif->tif_data;
		sp->lzw_flags = 0;
		sp->lzw_hordiff = 0;
		if (!LZWCheckPredictor(tif, sp))
			return (0);
	} else
		sp->lzw_flags &= ~LZW_RESTART;
	sp->lzw_nbits = BITS_MIN;
	/*
	 * Pre-load the table.
	 */
	for (code = 255; code >= 0; code--)
		sp->dec_suffix[code] = (u_char)code;
	sp->lzw_free_ent = CODE_FIRST;
	sp->lzw_bitoff = 0;
	/* calculate data size in bits */
	sp->lzw_bitsize = tif->tif_rawdatasize;
	sp->lzw_bitsize = (sp->lzw_bitsize << 3) - (BITS_MAX-1);
	sp->dec_stackp = sp->dec_stack;
	sp->lzw_oldcode = -1;
	sp->dec_firstchar = -1;
	/*
	 * Check for old bit-reversed codes.  All the flag
	 * manipulations are to insure only one warning is
	 * given for a file.
	 */
	if (tif->tif_rawdata[0] == 0 && (tif->tif_rawdata[1] & 0x1)) {
		if ((sp->lzw_flags & LZW_COMPAT) == 0)
			TIFFWarning(tif->tif_name,
			    "Old-style LZW codes, convert file");
		sp->lzw_flags |= LZW_COMPAT;
	} else
		sp->lzw_flags &= ~LZW_COMPAT;
	SetMaxCode(sp, MAXCODE(BITS_MIN));
	return (1);
}

#define REPEAT4(n, op)		\
    switch (n) {		\
    default: { int i; for (i = n-4; i > 0; i--) { op; } } \
    case 4:  op;		\
    case 3:  op;		\
    case 2:  op;		\
    case 1:  op;		\
    case 0:  ;			\
    }

static void
horizontalAccumulate8(cp, cc, stride)
	register char *cp;
	register int cc;
	register int stride;
{
	if (cc > stride) {
		cc -= stride;
		do {
			REPEAT4(stride, cp[stride] += cp[0]; cp++)
			cc -= stride;
		} while (cc > 0);
	}
}

static void
horizontalAccumulate16(wp, wc, stride)
	register short *wp;
	register int wc;
	register int stride;
{
	if (wc > stride) {
		wc -= stride;
		do {
			REPEAT4(stride, wp[stride] += wp[0]; wp++)
			wc -= stride;
		} while (wc > 0);
	}
}

/*
 * Decode the next scanline.
 */
static
LZWDecode(tif, op0, occ0)
	TIFF *tif;
	u_char *op0;
	int occ0;
{
	register char *op = (char *)op0;
	register int occ = occ0;
	register LZWState *sp = (LZWState *)tif->tif_data;
	register int code;
	register u_char *stackp;
	int firstchar, oldcode, incode;
	stackp = sp->dec_stackp;
	/*
	 * Restart interrupted unstacking operations.
	 */
	if (sp->lzw_flags & LZW_RESTART) {
		do {
			if (--occ < 0) {	/* end of scanline */
				sp->dec_stackp = stackp;
				return (1);
			}
			*op++ = *--stackp;
		} while (stackp > sp->dec_stack);
		sp->lzw_flags &= ~LZW_RESTART;
	}
	oldcode = sp->lzw_oldcode;
	firstchar = sp->dec_firstchar;
	while (occ > 0 && (code = GetNextCode(tif)) != CODE_EOI) {
		if (code == CODE_CLEAR) {
			bzero(sp->dec_prefix, sizeof (sp->dec_prefix));
			sp->lzw_free_ent = CODE_FIRST;
			sp->lzw_nbits = BITS_MIN;
			SetMaxCode(sp, MAXCODE(BITS_MIN));
			if ((code = GetNextCode(tif)) == CODE_EOI)
				break;
			*op++ = code, occ--;
			oldcode = firstchar = code;
			continue;
		}
		incode = code;
		/*
		 * When a code is not in the table we use (as spec'd):
		 *    StringFromCode(oldcode) +
		 *        FirstChar(StringFromCode(oldcode))
		 */
		if (code >= sp->lzw_free_ent) {	/* code not in table */
			*stackp++ = firstchar;
			code = oldcode;
		}

		/*
		 * Generate output string (first in reverse).
		 */
		for (; code >= 256; code = sp->dec_prefix[code])
			*stackp++ = sp->dec_suffix[code];
		*stackp++ = firstchar = sp->dec_suffix[code];
		do {
			if (--occ < 0) {	/* end of scanline */
				sp->lzw_flags |= LZW_RESTART;
				break;
			}
			*op++ = *--stackp;
		} while (stackp > sp->dec_stack);

		/*
		 * Add the new entry to the code table.
		 */
		if ((code = sp->lzw_free_ent) < CODE_MAX) {
			sp->dec_prefix[code] = (u_short)oldcode;
			sp->dec_suffix[code] = firstchar;
			sp->lzw_free_ent++;
			/*
			 * If the next entry is too big for the
			 * current code size, then increase the
			 * size up to the maximum possible.
			 */
			if (sp->lzw_free_ent > sp->lzw_maxcode) {
				sp->lzw_nbits++;
				if (sp->lzw_nbits > BITS_MAX)
					sp->lzw_nbits = BITS_MAX;
				SetMaxCode(sp, MAXCODE(sp->lzw_nbits));
			}
		} 
		oldcode = incode;
	}
	sp->dec_stackp = stackp;
	sp->lzw_oldcode = oldcode;
	sp->dec_firstchar = firstchar;
	switch (sp->lzw_hordiff) {
	case LZW_HORDIFF8:
		horizontalAccumulate8((char *)op0, occ0, (int)sp->lzw_stride);
		break;
	case LZW_HORDIFF16:
		horizontalAccumulate16((short *)op0, occ0/2,(int)sp->lzw_stride);
		break;
	}
	if (occ > 0) {
		TIFFError(tif->tif_name,
	    "LZWDecode: Not enough data for scanline %d",
		    tif->tif_row);
		return (0);
	}
	return (1);
}

/*
 * Get the next code from the raw data buffer.
 */
static
GetNextCode(tif)
	TIFF *tif;
{
	register LZWState *sp = (LZWState *)tif->tif_data;
	register int code, bits;
	register long r_off;
	register u_char *bp;

	/*
	 * This check shouldn't be necessary because each
	 * strip is suppose to be terminated with CODE_EOI.
	 * At worst it's a substitute for the CODE_EOI that's
	 * supposed to be there (see calculation of lzw_bitsize
	 * in LZWPreDecode()).
	 */
	if (sp->lzw_bitoff > sp->lzw_bitsize) {
		TIFFWarning(tif->tif_name,
		    "LZWDecode: Strip %d not terminated with EOI code",
		    tif->tif_curstrip);
		return (CODE_EOI);
	}
	r_off = sp->lzw_bitoff;
	bits = sp->lzw_nbits;
	/*
	 * Get to the first byte.
	 */
	bp = (u_char *)tif->tif_rawdata + (r_off >> 3);
	r_off &= 7;
	if (sp->lzw_flags & LZW_COMPAT) {
		/* Get first part (low order bits) */
		code = (*bp++ >> r_off);
		r_off = 8 - r_off;		/* now, offset into code word */
		bits -= r_off;
		/* Get any 8 bit parts in the middle (<=1 for up to 16 bits). */
		if (bits >= 8) {
			code |= *bp++ << r_off;
			r_off += 8;
			bits -= 8;
		}
		/* high order bits. */
		code |= (*bp & rmask[bits]) << r_off;
	} else {
		r_off = 8 - r_off;		/* convert offset to count */
		code = *bp++ & rmask[r_off];	/* high order bits */
		bits -= r_off;
		if (bits >= 8) {
			code = (code<<8) | *bp++;
			bits -= 8;
		}
		/* low order bits */
		code = (code << bits) | ((*bp & lmask[bits]) >> (8 - bits));
	}
	sp->lzw_bitoff += sp->lzw_nbits;
	return (code);
}

/*
 * LZW Encoding.
 */

/*
 * Reset encoding state at the start of a strip.
 */
static
LZWPreEncode(tif)
	TIFF *tif;
{
#ifdef DO_WRITE
	register LZWState *sp = (LZWState *)tif->tif_data;

	if (sp == NULL) {
		tif->tif_data = alloc(sizeof (LZWState));
		if (tif->tif_data == NULL) {
			TIFFError("LZWPreEncode",
			    "No space for LZW state block");
			return (0);
		}
		sp = (LZWState *)tif->tif_data;
		sp->lzw_flags = 0;
		sp->lzw_hordiff = 0;
		if (!LZWCheckPredictor(tif, sp))
			return (0);
	}
	sp->enc_ratio = 0;
	sp->enc_checkpoint = CHECK_GAP;
	SetMaxCode(sp, MAXCODE(sp->lzw_nbits = BITS_MIN)+1);
	sp->lzw_free_ent = CODE_FIRST;
	sp->lzw_bitoff = 0;
	sp->lzw_bitsize = (tif->tif_rawdatasize << 3) - (BITS_MAX-1);
	cl_hash(sp);		/* clear hash table */
	sp->lzw_oldcode = -1;	/* generates CODE_CLEAR in LZWEncode */
	return (1);
#else
	return 0;
#endif
}

#ifdef DO_WRITE
static void
horizontalDifference8(cp, cc, stride)
	register char *cp;
	register int cc;
	register int stride;
{
	if (cc > stride) {
		cc -= stride;
		cp += cc - 1;
		do {
			REPEAT4(stride, cp[stride] -= cp[0]; cp--)
			cc -= stride;
		} while (cc > 0);
	}
}

static void
horizontalDifference16(wp, wc, stride)
	register short *wp;
	register int wc;
	register int stride;
{
	if (wc > stride) {
		wc -= stride;
		wp += wc - 1;
		do {
			REPEAT4(stride, wp[stride] -= wp[0]; wp--)
			wc -= stride;
		} while (wc > 0);
	}
}
#endif

/*
 * Encode a scanline of pixels.
 *
 * Uses an open addressing double hashing (no chaining) on the 
 * prefix code/next character combination.  We do a variant of
 * Knuth's algorithm D (vol. 3, sec. 6.4) along with G. Knott's
 * relatively-prime secondary probe.  Here, the modular division
 * first probe is gives way to a faster exclusive-or manipulation. 
 * Also do block compression with an adaptive reset, whereby the
 * code table is cleared when the compression ratio decreases,
 * but after the table fills.  The variable-length output codes
 * are re-sized at this point, and a CODE_CLEAR is generated
 * for the decoder. 
 */
static
LZWEncode(tif, bp, cc)
	TIFF *tif;
	u_char *bp;
	int cc;
{
#ifdef DO_WRITE
#ifdef NEEDED
	static char module[] = "LZWEncode";
#endif /* NEEDED */
	register LZWState *sp;
	register long fcode;
	register int h, c, ent, disp;

	if ((sp = (LZWState *)tif->tif_data) == NULL)
		return (0);
/* XXX horizontal differencing alters user's data XXX */
	switch (sp->lzw_hordiff) {
	case LZW_HORDIFF8:
		horizontalDifference8((char *)bp, cc, (int)sp->lzw_stride);
		break;
	case LZW_HORDIFF16:
		horizontalDifference16((short *)bp, cc/2, (int)sp->lzw_stride);
		break;
	}
	ent = sp->lzw_oldcode;
	if (ent == -1 && cc > 0) {
		PutNextCode(tif, CODE_CLEAR);
		ent = *bp++; cc--; sp->enc_incount++;
	}
	while (cc > 0) {
		c = *bp++; cc--; sp->enc_incount++;
		fcode = ((long)c << BITS_MAX) + ent;
		h = (c << HSHIFT) ^ ent;	/* xor hashing */
		if (sp->enc_htab[h] == fcode) {
			ent = sp->enc_codetab[h];
			continue;
		}
		if (sp->enc_htab[h] >= 0) {
			/*
			 * Primary hash failed, check secondary hash.
			 */
			disp = HSIZE - h;
			if (h == 0)
				disp = 1;
			do {
				if ((h -= disp) < 0)
					h += HSIZE;
				if (sp->enc_htab[h] == fcode) {
					ent = sp->enc_codetab[h];
					goto hit;
				}
			} while (sp->enc_htab[h] >= 0);
		}
		/*
		 * New entry, emit code and add to table.
		 */
		PutNextCode(tif, ent);
		ent = c;
		
		sp->enc_codetab[h] = sp->lzw_free_ent++;
		sp->enc_htab[h] = fcode;
		if (sp->lzw_free_ent == CODE_MAX-1) {
			/* table is full, emit clear code and reset */
			sp->enc_ratio = 0;
			cl_hash(sp);
			sp->lzw_free_ent = CODE_FIRST;
			PutNextCode(tif, CODE_CLEAR);
			SetMaxCode(sp, MAXCODE(sp->lzw_nbits = BITS_MIN)+1);
		} else {
			if (sp->enc_incount >= sp->enc_checkpoint)
				cl_block(tif);
			/*
			 * If the next entry is going to be too big for
			 * the code size, then increase it, if possible.
			 */
			if (sp->lzw_free_ent > sp->lzw_maxcode) {
				sp->lzw_nbits++;
				assert(sp->lzw_nbits <= BITS_MAX);
				SetMaxCode(sp, MAXCODE(sp->lzw_nbits)+1);
			}
		}
	hit:
		;
	}
	sp->lzw_oldcode = ent;
	return (1);
#else
	return 0;
#endif
}

/*
 * Finish off an encoded strip by flushing the last
 * string and tacking on an End Of Information code.
 */
static
LZWPostEncode(tif)
	TIFF *tif;
{
	LZWState *sp = (LZWState *)tif->tif_data;

	if (sp->lzw_oldcode != -1)
		PutNextCode(tif, sp->lzw_oldcode);
	PutNextCode(tif, CODE_EOI);
	return (1);
}

static void
PutNextCode(tif, c)
	TIFF *tif;
	int c;
{
#ifdef DO_WRITE
	register LZWState *sp = (LZWState *)tif->tif_data;
	register long r_off;
	register int bits, code = c;
	register char *bp;

	r_off = sp->lzw_bitoff;
	bits = sp->lzw_nbits;
	/*
	 * Flush buffer if code doesn't fit.
	 */
	if (r_off + bits > sp->lzw_bitsize) {
		/*
		 * Calculate the number of full bytes that can be
		 * written and save anything else for the next write.
		 */
		if (r_off & 7) {
			tif->tif_rawcc = r_off >> 3;
			bp = tif->tif_rawdata + tif->tif_rawcc;
			(void) TIFFFlushData1(tif);
			tif->tif_rawdata[0] = *bp;
		} else {
			/*
			 * Otherwise, on a byte boundary (in
			 * which tiff_rawcc is already correct).
			 */
			(void) TIFFFlushData1(tif);
		}
		bp = tif->tif_rawdata;
		sp->lzw_bitoff = (r_off &= 7);
	} else {
		/*
		 * Get to the first byte.
		 */
		bp = tif->tif_rawdata + (r_off >> 3);
		r_off &= 7;
	}
	/*
	 * Note that lzw_bitoff is maintained as the bit offset
	 * into the buffer w/ a right-to-left orientation (i.e.
	 * lsb-to-msb).  The bits, however, go in the file in
	 * an msb-to-lsb order.
	 */
	bits -= (8 - r_off);
	*bp = (*bp & lmask[r_off]) | (code >> bits);
	bp++;
	if (bits >= 8) {
		bits -= 8;
		*bp++ = code >> bits;
	}
	if (bits)
		*bp = (code & rmask[bits]) << (8 - bits);
	/*
	 * enc_outcount is used by the compression analysis machinery
	 * which resets the compression tables when the compression
	 * ratio goes up.  lzw_bitoff is used here (in PutNextCode) for
	 * inserting codes into the output buffer.  tif_rawcc must
	 * be updated for the mainline write code in TIFFWriteScanline()
	 * so that data is flushed when the end of a strip is reached.
	 * Note that the latter is rounded up to ensure that a non-zero
	 * byte count is present. 
	 */
	sp->enc_outcount += sp->lzw_nbits;
	sp->lzw_bitoff += sp->lzw_nbits;
	tif->tif_rawcc = (sp->lzw_bitoff + 7) >> 3;
#endif
}

/*
 * Check compression ratio and, if things seem to
 * be slipping, clear the hash table and reset state.
 */
#ifdef DO_WRITE
static void
cl_block(tif)
	TIFF *tif;
{
	register LZWState *sp = (LZWState *)tif->tif_data;
	register long rat;

	sp->enc_checkpoint = sp->enc_incount + CHECK_GAP;
	if (sp->enc_incount > 0x007fffff) {	/* shift will overflow */
		rat = sp->enc_outcount >> 8;
		rat = (rat == 0 ? 0x7fffffff : sp->enc_incount / rat);
	} else
		rat = (sp->enc_incount << 8) / sp->enc_outcount; /* 8 fract bits */
	if (rat <= sp->enc_ratio) {
		sp->enc_ratio = 0;
		cl_hash(sp);
		sp->lzw_free_ent = CODE_FIRST;
		PutNextCode(tif, CODE_CLEAR);
		SetMaxCode(sp, MAXCODE(sp->lzw_nbits = BITS_MIN)+1);
	} else
		sp->enc_ratio = rat;
}
#endif

/*
 * Reset code table.
 */

static void
cl_hash(sp)
	LZWState *sp;
{
	register int *htab_p = sp->enc_htab+HSIZE;
	register long i, m1 = -1;

	i = HSIZE - 16;
 	do {
		*(htab_p-16) = m1;
		*(htab_p-15) = m1;
		*(htab_p-14) = m1;
		*(htab_p-13) = m1;
		*(htab_p-12) = m1;
		*(htab_p-11) = m1;
		*(htab_p-10) = m1;
		*(htab_p-9) = m1;
		*(htab_p-8) = m1;
		*(htab_p-7) = m1;
		*(htab_p-6) = m1;
		*(htab_p-5) = m1;
		*(htab_p-4) = m1;
		*(htab_p-3) = m1;
		*(htab_p-2) = m1;
		*(htab_p-1) = m1;
		htab_p -= 16;
	} while ((i -= 16) >= 0);
    	for (i += 16; i > 0; i--)
		*--htab_p = m1;
}

static
LZWCleanup(tif)
	TIFF *tif;
{

	if (tif->tif_data) {
		free(tif->tif_data);
		tif->tif_data = NULL;
	}
#ifdef KINETIX_TIFF_CHANGES
    return 1;       // arbitrary, but int function must return a value
#endif
}

/*
 * Copyright (c) 1985, 1986 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * James A. Woods, derived from original work by Spencer Thomas
 * and Joseph Orost.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_comp.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)tiff_compress.c	1.12 4/27/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library
 *
 * Compression Scheme Configuration Support.
 */
#include "tiffio.h"

extern	int TIFFInitDumpMode();
extern	int TIFFInitCCITTRLE(), TIFFInitCCITTRLEW();
extern	int TIFFInitPackBits();
#ifdef FAX_SUPPORT
extern	int TIFFInitCCITTFax3(), TIFFInitCCITTFax4();
#endif
#ifdef THUNDER_SUPPORT
extern	int TIFFInitThunderScan();
#endif
#ifdef PICIO_SUPPORT
extern	int TIFFInitPicio();
#endif
#ifdef NEXT_SUPPORT
extern	int TIFFInitNeXT();
#endif
#ifdef SGI_SUPPORT
extern	int TIFFInitSGI();
#endif
extern	int TIFFInitLZW();

static	struct cscheme {
	int	scheme;
	int	(*init)();
} CompressionSchemes[] = {
    { COMPRESSION_NONE,		TIFFInitDumpMode },
    { COMPRESSION_LZW,		TIFFInitLZW },
    { COMPRESSION_PACKBITS,	TIFFInitPackBits },
#ifdef PICIO_SUPPORT
    { COMPRESSION_PICIO,	TIFFInitPicio },
#endif
#ifdef THUNDER_SUPPORT
    { COMPRESSION_THUNDERSCAN,	TIFFInitThunderScan },
#endif
#ifdef NEXT_SUPPORT
    { COMPRESSION_NEXT,		TIFFInitNeXT },
#endif
#ifdef SGI_SUPPORT
    { COMPRESSION_SGIRLE,	TIFFInitSGI },
#endif
    { COMPRESSION_CCITTRLE,	TIFFInitCCITTRLE },
    { COMPRESSION_CCITTRLEW,	TIFFInitCCITTRLEW },
#ifdef FAX_SUPPORT
    { COMPRESSION_CCITTFAX3,	TIFFInitCCITTFax3 },
    { COMPRESSION_CCITTFAX4,	TIFFInitCCITTFax4 },
#endif
};
#define	NSCHEMES (sizeof (CompressionSchemes) / sizeof (CompressionSchemes[0]))

TIFFSetCompressionScheme(tif, scheme)
	TIFF *tif;
	int scheme;
{
	register struct cscheme *c;

	for (c = CompressionSchemes; c < &CompressionSchemes[NSCHEMES]; c++)
		if (c->scheme == scheme) {
			tif->tif_stripdecode = NULL;
			tif->tif_stripencode = NULL;
			tif->tif_encodestrip = NULL;
			tif->tif_seek = NULL;
			tif->tif_cleanup = NULL;
			return ((*c->init)(tif));
		}
	TIFFError(tif->tif_name, "Unknown data compression algorithm %u (0x%x)",
	    scheme, scheme);
	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_misc.cpp ===
//
// Tom's miscellaneous TIF support
//

#include "max.h"
#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>

void
TIFFError(char *module, char *fmt, ...)
	{
	va_list ap;
	char tmp_buffer[256];

	va_start(ap, fmt);
	vsprintf(tmp_buffer, fmt, ap);
	va_end(ap);
assert(0);
//	OutputDebugString(tmp_buffer);
}

void
TIFFWarning(char *module, char *fmt, ...)
	{
	va_list ap;
	char tmp_buffer[256];

	va_start(ap, fmt);
	vsprintf(tmp_buffer, fmt, ap);
	va_end(ap);
assert(0);
//	OutputDebugString(tmp_buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_misc.c ===
//
// Tom's miscellaneous TIF support
//

#include <stdio.h>
#include <ctype.h>
#include <stdarg.h>

void
TIFFError(char *module, char *fmt, ...)
	{
	va_list ap;
	char tmp_buffer[256];

	va_start(ap, fmt);
	vsprintf(tmp_buffer, fmt, ap);
	va_end(ap);
//	OutputDebugString(tmp_buffer);
}

void
TIFFWarning(char *module, char *fmt, ...)
	{
	va_list ap;
	char tmp_buffer[256];

	va_start(ap, fmt);
	vsprintf(tmp_buffer, fmt, ap);
	va_end(ap);
//	OutputDebugString(tmp_buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_dir.c ===
#include "tif_port.h"

#ifndef lint
static char     sccsid[] = "@(#)dir.c	1.12	(Pixar)	4/16/90";
/* static char sccsid[] = "@(#)tiff_dir.c	1.29 4/27/89"; */
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * Directory Support Routines.
 */

extern int rd_offset;


#ifdef __STDC__
#include <stdarg.h>
#else
#include <varargs.h>
#endif
#include "tiffio.h"

#ifdef applec
#include <FCntl.h>
#define lseek unix_lseek	/* Mac's Standard 'lseek' won't extend file */
#define L_SET 0
#define L_INCR 1
#define L_XTND 2
#define NO_FSTAT
/* applec's float parameters are really extended 80-bit floats. */
#define VA_FLOAT_PARAM_TYPE extended
#endif

// More commented-out stuff so the microsoft compiler won't generate bogus dependencies
//#ifdef i860
//#define NO_FSTAT
//#endif

//#ifndef NO_FSTAT
//#include "port/stat.h"
//#endif

/* If nobody's particular about this, assume doubles. */
#ifndef VA_FLOAT_PARAM_TYPE
#define VA_FLOAT_PARAM_TYPE double
#endif

// Forward reference
extern TIFFFetchStripThing(TIFF *tif,TIFFDirEntry *dir,u_long nstrips,u_long **lpp);
extern TIFFFetchPerSampleShorts(TIFF *tif, TIFFDirEntry *dir, long *pl);

#define	howmany(x, y)	(((x)+((y)-1))/(y))
#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))

#define	FieldSet(fields, f)		(fields[f/32] & (1L<<(f&0x1f)))
#define	ResetFieldBit(fields, f)	(fields[f/32] &= ~(1L<<(f&0x1f)))

#define	TIFFExtractData(tif, type, v) \
    ((tif)->tif_header.tiff_magic == TIFF_BIGENDIAN ? \
        ((v) >> (tif)->tif_typeshift[type]) & (tif)->tif_typemask[type] : \
	(v) & (tif)->tif_typemask[type])
#define	TIFFInsertData(tif, type, v) \
    ((tif)->tif_header.tiff_magic == TIFF_BIGENDIAN ? \
        ((v) & (tif)->tif_typemask[type]) << (tif)->tif_typeshift[type] : \
	(v) & (tif)->tif_typemask[type])

typedef	struct {
	u_short	field_tag;		/* field's tag */
	short	field_count;		/* expected item count */
	TIFFDataType field_type;	/* type of associated data */
	u_short	field_bit;		/* bit in fieldsset bit vector */
	char	*field_name;		/* TIF_ASCII name */
} TIFFFieldInfo;




/*
 * NB: This array is assumed to be sorted by tag.
 */
static
TIFFFieldInfo FieldInfo[] = {
    /*
     * SUBFILETYPE should be TIF_LONG according to the tiff 5.0 spec,
     * but previous versions of the library wrote it as TIF_SHORT,
     * so allow TIF_SHORT as a valid length for input.
     */
    { TIFFTAG_SUBFILETYPE,	 1, TIF_LONG,	FIELD_SUBFILETYPE,
      "SubfileType" },
    { TIFFTAG_SUBFILETYPE,	 1, TIF_SHORT,	FIELD_SUBFILETYPE,
      "SubfileType" },

    { TIFFTAG_OSUBFILETYPE,	 1, TIF_SHORT,	FIELD_SUBFILETYPE,
      "OldSubfileType" },
    { TIFFTAG_IMAGEWIDTH,	 1, TIF_LONG,	FIELD_IMAGEDIMENSIONS,
      "ImageWidth" },
    { TIFFTAG_IMAGEWIDTH,	 1, TIF_SHORT,	FIELD_IMAGEDIMENSIONS,
      "ImageWidth" },
    { TIFFTAG_IMAGELENGTH,	 1, TIF_LONG,	FIELD_IMAGEDIMENSIONS,
      "ImageLength" },
    { TIFFTAG_IMAGELENGTH,	 1, TIF_SHORT,	FIELD_IMAGEDIMENSIONS,
      "ImageLength" },
    { TIFFTAG_BITSPERSAMPLE,	-1, TIF_SHORT,	FIELD_BITSPERSAMPLE,
      "BitsPerSample" },
    { TIFFTAG_COMPRESSION,	 1, TIF_SHORT,	FIELD_COMPRESSION,
      "Compression" },
    { TIFFTAG_PHOTOMETRIC,	 1, TIF_SHORT,	FIELD_PHOTOMETRIC,
      "PhotometricInterpretation" },
    { TIFFTAG_THRESHHOLDING,	 1, TIF_SHORT,	FIELD_THRESHHOLDING,
      "Threshholding" },
    { TIFFTAG_CELLWIDTH,	 1, TIF_SHORT,	(u_short)-1,
      "CellWidth" },
    { TIFFTAG_CELLLENGTH,	 1, TIF_SHORT,	(u_short)-1,
      "CellLength" },
    { TIFFTAG_FILLORDER,	 1, TIF_SHORT,	(u_short)-1,
      "FillOrder" },
    { TIFFTAG_DOCUMENTNAME,	-1, TIF_ASCII,	FIELD_DOCUMENTNAME,
      "DocumentName" },
    { TIFFTAG_IMAGEDESCRIPTION,	-1, TIF_ASCII,	FIELD_IMAGEDESCRIPTION,
      "ImageDescription" },
    { TIFFTAG_MAKE,		-1, TIF_ASCII,	FIELD_MAKE,
      "Make" },
    { TIFFTAG_MODEL,		-1, TIF_ASCII,	FIELD_MODEL,
      "Model" },
    { TIFFTAG_STRIPOFFSETS,	-1, TIF_LONG,	FIELD_STRIPOFFSETS,
      "StripOffsets" },
    { TIFFTAG_STRIPOFFSETS,	-1, TIF_SHORT,	FIELD_STRIPOFFSETS,
      "StripOffsets" },
    { TIFFTAG_ORIENTATION,	 1, TIF_SHORT,	FIELD_ORIENTATION,
      "Orientation" },
    { TIFFTAG_SAMPLESPERPIXEL,	 1, TIF_SHORT,	FIELD_SAMPLESPERPIXEL,
      "SamplesPerPixel" },
    { TIFFTAG_ROWSPERSTRIP,	 1, TIF_LONG,	FIELD_ROWSPERSTRIP,
      "RowsPerStrip" },
    { TIFFTAG_ROWSPERSTRIP,	 1, TIF_SHORT,	FIELD_ROWSPERSTRIP,
      "RowsPerStrip" },
    { TIFFTAG_STRIPBYTECOUNTS,	-1, TIF_LONG,	FIELD_STRIPBYTECOUNTS,
      "StripByteCounts" },
    { TIFFTAG_STRIPBYTECOUNTS,	-1, TIF_SHORT,	FIELD_STRIPBYTECOUNTS,
      "StripByteCounts" },
    { TIFFTAG_MINSAMPLEVALUE,	-1, TIF_SHORT,	FIELD_MINSAMPLEVALUE,
      "MinSampleValue" },
    { TIFFTAG_MAXSAMPLEVALUE,	-1, TIF_SHORT,	FIELD_MAXSAMPLEVALUE,
      "MaxSampleValue" },
    { TIFFTAG_XRESOLUTION,	 1, TIF_RATIONAL,	FIELD_RESOLUTION,
      "XResolution" },
    { TIFFTAG_YRESOLUTION,	 1, TIF_RATIONAL,	FIELD_RESOLUTION,
      "YResolution" },
    { TIFFTAG_PLANARCONFIG,	 1, TIF_SHORT,	FIELD_PLANARCONFIG,
      "PlanarConfiguration" },
    { TIFFTAG_PAGENAME,		-1, TIF_ASCII,	FIELD_PAGENAME,
      "PageName" },
    { TIFFTAG_XPOSITION,	 1, TIF_RATIONAL,	FIELD_POSITION,
      "XPosition" },
    { TIFFTAG_YPOSITION,	 1, TIF_RATIONAL,	FIELD_POSITION,
      "YPosition" },
    { TIFFTAG_FREEOFFSETS,	-1, TIF_LONG,	(u_short)-1,
      "FreeOffsets" },
    { TIFFTAG_FREEBYTECOUNTS,	-1, TIF_LONG,	(u_short)-1,
      "FreeByteCounts" },
    { TIFFTAG_GRAYRESPONSEUNIT,	 1, TIF_SHORT,	FIELD_GRAYRESPONSEUNIT,
      "GrayResponseUnit" },
    { TIFFTAG_GRAYRESPONSECURVE,-1, TIF_SHORT,	FIELD_GRAYRESPONSECURVE,
      "GrayResponseCurve" },
    { TIFFTAG_GROUP3OPTIONS,	 1, TIF_LONG,	FIELD_GROUP3OPTIONS,
      "Group3Options" },
    { TIFFTAG_GROUP4OPTIONS,	 1, TIF_LONG,	FIELD_GROUP4OPTIONS,
      "Group4Options" },
    { TIFFTAG_RESOLUTIONUNIT,	 1, TIF_SHORT,	FIELD_RESOLUTIONUNIT,
      "ResolutionUnit" },
    { TIFFTAG_PAGENUMBER,	 2, TIF_SHORT,	FIELD_PAGENUMBER,
      "PageNumber" },
    { TIFFTAG_COLORRESPONSEUNIT, 1, TIF_SHORT,	FIELD_COLORRESPONSEUNIT,
      "ColorResponseUnit" },
    { TIFFTAG_COLORRESPONSECURVE,-1,TIF_SHORT,	FIELD_COLORRESPONSECURVE,
      "ColorResponseCurve" },
    { TIFFTAG_SOFTWARE,		-1, TIF_ASCII,	FIELD_SOFTWARE,
      "Software" },
    { TIFFTAG_DATETIME,		-1, TIF_ASCII,	FIELD_DATETIME,
      "DateTime" },
    { TIFFTAG_ARTIST,		-1, TIF_ASCII,	FIELD_ARTIST,
      "Artist" },
    { TIFFTAG_HOSTCOMPUTER,	-1, TIF_ASCII,	FIELD_HOSTCOMPUTER,
      "HostComputer" },
    { TIFFTAG_PREDICTOR,	 1, TIF_SHORT,	FIELD_PREDICTOR,
      "Predictor" },
    { TIFFTAG_WHITEPOINT,		-1, TIF_SHORT,	FIELD_WHITEPOINT,
      "WhitePoint" },
    { TIFFTAG_PRIMARYCHROMATICITIES,  	-1, TIF_BYTE,FIELD_PRIMARYCHROMATICITIES,
      "PrimaryChromaticities" },
    { TIFFTAG_COLORMAP,		-1, TIF_SHORT,	FIELD_COLORMAP,
      "ColorMap" },
/* begin nonstandard tags */
    { TIFFTAG_MATTEING,		 1, TIF_SHORT,	FIELD_MATTEING,
      "Matteing" },
#ifdef DESIGN_VER
	{ TIFFTAG_MODELPIXELSCALE, 3,	TIF_DOUBLE, FIELD_MODELPIXELSCALE,
	"ModelPixelScale" },
	{ TIFFTAG_MATRIX,		-1,	TIF_DOUBLE,	FIELD_MATRIX, "IntergraphMatrix" },
	{ TIFFTAG_MODELTIES,	-1,	TIF_DOUBLE, FIELD_MODELTIES, "ModelTiepoint" },
	{ TIFFTAG_MODELTRANS,	16,	TIF_DOUBLE,	FIELD_MODELTRANS, "ModelTransformation" },
	{ TIFFTAG_GEOKEYDIR,	-1, TIF_SHORT, FIELD_GEOKEYDIR, "GeoKeyDirectory" },
	{ TIFFTAG_GEODOUBLE,	-1, TIF_DOUBLE, FIELD_GEODOUBLE, "GeoDoubleParams" },
	{ TIFFTAG_GEOASCII,		-1, TIF_ASCII, FIELD_GEOASCII, "GeoAsciiParams" },
#endif
};
#define	NFIELDINFO	(sizeof (FieldInfo) / sizeof (FieldInfo[0]))

#define	IGNORE	0		/* tag placeholder used below */

/*short datawidth[] = { 1, 1, 1, 2, 4, 8, };*/

static TIFFFetchData(TIFF *tif,TIFFDirEntry *dir,char *cp);
static char *ncp = NULL;   /* Array allocated in TIFFReadDirectory */
static	double TIFFFetchRational(); 
static TIFFFieldInfo *FieldWithTag();

/*
 * If the system has it, just use fstat to get the file size.
 * Otherwise use lseek.
 */


static u_long TIFFGetFileSize(FILE *fd){
#ifdef MICROSOFT
	u_long curpos=0L;
	u_long filesize=(u_long)-1;
	curpos= ftell(fd);
	if (curpos != -1L) {
	    fseek(fd, 0L, SEEK_END);
		filesize = ftell(fd);
	    fseek(fd, curpos, SEEK_SET);
	}
	return(filesize);
#else
	struct stat sb;
	return (fstat(fd, &sb) == -1 ? 0 : sb.st_size);
#endif // MICROSOFT 
}


/*
 * Read the next TIFF directory from a file
 * and convert it to the internal format.
 * We read directories sequentially.
 */
int 
TIFFReadDirectory(TIFF *tif) {
	register TIFFDirEntry *dp;
	register int n;
	register TIFFDirectory *td = NULL;
	TIFFDirEntry *dir = NULL;
	long v;
	TIFFFieldInfo *fip;
	unsigned short dircount;
	u_short tag;
	int cc;

	tif->tif_diroff = tif->tif_nextdiroff;
	if (tif->tif_diroff == 0)		/* no more directories */
		return (0);
	if (!SeekOK(tif->tif_fd, tif->tif_diroff)) {

		TIFFError(tif->tif_name, "Seek error accessing TIFF directory");
		return (0);
	}
	if (!ReadOK(tif->tif_fd, &dircount, sizeof (short))) {
		TIFFError(tif->tif_name, "Can't read TIFF directory count");
		return (0);
	}
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabShort(&dircount);
	dir = (TIFFDirEntry *)alloc(dircount * sizeof (TIFFDirEntry));
	if (dir == NULL) {
		TIFFError(tif->tif_name, "No space to read TIFF directory");
		return (0);
	}
	if (!ReadOK(tif->tif_fd, dir, dircount * sizeof (TIFFDirEntry))) {
		TIFFError(tif->tif_name, "Can't read TIFF directory");
		goto bad;
	}
	/*
	 * Read offset to next directory for sequential scans.
	 */
	if (!ReadOK(tif->tif_fd, &tif->tif_nextdiroff, sizeof (long)))
		tif->tif_nextdiroff = 0;
	if (tif->tif_flags & TIFF_SWAB)
		TIFFSwabLong(&tif->tif_nextdiroff);

	tif->tif_flags &= ~TIFF_BEENWRITING;	/* reset before new dir */
	/*
	 * Setup default value and then make a pass over
	 * the fields to check type and tag information,
	 * and to extract info required to size data
	 * structures.  A second pass is made afterwards
	 * to read in everthing not taken in the first pass.
	 */
	td = &tif->tif_dir;
	if (tif->tif_diroff != tif->tif_header.tiff_diroff) {
		/* free any old stuff and reinit */
		TIFFFreeDirectory(tif);
		bzero((char *)td, sizeof (*td));
	}
	TIFFDefaultDirectory(tif);

	tag = 0;
	for (fip = FieldInfo, dp = dir, n = dircount; n > 0; n--, dp++) {
		if (tif->tif_flags & TIFF_SWAB) {
			TIFFSwabArrayOfShort(&dp->tdir_tag, 2);
			TIFFSwabArrayOfLong(&dp->tdir_count, 2);
		}
		/*
		 * For non-standard files that have out of order tags,
		 * print a warning, then reset the pointer so we try
		 * to parse it anyway.
		 */
#if 0		
		 printf(" TAG = %d (0x%X)\n",dp->tdir_tag,dp->tdir_tag);		
#endif

		if (dp->tdir_tag < tag)
		{
		    TIFFWarning(tif->tif_name,
		        "tag out of order, previous tag: %d (0x%x), new tag %d (0x%x)",
				tag, tag,
				dp->tdir_tag, dp->tdir_tag);
		    fip = FieldInfo;
		}
		tag = dp->tdir_tag; 
		/*
		 * Find the field information entry for this tag.
		 */
		while (fip < &FieldInfo[NFIELDINFO] &&
		    fip->field_tag < tag)
			fip++;
		if (fip >= &FieldInfo[NFIELDINFO] ||
		    fip->field_tag != tag) {
			/*	 Unknown field, should this be fatal? */
#if 0
			TIFFWarning(tif->tif_name,
			    "ignoring unknown field with tag %d (0x%x)",
				dp->tdir_tag, dp->tdir_tag);
#endif
			dp->tdir_tag = IGNORE;
			continue;
		}
		/*
		 * Null out old tags that we ignore.
		 */
		if (fip->field_bit == (u_short)-1) {
			dp->tdir_tag = IGNORE;
			continue;
		}
		/*
		 * Check data type. (now a warning, not an error)
		 */
		while ((TIFFDataType)dp->tdir_type != fip->field_type) {
			fip++;
			if (fip >= &FieldInfo[NFIELDINFO] ||
			    fip->field_tag != dp->tdir_tag) {
				TIFFWarning(tif->tif_name,
				    "Wrong data type %d for field \"%s\"",
				    dp->tdir_type, (--fip)->field_name);
			        dp->tdir_tag = IGNORE;
				break;
			}
		}

		switch (dp->tdir_tag) {
		case IGNORE:
			continue;
		case TIFFTAG_STRIPOFFSETS:
		case TIFFTAG_STRIPBYTECOUNTS:
			TIFFSetFieldBit(tif, fip->field_bit);
			break;
		case TIFFTAG_IMAGELENGTH:
		case TIFFTAG_PLANARCONFIG:
		case TIFFTAG_ROWSPERSTRIP:
		case TIFFTAG_SAMPLESPERPIXEL:
			if (!TIFFSetField(tif, dp->tdir_tag,
			  TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset)))
				goto bad;
			break;
		}
	}

	/*
	 * Allocate directory structure and setup defaults.
	 */
	if (!TIFFFieldSet(tif, FIELD_IMAGEDIMENSIONS)) {
		MissingRequired(tif, "ImageLength");
		goto bad;
	}
	/* some writters don't set PLANARCONFIG we will use default */
	if (!TIFFFieldSet(tif, FIELD_PLANARCONFIG)) {
	    TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
	    TIFFWarning(tif->tif_name,
	    "Required field PLANARCONFIG not present will use default");
	}
	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {
		MissingRequired(tif, "StripOffsets");
		goto bad;
	}
	/* some writters don't set ROWSPERSTRIP we will use default */
	if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP)) {
	    TIFFWarning(tif->tif_name,
	    "Required field ROWSPERSTRIP not present will use default");
	}
	td->td_stripsperimage = (td->td_rowsperstrip == 0xffffffff ?
	    1 : howmany(td->td_imagelength, td->td_rowsperstrip));
	td->td_nstrips = td->td_stripsperimage;
	if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
		td->td_nstrips *= td->td_samplesperpixel;

	/*
	 * Second pass: extract other information.
	 *
	 * Should do a better job of verifying values.
	 */
	for (dp = dir, n = dircount; n > 0; n--, dp++) {
		if (dp->tdir_tag == IGNORE)
			continue;
		if (dp->tdir_type == (short)TIF_ASCII) {
			if (dp->tdir_count > 0) {
				ncp = alloc(dp->tdir_count+1);
				if (ncp == NULL || !TIFFFetchData(tif, dp, ncp) ||
				    !TIFFSetField(tif, dp->tdir_tag, ncp))
					goto bad;
			}
			continue;
		}
		if (dp->tdir_type == (short)TIF_RATIONAL) {
			if (!TIFFSetField(tif, dp->tdir_tag,
			    TIFFFetchRational(tif, dp)))
				goto bad;
			continue;
		}
		switch (dp->tdir_tag) {
		case TIFFTAG_COMPRESSION:
			/*
			 * The 5.0 spec says the compression tag has
			 * one value, while earlier specs say it has
			 * one value per sample.  Because of this, we
			 * accept the tag if one value is supplied.
			 */
			if (dp->tdir_count == 1) {
				v = TIFFExtractData(tif,
				    dp->tdir_type, dp->tdir_offset);
				if (!TIFFSetField(tif, TIFFTAG_COMPRESSION, v))
					goto bad;
				break;
			}
			/* fall thru... */
		case TIFFTAG_MINSAMPLEVALUE:
		case TIFFTAG_MAXSAMPLEVALUE:
		case TIFFTAG_BITSPERSAMPLE:
			if (!TIFFFetchPerSampleShorts(tif, dp, &v) ||
			    !TIFFSetField(tif, dp->tdir_tag, v))
				goto bad;
			break;
		case TIFFTAG_STRIPOFFSETS:
		    /* some files assume wrong default ROWSPERSTRIP */
		    if ((td->td_nstrips != dp->tdir_count) &&
		        (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))) {
			td->td_nstrips = dp->tdir_count;
			td->td_stripsperimage = td->td_nstrips;
			if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
		            td->td_stripsperimage /= td->td_samplesperpixel;;
		        td->td_rowsperstrip = td->td_imagelength/td->td_stripsperimage;
		        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, td->td_rowsperstrip);
		        TIFFWarning(tif->tif_name,
		         "assuming ROWSPERSTRIP of %d",td->td_rowsperstrip);
		    }
		    if (!TIFFFetchStripThing(tif, dp,
		        td->td_nstrips, &td->td_stripoffset))
				goto bad;
		    TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
		    break;
		case TIFFTAG_STRIPBYTECOUNTS:
		    /* some files assume wrong default ROWSPERSTRIP */
		    if ((td->td_nstrips != dp->tdir_count) &&
		        (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))) {
			td->td_nstrips = dp->tdir_count;
			td->td_stripsperimage = td->td_nstrips;
			if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
		            td->td_stripsperimage /= td->td_samplesperpixel;;
		        td->td_rowsperstrip = td->td_imagelength/td->td_stripsperimage;
		        TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, td->td_rowsperstrip);
		        TIFFWarning(tif->tif_name,
		         "assuming ROWSPERSTRIP of %d",td->td_rowsperstrip);
		    }
		    if (!TIFFFetchStripThing(tif, dp,
		        td->td_nstrips, &td->td_stripbytecount))
			    goto bad;
		    TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);
		    break;
		case TIFFTAG_IMAGELENGTH:
		case TIFFTAG_ROWSPERSTRIP:
		case TIFFTAG_SAMPLESPERPIXEL:
		case TIFFTAG_PLANARCONFIG:
			/* handled in first pass above */
			break;
		case TIFFTAG_GRAYRESPONSECURVE:
		case TIFFTAG_COLORRESPONSECURVE:
		case TIFFTAG_COLORMAP:
			v = (1L<<td->td_bitspersample) * sizeof (u_short);
			ncp = alloc(dp->tdir_tag == TIFFTAG_GRAYRESPONSECURVE ? 
				v : 3*v);
			if (ncp == NULL)
				goto bad;
			if (!TIFFSetField(tif, dp->tdir_tag, ncp,ncp+v,ncp+2*v) ||
			    !TIFFFetchData(tif, dp, ncp))
				goto bad;
			break;
/* BEGIN REV 4.0 COMPATIBILITY */
		case TIFFTAG_OSUBFILETYPE:
			v = 0;
			switch (TIFFExtractData(tif, dp->tdir_type,
			    dp->tdir_offset)) {
			case OFILETYPE_REDUCEDIMAGE:
				v = FILETYPE_REDUCEDIMAGE;
				break;
			case OFILETYPE_PAGE:
				v = FILETYPE_PAGE;
				break;
			}
			if (!TIFFSetField(tif, dp->tdir_tag, v))
				goto bad;
			break;
/* END REV 4.0 COMPATIBILITY */
#ifdef DESIGN_VER
		case TIFFTAG_GEOKEYDIR:
			ncp = alloc(2*dp->tdir_count);
			if (!TIFFFetchData(tif, dp, ncp) ||
				!TIFFSetField(tif, dp->tdir_tag, ncp))
				goto bad;
			break;
		case TIFFTAG_MODELPIXELSCALE:
		case TIFFTAG_MODELTRANS:
		case TIFFTAG_MATRIX:
		case TIFFTAG_GEODOUBLE:
			ncp = alloc(8*dp->tdir_count);
			if (!TIFFFetchData(tif, dp, ncp) ||
				!TIFFSetField(tif, dp->tdir_tag, ncp))
				goto bad;
			break;
		case TIFFTAG_MODELTIES:
			ncp = alloc(8*dp->tdir_count);
			if (!TIFFFetchData(tif, dp, ncp) ||
				!TIFFSetField(tif, dp->tdir_tag, dp->tdir_count, ncp))
				goto bad;
			break;
#endif
		default:
			if (!TIFFSetField(tif, dp->tdir_tag,
			  TIFFExtractData(tif, dp->tdir_type, dp->tdir_offset)))
				goto bad;
			break;
		}
	}
	if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
		u_long file_size;
		u_long space;
		/*
		 * Some manufacturers violate the spec by not giving
		 * the size of the strips.  In this case, assume there
		 * is one uncompressed strip of data.
		 */
		if (td->td_nstrips > 1) {
			MissingRequired(tif, "StripByteCounts");
			goto bad;
		}
		TIFFWarning(tif->tif_name,
"TIFF directory is missing required \"%s\" field, calculating from imagelength",
		    FieldWithTag(TIFFTAG_STRIPBYTECOUNTS)->field_name);

		file_size = TIFFGetFileSize(tif->tif_fd);
		td->td_stripbytecount = (u_long *)alloc(sizeof (u_long));
		space = sizeof (TIFFHeader)
		    + sizeof (short)
		    + (dircount * sizeof (TIFFDirEntry))
		    + sizeof (long);
		/* calculate amount of space used by indirect values */
		for (dp = dir, n = dircount; n > 0; n--, dp++) {
                        switch(dp->tdir_type) {
                          case 0:
                          case 1:
                          case 2: cc = dp->tdir_count * 1;
				  break;
                          case 3: cc = dp->tdir_count * 2;
				  break;
                          case 4: cc = dp->tdir_count * 4;
				  break;
                          case 5: cc = dp->tdir_count * 8;
				  break;
                        }
/*			int cc = dp->tdir_count * datawidth[dp->tdir_type];*/
			if (cc > sizeof (long))
				space += cc;
		}

		if (TIFFFieldSet(tif, FIELD_STRIPOFFSETS))
			td->td_stripbytecount[0] = file_size - td->td_stripoffset[0];
		else 
			td->td_stripbytecount[0] = file_size - space;

		TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);
		if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))
			td->td_rowsperstrip = td->td_imagelength;
	}
	if (dir) 
	    free((char *)dir);
	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
		td->td_maxsamplevalue = (1L<<td->td_bitspersample)-1;
	/*
	 * Setup default compression scheme.
	 */
	return (!TIFFFieldSet(tif, FIELD_COMPRESSION) ?
	    TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE) : 1);
bad:
	if (dir)
            free((char *)dir);

	return (0);
}

static void
MissingRequired(tif, tagname)
	TIFF *tif;
	char *tagname;
{

	TIFFError(tif->tif_name,
	    "TIFF directory  missing \"%s\" field", tagname);
}

/*
 * Fetch a contiguous directory item.
 */
static
TIFFFetchData(TIFF *tif,TIFFDirEntry *dir,char *cp) {
	int cc, w;

   switch(dir->tdir_type) {
		case 0:
		case 1:
		case 2: w = 1;
			  break;
		case 3: w = 2;
			break;
		case 4: w = 4;
			break;
#ifdef DESIGN_VER
		case 12:
#endif
		case 5: w = 8;
			break;
		}
	/*w = datawidth[dir->tdir_type];*/
	cc = dir->tdir_count * w;
	if (SeekOK(tif->tif_fd, dir->tdir_offset) &&
	    ReadOK(tif->tif_fd, cp, cc)) {
		if (tif->tif_flags & TIFF_SWAB) {
			switch (dir->tdir_type) {
			case TIF_SHORT:
				TIFFSwabArrayOfShort((short *)cp, dir->tdir_count);     // KINETIX:  added cast to short *
				break;
			case TIF_LONG:
				TIFFSwabArrayOfLong((long *)cp, dir->tdir_count);       // KINETIX:  added cast to long *
				break;
			case TIF_RATIONAL:
				TIFFSwabArrayOfLong((long *)cp, 2*dir->tdir_count);     // KINETIX:  added cast to long *
				break;
			}
			}
		return (cc);
		}
	TIFFError(tif->tif_name, "Error fetching data for field \"%s\"",
	    FieldWithTag(dir->tdir_tag)->field_name);
	return (0);
	}

/*
 * Fetch a rational item from the file
 * at offset off.  We return the value
 * as floating point number.
 */
static double
TIFFFetchRational(tif, dir)
	TIFF *tif;
	TIFFDirEntry *dir;
{
	long l[2];

	if (!TIFFFetchData(tif, dir, (char *)l))
		return (1.);
	if (l[1] == 0) {
		TIFFError(tif->tif_name, "%s: Rational with zero denominator",
		    FieldWithTag(dir->tdir_tag)->field_name);
		return (1.);
	}
	return ((double)l[0] / (double)l[1]);
}

static
TIFFFetchPerSampleShorts(tif, dir, pl)
	TIFF *tif;
	TIFFDirEntry *dir;
	long *pl;
{
	u_short v[4];
	unsigned int i;     // KINETIX: changed type to from merely int

	switch (dir->tdir_count) {
	case 1:
		*pl = TIFFExtractData(tif, dir->tdir_type, dir->tdir_offset);
		return (1);		/* XXX should check samplesperpixel */
	case 2:
		if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
			v[0] = (u_short)dir->tdir_offset >> 16;
			v[1] = (u_short)dir->tdir_offset & 0xffff;
		} else {
			v[0] = (u_short)dir->tdir_offset & 0xffff;
			v[1] = (u_short)dir->tdir_offset >> 16;
		}
		break;
	default:
		if (!TIFFFetchData(tif, dir, (char *)v))
			return (0);
		break;
	}
	if (tif->tif_dir.td_samplesperpixel != dir->tdir_count) {
		TIFFError(tif->tif_name, "Incorrect count %d for field \"%s\"",
		    dir->tdir_count, FieldWithTag(dir->tdir_tag)->field_name);
		return (0);
	}
	for (i = 1; i < dir->tdir_count; i++)
		if (v[i] != v[0]) {
			TIFFError(tif->tif_name,
	"Cannot handle different per-sample values for field \"%s\"",
			     FieldWithTag(dir->tdir_tag)->field_name);
			return (0);
		}
	*pl = v[0];
	return (1);
}

static
TIFFFetchStripThing(tif, dir, nstrips, lpp)
	TIFF *tif;
	TIFFDirEntry *dir;
	u_long nstrips;
	u_long **lpp;
{
        char *dp;
	register u_long *lp;
	int status;

	if (nstrips != dir->tdir_count) {
		TIFFWarning(tif->tif_name,
		    "Count mismatch for field \"%s\"; expecting %d, got %d",
		    FieldWithTag(dir->tdir_tag)->field_name, nstrips,
		    dir->tdir_count);
		nstrips = dir->tdir_count;
		}
	/*
	 * Allocate space for strip information.
	 */
	if (*lpp == NULL &&
	    (*lpp = (u_long *)alloc(nstrips * sizeof (u_long))) == NULL) {
		TIFFError(tif->tif_name, "No space for \"%s\" array",
		    FieldWithTag(dir->tdir_tag)->field_name);
		return (0);
		}
	lp = *lpp;
	status = 1;
	if (dir->tdir_type == (int)TIF_SHORT) {
		/*
		 * Handle short->long expansion.
		 */
		if (dir->tdir_count > 2) {
			switch((int)TIF_SHORT) {
				case 0:
				case 1:
				case 2: dp = (char *)alloc(dir->tdir_count * 1);
					break;
				case 3: dp = (char *)alloc(dir->tdir_count * 2);
					break;
				case 4: dp = (char *)alloc(dir->tdir_count * 4);
					break;
				case 5: dp = (char *)alloc(dir->tdir_count * 8);
					break;
				}
			/*char *dp =  alloc(dir->tdir_count * datawidth[(int)TIF_SHORT]);*/
			if (dp == NULL) {
				TIFFError(tif->tif_name,
				    "No memory to fetch field \"%s\"",
				    FieldWithTag(dir->tdir_tag)->field_name);
				return (0);
				}
			if (status = TIFFFetchData(tif, dir, dp)) {
				register u_short *wp = (u_short *)dp;
				while (nstrips-- > 0)
					*lp++ = *wp++;
			}
			free(dp);
		} else {
			/*
			 * Extract data from offset field.
			 */
			if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
				*lp++ = dir->tdir_offset >> 16;
				*lp = dir->tdir_offset & 0xffff;
			} else {
				*lp++ = dir->tdir_offset & 0xffff;
				*lp = dir->tdir_offset >> 16;
			}
		}
	} else {
		if (dir->tdir_count > 1)
			status = TIFFFetchData(tif, dir, (char *)lp);
		else
			*lp = dir->tdir_offset;
	}
	return (status);
}

static TIFFFieldInfo *
FieldWithTag(tag)
	u_short tag;
{
	register TIFFFieldInfo *fip;

	for (fip = FieldInfo; fip < &FieldInfo[NFIELDINFO]; fip++)
		if (fip->field_tag == tag)
			return (fip);
	TIFFError("FieldWithTag", "Internal error, unknown tag 0x%x", tag);
	return NULL;
}

void
TIFFFreeDirectory(tif)
	TIFF *tif;
{
	register TIFFDirectory *td = &tif->tif_dir;

	if (TIFFFieldSet(tif, FIELD_GRAYRESPONSECURVE))
		free((char *)td->td_grayresponsecurve);
	if (TIFFFieldSet(tif, FIELD_COLORRESPONSECURVE)) {
		free((char *)td->td_redresponsecurve);
		/* free((char *)td->td_blueresponsecurve); */
		/* free((char *)td->td_greenresponsecurve); */
	}
	if (TIFFFieldSet(tif, FIELD_COLORMAP)) {
		if ((unsigned short)tif->tif_mode == (O_RDONLY | O_BINARY))
		free((char *)td->td_redcolormap);
		/* free((char *)td->td_bluecolormap); */
		/* free((char *)td->td_greencolormap); */
	}
#ifdef notdef
	/* can't free -- user supplied strings may be static */
	if (TIFFFieldSet(tif, FIELD_DOCUMENTNAME))
		free(td->td_documentname);
	if (TIFFFieldSet(tif, FIELD_ARTIST))
		free(td->td_artist);
	if (TIFFFieldSet(tif, FIELD_DATETIME))
		free(td->td_datetime);
	if (TIFFFieldSet(tif, FIELD_HOSTCOMPUTER))
		free(td->td_hostcomputer);
	if (TIFFFieldSet(tif, FIELD_IMAGEDESCRIPTION))
		free(td->td_imagedescription);
	if (TIFFFieldSet(tif, FIELD_MAKE))
		free(td->td_make);
	if (TIFFFieldSet(tif, FIELD_MODEL))
		free(td->td_model);
	if (TIFFFieldSet(tif, FIELD_SOFTWARE))
		free(td->td_software);
	if (TIFFFieldSet(tif, FIELD_PAGENAME))
		free(td->td_pagename);
#endif
	if  (td->td_stripoffset)
		free((char *)td->td_stripoffset);
	if  (td->td_stripbytecount)
		free((char *)td->td_stripbytecount);
#if 0
   if (ncp != NULL) {
     free(ncp);
     ncp = NULL;
     }
#endif
}

/*
 * Setup a default directory structure.
 */
TIFFDefaultDirectory(tif)
	TIFF *tif;
{
	register TIFFDirectory *td = &tif->tif_dir;

	td->td_bitspersample = 1;
	td->td_threshholding = THRESHHOLD_BILEVEL;
	td->td_orientation = ORIENTATION_TOPLEFT;
	td->td_samplesperpixel = 1;
	td->td_predictor = 1;
	td->td_rowsperstrip = 0xfffffff;
	td->td_grayresponseunit = GRAYRESPONSEUNIT_100S;
	td->td_resolutionunit = RESUNIT_INCH;
	td->td_colorresponseunit = COLORRESPONSEUNIT_100S;
	return (TIFFSetField(tif, TIFFTAG_COMPRESSION, COMPRESSION_NONE));
}


#ifdef KINETIX_TIFF_CHANGES
    extern TIFFSetCompressionScheme (TIFF *tif, int scheme);
#endif
/*
 * Record the value of a field in the
 * internal directory structure.  The
 * field will be written to the file
 * when/if the directory structure is
 * updated.
 */
/*VARARGS2*/
#ifdef __STDC__
#ifdef __MACH__		/* NeXT really */
TIFFSetField(TIFF *tif, int tag, ...)
#else
TIFFSetField(TIFF *tif, u_short tag, ...)
#endif /* __MACH__ */
#else
TIFFSetField(tif, tag, va_alist)
	TIFF *tif;
	u_short tag;
	va_dcl
#endif
{
	static char module[] = "TIFFSetField";
	TIFFDirectory *td = &tif->tif_dir;
	va_list ap;
	long v;
	int field = -1, status = 1;

	if (tag != TIFFTAG_IMAGELENGTH && (tif->tif_flags & TIFF_BEENWRITING)) {
		TIFFError(module,
		    "%s: Cannot change TIFF directory while writing",
		    tif->tif_name);
		return (0);
	}
#ifdef __STDC__
	va_start(ap, tag);
#else
	va_start(ap);
#endif
	switch (tag) {
	case TIFFTAG_SUBFILETYPE:
		td->td_subfiletype = (u_short)va_arg(ap, long);
		field = FIELD_SUBFILETYPE;
		break;
	case TIFFTAG_IMAGEWIDTH:
		td->td_imagewidth = va_arg(ap, int);
		field = FIELD_IMAGEDIMENSIONS;
		break;
	case TIFFTAG_IMAGELENGTH:
		td->td_imagelength = va_arg(ap, int);
		field = FIELD_IMAGEDIMENSIONS;
		break;
	case TIFFTAG_BITSPERSAMPLE:
		td->td_bitspersample = va_arg(ap, int);
		field = FIELD_BITSPERSAMPLE;
		break;
	case TIFFTAG_COMPRESSION:
		v = va_arg(ap, int) & 0xffff;
		/*
		 * If we're changing the compression scheme,
		 * the notify the previous module so that it
		 * can cleanup any state it's setup.
		 */
		if (TIFFFieldSet(tif, FIELD_COMPRESSION)) {
			if (td->td_compression == v)
				break;
			if (tif->tif_cleanup)
				(*tif->tif_cleanup)(tif);
		}
		/*
		 * Setup new compression routine state.
		 */
		if (status = TIFFSetCompressionScheme(tif, v)) {
			td->td_compression = (u_short)v;
			field = FIELD_COMPRESSION;
		}
		break;
	case TIFFTAG_PHOTOMETRIC:
		td->td_photometric = va_arg(ap, int);
		field = FIELD_PHOTOMETRIC;
		break;
	case TIFFTAG_THRESHHOLDING:
		td->td_threshholding = va_arg(ap, int);
		field = FIELD_THRESHHOLDING;
		break;
	case TIFFTAG_DOCUMENTNAME:
		td->td_documentname = va_arg(ap, char *);
		field = FIELD_DOCUMENTNAME;
		break;
	case TIFFTAG_ARTIST:
		td->td_artist = va_arg(ap, char *);
		field = FIELD_ARTIST;
		break;
	case TIFFTAG_DATETIME:
		td->td_datetime = va_arg(ap, char *);
		field = FIELD_DATETIME;
		break;
	case TIFFTAG_HOSTCOMPUTER:
		td->td_hostcomputer = va_arg(ap, char *);
		field = FIELD_HOSTCOMPUTER;
		break;
	case TIFFTAG_IMAGEDESCRIPTION:
		td->td_imagedescription = va_arg(ap, char *);
		field = FIELD_IMAGEDESCRIPTION;
		break;
	case TIFFTAG_MAKE:
		td->td_make = va_arg(ap, char *);
		field = FIELD_MAKE;
		break;
	case TIFFTAG_MODEL:
		td->td_model = va_arg(ap, char *);
		field = FIELD_MODEL;
		break;
	case TIFFTAG_SOFTWARE:
		td->td_software = va_arg(ap, char *);
		field = FIELD_SOFTWARE;
		break;
	case TIFFTAG_ORIENTATION:
		td->td_orientation = va_arg(ap, int);
		field = FIELD_ORIENTATION;
		break;
	case TIFFTAG_SAMPLESPERPIXEL:
		v = va_arg(ap, int);
		if (v == 0)
			goto badvalue;
		if (v > 4) {
			TIFFError(tif->tif_name,
			    "Cannot handle %d-channel data", v); 
			goto bad;
		}
		td->td_samplesperpixel = (u_short)v;
		field = FIELD_SAMPLESPERPIXEL;
		break;
	case TIFFTAG_ROWSPERSTRIP:
		v = va_arg(ap, long);
		if (v == 0)
			goto badvalue;
		td->td_rowsperstrip = v;
		field = FIELD_ROWSPERSTRIP;
		break;
	case TIFFTAG_MINSAMPLEVALUE:
		td->td_minsamplevalue = va_arg(ap, int) & 0xffff;
		field = FIELD_MINSAMPLEVALUE;
		break;
	case TIFFTAG_MAXSAMPLEVALUE:
		td->td_maxsamplevalue = va_arg(ap, int) & 0xffff;
		field = FIELD_MAXSAMPLEVALUE;
		break;
	case TIFFTAG_XRESOLUTION:
		td->td_xresolution = (float)va_arg(ap, VA_FLOAT_PARAM_TYPE);
		field = FIELD_RESOLUTION;
		break;
	case TIFFTAG_YRESOLUTION:
		td->td_yresolution = (float)va_arg(ap, VA_FLOAT_PARAM_TYPE);
		field = FIELD_RESOLUTION;
		break;
	case TIFFTAG_PLANARCONFIG:
		v = va_arg(ap, int);
		td->td_planarconfig = (u_short)v;
		field = FIELD_PLANARCONFIG;
		break;
	case TIFFTAG_PAGENAME:
		td->td_pagename = va_arg(ap, char *);
		field = FIELD_PAGENAME;
		break;
	case TIFFTAG_XPOSITION:
		td->td_xposition = (float)va_arg(ap, VA_FLOAT_PARAM_TYPE);
		field = FIELD_POSITION;
		break;
	case TIFFTAG_YPOSITION:
		td->td_yposition = (float)va_arg(ap, VA_FLOAT_PARAM_TYPE);
		field = FIELD_POSITION;
		break;
	case TIFFTAG_GRAYRESPONSEUNIT:
		td->td_grayresponseunit = va_arg(ap, int);
		field = FIELD_GRAYRESPONSEUNIT;
		break;
	case TIFFTAG_GRAYRESPONSECURVE:
		td->td_grayresponsecurve = va_arg(ap, u_short *);
		field = FIELD_GRAYRESPONSECURVE;
		break;
	case TIFFTAG_GROUP3OPTIONS:
		td->td_group3options = va_arg(ap, long);
		field = FIELD_GROUP3OPTIONS;
		break;
	case TIFFTAG_GROUP4OPTIONS:
		td->td_group4options = va_arg(ap, long);
		field = FIELD_GROUP4OPTIONS;
		break;
	case TIFFTAG_RESOLUTIONUNIT:
		td->td_resolutionunit = va_arg(ap, int);
		field = FIELD_RESOLUTIONUNIT;
		break;
	case TIFFTAG_PAGENUMBER:
		td->td_pagenumber = va_arg(ap, int);
		field = FIELD_PAGENUMBER;
		break;
	case TIFFTAG_COLORRESPONSEUNIT:
		td->td_colorresponseunit = va_arg(ap, int);
		field = FIELD_COLORRESPONSEUNIT;
		break;
	case TIFFTAG_COLORRESPONSECURVE:
		td->td_redresponsecurve = va_arg(ap, u_short *);
		td->td_greenresponsecurve = va_arg(ap, u_short *);
		td->td_blueresponsecurve = va_arg(ap, u_short *);
		field = FIELD_COLORRESPONSECURVE;
		break;
	case TIFFTAG_COLORMAP:
		td->td_redcolormap = va_arg(ap, u_short *);
		td->td_greencolormap = va_arg(ap, u_short *);
		td->td_bluecolormap = va_arg(ap, u_short *);
		field = FIELD_COLORMAP;
		break;
	case TIFFTAG_PREDICTOR:
		td->td_predictor = va_arg(ap, int);
		field = FIELD_PREDICTOR;
		break;
	case TIFFTAG_MATTEING:
		td->td_matteing = va_arg(ap, int);
		field = FIELD_MATTEING;
		break;
#ifdef DESIGN_VER
	case TIFFTAG_MODELPIXELSCALE:
		td->td_modpixelscale = va_arg(ap, double *);
		field = FIELD_MODELPIXELSCALE;
		break;
	case TIFFTAG_MODELTRANS:
		td->td_modtrans = va_arg(ap, double *);
		field = FIELD_MODELTRANS;
		break;
	case TIFFTAG_MATRIX:
		td->td_matrix = va_arg(ap, double *);
		field = FIELD_MATRIX;
		break;
	case TIFFTAG_MODELTIES:
		td->td_modtiescount = va_arg(ap, u_short);
		td->td_modties = va_arg(ap, double *);
		field = FIELD_MODELTIES;
		break;
	case TIFFTAG_GEOKEYDIR:
		td->td_geokeydir = va_arg(ap, u_short *);
		field = FIELD_GEOKEYDIR;
		break;
	case TIFFTAG_GEODOUBLE:
		td->td_geodouble = va_arg(ap, double *);
		field = FIELD_GEODOUBLE;
		break;
	case TIFFTAG_GEOASCII:
		td->td_geoascii = va_arg(ap, char *);
		field = FIELD_GEOASCII;
		break;
#endif
	}
	if (field >= 0) {
		TIFFSetFieldBit(tif, field);
		tif->tif_flags |= TIFF_DIRTYDIRECT;
	}
	va_end(ap);
	return (status);
badvalue:
	TIFFError(tif->tif_name, "%d: Bad value for \"%s\"", v,
	    FieldWithTag(tag)->field_name);
bad:
	va_end(ap);
	return (0);
}

/*
 * Return the value of a field in the
 * internal directory structure.
 */
#ifdef __STDC__
#ifdef __MACH__		/* NeXT really */
TIFFGetField(TIFF *tif, int tag, ...)
#else
TIFFGetField(TIFF *tif, u_short tag, ...)
#endif /* __MACH__ */
#else
TIFFGetField(tif, tag, va_alist)
	TIFF *tif;
	u_short tag;
	va_dcl
#endif
{
	register TIFFFieldInfo *fip;
	TIFFDirectory *td = &tif->tif_dir;
	va_list ap;

	for (fip = FieldInfo; fip < &FieldInfo[NFIELDINFO]; fip++)
		if (fip->field_tag == tag)
			break;
	if (fip >= &FieldInfo[NFIELDINFO]) {
		TIFFError("TIFFGetField", "Unknown field, tag 0x%x", tag);
		return (0);
	}
	if (TIFFFieldSet(tif, fip->field_bit)) {
#ifdef __STDC__
		va_start(ap, tag);
#else
		va_start(ap);
#endif
		(void) TIFFGetField1(td, tag, ap);
		va_end(ap);
		return (1);
	}
	return (0);
}

static void 
TIFFGetField1(td, tag, ap)
	TIFFDirectory *td;
	u_short tag;
	va_list ap;
{

	switch (tag) {
	case TIFFTAG_SUBFILETYPE:
		*va_arg(ap, u_long *) = td->td_subfiletype;
		break;
	case TIFFTAG_IMAGEWIDTH:
		*va_arg(ap, u_short *) = td->td_imagewidth;
		break;
	case TIFFTAG_IMAGELENGTH:
		*va_arg(ap, u_short *) = td->td_imagelength;
		break;
	case TIFFTAG_BITSPERSAMPLE:
		*va_arg(ap, u_short *) = td->td_bitspersample;
		break;
	case TIFFTAG_COMPRESSION:
		*va_arg(ap, u_short *) = td->td_compression;
		break;
	case TIFFTAG_PHOTOMETRIC:
		*va_arg(ap, u_short *) = td->td_photometric;
		break;
	case TIFFTAG_THRESHHOLDING:
		*va_arg(ap, u_short *) = td->td_threshholding;
		break;
	case TIFFTAG_DOCUMENTNAME:
		*va_arg(ap, char **) = td->td_documentname;
		break;
	case TIFFTAG_ARTIST:
		*va_arg(ap, char **) = td->td_artist;
		break;
	case TIFFTAG_DATETIME:
		*va_arg(ap, char **) = td->td_datetime;
		break;
	case TIFFTAG_HOSTCOMPUTER:
		*va_arg(ap, char **) = td->td_hostcomputer;
		break;
	case TIFFTAG_IMAGEDESCRIPTION:
		*va_arg(ap, char **) = td->td_imagedescription;
		break;
	case TIFFTAG_MAKE:
		*va_arg(ap, char **) = td->td_make;
		break;
	case TIFFTAG_MODEL:
		*va_arg(ap, char **) = td->td_model;
		break;
	case TIFFTAG_SOFTWARE:
		*va_arg(ap, char **) = td->td_software;
		break;
	case TIFFTAG_ORIENTATION:
		*va_arg(ap, u_short *) = td->td_orientation;
		break;
	case TIFFTAG_SAMPLESPERPIXEL:
		*va_arg(ap, u_short *) = td->td_samplesperpixel;
		break;
	case TIFFTAG_ROWSPERSTRIP:
		*va_arg(ap, u_long *) = td->td_rowsperstrip;
		break;
	case TIFFTAG_MINSAMPLEVALUE:
		*va_arg(ap, u_short *) = (u_short)td->td_minsamplevalue;    // KINETIX: supplied cast (what should it really be?)
		break;
	case TIFFTAG_MAXSAMPLEVALUE:
		*va_arg(ap, u_short *) = (u_short)td->td_maxsamplevalue;    // KINETIX: supplied cast (what should it really be?)
		break;
	case TIFFTAG_XRESOLUTION:
		*va_arg(ap, float *) = td->td_xresolution;
		break;
	case TIFFTAG_YRESOLUTION:
		*va_arg(ap, float *) = td->td_yresolution;
		break;
	case TIFFTAG_PLANARCONFIG:
		*va_arg(ap, u_short *) = td->td_planarconfig;
		break;
	case TIFFTAG_XPOSITION:
		*va_arg(ap, float *) = td->td_xposition;
		break;
	case TIFFTAG_YPOSITION:
		*va_arg(ap, float *) = td->td_yposition;
		break;
	case TIFFTAG_PAGENAME:
		*va_arg(ap, char **) = td->td_pagename;
		break;
	case TIFFTAG_GRAYRESPONSEUNIT:
		*va_arg(ap, u_short *) = td->td_grayresponseunit;
		break;
	case TIFFTAG_GRAYRESPONSECURVE:
		*va_arg(ap, u_short **) = td->td_grayresponsecurve;
		break;
	case TIFFTAG_GROUP3OPTIONS:
		*va_arg(ap, u_long *) = td->td_group3options;
		break;
	case TIFFTAG_GROUP4OPTIONS:
		*va_arg(ap, u_long *) = td->td_group4options;
		break;
	case TIFFTAG_RESOLUTIONUNIT:
		*va_arg(ap, u_short *) = td->td_resolutionunit;
		break;
	case TIFFTAG_PAGENUMBER:
		*va_arg(ap, u_long *) = td->td_pagenumber;
		break;
	case TIFFTAG_COLORRESPONSEUNIT:
		*va_arg(ap, u_short *) = td->td_colorresponseunit;
		break;
	case TIFFTAG_COLORRESPONSECURVE:
		*va_arg(ap, u_short **) = td->td_redresponsecurve;
		*va_arg(ap, u_short **) = td->td_greenresponsecurve;
		*va_arg(ap, u_short **) = td->td_blueresponsecurve;
		break;
	case TIFFTAG_COLORMAP:
		*va_arg(ap, u_short **) = td->td_redcolormap;
		*va_arg(ap, u_short **) = td->td_greencolormap;
		*va_arg(ap, u_short **) = td->td_bluecolormap;
		break;
	case TIFFTAG_PREDICTOR:
		*va_arg(ap, u_short *) = td->td_predictor;
		break;
	case TIFFTAG_STRIPOFFSETS:
		*va_arg(ap, u_long **) = td->td_stripoffset;
		break;
	case TIFFTAG_STRIPBYTECOUNTS:
		*va_arg(ap, u_long **) = td->td_stripbytecount;
		break;
	case TIFFTAG_MATTEING:
		*va_arg(ap, u_short *) = td->td_matteing;
		break;
	}
	va_end(ap);
}

/*
 * Internal interface to TIFFGetField...
 */
static
#ifdef __STDC__
TIFFgetfield(TIFFDirectory *td, u_short tag, ...)
#else
TIFFgetfield(td, tag, va_alist)
	TIFFDirectory *td;
	u_short tag;
	va_dcl
#endif
{
	va_list ap;

#ifdef __STDC__
	va_start(ap, tag);
#else
	va_start(ap);
#endif
	(void) TIFFGetField1(td, tag, ap);
	va_end(ap);
#ifdef KINETIX_TIFF_CHANGES
    return 1;   // arbitrary, but int function must return a value
#endif
}

/* shorthands for setting up and writing directory... */
#define	MakeShortDirent(tag, v) \
	dir->tdir_tag = tag; \
	dir->tdir_type = (short)TIF_SHORT; \
	dir->tdir_count = 1; \
	dir->tdir_offset = TIFFInsertData(tif, (int)TIF_SHORT, v); \
	dir++
#define	WriteRationalPair(tag1, v1, tag2, v2) \
	(TIFFWriteRational(tif, tag1, dir++, v1) && \
	 TIFFWriteRational(tif, tag2, dir++, v2))

static	long dataoff;

#ifdef DOWRITE
/*
 * Write the contents of the current directory
 * to the specified file.  This routine doesn't
 * handle overwriting a directory with auxiliary
 * storage that's been changed.
 */
TIFFWriteDirectory(TIFF *tif) {
	short dircount, v;
	int nfields, dirsize;
	char *data, *cp;
	TIFFFieldInfo *fip;
	TIFFDirEntry *dir;
	TIFFDirectory *td;
	u_long b, off, fields[sizeof (td->td_fieldsset) / sizeof (u_long)];

	if (tif->tif_mode == O_RDONLY)
		return (1);
	td = &tif->tif_dir;
	/*
	 * Size the directory so that we can calculate
	 * offsets for the data items that aren't kept
	 * in-place in each field.
	 */
	nfields = 0;
	for (b = 0; b <= FIELD_LAST; b++)
		if (TIFFFieldSet(tif, b))
			nfields += (b < FIELD_SUBFILETYPE ? 2 : 1);
	dirsize = nfields * sizeof (TIFFDirEntry);
	data = alloc(dirsize);
	if (data == NULL) {
		TIFFError(tif->tif_name,
		    "Cannot write directory, out of space");
		return (0);
	}
	/*
	 * Directory hasn't been placed yet, put
	 * it at the end of the file and link it
	 * into the existing directory structure.
	 */
	if (tif->tif_diroff == 0 && !TIFFLinkDirectory(tif))
		return (0);
	dataoff = tif->tif_diroff + sizeof (short) + dirsize + sizeof (long);
	if (dataoff & 1)
		dataoff++;
	(void) myseek(tif->tif_fd, dataoff, L_SET);
	dir = (TIFFDirEntry *)data;
	/*
	 * Setup external form of directory
	 * entries and write data items.
	 */
	bcopy(td->td_fieldsset, fields, sizeof (fields));
	for (fip = FieldInfo; fip < &FieldInfo[NFIELDINFO]; fip++) {
		if (fip->field_bit == (u_short)-1 ||
		    !FieldSet(fields, fip->field_bit))
			continue;
		if (fip->field_type == TIF_ASCII) {
			TIFFgetfield(td, fip->field_tag, &cp);
			dir->tdir_tag = fip->field_tag;
			dir->tdir_type = (short)TIF_ASCII;
			dir->tdir_count = strlen(cp) + 1;
			if (!TIFFWriteData(tif, dir++, cp))
				goto bad;
			ResetFieldBit(fields, fip->field_bit);
			continue;
		}
		switch (fip->field_bit) {
		case FIELD_STRIPOFFSETS:
		case FIELD_STRIPBYTECOUNTS:
			if (!TIFFWriteStripThing(tif,
			    fip->field_tag, dir++,
			    fip->field_bit == FIELD_STRIPOFFSETS ?
			      td->td_stripoffset : td->td_stripbytecount))
				goto bad;
			break;
		case FIELD_GRAYRESPONSECURVE:
			dir->tdir_tag = fip->field_tag;
			dir->tdir_type = (short)TIF_SHORT;
			dir->tdir_count = 1L<<td->td_bitspersample;
			if (!TIFFWriteData(tif, dir++,td->td_grayresponsecurve))
				goto bad;
			break;
		case FIELD_COLORRESPONSECURVE:
		case FIELD_COLORMAP:
			dir->tdir_tag = fip->field_tag;
			dir->tdir_type = (short)TIF_SHORT;
			/* XXX -- yech, fool TIFFWriteData */
			dir->tdir_count = 1L<<td->td_bitspersample;
			off = dataoff;
#define	WRITE(x)	TIFFWriteData(tif, dir, x)
			if (fip->field_tag == TIFFTAG_COLORMAP) {
				if (!WRITE(td->td_redcolormap) ||
				    !WRITE(td->td_greencolormap) ||
				    !WRITE(td->td_bluecolormap))
					goto bad;
			} else {
				if (!WRITE(td->td_redresponsecurve) ||
				    !WRITE(td->td_greenresponsecurve) ||
				    !WRITE(td->td_blueresponsecurve))
					goto bad;
			}
#undef WRITE
			dir->tdir_count *= 3;
			dir->tdir_offset = off;
			break;
		case FIELD_IMAGEDIMENSIONS:
			MakeShortDirent(TIFFTAG_IMAGEWIDTH, td->td_imagewidth);
			MakeShortDirent(TIFFTAG_IMAGELENGTH,td->td_imagelength);
			break;
		case FIELD_POSITION:
			if (!WriteRationalPair(
			    TIFFTAG_XPOSITION, td->td_xposition,
			    TIFFTAG_YPOSITION, td->td_yposition))
				goto bad;
			break;
		case FIELD_RESOLUTION:
			if (!WriteRationalPair(
			    TIFFTAG_XRESOLUTION, td->td_xresolution,
			    TIFFTAG_YRESOLUTION, td->td_yresolution))
				goto bad;
			break;
		case FIELD_BITSPERSAMPLE:
		case FIELD_MINSAMPLEVALUE:
		case FIELD_MAXSAMPLEVALUE:
			TIFFgetfield(td, fip->field_tag, &v);
			if (!TIFFWritePerSampleShorts(tif, fip->field_tag,
			    dir++, v))
				goto bad;
			break;
		default:
			dir->tdir_tag = fip->field_tag;
			dir->tdir_type = (short)fip->field_type;
			dir->tdir_count = fip->field_count;
			if (fip->field_type == TIF_SHORT) {
				TIFFgetfield(td, fip->field_tag, &v);
				dir->tdir_offset =
				    TIFFInsertData(tif, dir->tdir_type, v);
			} else
				TIFFgetfield(td, fip->field_tag,
				    &dir->tdir_offset);
			dir++;
			break;
		}
		ResetFieldBit(fields, fip->field_bit);
	}
	/*
	 * Write directory.
	 */
	(void) myseek(tif->tif_fd, tif->tif_diroff, L_SET);
	dircount = nfields;
	if (!WriteOK(tif->tif_fd, &dircount, sizeof (short))) {
		TIFFError(tif->tif_name, "Error writing directory count");
		goto bad;
	}
	if (!WriteOK(tif->tif_fd, data, dirsize)) {
		TIFFError(tif->tif_name, "Error writing directory contents");
		goto bad;
	}
	if (!WriteOK(tif->tif_fd, &tif->tif_nextdiroff, sizeof (long))) {
		TIFFError(tif->tif_name, "Error writing directory link");
		goto bad;
	}
	free(data);
	return (1);
bad:
	free(data);
	return (0);
}
#undef MakeShortDirent
#undef WriteRationalPair

static
TIFFWriteRational(tif, tag, dir, v)
	TIFF *tif;
	u_short tag;
	TIFFDirEntry *dir;
	float v;
{
	long t[2];

	dir->tdir_tag = tag;
	dir->tdir_type = (short)TIF_RATIONAL;
	dir->tdir_count = 1;
	/* need algorithm to convert ... XXX */
	t[0] = v * 10000.;
	t[1] = 10000;
	return (TIFFWriteData(tif, dir, t));
}

static
TIFFWritePerSampleShorts(tif, tag, dir, v)
	TIFF *tif;
	u_short tag;
	register TIFFDirEntry *dir;
	short v;
{
	short w[4];
	int i, samplesperpixel = tif->tif_dir.td_samplesperpixel;

	dir->tdir_tag = tag;
	dir->tdir_type = (short)TIF_SHORT;
	dir->tdir_count = samplesperpixel;
	if (samplesperpixel <= 2) {
		if (tif->tif_header.tiff_magic == TIFF_BIGENDIAN) {
			dir->tdir_offset = (long)v << 16;
			if (samplesperpixel == 2)
				dir->tdir_offset |= v & 0xffff;
		} else {
			dir->tdir_offset = v & 0xffff;
			if (samplesperpixel == 2)
				dir->tdir_offset |= (long)v << 16;
		}
		return (1);
	}
	for (i = 0; i < samplesperpixel; i++)
		w[i] = v;
	return (TIFFWriteData(tif, dir, w));
}

static
TIFFWriteStripThing(tif, tag, dir, lp)
	TIFF *tif;
	u_short tag;
	TIFFDirEntry *dir;
	u_long *lp;
{

	dir->tdir_tag = tag;
	dir->tdir_type = (short)TIF_LONG;		/* XXX */
	dir->tdir_count = tif->tif_dir.td_nstrips;
	if (dir->tdir_count > 1)
		return (TIFFWriteData(tif, dir, lp));
	dir->tdir_offset = *lp;
	return (1);
}

/*
 * Write a contiguous directory item.
 */
static
TIFFWriteData(tif, dir, cp)
	TIFF *tif;
	TIFFDirEntry *dir;
	char *cp;
{
	int cc;

	dir->tdir_offset = dataoff;
                        switch(dir->tdir_type) {
                          case 0:
                          case 1:
                          case 2: cc = dir->tdir_count * 1;
				  break;
                          case 3: cc = dir->tdir_count * 2;
				  break;
                          case 4: cc = dir->tdir_count * 4;
				  break;
                          case 5: cc = dir->tdir_count * 8;
				  break;
                        }
	/*cc = dir->tdir_count * datawidth[dir->tdir_type];*/
	if (SeekOK(tif->tif_fd, dir->tdir_offset) &&
	    WriteOK(tif->tif_fd, cp, cc)) {
		dataoff += (cc + 1) & ~1;
		return (1);
	}
	TIFFError(tif->tif_name, "Error writing data for field \"%s\"",
	    FieldWithTag(dir->tdir_tag)->field_name);
	return (0);
}

/*
 * Link the current directory into the
 * directory chain for the file.
 */
static
TIFFLinkDirectory(tif)
	register TIFF *tif;
{
	static char module[] = "TIFFLinkDirectory";
	short dircount;
	long nextdir;

	tif->tif_diroff = (myseek(tif->tif_fd, 0L, L_XTND)+1) &~ 1L;
	if (tif->tif_header.tiff_diroff == 0) {
		/*
		 * First directory, overwrite header.
		 */
		tif->tif_header.tiff_diroff = tif->tif_diroff;
		(void) myseek(tif->tif_fd, 0L, L_SET);
		if (!WriteOK(tif->tif_fd, &tif->tif_header,
		    sizeof (tif->tif_header))) {
			TIFFError(tif->tif_name, "Error writing TIFF header");
			return (0);
		}
		return (1);
	}
	/*
	 * Not the first directory, search to the last and append.
	 */
	nextdir = tif->tif_header.tiff_diroff;
	do {
		if (!SeekOK(tif->tif_fd, nextdir) ||
		    !ReadOK(tif->tif_fd, &dircount, sizeof (dircount))) {
			TIFFError(module, "Error fetching directory count");
			return (0);
		}
		myseek(tif->tif_fd, dircount * sizeof (TIFFDirEntry), L_INCR);
		if (!ReadOK(tif->tif_fd, &nextdir, sizeof (nextdir))) {
			TIFFError(module, "Error fetching directory link");
			return (0);
		}
	} while (nextdir != 0);
	(void) myseek(tif->tif_fd, -sizeof (nextdir), L_INCR);
	if (!WriteOK(tif->tif_fd, &tif->tif_diroff, sizeof (tif->tif_diroff))) {
		TIFFError(module, "Error writing directory link");
		return (0);
	}
	return (1);
}

/*
 * Set the n-th directory as the current directory.
 * NB: Directories are numbered starting at 0.
 */
TIFFSetDirectory(tif, n)
	register TIFF *tif;
	int n;
{
	static char module[] = "TIFFSetDirectory";
	short dircount;
	long nextdir;

	nextdir = tif->tif_header.tiff_diroff;
	while (n-- > 0 && nextdir != 0) {
		if (!SeekOK(tif->tif_fd, nextdir) ||
		    !ReadOK(tif->tif_fd, &dircount, sizeof (dircount))) {
			TIFFError(module, "%s: Error fetching directory count",
			    tif->tif_name);
			return (0);
		}
		myseek(tif->tif_fd, dircount*sizeof (TIFFDirEntry), L_INCR);
		if (!ReadOK(tif->tif_fd, &nextdir, sizeof (nextdir))) {
			TIFFError(module, "%s: Error fetching directory link",
			    tif->tif_name);
			return (0);
		}
	}
	tif->tif_nextdiroff = nextdir;
	return (TIFFReadDirectory(tif));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_misc.h ===
//
// Tom's miscellaneous TIF header file
//
// Deals with missing parts of the TIF library
//

extern void TIFFError(char *module, char *fmt, ...);
extern void TIFFWarning(char *module, char *fmt, ...);
extern void TIFFFreeDirectory(TIFF *tif);
extern void MissingRequired(TIFF *tif, char *tagname);
extern void TIFFGetField1(TIFFDirectory *td, u_short tag, va_list ap);
extern void TIFFSwabShort(unsigned short *wp);
extern void TIFFSwabLong(unsigned long *lp);
extern void TIFFSwabArrayOfShort(unsigned short *wp, int n);
extern void TIFFSwabArrayOfLong(unsigned long *lp, int n);
extern TIFFDefaultDirectory(TIFF *tif);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_port.h ===
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <buildver.h>

#define KINETIX_TIFF_CHANGES
#define MICROSOFT
#define NO_FSTAT
#define m386
#define BSDTYPES
#define MAXFNAME  13
typedef FILE *FILEHNDL;	
#define NOFILE 0
#ifndef EOS
#define EOS      '\0'
#endif

typedef unsigned long ulong;

#define  alloc(size) malloc(size)
#define index(str,char) strchr(str,char)

#define read(file, buf, size)	fread(file->_fd,buf,1,size)
#define write(file, buf, size) fwrite(file->_fd,buf,1,size)
#define myseek(file, off, type) fseek(file->_fd, (unsigned long)off, type)
#define c_open(name, mode) fopen(name,mode)
#define c_create(name, mode) fopen(name,mode)
#define open(name, mode,prot) fopen(name,mode)
#define close(file) fclose(file)

#define Attr_archive "wb"
#define For_updating "ab"
#define For_reading	"rb"


#undef NULL
#define NULL 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_open.c ===
#include "tif_port.h"


#ifndef lint
static char sccsid[] = "@(#)open.c	1.4	(Pixar - RenderMan Division)	11/2/89";
/* static char sccsid[] = "@(#)tiff_open.c	1.10 4/27/89"; */
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 */
#include "tiffio.h"

// TH 2/20/96 Commented this out to keep the microsoft compiler happy...
//#ifdef HIGHC
//#include <stdefs.h>
//extern int errno;
//static int saverr;
//#endif

long TIFFScanlineSize();


#ifndef MSDOS
#ifdef O_BINARY
#undef O_BINARY
#endif
#define O_BINARY 0
#endif

/*
 * Return an open file descriptor or -1.
 */
#if defined(applec) || defined(THINK_C)
#define	TIFFOpenFile(name, mode, prot)	open(name, mode)
#else
#ifdef HIGHC
#define TIFFOpenFile(name, mode, prot)  c_open(name, mode)
#define TIFFCreateFile(name, mode, prot)  c_create(name, mode)
#else
#define	TIFFOpenFile(name, mode, prot)	open(name, mode, prot)
#endif /* HIGHC */
#endif

#define	ord(e)	((int)e)

/*
 * Initialize shift & mask tables and byte
 * swapping state according to the file
 * byte order.
 */
static
TIFFInitByteOrder(register TIFF *tif,int magic, int bigendian)
	{
	tif->tif_typemask[0] = 0;
	tif->tif_typemask[ord(TIF_BYTE)] = 0xff;
	tif->tif_typemask[ord(TIF_SHORT)] = 0xffff;
	tif->tif_typemask[ord(TIF_LONG)] = 0xffffffff;
	tif->tif_typemask[ord(TIF_RATIONAL)] = 0xffffffff;
	tif->tif_typeshift[0] = 0;
	tif->tif_typeshift[ord(TIF_LONG)] = 0;
	tif->tif_typeshift[ord(TIF_RATIONAL)] = 0;
	if (magic == TIFF_BIGENDIAN) {
		tif->tif_typeshift[ord(TIF_BYTE)] = 24;
		tif->tif_typeshift[ord(TIF_SHORT)] = 16;
		if (!bigendian)
			tif->tif_flags |= TIFF_SWAB;
		} 
	else {
		tif->tif_typeshift[ord(TIF_BYTE)] = 0;
		tif->tif_typeshift[ord(TIF_SHORT)] = 0;
		if (bigendian)
			tif->tif_flags |= TIFF_SWAB;
		}
#ifdef KINETIX_TIFF_CHANGES
    return 1;   // arbitrary, but int function must return a value
#endif
	}


int rd_offset;
TIFF *TIFFReadHdr(FILEHNDL fd) {
	static char module[] = "TIFFReadHdr";
	TIFF *tif;
	int m, bigendian;
	rd_offset=0;

	m = O_RDONLY|O_BINARY;

	errno = 0;
	tif = (TIFF *)alloc(sizeof (TIFF));
	if (tif == NULL) {
		TIFFError(module, "Out of memory (TIFF structure)");
		return ((TIFF *)0);
		}
	bzero((char *)tif, sizeof (*tif));
	tif->tif_fd = fd;
	tif->tif_mode = m &~ (O_CREAT|O_TRUNC|O_BINARY);
	tif->tif_curoff = 0;
	tif->tif_curstrip = -1;		/* invalid strip */
	tif->tif_row = -1;		/* read/write pre-increment */
	{ int one = 1; bigendian = (*(char *)&one == 0); }
	/*
	 * Read in TIFF header.
	 */
	try_again:
	if (!ReadOK(fd, &tif->tif_header, sizeof (TIFFHeader))) {
		TIFFError("TIFFReadHdr", "Can't read TIFF header");
			goto bad;
		}
	/*
	 * Setup the byte order handling.
	 */
	if (tif->tif_header.tiff_magic != TIFF_BIGENDIAN &&
		tif->tif_header.tiff_magic != TIFF_LITTLEENDIAN) {
		if (rd_offset>0) {
			TIFFError("TIFFReadHdr",  "Not a TIFF file ");
			goto bad;
			}
		else {
			if (!SeekOK(fd,128)) goto bad;
			rd_offset = 128;
			goto try_again;
			}
		}
	TIFFInitByteOrder(tif, tif->tif_header.tiff_magic, bigendian);
	/*
	 * Swap header if required.
	 */
	if (tif->tif_flags & TIFF_SWAB) {
		TIFFSwabShort(&tif->tif_header.tiff_version);
		TIFFSwabLong(&tif->tif_header.tiff_diroff);
		}
	/*
	 * Now check version (if needed, it's been byte-swapped).
	 * Note that this isn't actually a version number, it's a
	 * magic number that doesn't change (stupid).
	 */
	if (tif->tif_header.tiff_version != TIFF_VERSION) {
		TIFFError("TIFFReadHdr",
			"Not a TIFF file, bad vers # %d (0x%x)",
			tif->tif_header.tiff_version,
			tif->tif_header.tiff_version); 
		goto bad;
		}
	/*
	 * Setup initial directory.
	 */

	tif->tif_nextdiroff = tif->tif_header.tiff_diroff;
	if (TIFFReadDirectory(tif)) {
		tif->tif_scanlinesize = TIFFScanlineSize(tif);
		tif->tif_rawcc = -1;
		tif->tif_flags |= TIFF_BUFFERSETUP;
		return (tif);
		}
bad:
	tif->tif_mode = O_RDONLY;	/* XXX avoid flush */
	return ((TIFF *)0);
   }

#define	howmany(x, y)	(((x)+((y)-1))/(y))
long
TIFFScanlineSize(	TIFF *tif) {
	TIFFDirectory *td = &tif->tif_dir;
	long scanline;
	
	scanline = td->td_bitspersample * td->td_imagewidth;
	if (td->td_planarconfig == PLANARCONFIG_CONTIG)
		scanline *= td->td_samplesperpixel;
	return (howmany(scanline, 8));
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_pack.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)tiff_packbits.c	1.9 4/25/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * PackBits Compression Algorithm Support
 */
#include "machdep.h"
#include "tiffio.h"

static	int PackBitsEncode(), PackBitsDecode();

TIFFInitPackBits(tif)
	TIFF *tif;
{

	tif->tif_decoderow = PackBitsDecode;
	tif->tif_encoderow = PackBitsEncode;
	return (1);
}

/*
 * Encode a scanline of pixels.
 */
static
PackBitsEncode(tif, bp, cc)
	TIFF *tif;
	u_char *bp;
	register int cc;
{
#ifdef DO_WRITE
	register char *op, *lastliteral;
	register int n, b;
	enum { BASE, LITERAL, RUN, LITERAL_RUN } state;
	char *ep;
	int slop;
	op = tif->tif_rawcp;
	ep = tif->tif_rawdata + tif->tif_rawdatasize;
	state = BASE;
	lastliteral = 0;
	while (cc > 0) {
		/*
		 * Find the longest string of identical bytes.
		 */
		b = *bp++, cc--, n = 1;
		for (; cc > 0 && b == *bp; cc--, bp++)
			n++;
	again:
		if (op + 2 >= ep) {		/* insure space for new data */
			/*
			 * Be careful about writing the last
			 * literal.  Must write up to that point
			 * and then copy the remainder to the
			 * front of the buffer.
			 */
			if (state == LITERAL || state == LITERAL_RUN) {
				slop = op - lastliteral;
				tif->tif_rawcc += lastliteral - tif->tif_rawcp;
				if (!TIFFFlushData(tif))
					return (-1);
				op = tif->tif_rawcp;
				for (; slop-- > 0; *op++ = *lastliteral++)
					;
				lastliteral = tif->tif_rawcp;
			} else {
				tif->tif_rawcc += op - tif->tif_rawcp;
				if (!TIFFFlushData(tif))
					return (-1);
				op = tif->tif_rawcp;
			}
		}
		switch (state) {
		case BASE:		/* initial state, set run/literal */
			if (n > 1) {
				state = RUN;
				if (n > 128) {
					*op++ = -127;
					*op++ = b;
					n -= 128;
					goto again;
				}
				*op++ = -(n-1);
				*op++ = b;
			} else {
				lastliteral = op;
				*op++ = 0;
				*op++ = b;
				state = LITERAL;
			}
			break;
		case LITERAL:		/* last object was literal string */
			if (n > 1) {
				state = LITERAL_RUN;
				if (n > 128) {
					*op++ = -127;
					*op++ = b;
					n -= 128;
					goto again;
				}
				*op++ = -(n-1);		/* encode run */
				*op++ = b;
			} else {			/* extend literal */
				if (++(*lastliteral) == 127)
					state = BASE;
				*op++ = b;
			}
			break;
		case RUN:		/* last object was run */
			if (n > 1) {
				if (n > 128) {
					*op++ = -127;
					*op++ = b;
					n -= 128;
					goto again;
				}
				*op++ = -(n-1);
				*op++ = b;
			} else {
				lastliteral = op;
				*op++ = 0;
				*op++ = b;
				state = LITERAL;
			}
			break;
		case LITERAL_RUN:	/* literal followed by a run */
			/*
			 * Check to see if previous run should
			 * be converted to a literal, in which
			 * case we convert literal-run-literal
			 * to a single literal.
			 */
			if (n == 1 && op[-2] == (char)-1 &&
			    *lastliteral < 126) {
				state = (((*lastliteral) += 2) == 127 ?
				    BASE : LITERAL);
				op[-2] = op[-1];	/* replicate */
			} else
				state = RUN;
			goto again;
		}
	}
	tif->tif_rawcc += op - tif->tif_rawcp;
	tif->tif_rawcp = op;
	return (1);
#else
	return 0;
#endif
}

static
PackBitsDecode(tif, op, occ)
	TIFF *tif;
	register char *op;
	register int occ;
{
	register char *bp;
	register int n, b;
	register int cc;

	bp = tif->tif_rawcp; cc = tif->tif_rawcc;
	while (cc > 0 && occ > 0) {
		SIGNEXTEND(*bp++, n);
		if (n == 128) {
			cc--;
			continue;
		}
		if (n < 0) {		/* replicate next byte -n+1 times */
			n = -n + 1;
			cc--;
			occ -= n;
			for (b = *bp++; n-- > 0;)
				*op++ = b;
		} else {		/* copy next n+1 bytes literally */
			bcopy(bp, op, ++n);
			op += n; occ -= n;
			bp += n; cc -= n;
		}
	}
	tif->tif_rawcp = bp;
	tif->tif_rawcc = cc;
	if (occ > 0) {
		TIFFError(tif->tif_name,
		    "PackBitsDecode: Not enough data for scanline %d",
		    tif->tif_row);
		return (0);
	}
	/* check for buffer overruns? */
	return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_next.c ===
#ifndef lint
static	char sccsid[] = "@(#)tiff_next.c	1.4 4/27/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * NeXT 2-bit Grey Scale Compression Algorithm Support
 */
#include "tif_port.h"
#include "tiffio.h"

static	int NeXTEncode(), NeXTDecode();

TIFFInitNeXT(tif)
	TIFF *tif;
{

	tif->tif_decoderow = NeXTDecode;
	tif->tif_encoderow = NeXTEncode;
	return (1);
}

static
NeXTEncode(tif, pp, cc)
	TIFF *tif;
	u_char *pp;
{

	TIFFError(tif->tif_name, "NeXT encoding is not implemented");
	return (-1);
}

#define SETPIXEL(op, v) {			\
	switch (npixels++ & 3) {		\
	case 0:	op[0]  = (v) << 6; break;	\
	case 1:	op[0] |= (v) << 4; break;	\
	case 2:	op[0] |= (v) << 2; break;	\
	case 3:	*op++ |= (v);	   break;	\
	}					\
}

#define LITERALROW	0x00
#define LITERALSPAN	0x40
#define WHITE   	((1<<2)-1)

static
NeXTDecode(tif, buf, occ)
	TIFF *tif;
	char *buf;
	int occ;
{
	register u_char *bp, *op;
	register int cc, n;
	u_char *row;
	int scanline;

	/*
	 * Each scanline is assumed to start off as all
	 * white (we assume a PhotometricInterpretation
	 * of ``min-is-black'').
	 */
	for (op = (u_char *)buf, cc = occ; cc-- > 0;)
		*op++ = 0xff;

	bp = (u_char *)tif->tif_rawcp;
	cc = tif->tif_rawcc;
	scanline = tif->tif_scanlinesize;
	for (row = (u_char *)buf; occ > 0; occ -= scanline, row += scanline) {
		n = *bp++, cc--;
		switch (n) {
		case LITERALROW:
			/*
			 * The entire scanline is given as literal values.
			 */
			if (cc < scanline)
				goto bad;
			bcopy(bp, row, scanline);
			bp += scanline;
			cc -= scanline;
			break;
		case LITERALSPAN: {
			int off;
			/*
			 * The scanline has a literal span
			 * that begins at some offset.
			 */
			off = (bp[0] * 256) + bp[1];
			n = (bp[2] * 256) + bp[3];
			if (cc < 4+n)
				goto bad;
			bcopy(bp+4, row+off, n);
			bp += 4+n;
			cc -= 4+n;
			break;
		}
		default: {
			register int npixels = 0, grey;
			int imagewidth = tif->tif_dir.td_imagewidth;

			/*
			 * The scanline is composed of a sequence
			 * of constant color ``runs''.  We shift
			 * into ``run mode'' and interpret bytes
			 * as codes of the form <color><npixels>
			 * until we've filled the scanline.
			 */
			op = row;
			for (;;) {
				grey = (n>>6) & 0x3;
				n &= 0x3f;
				if (grey < WHITE) {
					while (n-- > 0)
						SETPIXEL(op, grey);
				} else {
					/*
					 * Run of white -- just update stuff.
					 */
					npixels += n;
					op += n>>2;
				}
				if (npixels >= imagewidth)
					break;
				if (cc == 0)
					goto bad;
				n = *bp++, cc--;
			}
			break;
		}
		}
	}
	tif->tif_rawcp = (char *)bp;
	tif->tif_rawcc = cc;
	return (1);
bad:
	TIFFError(tif->tif_name, "NeXTDecode: Not enough data for scanline %d",
	    tif->tif_row);
	return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_prnt.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)print.c	1.2	(Pixar - RenderMan Division)	5/1/89";
/* static char sccsid[] = "@(#)tiff_print.c	1.9 4/25/89"; */
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * Directory Printing Support
 */
#include "tiffio.h"

static char *ResponseUnitNames[] = {
	"#0",
	"10ths",
	"100ths",
	"1,000ths",
	"10,000ths",
	"100,000ths",
};
static	float ResponseUnit[] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f };
#define	MAXRESPONSEUNIT \
    (sizeof (ResponseUnitNames) / sizeof (ResponseUnitNames[0]))

/*
 * Print the contents of the current directory
 * to the specified stdio file stream.
 */
void
TIFFPrintDirectory(tif, fd, showstrips, showresponsecurve, showcolormap)
	TIFF *tif;
	FILE *fd;
{
	register TIFFDirectory *td;
	int i;
	long n;
	float unit;

	fprintf(fd, "TIFF Directory at offset 0x%x\n", tif->tif_diroff);
	td = &tif->tif_dir;
	if (tif->tif_flags &TIFF_SWAB) 
		fprintf(fd, "  Byte order: Big Endian (Motorola) \n");
	else 
		fprintf(fd, "  Byte order: Little Endian (Intel) \n");
	if (TIFFFieldSet(tif,FIELD_SUBFILETYPE)) {
		fprintf(fd, "  Subfile Type: ");
		if (td->td_subfiletype & FILETYPE_REDUCEDIMAGE)
			fprintf(fd, "reduced-resolution image");
		if (td->td_subfiletype & FILETYPE_PAGE)
			fprintf(fd, "multi-page document");
		if (td->td_subfiletype & FILETYPE_MASK)
			fprintf(fd, "transparency mask");
		fprintf(fd, " (%d = 0x%x)\n",
		    td->td_subfiletype, td->td_subfiletype);
	}
	if (TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))
		fprintf(fd, "  Image Width: %d Image Length: %d\n",
		    td->td_imagewidth, td->td_imagelength);
	if (TIFFFieldSet(tif,FIELD_RESOLUTION))
		fprintf(fd, "  Resolution: %g, %g\n",
		    td->td_xresolution, td->td_yresolution);
	if (TIFFFieldSet(tif,FIELD_POSITION))
		fprintf(fd, "  Position: %g, %g\n",
		    td->td_xposition, td->td_yposition);
	if (TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
		fprintf(fd, "  Bits/Sample: %d\n", td->td_bitspersample);
	if (TIFFFieldSet(tif,FIELD_COMPRESSION)) {
		fprintf(fd, "  Compression Scheme: ");
		switch (td->td_compression) {
		case COMPRESSION_NONE:
			fprintf(fd, "none\n");
			break;
		case COMPRESSION_CCITTRLE:
			fprintf(fd, "CCITT modified Huffman encoding\n");
			break;
		case COMPRESSION_CCITTFAX3:
			fprintf(fd, "CCITT Group 3 facsimile encoding\n");
			break;
		case COMPRESSION_CCITTFAX4:
			fprintf(fd, "CCITT Group 4 facsimile encoding\n");
			break;
		case COMPRESSION_CCITTRLEW:
			fprintf(fd, "CCITT modified Huffman encoding %s\n",
			    "w/ word alignment");
			break;
		case COMPRESSION_PACKBITS:
			fprintf(fd, "Macintosh PackBits encoding\n");
			break;
		case COMPRESSION_THUNDERSCAN:
			fprintf(fd, "ThunderScan 4-bit encoding\n");
			break;
		case COMPRESSION_LZW:
			fprintf(fd, "Lempel-Ziv & Welch encoding\n");
			break;
		case COMPRESSION_PICIO:
			fprintf(fd, "Pixar picio encoding\n");
			break;
		case COMPRESSION_NEXT:
			fprintf(fd, "NeXT 2-bit encoding\n");
			break;
		default:
			fprintf(fd, "%d (0x%x)\n",
			    td->td_compression, td->td_compression);
			break;
		}
	}
	if (TIFFFieldSet(tif,FIELD_PHOTOMETRIC)) {
		fprintf(fd, "  Photometric Interpretation: ");
		switch (td->td_photometric) {
		case PHOTOMETRIC_MINISWHITE:
			fprintf(fd, "\"min-is-white\"\n");
			break;
		case PHOTOMETRIC_MINISBLACK:
			fprintf(fd, "\"min-is-black\"\n");
			break;
		case PHOTOMETRIC_RGB:
			fprintf(fd, "RGB color\n");
			break;
		case PHOTOMETRIC_PALETTE:
			fprintf(fd, "palette color (RGB from colormap)\n");
			break;
		case PHOTOMETRIC_MASK:
			fprintf(fd, "transparency mask\n");
			break;
		default:
			fprintf(fd, "%d (0x%x)\n",
			    td->td_photometric, td->td_photometric);
			break;
		}
	}
	if (TIFFFieldSet(tif,FIELD_MATTEING))
		fprintf(fd, "  Matteing: %s\n",
		    td->td_matteing ? "alpha channel present" : "none");
	if (TIFFFieldSet(tif,FIELD_THRESHHOLDING)) {
		fprintf(fd, "  Thresholding: ");
		switch (td->td_threshholding) {
		case THRESHHOLD_BILEVEL:
			fprintf(fd, "bilevel art scan\n");
			break;
		case THRESHHOLD_HALFTONE:
			fprintf(fd, "halftone or dithered scan\n");
			break;
		case THRESHHOLD_ERRORDIFFUSE:
			fprintf(fd, "error diffused\n");
			break;
		default:
			fprintf(fd, "%d (0x%x)\n",
			    td->td_threshholding, td->td_threshholding);
			break;
		}
	}
	if (TIFFFieldSet(tif,FIELD_PREDICTOR))
		fprintf(fd, "  Predictor: %d\n", td->td_predictor);
	if (TIFFFieldSet(tif,FIELD_ARTIST))
		fprintf(fd, "  Artist: %s\n", td->td_artist);
	if (TIFFFieldSet(tif,FIELD_DATETIME))
		fprintf(fd, "  Date & Time: %s\n", td->td_datetime);
	if (TIFFFieldSet(tif,FIELD_HOSTCOMPUTER))
		fprintf(fd, "  Host Computer: %s\n", td->td_hostcomputer);
	if (TIFFFieldSet(tif,FIELD_SOFTWARE))
		fprintf(fd, "  Software: %s\n", td->td_software);
	if (TIFFFieldSet(tif,FIELD_DOCUMENTNAME))
		fprintf(fd, "  Document Name: %s\n", td->td_documentname);
	if (TIFFFieldSet(tif,FIELD_IMAGEDESCRIPTION))
		fprintf(fd, "  Image Description: %s\n",
		    td->td_imagedescription);
	if (TIFFFieldSet(tif,FIELD_MAKE))
		fprintf(fd, "  Make: %s\n", td->td_make);
	if (TIFFFieldSet(tif,FIELD_MODEL))
		fprintf(fd, "  Model: %s\n", td->td_model);
	if (TIFFFieldSet(tif,FIELD_ORIENTATION)) {
		fprintf(fd, "  Orientation: ");
		switch (td->td_orientation) {
		case ORIENTATION_TOPLEFT:
			fprintf(fd, "row 0 top, col 0 lhs\n");
			break;
		case ORIENTATION_TOPRIGHT:
			fprintf(fd, "row 0 top, col 0 rhs\n");
			break;
		case ORIENTATION_BOTRIGHT:
			fprintf(fd, "row 0 bottom, col 0 rhs\n");
			break;
		case ORIENTATION_BOTLEFT:
			fprintf(fd, "row 0 bottom, col 0 lhs\n");
			break;
		case ORIENTATION_LEFTTOP:
			fprintf(fd, "row 0 lhs, col 0 top\n");
			break;
		case ORIENTATION_RIGHTTOP:
			fprintf(fd, "row 0 rhs, col 0 top\n");
			break;
		case ORIENTATION_RIGHTBOT:
			fprintf(fd, "row 0 rhs, col 0 bottom\n");
			break;
		case ORIENTATION_LEFTBOT:
			fprintf(fd, "row 0 lhs, col 0 bottom\n");
			break;
		default:
			fprintf(fd, "%d (0x%x)\n",
			    td->td_orientation, td->td_orientation);
			break;
		}
	}
	if (TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
		fprintf(fd, "  Samples/Pixel: %d\n", td->td_samplesperpixel);
	if (TIFFFieldSet(tif,FIELD_ROWSPERSTRIP))
		fprintf(fd, "  Rows/Strip: %d\n", td->td_rowsperstrip);
	if (TIFFFieldSet(tif,FIELD_MINSAMPLEVALUE))
		fprintf(fd, "  Min Sample Value: %d\n", td->td_minsamplevalue);
	if (TIFFFieldSet(tif,FIELD_MAXSAMPLEVALUE))
		fprintf(fd, "  Max Sample Value: %d\n", td->td_maxsamplevalue);
	if (TIFFFieldSet(tif,FIELD_PLANARCONFIG)) {
		fprintf(fd, "  Planar Configuration: ");
		switch (td->td_planarconfig) {
		case PLANARCONFIG_CONTIG:
			fprintf(fd, "single image plane\n");
			break;
		case PLANARCONFIG_SEPARATE:
			fprintf(fd, "separate image planes\n");
			break;
		default:
			fprintf(fd, "%d (0x%x)\n",
			    td->td_planarconfig, td->td_planarconfig);
			break;
		}
	}
	if (TIFFFieldSet(tif,FIELD_PAGENAME))
		fprintf(fd, "  Page Name: %s\n", td->td_pagename);
	if (TIFFFieldSet(tif,FIELD_GRAYRESPONSEUNIT)) {
		fprintf(fd, "  Gray Response Unit: ");
		if (td->td_grayresponseunit < MAXRESPONSEUNIT)
			fprintf(fd, "%s\n",
			    ResponseUnitNames[td->td_grayresponseunit]);
		else
			fprintf(fd, "%d (0x%x)\n",
			    td->td_grayresponseunit, td->td_grayresponseunit);
	}
	if (TIFFFieldSet(tif,FIELD_GRAYRESPONSECURVE)) {
		fprintf(fd, "  Gray Response Curve: ");
		if (showresponsecurve) {
			fprintf(fd, "\n");
			unit = ResponseUnit[td->td_grayresponseunit];
			n = 1L<<td->td_bitspersample;
			for (i = 0; i < n; i++)
				fprintf(fd, "    %2d: %g (%d)\n",
				    i,
				    td->td_grayresponsecurve[i] * unit,
				    td->td_grayresponsecurve[i]);
		} else
			fprintf(fd, "(present)\n");
	}
	if (TIFFFieldSet(tif,FIELD_GROUP3OPTIONS))
		fprintf(fd, "  Group 3 Options: 0x%x\n", td->td_group3options);
	if (TIFFFieldSet(tif,FIELD_GROUP4OPTIONS))
		fprintf(fd, "  Group 4 Options: 0x%x\n", td->td_group4options);
	if (TIFFFieldSet(tif,FIELD_RESOLUTIONUNIT)) {
		fprintf(fd, "  Resolution Unit: ");
		switch (td->td_resolutionunit) {
		case RESUNIT_NONE:
			fprintf(fd, "no meaningful units\n");
			break;
		case RESUNIT_INCH:
			fprintf(fd, "inches\n");
			break;
		case RESUNIT_CENTIMETER:
			fprintf(fd, "centimeters\n");
			break;
		default:
			fprintf(fd, "%d (0x%x)\n",
			    td->td_resolutionunit, td->td_resolutionunit);
			break;
		}
	}
	if (TIFFFieldSet(tif,FIELD_PAGENUMBER))
		fprintf(fd, "  Page Number: %d\n", td->td_pagenumber);
	if (TIFFFieldSet(tif,FIELD_COLORRESPONSEUNIT)) {
		fprintf(fd, "  Color Response Unit: ");
		if (td->td_colorresponseunit < MAXRESPONSEUNIT)
			fprintf(fd, "%s\n",
			    ResponseUnitNames[td->td_colorresponseunit]);
		else
			fprintf(fd, "%d (0x%x)\n",
			    td->td_colorresponseunit, td->td_colorresponseunit);
	}
	if (TIFFFieldSet(tif,FIELD_COLORMAP)) {
		fprintf(fd, "  Color Map: ");
		if (showcolormap) {
			fprintf(fd, "\n");
			n = 1L<<td->td_bitspersample;
			for (i = 0; i < n; i++)
				fprintf(fd, "    %2d: %4d %4d %4d\n",
				    i,
				    td->td_redcolormap[i],
				    td->td_greencolormap[i],
				    td->td_bluecolormap[i]);
		} else
			fprintf(fd, "(present)\n");
	}
	if (TIFFFieldSet(tif,FIELD_COLORRESPONSECURVE)) {
		fprintf(fd, "  Color Response Curve: ");
		if (showresponsecurve) {
			fprintf(fd, "\n");
			unit = ResponseUnit[td->td_colorresponseunit];
			n = 1L<<td->td_bitspersample;
			for (i = 0; i < n; i++)
				fprintf(fd, "    %2d: %6.4f %6.4f %6.4f\n",
				    i,
				    td->td_redresponsecurve[i] * unit,
				    td->td_greenresponsecurve[i] * unit,
				    td->td_blueresponsecurve[i] * unit);
		} else
			fprintf(fd, "(present)\n");
	}
	if (showstrips && TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {
    	unsigned int i;    // KINETIX: added shadow, so we can have an unsigned counter
		fprintf(fd, "  %d Strips:\n", td->td_nstrips);
		for (i = 0; i < td->td_nstrips; i++)
			fprintf(fd, "    %3d: [%8d, %8d]\n",
			    i, td->td_stripoffset[i], td->td_stripbytecount[i]);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_pic.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)picio.c	1.2	(Pixar - RenderMan Division)	5/1/89";
/* static char sccsid[] = "@(#)tiff_picio.c	1.13 4/27/89"; */
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * Pixar Picio RLE Algorithm Support
 *
 * NB: This algorithm is not (currently) very effective
 *   because the state is reset at each scanline.  This
 *   was done to avoid having dangling pointers into the
 *   raw data buffer that are invalidated by the flushing
 *   that occurs in TIFFWriteScanline().  To fix this
 *   problem we need to add an encodestrip routine (to reset
 *   state) and maintain state during decoding so that
 *   runs and such can be restarted when they cross scanline
 *   boundaries.  However, since LZW already works on a
 *   strip basis and seems to be more effective, there's
 *   not much reason to go to the trouble.
 */
#include "tiffio.h"

/*
 * Each image is composed of a sequence of dumps, runs,
 * partial dumps, and partial runs.  The first two
 * bytes of a sequence contain a flag indicator and
 * a count.  Flags are encoded in the upper 4 bits
 * of the first byte while the lower 12 bits contain
 * the count.
 */
/* tile flag indicators */
#define	PT_FILL		0		/* fill input buffer */
#define PT_FULLDUMP	1		/* full dump, use count */
#define PT_FULLRUN	2		/* full run, length precedes pixel */
#define PT_PARTDUMP	3		/* part dump, alpha constant */
#define PT_PARTRUN	4		/* part run, alpha constant */

/*
 * Picio encoding state.
 */
#define	MAXPACKETSIZE	8

struct	piciostate {
	u_char	*startptr;
	u_char	*lptr;		/* pointer to length byte in run */
	u_short	len;		/* length of run when in 16-bit mode */
	short	count;		/* repeat count of data in packet */
	short	amark;		/* index to alpha channel */
	int	type;		/* 4-bit packet type */
	int	fulldisklength;	/* size of data+alpha unit */
	int	infodisklength;	/* size of data unit */
	u_char	*fulleobuffer;	/* output buffer fencepost for full packet */
	u_char	*infoeobuffer;	/* output buffer fencepost for info packet */
/* temp buffers of data going to disk */
	u_char	disk0buffer[MAXPACKETSIZE];
	u_char	disk1buffer[MAXPACKETSIZE];
/* temp buffers of data in memory */
	u_short	core0buffer[MAXPACKETSIZE/2];
	u_short	core1buffer[MAXPACKETSIZE/2];
};

/* macros for unrolling loops */
#define REPEAT4(n, op) \
    switch (n) {case 4: op; case 3: op; case 2: op; case 1: op; }
#define REPEAT8(n, op) \
    switch (n) {case 8: op; case 7: op; case 6: op; case 5: op; \
		case 4: op; case 3: op; case 2: op; case 1: op; }

static	int PicioStripEncode(), PicioEncode();
static	int PicioDecodeStrip();
static	int pic8DecodeScanline(), pic16DecodeScanline();
static	int PicioCleanup();

TIFFInitPicio(tif)
	TIFF *tif;
{

	tif->tif_stripdecode = PicioDecodeStrip;
	tif->tif_stripencode = PicioStripEncode;
	tif->tif_encoderow = PicioEncode;
	tif->tif_cleanup = PicioCleanup;
	return (1);
}

static
PicioDecodeStrip(tif)
	TIFF *tif;
{

	switch (tif->tif_dir.td_bitspersample) {
	case 8:	
		tif->tif_decoderow = pic8DecodeScanline;
		break;
	case 16:
		tif->tif_decoderow = pic16DecodeScanline;
		break;
	default:
		TIFFError("PicioDecode", "Cannot handle %d-bit pictures",   // KINETIX: correct arguments
		    tif->tif_dir.td_bitspersample);
		return (0);
	}
	return (1);
}

#define	SPRAY4(nc, op) \
	switch (nc) { \
	case 4: op[3]; \
	case 3: op[2]; \
	case 2: op[1]; \
	case 1: op[0]; \
	}

static
pic8DecodeScanline(tif, op, cc)
	TIFF *tif;
	register u_char *op;
{
	static char module[] = "PicioDecode";
	register u_char *bp, *sp, *ep;
	register int npixels;
	short nc, flag, word, count, length;
	u_char spare[4];

	bp = (u_char *)tif->tif_rawcp;
	ep = bp + tif->tif_rawcc;
	npixels = tif->tif_dir.td_imagewidth;
	nc = (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG ?
	    tif->tif_dir.td_samplesperpixel : 1);
	while (bp < ep && npixels > 0) {
		word = (bp[1] << 8) | bp[0], bp += 2;
		count = (word & 0xfff) + 1;
		switch (flag = word >> 12) {
		case PT_FULLRUN:
			while (count-- > 0) {
				/*
				 * The first byte holds a count. 
				 * The next bytes hold data to be
				 * repeated.
				 */
				length = (*bp++) + 1;
				sp = spare+nc;
				REPEAT4(nc, *--sp = *bp++);
				npixels -= length;
				for (sp = spare; length-- > 0;)
					SPRAY4(nc, *op++ = sp);
			}
			break;
		case PT_FULLDUMP:
			npixels -= count;
			for (count *= nc; count-- > 0; *op++ = *bp++)
				;
			break;
		case PT_PARTRUN:
			spare[0] = *bp++;
			while (count-- > 0) {
				/*
				 * The first byte is a count. 
				 * The next bytes are data to
				 * be repeated.
				 */
				length = (*bp++) + 1;
				sp = spare+nc;
				REPEAT4(nc-1, *--sp = *bp++);
				npixels -= length;
				for (sp = spare; length-- > 0;)
					SPRAY4(nc, *op++ = sp);
			}
			break;
		case PT_PARTDUMP:
			/*
			 * The fixed value (normally alpha) is
			 * stored in the first byte.
			 */
			(sp = spare)[0] = *bp++;
			npixels -= count;
			while (count-- > 0) {
				REPEAT4(nc - 1, *op++ = *bp++);
				*op++ = sp[0];
			}
			break;
		default:
			TIFFError(module, 
			    "%s: Unknown flag 0x%x at scanline %d",
			    tif->tif_name, flag, tif->tif_row);
			return (0);
		}
	}
	tif->tif_rawcc -= bp - (u_char *)tif->tif_rawcp;
	tif->tif_rawcp = (char *)bp;
	if (npixels > 0) {
		TIFFError(module, "%s: Not enough data for scanline %d",
		    tif->tif_name, tif->tif_row);
		return (0);
	}
	return (1);
}

static
pic16DecodeScanline(tif, op, cc)
	TIFF *tif;
	register u_short *op;
{
	static char module[] = "PicioDecode";
	register u_short *sp;
	register u_char *bp, *ep;
	register int npixels;
	short nc, flag, word, count, length;
	u_short spare[4];

	bp = (u_char *)tif->tif_rawcp;
	ep = bp + tif->tif_rawcc;
	npixels = tif->tif_dir.td_imagewidth;
	nc = (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG ?
	    tif->tif_dir.td_samplesperpixel : 1);
	while (bp < ep && npixels > 0) {
		word = (bp[1] << 8) | bp[0], bp += 2;
		count = (word & 0xfff) + 1;
		switch (flag = word >> 12) {
		case PT_FULLRUN:
			while (count-- > 0) {
				/*
				 * The first byte holds a count. 
				 * The next bytes hold data to be
				 * repeated.
				 */
				length = ((bp[1] << 8) | bp[0]) + 1; bp += 2;
				sp = spare+nc;
				REPEAT4(nc, *--sp = bp[0]|(bp[1]<<8); bp += 2);
				npixels -= length;
				for (sp = spare; length-- > 0;)
					SPRAY4(nc, *op++ = sp);
			}
			break;
		case PT_FULLDUMP:
			npixels -= count;
			while (count-- > 0)
				REPEAT4(nc, *op++ = bp[0]|(bp[1]<<8); bp += 2);
			break;
		case PT_PARTRUN:
			spare[0] = bp[0]|(bp[1]<<8); bp += 2;
			while (count-- > 0) {
				/*
				 * The first byte is a count. 
				 * The next bytes are data to
				 * be repeated.
				 */
				length = ((bp[1] << 8) | bp[0]) + 1; bp += 2;
				sp = spare+nc;
				REPEAT4(nc-1, *--sp = bp[0]|(bp[1]<<8); bp +=2);
				npixels -= length;
				for (sp = spare; length-- > 0;)
					SPRAY4(nc, *op++ = sp);
			}
			break;
		case PT_PARTDUMP:
			/*
			 * The fixed value (normally alpha) is
			 * stored in the first byte.
			 */
			(sp = spare)[0] = bp[0]|(bp[1]<<8); bp += 2;
			npixels -= count;
			while (count-- > 0) {
				REPEAT4(nc-1, *op++ = bp[0]|(bp[1]<<8); bp +=2);
				*op++ = sp[0];
			}
			break;
		default:
			TIFFError(module,
			    "%s: Unknown flag 0x%x at scanline %d",
			    tif->tif_name, flag, tif->tif_row);
			return (0);
		}
	}
	tif->tif_rawcc -= bp - (u_char *)tif->tif_rawcp;
	tif->tif_rawcp = (char *)bp;
	if (npixels > 0) {
		TIFFError(module, "%s: Not enough data for scanline %d",
		    tif->tif_name, tif->tif_row);
		return (0);
	}
	return (1);
}

/*
 * Data is encoded into packets that include
 * a flag, a count, and data; and which never
 * span scanlines.
 */
static u_char *startpacket();

/* yech -- this knows about bp & runstatus */
#define startnewbuffer(tif, pt) { \
	endpacket((struct piciostate *)tif->tif_data); \
	tif->tif_rawcc += bp - (u_char *)tif->tif_rawcp; \
	if (!TIFFFlushData(tif)) \
		return (-1); \
	bp = startpacket(tif, tif->tif_rawcp, runstatus = pt); \
	if (bp == (u_char *)0) \
		return (-1); \
}

/* state indicators used in encoding */
#define PT_UNKNOWN	-1
#define PT_CFULLRUN	-2
#define PT_STARTUP	-3
#define PT_CPARTRUN	-4
/*
 * To encode tile type + same-pixel + same-alpha
 * into a single value, we use the following
 * magic constants.
 */
#define	SP_FALSE	(0 * (PT_PARTRUN - PT_CPARTRUN + 1))
#define	SP_TRUE		(1 * (PT_PARTRUN - PT_CPARTRUN + 1))
#define	SA_FALSE	(2 * SP_FALSE)
#define	SA_TRUE		(4 * SP_TRUE)

static	u_char *newdisk;
static	u_char *olddisk;
static	u_short *newcore;
static	u_short *oldcore;

/*
 * Setup encoding state.
 */
static
PicioStripEncode(tif)
	register TIFF *tif;
{
#ifdef DO_WRITE
	register struct piciostate *ps;
	int bytespersample;

	if (tif->tif_data != NULL)
		return (1);
	if (tif->tif_dir.td_bitspersample != 8 &&
	    tif->tif_dir.td_bitspersample != 16) {
		TIFFError("PicioEncode: Cannot handle %d-bit pictures",
		    tif->tif_dir.td_bitspersample);
		return (0);
	}
	tif->tif_data = alloc(sizeof (struct piciostate));
	if (tif->tif_data == NULL) {
		TIFFError("PicioEncode", "No space for picio state block");
		return (0);
	}
	bzero(tif->tif_data, sizeof (struct piciostate));
	ps = (struct piciostate *)tif->tif_data;
	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG) {
		ps->fulldisklength = tif->tif_dir.td_samplesperpixel;
		if ((ps->infodisklength = tif->tif_dir.td_samplesperpixel) > 3)
			ps->infodisklength = 3;
		ps->amark = tif->tif_dir.td_matteing ?
		    tif->tif_dir.td_samplesperpixel-1 : 3;
	} else {
		ps->fulldisklength = ps->infodisklength = 1;
		ps->amark = 0;
	}
	bytespersample = tif->tif_dir.td_bitspersample <= 8 ? 1 :
			 tif->tif_dir.td_bitspersample <= 16 ? 2 : 4;
	ps->fulldisklength *= bytespersample;
	ps->infodisklength *= bytespersample;

	/*
	 * eofullbuffer & eoinfobuffer mark the last spot
	 * in the buffer at which a packet can be placed
	 * (either a fulldisklength or infodisklength packet).
	 * The 2+ is for the 2 byte packet type and length.
	 */
	ps->fulleobuffer = (u_char *)tif->tif_rawdata +
	    tif->tif_rawdatasize - (2+ps->fulldisklength) - 1;
	ps->infoeobuffer = (u_char *)tif->tif_rawdata +
	    tif->tif_rawdatasize - (2+ps->infodisklength) - 1;
	return (1);
#else
	return 0;
#endif
}

/*
 * Encode a scanline of pixels.
 */
static
PicioEncode(tif, ip, cc)
	TIFF *tif;
	register u_char *ip;
{
#ifdef DO_WRITE
	register u_char *bp;
	register struct piciostate *ps;
	int cmpstatus, runstatus, nc, hasalphachannel;
	u_short *cp1, *cp2, *wp;
	u_char *dp, *ep;

	ps = (struct piciostate *)tif->tif_data;
	ep = ip + cc;
	bp = (u_char *)tif->tif_rawcp;
	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG) {
		nc = tif->tif_dir.td_samplesperpixel;
		hasalphachannel = tif->tif_dir.td_matteing;
	} else {
		nc = 1;
		hasalphachannel = 0;
	}
	oldcore = ps->core0buffer;
	newcore = ps->core1buffer;
	olddisk = ps->disk0buffer;
	newdisk = ps->disk1buffer;
	/* setup initial alpha to be different */
	oldcore[ps->amark] =  0;
	newcore[ps->amark] = -1;

	/*
	 * Process each pixel with a finite state machine with
	 * one-pixel look-ahead.  The look-ahead is used to compress
	 * identical pixels into ``pixel runs''.  The states of
	 * encoding process include all the packet types, filled
	 * out with a startup state (used only at startup) and
	 * an unknown state (used when we have no packet open and
	 * do not know yet what kind of packet this last pixel
	 * will start.  Also needed are temporary runlength states
	 * which are needed, for example, when we have just finished 
	 * one run in a runlength packet and do not know whether this
	 * last pixel is the start of a new run or the start of a
	 * whole new (dump) packet.
	 */
	runstatus = PT_STARTUP;
	while (ip < ep) {
		/*
		 * Swap pointers to new and old data buffers.
		 */
#define	SWAP(t, a, b)	{ t tmp; tmp = a; a = b; b = tmp; }
		SWAP(u_short *, oldcore, newcore);
		SWAP(u_char *, olddisk, newdisk);

		/* 
		 * Next move the new pixel from the
		 * user buffer into the local array.
		 * and set up the cmpstatus flag to
		 * indicate if the new and old pixels
		 * agree fully, or just in the flat
		 * field (alpha) component.
		 */
		cmpstatus = SP_TRUE;
		cp1 = newcore; cp2 = oldcore; dp = newdisk;
		if (tif->tif_dir.td_bitspersample == 8) {
			REPEAT4(nc, *cp1 = *ip++;
			    if (*cp2++ != *cp1)
				cmpstatus = SP_FALSE;
			    *dp++ = *cp1++);
		} else {
			wp = (u_short *)ip;	/* XXX for non-pcc compilers */
			REPEAT4(nc, *cp1 = *wp++;
			    if (*cp2++ != *cp1)
				cmpstatus = SP_FALSE;
			    *dp++ = *cp1;
			    *dp++ = *cp1++ >> 8);
			ip = (u_char *)wp;
		}
		cmpstatus += oldcore[ps->amark] == newcore[ps->amark] ?
		    SA_TRUE : SA_FALSE;

		/*
		 * Here is the main loop that decides how to
		 * handle the new pixel based on the current
		 * state.
		 */
		switch (runstatus + cmpstatus) {
		/*
		 * Continue the full run because
		 * the new pixel matches the old.
		 */
		case PT_FULLRUN + SP_TRUE + SA_FALSE:
		case PT_FULLRUN + SP_TRUE + SA_TRUE:
			/*
			 * The run count just overflowed.
			 * Go to the CFULLRUN state, because
			 * this run is done, and we do not
			 * know whether to start a new packet
			 * or just a new run.
			 */
			if (tif->tif_dir.td_bitspersample == 16) {
				ps->lptr[0] = ++(ps->len);
				ps->lptr[1] = ps->len >> 8;
				if (ps->len != 0)
					break;
				ps->lptr[0] = --(ps->len);
				ps->lptr[1] = ps->len >> 8;
			} else {
				if (++(*ps->lptr) != 0)
					break;
				(*ps->lptr)--;
			}
			/* fall thru... */
		case PT_FULLRUN + SP_FALSE + SA_FALSE:
		case PT_FULLRUN + SP_FALSE + SA_TRUE:
			/*
			 * Terminate the current run and
			 * go to CFULLRUN to decide whether
			 * to start a new run with this
			 * pixel or to start a whole new
			 * packet.
			 */
			runstatus = PT_CFULLRUN;
			break;
		/*
		 * In the middle of a fullrun packet; wait
		 * to see whether to start a new run, or
		 * whether to end this packet and start
		 * a new packet.
		 */
		case PT_CFULLRUN + SP_TRUE + SA_FALSE:
		case PT_CFULLRUN + SP_TRUE + SA_TRUE:
			/*
			 * Start a new run.  Increment the
			 * packet count which holds the number of
			 * runs in this packet.  Put out the
			 * run length (1, meaning 1 repetition or
			 * 2 instances) and the full component
			 * information.
			 */
			if (bp > ps->fulleobuffer) {
				startnewbuffer(tif, PT_FULLRUN);
			} else {
				ps->count++;
				ps->lptr = bp;
				*bp++ = 1;
				if (tif->tif_dir.td_bitspersample == 16) {
					ps->len = 1;
					*bp++ = 0;
				}
				dp = newdisk;
				REPEAT8(ps->fulldisklength, *bp++ = *dp++);
			}
			runstatus = PT_FULLRUN;
			break;
		case PT_CFULLRUN + SP_FALSE + SA_TRUE:
			/*
			 * End this packet and start a partial
			 * dump packet, because at least the alpha
			 * stayed constant.
			 */
			endpacket(ps);
			bp = startpacket(tif, bp, runstatus = PT_PARTDUMP);
			if (bp == 0)
				return (-1);
			break;
		case PT_CFULLRUN + SP_FALSE + SA_FALSE:
			endpacket(ps);
			bp = startpacket(tif, bp, runstatus = PT_FULLDUMP);
			if (bp == 0)
				return (-1);
			break;
		case PT_FULLDUMP + SP_TRUE + SA_TRUE:
		case PT_FULLDUMP + SP_TRUE + SA_FALSE:
			/*
			 * End this full dump packet and start
			 * a full run because of the match.
			 */
			endpacket(ps);
			bp = startpacket(tif, bp, runstatus = PT_FULLRUN);
			if (bp == 0)
				return (-1);
			break;
		case PT_FULLDUMP + SP_FALSE + SA_TRUE:
			endpacket(ps);
			bp = startpacket(tif, bp, runstatus = PT_PARTDUMP);
			if (bp == 0)
				return (-1);
			break;
		case PT_FULLDUMP + SP_FALSE + SA_FALSE:
			/*
			 * Continue the dump packet.  Write
			 * the full component information into
			 * the buffer.
			 */
			if (bp > ps->fulleobuffer) {
				startnewbuffer(tif, PT_FULLDUMP);
			} else {
				ps->count++;
				dp = olddisk;
				REPEAT8(ps->fulldisklength, *bp++ = *dp++);
			}
			break;
		case PT_PARTRUN + SP_TRUE + SA_FALSE:
		case PT_PARTRUN + SP_TRUE + SA_TRUE:
			/*
			 * Continue the part run packet.
			 */
			if (tif->tif_dir.td_bitspersample == 16) {
				ps->lptr[0] = ++(ps->len);
				ps->lptr[1] = ps->len >> 8;
				if (ps->len != 0)
					break;
				ps->lptr[0] = --(ps->len);
				ps->lptr[1] = ps->len >> 8;
			} else {
				if (++(*ps->lptr) != 0)
					break;
				(*ps->lptr)--;
			}
			/* fall thru... */
		case PT_PARTRUN + SP_FALSE + SA_TRUE:
			/*
			 * Go to CPARTRUN because this may
			 * just be the start of a new run for
			 * this packet.
			 */
			runstatus = PT_CPARTRUN;
			break;
		case PT_PARTRUN + SP_FALSE + SA_FALSE:
			/*
			 * With no match at all, we have to end
			 * this part run packet.  With only this
			 * last pixel to start with, we do not
			 * know what packet to start next.  Thus
			 * we go to the UNKNOWN state.
			 */
			endpacket(ps);
			runstatus = PT_UNKNOWN;
			break;
		case PT_CPARTRUN + SP_TRUE + SA_FALSE:
		case PT_CPARTRUN + SP_TRUE + SA_TRUE:
			if (bp > ps->infoeobuffer) {
				startnewbuffer(tif, PT_PARTRUN);
			} else {
				ps->count++;
				ps->lptr = bp;
				*bp++ = 1;
				if (tif->tif_dir.td_bitspersample == 16) {
					ps->len = 1;
					*bp++ = 0;
				}
				dp = newdisk;
				REPEAT8(ps->infodisklength, *bp++ = *dp++);
			}
			runstatus = PT_PARTRUN;
			break;
		case PT_CPARTRUN + SP_FALSE + SA_TRUE:
			endpacket(ps);
			bp = startpacket(tif, bp, runstatus = PT_PARTDUMP);
			if (bp == 0)
				return (-1);
			break;
		case PT_CPARTRUN + SP_FALSE + SA_FALSE:
			endpacket(ps);
			bp = startpacket(tif, bp, runstatus = PT_FULLDUMP);
			if (bp == 0)
				return (-1);
			break;
		case PT_PARTDUMP + SP_TRUE + SA_FALSE:
		case PT_PARTDUMP + SP_TRUE + SA_TRUE:
			/*
			 * This dump packet ends and a partial
			 * run packet begins with these last two
			 * pixels.
			 */
			endpacket(ps);
			bp = startpacket(tif, bp, runstatus = PT_PARTRUN);
			if (bp == 0)
				return (-1);
			break;
		case PT_PARTDUMP + SP_FALSE + SA_TRUE:
			/*
			 * The partial dump packet continues.
			 */
			if (bp > ps->infoeobuffer) {
				startnewbuffer(tif, PT_PARTDUMP);
			} else {
				ps->count++;
				dp = olddisk;
				REPEAT8(ps->infodisklength, *bp++ = *dp++);
			}
			break;
		case PT_PARTDUMP + SP_FALSE + SA_FALSE:
			/*
			 * The partial dump ends because alpha
			 * is no longer constant.  Finish off
			 * this packet and go to the unknown
			 * state with this new pixel.
			 */
			if (bp > ps->infoeobuffer) {
				startnewbuffer(tif, PT_PARTDUMP);
			} else {
				ps->count++;
				dp = olddisk;
				REPEAT8(ps->infodisklength, *bp++ = *dp++);
			}
			endpacket(ps);
			runstatus = PT_UNKNOWN;
			break;
		
		case PT_STARTUP + SP_FALSE + SA_FALSE:
		case PT_STARTUP + SP_FALSE + SA_TRUE:
		case PT_STARTUP + SP_TRUE + SA_FALSE:
		case PT_STARTUP + SP_TRUE + SA_TRUE:
			/*
			 * The only thing to do when starting is to
			 * start a packet.  However, we do not know
			 * which to start until we have two pixels,
			 * so we go to the unknown state.
			 */
			runstatus = PT_UNKNOWN;
			break;
		case PT_UNKNOWN + SP_TRUE + SA_FALSE:
		case PT_UNKNOWN + SP_TRUE + SA_TRUE:
			runstatus = hasalphachannel ? PT_PARTRUN : PT_FULLRUN;
			bp = startpacket(tif, bp, runstatus);
			if (bp == 0)
				return (-1);
			break;
		case PT_UNKNOWN + SP_FALSE + SA_TRUE:
			bp = startpacket(tif, bp, runstatus = PT_PARTDUMP);
			if (bp == 0)
				return (-1);
			break;
		case PT_UNKNOWN + SP_FALSE + SA_FALSE:
			bp = startpacket(tif, bp, runstatus = PT_FULLDUMP);
			if (bp == 0)
				return (-1);
			break;
		}
	}

	/*
	 * The following code handles the cleanup at the 
	 * end of the scanline -- we must flush the current
	 * packet.
	 */
	switch (runstatus) {
	case PT_FULLRUN:
		/*
		 * Everything is up to date.
		 */
		break;
	case PT_CFULLRUN:
		/*
		 * Add the last new pixel as a run 
		 * with repeat count 0.
		 */
		if (bp > ps->fulleobuffer) {
			startnewbuffer(tif, 0);
		} else {
			ps->count++;
			*bp++ = 0;
			if (tif->tif_dir.td_bitspersample == 16)
				*bp++ = 0;
			dp = newdisk;
			REPEAT8(ps->fulldisklength, *bp++ = *dp++);
		}
		break;
	case PT_FULLDUMP:
		/*
		 * Add this new pixel as the last pixel in a dump.
		 */
		if (bp > ps->fulleobuffer) {
			startnewbuffer(tif, 0);
		} else {
			ps->count++;
			dp = newdisk;	
			REPEAT8(ps->fulldisklength, *bp++ = *dp++);
		}
		break;
	case PT_PARTRUN:
		/*
		 * We are up to date.
		 */
		break;
	case PT_CPARTRUN:
		/*
		 * See CFULLRUN above.
		 */
		if (bp > ps->infoeobuffer) {
			startnewbuffer(tif, 0);
		} else {
			ps->count++;
			*bp++ = 0;
			if (tif->tif_dir.td_bitspersample == 16)
				*bp++ = 0;
			dp = newdisk;
			REPEAT8(ps->infodisklength, *bp++ = *dp++);
		}
		break;
	case PT_PARTDUMP:
		/*
		 * See FULLDUMP above.
		 */
		if (bp > ps->infoeobuffer) {
			startnewbuffer(tif, 0);
		} else {
			ps->count++;
			dp = newdisk;
			REPEAT8(ps->infodisklength, *bp++ = *dp++);
		}
		break;
	case PT_STARTUP:
		break;
	case PT_UNKNOWN:
		/*
		 * We are caught with one pixel in the hand and no packet
		 * to add it to.  We start a simple fulldump packet.
		 */
		bp = startpacket(tif, bp, 0);
		if (bp == 0)
			return (-1);
		break;
	}
	endpacket(ps);
	tif->tif_rawcc += bp - (u_char *)tif->tif_rawcp;
	tif->tif_rawcp = (char *)bp;
	return (1);
#else
	return 0;
#endif
}

/*
 * Startpacket takes the old and new pixels
 * and starts the requested packet using them.
 */
#ifdef DO_WRITE

static u_char *
startpacket(tif, ptr, type)
	TIFF *tif;
	register u_char *ptr;
	short type;
{
	register struct piciostate *ps;
	register u_char *dp;

	/*
	 * Set up packet type and count.  The packet count
	 * is incremented as the data is repeated.  These
	 * two values are merged and written when ending
	 * the packet.
	 */
	ps = (struct piciostate *)tif->tif_data;
	if (ptr > ps->fulleobuffer) {
		tif->tif_rawcc += ptr - (u_char *)tif->tif_rawcp;
		if (!TIFFFlushData(tif))
			return ((u_char *)0);
		ptr = (u_char *)tif->tif_rawcp;
	}
	ps->type = type;
	ps->count = 0;
	ps->startptr = ptr;
	ptr += 2;		/* skip packet header */
	switch (type) {
	case 0:
		ps->type = PT_FULLDUMP;
		dp = newdisk;
		REPEAT8(ps->fulldisklength, *ptr++ = *dp++);
		break;
	case PT_FULLDUMP:
	case PT_FULLRUN:
		if (type == PT_FULLRUN) {
			ps->lptr = ptr;
			*ptr++ = 1;
			if (tif->tif_dir.td_bitspersample == 16) {
				ps->len = 1;
				*ptr++ = 0;
			}
		}
		dp = olddisk;
		REPEAT8(ps->fulldisklength, *ptr++ = *dp++);
		break;
	case PT_PARTRUN:
	case PT_PARTDUMP:
		dp = olddisk + ps->infodisklength;
		REPEAT8(ps->fulldisklength - ps->infodisklength,
		    *ptr++ = *dp++);
		if (type == PT_PARTRUN) {
			ps->lptr = ptr;
			*ptr++ = 1;
			if (tif->tif_dir.td_bitspersample == 16) {
				ps->len = 1;
				*ptr++ = 0;
			}
		}
		dp = olddisk;
		REPEAT8(ps->infodisklength, *ptr++ = *dp++);
		break;
	}
	return (ptr);
}

/*
 * Set the packet header from the
 * accumulated state information.
 */
static
endpacket(ps)
	register struct piciostate *ps;
{

	ps->count |= ps->type << 12;
	ps->startptr[1] = ps->count >> 8;
	ps->startptr[0] = ps->count;
}
#endif

static
PicioCleanup(tif)
	TIFF *tif;
{

	if (tif->tif_data != NULL) {
		free(tif->tif_data);
		tif->tif_data = NULL;
	}
	return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_sgi.c ===
#ifndef lint
static	char sccsid[] = "@(#)tiff_sgi.c	1.2 4/27/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * SGI RLE Compression Algorithm Support
 */
#include "tif_port.h"
#include "tiffio.h"

static	int SGIEncode(), SGIDecode();

TIFFInitSGI(tif)
	TIFF *tif;
{

	tif->tif_decoderow = SGIDecode;
	tif->tif_encoderow = SGIEncode;
	return (1);
}

#define	MAXRUN	126		/* max length of a run */
#define	LITBIT	0x80		/* bit indicating a literal string */

/*
 * Encode a scanline of pixels (this
 * is basically the PackBits encoding).
 */
static
SGIEncode(tif, bp, cc)
	TIFF *tif;
	u_char *bp;
	register int cc;
{
#ifdef DO_WRITE
	register char *op, *lastliteral;
	register int n, b;
	enum { BASE, LITERAL, RUN, LITERAL_RUN } state;
	char *ep;
	int slop;

	/* XXX 16 bits/sample case */
	op = tif->tif_rawcp;
	ep = tif->tif_rawdata + tif->tif_rawdatasize;
	state = BASE;
	lastliteral = 0;
	while (cc > 0) {
		/*
		 * Find the longest string of identical bytes.
		 */
		b = *bp++, cc--, n = 1;
		for (; cc > 0 && b == *bp; cc--, bp++)
			n++;
	again:
		if (op + 2 >= ep) {		/* insure space for new data */
			/*
			 * Be careful about writing the last
			 * literal.  Must write up to that point
			 * and then copy the remainder to the
			 * front of the buffer.
			 */
			if (state == LITERAL || state == LITERAL_RUN) {
				slop = op - lastliteral;
				tif->tif_rawcc += lastliteral - tif->tif_rawcp;
				if (!TIFFFlushData(tif))
					return (-1);
				op = tif->tif_rawcp;
				for (; slop-- > 0; *op++ = *lastliteral++)
					;
				lastliteral = tif->tif_rawcp;
			} else {
				tif->tif_rawcc += op - tif->tif_rawcp;
				if (!TIFFFlushData(tif))
					return (-1);
				op = tif->tif_rawcp;
			}
		}
		switch (state) {
		case BASE:		/* initial state, set run/literal */
			if (n > 1) {
				state = RUN;
				if (n > MAXRUN) {
					*op++ = MAXRUN;
					*op++ = b;
					n -= MAXRUN;
					goto again;
				}
				*op++ = n;
				*op++ = b;
			} else {
				lastliteral = op;
				*op++ = 1;
				*op++ = b;
				state = LITERAL;
			}
			break;
		case LITERAL:		/* last object was literal string */
			if (n > 1) {
				state = LITERAL_RUN;
				if (n > MAXRUN) {
					*op++ = MAXRUN;
					*op++ = b;
					n -= MAXRUN;
					goto again;
				}
				*op++ = n;		/* encode run */
				*op++ = b;
			} else {			/* extend literal */
				if (++(*lastliteral) == MAXRUN) {
					*lastliteral |= LITBIT;
					state = BASE;
				}
				*op++ = b;
			}
			break;
		case RUN:		/* last object was run */
			if (n > 1) {
				if (n > MAXRUN) {
					*op++ = MAXRUN;
					*op++ = b;
					n -= MAXRUN;
					goto again;
				}
				*op++ = n;
				*op++ = b;
			} else {
				lastliteral = op;
				*op++ = 1;
				*op++ = b;
				state = LITERAL;
			}
			break;
		case LITERAL_RUN:	/* literal followed by a run */
			/*
			 * Check to see if previous run should
			 * be converted to a literal, in which
			 * case we convert literal-run-literal
			 * to a single literal.
			 */
			if (n == 1 && op[-2] == (char)-1 &&
			    *lastliteral < MAXRUN-2) {
				if ((*lastliteral += 2) == MAXRUN) {
					*lastliteral |= LITBIT;
					state = BASE;
				} else
					state = LITERAL;
				op[-2] = op[-1];	/* replicate */
			} else {
				*lastliteral |= LITBIT;
				state = RUN;
			}
			goto again;
		}
	}
	if (state == LITERAL || state == LITERAL_RUN)
		*lastliteral |= LITBIT;
	tif->tif_rawcc += op - tif->tif_rawcp;
	tif->tif_rawcp = op;
	return (1);
#else
	return 0;
#endif
}

#define	DECODE(cc, bp, occ, op, size)			\
	while (cc > 0 && occ > 0) {			\
		pixel = *bp++; cc--;			\
		n = pixel &~ LITBIT;			\
		if (n == 0)				\
			continue;			\
		if (pixel & LITBIT) {			\
			bcopy(bp, op, size*n);		\
			op += size*n; occ -= size*n;	\
			bp += size*n; cc -= size*n;	\
		} else {				\
			pixel = *bp++; cc--;		\
			occ -= size*n;			\
			while (n-- > 0)			\
				*op++ = pixel;		\
		}					\
	}

static
SGIDecode(tif, buf, occ)
	TIFF *tif;
	u_char *buf;
	register int occ;
{
	register int n, pixel, cc;

	cc = tif->tif_rawcc;
	if (tif->tif_dir.td_bitspersample <= 8) {
		register u_char *bp, *op;

		bp = (u_char *)tif->tif_rawcp;
		op = buf;
		DECODE(cc, bp, occ, op, sizeof (char));
		tif->tif_rawcp = (char *)bp;
	} else {
		register u_short *bp, *op;

		bp = (u_short *)tif->tif_rawcp;
		op = (u_short *)buf;
		DECODE(cc, bp, occ, op, sizeof (short));
		tif->tif_rawcp = (char *)bp;
	}
	tif->tif_rawcc = cc;
	if (occ > 0) {
		TIFFError(tif->tif_name,
		    "SGIDecode: Not enough data for scanline %d",
		    tif->tif_row);
		return (0);
	}
	return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_swab.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)tiff_swab.c	1.2 2/19/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library Byte Swapping Routines.
 *
 * XXX We assume short = 16-bits and long = 32-bits XXX
 */
#include "machdep.h"

#ifndef TIFFSwabShort
void TIFFSwabShort(wp)
	unsigned short *wp;
{
	register unsigned char *cp = (unsigned char *)wp;
	int t;

	t = cp[1]; cp[1] = cp[0]; cp[0] = t;
}
#endif

#ifndef TIFFSwabLong
void TIFFSwabLong(lp)
	unsigned long *lp;
{
	register unsigned char *cp = (unsigned char *)lp;
	int t;

	t = cp[3]; cp[3] = cp[0]; cp[0] = t;
	t = cp[2]; cp[2] = cp[1]; cp[1] = t;
}
#endif

#ifndef TIFFSwabArrayOfShort
void TIFFSwabArrayOfShort(wp, n)
	unsigned short *wp;
	register int n;
{
	register unsigned char *cp;
	register int t;

	/* XXX unroll loop some */
	while (n-- > 0) {
		cp = (unsigned char *)wp;
		t = cp[1]; cp[1] = cp[0]; cp[0] = t;
		wp++;
	}
}
#endif

#ifndef TIFFSwabArrayOfLong
void TIFFSwabArrayOfLong(lp, n)
	register unsigned long *lp;
	register int n;
{
	register unsigned char *cp;
	register int t;

	/* XXX unroll loop some */
	while (n-- > 0) {
		cp = (unsigned char *)lp;
		t = cp[3]; cp[3] = cp[0]; cp[0] = t;
		t = cp[2]; cp[2] = cp[1]; cp[1] = t;
		lp++;
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_read.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)read.c	1.3	(Pixar - RenderMan Division)	7/31/89";
/* static char sccsid[] = "@(#)tiff_read.c	1.13 4/25/89"; */
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

#define xxxDBGTIF

/*
 * TIFF Library.
 * Scanline-oriented Read Support
 */
#include "tiffio.h"

#ifdef applec
#include <FCntl.h>
#define lseek unix_lseek	/* Mac's Standard 'lseek' won't extend file */
#define L_SET 0
#define L_INCR 1
#define L_XTND 2
#endif

#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))

extern int rd_offset;


/* Set state to appear as if a
 * strip has just been read in */
static TIFFStartStrip(register TIFF *tif,	u_int strip) {
	TIFFDirectory *td = &tif->tif_dir;

#ifdef DBGTIF
	printf("TIFFStartStrip, strip %d, \n",strip);
#endif
	tif->tif_curstrip = strip;
	tif->tif_row = (strip % td->td_stripsperimage) * td->td_rowsperstrip;
	tif->tif_rawcp = tif->tif_rawdata;
	tif->tif_rawcc = td->td_stripbytecount[strip];
	return (tif->tif_stripdecode == NULL ||     // KINETIX: removed (int) cast from NULL
                (*tif->tif_stripdecode)(tif));
	}


/* Read a strip of data from the file. */
TIFFReadStrip( register TIFF *tif,	u_int strip )	{
	
	static char module[] = "TIFFReadStrip";
	TIFFDirectory *td = &tif->tif_dir;
	long bytecount;     // KINETIX: made type signed

#ifdef DBGTIF
	printf("TIFFReadStrip, strip %d, \n",strip);
#endif
	if (!SeekOK(tif->tif_fd, td->td_stripoffset[strip])) {
		TIFFError(module, "%s: Seek error at scanline %d, strip %d",
		    tif->tif_name, tif->tif_row, strip);
		return (0);
		}
	/*
	 * Expand raw data buffer, if needed, to
	 * hold data strip coming from file
	 * (perhaps should set upper bound on
	 *  the size of a buffer we'll use?).
	 */
	bytecount = td->td_stripbytecount[strip];
	if (bytecount > tif->tif_rawdatasize) {
		tif->tif_curstrip = -1;		/* unknown state */
		if (tif->tif_rawdata) {
			free(tif->tif_rawdata);
			tif->tif_rawdata = NULL;
			}
		tif->tif_rawdatasize = roundup(bytecount, 1024);
		tif->tif_rawdata = alloc(tif->tif_rawdatasize);
		if (tif->tif_rawdata == NULL) {
			TIFFError(module,
			    "%s: No space for data buffer at scanline %d",
			    tif->tif_name, tif->tif_row);
			tif->tif_rawdatasize = 0;
			return (0);
			}
		}
	if (!ReadOK(tif->tif_fd, tif->tif_rawdata, bytecount)) {
		TIFFError(module, "%s: Read error at scanline %d, bytecount=%d",
		    tif->tif_name, tif->tif_row, bytecount);
		return (0);
		}
	return (TIFFStartStrip(tif, strip));
	}


/* Seek to a random row+sample in a file. */
static
/*VARARGS2*/
TIFFSeek(register TIFF *tif, u_int in_u_row, u_int sample)	{
    // KINETIX: added local signed "row" to match signed comparisons below
    int row = (int)in_u_row;
	register TIFFDirectory *td = &tif->tif_dir;
	int strip;  // KINETIX: changed from u_int

#ifdef DBGTIF
	printf("TIFFSeek, row %d,  sample %d \n",row,sample);
#endif
	if (row >= td->td_imagelength) {	
		/* out of range */
		TIFFError(tif->tif_name, "%d: Row out of range, max %d",
		    row, td->td_imagelength);
		return (0);
		}	
	if (td->td_planarconfig == PLANARCONFIG_SEPARATE) {
		if (sample >= td->td_samplesperpixel) {
			TIFFError(tif->tif_name,
			    "%d: Sample out of range, max %d",
			    sample, td->td_samplesperpixel);
			return (0);
			}
		strip = sample*td->td_stripsperimage + row/td->td_rowsperstrip;
		} 
	else
		strip = row / td->td_rowsperstrip;
	if (strip != tif->tif_curstrip) { 	/* different strip, refill */
		if (!TIFFReadStrip(tif, strip))
			return (0);
		} 
	else if (row < tif->tif_row) {
		/* Moving backwards within the same strip: backup
		 * to the start and then decode forward (below).
		 *
		 * NB: If you're planning on lots of random access within a
		 * strip, it's better to just read and decode the entire
		 * strip, and then access the decoded data in a random fashion. 
		 */
		if (!TIFFStartStrip(tif, strip))
			return (0);
		}
	if (row != tif->tif_row) {
		if (tif->tif_seek) {
			/* Seek forward to the desired row. */
			if (!(*tif->tif_seek)(tif, row - tif->tif_row))
				return (0);
			tif->tif_row = row;
			} 
		else {
			TIFFError(tif->tif_name,
		     "Compression algorithm does not support random access");
			return (0);
			}
		}
	return (1);
	}

/*VARARGS3*/
TIFFReadScanline(	register TIFF *tif,u_char *buf,u_int row, u_int sample) {
	int e;

#ifdef DBGTIF
	printf("TIFFReadScanline, row %d,  sample %d \n",row,sample);
#endif
	if (tif->tif_mode == O_WRONLY) {
		TIFFError(tif->tif_name, "File not open for reading");
		return (-1);
		}
	if (e = TIFFSeek(tif, row, sample)) {
		/*
		 * Decompress desired row into user buffer
		 */
		e = (*tif->tif_decoderow)(tif, buf, tif->tif_scanlinesize);
		tif->tif_row++;
		}
	return (e ? 1 : -1);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\Wsd\fmtspec.h ===
//-----------------------------------------------------------------------------
// --------------------
// File ....: fmtspec.h
// --------------------
// Author...: Gus J Grubba
// Date ....: March 1997
// Descr....: WSD Device Specific Parameters
//
// History .: Mar, 27 1997 - Started
//
//-----------------------------------------------------------------------------
        
#ifndef _WSDFMTSPEC_
#define _WSDFMTSPEC_

//-----------------------------------------------------------------------------
//-- WSD data Structure -------------------------------------------------------
//

#define WSDVERSION    201

typedef struct tagWSDDATA {
	DWORD	version;			//-- Reserved
	int		startframe;			//-- Starting frame (Offset)
	BOOL	chromadither;		//-- Perform Chroma Dithering (TRUE or FALSE)
	char	hostname[MAX_PATH];
	BOOL    ntsc;
	int     height;
} WSDDATA;

#endif

//-- EOF: fmtspec.h -----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\tif\tif_thdr.c ===
#include "tif_port.h"

#ifndef lint
static char sccsid[] = "@(#)tiff_thunder.c	1.7 4/25/89";
#endif

/*
 * Copyright (c) 1988 by Sam Leffler.
 * All rights reserved.
 *
 * This file is provided for unrestricted use provided that this
 * legend is included on all tape media and as a part of the
 * software program in whole or part.  Users may copy, modify or
 * distribute this file at will.
 */

/*
 * TIFF Library.
 *
 * ThunderScan 4-bit Compression Algorithm Support
 */
#include "tiffio.h"

static	int ThunderScanEncode(), ThunderScanDecode();

TIFFInitThunderScan(tif)
	TIFF *tif;
{

	tif->tif_decoderow = ThunderScanDecode;
	tif->tif_encoderow = ThunderScanEncode;
	return (1);
}

/*
 * ThunderScan uses an encoding scheme designed for
 * 4-bit pixel values.  Data is encoded in bytes, with
 * each byte split into a 2-bit code word and a 6-bit
 * data value.  The encoding gives raw data, runs of
 * pixels, or pixel values encoded as a delta from the
 * previous pixel value.  For the latter, either 2-bit
 * or 3-bit delta values are used, with the deltas packed
 * into a single byte.
 */
#define	THUNDER_DATA		0x3f	/* mask for 6-bit data */
#define	THUNDER_CODE		0xc0	/* mask for 2-bit code word */
/* code values */
#define	THUNDER_RUN		0x00	/* run of pixels w/ encoded count */
#define	THUNDER_2BITDELTAS	0x40	/* 3 pixels w/ encoded 2-bit deltas */
#define	    DELTA2_SKIP		2	/* skip code for 2-bit deltas */
#define	THUNDER_3BITDELTAS	0x80	/* 2 pixels w/ encoded 3-bit deltas */
#define	    DELTA3_SKIP		4	/* skip code for 3-bit deltas */
#define	THUNDER_RAW		0xc0	/* raw data encoded */

static	int twobitdeltas[4] = { 0, 1, 0, -1 };
static	int threebitdeltas[8] = { 0, 1, 2, 3, 0, -3, -2, -1 };

static
ThunderScanEncode(tif, pp, cc)
	TIFF *tif;
	u_char *pp;
{

	TIFFError(tif->tif_name, "ThunderScan encoding is not implemented");
	return (-1);
}

#define	SETPIXEL(op, v) { \
	lastpixel = (v) & 0xf; \
	if (npixels++ & 1) \
	    *op++ |= lastpixel; \
	else \
	    op[0] = lastpixel << 4; \
}

static
ThunderScanDecode(tif, op, occ)
	TIFF *tif;
	register u_char *op;
{
	register u_char *bp;
	register int n, cc, lastpixel, npixels, delta;
	int imagewidth;

	bp = (u_char *)tif->tif_rawcp;
	cc = tif->tif_rawcc;
	imagewidth = tif->tif_dir.td_imagewidth;
	lastpixel = npixels = 0;
	while (cc > 0 && npixels < imagewidth) {
		n = *bp++, cc--;
		switch (n & THUNDER_CODE) {
		case THUNDER_RUN:		/* pixel run */
			/*
			 * Replicate the last pixel n times,
			 * where n is the lower-order 6 bits.
			 */
			if (npixels & 1) {
				op[0] |= lastpixel;
				lastpixel = *op++; npixels++; n--;
			} else
				lastpixel |= lastpixel << 4;
			npixels += n;
			for (; n > 0; n -= 2)
				*op++ = lastpixel;
			if (n == -1)
				*--op &= 0xf0;
			lastpixel &= 0xf;
			break;
		case THUNDER_2BITDELTAS:	/* 2-bit deltas */
			if ((delta = ((n >> 4) & 3)) != DELTA2_SKIP)
				SETPIXEL(op, lastpixel + twobitdeltas[delta]);
			if ((delta = ((n >> 2) & 3)) != DELTA2_SKIP)
				SETPIXEL(op, lastpixel + twobitdeltas[delta]);
			if ((delta = (n & 3)) != DELTA2_SKIP)
				SETPIXEL(op, lastpixel + twobitdeltas[delta]);
			break;
		case THUNDER_3BITDELTAS:	/* 3-bit deltas */
			if ((delta = ((n >> 3) & 7)) != DELTA3_SKIP)
				SETPIXEL(op, lastpixel + threebitdeltas[delta]);
			if ((delta = (n & 7)) != DELTA3_SKIP)
				SETPIXEL(op, lastpixel + threebitdeltas[delta]);
			break;
		case THUNDER_RAW:		/* raw data */
			SETPIXEL(op, n);
			break;
		}
	}
	tif->tif_rawcp = (char *)bp;
	tif->tif_rawcc = cc;
	if (npixels != imagewidth) {
		TIFFError(tif->tif_name,
		    "ThunderScanDecode: %s data for scanline %d (npixels=%d)",
		    npixels < imagewidth ? "Not enough" : "Too much",
		    tif->tif_row, npixels);
		return (0);
	}
	return (1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\Wsd\wsd.cpp ===
//-----------------------------------------------------------------------------
// ------------------
// File ....: wsd.cpp
// ------------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: WSD Image I/O Module
//
// History .: Sep, 20 1995 - Started (GG)
//            Jan, 17 1997 - Version 2 - Chroma Filtering Added (GG)
//            
//-----------------------------------------------------------------------------
		
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include <gcommlib.h>
#include "wsd.h"
#include "wsdrc.h"

//-- Handy macros

#define limit(x) {                      \
    if(x > 0xFFFFFF) x = 0xFFFFFF;      \
    if(x <=  0xFFFF) x = 0;             \
    x  &=  0xFF0000;                    \
}

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;
TCPcomm  *tcp   = NULL; 
char  szTemp[80];
static BOOL controlsInit = FALSE;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			if (hInst)
				return(FALSE);
				hInst = hDLLInst;
			if ( !controlsInit ) {
				controlsInit = TRUE;
				InitCustomControls(hInst);
			}
			break;
		case DLL_PROCESS_DETACH:
			hInst  = NULL;
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
	}
	return TRUE;
}

//-----------------------------------------------------------------------------
// *> GetString()
//

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
// *> psrand()
//

DWORD randomseed = 1234;

int psrand() {
	 randomseed = randomseed * 1103515245 + 12345;
	 return (int)((randomseed>>16)&0x7FFF);
}

//-----------------------------------------------------------------------------
// *> ErrorHandler()
//
//  Error Handler for the TCP/IP Library
//
//	 ERR_FATAL
//	 ERR_WARN 
//	 ERR_INFO 
//	 ERR_DEBUG
//

void WINAPI ErrorHandler( int ErrorCode, const TCHAR *ErrorMessage) {
	
	int LogType = 0;

	switch (ErrorCode) {
		case ERR_FATAL:
			LogType = SYSLOG_ERROR;
			break;
		case ERR_WARN:
			LogType = SYSLOG_WARN;
			break;
		case ERR_INFO:
			LogType = SYSLOG_INFO;
			break;
		case ERR_DEBUG:
			LogType = SYSLOG_DEBUG;
			break;
	}

	if (LogType) {
		TCHAR txt[MAX_PATH];
		wsprintf(txt,_T("TCP/IP - %s"),ErrorMessage);
		TheManager->Max()->Log()->LogEntry(LogType,NO_DIALOG,NULL,txt);
	}
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// WSD Class Description

class WSDClassDesc:public ClassDesc {
	
	public:

		int             IsPublic     ( )                   { return 1;                }
		void           *Create       ( BOOL loading=FALSE) { return new BitmapIO_WSD; }
		const TCHAR    *ClassName    ( )                   { return GetString(IDS_WSD);     }
		SClass_ID       SuperClassID ( )                   { return BMM_IO_CLASS_ID;  }
		Class_ID        ClassID      ( )                   { return Class_ID(WSDCLASSID,0); }
		const TCHAR    *Category     ( )                   { return GetString(IDS_BITMAP_IO); }

};

static WSDClassDesc WSDDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
	return GetString(IDS_LIBDSCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
	return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
	switch(i) {
		case  0: return &WSDDesc; break;
		default: return 0;        break;
	}
}

DLLEXPORT ULONG LibVersion ( )  { 
	return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//-----------------------------------------------------------------------------
// *> GetCfgFilename()
//

void BitmapIO_WSD::GetCfgFilename( TCHAR *filename ) {
	_tcscpy(filename,TheManager->GetDir(APP_PLUGCFG_DIR));
	int len = _tcslen(filename);
	if (len) {
		if (_tcscmp(&filename[len-1],_T("\\")))
			_tcscat(filename,_T("\\"));
	}   
	_tcscat(filename,WSDCONFIGNAME);   
}

//-----------------------------------------------------------------------------
// *> ReadCfg()
//

int BitmapIO_WSD::ReadCfg() {
	
	TCHAR filename[MAX_PATH];
	TCHAR system[64];
	
	GetCfgFilename(filename);
	
	if (!BMMIsFile(filename)) {
		//-- Log Entry (GG 02/23/97)
		TheManager->Max()->Log()->LogEntry(SYSLOG_WARN,NO_DIALOG,NULL,GetString(IDS_LOG_NOCFG));
		_tcscpy(system,WSDDEFSYS);
		return (FALSE);
	}
	
	TCHAR temp[64];
	wsprintf(temp,_T("%d"),maxframes);

	GetPrivateProfileString(WSDSECTION,WSDHOSTKEY,WSDDEFAULT,hostname,MAX_PATH,filename);
	GetPrivateProfileString(WSDSECTION,WSDSYSKEY,WSDDEFSYS,system,64,filename);
	GetPrivateProfileString(WSDSECTION,WSDMXFRAMEKEY,temp,temp,64,filename);
	maxframes = atoi(temp);
	
	if (!_tcscmp(system,WSDDEFSYS)) {
		ntsc   = TRUE;
		height = 486;
	} else {
		ntsc   = FALSE;
		height = 576;
	}
	
	return (TRUE);

}

//-----------------------------------------------------------------------------
// *> WriteCfg()
//

void BitmapIO_WSD::WriteCfg() {
	
	TCHAR filename[MAX_PATH];
	TCHAR system[64];
	
	if (ntsc)
		_tcscpy(system,WSDDEFSYS);
	else   
		_tcscpy(system,_T("pal"));
	
	GetCfgFilename(filename);
	WritePrivateProfileString(WSDSECTION,WSDHOSTKEY,hostname,filename);
	WritePrivateProfileString(WSDSECTION,WSDSYSKEY,system,filename);

	TCHAR temp[64];
	wsprintf(temp,_T("%d"),maxframes);
	WritePrivateProfileString(WSDSECTION,WSDMXFRAMEKEY,temp,filename);
}

//-----------------------------------------------------------------------------
// *> Setup()
//

BOOL BitmapIO_WSD::Setup(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

	switch (message) {
		
		case WM_INITDIALOG: {
			  
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));

			//-- Set Hostname Text -----------------------

			SetDlgItemText(hWnd,IDC_HOSTNAME,hostname);

			//-- Handle System Type ----------------------

			CheckRadioButton(hWnd,IDC_NTSC,IDC_PAL,ntsc?IDC_NTSC:IDC_PAL);

			ISpinnerControl	*mxframespin = GetISpinner(GetDlgItem(hWnd,IDC_MAX_FRAMES_SP));
			if (mxframespin) {
				mxframespin->LinkToEdit(GetDlgItem(hWnd,IDC_MAX_FRAMES_ED),EDITTYPE_INT);
				mxframespin->SetLimits(1,99999,FALSE);
				mxframespin->SetValue(maxframes,FALSE);
			}

			return 1;
		}

		case WM_COMMAND:

			switch (LOWORD(wParam)) {
				  
				//-- Changed Accepted ---------------------
				  
				case IDOK:
				  
					//-- Handle System Type --------------

					ntsc = IsDlgButtonChecked(hWnd,IDC_NTSC);

					//-- Handle Host Name ----------------

					GetDlgItemText(hWnd,IDC_HOSTNAME,hostname,MAX_PATH);
				  
					{
						ISpinnerControl	*mxframespin = GetISpinner(GetDlgItem(hWnd,IDC_MAX_FRAMES_SP));
						if (mxframespin)
							maxframes = mxframespin->GetIVal();
					}

					//-- Update Configuration File -------

					WriteCfg();
				  
					EndDialog(hWnd,1);
					break;

				//-- Changed Aborted ----------------------
				  
				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
		
			}
			return 1;

		case WM_DESTROY: {
				ISpinnerControl	*mxframespin = GetISpinner(GetDlgItem(hWnd,IDC_MAX_FRAMES_SP));
				if (mxframespin)
					ReleaseISpinner(mxframespin);
			}
			break;

	}
	
	return 0;

}

//-----------------------------------------------------------------------------
// *> SetupCtrlDlgProc()
//

BOOL CALLBACK SetupCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {
	static BitmapIO_WSD *bio = NULL;
	if (message == WM_INITDIALOG) 
		bio = (BitmapIO_WSD *)lParam;
	if (bio) 
		return (bio->Setup(hWnd,message,wParam,lParam));
	else
		return(FALSE);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::ShowSetup()

BOOL BitmapIO_WSD::ShowSetup(HWND hWnd) {
	return (
		DialogBoxParam(
			hInst,
			MAKEINTRESOURCE(IDD_WSD_SETUP),
			hWnd,
			(DLGPROC)SetupCtrlDlgProc,
			(LPARAM)this)
	);        
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::Where()

int BitmapIO_WSD::Where() {
	tcp->Send(&ci,"w\n",2);
	tcp->Receive(&ci,szTemp,80,0.0f);
	tcp->Receive(&ci,szTemp,80,0.333f);
	char *ptr = strstr(szTemp,"#");
	if (ptr)
		return(atoi(++ptr));
	else
		return (0);
}

//-----------------------------------------------------------------------------
// #> ControlConnect()
//

BOOL BitmapIO_WSD::ControlConnect(HWND hWnd) {

	SetCursor(LoadCursor(NULL,IDC_WAIT));

	ci.Reset();
	ci.SetServerName(hostname);

	if (tcp->rlogin(&ci) != GCRES_SUCCESS) {
		
		//-- Log Entry (GG 02/23/97)

		TCHAR title[MAX_PATH];
		_tcscpy(title,GetString(IDS_TITLE_LOG));

		TheManager->Max()->Log()->LogEntry(SYSLOG_ERROR,DISPLAY_DIALOG,
			title,
			GetString(IDS_LOG_NOHOST),hostname);
		
		HWND hDlg = GetDlgItem(hWnd,IDC_PLAY);
		EnableWindow(hDlg,FALSE);
		hDlg = GetDlgItem(hWnd,IDC_REW);
		EnableWindow(hDlg,FALSE);
		hDlg = GetDlgItem(hWnd,IDC_STOP);
		EnableWindow(hDlg,FALSE);
		SetCursor(LoadCursor(NULL,IDC_ARROW));
		return FALSE;
	} else {

		//-- Log Entry (GG 02/23/97)

		TheManager->Max()->Log()->LogEntry(SYSLOG_DEBUG,NO_DIALOG,
			NULL, GetString(IDS_LOG_CONNECTED),hostname);
		
		HWND hDlg = GetDlgItem(hWnd,IDC_PLAY);
		EnableWindow(hDlg,TRUE);
		hDlg = GetDlgItem(hWnd,IDC_REW);
		EnableWindow(hDlg,TRUE);
		hDlg = GetDlgItem(hWnd,IDC_STOP);
		EnableWindow(hDlg,TRUE);
		SetCursor(LoadCursor(NULL,IDC_ARROW));
		return TRUE;
	}

}

//-----------------------------------------------------------------------------
// #> ControlCtrlDlgProc()
//

BOOL BitmapIO_WSD::Control(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

	static connected = FALSE;
	
	switch (message) {
		
		//-- Initialization -------------------------------
		
		case WM_INITDIALOG: {
			  
			  CenterWindow(hWnd,GetParent(hWnd));
			  SetCursor(LoadCursor(NULL,IDC_ARROW));
			  
			  //-- Read Configuration ----------------------
			  
			  if (!ReadCfg()) {
				  if (!ShowSetup(hWnd)) {
					  EndDialog(hWnd,0);
					  return 1;
				  }
			  }
			  
			  //-- Attempt to Connect ----------------------
    
			  tcp = (TCPcomm *)gcommCreate(gcTCP);
			  if (!tcp) {
				  EndDialog(hWnd,0);
				  return 1;
			  }

			  //-- Set Error handlers ----------------------
	
			  tcp->SetSilentMode(TRUE);
			  tcp->RegisterErrorHandler((PERROR_HANDLER)ErrorHandler);
	
			  //-- Init ------------------------------------
	
			  if (!tcp->Init(hWnd)) {
				  EndDialog(hWnd,0);
				  return 1;
			  }
			  
			  connected = ControlConnect(hWnd);
	
			  //-- Handle Starting Frame -------------------
			  
			  sprintf(szTemp,"%d",data.startframe);
			  SetDlgItemText(hWnd,IDC_STARTFRAME,szTemp);

			  //-- Handle Chroma Filtering

			  CheckDlgButton(hWnd,IDC_CHROMA,data.chromadither);

			  return 1;
		}

		case WM_COMMAND:

			  switch (LOWORD(wParam)) {
				  
				  case IDC_PLAY:
						 tcp->Send(&ci,"play\n",5);
						 tcp->Receive(&ci,szTemp,80,0.0f);
						 break;

				  case IDC_REW:              
						 tcp->Send(&ci,"g 0\n",4);
						 tcp->Receive(&ci,szTemp,80,0.0f);
						 break;

				  case IDC_STOP:              
						 tcp->Send(&ci,"stop\n",5);
						 tcp->Receive(&ci,szTemp,80,0.0f);
						 break;

				  case IDC_CURRENT:              
						 data.startframe = Where();
						 sprintf(szTemp,"%d",data.startframe);
						 SetDlgItemText(hWnd,IDC_STARTFRAME,szTemp);
						 break;

				  case IDC_SETUP:              
						 if (ShowSetup(hWnd)) {
							 if (connected) {
								 tcp->Disconnect(&ci);
								 tcp->Close();
							 }
							 connected = ControlConnect(hWnd);
						 }
						 break;

				  case IDOK:
						 
						 //-- Get Starting Frame
						 
						 char buf[64];
						 GetDlgItemText(hWnd,IDC_STARTFRAME,buf,64);
						 data.startframe = atoi(buf);
						 data.chromadither = IsDlgButtonChecked(hWnd,IDC_CHROMA);
						 EndDialog(hWnd,1);
						 break;

				  case IDCANCEL:
						 EndDialog(hWnd,0);
						 break;
		
			  }
			  return 1;

		case WM_DESTROY:
			  if (connected) {
				  tcp->Disconnect(&ci);
				  tcp->Close();
			  }
			  connected = FALSE;  
			  delete tcp;
			  tcp = NULL;
			  return 1;

	}
	
	return 0;

}

//-----------------------------------------------------------------------------
// *> ControlDlgProc()
//

BOOL CALLBACK ControlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {
	static BitmapIO_WSD *bio = NULL;
	if (message == WM_INITDIALOG) 
		bio = (BitmapIO_WSD *)lParam;
	if (bio) 
		return (bio->Control(hWnd,message,wParam,lParam));
	else
		return(FALSE);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::ShowControl()

BOOL BitmapIO_WSD::ShowControl(HWND hWnd, DWORD flag) {
	return (
		DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_WSD_CONTROL),
		hWnd,
		(DLGPROC)ControlDlgProc,
		(LPARAM)this)
	);
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {
	switch (message) {
		case WM_INITDIALOG: {
			  CenterWindow(hWnd,GetParent(hWnd));
			  SetCursor(LoadCursor(NULL,IDC_ARROW));
			  return 1;
		}
		case WM_COMMAND:
			  switch (LOWORD(wParam)) {
				  case IDOK:              
				  case IDCANCEL:
						 EndDialog(hWnd,1);
						 break;
			  }
			  return 1;
	}
	return 0;
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::BitmapIO_WSD()

BitmapIO_WSD::BitmapIO_WSD  ( ) { 
	width   = 720;
	height  = 486;
	ntsc    = TRUE;
	rgbbuf  = NULL;
	yuvbuf  = NULL;
	line    = NULL;
	
	maxframes = MAX_FRAMES;

	data.version    	= WSDVERSION;
	data.startframe 	= 0;
	data.chromadither	= TRUE;

	_tcscpy(hostname,WSDDEFAULT);
}

BitmapIO_WSD::~BitmapIO_WSD ( ) { }

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::LongDesc()

const TCHAR *BitmapIO_WSD::LongDesc() {
	return GetString(IDS_WSD_FILE);
}
	
//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::ShortDesc()

const TCHAR *BitmapIO_WSD::ShortDesc() {
	return GetString(IDS_ACCOM);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::LoadConfigure()

BOOL BitmapIO_WSD::LoadConfigure ( void *ptr ) {
	WSDDATA *buf = (WSDDATA *)ptr;
	if (buf->version == WSDVERSION) {
		memcpy((void *)&data,ptr,sizeof(WSDDATA));
		height	= data.height;
		ntsc	= data.ntsc;
		strcpy(hostname,data.hostname);
		return (TRUE);
	} else
		return (FALSE);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::SaveConfigure()

BOOL BitmapIO_WSD::SaveConfigure ( void *ptr ) {
	if (ptr) {
		data.height	= height;
		data.ntsc	= ntsc;
		strcpy(data.hostname,hostname);
		memcpy(ptr,(void *)&data,sizeof(WSDDATA));
		return (TRUE);
	} else
		return (FALSE);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::EvaluateConfigure()

DWORD BitmapIO_WSD::EvaluateConfigure ( ) {
	 return (sizeof(WSDDATA));
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::ShowAbout()

void BitmapIO_WSD::ShowAbout(HWND hWnd) {
	DialogBoxParam(
		hInst,
		MAKEINTRESOURCE(IDD_WSD_ABOUT),
		hWnd,
		(DLGPROC)AboutCtrlDlgProc,
		(LPARAM)0);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::GetImageInfo()

BMMRES BitmapIO_WSD::GetImageInfo ( BitmapInfo *fbi ) {

	//-- Note that I'm hardcoding some bogus length. Eventually, I will get
	//   the number of frames straight from the Accom (disk size).

	//-- Update Bitmap Info ------------------------------
	
	fbi->SetWidth(720);
	fbi->SetHeight(486);
	fbi->SetType(BMM_TRUE_24);
	//fbi->SetGamma(1.0f);
	fbi->SetAspect(1.3333333f / 720.0f / 486.0f);
	fbi->SetFirstFrame(0);
	fbi->SetLastFrame(999999);

	return BMMRES_SUCCESS;

}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::Load()

BitmapStorage *BitmapIO_WSD::Load(BitmapInfo *fbi, Bitmap *map, BMMRES *status) {

	BitmapStorage *s = NULL;

	int   y;
	GCRES res;

	//-- Initialize Status Optimistically

	*status = BMMRES_SUCCESS;

	//-- Make sure nothing weird is going on

	if(openMode != BMM_NOT_OPEN) {
		*status = ProcessImageIOError(fbi,BMMRES_INTERNALERROR);
		return NULL;
	}

	//-- Allocate receive Buffer
	
	yuvbuf = (BYTE *)LocalAlloc(LPTR, width * 2);

	if (!yuvbuf) {
		memory_error:
		*status = ProcessImageIOError(fbi,BMMRES_MEMORYERROR);
		CleanUp();
		return NULL;
	}

	line = (BMM_Color_64 *)LocalAlloc(LPTR, width * sizeof(BMM_Color_64));

	if (!line)
		goto memory_error;

	//-- Update Bitmap Info ------------------------------
	
	fbi->SetWidth(  width  );
	fbi->SetHeight( height );
	fbi->SetAspect( 1.3333333f / (float)width / (float)height);
	fbi->SetType(BMM_YUV_422);
	fbi->ResetFlags(MAP_HAS_ALPHA);
	fbi->SetFirstFrame(0);
	fbi->SetLastFrame(999999);
	
	//-- Create Image Storage ---------------------------- 
	
	s = BMMCreateStorage(map->Manager(),BMM_TRUE_32);

	if (!s) {
		storage_error:
		*status = ProcessImageIOError(fbi,BMMRES_INTERNALERROR);
		goto bail_out;
	}
	
	if (s->Allocate(fbi,map->Manager(),BMM_OPEN_R)==0)
		goto storage_error;

	//-- Init login

	ReadCfg();
	
	tcp = (TCPcomm *)gcommCreate(gcTCP);

	if (!tcp) {
		*status = ProcessImageIOError(fbi,GetString(IDS_ERR_TCPERROR));
		goto bail_out;
	}

	//-- Set Error handlers ----------------------
	
	tcp->SetSilentMode(TRUE);
	tcp->RegisterErrorHandler((PERROR_HANDLER)ErrorHandler);
	
	//-- Init ------------------------------------
	
	if (!tcp->Init(fbi->GetUpdateWindow())) {
		*status = ProcessImageIOError(fbi,GetString(IDS_ERR_TCPINITERROR));
		goto bail_out;
	}
		
	ci.Reset();
	ci.SetServerName(hostname);
	*status = BMMRES_ERRORTAKENCARE;

	//-- Login
	
	if (tcp->rlogin(&ci) != GCRES_SUCCESS) {

		//-- Log Entry (GG 02/23/97)

		TheManager->Max()->Log()->LogEntry(SYSLOG_ERROR,NO_DIALOG,
			NULL,GetString(IDS_LOG_NOCONNECT),hostname);

		goto bail_out;

	}

	//-- Send "Receive" Command --------------------------
	
	char cmdstring[MAX_PATH];
	sprintf(cmdstring, "recv %d\n", (fbi->CurrentFrame() * fbi->GetCustomStep()) + data.startframe);
	res = tcp->Send(&ci,cmdstring,strlen(cmdstring));
	if (res != GCRES_SUCCESS)
		goto io_error;

	//-- Check for Ack
	
	res = tcp->Receive(&ci,szTemp,1);
	if (res != GCRES_SUCCESS)
		goto io_error;

	//-- Loop through rows
	
	for (y = 0; y < height; y++) {

		WORD *bf = rgbbuf;
		res = tcp->Receive(&ci,yuvbuf,width * 2,LINE_TIMEOUT);
		if (res != GCRES_SUCCESS)
			 goto io_error;
	
		YUVtoRGB(line,yuvbuf,width);
		
		if (s->PutPixels(0,y,width,line)!=1)
			goto io_error;

		//-- Progress Report
		
		if (fbi->GetUpdateWindow())
			SendMessage(fbi->GetUpdateWindow(),BMM_PROGRESS,y,height);

	}
	
	//-- Wait for ACK ------------------------------------

	res = tcp->Receive(&ci,szTemp,1);

	if (res != GCRES_SUCCESS) {

		io_error:
		
		//-- Log Entry (GG 02/23/97)

		TheManager->Max()->Log()->LogEntry(SYSLOG_ERROR,NO_DIALOG,
			NULL,GetString(IDS_LOG_IOERROR),hostname);
	
		bail_out:

		if (s)
			delete s;
		if (tcp) {
			tcp->Disconnect(&ci);
			tcp->Close();
			delete tcp;
			tcp = NULL;
		}
		CleanUp();
		return NULL;
	
	}
 
	//-- Set the storage's BitmapInfo

	tcp->Disconnect(&ci);
	tcp->Close();
	delete tcp;
	tcp = NULL;

	s->bi.CopyImageInfo(fbi);
	*status = BMMRES_SUCCESS;

	return  s;
	

}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::OpenOutput()
//

BMMRES  BitmapIO_WSD::OpenOutput(BitmapInfo *fbi, Bitmap *map) {

	if (openMode != BMM_NOT_OPEN)
		return (ProcessImageIOError(fbi,BMMRES_INTERNALERROR));
		
	if (!map)
		return (ProcessImageIOError(fbi,BMMRES_INTERNALERROR));
		
	ReadCfg();
	
	//-- Attempt login

	tcp = (TCPcomm *)gcommCreate(gcTCP);

	if (!tcp)
		return BMMRES_ERRORTAKENCARE;

	//-- Set Error handlers ----------------------
	
	tcp->SetSilentMode(TRUE);
	tcp->RegisterErrorHandler((PERROR_HANDLER)ErrorHandler);
	
	//-- Init ------------------------------------
	
	if (!tcp->Init(fbi->GetUpdateWindow()))
		return BMMRES_ERRORTAKENCARE;
	
	ci.Reset();
	ci.SetServerName(hostname);
	
	if (tcp->rlogin(&ci) != GCRES_SUCCESS) {

		//-- Log Entry (GG 02/23/97)

		TheManager->Max()->Log()->LogEntry(SYSLOG_ERROR,NO_DIALOG,
			NULL,GetString(IDS_LOG_NOCONNECT),hostname);

		return BMMRES_ERRORTAKENCARE;
	}

	//-- Save Image Info Data

	bi.CopyImageInfo(fbi);    
	bi.SetUpdateWindow(fbi->GetUpdateWindow());

	this->map   = map;
	openMode    = BMM_OPEN_W;

	return BMMRES_SUCCESS;

}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::Write()
//

BMMRES BitmapIO_WSD::Write(int frame) {

	GCRES res;

	//-- If we haven't gone through an OpenOutput(), leave

	if (openMode != BMM_OPEN_W)
		return (ProcessImageIOError(&bi,BMMRES_INTERNALERROR));

	if (!tcp)
		return (ProcessImageIOError(&bi,BMMRES_INTERNALERROR));
	
	//-- Check for a valid frame number

	if ((frame + data.startframe) > maxframes) {
		TCHAR title[MAX_PATH];
		_tcscpy(title,GetString(IDS_TITLE_LOG));
		TheManager->Max()->Log()->LogEntry(SYSLOG_ERROR,DISPLAY_DIALOG,
			title,
			GetString(IDS_LOG_INVALIDFRAMEERROR),(frame + data.startframe));
		return BMMRES_ERRORTAKENCARE;
	}
	
	//-- Allocate Buffers --------------------------------

	yuvbuf = (BYTE *)LocalAlloc(LPTR, width * 2);

	if (!yuvbuf) {
		memory_error:
		CleanUp();
		return (ProcessImageIOError(&bi,BMMRES_MEMORYERROR));
	}


	line = (BMM_Color_64 *)LocalAlloc(LPTR, width * sizeof(BMM_Color_64));

	if (!line)
		goto memory_error;
	
	//-- Convert Image and Transfer to Accom -------------
	
	int w = min(width,bi.Width());
	int h = bi.Height();
	int y;
    
	//-- Send "Send" Command
	
	char cmdstring[MAX_PATH];
	if (frame == BMM_SINGLEFRAME)
		frame = 0;
	sprintf(cmdstring, "send %d\n", (frame + data.startframe));

	res = tcp->Send(&ci,cmdstring,strlen(cmdstring));

	if (res != GCRES_SUCCESS)
		goto io_error;

	//-- Check for Ack
    
	res = tcp->Receive(&ci,szTemp,1);
	
	if (res != GCRES_SUCCESS)
		goto io_error;

	//-- Loop through rows
	
	for (y = 0; y < height; y++) {

		if (y < h) {
			GetOutputPixels(0,y,w,line);   // Get gamma-corrected, dithered pixels
			RGBtoYUV(line,yuvbuf,width);
		} else {
			if (y == h) {
				memset(line,0,width*sizeof(BMM_Color_64));
				RGBtoYUV(line,yuvbuf,width);
			}
		}
	
		res = tcp->Send(&ci,yuvbuf,(width * 2),LINE_TIMEOUT);
		if (res != GCRES_SUCCESS)
			 goto io_error;

		//-- Progress Report
		
		if (bi.GetUpdateWindow())
			SendMessage(bi.GetUpdateWindow(),BMM_PROGRESS,y,height);

	}
	
	//-- Wait for ACK ------------------------------------

	res = tcp->Receive(&ci,szTemp,1);
	
	if (res != GCRES_SUCCESS) {
		io_error:

		//-- Log Entry (GG 02/23/97)

		TheManager->Max()->Log()->LogEntry(SYSLOG_ERROR,NO_DIALOG,
			NULL,GetString(IDS_LOG_IOERROR),hostname);
	
		CleanUp();
		return BMMRES_ERRORTAKENCARE;
	}

	//-- Done --------------------------------------------
	
	CleanUp();   
	return (BMMRES_SUCCESS);

}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::Close()
//

int  BitmapIO_WSD::Close(int flag ) {

	if (openMode != BMM_OPEN_W)
		return 0;

	if (tcp) {   
		tcp->Disconnect(&ci);
		tcp->Close();   
		delete tcp;
		tcp = NULL;
	}

	CleanUp();

	return 1;
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::RGBtoYUV()
//

#define DITHER(to, from) { int d = (from+e)>>8;  to = (d>255)?255:d; }

void BitmapIO_WSD::RGBtoYUV (BMM_Color_64 *rgb, BYTE *yuv, int len) {

	int i, r, g, b, e;
	int y1, y2, u, v, u0, u1, u2, v0, v1, v2;

	u = v = y1 = y2 = u0 = u1 = v0 = v1 = v2 = 0;

	//-- Old Method

	if (!data.chromadither) {
				
		for (i = (len>>1); i>0; i--) {

			//-- first pixel

			e = psrand()&0xff; 
			DITHER(r,rgb->r);
			DITHER(g,rgb->g);
			DITHER(b,rgb->b);
				
			rgb++;

			y1  = 16840*r +  33060*g +  6420*b;
			u   = -9668*r + -18987*g + 28654*b;
				
			//-- second pixel

			e = psrand()&0xff; 
			DITHER(r,rgb->r);
			DITHER(g,rgb->g);
			DITHER(b,rgb->b);

			rgb++;

			y2  = 16840*r +  33060*g +  6420*b;
			v   = 28661*r + -23998*g + -4662*b;

			*yuv++  = (u >>16) +128;
			*yuv++  = (y1>>16) + 16;
			*yuv++  = (v >>16) +128;
			*yuv++  = (y2>>16) + 16;

		}

	//-- Chroma Dithering

	} else {

		for (i = (len>>1); i>0; i--) {

			//-- first pixel

			e = psrand()&0xff; 
			DITHER(r,rgb->r);
			DITHER(g,rgb->g);
			DITHER(b,rgb->b);
				
			rgb++;

			y1  = 16829*r +  33039*g +  6416*b;
			u1  = -4853*r +  -9530*g + 14383*b;
			v1  = 14386*r + -12046*g + -2340*b;
				
			//-- second pixel

			e = psrand()&0xff; 
			DITHER(r,rgb->r);
			DITHER(g,rgb->g);
			DITHER(b,rgb->b);

			rgb++;

			y2  = 16829*r +  33039*g +  6416*b + (0xFFFF & y1);
			u2  = -2426*r +  -4765*g +  7191*b;
			v2  =  7193*r +  -6023*g + -1170*b;

			//-- Filter the chroma 

			u = u0 + u1 + u2 + (0xFFFF & u);
			v = v0 + v1 + v2 + (0xFFFF & v);
			u0 = u2;
			v0 = v2;

			*yuv++  = (u >>16) +128;
			*yuv++  = (y1>>16) + 16;
			*yuv++  = (v >>16) +128;
			*yuv++  = (y2>>16) + 16;

		}

	}
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::YUVtoRGB()
//

void BitmapIO_WSD::YUVtoRGB (BMM_Color_64 *rgb, BYTE *yuv, int len) {

	int j;  
	long y, u, v, y1, r, g, b;

	for(j=0;j<(len/2);j++) {
		
		u = *yuv++;
		u -= 128;
		y = *yuv++;
		y -= 16;
		
		if(y<0) y = 0;

		v  = *yuv++;
		v -= 128;
		y1 = *yuv++;
		y1-= 16;
		
		if(y1<0) y1 = 0;

		y *= 76310;
		r  = y + 104635*v;
		g  = y + -25690*u + -53294*v;
		b  = y + 132278*u;

		limit(r);
		limit(g);
		limit(b);

		rgb->r = (WORD)(r>>8);
		rgb->g = (WORD)(g>>8);
		rgb->b = (WORD)(b>>8);
		rgb->a = 0;
		rgb++;

		y1 *= 76310;
		r  =    y1 + 104635*v;
		g  =    y1 + -25690*u + -53294*v;
		b  =    y1 + 132278*u;

		limit(r);
		limit(g);
		limit(b);
		
		rgb->r = (WORD)(r>>8);
		rgb->g = (WORD)(g>>8);
		rgb->b = (WORD)(b>>8);
		rgb->a = 0;
		rgb++;

    }

}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::CleanUp()
//

void BitmapIO_WSD::CleanUp () {
	if (rgbbuf)
		LocalFree(rgbbuf);
	if (yuvbuf)   
		LocalFree(yuvbuf);
	if (line)   
		LocalFree(line);
	rgbbuf= NULL;
	yuvbuf= NULL;
	line  = NULL;
}

//-----------------------------------------------------------------------------
// #> BitmapIO_WSD::EvalMatch()
//

void BitmapIO_WSD::EvalMatch( TCHAR *matchString ) {
	wsprintf(matchString,_T("%d"),data.startframe);
}
//-- EOF: wsd.cpp -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\Wsd\wsdrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wsd.rc
//
#define IDS_TITLE_LOG                   1
#define IDS_LOG_NOHOST                  2
#define IDS_WSD                         3
#define IDS_BITMAP_IO                   4
#define IDS_WSD_FILE                    5
#define IDS_ACCOM                       6
#define IDS_LOG_NOCFG                   7
#define IDS_LOG_CONNECTED               8
#define IDS_ERR_TCPERROR                9
#define IDS_ERR_TCPINITERROR            10
#define IDS_LOG_NOCONNECT               11
#define IDS_LOG_IOERROR                 12
#define IDS_LOG_INVALIDFRAMEERROR       12
#define IDS_LIBDSCRIPTION               13
#define IDD_WSD_ABOUT                   101
#define IDD_WSD_CONTROL                 102
#define IDD_WSD_SETUP                   103
#define IDC_REW                         1006
#define IDC_PLAY                        1007
#define IDC_CURRENT                     1008
#define IDC_HOSTNAME                    1009
#define IDC_NTSC                        1010
#define IDC_PAL                         1011
#define IDC_STARTFRAME                  1012
#define IDC_SETUP                       1013
#define IDC_STOP                        1014
#define IDC_CHROMA                      1015
#define IDC_MAX_FRAMES_ED               1028
#define IDC_MAX_FRAMES_SP               1047
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\Wsd\wsd.h ===
//-----------------------------------------------------------------------------
// ----------------
// File ....: wsd.h
// ----------------
// Author...: Gus J Grubba
// Date ....: September 1995
// Descr....: WSD Image I/O Module
//
// History .: Sep, 20 1995 - Started
//
//-----------------------------------------------------------------------------
        
#ifndef _WSDCLASS_
#define _WSDCLASS_

#define DLLEXPORT __declspec(dllexport)

#include "fmtspec.h"

//-- Constants ----------------------------------------------------------------

#define WSDCONFIGNAME _T("wsd.ini")
#define WSDSECTION    _T("Default State")
#define WSDHOSTKEY    _T("Hostname")
#define WSDMXFRAMEKEY _T("Max Frames")
#define WSDSYSKEY     _T("System")
#define WSDDEFAULT    _T("accom")
#define WSDDEFSYS     _T("ntsc")

#define MAX_FRAMES		1860
#define LINE_TIMEOUT	5.0f

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class BitmapIO_WSD : public BitmapIO {
    
     private:
        
        int     width;
        int     height;
        
        WORD    *rgbbuf;
        BYTE    *yuvbuf;

        TCHAR   hostname[MAX_PATH];
        BOOL    ntsc;
		int		maxframes;
        
        WSDDATA data;
        
        BMM_Color_64 *line;
        
        ConnectionInfo ci;
        
        //-- Private Methods
        
        void           RGBtoYUV           ( BMM_Color_64* rgb, BYTE *yuv, int len );
        void           YUVtoRGB           ( BMM_Color_64 *rgb, BYTE *yuv, int len );
        void           CleanUp            ( );
        void           GetCfgFilename     ( TCHAR *filename );
        int            ReadCfg            ( );
        void           WriteCfg           ( );
        int            Where              ( );
        BOOL           ControlConnect     ( HWND hWnd );
        BOOL           ShowSetup          ( HWND hWnd );
        
     public:
     
        //-- Constructors/Destructors
        
                       BitmapIO_WSD       ( );
                      ~BitmapIO_WSD       ( );
               
        //-- Number of extemsions supported
        
        int            ExtCount           ( )       { return 0;}
        
        //-- Extension #n (i.e. "3DS")
        
        const TCHAR   *Ext                ( int n ) {return _T("");}
        
        //-- Descriptions
        
        const TCHAR   *LongDesc           ( );
        const TCHAR   *ShortDesc          ( );

        //-- Miscelaneous Messages
        
        const TCHAR   *AuthorName         ( )       { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage   ( )       { return _T("Copyright 1994, 1996 Gus J Grubba");}
        unsigned int   Version            ( )       { return (WSDVERSION);}

        //-- Driver capabilities
        
        int            Capability         ( )       { return BMMIO_READER			| 
                                                             BMMIO_WRITER			|
                                                             BMMIO_RANDOM_ACCESS	|
                                                             BMMIO_MULTIFRAME		|
                                                             BMMIO_CONTROLREAD		| 
                                                             BMMIO_CONTROLWRITE		| 
                                                             BMMIO_EVALMATCH		| 
		    											 	 BMMIO_NON_CONCURRENT_ACCESS |
                                                             BMMIO_CONTROLGENERIC;}
                                                                   
        //-- Driver Configuration
        
        BOOL           LoadConfigure      ( void *ptr );
        BOOL           SaveConfigure      ( void *ptr );
        DWORD          EvaluateConfigure  ( );
        
        //-- Show DLL's "About..." box
        
        void           ShowAbout          ( HWND hWnd );  

        //-- Show DLL's Control Panel
        
        BOOL           ShowControl        ( HWND hWnd, DWORD flag );

        //-- Return info about image
        
        BMMRES         GetImageInfo       ( BitmapInfo *fbi );        

        //-- Image Input
        
        BitmapStorage *Load               ( BitmapInfo *fbi, Bitmap *map, BMMRES *status);

        //-- Image Output
        
        BMMRES         OpenOutput         ( BitmapInfo *fbi, Bitmap *map );
        BMMRES         Write              ( int frame );
        int            Close              ( int flag );

        //-- Dialog Procs
        
        BOOL           Setup              ( HWND,UINT,WPARAM,LPARAM );
        BOOL           Control            ( HWND,UINT,WPARAM,LPARAM );
        
        void			EvalMatch		   ( TCHAR *matchString );

};

#endif

//-- EOF: wsd.h ---------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\knots\frenet.h ===
/* 
 * Frenet frames
 */

typedef Point2 (*Curve2D)(float u, float t);
typedef Point3 (*Curve3D)(float t);

class FrenetFrame {
public:
		FrenetFrame(Curve3D spaceCurve, float t, float deltaT);

		Point3 Value()    { return mValue; }
		Point3 Tangent()  { return mTangent; }
		Point3 Normal()   { return mNormal; }
		Point3 BiNormal() { return mBiNormal; }

private:
		Point3 mValue;
		Point3 mTangent;
		Point3 mNormal;
		Point3 mBiNormal;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\Yuv\yuvrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by yuv.rc
//
#define IDS_YUV                         1
#define IDS_YUV_FILE                    2
#define IDS_BITMAP_IO                   3
#define IDS_LIBDESCRIPTION              4
#define IDD_YUV_ABOUT                   101
#define IDD_YUV_CONTROL                 102
#define IDC_RAD_NTSC                    1001
#define IDC_RAD_PAL                     1002
#define IDC_EDIT_X                      1003
#define IDC_EDIT_Y                      1004
#define IDC_RAD_CUSTOM                  1005
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\Yuv\yuv.h ===
//-----------------------------------------------------------------------------
// ----------------
// File ....: yuv.h
// ----------------
// Author...: Gus J Grubba
// Date ....: July 1995
// Descr....: YUV File I/O Module
//
// History .: Jul, 27 1995 - Started
//            
//
//
//-----------------------------------------------------------------------------
        
#ifndef _YUVCLASS_
#define _YUVCLASS_

#define DLLEXPORT __declspec(dllexport)

//-- Constants ----------------------------------------------------------------

#define WIDTH   720
#define PHEIGHT 576
#define NHEIGHT 486

//-----------------------------------------------------------------------------
//-- Class Definition ---------------------------------------------------------
//

class BitmapIO_YUV : public BitmapIO {
    
     private:
     
        Bitmap *loadMap;    // Set when loading a bitmap
        FILE   *inStream;   // Set when loading a bitmap
        
     public:
     
        //-- Constructors/Destructors
        
                       BitmapIO_YUV       ( );
                      ~BitmapIO_YUV       ( );
               
        //-- Number of extemsions supported
        
        int            ExtCount           ( )       { return 1;}
        
        //-- Extension #n (i.e. "3DS")
        
        const TCHAR   *Ext                ( int n ) {return _T("yuv");}
        
        //-- Descriptions
        
        const TCHAR   *LongDesc           ( );
        const TCHAR   *ShortDesc          ( );

        //-- Miscelaneous Messages
        
        const TCHAR   *AuthorName         ( )       { return _T("Gus J Grubba");}
        const TCHAR   *CopyrightMessage   ( )       { return _T("Copyright 1993, 1995 Gus J Grubba");}
        const TCHAR   *OtherMessage1      ( )       { return _T("");}
        const TCHAR   *OtherMessage2      ( )       { return _T("");}
        
        unsigned int   Version            ( )       { return (100);}

        //-- Driver capabilities
        
        int            Capability         ( )       { return BMMIO_READER    | 
                                                             BMMIO_EXTENSION |
                                                             BMMIO_CONTROLWRITE; }
        
        //-- Driver Configuration
        
        BOOL           LoadConfigure      ( void *ptr );
        BOOL           SaveConfigure      ( void *ptr );
        DWORD          EvaluateConfigure  ( )       { return 0; }
        
        //-- Show DLL's "About..." box
        
        void           ShowAbout          ( HWND hWnd );  

        //-- Show DLL's Control Panel
        
        BOOL           ShowControl        ( HWND hWnd, DWORD flag );

        //-- Return info about image
        
        BMMRES         GetImageInfo       ( BitmapInfo *fbi );        

        //-- Image Input
        
        BitmapStorage *Load               ( BitmapInfo *fbi, Bitmap *map, BMMRES *status);

        //-- Image Output
        
        BMMRES         OpenOutput         ( BitmapInfo *fbi, Bitmap *map );
        BMMRES         Write              ( int frame );
        int            Close              ( int flag );
        
        //-- This handler's specialized functions
        
        void           YUVtoRGB           ( BMM_Color_64 *rgb, BYTE *yuv, int len  );

};

#endif

//-- EOF: yuv.h ---------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\io\Yuv\yuv.cpp ===
//-----------------------------------------------------------------------------
// ------------------
// File ....: yuv.cpp
// ------------------
// Author...: Gus J Grubba
// Date ....: July 1995
// Descr....: YUV File I/O Module
//
// History .: Jul, 27 1995 - Started
//            
//-----------------------------------------------------------------------------
        
//-- Include files

#include <Max.h>
#include <bmmlib.h>
#include "yuv.h"
#include "yuvrc.h"

//-- Prototypes

//static BOOL CenterWindow(HWND hWndChild, HWND hWndParent);

//-- Handy macros

#define limit(x) {                      \
    if(x > 0xFFFFFF) x = 0xFFFFFF;      \
    if(x <=  0xFFFF) x = 0;             \
    x  &=  0xFF0000;                    \
}

//-----------------------------------------------------------------------------
//-- File Class

class File {
     public:
        FILE  *stream;
        File  ( const TCHAR *name, const TCHAR *mode) { stream = _tfopen(name,mode); }
        ~File ( ) { Close(); }
        void Close() { if(stream) fclose(stream); stream = NULL; }
};

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved) {
     switch (fdwReason) {
         case DLL_PROCESS_ATTACH:
              if (hInst)
                 return(FALSE);
              hInst = hDLLInst;
              break;
         case DLL_PROCESS_DETACH:
              hInst  = NULL;
              break;
         case DLL_THREAD_ATTACH:
              break;
         case DLL_THREAD_DETACH:
              break;
     }
     return TRUE;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// YUV Class Description

class YUVClassDesc:public ClassDesc {
     
     public:

        int             IsPublic     ( )                   { return 1;                }
        void           *Create       ( BOOL loading=FALSE) { return new BitmapIO_YUV; }
        const TCHAR    *ClassName    ( )                   { return GetString(IDS_YUV);     }
        SClass_ID       SuperClassID ( )                   { return BMM_IO_CLASS_ID;  }
        Class_ID        ClassID      ( )                   { return Class_ID(YUVCLASSID,0);    }
        const TCHAR    *Category     ( )                   { return GetString(IDS_BITMAP_IO); }

};

static YUVClassDesc YUVDesc;

//-----------------------------------------------------------------------------
// Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
     return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
     return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
     switch(i) {
        case  0: return &YUVDesc; break;
        default: return 0;        break;
     }
}

DLLEXPORT ULONG LibVersion ( )  { 
     return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//-----------------------------------------------------------------------------
// *> AboutCtrlDlgProc()
//

BOOL CALLBACK AboutCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     switch (message) {
        
        case WM_INITDIALOG: {
             CenterWindow(hWnd,GetParent(hWnd));
             return 1;
        }

        case WM_COMMAND:

             switch (LOWORD(wParam)) {
                
                case IDOK:              
                     EndDialog(hWnd,1);
                     break;

                case IDCANCEL:
                     EndDialog(hWnd,0);
                     break;
        
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// *> ControlCtrlDlgProc()
//

BOOL CALLBACK ControlCtrlDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) {

     switch (message) {
        
        case WM_INITDIALOG: {
             CenterWindow(hWnd,GetParent(hWnd));
             return 1;
        }

        case WM_COMMAND:

             switch (LOWORD(wParam)) {
                
                case IDOK:              
                     EndDialog(hWnd,1);
                     break;

                case IDCANCEL:
                     EndDialog(hWnd,0);
                     break;
        
             }
             return 1;

     }
     
     return 0;

}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::BitmapIO_YUV()

BitmapIO_YUV::BitmapIO_YUV  ( ) { }

BitmapIO_YUV::~BitmapIO_YUV ( ) { }

//BitmapIO_YUV::BitmapIO_YUV(BitmapStorage *s,BitmapIO *previous,int frame) : BitmapIO(s,previous,frame) { }

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::LongDesc()

const TCHAR *BitmapIO_YUV::LongDesc() {
     return GetString(IDS_YUV_FILE);
}
     
//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::ShortDesc()

const TCHAR *BitmapIO_YUV::ShortDesc() {
     return GetString(IDS_YUV);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::LoadConfigure()

BOOL BitmapIO_YUV::LoadConfigure ( void *ptr ) {
     return 1;
}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::SaveConfigure()

BOOL BitmapIO_YUV::SaveConfigure ( void *ptr ) {
     return 1;
}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::ShowAbout()

void BitmapIO_YUV::ShowAbout(HWND hWnd) {
     DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_YUV_ABOUT),
        hWnd,
        (DLGPROC)AboutCtrlDlgProc,
        (LPARAM)0);
}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::Control()

BOOL BitmapIO_YUV::ShowControl(HWND hWnd, DWORD flag ) {
     return (
        DialogBoxParam(
        hInst,
        MAKEINTRESOURCE(IDD_YUV_CONTROL),
        hWnd,
        (DLGPROC)ControlCtrlDlgProc,
        (LPARAM)0)
     );
}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::GetImageInfo()

BMMRES BitmapIO_YUV::GetImageInfo ( BitmapInfo *fbi ) {

	//-- Get File size

     HANDLE findhandle;
     WIN32_FIND_DATA file;
     findhandle = FindFirstFile(fbi->Name(),&file);
     if (findhandle == INVALID_HANDLE_VALUE)
        return BMMRES_FILENOTFOUND;

     //-- Fill up BitmapInfo 

     if (file.nFileSizeLow == WIDTH * NHEIGHT * 2) {
        fbi->SetWidth(WIDTH);
        fbi->SetHeight(NHEIGHT);
     } else if (file.nFileSizeLow == WIDTH * PHEIGHT * 2) {
        fbi->SetWidth(WIDTH);
        fbi->SetHeight(PHEIGHT);
     } else {
        fbi->SetWidth(WIDTH);
        fbi->SetHeight((WORD)(file.nFileSizeLow / (WIDTH * 2)));
     }
     
     //fbi->SetGamma(1.8f);
     fbi->SetAspect( 1.3333333f / (float)(fbi->Width()) / (float)(fbi->Height()));
     fbi->SetType(BMM_YUV_422);
     fbi->SetFirstFrame(0);
     fbi->SetLastFrame(0);

     FindClose(findhandle);

     return BMMRES_SUCCESS;

}

//-----------------------------------------------------------------------------
//-- BitmapIO_YUV::Load()

BitmapStorage *BitmapIO_YUV::Load(BitmapInfo *fbi, Bitmap *map, BMMRES *status) {

     unsigned char *yuvbuf = NULL;
     BMM_Color_64  *rgbbuf = NULL;
     BitmapStorage *s      = NULL;

	//-- Initialize Status Optimistically

	*status = BMMRES_SUCCESS;

	//-- Make sure nothing weird is going on

	if(openMode != BMM_NOT_OPEN) {
		*status = ProcessImageIOError(fbi,BMMRES_INTERNALERROR);
		return NULL;
	}

     //-- Update Bitmap Info
     
     *status = GetImageInfo(fbi);
     
     if (*status != BMMRES_SUCCESS)
        return(NULL);

     //-- Open YUV File -----------------------------------
     
     File file(fbi->Name(), _T("rb"));

     if (!(inStream = file.stream)) {
		*status = ProcessImageIOError(fbi);
        return NULL;
     }

     //-- Create Image Storage ---------------------------- 
     
     s = BMMCreateStorage(map->Manager(),BMM_TRUE_32);

     if(!s) {
		*status = ProcessImageIOError(fbi,BMMRES_INTERNALERROR);
        return NULL;
     }

     //-- Allocate Image Storage --------------------------
     
     if (s->Allocate(fbi,map->Manager(),BMM_OPEN_R)==0) {
        memory_error_out:
		*status = ProcessImageIOError(fbi,BMMRES_MEMORYERROR);
        goto bail_out;
        io_error_out:
		*status = ProcessImageIOError(fbi);
        bail_out:
        if (s) 
           delete s;
        if (yuvbuf)
           free(yuvbuf);
        if (rgbbuf)
           free(rgbbuf);
        return NULL;
     }

     //-- Allocate Buffers --------------------------------
     
     yuvbuf=(unsigned char *)malloc(fbi->Width()*2);
     rgbbuf=(BMM_Color_64  *)malloc(fbi->Width()*sizeof(BMM_Color_64));

     if(!yuvbuf || !rgbbuf)
        goto memory_error_out;
     
     //-- Read Image

     int pixels = fbi->Width() * fbi->Height();
     int rows   = 0;
     
     while (pixels) {
        pixels = fread(yuvbuf,2,fbi->Width(),inStream);
        if (pixels != fbi->Width() && pixels != 0)  {
           goto io_error_out;
        }
        if (pixels)  {
           YUVtoRGB(rgbbuf,yuvbuf,fbi->Width());
           if (s->PutPixels(0,rows,fbi->Width(),rgbbuf)!=1)
              goto io_error_out;
           rows++;
           if (rows>fbi->Height()) break;
        }   

        //-- Progress Report
        
        if (fbi->GetUpdateWindow())
           SendMessage(fbi->GetUpdateWindow(),BMM_PROGRESS,rows,fbi->Height());

     }
     
     if (yuvbuf)
        free(yuvbuf);
     if (rgbbuf)
        free(rgbbuf);

     //-- Set the storage's BitmapInfo

     s->bi.CopyImageInfo(fbi);
     return  s;

}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::OpenOutput()
//

BMMRES BitmapIO_YUV::OpenOutput(BitmapInfo *fbi, Bitmap *map) {

	if (openMode != BMM_NOT_OPEN)
		return (ProcessImageIOError(fbi,BMMRES_INTERNALERROR));
		
	if (!map)
		return (ProcessImageIOError(fbi,BMMRES_INTERNALERROR));
		
     //-- Save Image Info Data

     bi.CopyImageInfo(fbi);    

     this->map   = map;
     openMode    = BMM_OPEN_W;

     return BMMRES_SUCCESS;

}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::Write()
//
//

BMMRES BitmapIO_YUV::Write(int frame) {

	//-- If we haven't gone through an OpenOutput(), leave

	if (openMode != BMM_OPEN_W)
		return (ProcessImageIOError(&bi,BMMRES_INTERNALERROR));


	return (ProcessImageIOError(&bi,BMMRES_INTERNALERROR));
	
}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::Close()
//

int  BitmapIO_YUV::Close( int flag ) {

     return 1;

}

//-----------------------------------------------------------------------------
// #> BitmapIO_YUV::YUVtoRGB()
//

void BitmapIO_YUV::YUVtoRGB (BMM_Color_64 *rgb, unsigned char *yuv, int len) {

     int j;  
     long y, u, v, y1, r, g, b;

     for(j=0;j<(WIDTH/2);j++) {
        
        u = *yuv++;
        u -= 128;
        y = *yuv++;
        y -= 16;
        
        if(y<0) y = 0;

        v  = *yuv++;
        v -= 128;
        y1 = *yuv++;
        y1-= 16;
        
        if(y1<0) y1 = 0;

        y *= 76310;
        r  = y + 104635*v;
        g  = y + -25690*u + -53294*v;
        b  = y + 132278*u;

        limit(r);
        limit(g);
        limit(b);

        rgb->r = (WORD)(r>>8);
        rgb->g = (WORD)(g>>8);
        rgb->b = (WORD)(b>>8);
        rgb->a = 0;
        rgb++;

        y1 *= 76310;
        r  =    y1 + 104635*v;
        g  =    y1 + -25690*u + -53294*v;
        b  =    y1 + 132278*u;

        limit(r);
        limit(g);
        limit(b);
        
        rgb->r = (WORD)(r>>8);
        rgb->g = (WORD)(g>>8);
        rgb->b = (WORD)(b>>8);
        rgb->a = 0;
        rgb++;

    }

}

//-- EOF: yuv.cpp -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\knots\knot.cpp ===
/**********************************************************************
 *<
	FILE: knot.cpp

	DESCRIPTION:  Defines a PQ-Torus Knot object class

	CREATED BY: Scott Morrison based on the torus MAX primitive

	HISTORY: created 30 November, 1995
	         Internationalized by Audrey Peterson 1996

 *>	Copyright (c) 1995,1996  All Rights Reserved.
 **********************************************************************/

#include "knotbase.h"
#include "surf_api.h"

#define KNOT_CLASS_ID 0x720

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

class KnotObject : public SimpleObject, public IParamArray {
public:
  // Class vars
  static IParamMap *pmapCreate;
  static IParamMap *pmapTypeIn;
  static IParamMap *pmapParam;
  static IObjParam *ip;
  static int dlgSegments, dlgSides;		
  static int dlgCreateMeth;
  static int dlgSmooth;	
  static int dlgBaseCurve;
  static float dlgLumps;	
  static float dlgLumpHeight;
  static float dlgP;
  static float dlgQ;
  static float dlgE;	
  static float dlgTwist;	
  static float dlgRadius2;	
  static float dlgWarpHeight;
  static float dlgWarpFreq;
  static Point3 crtPos;		
  static float crtRadius1;
  static float crtRadius2;	
  static int   dlgGenUV;
  static float dlgUTile;
  static float dlgVTile;
  static float dlgUOff;
  static float dlgVOff;
  
  friend void resetKnotParams(); // mjm - 1.26.99

  KnotObject();
		
  // From BaseObject
  CreateMouseCallBack* GetCreateMouseCallBack();
  void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);		
  void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
  TCHAR *GetObjectName() { return GetString(IDS_AP_KNOTNAME); }
  BOOL HasUVW();
  void SetGenUVW(BOOL sw);

  // Animatable methods		
  void DeleteThis() { delete this; }
  Class_ID ClassID() { return Class_ID( KNOT_CLASS_ID,0); }  
		
  // From ref
  RefTargetHandle Clone(RemapDir& remap = NoRemap());		
  IOResult Load(ILoad *iload);

  // From IParamArray
  BOOL SetValue(int i, TimeValue t, int v);
  BOOL SetValue(int i, TimeValue t, float v);
  BOOL SetValue(int i, TimeValue t, Point3 &v);
  BOOL GetValue(int i, TimeValue t, int &v, Interval &ivalid);
  BOOL GetValue(int i, TimeValue t, float &v, Interval &ivalid);
  BOOL GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid);

  // From SimpleObject
  void BuildMesh(TimeValue t);
  BOOL OKtoDisplay(TimeValue t);
  void InvalidateUI();
  ParamDimension *GetParameterDim(int pbIndex);
  TSTR GetParameterName(int pbIndex);
  Object* ConvertToType(TimeValue t, Class_ID obtype);
  int CanConvertToType(Class_ID obtype);
  void GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist);
};

// segments  = sides
// lsegments = segments

#define MIN_SEGMENTS	4
#define MAX_SEGMENTS	2000

#define MIN_SIDES	3
#define MAX_SIDES	200

#define MIN_RADIUS	float(0)
#define MAX_RADIUS	float( 1.0E30)
#define MIN_PQ	        float(1)
#define MAX_PQ 	        float(25)
#define MIN_E	        float(0.1)
#define MAX_E 	        float(10.0)
#define MIN_LUMPS       float(0)
#define MAX_LUMPS       float(500)
#define MIN_LUMP_HEIGHT float(-4.0)
#define MAX_LUMP_HEIGHT float(4.0)
#define MIN_ROTATION    float(0)
#define MAX_ROTATION    float(360)
#define MIN_TILE        float(-10000)
#define MAX_TILE        float(1000)
#define MIN_OFF         float(-10)
#define MAX_OFF         float(100)
#define MIN_WARP_HEIGHT float(-2)
#define MAX_WARP_HEIGHT  float(4)
#define MIN_WARP_FREQ   float(0)
#define MAX_WARP_FREQ   float(100)

#define DEF_SEGMENTS 	120
#define DEF_SIDES	12
#define DEF_P           2.0f
#define DEF_Q           3.0f
#define DEF_E           1.0f
#define DEF_TWIST       0.0f
#define DEF_RADIUS	0.1f
#define DEF_RADIUS2   	10.0f
#define DEF_LUMPS       0.0f
#define DEF_LUMP_HEIGHT 0.0f
#define DEF_GENUV       0
#define DEF_UTILE       1.0f
#define DEF_VTILE       1.0f
#define DEF_UOFF        0.0f
#define DEF_VOFF        0.0f
#define DEF_WARP_HEIGHT 0.0f
#define DEF_WARP_FREQ   0.0f

#define SMOOTH_ON	2
#define SMOOTH_SIDES	1
#define SMOOTH_OFF	0

#define BASE_KNOT       0
#define BASE_CIRCLE     1


//--- ClassDescriptor and class vars ---------------------------------

class KnotClassDesc:public ClassDesc {
public:									   int 			IsPublic() { return 1; }

  void *			Create(BOOL loading = FALSE) { return new KnotObject; }
  const TCHAR *	ClassName() { return GetString(IDS_AP_KNOTNAME_CDESC); }
  SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
  Class_ID		ClassID() { return Class_ID(KNOT_CLASS_ID,0); }
  const TCHAR* 	Category() { return GetString(IDS_AP_EXTENDED); }
  void			ResetClassParams(BOOL fileReset) { if(fileReset) resetKnotParams(); } // mjm - 1.26.99
};

static KnotClassDesc knotDesc;

ClassDesc* GetTorusKnotDesc() { return &knotDesc; }

// class variable for sphere class.
IObjParam *KnotObject::ip         = NULL;
int KnotObject::dlgSegments       = DEF_SEGMENTS;
int KnotObject::dlgSides          = DEF_SIDES;
int KnotObject::dlgCreateMeth     = 1; // create_radius
int KnotObject::dlgSmooth         = SMOOTH_ON;
int KnotObject::dlgBaseCurve      = BASE_KNOT;
float KnotObject::dlgRadius2      = DEF_RADIUS2;
IParamMap *KnotObject::pmapCreate = NULL;
IParamMap *KnotObject::pmapTypeIn = NULL;
IParamMap *KnotObject::pmapParam  = NULL;
Point3 KnotObject::crtPos         = Point3(0,0,0);
float KnotObject::crtRadius1      = 0.0f;
float KnotObject::crtRadius2      = DEF_RADIUS2;
float KnotObject::dlgP             = DEF_P;
float KnotObject::dlgQ             = DEF_Q;
float KnotObject::dlgE             = DEF_E;
float KnotObject::dlgTwist         = DEF_TWIST;
float KnotObject::dlgLumpHeight    = DEF_LUMP_HEIGHT;
float KnotObject::dlgLumps         = DEF_LUMPS;
int   KnotObject::dlgGenUV         = DEF_GENUV;
float KnotObject::dlgUTile         = DEF_UTILE;
float KnotObject::dlgVTile         = DEF_VTILE;
float KnotObject::dlgUOff          = DEF_UOFF;
float KnotObject::dlgVOff          = DEF_VOFF;
float KnotObject::dlgWarpHeight    = DEF_WARP_HEIGHT;
float KnotObject::dlgWarpFreq      = DEF_WARP_FREQ;

// mjm - begin - 1.26.99
void resetKnotParams() 
{
	KnotObject::dlgSegments		= DEF_SEGMENTS;
	KnotObject::dlgSides		= DEF_SIDES;
	KnotObject::dlgCreateMeth	= 1; // create_radius
	KnotObject::dlgSmooth		= SMOOTH_ON;
	KnotObject::dlgBaseCurve	= BASE_KNOT;
	KnotObject::dlgRadius2		= DEF_RADIUS2;
	KnotObject::crtPos			= Point3(0,0,0);
	KnotObject::crtRadius1      = 0.0f;
	KnotObject::crtRadius2		= DEF_RADIUS2;
	KnotObject::dlgP			= DEF_P;
	KnotObject::dlgQ			= DEF_Q;
	KnotObject::dlgE			= DEF_E;
	KnotObject::dlgTwist		= DEF_TWIST;
	KnotObject::dlgLumpHeight	= DEF_LUMP_HEIGHT;
	KnotObject::dlgLumps		= DEF_LUMPS;
	KnotObject::dlgGenUV		= DEF_GENUV;
	KnotObject::dlgUTile		= DEF_UTILE;
	KnotObject::dlgVTile		= DEF_VTILE;
	KnotObject::dlgUOff			= DEF_UOFF;
	KnotObject::dlgVOff			= DEF_VOFF;
	KnotObject::dlgWarpHeight	= DEF_WARP_HEIGHT;
	KnotObject::dlgWarpFreq		= DEF_WARP_FREQ;
}
// mjm - end


//--- Parameter map/block descriptors -------------------------------

// Parameter map indices
#define PB_RADIUS		0
#define PB_RADIUS2		1
#define PB_ROTATION		2
#define PB_TWIST		3
#define PB_SEGMENTS		4
#define PB_SIDES		5
#define PB_SMOOTH		6
#define PB_P	7
#define PB_Q	8
#define PB_E    9
#define PB_LUMPS    10
#define PB_LUMP_HEIGHT    11
#define PB_BASE_CURVE     12
#define PB_GENUV          13
#define PB_UTILE          14
#define PB_VTILE          15
#define PB_UOFF           16
#define PB_VOFF           17
#define PB_WARP_HEIGHT    18
#define PB_WARP_FREQ      19

// Non-parameter block indices
#define PB_CREATEMETHOD		0
#define PB_TI_POS			1
#define PB_TI_RADIUS1		2
#define PB_TI_RADIUS2		3


//
//
//	Creation method

static int createMethIDs[] = {IDC_CREATEDIAMETER,IDC_CREATERADIUS};

static ParamUIDesc descCreate[] = {
  // Diameter/radius
  ParamUIDesc(PB_CREATEMETHOD,TYPE_RADIO,createMethIDs,2)
};
#define CREATEDESC_LENGH 1


//
//
// Type in
static ParamUIDesc descTypeIn[] = {
	
  // Position
  ParamUIDesc(
              PB_TI_POS,
              EDITTYPE_UNIVERSE,
              IDC_TI_POSX,IDC_TI_POSXSPIN,
              IDC_TI_POSY,IDC_TI_POSYSPIN,
              IDC_TI_POSZ,IDC_TI_POSZSPIN,
              -99999999.0f,99999999.0f,
              SPIN_AUTOSCALE),
	
  // Radius 1
  ParamUIDesc(
              PB_TI_RADIUS1,
              EDITTYPE_UNIVERSE,
              IDC_RADIUS1,IDC_RADSPINNER1,
              MIN_RADIUS,MAX_RADIUS,
              SPIN_AUTOSCALE),
	
  // Radius 2
  ParamUIDesc(
              PB_TI_RADIUS2,
              EDITTYPE_UNIVERSE,
              IDC_RADIUS2,IDC_RAD2SPINNER,
              MIN_RADIUS,MAX_RADIUS,
              SPIN_AUTOSCALE),	
};
#define TYPEINDESC_LENGH 3


//
//
// Parameters

static int smoothIDs[] = {IDC_SMOOTH_NONE,IDC_SMOOTH_SIDES,IDC_SMOOTH_ALL};

static int curveIDs[] = {IDC_KNOT_CURVE,IDC_CIRCLE_CURVE};

static ParamUIDesc descParam[] = {
  // Radius
  ParamUIDesc(
              PB_RADIUS,
              EDITTYPE_UNIVERSE,
              IDC_RADIUS1,IDC_RADSPINNER1,
              MIN_RADIUS,MAX_RADIUS,
              SPIN_AUTOSCALE),	

  // Radius
  ParamUIDesc(
              PB_RADIUS2,
              EDITTYPE_UNIVERSE,
              IDC_RADIUS2,IDC_RAD2SPINNER,
              MIN_RADIUS,MAX_RADIUS,
              SPIN_AUTOSCALE),	

  // Rotation
  ParamUIDesc(
              PB_ROTATION,
              EDITTYPE_FLOAT,
              IDC_TORUS_ROT,IDC_TORUS_ROTSPIN,
              MIN_ROTATION,MAX_ROTATION,
              1.0f,
              stdAngleDim),	

  // Twist
  ParamUIDesc(
              PB_TWIST,
              EDITTYPE_FLOAT,
              IDC_TORUS_TWIST,IDC_TORUS_TWISTSPIN,
              0.0f,1000.0f,
              1.0f,
              defaultDim),	

  // Segments
  ParamUIDesc(
              PB_SEGMENTS,
              EDITTYPE_INT,
              IDC_SEGMENTS,IDC_SEGSPINNER,
              (float)MIN_SEGMENTS,(float)MAX_SEGMENTS,
              1.0f),
	
  // Sides
  ParamUIDesc(
              PB_SIDES,
              EDITTYPE_INT,
              IDC_SIDES,IDC_SIDESPINNER,
              (float)MIN_SIDES,(float)MAX_SIDES,
              1.0f),
	
  // Smooth	
  ParamUIDesc(PB_SMOOTH,TYPE_RADIO,smoothIDs,3),

  // P
  ParamUIDesc(
              PB_P,
              EDITTYPE_FLOAT,
              IDC_P,IDC_PSPIN,
              MIN_PQ,MAX_PQ,
              0.25f,
              defaultDim),	

  // Q
  ParamUIDesc(
              PB_Q,
              EDITTYPE_FLOAT,
              IDC_Q,IDC_QSPIN,
              MIN_PQ,MAX_PQ,		
              0.25f,
              defaultDim),

  // Ecentricity
  ParamUIDesc(
              PB_E,
              EDITTYPE_FLOAT,
              IDC_E,IDC_ESPIN,
              MIN_E,MAX_E,		
              0.05f,
              defaultDim),

  // Lumps
  ParamUIDesc(
              PB_LUMPS,
              EDITTYPE_FLOAT,
              IDC_LUMPS,IDC_LUMPSSPIN,
              MIN_LUMPS,MAX_LUMPS,		
              1.0f,
              defaultDim),

  // Lump Height
  ParamUIDesc(
              PB_LUMP_HEIGHT,
              EDITTYPE_FLOAT,
              IDC_LUMP_HEIGHT,IDC_LUMP_HEIGHT_SPIN,
              MIN_LUMP_HEIGHT,MAX_LUMP_HEIGHT,		
              0.01f,
              defaultDim),

  // Base Curve
  ParamUIDesc(PB_BASE_CURVE,TYPE_RADIO,curveIDs,2),

  // Generate UV
  ParamUIDesc(PB_GENUV, TYPE_SINGLECHEKBOX, IDC_GENUVS),

  // U Tile
  ParamUIDesc(
              PB_UTILE,
              EDITTYPE_FLOAT,
              IDC_UTILE,IDC_UTILESPIN,
              MIN_TILE,MAX_TILE,		
              0.1f,
              defaultDim),
  // V Tile
  ParamUIDesc(
              PB_VTILE,
              EDITTYPE_FLOAT,
              IDC_VTILE,IDC_VTILESPIN,
              MIN_TILE,MAX_TILE,		
              0.1f,
              defaultDim),
  

  // U Off
  ParamUIDesc(
              PB_UOFF,
              EDITTYPE_FLOAT,
              IDC_UOFF,IDC_UOFFSPIN,
              MIN_OFF,MAX_OFF,		
              0.1f,
              defaultDim),
  // V Off
  ParamUIDesc(
              PB_VOFF,
              EDITTYPE_FLOAT,
              IDC_VOFF,IDC_VOFFSPIN,
              MIN_OFF,MAX_OFF,		
              0.1f,
              defaultDim),
  

  // Warp Height
  ParamUIDesc(
              PB_WARP_HEIGHT,
              EDITTYPE_FLOAT,
              IDC_WARP_HEIGHT,IDC_WARP_HEIGHT_SPIN,
              MIN_WARP_HEIGHT,MAX_WARP_HEIGHT,		
              0.01f,
              defaultDim),

  // Warp Freq
  ParamUIDesc(
              PB_WARP_FREQ,
              EDITTYPE_FLOAT,
              IDC_WARP_FREQ,IDC_WARP_FREQ_SPIN,
              MIN_WARP_FREQ,MAX_WARP_FREQ,		
              1.0f,
              defaultDim),

};
#define PARAMDESC_LENGH 20

static ParamBlockDescID descVer0[] = {
  { TYPE_FLOAT, NULL, TRUE, 0 },
  { TYPE_FLOAT, NULL, TRUE, 1 },
  { TYPE_INT, NULL, TRUE, 2 },
  { TYPE_INT, NULL, TRUE, 3 },
  { TYPE_INT, NULL, TRUE, 4 } };

static ParamBlockDescID descVer1[] = {
  { TYPE_FLOAT, NULL, TRUE, 0 },
  { TYPE_FLOAT, NULL, TRUE, 1 },
  { TYPE_FLOAT, NULL, TRUE, 8 },
  { TYPE_INT, NULL, TRUE, 2 },
  { TYPE_INT, NULL, TRUE, 3 },
  { TYPE_INT, NULL, TRUE, 4 },
  { TYPE_FLOAT, NULL, TRUE, 6 },
  { TYPE_FLOAT, NULL, TRUE, 7 } };

static ParamBlockDescID descVer2[] = {
  { TYPE_FLOAT, NULL, TRUE, 0 },
  { TYPE_FLOAT, NULL, TRUE, 1 },
  { TYPE_FLOAT, NULL, TRUE, 8 },
  { TYPE_FLOAT, NULL, TRUE, 9 },
  { TYPE_INT, NULL, TRUE, 2 },
  { TYPE_INT, NULL, TRUE, 3 },
  { TYPE_INT, NULL, TRUE, 4 },
  { TYPE_FLOAT, NULL, TRUE, 6 },
  { TYPE_FLOAT, NULL, TRUE, 7 } };

static ParamBlockDescID descVer3[] = {
  { TYPE_FLOAT, NULL, TRUE, 0 },
  { TYPE_FLOAT, NULL, TRUE, 1 },
  { TYPE_FLOAT, NULL, TRUE, 2 },
  { TYPE_FLOAT, NULL, TRUE, 3 },
  { TYPE_INT, NULL, TRUE, 4 },
  { TYPE_INT, NULL, TRUE, 5 },
  { TYPE_INT, NULL, TRUE, 6 },
  { TYPE_INT, NULL, TRUE, 7 },
  { TYPE_FLOAT, NULL, TRUE, 8 },
  { TYPE_FLOAT, NULL, TRUE, 9 }, 
  { TYPE_FLOAT, NULL, TRUE, 10 }, 
  { TYPE_FLOAT, NULL, TRUE, 11 }, 
  { TYPE_FLOAT, NULL, TRUE, 12 } };

static ParamBlockDescID descVer4[] = {
  { TYPE_FLOAT, NULL, TRUE, 0 },
  { TYPE_FLOAT, NULL, TRUE, 1 },
  { TYPE_FLOAT, NULL, TRUE, 2 },
  { TYPE_FLOAT, NULL, TRUE, 3 },
  { TYPE_INT, NULL, TRUE, 4 },
  { TYPE_INT, NULL, TRUE, 5 },
  { TYPE_INT, NULL, TRUE, 6 },
  { TYPE_INT, NULL, TRUE, 7 },
  { TYPE_FLOAT, NULL, TRUE, 8 },
  { TYPE_FLOAT, NULL, TRUE, 9 }, 
  { TYPE_FLOAT, NULL, TRUE, 10 }, 
  { TYPE_FLOAT, NULL, TRUE, 11 }, 
  { TYPE_FLOAT, NULL, TRUE, 12 },
  { TYPE_INT, NULL, TRUE, 13 } };

static ParamBlockDescID descVer5[] = {
  { TYPE_FLOAT, NULL, TRUE, 0 },
  { TYPE_FLOAT, NULL, TRUE, 1 },
  { TYPE_FLOAT, NULL, TRUE, 2 },
  { TYPE_FLOAT, NULL, TRUE, 3 },
  { TYPE_INT, NULL, TRUE, 4 },
  { TYPE_INT, NULL, TRUE, 5 },
  { TYPE_INT, NULL, TRUE, 6 },
  { TYPE_INT, NULL, TRUE, 7 },
  { TYPE_FLOAT, NULL, TRUE, 8 },
  { TYPE_FLOAT, NULL, TRUE, 9 }, 
  { TYPE_FLOAT, NULL, TRUE, 10 }, 
  { TYPE_FLOAT, NULL, TRUE, 11 }, 
  { TYPE_FLOAT, NULL, TRUE, 12 },
  { TYPE_INT, NULL, TRUE, 13 },
  { TYPE_INT, NULL, TRUE, 14 },
  { TYPE_FLOAT, NULL, TRUE, 15 },
  { TYPE_FLOAT, NULL, TRUE, 16 },
  { TYPE_FLOAT, NULL, TRUE, 17 },
  { TYPE_FLOAT, NULL, TRUE, 18 } };

static ParamBlockDescID descVer6[] = {
  { TYPE_FLOAT, NULL, TRUE, 0 },
  { TYPE_FLOAT, NULL, TRUE, 1 },
  { TYPE_FLOAT, NULL, TRUE, 2 },
  { TYPE_FLOAT, NULL, TRUE, 3 },
  { TYPE_INT, NULL, TRUE, 4 },
  { TYPE_INT, NULL, TRUE, 5 },
  { TYPE_INT, NULL, FALSE, 6 },
  { TYPE_INT, NULL, FALSE, 7 },
  { TYPE_FLOAT, NULL, TRUE, 8 },
  { TYPE_FLOAT, NULL, TRUE, 9 }, 
  { TYPE_FLOAT, NULL, TRUE, 10 }, 
  { TYPE_FLOAT, NULL, TRUE, 11 }, 
  { TYPE_FLOAT, NULL, TRUE, 12 },
  { TYPE_INT, NULL, FALSE, 13 },
  { TYPE_INT, NULL, FALSE, 14 },
  { TYPE_FLOAT, NULL, TRUE, 15 },
  { TYPE_FLOAT, NULL, TRUE, 16 },
  { TYPE_FLOAT, NULL, TRUE, 17 },
  { TYPE_FLOAT, NULL, TRUE, 18 },
  { TYPE_FLOAT, NULL, TRUE, 19 },
  { TYPE_FLOAT, NULL, TRUE, 20 } };

static ParamBlockDescID descVer7[] = {
  { TYPE_FLOAT, NULL, TRUE, 0 },
  { TYPE_FLOAT, NULL, TRUE, 1 },
  { TYPE_FLOAT, NULL, TRUE, 2 },
  { TYPE_FLOAT, NULL, TRUE, 3 },
  { TYPE_INT, NULL, TRUE, 4 },
  { TYPE_INT, NULL, TRUE, 5 },
  { TYPE_INT, NULL, FALSE, 6 },
  { TYPE_FLOAT, NULL, TRUE, 8 },
  { TYPE_FLOAT, NULL, TRUE, 9 }, 
  { TYPE_FLOAT, NULL, TRUE, 10 }, 
  { TYPE_FLOAT, NULL, TRUE, 11 }, 
  { TYPE_FLOAT, NULL, TRUE, 12 },
  { TYPE_INT, NULL, FALSE, 13 },
  { TYPE_INT, NULL, FALSE, 14 },
  { TYPE_FLOAT, NULL, TRUE, 15 },
  { TYPE_FLOAT, NULL, TRUE, 16 },
  { TYPE_FLOAT, NULL, TRUE, 17 },
  { TYPE_FLOAT, NULL, TRUE, 18 },
  { TYPE_FLOAT, NULL, TRUE, 19 },
  { TYPE_FLOAT, NULL, TRUE, 20 } };

#define PBLOCK_LENGTH	20

// Array of old versions
static ParamVersionDesc versions[] = {
  ParamVersionDesc(descVer0,5,0),
  ParamVersionDesc(descVer1,9,1),
  ParamVersionDesc(descVer2,9,2),
  ParamVersionDesc(descVer3,13,3),
  ParamVersionDesc(descVer4,14,4),
  ParamVersionDesc(descVer5,19,5),
  ParamVersionDesc(descVer6,19,6)
};

#define NUM_OLDVERSIONS	7

// Current version
static ParamVersionDesc curVersion(descVer7,PBLOCK_LENGTH,7);
#define CURRENT_VERSION	7


//--- TypeInDlgProc --------------------------------

class KnotTypeInDlgProc : public ParamMapUserDlgProc {
public:
  KnotObject *ob;

  KnotTypeInDlgProc(KnotObject *o) {ob=o;}
  BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL KnotTypeInDlgProc::DlgProc(TimeValue t,IParamMap *map,HWND
                                hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
  switch (msg) {
  case WM_COMMAND:
    switch (LOWORD(wParam)) {
    case IDC_TI_CREATE: {
      if (ob->crtRadius1==0.0) return TRUE;
					
      // We only want to set the value if the object is 
      // not in the scene.
      if (ob->TestAFlag(A_OBJ_CREATING)) {
        ob->pblock->SetValue(PB_RADIUS,0,ob->crtRadius1);
        ob->pblock->SetValue(PB_RADIUS2,0,ob->crtRadius2);
      }

      Matrix3 tm(1);
      tm.SetTrans(ob->crtPos);
      ob->ip->NonMouseCreate(tm);
      // NOTE that calling NonMouseCreate will cause this
      // object to be deleted. DO NOT DO ANYTHING BUT RETURN.
      return TRUE;	
    }
    }
    break;	
  }
  return FALSE;
}


class KnotParamDlgProc : public ParamMapUserDlgProc {
public:
  KnotObject *ob;

  KnotParamDlgProc(KnotObject *o) {ob=o;}
  BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
  void DeleteThis() {delete this;}
};

static HWND hDlg;

BOOL KnotParamDlgProc::DlgProc(TimeValue t,IParamMap *map,HWND
                                hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
  int baseCurve;
  if (ob->pmapParam) {
    ob->pblock->GetValue(PB_BASE_CURVE,t,baseCurve,FOREVER);
    // Enable/disable controls
    EnableWindow(GetDlgItem(ob->pmapParam->GetHWnd(), IDC_P),
                 baseCurve == BASE_KNOT);
    EnableWindow(GetDlgItem(ob->pmapParam->GetHWnd(), IDC_Q),
                 baseCurve == BASE_KNOT);

    EnableWindow(GetDlgItem(ob->pmapParam->GetHWnd(), IDC_PSPIN),
                 baseCurve == BASE_KNOT);
    EnableWindow(GetDlgItem(ob->pmapParam->GetHWnd(), IDC_QSPIN),
                 baseCurve == BASE_KNOT);

    EnableWindow(GetDlgItem(ob->pmapParam->GetHWnd(), IDC_WARP_HEIGHT),
                 baseCurve == BASE_CIRCLE);
    EnableWindow(GetDlgItem(ob->pmapParam->GetHWnd(), IDC_WARP_FREQ),
                 baseCurve == BASE_CIRCLE);

    EnableWindow(GetDlgItem(ob->pmapParam->GetHWnd(), IDC_WARP_HEIGHT_SPIN),
                 baseCurve == BASE_CIRCLE);
    EnableWindow(GetDlgItem(ob->pmapParam->GetHWnd(), IDC_WARP_FREQ_SPIN),
                 baseCurve == BASE_CIRCLE);

  }
    
  return FALSE;
}


//--- Knot methods -------------------------------


KnotObject::KnotObject()
{	
  MakeRefByID(FOREVER, 0,
              CreateParameterBlock(descVer7, PBLOCK_LENGTH, CURRENT_VERSION));
  assert(pblock);

  pblock->SetValue(PB_SMOOTH,0,dlgSmooth);
  pblock->SetValue(PB_BASE_CURVE,0,dlgBaseCurve);
  pblock->SetValue(PB_SEGMENTS,0,dlgSegments);
  pblock->SetValue(PB_SIDES,0,dlgSides);	
  pblock->SetValue(PB_RADIUS,0,crtRadius1);
  pblock->SetValue(PB_RADIUS2,0,crtRadius2);	
  pblock->SetValue(PB_P,0,dlgP);	
  pblock->SetValue(PB_Q,0,dlgQ);	
  pblock->SetValue(PB_E,0,dlgE);	
  pblock->SetValue(PB_TWIST,0,dlgTwist);	
  pblock->SetValue(PB_LUMPS,0,dlgLumps);	
  pblock->SetValue(PB_LUMP_HEIGHT,0,dlgLumpHeight);	
  pblock->SetValue(PB_GENUV,0,dlgGenUV);	
  pblock->SetValue(PB_UTILE,0,dlgUTile);	
  pblock->SetValue(PB_VTILE,0,dlgVTile);	
  pblock->SetValue(PB_UOFF,0,dlgUOff);	
  pblock->SetValue(PB_VOFF,0,dlgVOff);	
  pblock->SetValue(PB_WARP_HEIGHT,0,dlgWarpHeight);	
  pblock->SetValue(PB_WARP_FREQ,0,dlgWarpFreq);	
}

IOResult KnotObject::Load(ILoad *iload) 
{
  iload->RegisterPostLoadCallback(new ParamBlockPLCB(versions,
                                                     NUM_OLDVERSIONS,
                                                     &curVersion,this,0));
  return IO_OK;
}


void KnotObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                  Animatable *prev )
{
  SimpleObject::BeginEditParams(ip,flags,prev);
  this->ip = ip;

  if (pmapCreate && pmapParam && pmapTypeIn) {
		
    // Left over from last Knot ceated		
    pmapCreate->SetParamBlock(this);
    pmapTypeIn->SetParamBlock(this);
    pmapParam->SetParamBlock(pblock);
  } else {
		
    // Gotta make a new one.
    if (flags&BEGIN_EDIT_CREATE) {
      pmapCreate = CreateCPParamMap(descCreate,CREATEDESC_LENGH,
                                    this,
                                    ip,
                                    hInstance,
                                    MAKEINTRESOURCE(IDD_TORUSPARAM1),
                                    GetString(IDS_AP_CREATE_DIALOG),
                                    0);

			
      pmapTypeIn = CreateCPParamMap(descTypeIn,TYPEINDESC_LENGH,
                                    this,
                                    ip,
                                    hInstance,
                                    MAKEINTRESOURCE(IDD_TORUSPARAM3),
                                    GetString(IDS_AP_KEYBOARDENTRY),
                                    APPENDROLL_CLOSED);			
    }

    pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGH,
                                 pblock,
                                 ip,
                                 hInstance,
                                 MAKEINTRESOURCE(IDD_KNOTPARAM2),
                                 GetString(IDS_AP_PARAMETERS),
                                 0);
  }

  if(pmapTypeIn) {
    // A callback for the type in.
    pmapTypeIn->SetUserDlgProc(new KnotTypeInDlgProc(this));
  }
  if(pmapParam) {
    // A callback for the type in.
    pmapParam->SetUserDlgProc(new KnotParamDlgProc(this));
  }
}
		
void KnotObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{
  SimpleObject::EndEditParams(ip,flags,next);
  this->ip = NULL;

  if (flags&END_EDIT_REMOVEUI ) {
    if (pmapCreate) DestroyCPParamMap(pmapCreate);
    if (pmapTypeIn) DestroyCPParamMap(pmapTypeIn);
    DestroyCPParamMap(pmapParam);
    pmapParam  = NULL;
    pmapTypeIn = NULL;
    pmapCreate = NULL;
  }

  // Save these values in class variables so the next object created will inherit them.
  pblock->GetValue(PB_SIDES,ip->GetTime(),dlgSides,FOREVER);
  pblock->GetValue(PB_SEGMENTS,ip->GetTime(),dlgSegments,FOREVER);
  pblock->GetValue(PB_SMOOTH,ip->GetTime(),dlgSmooth,FOREVER);	
  pblock->GetValue(PB_BASE_CURVE,ip->GetTime(),dlgBaseCurve,FOREVER);	
  pblock->GetValue(PB_RADIUS2,ip->GetTime(),dlgRadius2,FOREVER);
  pblock->GetValue(PB_P,ip->GetTime(),dlgP,FOREVER);
  pblock->GetValue(PB_Q,ip->GetTime(),dlgQ,FOREVER);
  pblock->GetValue(PB_E,ip->GetTime(),dlgE,FOREVER);
  pblock->GetValue(PB_TWIST,ip->GetTime(),dlgTwist,FOREVER);
  pblock->GetValue(PB_LUMPS,ip->GetTime(),dlgLumps,FOREVER);
  pblock->GetValue(PB_LUMP_HEIGHT,ip->GetTime(),dlgLumpHeight,FOREVER);
  pblock->GetValue(PB_GENUV,ip->GetTime(),dlgGenUV,FOREVER);
  pblock->GetValue(PB_UTILE,ip->GetTime(),dlgUTile,FOREVER);
  pblock->GetValue(PB_VTILE,ip->GetTime(),dlgVTile,FOREVER);
  pblock->GetValue(PB_UOFF,ip->GetTime(),dlgUOff,FOREVER);
  pblock->GetValue(PB_VOFF,ip->GetTime(),dlgVOff,FOREVER);
  pblock->GetValue(PB_WARP_HEIGHT,ip->GetTime(),dlgWarpHeight,FOREVER);
  pblock->GetValue(PB_WARP_FREQ,ip->GetTime(),dlgWarpFreq,FOREVER);
}


FrenetFrame::FrenetFrame(Curve3D spaceCurve, float t, float deltaT)
{
  Point3 f0 = (*spaceCurve)(t);
  Point3 f1 = (*spaceCurve)(t+deltaT);
  Point3 t0 = f1 - f0;
  Point3 n0 = f1 + f0;
  Point3 b = CrossProd(t0, n0);
  Point3 n = CrossProd(b, t0);
  float lengthN = Length(n);
  float lengthB = Length(b);
  if (lengthB != 0.0f)
    b = (1.0f / lengthB) * b;
  if (lengthN != 0.0F)
    n = (1.0f / lengthN) * n;
  mValue    = f0;
  mTangent  = t0;
  mNormal   = n;
  mBiNormal = b;
}

Point3 generalKnot(Curve3D spaceCurve, Curve2D planeCurve, float t,
                   float deltaT, float u)
{
  FrenetFrame frame(spaceCurve, t, deltaT);
  Point2 p2 = (*planeCurve)(u, t);
  Point3 p3 = frame.Value() + p2.x * frame.Normal() + p2.y * frame.BiNormal();
  return p3;
}

static float P, Q, E, Radius1, Radius2, Twist, Lumps, LumpHeight, Rotation,
             WarpHeight, WarpFreq;
int BaseCurve;

Point3 torusKnot(float t)
{
  float fac = 4.0f / (2.2f - (float)sin(t * Q));
  Point3 p;
  p.x = Radius1*(fac * (float)cos(P * t))*0.5f;
  p.y = Radius1*(fac * (float)sin(P * t))*0.5f;
  p.z = Radius1*(fac * (float)cos(Q * t))*0.5f;
  return p;
}

Point3 baseCircle(float t)
{
  Point3 p;
  float r = Radius1 + Radius1 * WarpHeight *
    (0.5f - 0.5f * (float) cos(WarpFreq*t));
  p.x = r*((float)cos(t));
  p.y = r*((float)sin(t));
  p.z = 0.0f;
  return p;
}

Point2 circle(float u, float t)
{
  float eInv = 1.0f / E;
  float theta = Twist * t;
  float r = Radius2 + Radius2* LumpHeight *
    (0.5f - 0.5f * (float)cos((t + Rotation) * Lumps));
  Point2 p(E * r * (float)sin(u), eInv * r * (float)cos(u));
  float c = (float) cos(theta);
  float s = (float) sin(theta);
  Point2 p2(p.x*c - p.y*s, p.x*s + p.y*c);
  return p2;
}
BOOL KnotObject::HasUVW() { 
	BOOL genUVs;
	Interval v;
	pblock->GetValue(PB_GENUV, 0, genUVs, v);
	return genUVs; 
	}

void KnotObject::SetGenUVW(BOOL sw) {  
	if (sw==HasUVW()) return;
	pblock->SetValue(PB_GENUV,0, sw);				
	}

void KnotObject::BuildMesh(TimeValue t)
{
	Point3 p;
	int ix, na, nb, nc, nd, jx, kx, jxTex, naTex, nbTex, ncTex, ndTex; // mjm - 5.25.99
	float delTheta, theta;
	float delPhi, phi;
	int sides, segs, smooth;
	float radius,radius2;
	float startTheta = 0.0f;
	int connect;
	int genUV;
	float uTile, vTile, uOff, vOff;
	
	// Start the validity interval at forever and widdle it down.
	ivalid = FOREVER;
	pblock->GetValue(PB_RADIUS,t,radius,ivalid);
	pblock->GetValue(PB_RADIUS2,t,radius2,ivalid);
	pblock->GetValue(PB_ROTATION,t,Rotation,ivalid);
	pblock->GetValue(PB_TWIST,t,Twist,ivalid);
	pblock->GetValue(PB_SEGMENTS,t,segs,ivalid);
	pblock->GetValue(PB_SIDES,t,sides,ivalid);
	pblock->GetValue(PB_SMOOTH,t,smooth,ivalid);
	pblock->GetValue(PB_BASE_CURVE,t,BaseCurve,ivalid);
	pblock->GetValue(PB_P,t,P,ivalid);
	pblock->GetValue(PB_Q,t,Q,ivalid);
	pblock->GetValue(PB_E,t,E,ivalid);
	pblock->GetValue(PB_LUMPS,t,Lumps,ivalid);
	pblock->GetValue(PB_LUMP_HEIGHT,t,LumpHeight,ivalid);
	pblock->GetValue(PB_GENUV,t,genUV,ivalid);
	pblock->GetValue(PB_UTILE,t,uTile,ivalid);
	pblock->GetValue(PB_VTILE,t,vTile,ivalid);
	pblock->GetValue(PB_UOFF,t,uOff,ivalid);
	pblock->GetValue(PB_VOFF,t,vOff,ivalid);
	pblock->GetValue(PB_WARP_HEIGHT,t,WarpHeight,ivalid);
	pblock->GetValue(PB_WARP_FREQ,t,WarpFreq,ivalid);
	LimitValue( radius, MIN_RADIUS, MAX_RADIUS );
	LimitValue( radius2, MIN_RADIUS, MAX_RADIUS );
	LimitValue( segs, MIN_SEGMENTS, MAX_SEGMENTS );
	LimitValue( sides, MIN_SIDES, MAX_SIDES );
	
	delTheta = (float)2.0*PI/(float)segs;
	delPhi   = (float)2.0*PI/(float)sides;
	
	// if P and Q are integers tie up the ends
	connect = (fabs(P - (int)P) < 0.00001 && fabs(Q - (int)Q) < 0.00001);
	if (BaseCurve == BASE_CIRCLE && fabs(WarpFreq - (int)WarpFreq) > 0.00001)
		connect = FALSE;
	
	int nVerts = (sides)*(connect?segs:segs+1); // mjm - 5.13.99
	int nTVerts = (sides+1)*(segs+1);			// mjm - 5.25.99
	int nFaces = 2*sides*segs;
	mesh.setNumVerts(nVerts);
	mesh.setNumFaces(nFaces);
	mesh.setSmoothFlags(smooth);
	
	if (genUV)
	{
		mesh.setNumTVerts(nTVerts); // mjm - 5.25.99
		mesh.setNumTVFaces(nFaces);
	}
	
	theta = startTheta;
	
// Make verts
	Radius1 = radius;
	Radius2 = radius2;
	float deltaT = (2.0f*PI) / 10000.0f;
	int noVertSeg = connect ? segs : segs+1; // mjm - 5.25.99 - if connected, no verts at last segment (same as first segment)
	int nV=0, nTV=0; // mjm - 5.25.99
	for (ix=0; ix<=segs; ix++)
	{
		phi = 0.0f;
		for (jx = 0; jx<=sides; jx++)
		{
			if (ix!=noVertSeg)		// mjm - 5.25.99 - if not skipping vertex segment
			{
				if (BaseCurve == BASE_KNOT)
					p = generalKnot(torusKnot, circle, theta, deltaT, phi);
				else
					p = generalKnot(baseCircle, circle, theta, deltaT, phi);
				if (jx!=sides)		// mjm - 5.25.99 - no verts at last side (same as first side)
					mesh.setVert(nV++, p);
			}
			if (genUV)				// mjm - 5.25.99 - always make texture verts at last segment and last side
				mesh.setTVert(nTV++, uOff + uTile * theta / (2.0f*PI), vOff + vTile * phi / (2.0f*PI), 0.0f);
			phi += delPhi;
		}
		theta += delTheta;
	}

// Make faces
	int nF=0;
	for(ix = 0; ix < segs; ix++)
	{
		jx    = ix * (sides);	// mjm - 5.13.99
		jxTex = ix * (sides+1); // mjm - 5.25.99
		for (kx = 0; kx<sides; kx++)
		{
			na = jx + kx;
			nb = (connect && ix == (segs-1)) ? kx : na+sides; // mjm - 5.13.99
			nd = (kx == (sides-1)) ? jx : na+1;
			nc = nb+nd-na;

			naTex = jxTex + kx;			// mjm - 5.25.99
			nbTex = naTex+sides+1;		// mjm - 5.25.99
			ndTex = naTex+1;			// mjm - 5.25.99
			ncTex = nbTex+ndTex-naTex;	// mjm - 5.25.99

			DWORD grp = 0;
			if (smooth==SMOOTH_SIDES)
			{
				if (kx == sides-1 && (sides&1))
					grp = (1<<2);
				else
					grp = (kx&1) ? (1<<0) : (1<<1);
			}
			else if (smooth > 0)
			{
				grp = 1;
			}
			
			mesh.faces[nF].setEdgeVisFlags(1,1,0);
			mesh.faces[nF].setSmGroup(grp);
			mesh.faces[nF].setVerts( na,nb,nc);
			if (genUV)
				mesh.tvFace[nF].setTVerts(naTex, nbTex, ncTex);
			nF++;
			
			mesh.faces[nF].setEdgeVisFlags(0,1,1);
			mesh.faces[nF].setSmGroup(grp);
			mesh.faces[nF].setVerts(na,nc,nd);
			if (genUV)
				mesh.tvFace[nF].setTVerts(naTex, ncTex, ndTex);
			nF++;
		}
	}
	
	mesh.InvalidateGeomCache();
	mesh.InvalidateTopologyCache();
}




class KnotObjCreateCallBack: public CreateMouseCallBack {
  KnotObject *ob;	
  Point3 p0, p1, p2;
  IPoint2 sp0,sp1,sp2;	
public:
  int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m,
            Matrix3& mat );
  void SetObj(KnotObject *obj) { ob = obj; }
};



int KnotObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                                IPoint2 m, Matrix3& mat ) {
  float r, r2;
  Point3 center;
#ifdef _OSNAP
	if(msg == MOUSE_FREEMOVE)
	{
	#ifdef _3D_CREATE
		vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
	#else
		vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
	#endif
	}
#endif
  if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
    switch(point) {
    case 0:  // only happens with MOUSE_POINT msg				
      sp0 = m;
#ifdef _3D_CREATE
      p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
#else	
      p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
#endif
      mat.SetTrans(p0);
      break;
    case 1:
      mat.IdentityMatrix();
      sp1 = m;							   
#ifdef _3D_CREATE
      p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
#else
      p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
#endif
      if (ob->dlgCreateMeth) {	
        // radius	
        r = Length(p1-p0) - ob->crtRadius2;
        mat.SetTrans(p0);
      } else {
        // diameter
        Point3 center = (p0+p1)/float(2);
        r = Length(center-p0) - ob->crtRadius2;
        mat.SetTrans(center);  // Modify Node's transform
      }
      
      if (msg==MOUSE_POINT) {
          ob->suspendSnap = FALSE;
          if (Length(m-sp0)<3 || Length(p1-p0)<0.1f)
              return CREATE_ABORT;
      }
      
      ob->pblock->SetValue(PB_RADIUS,0,r);
      ob->pmapParam->Invalidate();
				
      if (flags&MOUSE_CTRL) {
        float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
        mat.PreRotateZ(ob->ip->SnapAngle(ang));
      }
      break;
			
    case 2:					
      center = mat.GetTrans();
      mat.IdentityMatrix();
      mat.SetTrans(center);

#ifdef _3D_CREATE
      p2  = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
#else
      p2  = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
#endif
      r   = Length(p1-p0);
      r2  = Length(p2-p0);

      ob->crtRadius2 = (float)fabs(r-r2)/2.0f;
      ob->pblock->SetValue(PB_RADIUS,0,(r2+r)/2);
      ob->pblock->SetValue(PB_RADIUS2,0,ob->crtRadius2);
      ob->pmapParam->Invalidate();
				
      if (flags&MOUSE_CTRL) {
        float ang = (float)atan2(p2.y-p0.y,p2.x-p0.x);					
        mat.PreRotateZ(ob->ip->SnapAngle(ang));
      }

      if (msg==MOUSE_POINT) {					
        return (Length(sp1-sp0)<3)?CREATE_ABORT:CREATE_STOP;
      }
      break;					   
    }
  }
  else
    if (msg == MOUSE_ABORT) {		
      return CREATE_ABORT;
    }

  return TRUE;
}


static KnotObjCreateCallBack knotCreateCB;

CreateMouseCallBack* KnotObject::GetCreateMouseCallBack() {
  knotCreateCB.SetObj(this);
  return(&knotCreateCB);
}

BOOL KnotObject::OKtoDisplay(TimeValue t) 
{
  float radius;
  pblock->GetValue(PB_RADIUS,t,radius,FOREVER);
  if (radius==0.0f) return FALSE;
  else return TRUE;
}


// From ParamArray
BOOL KnotObject::SetValue(int i, TimeValue t, int v) 
{
  switch (i) {
  case PB_CREATEMETHOD: dlgCreateMeth = v; break;
  }		
  return TRUE;
}

BOOL KnotObject::SetValue(int i, TimeValue t, float v)
{
  switch (i) {				
  case PB_TI_RADIUS1: crtRadius1 = v; break;
  case PB_TI_RADIUS2: crtRadius2 = v; break;
  }	
  return TRUE;
}

BOOL KnotObject::SetValue(int i, TimeValue t, Point3 &v) 
{
  switch (i) {
  case PB_TI_POS: crtPos = v; break;
  }		
  return TRUE;
}

BOOL KnotObject::GetValue(int i, TimeValue t, int &v, Interval &ivalid) 
{
  switch (i) {
  case PB_CREATEMETHOD: v = dlgCreateMeth; break;
  }
  return TRUE;
}

BOOL KnotObject::GetValue(int i, TimeValue t, float &v, Interval &ivalid) 
{	
  switch (i) {		
  case PB_TI_RADIUS1: v = crtRadius1; break;
  case PB_TI_RADIUS2: v = crtRadius2; break;
  }
  return TRUE;
}

BOOL KnotObject::GetValue(int i, TimeValue t, Point3 &v, Interval &ivalid) 
{	
  switch (i) {		
  case PB_TI_POS: v = crtPos; break;		
  }
  return TRUE;
}


void KnotObject::InvalidateUI() 
{
  if (pmapParam) pmapParam->Invalidate();
}

ParamDimension *KnotObject::GetParameterDim(int pbIndex) 
{
  switch (pbIndex) {
  case PB_RADIUS:		return stdWorldDim;
  case PB_RADIUS2:	return stdWorldDim;
  case PB_ROTATION:	return stdAngleDim;
  case PB_TWIST:		return defaultDim;
  case PB_SEGMENTS:	return stdSegmentsDim;
  case PB_SIDES:		return stdSegmentsDim;
  case PB_SMOOTH:		return stdNormalizedDim;
  case PB_BASE_CURVE:		return stdNormalizedDim;
  case PB_P:	return defaultDim;
  case PB_Q:	return defaultDim;
  case PB_E:	return defaultDim;
  case PB_LUMPS:	return defaultDim;
  case PB_LUMP_HEIGHT:	return defaultDim;
  case PB_GENUV:	return defaultDim;
  case PB_UTILE:	return defaultDim;
  case PB_VTILE:	return defaultDim;
  case PB_UOFF: 	return defaultDim;
  case PB_VOFF:	        return defaultDim;
  case PB_WARP_HEIGHT:  return defaultDim;
  case PB_WARP_FREQ:    return defaultDim;
  default: return defaultDim;
  }
}

TSTR KnotObject::GetParameterName(int pbIndex) 
{
  switch (pbIndex) {
  case PB_RADIUS:	return GetString(IDS_AP_RADIUS);		
  case PB_RADIUS2:	return GetString(IDS_AP_RADIUS2);
  case PB_ROTATION:	return GetString(IDS_AP_ROTATION);
  case PB_TWIST:	return GetString(IDS_AP_TWIST);
  case PB_SEGMENTS:	return GetString(IDS_AP_SEGMENTS);
  case PB_SIDES:	return GetString(IDS_AP_SIDES);
  case PB_SMOOTH:	return GetString(IDS_AP_SMOOTH);
  case PB_BASE_CURVE:	return GetString(IDS_AP_BASECURVE);
  case PB_P:	        return GetString(IDS_AP_P);
  case PB_Q:	        return GetString(IDS_AP_Q);		
  case PB_E:	        return GetString(IDS_AP_ECENTRICITY);		
  case PB_LUMPS:	return GetString(IDS_AP_LUMPS);		
  case PB_LUMP_HEIGHT:	return GetString(IDS_AP_LUMPHEIGHT);		
  case PB_GENUV:	return GetString(IDS_AP_GENUV);		
  case PB_UTILE:	return GetString(IDS_AP_UTILE);		
  case PB_VTILE:	return GetString(IDS_AP_VTILE);		
  case PB_UOFF: 	return GetString(IDS_AP_UOFFSET);		
  case PB_VOFF:	        return GetString(IDS_AP_VOFFSET);		
  case PB_WARP_HEIGHT:	return GetString(IDS_AP_WARPHEIGHT);		
  case PB_WARP_FREQ:	return GetString(IDS_AP_WARPFREQUENCY);		
  default: return TSTR(_T(""));
  }
}

RefTargetHandle KnotObject::Clone(RemapDir& remap) 
{
  KnotObject* newob = new KnotObject();	
  newob->ReplaceReference(0,pblock->Clone(remap));	
  newob->ivalid.SetEmpty();	
  return(newob);
}



#ifndef NO_NURBS

NURBSResult
ParameterRangeProc(double& uMin, double& uMax, double& vMin, double& vMax)
{
	uMin = vMin = 0.0;
	uMax = vMax = 2.0f*PI;

	return kNOk;
}

NURBSResult
EvaluateProc(double u, double v, Point3& pt)
{
	float deltaT = (2.0f*PI) / 10000.0f;
	float theta = (float)u;
	float phi = (float)v;

	if (BaseCurve == BASE_KNOT)
		pt = generalKnot(torusKnot, circle, theta, deltaT, phi);
	else
		pt = generalKnot(baseCircle, circle, theta, deltaT, phi);

	return kNOk;
}

#endif
Object* KnotObject::ConvertToType(TimeValue t, Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype == EDITABLE_SURF_CLASS_ID) {
		NURBSSet nset;

		float uTile, vTile, uOff, vOff;
		int genUV;

		float radius, radius2;
		Interval ivalid;
		pblock->GetValue(PB_RADIUS,		t,	radius,		ivalid);
		pblock->GetValue(PB_RADIUS2,	t,	radius2,	ivalid);

		pblock->GetValue(PB_ROTATION,	t,	Rotation,	ivalid);
		pblock->GetValue(PB_TWIST,		t,	Twist,		ivalid);
		pblock->GetValue(PB_BASE_CURVE,	t,	BaseCurve,	ivalid);
		pblock->GetValue(PB_P,			t,	P,			ivalid);
		pblock->GetValue(PB_Q,			t,	Q,			ivalid);	
		pblock->GetValue(PB_E,			t,	E,			ivalid);	
		pblock->GetValue(PB_LUMPS,		t,	Lumps,		ivalid);	
		pblock->GetValue(PB_LUMP_HEIGHT,t,	LumpHeight,	ivalid);

		pblock->GetValue(PB_GENUV,		t,	genUV,		ivalid);	
		pblock->GetValue(PB_UTILE,		t,	uTile,		ivalid);	
		pblock->GetValue(PB_VTILE,		t,	vTile,		ivalid);	
		pblock->GetValue(PB_UOFF,		t,	uOff,		ivalid);	
		pblock->GetValue(PB_VOFF,		t,	vOff,		ivalid);

		pblock->GetValue(PB_WARP_HEIGHT,t,	WarpHeight,	ivalid);	
		pblock->GetValue(PB_WARP_FREQ,	t,	WarpFreq,	ivalid);

		LimitValue( radius, MIN_RADIUS, MAX_RADIUS );
		LimitValue( radius2, MIN_RADIUS, MAX_RADIUS );

		Radius1 = radius;
		Radius2 = radius2;


		NURBSProceeduralSurface pSurf((SurfParamRangeProc)ParameterRangeProc,
										(SurfEvalProc)EvaluateProc,
										(SurfEvalTan)NULL,
										(SurfEvalMixedProc)NULL);

		NURBSCVSurface nSurf;
		double tol = (radius > radius2) ? radius2 : radius;
		if (E > 1.0f) tol /= E; else tol *= E;
		tol /= 100.0;
		GenNURBSCVSurfaceProceedurally(&pSurf, tol, nSurf);

		if (genUV) {
			nSurf.SetGenerateUVs(TRUE);
			nSurf.SetTileOffset(0, uTile, vTile, uOff, vOff, 0.0f);
		}

		nset.AppendObject(&nSurf);

		Matrix3 mat;
		mat.IdentityMatrix();
		Object *ob = CreateNURBSObject(NULL, &nset, mat);

		ob->SetChannelValidity(TOPO_CHAN_NUM,FOREVER);
		ob->SetChannelValidity(GEOM_CHAN_NUM,FOREVER);
		ob->UnlockObject();
		return ob;
	} 
#endif

    return SimpleObject::ConvertToType(t,obtype);
	}

int KnotObject::CanConvertToType(Class_ID obtype)
	{
#ifndef NO_NURBS
	if (obtype==EDITABLE_SURF_CLASS_ID)
		return 1;
#endif

    return SimpleObject::CanConvertToType(obtype);
	}

void KnotObject::GetCollapseTypes(Tab<Class_ID> &clist,Tab<TSTR*> &nlist)
{
    Object::GetCollapseTypes(clist, nlist);
#ifndef NO_NURBS
    Class_ID id = EDITABLE_SURF_CLASS_ID;
    TSTR *name = new TSTR(GetString(IDS_SM_NURBS_SURFACE));
    clist.Append(1,&id);
    nlist.Append(1,&name);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\knots\knotbase.cpp ===
#include "knotbase.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;

const float IntMax=32767.0f;
const float IntMax1=32768.0f;
const float HalfIntMax=16383.5f;
#define ALEN 20
static char astring[ALEN];
ParticleMtl::ParticleMtl():Material() {
	Kd[0] = PARTICLE_R;
	Kd[1] = PARTICLE_G;
	Kd[2] = PARTICLE_B;
	Ks[0] = PARTICLE_R;
	Ks[1] = PARTICLE_G;
	Ks[2] = PARTICLE_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME;
	selfIllum = (float)1.0;
	}

int FloatEQ0(float number)
{return((FLOAT_EPSILON>=number)&&(number>=-FLOAT_EPSILON));
}
int SmallerEQ0(float number)
{return((SMALL_EPSILON>=number)&&(number>=-SMALL_EPSILON));
}
int FGT0(Point3 p1)
{
	return((fabs(p1[0])>SMALL_EPSILON)||(fabs(p1[1])>SMALL_EPSILON)||(fabs(p1[2])>SMALL_EPSILON));
}

void Mult1X4(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0]+A[3]*B[3][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1]+A[3]*B[3][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2]+A[3]*B[3][2];
   C[3]=A[0]*B[0][3]+A[1]*B[1][3]+A[2]*B[2][3]+A[3]*B[3][3];
}

void Mult4X1(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[0][1]+A[2]*B[0][2]+A[3]*B[0][3];
   C[1]=A[0]*B[1][0]+A[1]*B[1][1]+A[2]*B[1][2]+A[3]*B[1][3];
   C[2]=A[0]*B[2][0]+A[1]*B[2][1]+A[2]*B[2][2]+A[3]*B[2][3];
   C[3]=A[0]*B[3][0]+A[1]*B[3][1]+A[2]*B[3][2]+A[3]*B[3][3];
}

void Mult1X3(float *A,Matrix3By3 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2];
}

void Mult3X4(Matrix3By4 A,Matrix4By4 B,Matrix3By4 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
   C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
   C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
   C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
   C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
   C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
   C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
   C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
   C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
   C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
   C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
   C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
}

void Mult4X3(Matrix4By3 A,Matrix4By4 B,Matrix4By3 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[1][0]*B[0][1]+A[2][0]*B[0][2]+A[3][0]*B[0][3];
   C[1][0]=A[0][0]*B[1][0]+A[1][0]*B[1][1]+A[2][0]*B[1][2]+A[3][0]*B[1][3];
   C[2][0]=A[0][0]*B[2][0]+A[1][0]*B[2][1]+A[2][0]*B[2][2]+A[3][0]*B[2][3];
   C[3][0]=A[0][0]*B[3][0]+A[1][0]*B[3][1]+A[2][0]*B[3][2]+A[3][0]*B[3][3];
   C[0][1]=A[0][1]*B[0][0]+A[1][1]*B[0][1]+A[2][1]*B[0][2]+A[3][1]*B[0][3];
   C[1][1]=A[0][1]*B[1][0]+A[1][1]*B[1][1]+A[2][1]*B[1][2]+A[3][1]*B[1][3];
   C[2][1]=A[0][1]*B[2][0]+A[1][1]*B[2][1]+A[2][1]*B[2][2]+A[3][1]*B[2][3];
   C[3][1]=A[0][1]*B[3][0]+A[1][1]*B[3][1]+A[2][1]*B[3][2]+A[3][1]*B[3][3];
   C[0][2]=A[0][2]*B[0][0]+A[1][2]*B[0][1]+A[2][2]*B[0][2]+A[3][2]*B[0][3];
   C[1][2]=A[0][2]*B[1][0]+A[1][2]*B[1][1]+A[2][2]*B[1][2]+A[3][2]*B[1][3];
   C[2][2]=A[0][2]*B[2][0]+A[1][2]*B[2][1]+A[2][2]*B[2][2]+A[3][2]*B[2][3];
   C[3][2]=A[0][2]*B[3][0]+A[1][2]*B[3][1]+A[2][2]*B[3][2]+A[3][2]*B[3][3];
}

void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C)
{
   C[0][0]=A[0][0]*B[0][0]+A[0][1]*B[1][0]+A[0][2]*B[2][0]+A[0][3]*B[3][0];
   C[0][1]=A[0][0]*B[0][1]+A[0][1]*B[1][1]+A[0][2]*B[2][1]+A[0][3]*B[3][1];
   C[0][2]=A[0][0]*B[0][2]+A[0][1]*B[1][2]+A[0][2]*B[2][2]+A[0][3]*B[3][2];
   C[0][3]=A[0][0]*B[0][3]+A[0][1]*B[1][3]+A[0][2]*B[2][3]+A[0][3]*B[3][3];
   C[1][0]=A[1][0]*B[0][0]+A[1][1]*B[1][0]+A[1][2]*B[2][0]+A[1][3]*B[3][0];
   C[1][1]=A[1][0]*B[0][1]+A[1][1]*B[1][1]+A[1][2]*B[2][1]+A[1][3]*B[3][1];
   C[1][2]=A[1][0]*B[0][2]+A[1][1]*B[1][2]+A[1][2]*B[2][2]+A[1][3]*B[3][2];
   C[1][3]=A[1][0]*B[0][3]+A[1][1]*B[1][3]+A[1][2]*B[2][3]+A[1][3]*B[3][3];
   C[2][0]=A[2][0]*B[0][0]+A[2][1]*B[1][0]+A[2][2]*B[2][0]+A[2][3]*B[3][0];
   C[2][1]=A[2][0]*B[0][1]+A[2][1]*B[1][1]+A[2][2]*B[2][1]+A[2][3]*B[3][1];
   C[2][2]=A[2][0]*B[0][2]+A[2][1]*B[1][2]+A[2][2]*B[2][2]+A[2][3]*B[3][2];
   C[2][3]=A[2][0]*B[0][3]+A[2][1]*B[1][3]+A[2][2]*B[2][3]+A[2][3]*B[3][3];
   C[3][0]=A[3][0]*B[0][0]+A[3][1]*B[1][0]+A[3][2]*B[2][0]+A[3][3]*B[3][0];
   C[3][1]=A[3][0]*B[0][1]+A[3][1]*B[1][1]+A[3][2]*B[2][1]+A[3][3]*B[3][1];
   C[3][2]=A[3][0]*B[0][2]+A[3][1]*B[1][2]+A[3][2]*B[2][2]+A[3][3]*B[3][2];
   C[3][3]=A[3][0]*B[0][3]+A[3][1]*B[1][3]+A[3][2]*B[2][3]+A[3][3]*B[3][3];
}

float det2x2(float a,float b,float c,float d)
{ return(a*d-b*c);
}
float det3x3(float a1,float a2,float a3,float b1,float b2,float b3,float c1,float c2,float c3)
{ return(a1*det2x2(b2,b3,c2,c3)-b1*det2x2(a2,a3,c2,c3)+c1*det2x2(a2,a3,b2,b3));
}

void Adjoint(Matrix4By4 in, Matrix4By4 out,float det)
{float a1,a2,a3,a4,b1,b2,b3,b4;
 float c1,c2,c3,c4,d1,d2,d3,d4;

 a1=in[0][0];b1=in[0][1];c1=in[0][2];d1=in[0][3];
 a2=in[1][0];b2=in[1][1];c2=in[1][2];d2=in[1][3];
 a3=in[2][0];b3=in[2][1];c3=in[2][2];d3=in[2][3];
 a4=in[3][0];b4=in[3][1];c4=in[3][2];d4=in[3][3];
 out[0][0]= det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)/det;
 out[1][0]=-det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)/det;
 out[2][0]= det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)/det;
 out[3][0]=-det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4)/det;
 out[0][1]=-det3x3(b1,b3,b4,c1,c3,c4,d1,d3,d4)/det;
 out[1][1]= det3x3(a1,a3,a4,c1,c3,c4,d1,d3,d4)/det;
 out[2][1]=-det3x3(a1,a3,a4,b1,b3,b4,d1,d3,d4)/det;
 out[3][1]= det3x3(a1,a3,a4,b1,b3,b4,c1,c3,c4)/det;
 out[0][2]= det3x3(b1,b2,b4,c1,c2,c4,d1,d2,d4)/det;
 out[1][2]=-det3x3(a1,a2,a4,c1,c2,c4,d1,d2,d4)/det;
 out[2][2]= det3x3(a1,a2,a4,b1,b2,b4,d1,d2,d4)/det;
 out[3][2]=-det3x3(a1,a2,a4,b1,b2,b4,c1,c2,c4)/det;
 out[0][3]=-det3x3(b1,b2,b3,c1,c2,c3,d1,d2,d3)/det;
 out[1][3]= det3x3(a1,a2,a3,c1,c2,c3,d1,d2,d3)/det;
 out[2][3]=-det3x3(a1,a2,a3,b1,b2,b3,d1,d2,d3)/det;
 out[3][3]= det3x3(a1,a2,a3,b1,b2,b3,c1,c2,c3)/det;
}

float det4x4(Matrix4By4 m)
{float a1,a2,a3,a4,b1,b2,b3,b4;
 float c1,c2,c3,c4,d1,d2,d3,d4,ans;

 a1=m[0][0];b1=m[0][1];c1=m[0][2];d1=m[0][3];
 a2=m[1][0];b2=m[1][1];c2=m[1][2];d2=m[1][3];
 a3=m[2][0];b3=m[2][1];c3=m[2][2];d3=m[2][3];
 a4=m[3][0];b4=m[3][1];c4=m[3][2];d4=m[3][3];
 ans= a1*det3x3(b2,b3,b4,c2,c3,c4,d2,d3,d4)
     -b1*det3x3(a2,a3,a4,c2,c3,c4,d2,d3,d4)
     +c1*det3x3(a2,a3,a4,b2,b3,b4,d2,d3,d4)
     -d1*det3x3(a2,a3,a4,b2,b3,b4,c2,c3,c4);
 return(ans);
}

int MatrixInvert(Matrix4By4 in,Matrix4By4 out)
{ float det;

  det=det4x4(in);
  if (fabs(det)<PRECISION_LIMIT)  /* NO INVERSE */
    return(0);
  Adjoint(in,out,det);
  return(1);
}

void SetUpRotation(float *Q, float *W,float Theta,Matrix4By4 Rq)
{ float ww1,ww2,ww3,w12,w13,w23,CosTheta,SinTheta,MinCosTheta;
  Point3 temp;
  Matrix3By3 R;

 ww1=W[0]*W[0];ww2=W[1]*W[1];ww3=W[2]*W[2];
 w12=W[0]*W[1];w13=W[0]*W[2];w23=W[1]*W[2];
 CosTheta=(float)cos(Theta);MinCosTheta=1.0f-CosTheta;SinTheta=(float)sin(Theta);
 R[0][0]=ww1+(1.0f-ww1)*CosTheta;
 R[0][1]=w12*MinCosTheta+W[2]*SinTheta;
 R[0][2]=w13*MinCosTheta-W[1]*SinTheta;
 R[1][0]=w12*MinCosTheta-W[2]*SinTheta;
 R[1][1]=ww2+(1.0f-ww2)*CosTheta;
 R[1][2]=w23*MinCosTheta+W[0]*SinTheta;
 R[2][0]=w13*MinCosTheta+W[1]*SinTheta;
 R[2][1]=w23*MinCosTheta-W[0]*SinTheta;
 R[2][2]=ww3+(1.0f-ww3)*CosTheta;
 Mult1X3(Q,R,&temp.x);
 memcpy(Rq[0],R[0],row3size);memcpy(Rq[1],R[1],row3size);memcpy(Rq[2],R[2],row3size);
 Rq[3][0]=Q[0]-temp.x;Rq[3][1]=Q[1]-temp.y;Rq[3][2]=Q[2]-temp.z;
 Rq[0][3]=Rq[1][3]=Rq[2][3]=0.0f;Rq[3][3]=1.0f;
}

void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta)
{ Matrix3By4 Pout;
  Matrix4By4 Rq;

 SetUpRotation(Q,W,Theta,Rq);
 Mult3X4(Pin,Rq,Pout);
 memcpy(Pin, Pout, sizeof(Matrix3By4));
}

void RotateOnePoint(float *Pin,float *Q, float *W,float Theta)
{ Matrix4By4 Rq;
  float Pout[4],Pby4[4];

 SetUpRotation(Q,W,Theta,Rq);
 memcpy(Pby4,Pin,row3size);Pby4[3]=1.0f;
 Mult1X4(Pby4,Rq,Pout);
 memcpy(Pin,Pout,row3size);
}
/* rand returns a number between 0 and 32767 */
/* number between 0 and 1 */
float RND01()
{ float num;

  num=(float)rand();
  return(num/IntMax);
}

/* number between -1 and 1 */
float RND11()
{ float num;

   num=(float)rand()-HalfIntMax;
   return(num/HalfIntMax);
}

int RNDSign()
{
  return((RND11()<0?-1:1));
}

float RND55()
{ float num;

  num=RND11();
  return(num/2);
}
int RND0x(int maxnum)
{ float num;
  int newnum;

   num=(float)rand();
   if (maxnum==0) return(0);
   newnum=(int)floor((++maxnum)*num/IntMax1);
   return(newnum>maxnum?maxnum:newnum);
}

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_AP_PQTORUSKNOTS); }

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int 
LibNumberClasses() { return 2; }

// This function return the ith class descriptor. We have one.
__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case 0:return GetTorusKnotDesc();
	case 1:return GetRingWaveObjDesc();
    default:return 0;}
 }

/*
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

  	if (!controlsInit) {
		controlsInit = TRUE;		

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	}
	
	return(TRUE);
	}
*/

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
		// initialize 3D controls
		Ctl3dRegister(hinstDLL);
		Ctl3dAutoSubclass(hinstDLL);
#endif
		
		// initialize Chicago controls
		InitCommonControls();
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.

__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}

void TurnButton(HWND hWnd,int SpinNum,BOOL ison)
{	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(hWnd,SpinNum));
	if (iBut) 
	{ if (ison) iBut->Enable(); else iBut->Disable();
	}
	ReleaseICustButton(iBut);
};

TriObject *IsTriUseable(ObjectState os,TimeValue t)
{ 
  if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
  {	if (os.obj->IsSubClassOf(triObjectClassID)) 
      return (TriObject*)os.obj;
    else 
	{ if (os.obj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)os.obj->ConvertToType(t,triObjectClassID);			
	}
  }
  return NULL;
}
ShapeObject *IsShapeUseable(Object *pobj,TimeValue t)
{ 
  if (pobj->IsShapeObject())
    return (ShapeObject*)pobj;
  else return NULL;
}
void MakeNodeList(INode *node,INodeTab *ntab,TimeValue t)
{  Object *pobj=NULL;
  if ((!node->IsGroupHead())&&((IsShapeUseable(node->EvalWorldState(t).obj,t))!=NULL))
   (*ntab).Append(1,&node,0);
}
void MakeGroupNodeList(INode *node,INodeTab *ntab,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) MakeGroupNodeList(nxtnode,ntab,t);
	  else if (nxtnode->IsGroupMember()) MakeNodeList(nxtnode,ntab,t);
	}
}

int IncS(int s,int max)
{ s++;
  if (s>=max) s=s % max;
  return s;
}
int DecS(int s,int max)
{ s--;
  if (s<0) s=max-1;
  return s;
}

BOOL ReadInt(int *buf,FILE *f)
{ return(fread(buf,isize,1,f)==1);
}
BOOL WriteInt(int *buf,FILE *f)
{ return(fwrite(buf,isize,1,f)==1);
}

BOOL GenNewSaveFile(int osize,int size,int custsettings,FILE *f,TCHAR *filename,int vers)
{ int future=0;BOOL ok=TRUE;
  fclose(f);
  if ((f = _tfopen(filename, _T("r+b"))) == NULL) return FALSE;
  ok=(WriteInt(&custsettings,f)&&WriteInt(&vers,f)&&WriteInt(&size,f)&&WriteInt(&future,f));
 if (custsettings>0)
 { int cset=(custsettings-1),odata=osize+NLEN;
   AName Name;int ofs=(size-osize),tofs=cset*ofs;
   BYTE *data=new BYTE[size];for (int x=0;x<size;x++) data[x]=0;
   cset*=odata;cset+=HLEN;
   while (cset>=HLEN)
   { fseek(f,cset,SEEK_SET);
      if (fread(Name,NLEN,1,f)==1)
	 { if (fread(data,osize,1,f)!=1) goto badend;
       fseek(f,cset+tofs,SEEK_SET);
		if (fwrite(Name,1,NLEN,f)!=NLEN) goto badend;
	   if (fwrite(data,size,1,f)!=1) goto badend;
	 } else goto badend;
	 cset-=odata;tofs-=ofs;
   }
   delete[] data;
   rewind(f);
 }
 return ok;
 badend: fclose(f);return FALSE;
}

void SpinnerOn(HWND hWnd,int SpinNum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Enable();
	ReleaseISpinner(spin2);

};
void SpinnerOff(HWND hWnd,int SpinNum)
{	ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
	spin2->Disable();
	ReleaseISpinner(spin2);
};
static unsigned int goodval;
static BOOL isbad;
static FILE *f;
#define MAXSERNUM	16
static char applicationID[MAXSERNUM];

// Prints out the application ID
void OutputApplicationID (HWND hWnd)
{
    PAINTSTRUCT ps;
    HDC hDC;
    InvalidateRect (hWnd, NULL, TRUE);
    hDC = BeginPaint (hWnd, &ps);
    SetBkMode (hDC, TRANSPARENT);
    TextOut (hDC, 0, 0, applicationID, strlen(applicationID));
    EndPaint (hWnd, &ps);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\knots\knotbase.h ===
#ifndef __MAXTR__H
#define __MAXTR__H

#include "Max.h"
#include "knotbase.h"
#include "Simpobj.h"
#include "resource.h"
#include "windows.h"
#include "iparamm.h"
#include "frenet.h"

TCHAR *GetString(int id);
#define NUMNODES	40

extern ClassDesc* GetTorusKnotDesc();
extern ClassDesc* GetRingWaveObjDesc();

extern HINSTANCE hInstance;
const int isize=sizeof(int);
const int fsize=sizeof(float);
const int NLEN=16;
const int HLEN=4*isize;
typedef TCHAR AName[NLEN];
typedef float Matrix3By3[3][3];
typedef float Matrix3By4[3][4];
typedef float Matrix4By3[4][3];
typedef float Matrix4By4[4][4];
typedef struct{
	int on,off;
} Lpair;

class NullView: public View {
	public:
		Point2 ViewToScreen(Point3 p) { return Point2(p.x,p.y); }
		NullView() { worldToView.IdentityMatrix(); screenW=640.0f; screenH = 480.0f; }
	};
class ParticleMtl: public Material {
	public:
	ParticleMtl();
	};
static ParticleMtl particleMtl;
static Matrix3 ident(1);
#define PARTICLE_R	float(1.0)
#define PARTICLE_G	float(1.0)
#define PARTICLE_B	float(0.0)

const Point3 Zero=Point3(0.0f,0.0f,0.0f);
const int row3size=3*sizeof(float);
const float FLOAT_EPSILON=0.005f;
const float PRECISION_LIMIT=1.0e-15f;
const float SMALL_EPSILON=0.00002f;
extern int MatrixInvert(Matrix4By4 in,Matrix4By4 out);
extern void Mult4X1(float *A,Matrix4By4 B,float *C);
extern void RotateOnePoint(float *Pin,float *Q, float *W,float Theta);
extern int FloatEQ0(float number);
extern int SmallerEQ0(float number);
extern int FGT0(Point3 p1);
extern void TurnButton(HWND hWnd,int SpinNum,BOOL ison);
extern TriObject *IsTriUseable(ObjectState os,TimeValue t);
extern ShapeObject *IsShapeUseable(Object *pobj,TimeValue t);
extern void MakeNodeList(INode *node,INodeTab *ntab,TimeValue t);
extern void MakeGroupNodeList(INode *node,INodeTab *ntab,TimeValue t);
extern int IncS(int s,int max);
extern int DecS(int s,int max);
extern BOOL ReadInt(int *buf,FILE *f);
extern BOOL WriteInt(int *buf,FILE *f);
extern BOOL GenNewSaveFile(int osize,int size,int custsettings,FILE *f,TCHAR *filename,int vers);
extern void SpinnerOn(HWND hWnd,int SpinNum);
extern void SpinnerOff(HWND hWnd,int SpinNum);
extern BOOL LockBoxBad(IObjParam *ip);
extern void TimingOn(HWND hWnd);
extern void TimingOff(HWND hWnd);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\knots\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by knot.rc
//
#define IDS_AP_KNOTNAME                 1
#define IDS_AP_EXTENDED                 2
#define IDS_AP_CREATE_DIALOG            3
#define IDS_AP_KEYBOARDENTRY            4
#define IDS_AP_PARAMETERS               5
#define IDS_AP_RADIUS                   6
#define IDS_AP_RADIUS2                  7
#define IDS_AP_ROTATION                 8
#define IDS_AP_TWIST                    9
#define IDS_AP_SEGMENTS                 10
#define IDS_AP_SIDES                    11
#define IDS_AP_SMOOTH                   12
#define IDS_AP_BASECURVE                13
#define IDS_AP_SLICEON                  14
#define IDS_AP_P                        15
#define IDS_AP_Q                        16
#define IDS_AP_ECENTRICITY              17
#define IDS_AP_LUMPS                    18
#define IDS_AP_LUMPHEIGHT               19
#define IDS_AP_GENUV                    20
#define IDS_AP_UTILE                    21
#define IDS_AP_VTILE                    22
#define IDS_AP_UOFFSET                  23
#define IDS_AP_VOFFSET                  24
#define IDS_AP_WARPHEIGHT               25
#define IDS_AP_WARPFREQUENCY            26
#define IDS_AP_PQTORUSKNOTS             27
#define IDS_AP_MGEOM                    28
#define IDS_AP_PARAMS                   29
#define IDS_AP_KNOTNAME_CDESC           30
#define IDS_AP_TIMEON                   56
#define IDS_AP_TIMEOFF                  59
#define IDS_EP_RINGWAVE                 62
#define IDS_AP_GROWTIME                 63
#define IDS_AP_REPEAT                   64
#define IDS_AP_MAXD                     65
#define IDS_AP_RINGW                    66
#define IDS_AP_RES                      67
#define IDS_AP_OUTERB                   68
#define IDS_AP_ONCYCLES1                69
#define IDS_AP_OWID1                    70
#define IDS_AP_OPER1                    71
#define IDS_AP_ONCYCLES2                72
#define IDS_AP_OWID2                    73
#define IDS_AP_OPER2                    74
#define IDS_AP_IUTERB                   75
#define IDS_AP_INCYCLES1                76
#define IDS_AP_IWID1                    77
#define IDS_AP_IPER1                    78
#define IDS_AP_INCYCLES2                79
#define IDS_AP_IWID2                    80
#define IDS_AP_IPER2                    81
#define IDS_AP_HEIGHT                   82
#define IDS_AP_HEIGHTSEGS               83
#define IDS_AP_RADSEGS                  84
#define IDS_SM_NURBS_SURFACE            85
#define IDD_SPHEREPARAM                 101
#define IDD_SPHEREPARAM2                101
#define IDB_SPINNER                     102
#define IDD_CYLINDERPARAM               102
#define IDD_CYLINDERPARAM2              102
#define IDC_SPINNERCUR                  103
#define IDD_BOXPARAM                    103
#define IDD_BOXPARAM2                   103
#define IDD_WAVEPARAM                   104
#define IDD_SCAMERA                     105
#define IDD_SCAMERAPARAM                105
#define IDD_LIGHT_PARAM                 106
#define IDD_CYLINDERPARAM1              107
#define IDD_DIRLIGHTPARAM               108
#define IDD_DUMMY1                      109
#define IDD_RINGWAVE_UI                 109
#define IDD_DUMMY2                      110
#define IDD_DUMMY3                      111
#define IDD_DUMMY4                      112
#define IDD_SPHEREPARAM1                113
#define IDD_DUMMY5                      114
#define IDD_DUMMY6                      115
#define IDD_FSPOTLIGHTPARAM             116
#define IDD_SPOTLIGHT                   116
#define IDD_SPLINEPARAM                 117
#define IDD_SPLINEPARAM1                117
#define IDD_NGONPARAM2                  118
#define IDD_NGONPARAM1                  119
#define IDD_DONUTPARAM2                 120
#define IDD_DONUTPARAM1                 121
#define IDD_SAMPLEPARAM                 122
#define IDD_FCAMERAPARAM                123
#define IDD_PATCHGRIDPARAM              124
#define IDD_TRIPATCHPARAM               125
#define IDD_PSPHEREPARAM1               126
#define IDD_PSPHEREPARAM2               127
#define IDD_TORUSPARAM1                 128
#define IDD_TORUSPARAM2                 129
#define IDD_MORPHPARAM                  130
#define IDD_MORPHPARAM2                 130
#define IDD_MORPHPARAM1                 131
#define IDD_FREE_SPOTLIGHT              132
#define IDD_LIGHT_SHADOW                134
#define IDD_RECTANGLEPARAM              135
#define IDD_BOOLPARAM1                  136
#define IDD_BOOLPARAM2                  137
#define IDD_TAPEHELPER                  138
#define IDD_SPHEREPARAM3                139
#define IDD_CYLINDERPARAM3              140
#define IDD_TORUSPARAM3                 141
#define IDD_TUBEPARAM1                  142
#define IDD_TUBEPARAM2                  143
#define IDD_TUBEPARAM3                  144
#define IDD_BOXPARAM1                   145
#define IDD_BOXPARAM3                   146
#define IDD_CONEPARAM1                  147
#define IDD_CONEPARAM2                  148
#define IDD_CONEPARAM3                  149
#define IDD_HEDRAPARAM                  150
#define IDD_HELIXPARAM1                 151
#define IDD_HELIXPARAM2                 152
#define IDB_TEXT_BUTTONS                152
#define IDD_DONUTPARAM3                 153
#define IDB_TEXT_MASKBUTTONS            153
#define IDD_NGONPARAM3                  154
#define IDD_HELIXPARAM3                 156
#define IDD_RECTANGLEPARAM3             157
#define IDD_RECTANGLEPARAM2             158
#define IDD_RECTANGLEPARAM1             159
#define IDD_CIRCLEPARAM2                160
#define IDD_CIRCLEPARAM1                161
#define IDD_ELLIPSEPARAM3               162
#define IDD_ELLIPSEPARAM2               163
#define IDD_ELLIPSEPARAM1               164
#define IDD_CIRCLEPARAM3                165
#define IDD_ARCPARAM3                   166
#define IDD_ARCPARAM2                   167
#define IDD_ARCPARAM1                   168
#define IDD_RAINPARAM                   169
#define IDD_STARPARAM2                  170
#define IDD_STARPARAM1                  171
#define IDD_SNOWPARAM                   172
#define IDD_TEXTPARAM                   173
#define IDD_INTERPPARAMS                174
#define IDD_SPLINEPARAM2                175
#define IDD_KNOTPARAM2                  176
#define IDC_RADIUS                      1000
#define IDC_SEGMENTS                    1001
#define IDC_AMPLITUDE                   1001
#define IDC_PARAM_P                     1001
#define IDC_TI_ARCFROM                  1001
#define IDC_CREATEDIAMETER              1002
#define IDC_CYCLES                      1002
#define IDC_HEMISPHERE                  1002
#define IDC_CAPSEGMENTS                 1002
#define IDC_PARAM_Q                     1002
#define IDC_TI_ARCTO                    1002
#define IDC_CREATERADIUS                1003
#define IDC_PHASE                       1003
#define IDC_SCALE_P                     1003
#define IDC_SEGSPINNER                  1004
#define IDC_NUMNODES                    1004
#define IDC_SCALE_Q                     1004
#define IDC_RADSPINNER                  1005
#define IDC_CAPSEGSPINNER               1005
#define IDC_OBSMOOTH                    1006
#define IDC_AMPSPINNER                  1006
#define IDC_PARAM_PSPIN                 1006
#define IDC_TI_ARCFROMSPINNER           1006
#define IDC_LENGTH                      1007
#define IDC_CYCSPINNER                  1007
#define IDC_HEMISPHERESPINNER           1007
#define IDC_PARAM_QSPIN                 1007
#define IDC_TI_ARCTOSPINNER             1007
#define IDC_LENSPINNER                  1008
#define IDC_PHSSPINNER                  1008
#define IDC_SCALE_PSPIN                 1008
#define IDC_SIDES                       1009
#define IDC_NUMSPINNER                  1009
#define IDC_SCALE_QSPIN                 1009
#define IDC_POINTS                      1009
#define IDC_SIDESPINNER                 1010
#define IDC_HEIGHT                      1010
#define IDC_HEIGHTEDIT                  1010
#define IDC_SCALE_R                     1010
#define IDC_POINTSSPINNER               1010
#define IDC_WIDTHSPINNER                1011
#define IDC_PIESLICESPIN1               1011
#define IDC_SCALE_RSPIN                 1011
#define IDC_DISTORTSPINNER              1011
#define IDC_HEIGHTSPINNER               1012
#define IDC_PIESLICESPIN2               1012
#define IDC_DISTORT                     1012
#define IDC_BROWSE                      1013
#define IDC_HSEGSPIN                    1013
#define IDC_RADSPINNER2                 1013
#define IDC_CAPSEGSPIN                  1013
#define IDC_OBJFILENAME                 1014
#define IDC_HSEGS                       1014
#define IDC_FOV                         1015
#define IDC_WSEGSPIN                    1015
#define IDC_RSEGS                       1015
#define IDC_FOVSPINNER                  1016
#define IDC_WSEGS                       1016
#define IDC_LRED                        1017
#define IDC_LSEGSPIN                    1017
#define IDC_FOVSPINNER2                 1017
#define IDC_DW_GROWTIME                 1017
#define IDC_LREDSPINNER                 1018
#define IDC_LSEGS                       1018
#define IDC_FOV2                        1018
#define IDC_DW_GROWTIMESPIN             1018
#define IDC_SHOWCAMCONE                 1019
#define IDC_DW_FIRSTBLAST               1019
#define IDC_CHECK1                      1020
#define IDC_SHOW_CONE                   1020
#define IDC_BOOL_OPTIMIZE               1020
#define IDC_SHOWHORZLINE                1020
#define IDC_SPEC_LEN                    1020
#define IDC_HEMI_RECENTER               1020
#define IDC_SLICEON                     1020
#define IDC_ARCPIE                      1020
#define IDC_HIDE_EMITTER                1020
#define IDC_GENUVS                      1020
#define IDC_DW_FIRSTBLASTSPIN           1020
#define IDC_LGREEN                      1021
#define IDC_BUTTON1                     1021
#define IDC_CREATE_MORPHKEY             1021
#define IDC_15MM                        1021
#define IDC_SCALE_RESET                 1021
#define IDC_DUMMY                       1021
#define IDC_DW_OFFTIME                  1021
#define IDC_LGREENSPINNER               1022
#define IDC_BUTTON2                     1022
#define IDC_PROJ_IMAGE                  1022
#define IDC_20MM                        1022
#define IDC_DW_OFFTIMESPIN              1022
#define IDC_LBLUE                       1023
#define IDC_RADIO1                      1023
#define IDC_BUTTON3                     1023
#define IDC_TARG_REFERENCE              1023
#define IDC_RECT_LIGHT                  1023
#define IDC_24MM                        1023
#define IDC_BOOL_UNION                  1023
#define IDC_HEMI_SQUASH                 1023
#define IDC_SMOOTH_ALL                  1023
#define IDC_FAM_TETRA                   1023
#define IDC_HELIX_CW                    1023
#define IDC_PARTICLE_DOTS               1023
#define IDC_LBLUESPINNER                1024
#define IDC_RADIO2                      1024
#define IDC_BUTTON4                     1024
#define IDC_TARG_COPY                   1024
#define IDC_CIRCLE_LIGHT                1024
#define IDC_28MM                        1024
#define IDC_BOOL_INTERSECTION           1024
#define IDC_HEMI_CHOP                   1024
#define IDC_SMOOTH_SIDES                1024
#define IDC_FAM_OCTA                    1024
#define IDC_HELIX_CCW                   1024
#define IDC_PARTICLE_TICKS              1024
#define IDC_OE_BREAKSON                 1024
#define IDC_RADIO3                      1025
#define IDC_BUTTON5                     1025
#define IDC_LHOTSIZESPINNER             1025
#define IDC_TARG_MOVE                   1025
#define IDC_35MM                        1025
#define IDC_MAP_RANGE                   1025
#define IDC_BOOL_DIFFERENCEA            1025
#define IDC_SMOOTH_NONE                 1025
#define IDC_FAM_DODEC                   1025
#define IDC_IE_BREAKSON                 1025
#define IDC_RADIO4                      1026
#define IDC_BUTTON6                     1026
#define IDC_LHOTSIZE                    1026
#define IDC_TARG_INSTANCE               1026
#define IDC_50MM                        1026
#define IDC_SHADOW_MAPS                 1026
#define IDC_BOOL_DISPRESULT             1026
#define IDC_FAM_STAR1                   1026
#define IDC_KNOT_CURVE                  1026
#define IDC_WAVEREPEAT                  1026
#define IDC_BUTTON7                     1027
#define IDC_LFALLOFFSPINNER             1027
#define IDC_85MM                        1027
#define IDC_BOOL_DIFFERENCEB            1027
#define IDC_WAVEONESHOT                 1027
#define IDC_CHECK2                      1028
#define IDC_BUTTON8                     1028
#define IDC_LFALLOFF                    1028
#define IDC_135MM                       1028
#define IDC_TICKMARKS                   1028
#define IDC_BOOL_SHOWHIDDENOPS          1028
#define IDC_GENTEXTURE                  1028
#define IDC_PARTICLE_CONSTANTRATE       1028
#define IDC_WAVEGROWANDHOLD             1028
#define IDC_BUTTON9                     1029
#define IDC_LTDISTSPINNER               1029
#define IDC_200MM                       1029
#define IDC_WAVESTATIC                  1029
#define IDC_BUTTON10                    1030
#define IDC_LASPECT_SPIN                1030
#define IDC_BUTTON11                    1031
#define IDC_LASPECT                     1031
#define IDC_LIST1                       1032
#define IDC_MORPHTARG_LIST              1032
#define IDC_LBLUR_SPIN                  1032
#define IDC_BOOL_OPERANDS               1032
#define IDC_SCROLLBAR2                  1033
#define IDC_LBLUR                       1033
#define IDC_SCROLLBAR1                  1035
#define IDC_SCROLLBAR3                  1035
#define IDC_SCROLLBAR4                  1036
#define IDC_EDIT1                       1037
#define IDC_TEXTENTRY                   1037
#define IDC_USER1                       1039
#define IDC_PICK_MORPHTARG              1039
#define IDC_LIGHT_COLOR                 1039
#define IDC_ICORNER                     1040
#define IDC_ISMOOTH                     1041
#define IDC_DCORNER                     1042
#define IDC_OBCIRCULAR                  1042
#define IDC_DSMOOTH                     1043
#define IDC_RADIUS1                     1043
#define IDC_DBEZIER                     1044
#define IDC_RAD1SPINNER                 1044
#define IDC_RADIUS2                     1045
#define IDC_RAD2SPINNER                 1046
#define IDC_TORUS_ROT                   1047
#define IDC_TURNS                       1047
#define IDC_TORUS_ROTSPIN               1048
#define IDC_TORUS_TWIST                 1049
#define IDC_TURNSSPINNER                1049
#define IDC_SHOW_RANGES                 1050
#define IDC_TORUS_TWISTSPIN             1050
#define IDC_TURNSEDIT                   1050
#define IDC_BIASSPINNER                 1051
#define IDC_BIASEDIT                    1052
#define IDC_USE_ATTEN                   1062
#define IDC_START_RANGE_SPIN            1063
#define IDC_START_RANGE                 1064
#define IDC_END_RANGE_SPIN              1065
#define IDC_END_RANGE                   1066
#define IDC_LMULTSPINNER                1067
#define IDC_LMULT                       1068
#define IDC_LTDIST                      1069
#define IDC_SSTEPSSPINNER               1069
#define IDC_TDIST                       1070
#define IDC_SHAPESTEPS                  1070
#define IDC_TDISTSPINNER                1071
#define IDC_HITHER_SPIN                 1072
#define IDC_LVSPINNER                   1073
#define IDC_HITHER                      1073
#define IDC_LV                          1074
#define IDC_YON_SPIN                    1074
#define IDC_LSSPINNER                   1075
#define IDC_YON                         1075
#define IDC_LS                          1076
#define IDC_LHSPINNER                   1077
#define IDC_LH                          1078
#define IDC_OVERSHOOT                   1080
#define IDC_PROJECTOR                   1081
#define IDC_BITMAP_FIT                  1082
#define IDC_LIGHT_ON                    1083
#define IDC_ADAPTIVE                    1225
#define IDC_OPTIMIZE                    1500
#define IDC_LENS                        3000
#define IDC_LENSSPINNER                 3001
#define IDC_MAP_BIAS                    3002
#define IDC_MAP_BIAS_SPIN               3003
#define IDC_MAP_SIZE                    3004
#define IDC_MAP_SIZE_SPIN               3005
#define IDC_RT_BIAS                     3006
#define IDC_RT_BIAS_SPIN                3007
#define IDC_RAY_TRACED_SHADOWS          3008
#define IDC_LENGTHEDIT                  3009
#define IDC_WIDTHEDIT                   3010
#define IDC_PICK_BOOLOPERAND            3011
#define IDC_BOOL_RECALC                 3012
#define IDC_BOOL_DISPOPS                3015
#define IDC_BOOL_UPDATERENDER           3016
#define IDC_BOOL_UPDATEMANUAL           3017
#define IDC_BOOL_UPDATEALWAYS           3018
#define IDC_BOOL_UPDATESELECT           3019
#define IDC_TI_POSX                     3019
#define IDC_TI_POSXSPIN                 3020
#define IDC_TI_POSY                     3021
#define IDC_TI_POSYSPIN                 3022
#define IDC_TI_CREATE                   3023
#define IDC_TI_POSZ                     3024
#define IDC_PIESLICE1                   3024
#define IDC_TEXTITALIC                  3024
#define IDC_TI_POSZSPIN                 3025
#define IDC_PIESLICE2                   3025
#define IDC_TEXTUNDERLINE               3025
#define IDC_TI_CLOSE                    3026
#define IDC_RADSPINNER1                 3027
#define IDC_TI_FINISH                   3027
#define IDC_CREATECUBE                  3028
#define IDC_CREATEBOX                   3029
#define IDC_FAM_STAR2                   3030
#define IDC_VERT_BASIC                  3031
#define IDC_VERT_CENTER                 3032
#define IDC_VERT_SIDES                  3033
#define IDC_RADIUSSPIN                  3034
#define IDC_MANUAL_CLIP                 3035
#define IDC_CREATEEDGE                  3036
#define IDC_VPT_PARTICLES               3036
#define IDC_CREATECENTER                3037
#define IDC_VPT_PARTICLESSPIN           3037
#define IDC_ARCFROM                     3038
#define IDC_PARTICLE_SIZE               3038
#define IDC_ARCFROMSPINNER              3039
#define IDC_PARTICLE_SIZESPIN           3039
#define IDC_ARCTO                       3040
#define IDC_PARTICLE_START              3040
#define IDC_ARCTOSPINNER                3041
#define IDC_PARTICLE_STARTSPIN          3041
#define IDC_CREATE_EEC                  3042
#define IDC_PARTICLE_LIFE               3042
#define IDC_TEXTFONT                    3042
#define IDC_CREATE_CEE                  3043
#define IDC_PARTICLE_LIFESPIN           3043
#define IDC_TEXTSIZEEDIT                3043
#define IDC_EMITTER_WIDTH               3044
#define IDC_TEXTSIZESPINNER             3044
#define IDC_EMITTER_DIAM                3044
#define IDC_EMITTER_WIDTHSPIN           3045
#define IDC_TEXTBOLD                    3045
#define IDC_EMITTER_DIAMSPIN            3045
#define IDC_EMITTER_HEIGHT              3046
#define IDC_RW_WIDTH                    3046
#define IDC_EMITTER_HEIGHTSPIN          3047
#define IDC_RW_WIDTHSPIN                3047
#define IDC_PARTICLE_SPEED              3048
#define IDC_OE_NCYC1                    3048
#define IDC_PARTICLE_SPEEDSPIN          3049
#define IDC_OE_NCYC1SPIN                3049
#define IDC_PARTICLE_VARIATION          3050
#define IDC_OE_WID1                     3050
#define IDC_PARTICLE_VARIATIONSPIN      3051
#define IDC_OE_WID1SPIN                 3051
#define IDC_PARTICLE_CUST               3052
#define IDC_OE_NCYC2                    3052
#define IDC_TEXTEXAMPLE                 3053
#define IDC_PARTICLE_BIRTHRATE          3053
#define IDC_OE_NCYC2SPIN                3053
#define IDC_PARTICLE_BIRTHRATESPIN      3054
#define IDC_OE_WID2                     3054
#define IDC_PARTICLE_MAXRATE            3055
#define IDC_OE_WID2SPIN                 3055
#define IDC_NO_CROSSOVER                3056
#define IDC_OE_CRAWLT1                  3056
#define IDC_FAR_RANGE                   3057
#define IDC_OE_CRAWLT1SPIN              3057
#define IDC_FAR_RANGE_SPIN              3058
#define IDC_OE_CRAWLT2                  3058
#define IDC_NEAR_RANGE                  3059
#define IDC_OE_CRAWLT2SPIN              3059
#define IDC_NEAR_RANGE_SPIN             3060
#define IDC_IE_NCYC1                    3060
#define IDC_TI_ADDPOINT                 3061
#define IDC_IE_NCYC1SPIN                3061
#define IDC_MAP_RANGE_SPIN              3062
#define IDC_IE_WID1                     3062
#define IDC_GLOBAL_SET                  3063
#define IDC_IE_WID1SPIN                 3063
#define IDC_CAST_SHADOWS                3064
#define IDC_IE_NCYC2                    3064
#define IDC_P                           3065
#define IDC_IE_NCYC2SPIN                3065
#define IDC_ABS_MAP_BIAS                3066
#define IDC_Q                           3066
#define IDC_IE_WID2                     3066
#define IDC_QSPIN                       3067
#define IDC_IE_WID2SPIN                 3067
#define IDC_PSPIN                       3068
#define IDC_IE_CRAWLT1                  3068
#define IDC_E                           3069
#define IDC_IE_CRAWLT1SPIN              3069
#define IDC_ESPIN                       3070
#define IDC_IE_CRAWLT2                  3070
#define IDC_LUMP_HEIGHT                 3071
#define IDC_IE_CRAWLT2SPIN              3071
#define IDC_LUMP_HEIGHT_SPIN            3072
#define IDC_RES                         3072
#define IDC_CIRCLE_CURVE                3073
#define IDC_RESSPIN                     3073
#define IDC_VTILE                       3074
#define IDC_HINNER                      3074
#define IDC_LUMPS                       3075
#define IDC_HINNERSPIN                  3075
#define IDC_LUMPSSPIN                   3076
#define IDC_VTILESPIN                   3077
#define IDC_HSEGSSPIN                   3077
#define IDC_UTILE                       3078
#define IDC_RSEGSSPIN                   3078
#define IDC_UTILESPIN                   3079
#define IDC_VOFF                        3080
#define IDC_VOFFSPIN                    3081
#define IDC_UOFF                        3082
#define IDC_UOFFSPIN                    3083
#define IDC_WARP_FREQ                   3084
#define IDC_WARP_HEIGHT                 3085
#define IDC_WARP_FREQ_SPIN              3086
#define IDC_WARP_HEIGHT_SPIN            3087
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        156
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         3074
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\knots\ringwave.cpp ===
#include "knotbase.h"
#include "iparamm.h"
#include "texutil.h"

static Class_ID RINGWAVE_CLASS_ID(0x28e41f64, 0x124b5312);
const float HalfPI=1.570796327f;
const float QuarterPI=0.785398163f;
#define A_RENDER			A_PLUGIN1

class RingWaveObject : public SimpleObject {
	public:
		// Class vars
		static IParamMap *pmapParam;		
		static IObjParam *ip;
		int FToTick;
		static HWND hparam;
		static RingWaveObject *reditOb;
		RingWaveObject();
		// From Object
		int CanConvertToType(Class_ID obtype);
		Object* ConvertToType(TimeValue t, Class_ID obtype);
//		int IsRenderable() {return 0;};
		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() {  return GetString(IDS_EP_RINGWAVE); }

		// Animatable methods
		void MapKeys(TimeMap *map,DWORD flags);
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return RINGWAVE_CLASS_ID; }  
		
		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// From SimpleObject
		void BuildMesh(TimeValue t);
		BOOL OKtoDisplay(TimeValue t);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		//mine
	};				


//--- ClassDescriptor and class vars ---------------------------------

class RingWaveObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new RingWaveObject;}
	const TCHAR *	ClassName() { return GetString(IDS_EP_RINGWAVE); }
	SClass_ID		SuperClassID() { return GEOMOBJECT_CLASS_ID; }
	Class_ID		ClassID() { return RINGWAVE_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_AP_EXTENDED);}	
	void			ResetClassParams(BOOL fileReset);
	};

static RingWaveObjClassDesc RingWaveObjDesc;

ClassDesc* GetRingWaveObjDesc() { return &RingWaveObjDesc; }

extern HINSTANCE hInstance;

IObjParam *RingWaveObject::ip         = NULL;
IParamMap *RingWaveObject::pmapParam  = NULL;	
HWND RingWaveObject::hparam;
RingWaveObject *RingWaveObject::reditOb              = NULL;
		
#define PB_TIMEON		0
#define PB_TIMEGROW		1
#define PB_TIMEOFF		2
#define PB_REPEAT		3
#define PB_MAXD			4
#define PB_RWIDTH		5
#define PB_RES			6
#define PB_OEBREAKON	7
#define PB_OENCYC1		8
#define PB_OEDWID1		9
#define PB_OEPER1		10
#define PB_OENCYC2		11
#define PB_OEDWID2		12
#define PB_OEPER2		13
#define PB_IEBREAKON	14
#define PB_IENCYC1		15
#define PB_IEDWID1		16
#define PB_IEPER1		17
#define PB_IENCYC2		18
#define PB_IEDWID2		19
#define PB_IEPER2		20
#define PB_HEIGHT		21
#define PB_HEIGHTSEGS	22
#define PB_RADSEGS		23

static int repeattypeIDs[] = {IDC_WAVEREPEAT,IDC_WAVEGROWANDHOLD,IDC_WAVESTATIC};

static ParamUIDesc descParamRingWave[] = {

	// time on
	ParamUIDesc(
		PB_TIMEON,
		EDITTYPE_TIME,
		IDC_DW_FIRSTBLAST,IDC_DW_FIRSTBLASTSPIN,
		-999999999.0f,999999999.0f,
		10.0f),

	// grow time
	ParamUIDesc(
		PB_TIMEGROW,
		EDITTYPE_TIME,
		IDC_DW_GROWTIME,IDC_DW_GROWTIMESPIN,
		0.0f,999999999.0f,
		10.0f),

	// display until
	ParamUIDesc(
		PB_TIMEOFF,
		EDITTYPE_TIME,
		IDC_DW_OFFTIME,IDC_DW_OFFTIMESPIN,
		-999999999.0f,999999999.0f,
		10.0f),
	
	// Repeats On
	ParamUIDesc(PB_REPEAT,TYPE_RADIO,repeattypeIDs,3),

	// Max Diameter
	ParamUIDesc(
		PB_MAXD,
		EDITTYPE_UNIVERSE,
		IDC_EMITTER_DIAM,IDC_EMITTER_DIAMSPIN,
		0.0f,999999999.0f,
		1.0f),
		
	// Ring Width
	ParamUIDesc(
		PB_RWIDTH,
		EDITTYPE_UNIVERSE,
		IDC_RW_WIDTH,IDC_RW_WIDTHSPIN,
		0.0f,999999999.0f,
		1.0f),	

	// Ring Resolution
	ParamUIDesc(
		PB_RES,
		EDITTYPE_INT,
		IDC_RES,IDC_RESSPIN,
		3.0f,1000.0f,
		1.0f),

	// Outer Edge Break On
	ParamUIDesc(PB_OEBREAKON,TYPE_SINGLECHEKBOX,IDC_OE_BREAKSON),

	// Major Cycle Count
	ParamUIDesc(
		PB_OENCYC1,
		EDITTYPE_INT,
		IDC_OE_NCYC1,IDC_OE_NCYC1SPIN,
		0.0f,100000.0f,
		1.0f),
		
	// Major Cycle Width Flux
	ParamUIDesc(
		PB_OEDWID1,
		EDITTYPE_FLOAT,
		IDC_OE_WID1,IDC_OE_WID1SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),	

	// Major Cycle Flux Period
	ParamUIDesc(
		PB_OEPER1,
		EDITTYPE_TIME,
		IDC_OE_CRAWLT1,IDC_OE_CRAWLT1SPIN,
		-99999999.0f,99999999.0f,
		10.0f),

	// Minor Cycle Count
	ParamUIDesc(
		PB_OENCYC2,
		EDITTYPE_INT,
		IDC_OE_NCYC2,IDC_OE_NCYC2SPIN,
		0.0f,100000.0f,
		1.0f),
		
	// Minor Cycle Width Flux
	ParamUIDesc(
		PB_OEDWID2,
		EDITTYPE_FLOAT,
		IDC_OE_WID2,IDC_OE_WID2SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),	

	// Minor Cycle Flux Period
	ParamUIDesc(
		PB_OEPER2,
		EDITTYPE_TIME,
		IDC_OE_CRAWLT2,IDC_OE_CRAWLT2SPIN,
		-99999999.0f,99999999.0f,
		10.0f),

	// Inner Edge Break On
	ParamUIDesc(PB_IEBREAKON,TYPE_SINGLECHEKBOX,IDC_IE_BREAKSON),

	// Major Cycle Count
	ParamUIDesc(
		PB_IENCYC1,
		EDITTYPE_INT,
		IDC_IE_NCYC1,IDC_IE_NCYC1SPIN,
		0.0f,100000.0f,
		1.0f),
		
	// Major Cycle Width Flux
	ParamUIDesc(
		PB_IEDWID1,
		EDITTYPE_FLOAT,
		IDC_IE_WID1,IDC_IE_WID1SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),	

	// Major Cycle Flux Period
	ParamUIDesc(
		PB_IEPER1,
		EDITTYPE_TIME,
		IDC_IE_CRAWLT1,IDC_IE_CRAWLT1SPIN,
		-99999999.0f,99999999.0f,
		10.0f),

	// Minor Cycle Count
	ParamUIDesc(
		PB_IENCYC2,
		EDITTYPE_INT,
		IDC_IE_NCYC2,IDC_IE_NCYC2SPIN,
		0.0f,100000.0f,
		1.0f),
		
	// Minor Cycle Width Flux
	ParamUIDesc(
		PB_IEDWID2,
		EDITTYPE_FLOAT,
		IDC_IE_WID2,IDC_IE_WID2SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),	

	// Minor Cycle Flux Period
	ParamUIDesc(
		PB_IEPER2,
		EDITTYPE_TIME,
		IDC_IE_CRAWLT2,IDC_IE_CRAWLT2SPIN,
		-99999999.0f,99999999.0f,
		10.0f),

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_HINNER,IDC_HINNERSPIN,
		0.0f,999999999.0f,
		1.0f),

	// Height Segs
	ParamUIDesc(
		PB_HEIGHTSEGS,
		EDITTYPE_INT,
		IDC_HSEGS,IDC_HSEGSSPIN,
		1.0f,1000.0f,
		1.0f),

	// Radius Segs
	ParamUIDesc(
		PB_RADSEGS,
		EDITTYPE_INT,
		IDC_RSEGS,IDC_RSEGSSPIN,
		1.0f,1000.0f,
		1.0f),
};

#define RINGWAVEPARAMDESC_LENGTH 24

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, TRUE, 0 }, // start time
	{ TYPE_INT, NULL, FALSE, 1 },// grow time
	{ TYPE_INT, NULL, TRUE, 2 },// display until
	{ TYPE_INT, NULL, FALSE, 3 },// repeats
	{ TYPE_FLOAT, NULL, TRUE, 4 },// max dia
	{ TYPE_FLOAT, NULL, TRUE, 5 },// ring width
	{ TYPE_INT, NULL, TRUE, 6 },// ring resolution

	{ TYPE_INT, NULL, FALSE, 7 },// outer edge breakup on
	{ TYPE_INT, NULL, FALSE, 8 },// major cycs
	{ TYPE_FLOAT, NULL, TRUE, 9 },// width flux
	{ TYPE_INT, NULL, TRUE, 10 },// crawl time
	{ TYPE_INT, NULL, FALSE, 11 },// minor cycs
	{ TYPE_FLOAT, NULL, TRUE, 12 },// width flux
	{ TYPE_INT, NULL, TRUE, 13 },// crawl time

	{ TYPE_INT, NULL, FALSE, 14 },// inner edge breakup on
	{ TYPE_INT, NULL, FALSE, 15 },// major cycs
	{ TYPE_FLOAT, NULL, TRUE, 16 },// width flux
	{ TYPE_INT, NULL, TRUE, 17 },// crawl time
	{ TYPE_INT, NULL, FALSE, 18 },// minor cycs
	{ TYPE_FLOAT, NULL, TRUE, 19 },// width flux
	{ TYPE_INT, NULL, TRUE, 20 },// crawl time

	{ TYPE_FLOAT, NULL, TRUE, 21 },// height 
	{ TYPE_INT, NULL, TRUE, 22 }, // height segs
	{ TYPE_INT, NULL, TRUE, 23 }, // rad segs
};

#define PBLOCK_LENGTH_RINGWAVE 24

void RingWaveObjClassDesc::ResetClassParams(BOOL fileReset){ }

//--- Parameter map/block descriptors -------------------------------

#define NUM_OLDVERSIONS	0
#define CURRENT_VERSION	0

static ParamVersionDesc curVersion(descVer0,PBLOCK_LENGTH_RINGWAVE,CURRENT_VERSION);

void OuterOn(HWND hwnd)
{ SpinnerOn(hwnd,IDC_OE_NCYC1SPIN);
  SpinnerOn(hwnd,IDC_OE_WID1SPIN);
  SpinnerOn(hwnd,IDC_OE_CRAWLT1SPIN);
  SpinnerOn(hwnd,IDC_OE_NCYC2SPIN);
  SpinnerOn(hwnd,IDC_OE_WID2SPIN);
  SpinnerOn(hwnd,IDC_OE_CRAWLT2SPIN);
}
void OuterOff(HWND hwnd)
{ SpinnerOff(hwnd,IDC_OE_NCYC1SPIN);
  SpinnerOff(hwnd,IDC_OE_WID1SPIN);
  SpinnerOff(hwnd,IDC_OE_CRAWLT1SPIN);
  SpinnerOff(hwnd,IDC_OE_NCYC2SPIN);
  SpinnerOff(hwnd,IDC_OE_WID2SPIN);
  SpinnerOff(hwnd,IDC_OE_CRAWLT2SPIN);
}
void InnerOn(HWND hwnd)
{ SpinnerOn(hwnd,IDC_IE_NCYC1SPIN);
  SpinnerOn(hwnd,IDC_IE_WID1SPIN);
  SpinnerOn(hwnd,IDC_IE_CRAWLT1SPIN);
  SpinnerOn(hwnd,IDC_IE_NCYC2SPIN);
  SpinnerOn(hwnd,IDC_IE_WID2SPIN);
  SpinnerOn(hwnd,IDC_IE_CRAWLT2SPIN);
}
void InnerOff(HWND hwnd)
{ SpinnerOff(hwnd,IDC_IE_NCYC1SPIN);
  SpinnerOff(hwnd,IDC_IE_WID1SPIN);
  SpinnerOff(hwnd,IDC_IE_CRAWLT1SPIN);
  SpinnerOff(hwnd,IDC_IE_NCYC2SPIN);
  SpinnerOff(hwnd,IDC_IE_WID2SPIN);
  SpinnerOff(hwnd,IDC_IE_CRAWLT2SPIN);
}

class RingParamDlgProc : public ParamMapUserDlgProc {
public:
  RingWaveObject *ob;

  RingParamDlgProc(RingWaveObject *o) {ob=o;}
  BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
  void Update(TimeValue t);
  void DeleteThis() {delete this;}
};

void RingParamDlgProc::Update(TimeValue t)
{ if (!ob->reditOb) return;
  int repeat,outeron,inneron;
  ob->pblock->GetValue(PB_REPEAT,0,repeat,FOREVER);
  if (repeat==2) SpinnerOff(ob->hparam,IDC_DW_GROWTIMESPIN);
  else  SpinnerOn(ob->hparam,IDC_DW_GROWTIMESPIN);
  ob->pblock->GetValue(PB_OEBREAKON,0,outeron,FOREVER);
  if (outeron) OuterOn(ob->hparam);else OuterOff(ob->hparam);
  ob->pblock->GetValue(PB_IEBREAKON,0,inneron,FOREVER);
  if (inneron) InnerOn(ob->hparam);else InnerOff(ob->hparam);  
}
static HWND hDlg;

BOOL RingParamDlgProc::DlgProc(TimeValue t,IParamMap *map,HWND
                                hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{    switch (msg) 
	  { case WM_INITDIALOG: 
			{ Update(t);
			  break;
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_WAVESTATIC:
				{ SpinnerOff(hWnd,IDC_DW_GROWTIMESPIN);
				  return TRUE;
				}
			  case IDC_WAVEGROWANDHOLD:
			  case IDC_WAVEREPEAT:
				{ SpinnerOn(hWnd,IDC_DW_GROWTIMESPIN);
				  return TRUE;
				}
			  case IDC_OE_BREAKSON:
				{ int outeron;
				  ob->pblock->GetValue(PB_OEBREAKON,0,outeron,FOREVER);
				  if (outeron) OuterOn(ob->hparam);else OuterOff(ob->hparam);
				  return TRUE;
				}
			  case IDC_IE_BREAKSON:
				{ int inneron;
				  ob->pblock->GetValue(PB_IEBREAKON,0,inneron,FOREVER);
				  if (inneron) InnerOn(ob->hparam);else InnerOff(ob->hparam);
				  return TRUE;
				}
			}
	  }
	return FALSE;
}

RingWaveObject::RingWaveObject()
{	MakeRefByID(FOREVER, 0, CreateParameterBlock(descVer0, PBLOCK_LENGTH_RINGWAVE, CURRENT_VERSION));
	assert(pblock);
	
	FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	pblock->SetValue(PB_TIMEON,0,(TimeValue)0);
	pblock->SetValue(PB_TIMEGROW,0,(TimeValue)60*FToTick);
	pblock->SetValue(PB_TIMEOFF,0,(TimeValue)100*FToTick);
	pblock->SetValue(PB_REPEAT,0,2);
	pblock->SetValue(PB_MAXD,0,500.0f);
	pblock->SetValue(PB_RWIDTH,0,1.0f);
	pblock->SetValue(PB_RES,0,200);

	pblock->SetValue(PB_OEBREAKON,0,0);
	pblock->SetValue(PB_OENCYC1,0,1);
	pblock->SetValue(PB_OEDWID1,0,0.0f);
	pblock->SetValue(PB_OEPER1,0,(TimeValue)100*FToTick);
	pblock->SetValue(PB_OENCYC2,0,1);
	pblock->SetValue(PB_OEDWID2,0,0.0f);
	pblock->SetValue(PB_OEPER2,0,-(TimeValue)100*FToTick);

	pblock->SetValue(PB_IEBREAKON,0,1);
	pblock->SetValue(PB_IENCYC1,0,11);
	pblock->SetValue(PB_IEDWID1,0,0.25f);
	pblock->SetValue(PB_IEPER1,0,(TimeValue)121*FToTick);
	pblock->SetValue(PB_IENCYC2,0,29);
	pblock->SetValue(PB_IEDWID2,0,0.1f);
	pblock->SetValue(PB_IEPER2,0,-(TimeValue)27*FToTick);
	pblock->SetValue(PB_HEIGHT,0,0.0f);
	pblock->SetValue(PB_HEIGHTSEGS,0,1);
	pblock->SetValue(PB_RADSEGS,0,1);
}

void RingWaveObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleObject::BeginEditParams(ip,flags,prev);
	reditOb = this;
	this->ip = ip;

	if (pmapParam) {
		
		// Left over from last Box ceated
		pmapParam->SetParamBlock(pblock);
	} else {
		
		// Gotta make a new one.

		pmapParam = CreateCPParamMap(
			descParamRingWave,RINGWAVEPARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_RINGWAVE_UI),
			GetString(IDS_AP_PARAMS),
			0);
		}
	hparam=pmapParam->GetHWnd();
	if (pmapParam) pmapParam->SetUserDlgProc(new RingParamDlgProc(this));
}
		
void RingWaveObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleObject::EndEditParams(ip,flags,next);
	this->ip = NULL;
	reditOb=NULL;
	if (flags&END_EDIT_REMOVEUI ) {
		DestroyCPParamMap(pmapParam);
		pmapParam = NULL;
		}
	}

void RingWaveObject::MapKeys(TimeMap *map,DWORD flags)
{	Animatable::MapKeys(map,flags);
	TimeValue TempTime;
// remap values
	pblock->GetValue(PB_TIMEON,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEON,0,TempTime);
	pblock->GetValue(PB_TIMEGROW,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEGROW,0,TempTime);
	pblock->GetValue(PB_TIMEOFF,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_TIMEOFF,0,TempTime);
	pblock->GetValue(PB_OEPER1,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_OEPER1,0,TempTime);
	pblock->GetValue(PB_OEPER2,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_OEPER2,0,TempTime);
	pblock->GetValue(PB_IEPER1,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_IEPER1,0,TempTime);
	pblock->GetValue(PB_IEPER2,0,TempTime,FOREVER);
	TempTime=map->map(TempTime);
	pblock->SetValue(PB_IEPER2,0,TempTime);
}  

#define CYCLIC		0
#define GROWHOLD	1
#define STATIC		2

void RingWaveObject::BuildMesh(TimeValue t)
{	int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	int nverts,nfaces,res,i,j,repeat,hsegs, rsegs;	
	float radius,width,cyclepoint,irad,height,htop,hbot;
	TimeValue t1,t2,tg,tincycle;

	ivalid=FOREVER;
	pblock->GetValue(PB_TIMEON,t,t1,ivalid);
	pblock->GetValue(PB_TIMEGROW,t,tg,ivalid);
	pblock->GetValue(PB_TIMEOFF,t,t2,ivalid);
	pblock->GetValue(PB_REPEAT,t,repeat,ivalid);

	if (t<t1) ivalid.SetEnd(t1-1);
	else if (t>t2) ivalid.SetStart(t2);
	else ivalid.SetInstant(t);

	if ( (t<t1) || (t>t2) )
	{	mesh.setNumVerts(0);
		mesh.setNumFaces(0);
		mesh.setNumTVerts(0);
		mesh.setNumTVFaces(0);
		mesh.InvalidateGeomCache();
		return;
	}

	if (tg<FToTick) tg=FToTick;
	if (repeat==CYCLIC)
	{	tincycle=(t-t1)%tg;
		cyclepoint=(float)tincycle/(float)tg;
	}
	else if (repeat==GROWHOLD)
	{	if (t>=t1+tg)
		{	cyclepoint=1.0f;
		}
		else
		{	tincycle=(t-t1)%tg;
			cyclepoint=(float)tincycle/(float)tg;
		}
	}
	else
		cyclepoint=1.0f;

	pblock->GetValue(PB_MAXD,t,radius,ivalid);
	radius*=cyclepoint;

	pblock->GetValue(PB_RWIDTH,t,width,ivalid);
	irad=radius-width;

	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	pblock->GetValue(PB_HEIGHTSEGS,t,hsegs,ivalid);
	pblock->GetValue(PB_RADSEGS,t,rsegs,ivalid);
	htop=height*0.5f; hbot= -htop;

	int ibreakon,obreakon;
	float iwidthflux1,iwidthflux2;
	float owidthflux1,owidthflux2;
	int icycles1,icycles2;
	int ocycles1,ocycles2;
	float incycle1,incycle2;
	TimeValue iper1,iper2;
	TimeValue oper1,oper2;

	pblock->GetValue(PB_IEBREAKON,t,ibreakon,ivalid);
	pblock->GetValue(PB_OEBREAKON,t,obreakon,ivalid);

	if (ibreakon)
	{	pblock->GetValue(PB_IENCYC1,t,icycles1,ivalid);
		pblock->GetValue(PB_IEDWID1,t,iwidthflux1,ivalid);
		pblock->GetValue(PB_IEPER1,t,iper1,ivalid);
		if (fabs(iper1)<1) iper1=1;
		pblock->GetValue(PB_IENCYC2,t,icycles2,ivalid);
		pblock->GetValue(PB_IEDWID2,t,iwidthflux2,ivalid);
		pblock->GetValue(PB_IEPER2,t,iper2,ivalid);
		if (fabs(iper2)<1) iper2=1;
	}
	if (obreakon)
	{	pblock->GetValue(PB_OENCYC1,t,ocycles1,ivalid);
		pblock->GetValue(PB_OEDWID1,t,owidthflux1,ivalid);
		pblock->GetValue(PB_OEPER1,t,oper1,ivalid);
		if (fabs(oper1)<1) oper1=1;
		pblock->GetValue(PB_OENCYC2,t,ocycles2,ivalid);
		pblock->GetValue(PB_OEDWID2,t,owidthflux2,ivalid);
		pblock->GetValue(PB_OEPER2,t,oper2,ivalid);
		if (fabs(oper2)<1) oper2=1;
	}

	pblock->GetValue(PB_RES,t,res,ivalid);
	nverts=(res+1)*(rsegs+1);
	nfaces=2*res*rsegs;

	int topverts,topfaces,
		vertsinrow,facesinrow,
		mostverts,mostfaces,
		vertshere;

	BOOL isthick=FALSE;

	if (height>0.0f)
	{	isthick=TRUE;
	
		topverts=nverts;
		mostverts=topverts + 2*(res+1)*(hsegs-1);

		topfaces=nfaces;
		mostfaces=nfaces+4*res*hsegs;

		facesinrow=2*res;
		vertsinrow=2*res+2;

		nverts=topverts+mostverts;
		nfaces=topfaces+mostfaces;
	}

	mesh.setNumVerts(nverts);
	mesh.setNumFaces(nfaces);
	mesh.setNumTVerts(nverts);
	mesh.setNumTVFaces(nfaces);

	float a,b,cosu,sinu,ilocalrad,olocalrad,
		  iradcosu,oradcosu,iradsinu,oradsinu;

	float verticalportion, whereAmI, verticalmapping;

	float temp, rhere, xhere, yhere;

	for (i=0;i<=res;i++)
	{	ilocalrad=irad;
		olocalrad=radius;
		a=(float)i/(float)res;
		b=a*TWOPI;
  		cosu=(float)cos(b);
		sinu=(float)sin(b);

		if (ibreakon)
		{	incycle1=(float)(t-t1)/(float)iper1;
			incycle2=(float)(t-t1)/(float)iper2;
			ilocalrad+=width*iwidthflux1*(float)sin(TWOPI*(icycles1*a+incycle1));
			ilocalrad+=width*iwidthflux2*(float)sin(TWOPI*(icycles2*a+incycle2));
		}
		if (ilocalrad<0.0f) ilocalrad=0.0f;

		if (obreakon)
		{	incycle1=(float)(t-t1)/(float)oper1;
			incycle2=(float)(t-t1)/(float)oper2;
			olocalrad+=width*owidthflux1*(float)sin(TWOPI*(ocycles1*a+incycle1));
			olocalrad+=width*owidthflux2*(float)sin(TWOPI*(ocycles2*a+incycle2));
		}
		if (olocalrad<ilocalrad) olocalrad=ilocalrad;

		iradcosu=ilocalrad*cosu;
		iradsinu=ilocalrad*sinu;
		oradcosu=olocalrad*cosu;
		oradsinu=olocalrad*sinu;

		// top surface
		if (rsegs<2)
		{	mesh.setVert(      i, Point3(iradcosu,iradsinu,htop));
			mesh.setVert(res+1+i, Point3(oradcosu,oradsinu,htop));
			mesh.setTVert(      i,a,0.01f,0.999f);
			mesh.setTVert(res+1+i,a,0.99f,0.999f);
		}
		else
		{	for (j=0; j<=rsegs; j++)
			{	rhere = olocalrad-ilocalrad;
				temp = (float)j/(float)rsegs;
				xhere = iradcosu + temp*(oradcosu-iradcosu);
				yhere = iradsinu + temp*(oradsinu-iradsinu);
				vertshere = i+j*(res+1);
				mesh.setVert(vertshere, Point3(xhere,yhere,htop));
				mesh.setTVert(vertshere,a,temp,0.999f);
			}
		}

		// intermediate rows of vertices
		if ((isthick)&&(hsegs>1))
		{	for (j=1; j<hsegs; j++)
			{	verticalportion = (float)j/(float)hsegs;
				verticalmapping = 1.0f-verticalportion;
				whereAmI = htop-verticalportion*height;
				vertshere=topverts + vertsinrow*(j-1) + i;
				mesh.setVert(vertshere       , Point3(iradcosu,iradsinu,whereAmI));
				mesh.setVert(vertshere+res+1 , Point3(oradcosu,oradsinu,whereAmI));
				mesh.setTVert(vertshere      ,a,0.01f,verticalmapping);
				mesh.setTVert(vertshere+res+1,a,0.99f,verticalmapping);
			}
		}

		// bottom surface
		if (isthick)
		{	if (rsegs<2)
			{	mesh.setVert(mostverts+      i, Point3(iradcosu,iradsinu,hbot));
				mesh.setVert(mostverts+res+1+i, Point3(oradcosu,oradsinu,hbot));
				mesh.setTVert(mostverts+      i,a,0.01f,0.001f);
				mesh.setTVert(mostverts+res+1+i,a,0.99f,0.001f);
			}
			else
			{	for (j=0; j<=rsegs; j++)
				{	rhere = olocalrad-ilocalrad;
					temp = (float)j/(float)rsegs;
					xhere = iradcosu + temp*(oradcosu-iradcosu);
					yhere = iradsinu + temp*(oradsinu-iradsinu);
					vertshere = mostverts+i+j*(res+1);
					mesh.setVert(vertshere, Point3(xhere,yhere,hbot));
					mesh.setTVert(vertshere,a,temp,0.001f);
				}
			}
		}
    }

	int face1,face2,face3,face4,face5,face6,face7,face8;
	int vert1,vert2,vert3,vert4,
		vert1a,vert2a,vert3a,vert4a,
		vert1b,vert2b,vert3b,vert4b;

	for (i=0;i<res;i++)
	{	// top surface
		for (j=0; j<rsegs; j++)
		{	face1=2*i + 2*j*res;
			face2=face1+1;

//	vertshere = i+j*(res+1);

			vert1 = i + j*(res+1);
			vert2 = vert1+1;
			vert3 = vert2+res;
			vert4 = vert3+1;

			mesh.faces[face1].setSmGroup(1);
			mesh.faces[face1].setVerts(vert2,vert1,vert3);
			mesh.faces[face1].setEdgeVisFlags(1,1,0);
			mesh.tvFace[face1].setTVerts(vert2,vert1,vert3);

			mesh.faces[face2].setSmGroup(1);
			mesh.faces[face2].setVerts(vert3,vert4,vert2);
			mesh.faces[face2].setEdgeVisFlags(1,1,0);
			mesh.tvFace[face2].setTVerts(vert3,vert4,vert2);
		}

		// bottom surface
		if (isthick)
		{	for (j=0; j<rsegs; j++)
			{	vert1b = mostverts + i + j*(res+1);
				vert2b = vert1b+1;
				vert3b = vert2b+res;
				vert4b = vert3b+1;
	
				face7 = mostfaces + 2*i + 2*res*j;
				face8 = face7 + 1;
	
				mesh.faces[face7].setSmGroup(1);
				mesh.faces[face7].setVerts(vert3b,vert1b,vert2b);
				mesh.faces[face7].setEdgeVisFlags(1,1,0);
				mesh.tvFace[face7].setTVerts(vert3b,vert1b,vert2b);
	
				mesh.faces[face8].setSmGroup(1);
				mesh.faces[face8].setVerts(vert2b,vert4b,vert3b);
				mesh.faces[face8].setEdgeVisFlags(1,1,0);
				mesh.tvFace[face8].setTVerts(vert2b,vert4b,vert3b);
			}
		}

		// intermediate faces
		if (isthick)
		{	if (hsegs>1)
			{	for (j=1; j<=hsegs; j++)
				{	if (j==1)
					{	vert1a = i;
						vert2a = vert1a + 1;
						vert3a = i + rsegs*(res+1);
						vert4a = vert3a + 1;
	
						vert1b = i + topverts;
						vert2b = vert1b + 1;
						vert3b = vert2b + res;
						vert4b = vert3b + 1;
					}
					else if (j==hsegs)
					{	vert1b = mostverts + i;
						vert2b = vert1b + 1;
						vert1a = vert1b - vertsinrow;
						vert2a = vert2b - vertsinrow;
	
						vert3a = vert2a + res;
						vert4a = vert3a + 1;
						vert3b = vert1b + rsegs*(res+1);
						vert4b = vert3b + 1;
					}
					else
					{	vert1a = i + topverts + vertsinrow*(j-2);
						vert2a = vert1a + 1;
						vert3a = vert2a + res;
						vert4a = vert3a + 1;
	
						vert1b = vert1a + vertsinrow;
						vert2b = vert1b + 1;
						vert3b = vert2b + res;
						vert4b = vert3b + 1;
					}
			
					face3=topfaces + 2*facesinrow*(j-1) + 2*i;
					face4=face3 + 1;
					face5=face3 + facesinrow;
					face6=face5 + 1;

					mesh.faces[face3].setSmGroup(2);
					mesh.faces[face3].setVerts(vert4a,vert3a,vert3b);
					mesh.faces[face3].setEdgeVisFlags(1,1,0);
					mesh.tvFace[face3].setTVerts(vert4a,vert3a,vert3b);
		
					mesh.faces[face4].setSmGroup(2);
					mesh.faces[face4].setVerts(vert3b,vert4b,vert4a);
					mesh.faces[face4].setEdgeVisFlags(1,1,0);
					mesh.tvFace[face4].setTVerts(vert3b,vert4b,vert4a);
		
					mesh.faces[face5].setSmGroup(2);
					mesh.faces[face5].setVerts(vert1b,vert1a,vert2a);
					mesh.faces[face5].setEdgeVisFlags(1,1,0);
					mesh.tvFace[face5].setTVerts(vert1b,vert1a,vert2a);

					mesh.faces[face6].setSmGroup(2);
					mesh.faces[face6].setVerts(vert2a,vert2b,vert1b);
					mesh.faces[face6].setEdgeVisFlags(1,1,0);
					mesh.tvFace[face6].setTVerts(vert2a,vert2b,vert1b);
				}
			}
			else
			{	vert1a = i;
				vert2a = vert1a + 1;
				vert3a = i + rsegs*(res+1);
				vert4a = vert3a + 1;

				vert1b = mostverts + i;
				vert2b = vert1b + 1;
				vert3b = vert1b + rsegs*(res+1);
				vert4b = vert3b + 1;

				face3 = 2*i + topfaces;
				face4 = face3 + 1;
				face5 = face3 + facesinrow;
				face6 = face5 + 1;

				mesh.faces[face3].setSmGroup(2);
				mesh.faces[face3].setVerts(vert4a,vert3a,vert3b);
				mesh.faces[face3].setEdgeVisFlags(1,1,0);
				mesh.tvFace[face3].setTVerts(vert4a,vert3a,vert3b);
	
				mesh.faces[face4].setSmGroup(2);
				mesh.faces[face4].setVerts(vert3b,vert4b,vert4a);
				mesh.faces[face4].setEdgeVisFlags(1,1,0);
				mesh.tvFace[face4].setTVerts(vert3b,vert4b,vert4a);
	
				mesh.faces[face5].setSmGroup(2);
				mesh.faces[face5].setVerts(vert1b,vert1a,vert2a);
				mesh.faces[face5].setEdgeVisFlags(1,1,0);
				mesh.tvFace[face5].setTVerts(vert1b,vert1a,vert2a);

				mesh.faces[face6].setSmGroup(2);
				mesh.faces[face6].setVerts(vert2a,vert2b,vert1b);
				mesh.faces[face6].setEdgeVisFlags(1,1,0);
				mesh.tvFace[face6].setTVerts(vert2a,vert2b,vert1b);
			}
		}
	}

	mesh.InvalidateGeomCache();
}

Object* RingWaveObject::ConvertToType(TimeValue t, Class_ID obtype)
{	return SimpleObject::ConvertToType(t,obtype);
}

int RingWaveObject::CanConvertToType(Class_ID obtype)
{	return SimpleObject::CanConvertToType(obtype);
}

class RingWaveObjCreateCallBack : public CreateMouseCallBack {
	public:
		RingWaveObject *po;
		Point3 p0,p1,p2;
		IPoint2 sp0, sp1, sp2;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};


int RingWaveObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{	float r,r2;
	Point3 center;
	#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{
		#ifdef _3D_CREATE
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
		#else
			vpt->SnapPreview(m,m,NULL, SNAP_IN_PLANE);
		#endif
	}
	#endif
	
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE)
	{	switch(point)
		{	case 0:
				GetCOREInterface()->SetHideByCategoryFlags(
						GetCOREInterface()->GetHideByCategoryFlags() & ~(HIDE_OBJECTS|HIDE_PARTICLES));
				po->pblock->SetValue(PB_MAXD,0,0.0f);				
				po->suspendSnap = TRUE;				
				sp0 = m;
				#ifdef _3D_CREATE	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				mat.SetTrans(p0);
				break;
			case 1:
				mat.IdentityMatrix();
				sp1 = m;							   
				#ifdef _3D_CREATE	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif
				// radius	
				r = Length(p1-p0);
				mat.SetTrans(p0);
				
				if (msg==MOUSE_POINT)
				{ if (Length(sp1-sp0)<3 || (r<0.1f))
				   return CREATE_ABORT;	
				}
				po->pblock->SetValue(PB_MAXD,0,r);
				po->pmapParam->Invalidate();
				
				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
					mat.PreRotateZ(po->ip->SnapAngle(ang));
					}
				break;
			case 2:
				center = mat.GetTrans();
				mat.IdentityMatrix();
				mat.SetTrans(center);

				#ifdef _3D_CREATE	
					p2 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				#else	
					p2 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				#endif

				r   = Length(p1-p0);
				r2  = Length(p2-p1);

				po->pblock->SetValue(PB_MAXD,0,r);
				po->pblock->SetValue(PB_RWIDTH,0,r2);
				po->pmapParam->Invalidate();
				
				if (flags&MOUSE_CTRL) {
					float ang = (float)atan2(p2.y-p0.y,p2.x-p0.x);					
					mat.PreRotateZ(po->ip->SnapAngle(ang));
					}

				if (msg==MOUSE_POINT) {
					po->suspendSnap = FALSE;
					return CREATE_STOP;
					}
				break;					   
			}
		}
		else
	{	if (msg == MOUSE_ABORT)	return CREATE_ABORT;
	}
	return TRUE;
}

/*
	
	po->pmapParam->Invalidate();
				return CREATE_STOP;			
*/

static RingWaveObjCreateCallBack trackCreateCB;

CreateMouseCallBack* RingWaveObject::GetCreateMouseCallBack()
{	trackCreateCB.po=this;
	return(&trackCreateCB);
}


BOOL RingWaveObject::OKtoDisplay(TimeValue t) 
{  return (TRUE);
}



void RingWaveObject::InvalidateUI() 
{	if (pmapParam) pmapParam->Invalidate();
}

ParamDimension *RingWaveObject::GetParameterDim(int pbIndex) 
{	switch (pbIndex)
	{	case PB_MAXD:
		case PB_RWIDTH:
		case PB_HEIGHT:
			return stdWorldDim;
		case PB_TIMEON:
		case PB_TIMEGROW:
		case PB_TIMEOFF:
		case PB_OEPER1:
		case PB_OEPER2:
		case PB_IEPER1:
		case PB_IEPER2:
			return stdTimeDim;
		case PB_OEDWID1:
		case PB_OEDWID2:
		case PB_IEDWID1:
		case PB_IEDWID2:
			return stdPercentDim;
		default:
			return defaultDim;
	}
}

TSTR RingWaveObject::GetParameterName(int pbIndex)
{	switch (pbIndex)
	{	case PB_TIMEON:		return GetString(IDS_AP_TIMEON);
		case PB_TIMEGROW:	return GetString(IDS_AP_GROWTIME);
		case PB_TIMEOFF:	return GetString(IDS_AP_TIMEOFF);
		case PB_REPEAT:		return GetString(IDS_AP_REPEAT);
		case PB_MAXD:		return GetString(IDS_AP_MAXD);
		case PB_RWIDTH:		return GetString(IDS_AP_RINGW);
		case PB_RES:		return GetString(IDS_AP_RES);

		case PB_OEBREAKON:	return GetString(IDS_AP_OUTERB);
		case PB_OENCYC1:	return GetString(IDS_AP_ONCYCLES1);
		case PB_OEDWID1:	return GetString(IDS_AP_OWID1);
		case PB_OEPER1:		return GetString(IDS_AP_OPER1);
		case PB_OENCYC2:	return GetString(IDS_AP_ONCYCLES2);
		case PB_OEDWID2:	return GetString(IDS_AP_OWID2);
		case PB_OEPER2:		return GetString(IDS_AP_OPER2);

		case PB_IEBREAKON:	return GetString(IDS_AP_IUTERB);
		case PB_IENCYC1:	return GetString(IDS_AP_INCYCLES1);
		case PB_IEDWID1:	return GetString(IDS_AP_IWID1);
		case PB_IEPER1:		return GetString(IDS_AP_IPER1);
		case PB_IENCYC2:	return GetString(IDS_AP_INCYCLES2);
		case PB_IEDWID2:	return GetString(IDS_AP_IWID2);
		case PB_IEPER2:		return GetString(IDS_AP_IPER2);
		case PB_HEIGHT:		return GetString(IDS_AP_HEIGHT);
		case PB_HEIGHTSEGS:	return GetString(IDS_AP_HEIGHTSEGS);
		case PB_RADSEGS:	return GetString(IDS_AP_RADSEGS);
		break;

		default: 				return TSTR(_T(""));
	}
}

RefTargetHandle RingWaveObject::Clone(RemapDir& remap) 
{	RingWaveObject* newob = new RingWaveObject();
	newob->ReplaceReference(0,pblock->Clone(remap));	
	newob->ivalid.SetEmpty();	
	return(newob);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\lattice\lattice.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by lattice.RC
//
#define IDC_AP_TYPETET                  0
#define IDC_AP_TYPEOCT                  1
#define IDS_AP_LATTICECLASS             1
#define IDC_AP_TYPEICOSA                2
#define IDS_AP_LATTICE                  2
#define IDC_AP_MAPNEW                   3
#define IDS_AP_PARAMETERS               3
#define IDC_AP_MAPOLD                   4
#define IDS_AP_DEFDEFORMATIONS          4
#define IDC_AP_MAPNONE                  5
#define IDS_AP_SRADIUS                  5
#define IDC_AP_EDGESVIS                 6
#define IDS_AP_SSEGS                    6
#define IDC_AP_EDGESALL                 7
#define IDS_AP_SIDES                    7
#define IDS_AP_JRADIUS                  8
#define IDS_AP_JSEGS                    9
#define IDS_AP_SPLINESELMOD             10
#define IDS_AP_SELOBJECT                11
#define IDS_AP_SELVERTEX                12
#define IDS_AP_SELSEG                   13
#define IDS_AP_SELSPLINE                14
#define IDS_AP_VERTEX                   15
#define IDS_AP_SEGMENT                  16
#define IDS_AP_SPLINE                   17
#define IDS_AP_SELECT                   18
#define IDS_LIB_DESCRIPTION             19
#define IDS_EP_RANDMATLMOD              20
#define IDS_EP_DEFSURFACE               21
#define IDS_AP_METHOD                   22
#define IDS_AP_COUNT                    23
#define IDS_AP_MAT1                     24
#define IDS_AP_MAT2                     25
#define IDS_AP_MAT3                     26
#define IDS_AP_MAT4                     27
#define IDS_AP_MAT5                     28
#define IDS_AP_MAT6                     29
#define IDS_AP_MAT7                     30
#define IDS_AP_MAT8                     31
#define IDS_AP_SEED                     32
#define IDS_EP_SPINDLE                  33
#define IDS_EP_SPINDLEMOD               34
#define IDS_EP_AMOUNT                   35
#define IDS_EP_CURVITURE                36
#define IDS_RB_DEFDEFORMATIONS          39
#define IDS_EP_AMOUNTQ                  41
#define IDS_EP_CURVITUREQ               42
#define IDS_EP_FROMQ                    43
#define IDS_EP_TOQ                      44
#define IDS_EP_REGIONQ                  45
#define IDS_EP_BIAS                     46
#define IDS_EP_VOLUME                   47
#define IDD_AP_LATTICE                  101
#define IDD_SPINDLEPARAM                102
#define IDD_SPLSEL_VERTEX               206
#define IDD_SPLSEL_SEGMENT              207
#define IDD_SPLSEL_SPLINE               208
#define IDD_SPLSEL_OBJECT               209
#define IDD_PASTE_NAMEDSET              213
#define IDD_SEL_NAMEDSET                214
#define IDD_RNDMATLPARAMS               215
#define IDC_AP_STRUTRADIUS              1000
#define IDC_SPLSEL_GETVERTEX            1000
#define IDC_ANGLE                       1000
#define IDC_IDCOUNT                     1000
#define IDC_AP_STRUTSON                 1001
#define IDC_SEG_COPYNS                  1001
#define IDC_X                           1001
#define IDC_METHRND                     1001
#define IDC_AP_JUNCTSON                 1002
#define IDC_SEG_PASTENS                 1002
#define IDC_Y                           1002
#define IDC_METHLIST                    1002
#define IDC_AP_BOTHON                   1003
#define IDC_SPLINE_COPYNS               1003
#define IDC_Z                           1003
#define IDC_AP_JUNCTRADIUS              1004
#define IDC_SPLINE_PASTENS              1004
#define IDC_DIR                         1004
#define IDC_AP_STRUTSEGMENTS            1005
#define IDC_ANGLESPINNER                1005
#define IDC_IDCOUNTSPIN                 1005
#define IDC_DIRSPINNER                  1006
#define IDC_AP_JUNCTRADIUSSPIN          1007
#define IDC_NS_LIST                     1007
#define IDC_CRV                         1007
#define IDC_AP_JUNCTSEGMENTS            1008
#define IDC_SET_NAME                    1008
#define IDC_AMT                         1008
#define IDC_AP_STRUTSIDES               1009
#define IDC_AMTSPINNER                  1009
#define IDC_AP_STRUTSMOOTH              1010
#define IDC_CRVSPINNER                  1010
#define IDC_AP_STRUTRADIUSSPIN          1011
#define IDC_AP_JUNCTSEGMENTSSPIN        1012
#define IDC_AP_STRUTSEGMENTSSPIN        1013
#define IDC_AP_STRUTSIDESSPIN           1014
#define IDC_AP_JUNCTSMOOTH              1015
#define IDC_AMT2                        1015
#define IDC_CRV2                        1016
#define IDC_AP_USESUBOBJS               1016
#define IDC_AMT2SPIN                    1017
#define IDC_AP_ENDCAPS                  1018
#define IDC_CRV2SPIN                    1018
#define IDC_SQUEEZE_TO                  1019
#define IDC_AP_IGNOREHIDDEN             1019
#define IDC_SQUEEZE_FROM                1020
#define IDC_AP_SUBOBJECT                1020
#define IDC_AP_ENTIREOBJECT             1020
#define IDC_SQUEEZE_TOSPIN              1021
#define IDC_SQUEEZE_FROMSPIN            1022
#define IDC_SQUEEZE_BIAS                1023
#define IDC_SQUEEZE_BIASSPIN            1024
#define IDC_SQUEEZE_VOLUME              1025
#define IDC_SQUEEZE_VOLUMESPIN          1026
#define IDC_AP_STRUTMATID               1031
#define IDC_AP_STRUTMATIDSPIN           1032
#define IDC_AP_JUNCTMATID               1033
#define IDC_AP_JUNCTMATIDSPIN           1034
#define IDC_SQUEEZE_AFFECTREGION        1099
#define IDC_BEND_AFFECTREGION           1108
#define IDC_BEND_TO                     1109
#define IDC_MATLID1                     1109
#define IDC_BEND_TOSPIN                 1110
#define IDC_MATLID1SPIN                 1110
#define IDC_BEND_FROM                   1111
#define IDC_MATLID2                     1111
#define IDC_BEND_FROMSPIN               1112
#define IDC_MATLID2SPIN                 1112
#define IDC_MATLID3                     1113
#define IDC_MATLID3SPIN                 1114
#define IDC_MATLID4                     1115
#define IDC_MATLID4SPIN                 1116
#define IDC_MATLID5                     1117
#define IDC_MATLID5SPIN                 1118
#define IDC_MATLID6                     1119
#define IDC_MATLID6SPIN                 1120
#define IDC_MATLID7                     1121
#define IDC_MATLID7SPIN                 1122
#define IDC_MATLID8                     1123
#define IDC_MATLID8SPIN                 1124
#define IDC_SEED                        1125
#define IDC_SEEDSPIN                    1126
#define IDC_SPLSEL_GETSEGMENT           1269
#define IDC_SPLSEL_GETSPLINE            1270
#define IDC_VERT_COPYNS                 1303
#define IDC_VERT_PASTENS                1304

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1005
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\lattice\lattice.cpp ===
/**********************************************************************
 *<
	FILE: lattice.cpp

	DESCRIPTION:  Converts a mesh to a lattice

	CREATED BY: Audrey Peterson

	HISTORY: created 6 January, 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "mods2.h"
#include "windows.h"

//--- LatticeMod -----------------------------------------------------------
extern HINSTANCE hInstance;

#define MIN_AMOUNT		float(-1.0E30)
#define MAX_AMOUNT		float(1.0E30)
static Class_ID LATTICEOSM_CLASS_ID(0x148132a1, 0x2ed9401c);

typedef struct{
  DWORD vfrom,vto,face;
  int edgeindex;
  Point3 normal;
  UVVert uvfrom,uvto;
}fEdge;


const int row3size=3*sizeof(float);
typedef float Matrix4By4[4][4];
typedef float Matrix3By3[3][3];

void Mult1X4(float *A,Matrix4By4 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0]+A[3]*B[3][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1]+A[3]*B[3][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2]+A[3]*B[3][2];
   C[3]=A[0]*B[0][3]+A[1]*B[1][3]+A[2]*B[2][3]+A[3]*B[3][3];
}

void Mult1X3(float *A,Matrix3By3 B,float *C)
{
   C[0]=A[0]*B[0][0]+A[1]*B[1][0]+A[2]*B[2][0];
   C[1]=A[0]*B[0][1]+A[1]*B[1][1]+A[2]*B[2][1];
   C[2]=A[0]*B[0][2]+A[1]*B[1][2]+A[2]*B[2][2];
}

void SetUpRotation(float *Q, float *W,float Theta,Matrix4By4 Rq)
{ float ww1,ww2,ww3,w12,w13,w23,CosTheta,SinTheta,MinCosTheta;
  Point3 temp;
  Matrix3By3 R;

 ww1=W[0]*W[0];ww2=W[1]*W[1];ww3=W[2]*W[2];
 w12=W[0]*W[1];w13=W[0]*W[2];w23=W[1]*W[2];
 CosTheta=(float)cos(Theta);MinCosTheta=1.0f-CosTheta;SinTheta=(float)sin(Theta);
 R[0][0]=ww1+(1.0f-ww1)*CosTheta;
 R[0][1]=w12*MinCosTheta+W[2]*SinTheta;
 R[0][2]=w13*MinCosTheta-W[1]*SinTheta;
 R[1][0]=w12*MinCosTheta-W[2]*SinTheta;
 R[1][1]=ww2+(1.0f-ww2)*CosTheta;
 R[1][2]=w23*MinCosTheta+W[0]*SinTheta;
 R[2][0]=w13*MinCosTheta+W[1]*SinTheta;
 R[2][1]=w23*MinCosTheta-W[0]*SinTheta;
 R[2][2]=ww3+(1.0f-ww3)*CosTheta;
 Mult1X3(Q,R,&temp.x);
 memcpy(Rq[0],R[0],row3size);memcpy(Rq[1],R[1],row3size);memcpy(Rq[2],R[2],row3size);
 Rq[3][0]=Q[0]-temp.x;Rq[3][1]=Q[1]-temp.y;Rq[3][2]=Q[2]-temp.z;
 Rq[0][3]=Rq[1][3]=Rq[2][3]=0.0f;Rq[3][3]=1.0f;
}
void RotateOnePoint(float *Pin,float *Q, float *W,float Theta)
{ Matrix4By4 Rq;
  float Pout[4],Pby4[4];

 SetUpRotation(Q,W,Theta,Rq);
 memcpy(Pby4,Pin,row3size);Pby4[3]=1.0f;
 Mult1X4(Pby4,Rq,Pout);
 memcpy(Pin,Pout,row3size);
}

class LatticeMod: public Modifier {
	
	protected:
		static IObjParam *ip;
		
	public:
		static IParamMap *pmapParam;
		static LatticeMod *lattMod;
		IParamBlock *pblock;
		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_AP_LATTICE); }  
		virtual Class_ID ClassID() { return LATTICEOSM_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_AP_LATTICE); }
		IOResult Load(ILoad *iload);

		LatticeMod();
		virtual ~LatticeMod();

		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO; }
		// Possible GOTCHA -- Modifiers like this one, which completely change the type of
		// object change ALL channels!  Be sure to tell the system!
		ChannelMask ChannelsChanged() { return PART_ALL; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Class_ID InputType() {return triObjectClassID;}
		Interval LocalValidity(TimeValue t);

		// From BaseObject
		BOOL ChangeTopology() {return TRUE;}
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}

 		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) { return TSTR(GetString(IDS_AP_PARAMETERS));}		

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip, ULONG flags,Animatable *next);

		void BuildMeshFromShape(TimeValue t,ModContext &mc, ObjectState * os, Mesh &mesh);

		void UpdateUI(TimeValue t) {}
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
	};

class LatticeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new LatticeMod; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_LATTICE); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return  LATTICEOSM_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_AP_DEFDEFORMATIONS);}
	void			ResetClassParams(BOOL fileReset);
	};

static LatticeClassDesc LatticeDesc;
ClassDesc* GetLatticeModDesc() { return &LatticeDesc; }

IObjParam*		LatticeMod::ip          = NULL;
IParamMap *		LatticeMod::pmapParam = NULL;
LatticeMod *	LatticeMod::lattMod = NULL;

void LatticeClassDesc::ResetClassParams(BOOL fileReset)
	{
	}

//--- Parameter map/block descriptors -------------------------------

#define PB_GEOMETRY		0
#define PB_SRADIUS		1
#define PB_SSEGS		2
#define PB_SSIDES		3
#define PB_EDGES		4
#define PB_ENDCAPS		5
#define PB_SSMOOTH		6
#define PB_JRADIUS		7
#define PB_JSEGS		8
#define PB_GEOBASE		9
#define PB_JSMOOTH		10
#define PB_MAPPING		11
#define PB_STRUTMTL		12
#define PB_JUNCTMTL		13
#define PB_ENTIREOBJECT	14

static int geometryIDs[] = {IDC_AP_STRUTSON,IDC_AP_JUNCTSON,IDC_AP_BOTHON};
static int geobasicIDs[] = {IDC_AP_TYPETET,IDC_AP_TYPEOCT,IDC_AP_TYPEICOSA};
static int mappingIDs[] = {IDC_AP_MAPNONE,IDC_AP_MAPOLD,IDC_AP_MAPNEW};

//
//
// Parameters
static ParamUIDesc descParam[] = {
	// Geometry
	ParamUIDesc(PB_GEOMETRY,TYPE_RADIO,geometryIDs,3),

	// Amount
	ParamUIDesc(
		PB_SRADIUS,
		EDITTYPE_UNIVERSE,
		IDC_AP_STRUTRADIUS,IDC_AP_STRUTRADIUSSPIN,
		0.0f,MAX_AMOUNT,
		0.5f),

	// Segments
	ParamUIDesc(
		PB_SSEGS,
		EDITTYPE_INT,
		IDC_AP_STRUTSEGMENTS,IDC_AP_STRUTSEGMENTSSPIN,
		1.0f,100.0f,
		0.5f),

	// Sides
	ParamUIDesc(
		PB_SSIDES,
		EDITTYPE_INT,
		IDC_AP_STRUTSIDES,IDC_AP_STRUTSIDESSPIN,
		3.0f,100.0f,
		0.5f),

	// Edges
	ParamUIDesc(PB_EDGES,TYPE_SINGLECHEKBOX,IDC_AP_IGNOREHIDDEN),

	// EndCaps
	ParamUIDesc(PB_ENDCAPS,TYPE_SINGLECHEKBOX,IDC_AP_ENDCAPS),

	// Strut Smooth
	ParamUIDesc(PB_SSMOOTH,TYPE_SINGLECHEKBOX,IDC_AP_STRUTSMOOTH),

	// Amount
	ParamUIDesc(
		PB_JRADIUS,
		EDITTYPE_UNIVERSE,
		IDC_AP_JUNCTRADIUS,IDC_AP_JUNCTRADIUSSPIN,
		0.0f,MAX_AMOUNT,
		0.5f),

	// Segments
	ParamUIDesc(
		PB_JSEGS,
		EDITTYPE_INT,
		IDC_AP_JUNCTSEGMENTS,IDC_AP_JUNCTSEGMENTSSPIN,
		1.0f,100.0f,
		0.5f),

	// Geo base type
	ParamUIDesc(PB_GEOBASE,TYPE_RADIO,geobasicIDs,3),

	// Texture coords
	ParamUIDesc(PB_JSMOOTH,TYPE_SINGLECHEKBOX,IDC_AP_JUNCTSMOOTH),

	// Output type
	ParamUIDesc(PB_MAPPING,TYPE_RADIO,mappingIDs,3),

	// StrutMtl
	ParamUIDesc(
		PB_STRUTMTL,
		EDITTYPE_INT,
		IDC_AP_STRUTMATID,IDC_AP_STRUTMATIDSPIN,
		1.0f,255.0f,
		1.0f),

	// JunctMtl
	ParamUIDesc(
		PB_JUNCTMTL,
		EDITTYPE_INT,
		IDC_AP_JUNCTMATID,IDC_AP_JUNCTMATIDSPIN,
		1.0f,255.0f,
		1.0f),

	// Texture coords
	ParamUIDesc(PB_ENTIREOBJECT,TYPE_SINGLECHEKBOX,IDC_AP_ENTIREOBJECT),
};

#define PARAMDESC_LENGTH 15

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_INT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 },
	{ TYPE_INT, NULL, FALSE, 11 },
	{ TYPE_INT, NULL, FALSE, 12 },
	{ TYPE_INT, NULL, FALSE, 13 },
 };
static ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, TRUE, 2 },
	{ TYPE_INT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_INT, NULL, FALSE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_INT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, FALSE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 },
	{ TYPE_INT, NULL, FALSE, 11 },
	{ TYPE_INT, NULL, FALSE, 12 },
	{ TYPE_INT, NULL, FALSE, 13 },
	{ TYPE_INT, NULL, FALSE, 14 },
 };

#define PBLOCK_LENGTH	15

static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,14,0),
	};
static ParamBlockDescID *currentver=descVer1;
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(currentver,PBLOCK_LENGTH,CURRENT_VERSION);

LatticeMod::LatticeMod()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(currentver, PBLOCK_LENGTH, CURRENT_VERSION));
	pblock->SetValue(PB_GEOMETRY, TimeValue(0), 2);
	pblock->SetValue(PB_SRADIUS, TimeValue(0), 2.0f);
	pblock->SetValue(PB_SSEGS	, TimeValue(0), 1);
	pblock->SetValue(PB_SSIDES, TimeValue(0), 4);
	pblock->SetValue(PB_EDGES, TimeValue(0), 1);
	pblock->SetValue(PB_ENDCAPS, TimeValue(0), 0);
	pblock->SetValue(PB_SSMOOTH, TimeValue(0), 0);
	pblock->SetValue(PB_JRADIUS, TimeValue(0), 5.0f);
	pblock->SetValue(PB_JSEGS, TimeValue(0), 1);
	pblock->SetValue(PB_GEOBASE, TimeValue(0), 1);
	pblock->SetValue(PB_JSMOOTH, TimeValue(0), 0);
	pblock->SetValue(PB_MAPPING, TimeValue(0), 1);
	pblock->SetValue(PB_STRUTMTL, TimeValue(0), 1);
	pblock->SetValue(PB_JUNCTMTL, TimeValue(0), 2);
	pblock->SetValue(PB_ENTIREOBJECT, 0,1);
	}

LatticeMod::~LatticeMod()
	{	
	}

const float HalfIntMax=16383.5f;
/* number between -1 and 1 */
float RND11()
{ float num;

   num=(float)rand()-HalfIntMax;
   return(num/HalfIntMax);
}

Interval LatticeMod::LocalValidity(TimeValue t)
	{
	// if being edited, return NEVER forces a cache to be built 
	// after previous modifier.
	if (TestAFlag(A_MOD_BEING_EDITED))
		return NEVER;  
	Interval valid = GetValidity(t);	
	return valid;
	}

RefTargetHandle LatticeMod::Clone(RemapDir& remap)
	{
	LatticeMod* newmod = new LatticeMod();	
	newmod->ReplaceReference(0,pblock->Clone(remap));
	return(newmod);
	}

 static TriObject *IsUseable(Object *pobj,TimeValue t)
{ 
  if (pobj->SuperClassID()==GEOMOBJECT_CLASS_ID)
  {	if (pobj->IsSubClassOf(triObjectClassID)) 
      return (TriObject*)pobj;
    else 
	{ if (pobj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)pobj->ConvertToType(t,triObjectClassID);			
	}
  }
  return NULL;
}

void Checkfordup(DWORD *curface,int P0,int P1,fEdge *edgelst,int *edges,int face,Mesh &mesh,BOOL douv)
{ int i,found;

  found=i=0;
  while ((!found)&&(i<*edges))
   { found=((edgelst[i].vto==curface[P0])&&(edgelst[i].vfrom==curface[P1]))||
            ((edgelst[i].vfrom==curface[P0])&&(edgelst[i].vto==curface[P1]));
     if (!found) i++;
   }
   if (!found)
   { edgelst[i].vfrom=curface[P0];edgelst[i].vto=curface[P1];
     edgelst[i].face=face;edgelst[i].edgeindex=P0;
	 if (douv)
	 { edgelst[i].uvfrom=mesh.tVerts[mesh.tvFace[face].t[P0]];
	   edgelst[i].uvto=mesh.tVerts[mesh.tvFace[face].t[P1]];
	 }
    (*edges)++;
   }
}

void GetEdges(Mesh &mesh,fEdge *edgelst,int *edges,int face,BOOL useall,BOOL douv,BOOL all,BitArray subedgelst)
{ DWORD *curface=&(mesh.faces[face]).v[0],flags=mesh.faces[face].flags;
  int cnt=face*3;
  if (all?(useall||((flags & EDGE_A)>0)):subedgelst[cnt])
    Checkfordup(curface,0,1,edgelst,edges,face,mesh,douv);
  if (all ?(useall||((flags & EDGE_B)>0)):subedgelst[cnt+1])
    Checkfordup(curface,1,2,edgelst,edges,face,mesh,douv);
  if (all ?(useall||((flags & EDGE_C)>0)):subedgelst[cnt+2])
    Checkfordup(curface,2,0,edgelst,edges,face,mesh,douv);
}

void SphericalInterpolate (Mesh& amesh, int v1, int v2, int *current, int num)
{	int i;
	float theta, theta1, theta2, sn, cs, rad;
	Point3 a, b, c;

	if (num<2) { return; }
	a=amesh.getVert (v1);
	b=amesh.getVert (v2);
	rad = DotProd (a,a);
	if (rad==0) 
	{	for (i=1; i<num; i++) amesh.setVert ((*current)++, a);
		return;
	}
	cs = DotProd (a,b) / rad;
	LimitValue (cs, -1.0f, 1.0f);
	theta = (float) acos (cs);
	sn = (float) sin (theta);

	for (i=1; i<num; i++) 
	{	theta1 = (theta*i)/num;
		theta2 = (theta*(num-i))/num;
		c = (a*((float)sin(theta2))+b*((float)sin(theta1)))/sn;
		amesh.setVert ((*current)++, c);
	}
}

int tetra_find_vert_index (int s, int f, int r, int c)
{						// segs, face, row, column.
	if (r==0) {	return (f<3?0:1); }
	if (c==0) {	if (r==s)  return(f<3?f+1:3); 
	  return (f<3?4+(s-1)*f+r-1:4+(s-1)*4+r-1); 
	}
	if (c==r) 
	{	if (r==s) {	return (f<3?(f+1)%3+1:2); }
		return(f<3?4+(s-1)*((f+1)%3)+r-1:4+(s-1)*3+r-1); 
	}
	if (r==s)
	{switch (f) {
		case 0: return 4+(s-1)*3 + c-1;
		case 1: return 4+(s-1)*5 + c-1;
		case 2:	return 4+(s-1)*4 + s-1-c;
		case 3:	return 4+(s-1)*5 + s-1-c;
		}
	}
	return 4 + (s-1)*6 + f*(s-1)*(s-2)/2 + (r-2)*(r-1)/2 + c-1;
}

int octa_find_vert_index (int s, int f, int r, int c)
{						// segs, face, row, column.
	if (r==0)  // Top corner of face
	  	return (f<4?0:5);	
	if (r==s) 
	{  	if (((f<4)&&(c==0)) || ((f>3)&&(c==r))) return f%4+1;
		if (((f>3)&&(c==0)) || ((f<4)&&(c==r))) return (f+1)%4+1;
		if (f<4) return 6+(s-1)*(8+f)+c-1;
		return 6+(s-1)*(4+f)+s-1-c;
	}
	if (c==0)  // r is between 0 and s.
		return (f<4?6+(s-1)*f + r-1:6+(s-1)*((f+1)%4+4) + r-1);		
	if (c==r) return(f<4?6+(s-1)*((f+1)%4) + r-1:6+(s-1)*f + r-1);
	return 6 + (s-1)*12 + f*(s-1)*(s-2)/2 + (r-1)*(r-2)/2 + c-1;
}

int icosa_find_vert_index (int s, int f, int r, int c)
{							// segs, face, row, column
	if (r==0) 	// Top corner of face
		return(f<5?0:(f>14?11:f-4));
	if ((r==s) && (c==0)) { // Lower left corner of face
		if (f<5) { return f+1; }
		if (f<10) { return (f+4)%5 + 6; }
		if (f<15) { return (f+1)%5 + 1; }
		return (f+1)%5 + 6;
	}
	if ((r==s) && (c==s)) { // Lower right corner
		if (f<5) { return (f+1)%5+1; }
		if (f<10) { return f+1; }
		if (f<15) { return f-9; }
		return f-9;
	}
	if (r==s) { // Bottom edge
		if (f<5) { return 12 + (5+f)*(s-1) + c-1; }
		if (f<10) { return 12 + (20+(f+4)%5)*(s-1) + c-1; }
		if (f<15) { return 12 + (f-5)*(s-1) + s-1-c; }
		return 12 + (5+f)*(s-1) + s-1-c;
	}
	if (c==0) { // Left edge
		if (f<5) { return 12 + f*(s-1) + r-1; }
		if (f<10) { return 12 + (f%5+15)*(s-1) + r-1; }
		if (f<15) { return 12 + ((f+1)%5+15)*(s-1) + s-1-r; }
		return 12 + ((f+1)%5+25)*(s-1) + r-1;
	}
	if (c==r) { // Right edge
		if (f<5) { return 12 + ((f+1)%5)*(s-1) + r-1; }
		if (f<10) { return 12 + (f%5+10)*(s-1) + r-1; }
		if (f<15) { return 12 + (f%5+10)*(s-1) + s-1-r; }
		return 12 + (f%5+25)*(s-1) + r-1;
	}
	// Not an edge or corner.
	return 12 + 30*(s-1) + f*(s-1)*(s-2)/2 + (r-1)*(r-2)/2 + c-1;
}

int find_vert_index (int basetype, int segs, int face, int row, int column)
{ 	switch (basetype) {
	case 0: return tetra_find_vert_index (segs, face, row, column);
	case 1: return octa_find_vert_index (segs, face, row, column);
	default: return icosa_find_vert_index (segs, face, row, column);
	}
}

void DoHedron(float radius,Mesh& mesh,int nv,int segs,int basetype,int nfaces,BOOL smooth,int nf,int mtlid)
{int nsections,i,face,bv=nv,b1=nv+1;
 switch (basetype)
 {	case 0: // Based on tetrahedron
		// First four tetrahedral vertices 
	{	nsections=4;
		mesh.setVert (nv++, (float)0.0, (float)0.0, radius);
		mesh.setVert (nv++, radius*((float) sqrt(8./9.)), (float)0.0, -radius/((float)3.));
		mesh.setVert (nv++, -radius*((float) sqrt(2./9.)), radius*((float) sqrt(2./3.)), -radius/((float)3.));
		mesh.setVert (nv++, -radius*((float) sqrt(2./9.)), -radius*((float) sqrt(2./3.)), -radius/((float)3.));

		// Edge vertices
		int b2=bv+2,b3=bv+3;
		SphericalInterpolate (mesh, bv, b1, &nv, segs);
		SphericalInterpolate (mesh, bv, b2, &nv, segs);
		SphericalInterpolate (mesh, bv, b3, &nv, segs);
		SphericalInterpolate (mesh, b1, b2, &nv, segs);
		SphericalInterpolate (mesh, b1, b3, &nv, segs);
		SphericalInterpolate (mesh, b2, b3, &nv, segs);

		// Face vertices
		int b4=4+bv;
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, b4+i, b4+(segs-1)+i, &nv, i+1);
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, b4+(segs-1)+i, b4+2*(segs-1)+i, &nv, i+1);
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, b4+2*(segs-1)+i, b4+i, &nv, i+1);
		for (i=1; i<segs-1; i++) SphericalInterpolate (mesh, b4+4*(segs-1)+i, b4+3*(segs-1)+i, &nv, i+1);
	}
		break;

	case 1: //Based on the Octahedron
		// First 6 octahedral vertices
	{	nsections=8;
		mesh.setVert (nv++, (float)0, (float)0, radius);
		mesh.setVert (nv++, radius, (float)0, (float)0);
		mesh.setVert (nv++, (float)0, radius, (float)0);
		mesh.setVert (nv++, -radius, (float)0, (float)0);
		mesh.setVert (nv++, (float)0, -radius, (float)0);
		mesh.setVert (nv++, (float)0, (float)0, -radius);

		// Edge vertices
		for (face=0; face<4; face++) SphericalInterpolate (mesh, bv, face+b1, &nv, segs);
		for (face=0; face<4; face++) SphericalInterpolate (mesh, bv+5, face+b1, &nv, segs);
		for (face=0; face<4; face++) SphericalInterpolate (mesh, face+b1, (face+1)%4+b1, &nv, segs);
		 int b6=bv+6;
		// Face vertices
		for (face=0; face<4; face++) 
		 for (i=1; i<segs-1; i++) 
			 SphericalInterpolate (mesh, b6+face*(segs-1)+i, b6+((face+1)%4)*(segs-1)+i, &nv, i+1);
		for (face=0; face<4; face++)
		 for (i=1; i<segs-1; i++)
			 SphericalInterpolate (mesh, b6+((face+1)%4+4)*(segs-1)+i, b6+(face+4)*(segs-1)+i, &nv, i+1);
	}
		break;

	case 2:  // Based on the Icosahedron
		// First 12 icosahedral vertices
	{	float subz,subrad,theta;
		nsections=20;
		mesh.setVert (nv++, (float)0, (float)0, radius);
		subz = (float) sqrt (.2) * radius;
		subrad = 2*subz;
		for (face=0; face<5; face++) {
			theta = 2*PI*face/5;
			mesh.setVert (nv++, subrad*((float)cos(theta)), subrad*((float)sin(theta)), subz);
		}
		for (face=0; face<5; face++) {
			theta = PI*(2*face+1)/5;
			mesh.setVert (nv++, subrad*((float)cos(theta)), subrad*((float)sin(theta)), -subz);
		}
 		mesh.setVert (nv++, (float)0, (float)0, -radius);

		int b6=bv+6,b12=bv+12;
		// Edge vertices: 6*5*(segs-1) of these.
		for (face=0; face<5; face++) SphericalInterpolate (mesh, bv, face+b1, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+b1, (face+1)%5+b1, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+b1, face+b6, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+b1, (face+4)%5+b6, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, face+b6, (face+1)%5+b6, &nv, segs);
		for (face=0; face<5; face++) SphericalInterpolate (mesh, bv+11, face+b6, &nv, segs);
		
		// Face vertices: 4 rows of 5 faces each.
		for (face=0; face<5; face++) 
			for (i=1; i<segs-1; i++) 
				SphericalInterpolate (mesh, b12+face*(segs-1)+i, b12+((face+1)%5)*(segs-1)+i, &nv, i+1);
		for (face=0; face<5; face++) 
			for (i=1; i<segs-1; i++) 
				SphericalInterpolate (mesh, b12+(face+15)*(segs-1)+i, b12+(face+10)*(segs-1)+i, &nv, i+1);
		for (face=0; face<5; face++) 
		 for (i=1; i<segs-1; i++) 
		   SphericalInterpolate (mesh, b12+((face+1)%5+15)*(segs-1)+segs-2-i, b12+(face+10)*(segs-1)+segs-2-i, &nv, i+1);
		for (face=0; face<5; face++) 
			for (i=1; i<segs-1; i++) 
				SphericalInterpolate (mesh, b12+((face+1)%5+25)*(segs-1)+i, b12+(face+25)*(segs-1)+i, &nv, i+1);
		}
		break;
	}

	// Now make faces 
	// Set all smoothing, edge flags
	int fcount=nf,sgroup(smooth?1:0);
	for (i=0; i<nfaces; i++) 
	{ if (mtlid>=0) mesh.faces[fcount].setMatID(mtlid);
	  mesh.faces[fcount].setEdgeVisFlags(1,1,1);
	  mesh.faces[fcount++].setSmGroup(sgroup);
	}
	int row,column,a,b,c,d;
	for (face=0; face<nsections; face++)
	{ for (row=0; row<segs; row++)
		{  for (column=0; column<=row; column++) 
			{	a = bv+find_vert_index (basetype, segs, face, row, column);
				b = bv+find_vert_index (basetype, segs, face, row+1, column);
				c = bv+find_vert_index (basetype, segs, face, row+1, column+1);
				mesh.faces[nf].setVerts (a,b,c);
				nf++;
				if (column<row)
				{	d = bv+find_vert_index (basetype, segs, face, row, column+1);
					mesh.faces[nf].setVerts (a,c,d);
					nf++;
				}
			}
		}
	}
}

BOOL VertexinWhichFace(int v,Face *flst,int infaces,int *aface,int *isv)
{ BOOL found;

  found=0;
  while ((*aface<infaces)&&(!found))
  { *isv=0;
    while ((!found)&&(*isv<3))
    {  found=(flst[*aface].v[*isv]==(DWORD)v);
      if (!found) (*isv)++;
    }
    if (!found) (*aface)++;
  }
  return(found);
}

void LatticeMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{TriObject *triOb;
	if ((triOb=IsUseable(os->obj,t))==NULL) return;

	// Get our personal validity interval...
	Interval valid = GetValidity(t);
	// and intersect it with the channels we use as input (see ChannelsUsed)
	valid &= os->obj->ChannelValidity(t,TOPO_CHAN_NUM);
	valid &= os->obj->ChannelValidity(t,GEOM_CHAN_NUM);
	BOOL whole=FALSE;
	pblock->GetValue(PB_ENTIREOBJECT,0,whole,FOREVER); 
	int edges=0,inverts=triOb->GetMesh().getNumVerts(),infaces=triOb->GetMesh().getNumFaces();
	int numedges=infaces*3,tverts=triOb->GetMesh().getNumTVerts();
	int subvs=0;
	BOOL useall;
	int alledges;
	pblock->GetValue(PB_EDGES,0,alledges,FOREVER); useall=(alledges==0);
	BitArray subedgelst,vertSel,faceSel,fmuststay,vmuststay;
	int basev=0,basef=0;
	Face *fstaylst=NULL;TVFace *tvfstaylst=NULL;UVVert *tvstaylst=NULL;
	int addmap,oldtvs=0;
	pblock->GetValue(PB_MAPPING,0,addmap,FOREVER); 
	if ((addmap==1)&&(tverts==0)) addmap=0;
	BitArray savedtvlst;int selLevel=triOb->GetMesh().selLevel;
	BOOL submesh=(!whole)&&(selLevel!=MESH_OBJECT);
 	int edgesize=infaces*3;
	subedgelst.SetSize(edgesize);subedgelst.ClearAll();
	if (submesh)
	{ faceSel.SetSize(infaces);faceSel.ClearAll();
	  vertSel.SetSize(inverts);vertSel.ClearAll();
	  if (selLevel==MESH_FACE) faceSel=triOb->GetMesh().faceSel; 
	  if (selLevel==MESH_VERTEX) vertSel=triOb->GetMesh().vertSel; 
	  if (selLevel==MESH_EDGE) subedgelst=triOb->GetMesh().edgeSel;
	  int edgenum=0;
	  fmuststay.SetSize(infaces);fmuststay.ClearAll();
	  vmuststay.SetSize(inverts);vmuststay.ClearAll();
	  BOOL visonly=!useall;
	  BOOL cull=(subedgelst.NumberSet()) && visonly;
	  for (int fcnt=0;(fcnt<infaces);fcnt++)
	  { DWORD flags=triOb->GetMesh().faces[fcnt].flags;int e1=edgenum+1,e2=edgenum+2;
	    BOOL invis0=((flags & EDGE_A)==0),invis1=((flags & EDGE_B)==0),invis2=((flags & EDGE_C)==0);
		BOOL keepface=TRUE;
	    if (cull) 
		{ if (subedgelst[edgenum]&& invis0) subedgelst.Clear(edgenum);
		  if (subedgelst[e1]&& invis1) subedgelst.Clear(e1);
		  if (subedgelst[e2]&& invis2) subedgelst.Clear(e2);
		}
		if (faceSel[fcnt]) 
		{ if (useall ||(!invis0)) subedgelst.Set(edgenum);
		  if (useall ||(!invis1)) subedgelst.Set(e1);
		  if (useall ||(!invis2)) subedgelst.Set(e2);
		  keepface=FALSE;
		}
		else 
		{ keepface=!((subedgelst[edgenum]||(visonly&&invis0))&&((subedgelst[e1]||(visonly&&invis1))&&(subedgelst[e2]||(visonly&&invis2))));
		}
		int v0=triOb->GetMesh().faces[fcnt].v[0],v1=triOb->GetMesh().faces[fcnt].v[1];
		int v2=triOb->GetMesh().faces[fcnt].v[2];
		if (subedgelst[edgenum]) { vertSel.Set(v0);vertSel.Set(v1);}
		if (subedgelst[e1]) { vertSel.Set(v1);vertSel.Set(v2);}
		if (subedgelst[e2]) { vertSel.Set(v0);vertSel.Set(v2);}
		if (keepface)
		{ fmuststay.Set(fcnt);
		  vmuststay.Set(v0);vmuststay.Set(v1);vmuststay.Set(v2);
		}
		edgenum+=3;
	  }
	  subvs=vertSel.NumberSet();
	  vmuststay=vmuststay | (~vertSel);
	  basev=vmuststay.NumberSet();
	  basef=fmuststay.NumberSet();
	  fstaylst=new Face[basef];assert(fstaylst);
	  int cnt=0;
	  for (fcnt=0;fcnt<infaces;fcnt++) 
	  { if (fmuststay[fcnt]) fstaylst[cnt++]=triOb->GetMesh().faces[fcnt];}
	  if ((addmap>0)&&(tverts>0))
	  { savedtvlst.SetSize(tverts);
	    int cnt=0;tvfstaylst=new TVFace[basef];assert(tvfstaylst);
		for (int i=0;i<infaces;i++)
		  if (fmuststay[i])
		{ tvfstaylst[cnt]=triOb->GetMesh().tvFace[i];
		  savedtvlst.Set(tvfstaylst[cnt].t[0]);
		  savedtvlst.Set(tvfstaylst[cnt].t[1]);
		  savedtvlst.Set(tvfstaylst[cnt].t[2]);cnt++;
		}
		oldtvs=savedtvlst.NumberSet();
		tvstaylst=new UVVert[oldtvs];cnt=0;
	    for (i=0;i<tverts;i++)
		{ if (savedtvlst[i])
		  tvstaylst[cnt++]=triOb->GetMesh().tVerts[i];
		}
	  } else if (addmap) oldtvs=1;
	}
	Point3 *vlst=new Point3[inverts];
	assert(vlst);
    fEdge *edgelst=NULL;
	UVVert *tvlst=NULL;
	int nummtls=0,multi=0;
	if ((inverts==0)&&(infaces==0)) 
	{ triOb->GetMesh().setNumVerts(0);
	  triOb->GetMesh().setNumFaces(0);
	  triOb->GetMesh().setNumTVerts(0);
	  triOb->GetMesh().setNumTVFaces(0);
	}
	else
	{
	int type,smooth;
	pblock->GetValue(PB_GEOMETRY,0,type,FOREVER); 
	for (int i=0;i<inverts;i++)
	   vlst[i]=triOb->GetMesh().verts[i];
	assert((edgelst=new fEdge[numedges])!=NULL);
	if (addmap==1)
	{ tvlst=new UVVert[inverts];	}
	for (i=0;i<infaces;i++)
      GetEdges(triOb->GetMesh(),edgelst,&edges,i,useall,addmap==1,!submesh,subedgelst);
	int outverts=0,outfaces=0;
	int jsegs,geobase,ssegs,ssides,endcaps,veachv,veachf,eeachv,eeachf,nsegs;
	int toutv=0,strutID,junctID;
	int realverts=(submesh?subvs:inverts);
	if ((realverts>0)&&(type>0))
	{ pblock->GetValue(PB_JSEGS,t,jsegs,FOREVER); if (jsegs<1) jsegs=1;
	  pblock->GetValue(PB_GEOBASE,t,geobase,FOREVER); if (geobase<0) geobase=0;
	  pblock->GetValue(PB_JUNCTMTL,t,junctID,FOREVER); 
//	  if (junctID>nummtls) junctID=0; 
	  junctID-=1;
      veachf=(jsegs*jsegs*(nsegs=(geobase==0?4:(geobase==1?8:20))));
	  veachv=veachf/2 + 2;
	  outfaces=veachf*realverts;
	  outverts=veachv*realverts;
	  if (addmap==1) 
	  { toutv=inverts;
	    for (i=0;i<inverts;i++)
	    { int inwhich=0,vnum;
		  if (VertexinWhichFace(i,triOb->GetMesh().faces,infaces,&inwhich,&vnum))
		    tvlst[i]=triOb->GetMesh().tVerts[triOb->GetMesh().tvFace[inwhich].t[vnum]];
		  else tvlst[i]=Point3(0.0f,0.0f,0.0f);
		}
	  }
	}
	if ((edges>0)&&(type!=1))
	{ pblock->GetValue(PB_SSEGS,t,ssegs,FOREVER); if (ssegs<1) ssegs=1;
	  pblock->GetValue(PB_SSIDES,t,ssides,FOREVER); if (ssides<3) ssides=3;
	  pblock->GetValue(PB_ENDCAPS,t,endcaps,FOREVER); 
	  pblock->GetValue(PB_STRUTMTL,t,strutID,FOREVER); 
//	  if (strutID>nummtls) strutID=0;
	  strutID-=1;
      outverts+=edges*(eeachv=((ssegs+1)*ssides+(endcaps?2:0)));
	  outfaces+=edges*(eeachf=(ssegs*ssides*2+(endcaps?2*ssides:0)));
	  if (addmap==1) toutv+=(ssegs+1)*(ssides+1)*edges;
	  else if (addmap==2) toutv=(ssegs+1)*(ssides+1);
	}
	outverts+=basev;outfaces+=basef;toutv+=oldtvs;
	BOOL mapsphere=(realverts>0)&&((addmap==2)&&(type!=0));
	triOb->GetMesh().setNumVerts(mapsphere?veachv:outverts);
	triOb->GetMesh().setNumFaces(mapsphere?veachf:outfaces);
	triOb->GetMesh().setNumTVerts(((addmap==0)|| mapsphere)?0:toutv);
	triOb->GetMesh().setNumTVFaces(((addmap==0)|| mapsphere)?0:outfaces);
	int vertexnum=0,face=0,ntvs=0;
	if ((realverts>0)&&(type>0))
	{ float radius;
	  UVVert uv;
	  pblock->GetValue(PB_JRADIUS,t,radius,FOREVER); 
	  pblock->GetValue(PB_JSMOOTH,0,smooth,FOREVER); 
	  if (radius<0.0f) radius=0.0f;
	  DoHedron(radius,triOb->GetMesh(),vertexnum,jsegs,geobase,veachf,smooth,face,junctID);
	  int fcnt=0,vcnt=veachv;
	  if (addmap==2)
	  {	Matrix3 id(1);
		triOb->GetMesh().ApplyUVWMap (MAP_SPHERICAL, 1.0f, 1.0f, 1.0f, 0, 0, 0, 0, id);
		triOb->GetMesh().setNumVerts(outverts,TRUE);
		triOb->GetMesh().setNumFaces(outfaces,TRUE);
		triOb->GetMesh().setNumTVerts((ntvs=triOb->GetMesh().getNumTVerts())+toutv,TRUE);
		triOb->GetMesh().setNumTVFaces(outfaces,TRUE,veachf);
	  }
	  int latv=0,first=-1;
	  for (i=0;i<inverts;i++)
		if ((!submesh)||vertSel[i])
	  { if (first<0) first=i;
		for (int cnt=0;cnt<veachf;cnt++)
		{ if ((addmap==2)&&(i>0)) triOb->GetMesh().tvFace[fcnt]=triOb->GetMesh().tvFace[cnt];  
		  else if (addmap==1) triOb->GetMesh().tvFace[fcnt].setTVerts(latv,latv,latv); 
		  if (i>0) 
		  { triOb->GetMesh().faces[fcnt]=triOb->GetMesh().faces[cnt];
		    triOb->GetMesh().faces[fcnt].v[0]+=vertexnum;
		    triOb->GetMesh().faces[fcnt].v[1]+=vertexnum;
		    triOb->GetMesh().faces[fcnt].v[2]+=vertexnum;
		  }
		  fcnt++;
		}
		latv++;
	    if (i>first)
		for (int cnt=0;cnt<veachv;cnt++)
		    triOb->GetMesh().verts[vcnt++]=triOb->GetMesh().verts[cnt]+vlst[i];
	    face+=veachf;
		vertexnum+=veachv;
	  }
	  for (int cnt=0;cnt<veachv;cnt++)
		 triOb->GetMesh().verts[cnt]+=vlst[first];
	  if (addmap==1)
	  { int latv=0;
		for (i=0;i<inverts;i++)
		  if ((!submesh)||(vertSel[i])) triOb->GetMesh().tVerts[latv++]=tvlst[i];
		ntvs=latv;
	  }
	}
	if ((edges>0)&&(type!=1))
	{ float cyllen,sradius;
	  pblock->GetValue(PB_SRADIUS,t,sradius,FOREVER); 
	  pblock->GetValue(PB_SSMOOTH,0,smooth,FOREVER);
	  if (sradius<0.0f) sradius=0.0f;
	  int nf=face;
	  srand(12345);
	  Point3 rndv=Point3(RND11(),RND11(),RND11());	  
	  int startnt=ntvs;
	  for (i=0;i<edges;i++)
	  { Point3 vert,axis,center;
	    float ang;
		int startv=vertexnum;
		cyllen=Length(axis=(vlst[edgelst[i].vto]-vlst[edgelst[i].vfrom]));
		Point3 lincr=axis/(float)ssegs;
		float delta = TWOPI/(float)ssides;
		vert=(center=vlst[edgelst[i].vfrom])+sradius*Normalize(axis^rndv);
		ang=0.0f;
		axis=Normalize(axis);
	    for (int j=0;j<ssides;j++)
		{ for (int k=0;k<=ssegs;k++)
		    triOb->GetMesh().verts[vertexnum+k*ssides]=vert+(float)k*lincr;
		  RotateOnePoint(&vert.x,&center.x,&axis.x,-delta);
		  vertexnum++;
		}
		vertexnum+=ssegs*ssides;
		int sv,sv2,kcount,k,maxf=2*ssides,maxv=maxf-2,level=ssides-1,tvcnt=0,nlevel=ssides+1;
		BOOL odd=FALSE;
		if (addmap==1) startnt=ntvs;
		sv=startv;sv2=startv+ssides;
		float udiv,vdiv,u1=0.0f,v1=0.0f;
		if (addmap>0)
		{ float u=0.0f,v=0.0f,t1;
		  if (addmap==1)
		  { u=edgelst[i].uvfrom.x;v=edgelst[i].uvfrom.y;
			udiv=(edgelst[i].uvto.x-edgelst[i].uvfrom.x)/ssides;
		    vdiv=((t1=edgelst[i].uvto.y)-v)/ssegs;}
		  else if (addmap==2) {udiv=1.0f/(float)ssides;vdiv=1.0f/(float)ssegs;}
		  if ((addmap==1)||(i==0))
		  { for (k=0;k<=ssegs;k++)
		    { u=0.0f;
			  for (j=0;j<=ssides;j++)
			  { triOb->GetMesh().tVerts[ntvs++]=Point3(u,v,0.0f);
			    u+=udiv;
		      }
			  v+=vdiv;
		    }
		  }
		}
		int uincr=ssides+1,tvu1=0,tvv=0,sntvs=startnt,nt2=sntvs+nlevel;
		for (k=0;k<ssegs;k++)
		{ for (j=0;j<maxf;j++)
		{ triOb->GetMesh().faces[nf].setEdgeVisFlags(0,1,1);
		  if (strutID>=0) triOb->GetMesh().faces[nf].setMatID(strutID);
		  if (!smooth) triOb->GetMesh().faces[nf].setSmGroup(0);
		  else triOb->GetMesh().faces[nf].setSmGroup(1);
		  if (odd) 
		  { if (j<maxv) 
		     triOb->GetMesh().faces[nf].setVerts(sv,sv2+1,sv+1);
		    else triOb->GetMesh().faces[nf].setVerts(sv,sv2-level,sv-level);
		    if (addmap>0) triOb->GetMesh().tvFace[nf].setTVerts(sntvs,nt2+1,sntvs+1);
		    sv++;sv2++;sntvs++;nt2++; }
		  else
		  { if (j<maxv) triOb->GetMesh().faces[nf].setVerts(sv2+1,sv,sv2);
		    else triOb->GetMesh().faces[nf].setVerts(sv2-level,sv,sv2); 
		    if (addmap>0) triOb->GetMesh().tvFace[nf].setTVerts(nt2+1,sntvs,nt2);
		  }
		  odd=!odd;
		  nf++;
		}  sntvs++;nt2++;
		} 
		if (endcaps) 
		{ triOb->GetMesh().verts[vertexnum]=vlst[edgelst[i].vfrom];
		  sntvs=startnt;
		  sv=startv;kcount=nf;
		  for (k=0;k<ssides*2;k++)
		  {	triOb->GetMesh().faces[kcount].setEdgeVisFlags(0,1,0);
		    if (strutID>=0) triOb->GetMesh().faces[nf].setMatID(strutID);
			if (!smooth) triOb->GetMesh().faces[kcount].setSmGroup(0);
			else triOb->GetMesh().faces[kcount].setSmGroup(2);
			kcount++;
		  }
		  for (k=0;k<ssides-1;k++)
		  { triOb->GetMesh().faces[nf].setVerts(vertexnum,sv,sv+1);
		    if (addmap>0) triOb->GetMesh().tvFace[nf].setTVerts(startnt,sntvs,sntvs+1);
		    sv++;nf++;sntvs++;
		  }
		  if (addmap>0) {triOb->GetMesh().tvFace[nf].setTVerts(startnt,sntvs,sntvs+1);sntvs++;}
		  triOb->GetMesh().faces[nf++].setVerts(vertexnum,sv,startv);
		  startv=sv=vertexnum-ssides;
		  vertexnum++; int lasts=nt2-1;sntvs=lasts-ssides;
		  triOb->GetMesh().verts[vertexnum]=vlst[edgelst[i].vto];
		  for (k=0;k<ssides-1;k++)
		  { triOb->GetMesh().faces[nf].setVerts(vertexnum,sv+1,sv);
		    if (addmap>0) triOb->GetMesh().tvFace[nf].setTVerts(lasts,sntvs+1,sntvs);
		    sv++;nf++;sntvs++;
		  }
		  if (addmap>0) triOb->GetMesh().tvFace[nf].setTVerts(lasts,sntvs+1,sntvs);
		  triOb->GetMesh().faces[nf++].setVerts(vertexnum,startv,sv);
		  vertexnum++;
		}
	  }
	}
	if (submesh)
	{ int *newlst=new int[inverts];assert(newlst);
	  for (int i=0;i<inverts;i++)
		{ if (vmuststay[i]) 
		  { triOb->GetMesh().verts[vertexnum]=vlst[i];
			newlst[i]=vertexnum;
			vertexnum++;
		  }
		}
	  int nf=outfaces-basef;
	  for (i=0;i<basef;i++)
	  { triOb->GetMesh().faces[nf]=fstaylst[i];
	    triOb->GetMesh().faces[nf].v[0]=newlst[fstaylst[i].v[0]];
	    triOb->GetMesh().faces[nf].v[1]=newlst[fstaylst[i].v[1]];
	    triOb->GetMesh().faces[nf].v[2]=newlst[fstaylst[i].v[2]];
	    nf++;
	  }
	  if (newlst) delete[] newlst;
	  if (tvstaylst)
	  { int ntv=triOb->GetMesh().getNumTVerts()-oldtvs;
		for (i=0;i<oldtvs;i++)
		  triOb->GetMesh().tVerts[ntv++]=tvstaylst[i];  
		int *tvlst=new int[tverts];assert(tvlst);
		int count=0;
		for (i=0;i<tverts;i++)
		{  if (savedtvlst[i]) {tvlst[i]=count;count++;}
		}
		int nf=triOb->GetMesh().getNumFaces()-basef;
		for (i=0;i<basef;i++)
			triOb->GetMesh().tvFace[nf++].setTVerts(tvlst[tvfstaylst[i].t[0]],tvlst[tvfstaylst[i].t[1]],tvlst[tvfstaylst[i].t[2]]);
	    if (tvlst) delete[] tvlst;
	  }
	  else if (addmap) 
	  { int nv=triOb->GetMesh().getNumTVerts()-oldtvs;
		triOb->GetMesh().tVerts[nv]=Point3(0.0f,0.0f,0.0f);
		int nf=triOb->GetMesh().getNumFaces()-basef;
		for (i=0;i<basef;i++)
		  triOb->GetMesh().tvFace[nf++].setTVerts(nv,nv,nv);	 
	  }
	}
	}	
	if (tvstaylst) delete[] tvstaylst;
	if (tvfstaylst) delete[] tvfstaylst;
	if (tvlst) delete[] tvlst;
	if (edgelst) delete[] edgelst;
	if (vlst) delete[] vlst;
	if (fstaylst) delete[] fstaylst;
	triOb->GetMesh().faceSel.ClearAll();
	triOb->GetMesh().vertSel.ClearAll();
	triOb->GetMesh().edgeSel.ClearAll();
	triOb->SetChannelValidity(TOPO_CHAN_NUM, valid);
	triOb->SetChannelValidity(GEOM_CHAN_NUM, valid);
	triOb->SetChannelValidity(TEXMAP_CHAN_NUM, valid);
	triOb->SetChannelValidity(MTL_CHAN_NUM, valid);
	triOb->SetChannelValidity(SELECT_CHAN_NUM, valid);
	triOb->SetChannelValidity(SUBSEL_TYPE_CHAN_NUM, valid);
	triOb->SetChannelValidity(DISP_ATTRIB_CHAN_NUM, valid);
	triOb->FreeChannels(VERTCOLOR_CHANNEL);
	os->obj = triOb;
	os->obj->UnlockObject();
	}

void SpinnerOff(HWND hWnd,int SpinNum)
{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
  spin2->Disable();
  ReleaseISpinner(spin2);
}
void SpinnerOn(HWND hWnd,int SpinNum)
{ ISpinnerControl *spin2 = GetISpinner(GetDlgItem(hWnd,SpinNum));
  spin2->Enable();
  ReleaseISpinner(spin2);
}

void StrutsOn(LatticeMod *po,HWND hWnd,BOOL joff)
{ EnableWindow(GetDlgItem(hWnd,IDC_AP_EDGESVIS),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_EDGESALL),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_ENDCAPS),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_STRUTSMOOTH),TRUE);
  SpinnerOn(hWnd,IDC_AP_STRUTRADIUSSPIN);
  SpinnerOn(hWnd,IDC_AP_STRUTSEGMENTSSPIN);
  SpinnerOn(hWnd,IDC_AP_STRUTSIDESSPIN);
  SpinnerOn(hWnd,IDC_AP_STRUTMATIDSPIN);
  if (joff)
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_TYPETET),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_AP_TYPEOCT),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_AP_TYPEICOSA),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_AP_JUNCTSMOOTH),FALSE);
    SpinnerOff(hWnd,IDC_AP_JUNCTRADIUSSPIN);
    SpinnerOff(hWnd,IDC_AP_JUNCTSEGMENTSSPIN);
	SpinnerOff(hWnd,IDC_AP_JUNCTMATIDSPIN);
  }
}
void JunctionOn(LatticeMod *po,HWND hWnd,BOOL soff)
{ if (soff)
  { EnableWindow(GetDlgItem(hWnd,IDC_AP_EDGESVIS),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_AP_EDGESALL),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_AP_ENDCAPS),FALSE);
    EnableWindow(GetDlgItem(hWnd,IDC_AP_STRUTSMOOTH),FALSE);
    SpinnerOff(hWnd,IDC_AP_STRUTRADIUSSPIN);
    SpinnerOff(hWnd,IDC_AP_STRUTSEGMENTSSPIN);
    SpinnerOff(hWnd,IDC_AP_STRUTSIDESSPIN);
    SpinnerOff(hWnd,IDC_AP_STRUTMATIDSPIN);
  }
  EnableWindow(GetDlgItem(hWnd,IDC_AP_TYPETET),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_TYPEOCT),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_TYPEICOSA),TRUE);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_JUNCTSMOOTH),TRUE);
  SpinnerOn(hWnd,IDC_AP_JUNCTRADIUSSPIN);
  SpinnerOn(hWnd,IDC_AP_JUNCTSEGMENTSSPIN);
  SpinnerOn(hWnd,IDC_AP_JUNCTMATIDSPIN);
}

class LatticeDlg : public ParamMapUserDlgProc {
	public:
		LatticeMod *po;

		LatticeDlg(LatticeMod *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void LatticeDlg::Update(TimeValue t)
{	if (po->lattMod)
{	HWND hWnd=po->pmapParam->GetHWnd();
	int geom;
	po->pblock->GetValue(PB_GEOMETRY,t,geom,FOREVER);
	if (geom==0) StrutsOn(po,hWnd,1);
	else if (geom==1) JunctionOn(po,hWnd,1);
	else
	{ StrutsOn(po,hWnd,0);
	  JunctionOn(po,hWnd,0);
	}
}
}

BOOL LatticeDlg::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{ case IDC_AP_STRUTSON:
				StrutsOn(po,hWnd,1);
				break;
			  case IDC_AP_JUNCTSON:
				JunctionOn(po,hWnd,1);
				break;
			  case IDC_AP_BOTHON:
				StrutsOn(po,hWnd,0);
				JunctionOn(po,hWnd,0);
				break;
			}
			break;	
		default:
			return FALSE;
		}
	return TRUE;
}
void LatticeMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{	this->ip = ip;
	lattMod = this;

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_AP_LATTICE),
		GetString(IDS_AP_PARAMETERS),
		0);	
	  if (pmapParam) pmapParam->SetUserDlgProc(new LatticeDlg(this));
}

void LatticeMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next)
{	this->ip = NULL;
	lattMod=NULL;
	
	TimeValue t = ip->GetTime();

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	ClearAFlag(A_MOD_BEING_EDITED);

	DestroyCPParamMap(pmapParam);

	// Save these values in class variables so the next object created will inherit them.
/*	pblock->GetValue(PB_AMOUNT,ip->GetTime(),dlgAmount,FOREVER);
	pblock->GetValue(PB_SEGS,ip->GetTime(),dlgSegs,FOREVER);
	pblock->GetValue(PB_CAPSTART,ip->GetTime(),dlgCapStart,FOREVER);
	pblock->GetValue(PB_CAPEND,ip->GetTime(),dlgCapEnd,FOREVER);
	pblock->GetValue(PB_CAPTYPE,ip->GetTime(),dlgCapType,FOREVER);
	pblock->GetValue(PB_OUTPUT,ip->GetTime(),dlgOutput,FOREVER);
	pblock->GetValue(PB_MAPPING,ip->GetTime(),dlgMapping,FOREVER);	*/
	}

Interval LatticeMod::GetValidity(TimeValue t)
	{
	float f;
	int i;
	Interval valid = FOREVER;
	pblock->GetValue(PB_SRADIUS,t,f,valid);
	pblock->GetValue(PB_SSEGS,t,i,valid);	
	pblock->GetValue(PB_SSIDES,t,i,valid);
	pblock->GetValue(PB_JRADIUS,t,f,valid);
	pblock->GetValue(PB_JSEGS,t,i,valid);	
	return valid;
	}

RefResult LatticeMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message ) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			if ((lattMod==this) && pmapParam) pmapParam->Invalidate();
			break;
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			gpd->dim = GetParameterDim(gpd->index);			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			gpn->name = GetParameterName(gpn->index);			
			return REF_STOP; 
			}
		}
	return(REF_SUCCEED);
	}

ParamDimension *LatticeMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_SRADIUS: 	
		case PB_JRADIUS: 	return stdWorldDim;
		case PB_GEOMETRY: 
		case PB_SSEGS:		
		case PB_SSIDES:	
		case PB_EDGES:		
		case PB_ENDCAPS:
		case PB_SSMOOTH:
		case PB_JSEGS:
		case PB_GEOBASE:
		case PB_JSMOOTH:
		case PB_MAPPING:
							return defaultDim;
		default:			return defaultDim;
		}
	}

TSTR LatticeMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_SRADIUS:	return TSTR(GetString(IDS_AP_SRADIUS));
		case PB_SSEGS:		return TSTR(GetString(IDS_AP_SSEGS));
		case PB_SSIDES:		return TSTR(GetString(IDS_AP_SIDES));
		case PB_JRADIUS:	return TSTR(GetString(IDS_AP_JRADIUS));
		case PB_JSEGS:		return TSTR(GetString(IDS_AP_JSEGS));
		default:			return TSTR(_T(""));
		}
	}
class LatPostLoadCallback : public PostLoadCallback {
	public:
		ParamBlockPLCB *cb;
		LatPostLoadCallback(ParamBlockPLCB *c) {cb=c;}
		void proc(ILoad *iload) {
			DWORD oldVer = ((LatticeMod*)(cb->targ))->pblock->GetVersion();
			ReferenceTarget *targ = cb->targ;
			cb->proc(iload);
			if (oldVer<1) 
			{	((LatticeMod*)targ)->pblock->SetValue(PB_ENTIREOBJECT,0,1);
				int whatsit;
				((LatticeMod*)targ)->pblock->GetValue(PB_EDGES,0,whatsit,FOREVER);
				((LatticeMod*)targ)->pblock->SetValue(PB_EDGES,0,(1-whatsit));
			}
			delete this;
		}
	};

IOResult LatticeMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new LatPostLoadCallback(
			new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0)));
	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\lattice\mods2.h ===
#ifndef __MODS2__H
#define __MODS2__H

#include "Max.h"
#include "lattice.h"
#include "iparamm.h"

#define FLOAT_EPSILON 1.0e-06

TCHAR *GetString(int id);

extern ClassDesc* GetLatticeModDesc(); 
extern ClassDesc* GetSplineSelModDesc();
extern ClassDesc* GetRandMatlModDesc();
extern ClassDesc* GetSpindleModDesc();

extern int FloatEQ0(float number);

extern HINSTANCE hInstance;
extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\lattice\selname.h ===
#ifndef __SELNAME_H__ 

#define __SELNAME_H__

#include "Max.h"

class NVertSelSetList {
	public:
		Tab<ShapeVSel*> sets;

		~NVertSelSetList();
		ShapeVSel &operator[](int i) {return *sets[i];}
		int Count() {return sets.Count();}
		void AppendSet(ShapeVSel &nset);
		void DeleteSet(int i);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void SetSize(BezierShape& shape);
		NVertSelSetList& operator=(NVertSelSetList& from);
		void DeleteSetElements(ShapeVSel &set,int m=1);
	};

class NSegSelSetList {
	public:
		Tab<ShapeSSel*> sets;

		~NSegSelSetList();
		ShapeSSel &operator[](int i) {return *sets[i];}
		int Count() {return sets.Count();}
		void AppendSet(ShapeSSel &nset);
		void DeleteSet(int i);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void SetSize(BezierShape& shape);
		NSegSelSetList& operator=(NSegSelSetList& from);
		void DeleteSetElements(ShapeSSel &set,int m=1);
	};

class NPolySelSetList {
	public:
		Tab<ShapePSel*> sets;

		~NPolySelSetList();
		ShapePSel &operator[](int i) {return *sets[i];}
		int Count() {return sets.Count();}
		void AppendSet(ShapePSel &nset);
		void DeleteSet(int i);
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		void SetSize(BezierShape& shape);
		NPolySelSetList& operator=(NPolySelSetList& from);
		void DeleteSetElements(ShapePSel &set,int m=1);
	};
#endif // __SELNAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\lattice\randmatl.cpp ===
/**********************************************************************
 *<
	FILE: randmatl.cpp

	DESCRIPTION:  Assigns Material ID randomly by element

	CREATED BY: Eric Peterson

	HISTORY: 3/98

 *>	Copyright (c) 1998 for Kinetix, All Rights Reserved.
 **********************************************************************/
#include "mods2.h"
#include "iparamm.h"
 #include "meshadj.h"

const float IntMax=32767.0f;

float RND01()
{	float num;
	num=(float)rand();
	return(num/IntMax);
}

static Class_ID RANDMATLOSM_CLASS_ID(0x597d58ee,0xdec17af);


class RandMatByElemMod : public Modifier {	
	public:
		IParamBlock *pblock;
		static IParamMap *pmapParam;

		RandMatByElemMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_EP_RANDMATLMOD); }  
		virtual Class_ID ClassID() { return RANDMATLOSM_CLASS_ID;}
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() { return GetString(IDS_EP_RANDMATLMOD); }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		ChannelMask ChannelsUsed()  {return OBJ_CHANNELS;}
		ChannelMask ChannelsChanged() {return GEOM_CHANNEL|TOPO_CHANNEL;}
		Class_ID InputType() {return triObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);
		IParamArray *GetParamBlock() {return pblock;}
		int GetParamBlockIndex(int id) {return id;}

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock = (IParamBlock*)rtarg;}

		int NumSubs() {return 1;}
		Animatable* SubAnim(int i) {return pblock;}
		TSTR SubAnimName(int i) {return GetString(IDS_AP_PARAMETERS);}

		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
	};



//--- ClassDescriptor and class vars ---------------------------------

IParamMap *RandMatByElemMod::pmapParam = NULL;



class RandMatlClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new RandMatByElemMod; }
	const TCHAR *	ClassName() { return GetString(IDS_EP_RANDMATLMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return RANDMATLOSM_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_EP_DEFSURFACE);}
	};

static RandMatlClassDesc matDesc;
extern ClassDesc* GetRandMatlModDesc() { return &matDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_MATLMETHOD	0
#define PB_IDCOUNT		1
#define PB_IDONE		2
#define PB_IDTWO		3
#define PB_IDTHREE		4
#define PB_IDFOUR		5
#define PB_IDFIVE		6
#define PB_IDSIX		7
#define PB_IDSEVEN		8
#define PB_IDEIGHT		9
#define	PB_SEED			10

static int methodIDs[] = {IDC_METHRND,IDC_METHLIST};

//
//
// Parameters

static ParamUIDesc descParam[] = {
	

	// Methods
	ParamUIDesc(PB_MATLMETHOD,TYPE_RADIO,methodIDs,2),

	// ID Count
	ParamUIDesc(
		PB_IDCOUNT,
		EDITTYPE_INT,
		IDC_IDCOUNT,IDC_IDCOUNTSPIN,
		1.0f,(float)0xffff,
		1.0f),	

	// Material ID 
	ParamUIDesc(
		PB_IDONE,
		EDITTYPE_FLOAT,
		IDC_MATLID1,IDC_MATLID1SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Material ID
	ParamUIDesc(
		PB_IDTWO,
		EDITTYPE_FLOAT,
		IDC_MATLID2,IDC_MATLID2SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Material ID
	ParamUIDesc(
		PB_IDTHREE,
		EDITTYPE_FLOAT,
		IDC_MATLID3,IDC_MATLID3SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Material ID
	ParamUIDesc(
		PB_IDFOUR,
		EDITTYPE_FLOAT,
		IDC_MATLID4,IDC_MATLID4SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Material ID
	ParamUIDesc(
		PB_IDFIVE,
		EDITTYPE_FLOAT,
		IDC_MATLID5,IDC_MATLID5SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Material ID
	ParamUIDesc(
		PB_IDSIX,
		EDITTYPE_FLOAT,
		IDC_MATLID6,IDC_MATLID6SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Material ID
	ParamUIDesc(
		PB_IDSEVEN,
		EDITTYPE_FLOAT,
		IDC_MATLID7,IDC_MATLID7SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Material ID
	ParamUIDesc(
		PB_IDEIGHT,
		EDITTYPE_FLOAT,
		IDC_MATLID8,IDC_MATLID8SPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),

	// Random Seed
	ParamUIDesc(
		PB_SEED,
		EDITTYPE_INT,
		IDC_SEED,IDC_SEEDSPIN,
		0.0f,32000.0f,
		1.0f),
};

#define PARAMDESC_LENGH 11

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_FLOAT, NULL, TRUE, 9 },
	{ TYPE_INT, NULL, FALSE, 10 }
};

#define PBLOCK_LENGTH	11

#define CURRENT_VERSION	0

//--- RandMatByElemMod methods -------------------------------

RandMatByElemMod::RandMatByElemMod()
{	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));	
	pblock->SetValue(PB_MATLMETHOD,0,1);
	pblock->SetValue(PB_IDCOUNT,0,2);
	pblock->SetValue(PB_IDONE,0,0.5f);
	pblock->SetValue(PB_IDTWO,0,0.5f);
	pblock->SetValue(PB_IDTHREE,0,0.0f);
	pblock->SetValue(PB_IDFOUR,0,0.0f);
	pblock->SetValue(PB_IDFIVE,0,0.0f);
	pblock->SetValue(PB_IDSIX,0,0.0f);
	pblock->SetValue(PB_IDSEVEN,0,0.0f);
	pblock->SetValue(PB_IDEIGHT,0,0.0f);
	pblock->SetValue(PB_SEED,0,12345);
}

void RandMatByElemMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
{	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_RNDMATLPARAMS),
		GetString(IDS_AP_PARAMETERS),
		0);		
}
		
void RandMatByElemMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{	DestroyCPParamMap(pmapParam);
	pmapParam = NULL;
}

Interval RandMatByElemMod::LocalValidity(TimeValue t)
{	int i;
	float f;
	Interval valid = FOREVER;
	pblock->GetValue(PB_IDCOUNT,t,i,valid);	
	pblock->GetValue(PB_IDONE,t,f,valid);	
	pblock->GetValue(PB_IDTWO,t,f,valid);	
	pblock->GetValue(PB_IDTHREE,t,f,valid);	
	pblock->GetValue(PB_IDFOUR,t,f,valid);	
	pblock->GetValue(PB_IDFIVE,t,f,valid);	
	pblock->GetValue(PB_IDSIX,t,f,valid);	
	pblock->GetValue(PB_IDSEVEN,t,f,valid);	
	pblock->GetValue(PB_IDEIGHT,t,f,valid);	
	return valid;
}

RefTargetHandle RandMatByElemMod::Clone(RemapDir& remap) 
{	RandMatByElemMod* newmod = new RandMatByElemMod();	
	newmod->ReplaceReference(0,pblock->Clone(remap));	
	return newmod;
}

void RandMatByElemMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{	Interval valid = FOREVER;
	int method,nIDs,rndseed;
	float pctIDs[8];
	pblock->GetValue(PB_MATLMETHOD,t,method   ,valid);
	pblock->GetValue(PB_IDCOUNT   ,t,nIDs     ,valid);
	pblock->GetValue(PB_IDONE     ,t,pctIDs[0],valid);
	pblock->GetValue(PB_IDTWO     ,t,pctIDs[1],valid);
	pblock->GetValue(PB_IDTHREE   ,t,pctIDs[2],valid);
	pblock->GetValue(PB_IDFOUR    ,t,pctIDs[3],valid);
	pblock->GetValue(PB_IDFIVE    ,t,pctIDs[4],valid);
	pblock->GetValue(PB_IDSIX     ,t,pctIDs[5],valid);
	pblock->GetValue(PB_IDSEVEN   ,t,pctIDs[6],valid);
	pblock->GetValue(PB_IDEIGHT   ,t,pctIDs[7],valid);
	float firstseven=pctIDs[0]+pctIDs[1]+pctIDs[2]+pctIDs[3]+pctIDs[4]+pctIDs[5]+pctIDs[6];
	if ((pctIDs[7]+firstseven)<1.0f)pctIDs[7]=1.0f-firstseven;
	pblock->GetValue(PB_SEED      ,t,rndseed  ,valid);
	srand(rndseed);

	assert(os->obj->IsSubClassOf(triObjectClassID));

	TriObject *triOb = (TriObject *)os->obj;
	BOOL useSel=triOb->GetMesh().selLevel==MESH_FACE;

	int facecount=triOb->GetMesh().getNumFaces();

	AdjEdgeList aelist(triOb->GetMesh());
	AdjFaceList aflist(triOb->GetMesh(),aelist);
	FaceElementList elemlist(triOb->GetMesh(),aflist);

	int elemcount=elemlist.count;

	int *elemmatlref;
	elemmatlref=new int[elemcount];

	int iloop,jloop,rndindex;
	float rndvar,currentpct;
	BOOL isfound;
	if (method==0) //fill in the element material reference array using random materials
	{	for (iloop=0;iloop<elemcount;iloop++) 
		{	rndindex=int((float)nIDs*RND01());
			if (rndindex==nIDs)rndindex--;
			if (rndindex<0)rndindex=0;
			elemmatlref[iloop]=rndindex;
		}
	}
	else
	{	for (iloop=0;iloop<elemcount;iloop++)
		{	rndvar=RND01();
			isfound=FALSE;
			jloop=0;
			currentpct=0.0f;
			while ((!isfound)&&(jloop<8))
			{	currentpct+=pctIDs[jloop];
				if (rndvar<=currentpct)
				{	elemmatlref[iloop]=jloop;
					isfound=TRUE;
				}
				jloop++;
			}
		}
	}
	
	for (int i=0; i<facecount; i++)
	{	if ((!useSel)||(triOb->GetMesh().faceSel[i]))
		{	triOb->GetMesh().setFaceMtlIndex(i,(MtlID)elemmatlref[elemlist[i]]);
		}
	}
		
	triOb->UpdateValidity(TOPO_CHAN_NUM,valid);		

	delete[] elemmatlref;
}

RefResult RandMatByElemMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message) 
{	switch (message) {
		case REFMSG_CHANGE:
			if (pmapParam && pmapParam->GetParamBlock()==pblock) {
				pmapParam->Invalidate();
				}
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {				
				case 0:
				default: gpd->dim = defaultDim; break;
				}			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {				
				case PB_MATLMETHOD:	gpn->name=GetString(IDS_AP_METHOD); break;
				case PB_IDCOUNT:	gpn->name=GetString(IDS_AP_COUNT); break;
				case PB_IDONE:		gpn->name=GetString(IDS_AP_MAT1); break;
				case PB_IDTWO:		gpn->name=GetString(IDS_AP_MAT2); break;
				case PB_IDTHREE:	gpn->name=GetString(IDS_AP_MAT3); break;
				case PB_IDFOUR:		gpn->name=GetString(IDS_AP_MAT4); break;
				case PB_IDFIVE:		gpn->name=GetString(IDS_AP_MAT5); break;
				case PB_IDSIX:		gpn->name=GetString(IDS_AP_MAT6); break;
				case PB_IDSEVEN:	gpn->name=GetString(IDS_AP_MAT7); break;
				case PB_IDEIGHT:	gpn->name=GetString(IDS_AP_MAT8); break;
				case PB_SEED:		gpn->name=GetString(IDS_AP_SEED); break;
				default:			gpn->name = TSTR(_T("")); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\lattice\mods2.cpp ===
/**********************************************************************
 *<
	FILE: mods2.cpp

	DESCRIPTION:  Converts a mesh to a lattice Utility Files
	              Also Contains SplineSelect
				  This version contains RandMatl Modifier

	CREATED BY: Audrey Peterson
				RandMatl by Eric Peterson

	HISTORY: created 6 January, 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "mods2.h"

HINSTANCE hInstance;
static int controlsInit = FALSE;


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString (IDS_LIB_DESCRIPTION); }

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int 
LibNumberClasses() { return 4; }

// This function return the ith class descriptor.
__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case 0:return GetLatticeModDesc();
	case 1:return GetSplineSelModDesc();
	case 2:return GetRandMatlModDesc();
	case 3:return GetSpindleModDesc();
    default:return 0;}
 }

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

  	if (!controlsInit) {
		controlsInit = TRUE;		

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	}
	
	return(TRUE);
	}


// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}

int FloatEQ0(float number)
{return((FLOAT_EPSILON>=number)&&(number>=-FLOAT_EPSILON));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\about.cpp ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 19, 1998
 About.cpp - 3D AboutBox Implementation
 ***************************************************************************/
#include "pch.h"
#include "app.h"
#include "resource.h"
#include "..\..\include\buildver.h"

#define COOL_ABOUTBOX
#ifdef COOL_ABOUTBOX

#include <gl/gl.h>
#include <gl/glaux.h>

#include <stdlib.h>
#include <math.h>
#include "gtypes.h"
#include "vtrackbl.h"

#include "geometry.h"

BOOL CALLBACK AboutDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
LRESULT CALLBACK oglWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

void InitOpenGL(HWND hWnd);
void DrawGrid();
void SetView();
void SetupLights();
void RenderColor(Point3 color);
void Render();
void RenderGeometry();

#define WM_INITOPENGL	(WM_USER+42)
#define WM_CHECKSPIN	(WM_USER+43)

static HWND			hGLWnd;
static HDC			hdc;
static HGLRC		hRC;
static HINSTANCE	hInstance;
static VirtualTrackball Trackball;
static float distance;
static float aspect;
static float col[3];
float  rcount;

void App::DoAboutBox()
	{
	hInstance = GetInstance();

	DialogBoxParam(
		GetInstance(),
#ifndef DESIGN_VER
        MAKEINTRESOURCE(IDD_ABOUTBOX),
#else
        MAKEINTRESOURCE(IDD_VIZ_ABOUTBOX),
#endif
        GetHWnd(),
        (DLGPROC)AboutDlgProc,
        (LPARAM)this);
	}

BOOL CALLBACK AboutDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
	{
	switch (message) {
		case WM_INITDIALOG:
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			CenterWindow(hWnd, GetParent(hWnd));
			PostMessage(hWnd, WM_INITOPENGL, 0, 0);
			return 1;
		case WM_INITOPENGL:
			InitOpenGL(GetDlgItem(hWnd, IDC_IMAGE));
			break;

		case WM_DESTROY:
			wglDeleteContext(hRC);
			ReleaseDC(hGLWnd, hdc);
			break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
				}
			return 1;
		}
	return 0;
	}

void InitOpenGL(HWND hWnd)
	{
	WNDCLASSEX	wc;

	wc.cbSize		 = sizeof(WNDCLASSEX);
	wc.style         = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
	wc.lpfnWndProc   = oglWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInstance;
	wc.hIconSm		 = NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MAINWND));
	wc.hIcon         = NULL; //LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MAINWND));
	wc.hCursor       = LoadCursor(NULL, IDC_SIZEALL);
	wc.hbrBackground = NULL; //(HBRUSH)(COLOR_DESKTOP+1);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = "CJOGLFRAME";

	RegisterClassEx(&wc);

	RECT rect;
	GetClientRect(hWnd, &rect);
	int width = rect.right - rect.left;
	int height = rect.bottom - rect.top;
	hGLWnd = CreateWindow("CJOGLFRAME",
						"",
						WS_CHILDWINDOW | WS_VISIBLE,
						rect.left, rect.top, rect.right, rect.bottom,
						hWnd, NULL, hInstance, NULL);

	hdc = GetDC(hGLWnd);

	PIXELFORMATDESCRIPTOR pfd = { 
		sizeof(PIXELFORMATDESCRIPTOR),    // size of this pfd 
		1,                                // version number 
		PFD_DRAW_TO_WINDOW |              // support window 
		PFD_SUPPORT_OPENGL |              // support OpenGL 
		PFD_DOUBLEBUFFER,                 // double buffered 
		PFD_TYPE_RGBA,                    // RGBA type 
		24,                               // 24-bit color depth 
		0, 0, 0, 0, 0, 0,                 // color bits ignored 
		0,                                // no alpha buffer 
		0,                                // shift bit ignored 
		0,                                // no accumulation buffer 
		0, 0, 0, 0,                       // accum bits ignored 
		32,                               // 32-bit z-buffer     
		0,                                // no stencil buffer 
		0,                                // no auxiliary buffer 
		PFD_MAIN_PLANE,                   // main layer 
		0,                                // reserved 
		0, 0, 0                           // layer masks ignored 
	}; 
	int  iPixelFormat; 

	// get the device context's best, available pixel format match 
	if ((iPixelFormat = ChoosePixelFormat(hdc, &pfd)) == 0) {
		return;
	}

	// make that match the device context's current pixel format 
	if (SetPixelFormat(hdc, iPixelFormat, &pfd) == FALSE) {
        return;
	}

	glDepthFunc(GL_LESS);
    glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	hRC = wglCreateContext(hdc);
	wglMakeCurrent(hdc, hRC);

	Trackball.Init(hWnd, width, height);
	distance = 2.0f;
	aspect = (float)width/(float)height;

	rcount = 0.0f;
	col[0] = (float)sin(rcount+0.00f)/2.0f+0.5f;
	col[1] = (float)sin(rcount+2.09f)/2.0f+0.5f;
	col[2] = (float)sin(rcount+4.18f)/2.0f+0.5f;
	}

void Render()
	{
	glClearColor(0.7f, 0.7f, 0.7f, 0.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glEnable(GL_DEPTH_TEST);

	SetView();
	DrawGrid();

	glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);

	glShadeModel(GL_SMOOTH);
	glCullFace(GL_BACK);

	glEnable(GL_CULL_FACE);
	glEnable(GL_CCW);
	glEnable(GL_LIGHTING);

	RenderGeometry();

    glDisable(GL_LIGHTING);

	SwapBuffers(hdc);
	}

void RenderGeometry()
	{
	RenderColor(Point3(col[0], col[1], col[2]));

	rcount+=0.01f;
	col[0] = (float)sin(rcount+0.00f)/2.0f+0.5f;
	col[1] = (float)sin(rcount+2.09f)/2.0f+0.5f;
	col[2] = (float)sin(rcount+4.18f)/2.0f+0.5f;

	int numfloats = sizeof(objectDef)/sizeof(float);

	//auxSolidIcosahedron(0.5);
	glBegin(GL_TRIANGLES);

	for (int i=0; i<numfloats; i+=6) {
		glNormal3f(objectDef[i], objectDef[i+1], objectDef[i+2]);
		glVertex3f(objectDef[i+3], objectDef[i+4], objectDef[i+5]);
		}

	glEnd();

	}

void SetView()
	{
    float matRot[4][4];

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(45.0f, aspect, 0.1f, 2.0 * distance);
    glTranslated( 0, 0, -distance);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
    SetupLights();
    Trackball.CalcRotMatrix(matRot);
    glMultMatrixf( &(matRot[0][0]) );
	}

void SetupLights()
	{
	static float ambient[]		= {   0.1f,    0.1f,    0.1f, 1.0f};
    static float diffuse[]		= {   0.8f,    0.8f,    0.8f, 1.0f};
    static float specular[]		= {   1.0f,    1.0f,    1.0f, 1.0f};
    static float position[]		= { 100.0f,    0.0f, -100.0f, 0.0f};
    static float position2[]	= {-100.0f,    0.0f,  100.0f, 0.0f};

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, specular);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glEnable(GL_LIGHT0);

    glLightfv(GL_LIGHT1, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT1, GL_SPECULAR, specular);
    glLightfv(GL_LIGHT1, GL_POSITION, position2);
    glEnable(GL_LIGHT1);
	}

void RenderColor(Point3 color)
{
	static float ambient[4] = { 0.1f, 0.1f, 0.1f, 1.0f };
	static float specular[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
	static float diffuse[4];

    diffuse[0] = color.x;
	diffuse[1] = color.y;
	diffuse[2] = color.z;
	diffuse[3] = 1.0f;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,	 ambient);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,	 diffuse);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, specular);
	glMateriali(GL_FRONT_AND_BACK, GL_SHININESS, 128);
}

void DrawGrid()
	{
    float gx, gy;
    float dx, dy;
    float axisLen;

    Point3 gridStart    = Point3(-1, -1, 0);
    Point3 gridEnd      = Point3( 1,  1, 0);

    float maxVal = (float)__max(fabs(gridStart.x), __max(fabs(gridStart.y),
                    __max(fabs(gridEnd.x), fabs(gridEnd.y))));

    gridStart.x = -maxVal;
    gridStart.y = -maxVal;
    gridEnd.x   = maxVal;
    gridEnd.y   = maxVal;

    gridStart.z = 0.0f;
    gridEnd.z   = 0.0f;

    dx = (gridEnd.x - gridStart.x) / 20.0f;
    dy = (gridEnd.y - gridStart.y) / 20.0f;

    axisLen = (gridEnd.y - gridStart.y) / 4.0f;

/*
	glBegin(GL_LINES);
		glColor3f(1.0f, 0.0f, 0.0f);
		glVertex3f(0.0f, 0.0f, 0.0f);
		glVertex3f(axisLen, 0.0f, 0.0f);

		glColor3f(0.0f, 1.0f, 0.0f);
		glVertex3f(0.0f, 0.0f, 0.0f);
		glVertex3f(0.0f, axisLen, 0.0f);

		glColor3f(0.0f, 0.0f, 1.0f);
		glVertex3f(0.0f, 0.0f, 0.0f);
		glVertex3f(0.0f, 0.0f, axisLen);
	glEnd();
*/

	// Grid lines
	glColor3f(0.5f, 0.5f, 0.5f);

	glBegin(GL_LINES);
		for (gy = gridStart.y; gy<(gridEnd.y+dy); gy+=dy) {
			glVertex2f(gridStart.x, gy);
			glVertex2f(gridEnd.x, gy);
			}
		for (gx = gridStart.x; gx<(gridEnd.x+dx); gx+=dx) {
			glVertex2f(gx, gridStart.y);
			glVertex2f(gx, gridEnd.y);
			}

		glColor3f(0.3f, 0.3f, 0.3f);
		glVertex2f(gridStart.x, 0.0f);
		glVertex2f(gridEnd.x, 0.0f);

		glVertex2f(0.0f, gridStart.y);
		glVertex2f(0.0f, gridEnd.y);

	glEnd();
	}


LRESULT CALLBACK oglWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
	PAINTSTRUCT	ps;
	static		int rbY = 0;

    switch (message) {
		case WM_LBUTTONDOWN:
			SetCapture(hWnd);
			if (Trackball.OnLMouseDown((short)LOWORD(lParam), (short)HIWORD(lParam)))
				InvalidateRect(hWnd, NULL, TRUE);
			break;
		case WM_MBUTTONDOWN:
			SetCapture(hWnd);
			if (Trackball.OnMMouseDown((short)LOWORD(lParam), (short)HIWORD(lParam)))
				InvalidateRect(hWnd, NULL, TRUE);
			break;
		case WM_RBUTTONDOWN:
			SetCapture(hWnd);
			if (Trackball.OnRMouseDown((short)LOWORD(lParam), (short)HIWORD(lParam))) {
				InvalidateRect(hWnd, NULL, TRUE);
			}
			else {
				rbY = (short)HIWORD(lParam);
			}
			break;
		case WM_LBUTTONUP:
			ReleaseCapture();
			if (Trackball.OnLMouseUp((short)LOWORD(lParam), (short)HIWORD(lParam)))
				InvalidateRect(hWnd, NULL, TRUE);
			PostMessage(hWnd, WM_CHECKSPIN, 0, 0);

			break;
		case WM_MBUTTONUP:
			ReleaseCapture();
			if (Trackball.OnMMouseUp((short)LOWORD(lParam), (short)HIWORD(lParam)))
				InvalidateRect(hWnd, NULL, TRUE);
			PostMessage(hWnd, WM_CHECKSPIN, 0, 0);

			break;
		case WM_RBUTTONUP:
			ReleaseCapture();
			if (Trackball.OnRMouseUp((short)LOWORD(lParam), (short)HIWORD(lParam)))
				InvalidateRect(hWnd, NULL, TRUE);
			PostMessage(hWnd, WM_CHECKSPIN, 0, 0);

			break;

		case WM_MOUSEMOVE:
			if (Trackball.OnMouseMove(wParam, (short)LOWORD(lParam), (short)HIWORD(lParam))) {
				InvalidateRect(hWnd, NULL, TRUE);
			}
			else if (wParam & MK_RBUTTON) {
				// Right button down
				distance += ((short)HIWORD(lParam) - rbY)/40.0f;
				rbY = (short)HIWORD(lParam);
				InvalidateRect(hWnd, NULL, TRUE);
			}

			break;

		case WM_TIMER:
			if (Trackball.HasMotion()) {
				InvalidateRect(hWnd, NULL, TRUE);
				}
			break;

		case WM_PAINT:
			BeginPaint(hWnd, &ps);
			Render();
			EndPaint(hWnd, &ps);

			if (Trackball.HasMotion()) {
				SetTimer(hWnd, 1, 10, NULL);
				//PostMessage(hWnd, WM_CHECKSPIN, 0, 0);
				}

			break;

		default:
			break;
		}

    return (DefWindowProc(hWnd, message, wParam, lParam));

	}

#else

BOOL CALLBACK AboutDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);

void App::DoAboutBox(void)
	{
	DialogBoxParam(
		GetInstance(),
        MAKEINTRESOURCE(IDD_ABOUTBOX_TINY),
        GetHWnd(),
        (DLGPROC)AboutDlgProc,
        (LPARAM)this);
	}

BOOL CALLBACK AboutDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
	{
	switch (message) {
		case WM_INITDIALOG:
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			CenterWindow(hWnd, GetParent(hWnd));
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
				}
			return 1;
		}
	return 0;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\lattice\splsel.cpp ===
/**********************************************************************
 *<
	FILE: splsel.cpp

	DESCRIPTION:  A selection modifier for splines

	CREATED BY: Audrey Peterson	

	HISTORY: 1/14/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "mods2.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "nsclip.h"
#include "selname.h"

#define WM_UPDATE_CACHE		(WM_USER+0x287)

// This is a special override value which allows us to hit-test on
// any sub-part of a shape


NVertSelSetList::~NVertSelSetList()
	{
	for (int i=0; i<sets.Count(); i++) {
		delete sets[i];
		}
	}

void NVertSelSetList::AppendSet(ShapeVSel &nset)
	{
	ShapeVSel *n = new ShapeVSel();
	*n = nset;
	sets.Append(1,&n);
	}

void NVertSelSetList::DeleteSet(int i)
	{
	delete sets[i];
	sets.Delete(i,1);
	}

void NVertSelSetList::SetSize(BezierShape& shape)
	{
	for (int i=0; i<sets.Count(); i++) {
		sets[i]->SetSize(shape);
		}
	}

NVertSelSetList& NVertSelSetList::operator=(NVertSelSetList& from)
	{
	for (int i=0; i<sets.Count(); i++) {
		delete sets[i];
		}
	sets.SetCount(0);
	return *this;
	}

static void BitArrayDeleteSet(BitArray &ba,BitArray &set,int m)
	{
	int j = 0, sz = set.GetSize();
	if (ba.GetSize()<sz) sz = ba.GetSize();

	for (int i=0; i<sz; i++) {
		if (set[i]) continue;
		
		for (int k=0; k<m; k++) ba.Set(j*m+k,ba[i*m+k]);
		j++;
		}
	if (j*m!=ba.GetSize()) ba.SetSize(j*m,TRUE);
	}

void NVertSelSetList::DeleteSetElements(ShapeVSel &set,int m)
	{
	for (int i=0; i<sets.Count(); i++) {
		if (!(*this)[i].IsCompatible(set)) {
			(*this)[i].SetSize(set);
			}
		for(int j = 0; j < set.polys; ++j)
			BitArrayDeleteSet((*this)[i][j],set[j],m);
		}
	}

#define SELSET_SET_CHUNK		0x1000

IOResult NVertSelSetList::Load(ILoad *iload)
	{
	IOResult res;
	ShapeVSel set;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SELSET_SET_CHUNK:				
				set = ShapeVSel();
				res = set.Load(iload);				
				AppendSet(set);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult NVertSelSetList::Save(ISave *isave)
	{
	for (int i=0; i<sets.Count(); i++) {
		isave->BeginChunk(SELSET_SET_CHUNK);
		sets[i]->Save(isave);
		isave->EndChunk();
		}
	return IO_OK;
	}

NSegSelSetList::~NSegSelSetList()
	{
	for (int i=0; i<sets.Count(); i++) {
		delete sets[i];
		}
	}

void NSegSelSetList::AppendSet(ShapeSSel &nset)
	{
	ShapeSSel *n = new ShapeSSel();
	*n = nset;
	sets.Append(1,&n);
	}

void NSegSelSetList::DeleteSet(int i)
	{
	delete sets[i];
	sets.Delete(i,1);
	}

void NSegSelSetList::SetSize(BezierShape& shape)
	{
	for (int i=0; i<sets.Count(); i++) {
		sets[i]->SetSize(shape);
		}
	}

NSegSelSetList& NSegSelSetList::operator=(NSegSelSetList& from)
	{
	for (int i=0; i<sets.Count(); i++) {
		delete sets[i];
		}
	sets.SetCount(0);
	return *this;
	}

void NSegSelSetList::DeleteSetElements(ShapeSSel &set,int m)
	{
	for (int i=0; i<sets.Count(); i++) {
		if (!(*this)[i].IsCompatible(set)) {
			(*this)[i].SetSize(set);
			}
		for(int j = 0; j < set.polys; ++j)
			BitArrayDeleteSet((*this)[i][j],set[j],m);
		}
	}

#define SELSET_SET_CHUNK		0x1000
#define SELSET_NAME_CHUNK		0x1010

IOResult NSegSelSetList::Load(ILoad *iload)
	{
	IOResult res;
	ShapeSSel set;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SELSET_SET_CHUNK:				
				set = ShapeSSel();
				res = set.Load(iload);				
				AppendSet(set);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult NSegSelSetList::Save(ISave *isave)
	{
	for (int i=0; i<sets.Count(); i++) {
		isave->BeginChunk(SELSET_SET_CHUNK);
		sets[i]->Save(isave);
		isave->EndChunk();
		}
	return IO_OK;
	}

//--- Named spline selection sets --------------------------------

NPolySelSetList::~NPolySelSetList()
	{
	for (int i=0; i<sets.Count(); i++) {
		delete sets[i];
		}
	}

void NPolySelSetList::AppendSet(ShapePSel &nset)
	{
	ShapePSel *n = new ShapePSel();
	*n = nset;
	sets.Append(1,&n);
	}

void NPolySelSetList::DeleteSet(int i)
	{
	delete sets[i];
	sets.Delete(i,1);
	}

void NPolySelSetList::SetSize(BezierShape& shape)
	{
	for (int i=0; i<sets.Count(); i++) {
		sets[i]->SetSize(shape);
		}
	}

NPolySelSetList& NPolySelSetList::operator=(NPolySelSetList& from)
	{
	for (int i=0; i<sets.Count(); i++) {
		delete sets[i];
		}
	sets.SetCount(0);
	return *this;
	}

void NPolySelSetList::DeleteSetElements(ShapePSel &set,int m)
	{
	for (int i=0; i<sets.Count(); i++) {
		if (!(*this)[i].IsCompatible(set)) {
			(*this)[i].SetSize(set);
			}
		BitArrayDeleteSet((*this)[i].sel,set.sel,m);
		}
	}

#define SELSET_SET_CHUNK		0x1000
#define SELSET_NAME_CHUNK		0x1010

IOResult NPolySelSetList::Load(ILoad *iload)
	{
	IOResult res;
	ShapePSel set;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SELSET_SET_CHUNK:				
				set = ShapePSel();
				res = set.Load(iload);				
				AppendSet(set);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult NPolySelSetList::Save(ISave *isave)
	{
	for (int i=0; i<sets.Count(); i++) {
		isave->BeginChunk(SELSET_SET_CHUNK);
		sets[i]->Save(isave);
		isave->EndChunk();
		}
	return IO_OK;
	}
int splineHitOverride = 0;	// If zero, no override is done

void SetSplineHitOverride(int value) {
	splineHitOverride = value;
	}

void ClearSplineHitOverride() {
	splineHitOverride = 0;
	}
static Class_ID SPLSELECT_CLASS_ID(0x4dbe3132, 0x614357b9);

class SplineSelMod : public Modifier {	
	public:				
		DWORD selLevel;
		Tab<TSTR*> namedSel[3];		

		static IObjParam *ip;
		static IParamMap *pmapParam;
		static SplineSelMod *editMod;
		static BOOL selByVert;
		static HWND hParams;
		static SelectModBoxCMode *selectMode;
		static BOOL updateCachePosted;

		SplineSelMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s = GetString(IDS_AP_SPLINESELMOD);}  
		virtual Class_ID ClassID() { return SPLSELECT_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_SPLINESELMOD);}

		// From modifier
		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE;}
		ChannelMask ChannelsChanged() {return PART_SELECT;}
		Class_ID InputType() { return Class_ID(SPLINESHAPE_CLASS_ID,0); }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t) {return FOREVER;}

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		void ActivateSubobjSel(int level, XFormModes& modes);
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
		void ClearSelection(int selLevel);
		void SelectAll(int selLevel);
		void InvertSelection(int selLevel);
		void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);

		BOOL SupportsNamedSubSels() {return TRUE;}
		void ActivateSubSelSet(TSTR &setName);
		void NewSetFromCurSel(TSTR &setName);
		void RemoveSubSelSet(TSTR &setName);
		void SetupNamedSelDropDown();
		int NumNamedSelSets();
		TSTR GetNamedSelSetName(int i);
		void SetNamedSelSetName(int i,TSTR &newName);
		void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);


		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		IOResult LoadNamedSelChunk(ILoad *iload,int level);
		IOResult SaveLocalData(ISave *isave, LocalModData *ld);
		IOResult LoadLocalData(ILoad *iload, LocalModData **pld);

		int NumRefs() {return 0;}
		RefTargetHandle GetReference(int i) {return NULL;}
		void SetReference(int i, RefTargetHandle rtarg) {}

		int NumSubs() {return 0;}
		Animatable* SubAnim(int i) {return NULL;}
		TSTR SubAnimName(int i) {return _T("");}

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message) {return REF_SUCCEED;}

		void RemoveRollupPages();
		void SetRollupPages();
		void SelectFrom(int from);
		void UpdateCache(TimeValue t);

		// Local methods for handling named selection sets
		int FindSet(TSTR &setName,int level);
		void AddSet(TSTR &setName,int level);
		void RemoveSet(TSTR &setName,int level);
		void ClearSetNames();
		void NSCopy();
		void NSPaste();
		BOOL GetUniqueSetName(TSTR &name);
		int SelectNamedSet();

	};


class SplineSelData : public LocalModData {
	public:
		// Selection sets
		ShapeVSel vertSel;
		ShapeSSel SegSel;
		ShapePSel SplineSel;

		// Lists of named selection sets
		NVertSelSetList NvselSet;
		NSegSelSetList NsegselSet;
		NPolySelSetList NsplselSet;

		BOOL held;
		BezierShape *shape;

		SplineSelData(BezierShape &shape);
		SplineSelData() {held=0;shape=NULL;}
		~SplineSelData() {FreeCache();}
		LocalModData *Clone();
		BezierShape *GetShape() {return shape;}
		void SetCache(BezierShape &Shape);
		void FreeCache();

		void SelVertBySeg();
		void SelVertBySpline();
		void SelSegByVert();
		void SelSegBySpline();
		void SelSplineByVert();
		void SelSplineBySeg();
	};


class SplSelRestore : public RestoreObj {
	public:
		ShapeVSel uvsel,rvsel;
		ShapeSSel ussel,rssel;
		ShapePSel upsel,rpsel;
		BitArray *sel;
		SplineSelMod *mod;
		SplineSelData *d;
		int level;

		SplSelRestore(SplineSelMod *m, SplineSelData *d);
		void Restore(int isUndo);
		void Redo();
		int Size() { return 1; }
		void EndHold() {d->held=FALSE;}
		TSTR Description() { return TSTR(_T("SelectRestore")); }
	};

class SetNameRestore : public RestoreObj {
	public:
		TSTR undo, redo;
		int index;
		Tab<TSTR*> *sets;
		SplineSelMod *ss;
		SetNameRestore(int i,Tab<TSTR*> *s1,SplineSelMod *s) {
			index = i; sets = s1; ss = s;
			undo = *(*sets)[index];
			}

		void Restore(int isUndo) {			
			redo = *(*sets)[index];
			*(*sets)[index] = undo;
			if (ss->ip) ss->ip->NamedSelSetListChanged();
			}
		void Redo() {
			*(*sets)[index] = redo;
			if (ss->ip) ss->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Set Name"));}
	};

class AppendVertSetRestore : public RestoreObj {
	public:
		ShapeVSel set;
		NVertSelSetList *setList;

		AppendVertSetRestore(NVertSelSetList *sl) {	setList = sl;}   		
		void Restore(int isUndo) {
			set  = *setList->sets[setList->Count()-1];
			setList->DeleteSet(setList->Count()-1);
			}
		void Redo() {
			setList->AppendSet(set);
			}
				
		TSTR Description() {return TSTR(_T("Append Vert Set"));}
	};
class NAppendSetNameRestore : public RestoreObj {
	public:
		TSTR name;
		SplineSelMod *ss;
		Tab<TSTR*> *sets;

		NAppendSetNameRestore(SplineSelMod *sl,Tab<TSTR*> *s) {
			ss = sl; 
			sets = s;
			}   		
		void Restore(int isUndo) {
			name = *(*sets)[sets->Count()-1];
			delete (*sets)[sets->Count()-1];
			sets->Delete(sets->Count()-1,1);			
			if (ss->ip) ss->ip->NamedSelSetListChanged();
			}
		void Redo() {
			TSTR *nm = new TSTR(name);
			sets->Append(1,&nm);
			if (ss->ip) ss->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Append Set Name"));}
	};
class AppendSegSetRestore : public RestoreObj {
	public:
		ShapeSSel set;
		NSegSelSetList *setList;

		AppendSegSetRestore(NSegSelSetList *sl) {	setList = sl;}   		
		void Restore(int isUndo) {
			set  = *setList->sets[setList->Count()-1];
			setList->DeleteSet(setList->Count()-1);
			}
		void Redo() {
			setList->AppendSet(set);
			}
				
		TSTR Description() {return TSTR(_T("Append Seg Set"));}
	};
class AppendPolySetRestore : public RestoreObj {
	public:
		ShapePSel set;
		NPolySelSetList *setList;

		AppendPolySetRestore(NPolySelSetList *sl) {	setList = sl;}   		
		void Restore(int isUndo) {
			set  = *setList->sets[setList->Count()-1];
			setList->DeleteSet(setList->Count()-1);
			}
		void Redo() {
			setList->AppendSet(set);
			}
				
		TSTR Description() {return TSTR(_T("Append Poly Set"));}
	};

class DeleteVertSetRestore : public RestoreObj {
	public:
		ShapeVSel set;
		int index;
		NVertSelSetList *setList;

		DeleteVertSetRestore(int i,NVertSelSetList *sl) {
			setList = sl; index = i;
			set  = *setList->sets[index];
			}   		
		void Restore(int isUndo) {
			ShapeVSel *n = new ShapeVSel(set);
			setList->sets.Insert(index,1,&n);
			}
		void Redo() {
			setList->DeleteSet(index);
			}
				
		TSTR Description() {return TSTR(_T("Delete Vert Set"));}
	};

class DeleteSegSetRestore : public RestoreObj {
	public:
		ShapeSSel set;
		int index;
		NSegSelSetList *setList;

		DeleteSegSetRestore(int i,NSegSelSetList *sl) {
			setList = sl; index = i;
			set  = *setList->sets[index];
			}   		
		void Restore(int isUndo) {
			ShapeSSel *n = new ShapeSSel(set);
			setList->sets.Insert(index,1,&n);
			}
		void Redo() {
			setList->DeleteSet(index);
			}
				
		TSTR Description() {return TSTR(_T("Delete Seg Set"));}
	};

class DeletePolySetRestore : public RestoreObj {
	public:
		ShapePSel set;
		int index;
		NPolySelSetList *setList;

		DeletePolySetRestore(int i,NPolySelSetList *sl) {
			setList = sl; index = i;
			set  = *setList->sets[index];
			}   		
		void Restore(int isUndo) {
			ShapePSel *n = new ShapePSel(set);
			setList->sets.Insert(index,1,&n);
			}
		void Redo() {
			setList->DeleteSet(index);
			}
				
		TSTR Description() {return TSTR(_T("Delete Poly Set"));}
	};

class DeleteSetNameRestore : public RestoreObj {
	public:		
		TSTR name;
		int index;		
		SplineSelMod *ss;
		Tab<TSTR*> *sets;

		DeleteSetNameRestore(int i,Tab<TSTR*> *s,SplineSelMod *sm) {
			sets = s; ss = sm; index = i;			
			name = *(*sets)[index];
			}   		
		void Restore(int isUndo) {			
			TSTR *nm = new TSTR(name);			
			sets->Insert(index,1,&nm);
			if (ss->ip) ss->ip->NamedSelSetListChanged();
			}
		void Redo() {
			sets->Delete(index,1);
			if (ss->ip) ss->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Delete Set Name"));}
	};

//--- ClassDescriptor and class vars ---------------------------------

#define SEL_OBJECT	0
#define SEL_VERTEX	1
#define SEL_SEGMENT		2
#define SEL_SPLINE	3


IObjParam             *SplineSelMod::ip              = NULL;
IParamMap             *SplineSelMod::pmapParam       = NULL;
SplineSelMod            *SplineSelMod::editMod         = NULL;
HWND                   SplineSelMod::hParams         = NULL;
BOOL                   SplineSelMod::selByVert       = FALSE;
SelectModBoxCMode     *SplineSelMod::selectMode      = NULL;
BOOL                   SplineSelMod::updateCachePosted = FALSE;

static float lastSegThresh = 1.0f;

class SplSelClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SplineSelMod; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_SPLINESELMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return SPLSELECT_CLASS_ID; }
	const TCHAR* 	Category() { return GetString(IDS_AP_DEFDEFORMATIONS);}
	};

static SplSelClassDesc SplSelDesc;
ClassDesc* GetSplineSelModDesc() {return &SplSelDesc;}


static HIMAGELIST hSegImages = NULL;

static BOOL CALLBACK SplineSelObjectProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK SplineSelVertProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK SplineSelSegProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static BOOL CALLBACK SplineSelProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static DLGPROC windProcs[] = {SplineSelObjectProc,SplineSelVertProc,SplineSelSegProc,SplineSelProc};
static int dlgIDs[] = {IDD_SPLSEL_OBJECT,IDD_SPLSEL_VERTEX,IDD_SPLSEL_SEGMENT,IDD_SPLSEL_SPLINE};
static int dlgTitles[] = {IDS_AP_SELOBJECT,IDS_AP_SELVERTEX,IDS_AP_SELSEG,IDS_AP_SELSPLINE};

// Table to convert selLevel values to shape selLevel flags.
const int shapeLevel[] = {SHAPE_OBJECT,SHAPE_VERTEX,SHAPE_SEGMENT,SHAPE_SPLINE};

// Get display flags based on selLevel.
const DWORD shapeLevelDispFlags[] = {0,DISP_VERTTICKS|DISP_SELVERTS,DISP_VERTTICKS|DISP_SELSEGMENTS,DISP_SELPOLYS};

// For hit testing...
const int shapeHitLevel[] = {0,SUBHIT_SHAPE_VERTS,SUBHIT_SHAPE_SEGMENTS,SUBHIT_SHAPE_POLYS};

//--- SPLSEL mod methods -------------------------------

SplineSelMod::SplineSelMod()
	{	
	selLevel = SEL_VERTEX;
	}

RefTargetHandle SplineSelMod::Clone(RemapDir& remap)
{   SplineSelMod *ssmod= new SplineSelMod();
	ssmod->selLevel = selLevel;
	return ssmod;
}

void SplineSelMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{ if ( os->obj->ClassID() == Class_ID(SPLINESHAPE_CLASS_ID,0))
  { SplineShape *sShape = (SplineShape *)os->obj;
    BezierShape splShape=sShape->GetShape();
    SplineSelData *d  = (SplineSelData*)mc.localData;
    if (!d) {	mc.localData = d = new SplineSelData(splShape);}
	if (editMod==this) 
	{ if (!d->GetShape()) d->SetCache(splShape); }

	d->vertSel.SetSize(splShape,1);
	d->SegSel.SetSize(splShape,1);
	d->SplineSel.SetSize(splShape,1);
	sShape->shape.vertSel = d->vertSel;
	sShape->shape.segSel = d->SegSel;
	sShape->shape.polySel = d->SplineSel;

	if (d->GetShape()) {
	// Keep the cache up to date if it exists.
	d->GetShape()->vertSel = d->vertSel;
	d->GetShape()->segSel = d->SegSel;
	d->GetShape()->polySel = d->SplineSel;
	}

	sShape->shape.dispFlags = 0;
	switch ( selLevel ) {
		case SS_SPLINE:
			sShape->shape.SetDispFlag(DISP_SELPOLYS);
			break;
		case SS_VERTEX:
			sShape->shape.SetDispFlag(DISP_VERTTICKS|DISP_SELVERTS);
			break;
		case SS_SEGMENT:
			sShape->shape.SetDispFlag(DISP_VERTTICKS|DISP_SELSEGMENTS);			
			break;
		}
	sShape->shape.selLevel = shapeLevel[selLevel];
  }
}


void SplineSelMod::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc)
	{
	if (mc->localData && ip) {
		((SplineSelData*)mc->localData)->FreeCache();
		TimeValue t = ip->GetTime();
		if (hParams && editMod==this && !updateCachePosted) {
			PostMessage(hParams,WM_UPDATE_CACHE,(WPARAM)t,0);
			updateCachePosted = TRUE;
			}
/*		NotifyDependents(Interval(t,t), 
			PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|
			PART_DISPLAY|PART_TOPO,
		    REFMSG_MOD_EVAL);  */

		}
	}

void SplineSelMod::UpdateCache(TimeValue t)
	{
	NotifyDependents(Interval(t,t), 
		PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|
		PART_DISPLAY|PART_TOPO,
		REFMSG_MOD_EVAL);
	updateCachePosted = FALSE;
	}


void SplineSelMod::RemoveRollupPages()
	{
	if (hParams) ip->DeleteRollupPage(hParams);
	hParams = NULL;	
	}

void SplineSelMod::SetRollupPages()
	{
	RemoveRollupPages();
	hParams = ip->AddRollupPage( 
		hInstance, 
		MAKEINTRESOURCE(dlgIDs[selLevel]),
		windProcs[selLevel],
		GetString(dlgTitles[selLevel]),
		(LPARAM)this);	
	}

void SplineSelMod::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;	
	editMod  = this;

	SetRollupPages();
	
	selectMode = new SelectModBoxCMode(this,ip);

	// Add our sub object type
	TSTR type1(GetString(IDS_AP_VERTEX));
	TSTR type2(GetString(IDS_AP_SEGMENT));
	TSTR type3(GetString(IDS_AP_SPLINE));
	const TCHAR *ptype[] = {type1, type2, type3};
	ip->RegisterSubObjectTypes(ptype, 3);

	// Restore the selection level.
	ip->SetSubObjectLevel(selLevel);

	// Disable show end result.
	ip->EnableShowEndResult(FALSE);
		
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	}

void SplineSelMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	for (int i=0; i<list.Count(); i++) {
		if (list[i]->localData) {
			((SplineSelData*)list[i]->localData)->FreeCache();
			}
		}
	nodes.DisposeTemporary();

	RemoveRollupPages();

	ip->DeleteMode(selectMode);
	if (selectMode) delete selectMode;
	selectMode = NULL;

	// Enable show end result
	ip->EnableShowEndResult(TRUE);

	this->ip = NULL;
	editMod  = NULL;
	hParams  = NULL;
	}

int SplineSelMod::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{
	Interval valid;
	int savedLimits,res = 0;
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 mat = inode->GetObjectTM(t);
	gw->setTransform(mat);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	
	if ( mc->localData ) {		
		SplineSelData *shapeData = (SplineSelData*)mc->localData;
		BezierShape *shape = shapeData->GetShape();
		if(!shape) return 0;
		SubShapeHitList hitList;
		ShapeSubHitRec *rec;
		res = shape->SubObjectHitTest( gw, gw->getMaterial(), &hr,
			flags|((splineHitOverride) ? shapeHitLevel[splineHitOverride] : shapeHitLevel[selLevel]), hitList );
	
		rec = hitList.First();
		while( rec ) {
			vpt->LogHit(inode,mc,rec->dist,123456,new ShapeHitData(rec->shape, rec->poly, rec->index));
			rec = rec->Next();
			}
		}

	gw->setRndLimits(savedLimits);	
	return res;
}

void SplineSelMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
	//SetSubobjectLevel(level);
	selLevel = level;

	// Fill in modes with our sub-object modes
	if (level!=SEL_OBJECT) {
		modes = XFormModes(NULL,NULL,NULL,NULL,NULL,selectMode);
		}

	// Setup rollup pages
	SetRollupPages();
	
	// Setup named selection sets	
	SetupNamedSelDropDown();

	ip->PipeSelLevelChanged();
	NotifyDependents(FOREVER, SELECT_CHANNEL|DISP_ATTRIB_CHANNEL|SUBSEL_TYPE_CHANNEL, REFMSG_CHANGE);
	}

void SplineSelMod::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert)
	{
	SplineSelData *d = NULL, *od = NULL;	

	ip->ClearCurNamedSelSet();

	switch (selLevel) {
		case SEL_VERTEX:
			while (hitRec) {
				d = (SplineSelData*)hitRec->modContext->localData;
				if (d) {
					if (theHold.Holding() && !d->held) theHold.Put(new SplSelRestore(this,d));
					BOOL state = selected;
					int poly=((ShapeHitData *)(hitRec->hitData))->poly;
					int vert=((ShapeHitData *)(hitRec->hitData))->index;
					if (invert) state = !d->vertSel[poly][vert];
					if (state) d->vertSel[poly].Set(vert);
					else       d->vertSel[poly].Clear(vert);
					}
				if (!all) break;
				hitRec = hitRec->Next();
				}			
			break;

		case SEL_SEGMENT: 
			while (hitRec) {					
				d = (SplineSelData*)hitRec->modContext->localData;
				if (d) {
					if (theHold.Holding() && !d->held) theHold.Put(new SplSelRestore(this,d));
					BOOL state = selected;
					int poly=((ShapeHitData *)(hitRec->hitData))->poly;
					int vert=((ShapeHitData *)(hitRec->hitData))->index;
					if (invert) state = !d->SegSel[poly][vert];
					if (state) d->SegSel[poly].Set(vert);
					else       d->SegSel[poly].Clear(vert);
					}
				if (!all) break;
				hitRec = hitRec->Next();
				}
			break;

		case SEL_SPLINE:
			while (hitRec) {				
				d = (SplineSelData*)hitRec->modContext->localData;
				if (d) {
					if (theHold.Holding() && !d->held) theHold.Put(new SplSelRestore(this,d));
					BOOL state = selected;
					int poly=((ShapeHitData *)(hitRec->hitData))->poly;
					if (invert) state = !d->SplineSel[poly];
					if (state) d->SplineSel.Set(poly);
					else       d->SplineSel.Clear(poly);					
					}
				if (!all) break;
				hitRec = hitRec->Next();
				}
			break;
		};

	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void SplineSelMod::ClearSelection(int selLevel)
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	SplineSelData *d;
	for (int i=0; i<list.Count(); i++) {
		d = (SplineSelData*)list[i]->localData;
		if (!d) continue;
		if (theHold.Holding() && !d->held) theHold.Put(new SplSelRestore(this,d));
		switch (selLevel) {
			case SEL_VERTEX: d->vertSel.ClearAll(); break;
			case SEL_SEGMENT:   d->SegSel.ClearAll(); break;
			case SEL_SPLINE:   d->SplineSel.ClearAll(); break;
			}
		}
	ip->ClearCurNamedSelSet();
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void SplineSelMod::SelectAll(int selLevel)
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	SplineSelData *d;
	for (int i=0; i<list.Count(); i++) {
		d = (SplineSelData*)list[i]->localData;
		if (!d) continue;
		if (theHold.Holding() && !d->held) theHold.Put(new SplSelRestore(this,d));
		switch (selLevel) {
			case SEL_VERTEX: d->vertSel.SetAll(); break;
			case SEL_SEGMENT:   d->SegSel.SetAll(); break;
			case SEL_SPLINE:   d->SplineSel.SetAll(); break;
			}
		}
	ip->ClearCurNamedSelSet();
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void SplineSelMod::InvertSelection(int selLevel)
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	SplineSelData *d;
	for (int i=0; i<list.Count(); i++) {
		d = (SplineSelData*)list[i]->localData;
		if (!d) continue;
		if (theHold.Holding() && !d->held) theHold.Put(new SplSelRestore(this,d));
		switch (selLevel) {
			case SEL_VERTEX:  
				{for (int j=0;j<d->vertSel.polys;j++) d->vertSel[j]=~d->vertSel[j];
				 break;
				}
			case SEL_SEGMENT:  
				{ for (int j=0;j<d->SegSel.polys;j++)
					d->SegSel[j] = ~d->SegSel[j];
				  break;
				}
			case SEL_SPLINE:  d->SplineSel.sel = d->SplineSel.sel; break;
			}
		}
	ip->ClearCurNamedSelSet();
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void SplineSelMod::SelectFrom(int from) 
	{
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	SplineSelData *d;
	theHold.Begin();
	for (int i=0; i<list.Count(); i++) {
		d = (SplineSelData*)list[i]->localData;
		if (!d) continue;
		if (!d->held) theHold.Put(new SplSelRestore(this,d));
		switch (selLevel) {
			case SEL_VERTEX: 
				if (from==SEL_SEGMENT) d->SelVertBySeg();
				else d->SelVertBySpline();
				break;
			case SEL_SEGMENT:   
				if (from==SEL_VERTEX) d->SelSegByVert();
				else d->SelSegBySpline();
				break;
			case SEL_SPLINE:
				if (from==SEL_VERTEX) d->SelSplineByVert();
				else d->SelSplineBySeg();
				break;
			}
		}
	theHold.Accept(GetString(IDS_AP_SELECT));
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	ip->ClearCurNamedSelSet();
	}

#define SELLEVEL_CHUNKID		0x0100
#define VERTSEL_CHUNKID			0x0200
#define SEGSEL_CHUNKID			0x0210
#define SPLINESEL_CHUNKID		0x0220

#define NAMEDVSEL_NAMES_CHUNK	0x2805
#define NAMEDFSEL_NAMES_CHUNK	0x2806
#define NAMEDESEL_NAMES_CHUNK	0x2807
#define NAMEDSEL_STRING_CHUNK	0x2809

#define NvselSet_CHUNK			0x2845
#define FSELSET_CHUNK			0x2846
#define ESELSET_CHUNK			0x2847

static int namedSelID[] = {NAMEDVSEL_NAMES_CHUNK,NAMEDFSEL_NAMES_CHUNK,NAMEDESEL_NAMES_CHUNK};


IOResult SplineSelMod::Save(ISave *isave)
	{
	IOResult res;
	ULONG nb;
	Modifier::Save(isave);
	isave->BeginChunk(SELLEVEL_CHUNKID);
	res = isave->Write(&selLevel, sizeof(selLevel), &nb);
	isave->EndChunk();

	for (int j=0; j<3; j++) {
		if (namedSel[j].Count()) {
			isave->BeginChunk(namedSelID[j]);			
			for (int i=0; i<namedSel[j].Count(); i++) {
				isave->BeginChunk(NAMEDSEL_STRING_CHUNK);
				isave->WriteWString(*namedSel[j][i]);
				isave->EndChunk();
				}
			isave->EndChunk();
			}
		}

	return res;
	}

IOResult SplineSelMod::LoadNamedSelChunk(ILoad *iload,int level)
	{	
	IOResult res;
	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case NAMEDSEL_STRING_CHUNK: {
				TCHAR *name;
				res = iload->ReadWStringChunk(&name);
				AddSet(TSTR(name),level+1);
				break;
				}
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult SplineSelMod::Load(ILoad *iload)
	{
	IOResult res;
	ULONG nb;
	Modifier::Load(iload);
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SELLEVEL_CHUNKID:
				iload->Read(&selLevel, sizeof(selLevel), &nb);
				break;

			case NAMEDVSEL_NAMES_CHUNK: {				
				res = LoadNamedSelChunk(iload,0);
				break;
				}

			case NAMEDFSEL_NAMES_CHUNK: {
				res = LoadNamedSelChunk(iload,1);
				break;
				}

			case NAMEDESEL_NAMES_CHUNK: {
				res = LoadNamedSelChunk(iload,2);
				break;
				}
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult SplineSelMod::SaveLocalData(ISave *isave, LocalModData *ld)
	{	
	SplineSelData *d = (SplineSelData*)ld;

	isave->BeginChunk(VERTSEL_CHUNKID);
	d->vertSel.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(SEGSEL_CHUNKID);
	d->SegSel.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(SPLINESEL_CHUNKID);
	d->SplineSel.Save(isave);
	isave->EndChunk();
	
	if (d->NvselSet.Count()) {
		isave->BeginChunk(NvselSet_CHUNK);
		d->NvselSet.Save(isave);
		isave->EndChunk();
		}
	if (d->NsplselSet.Count()) {
		isave->BeginChunk(ESELSET_CHUNK);
		d->NsplselSet.Save(isave);
		isave->EndChunk();
		}
	if (d->NsegselSet.Count()) {
		isave->BeginChunk(FSELSET_CHUNK);
		d->NsegselSet.Save(isave);
		isave->EndChunk();
		}

	return IO_OK;
	}

IOResult SplineSelMod::LoadLocalData(ILoad *iload, LocalModData **pld)
	{
	SplineSelData *d = new SplineSelData;
	*pld = d;
	IOResult res;	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VERTSEL_CHUNKID:
				d->vertSel.Load(iload);
				break;
			case SEGSEL_CHUNKID:
				d->SegSel.Load(iload);
				break;
			case SPLINESEL_CHUNKID:
				d->SplineSel.Load(iload);
				break;

			case NvselSet_CHUNK:
				res = d->NvselSet.Load(iload);
				break;
			case FSELSET_CHUNK:
				res = d->NsegselSet.Load(iload);
				break;
			case ESELSET_CHUNK:
				res = d->NsplselSet.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}



// Window Procs ------------------------------------------------------

static BOOL CALLBACK SplineSelObjectProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SplineSelMod *mod = (SplineSelMod*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG:
			mod = (SplineSelMod*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mod->hParams = hWnd;
			break;
		
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			mod->ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			break;
		case WM_UPDATE_CACHE:
			mod->UpdateCache((TimeValue)wParam);
 			break;
		default: return FALSE;
		}
	return TRUE;
	}

static BOOL CALLBACK SplineSelVertProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SplineSelMod *mod = (SplineSelMod*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG: {
			mod = (SplineSelMod*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mod->hParams = hWnd;

			ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_VERT_PASTENS));
			if (GetShapeNamedVertSelClip()) but->Enable();
			else but->Disable();
			ReleaseICustButton(but);
			break;
			}
		
		case WM_UPDATE_CACHE:
			mod->UpdateCache((TimeValue)wParam);
 			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SPLSEL_GETSEGMENT: mod->SelectFrom(SEL_SEGMENT); break;
				case IDC_SPLSEL_GETSPLINE: mod->SelectFrom(SEL_SPLINE); break;

				case IDC_VERT_COPYNS:  mod->NSCopy();  break;
				case IDC_VERT_PASTENS: mod->NSPaste(); break;
				}
			break;

		default: return FALSE;
		}
	return TRUE;
	}
static BOOL CALLBACK SplineSelSegProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SplineSelMod *mod = (SplineSelMod*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG: {
			mod = (SplineSelMod*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mod->hParams = hWnd;

			ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_SEG_PASTENS));
			if (GetShapeNamedSegSelClip()) but->Enable();
			else but->Disable();
			ReleaseICustButton(but);
			break;
			}
		
		case WM_UPDATE_CACHE:
			mod->UpdateCache((TimeValue)wParam);
 			break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SPLSEL_GETVERTEX: mod->SelectFrom(SEL_VERTEX); break;
				case IDC_SPLSEL_GETSPLINE: mod->SelectFrom(SEL_SPLINE); break;

				case IDC_SEG_COPYNS:  mod->NSCopy();  break;
				case IDC_SEG_PASTENS: mod->NSPaste(); break;
				}
			break;

		default: return FALSE;
		}
	return TRUE;
	}

static BOOL CALLBACK SplineSelProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	SplineSelMod *mod = (SplineSelMod*)GetWindowLong(hWnd,GWL_USERDATA);
	switch (msg) {
		case WM_INITDIALOG: {
			mod = (SplineSelMod*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mod->hParams = hWnd;
			
			ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_SPLINE_PASTENS));
			if (GetShapeNamedPolySelClip()) but->Enable();
			else but->Disable();
			ReleaseICustButton(but);
			break;
			}
		
		case WM_UPDATE_CACHE:
			mod->UpdateCache((TimeValue)wParam);
 			break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_SPLSEL_GETVERTEX: mod->SelectFrom(SEL_VERTEX); break;
				case IDC_SPLSEL_GETSEGMENT: mod->SelectFrom(SEL_SEGMENT); break;

				case IDC_SPLINE_COPYNS:  mod->NSCopy();  break;
				case IDC_SPLINE_PASTENS: mod->NSPaste(); break;
				}
			break;

		default: return FALSE;
		}
	return TRUE;
	}


static BOOL CALLBACK PickSetNameDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static TSTR *name;

	switch (msg) {
		case WM_INITDIALOG: {
			name = (TSTR*)lParam;
			ICustEdit *edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
			edit->SetText(*name);
			ReleaseICustEdit(edit);
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ICustEdit *edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
					TCHAR buf[256];
					edit->GetText(buf,256);
					*name = TSTR(buf);
					ReleaseICustEdit(edit);
					EndDialog(hWnd,1);
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		};
	return TRUE;
	}

BOOL SplineSelMod::GetUniqueSetName(TSTR &name)
	{
	while (1) {				
		Tab<TSTR*> &setList = namedSel[selLevel-1];

		BOOL unique = TRUE;
		for (int i=0; i<setList.Count(); i++) {
			if (name==*setList[i]) {
				unique = FALSE;
				break;
				}
			}
		if (unique) break;

		if (!DialogBoxParam(
			hInstance, 
			MAKEINTRESOURCE(IDD_PASTE_NAMEDSET),
			hParams, 
			PickSetNameDlgProc,
			(LPARAM)&name)) return FALSE;		
		}
	return TRUE;
	}

static BOOL CALLBACK PickSetDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{	
	switch (msg) {
		case WM_INITDIALOG:	{
			Tab<TSTR*> *setList = (Tab<TSTR*>*)lParam;
			for (int i=0; i<setList->Count(); i++) {
				int pos  = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_ADDSTRING,0,
					(LPARAM)(TCHAR*)*(*setList)[i]);
				SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_SETITEMDATA,pos,i);
				}
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					int sel = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETCURSEL,0,0);
					if (sel!=LB_ERR) {
						int res =SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETITEMDATA,sel,0);
						EndDialog(hWnd,res);
						break;
						}
					// fall through
					}

				case IDCANCEL:
					EndDialog(hWnd,-1);
					break;
				}
			break;

		default:
			return FALSE;
		};
	return TRUE;
	}

int SplineSelMod::SelectNamedSet()
	{
	Tab<TSTR*> &setList = namedSel[selLevel-1];
	return DialogBoxParam(
		hInstance, 
		MAKEINTRESOURCE(IDD_SEL_NAMEDSET),
		hParams, 
		PickSetDlgProc,
		(LPARAM)&setList);
	}




// SplineSelData -----------------------------------------------------

LocalModData *SplineSelData::Clone()
	{
	SplineSelData *d = new SplineSelData;
	d->vertSel = vertSel;
	d->SegSel = SegSel;
	d->SplineSel = SplineSel;
	held = FALSE;
	shape = NULL;
	return d;
	}

SplineSelData::SplineSelData(BezierShape &shape)
{ 	vertSel = shape.vertSel;
	SegSel = shape.segSel;
	SplineSel = shape.polySel;
//	vertSel.ClearAll();	SegSel.ClearAll();SplineSel.ClearAll();
	held = FALSE;
	this->shape = NULL;
}

void SplineSelData::FreeCache()
{ if (shape) delete shape;
  shape = NULL;
}

void SplineSelData::SetCache(BezierShape &Shape)
{ 	if (this->shape) delete this->shape;
	this->shape = new BezierShape(Shape);
}

void SplineSelData::SelVertBySeg()
{ int maxv=0,nxtj=0,vcnt=1;
  for (int i=0; i<SegSel.polys; i++) 
  {	maxv=vertSel[i].GetSize()-1; vcnt=1;
    for (int j=0;j<SegSel[i].GetSize();j++)
    { if (SegSel[i][j])
	  { vertSel[i].Set(vcnt);nxtj=vcnt+3;
		vertSel[i].Set(nxtj>maxv?1:nxtj);
	  }
	  vcnt+=3;
	}
  }
}

void SplineSelData::SelVertBySpline()
{ for (int i=0; i<SplineSel.polys; i++)
   if (SplineSel[i])		
	 for (int j=0; j<vertSel[i].GetSize();j++)
      	vertSel[i].Set(j);
}

void SplineSelData::SelSegByVert()
{ int maxv=0,nxtj=0,vcnt=1;
  for (int i=0; i<SegSel.polys; i++) 
  {	maxv=vertSel[i].GetSize()-1; vcnt=1;
  	for (int j=0; j<SegSel[i].GetSize(); j++)
	{ if ((vertSel[i][vcnt])||(vertSel[i][(nxtj=vcnt+3)>maxv?1:nxtj]))
	    SegSel[i].Set(j);
	  vcnt+=3;
	}
  }
}

void SplineSelData::SelSegBySpline()
{ for (int i=0; i<SplineSel.polys; i++)
   if (SplineSel[i])		
	 for (int j=0; j<SegSel[i].GetSize();j++)
      	SegSel[i].Set(j);
}

void SplineSelData::SelSplineByVert()
{ for (int i=0; i<SplineSel.polys; i++) 
  	for (int j=0; j<vertSel[i].GetSize(); j++) 
      if (vertSel[i][j]) 
	  {	SplineSel.Set(i);
		break;
	  }
}

void SplineSelData::SelSplineBySeg()
{ for (int i=0; i<SplineSel.polys; i++) 
  	for (int j=0; j<SegSel[i].GetSize(); j++) 
      if (SegSel[i][j]) 
	  {	SplineSel.Set(i);
		break;
	  }
}


// SplSelRestore --------------------------------------------------

SplSelRestore::SplSelRestore(SplineSelMod *m, SplineSelData *data)
	{
	mod     = m;
	level   = mod->selLevel;
	d       = data;
	d->held = TRUE;
	switch (level) {
		case SEL_OBJECT: assert(0); break;
		case SEL_VERTEX: uvsel = d->vertSel; break;
		case SEL_SEGMENT:  ussel = d->SegSel; break;
		case SEL_SPLINE:   upsel = d->SplineSel; break;
		}
	}

void SplSelRestore::Restore(int isUndo)
	{
	if (isUndo) {
		switch (level) {			
			case SEL_VERTEX: rvsel = d->vertSel; break;
			case SEL_SEGMENT:   rssel = d->SegSel; break;
			case SEL_SPLINE:   rpsel = d->SplineSel; break;
			}
		}
	switch (level) {		
		case SEL_VERTEX: d->vertSel = uvsel; break;
		case SEL_SEGMENT:   d->SegSel = ussel; break;
		case SEL_SPLINE:   d->SplineSel = upsel; break;
		}
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void SplSelRestore::Redo()
	{
	switch (level) {		
		case SEL_VERTEX: d->vertSel = rvsel; break;
		case SEL_SEGMENT:   d->SegSel = rssel; break;
		case SEL_SPLINE:   d->SplineSel = rpsel; break;
		}
	mod->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}


//--- Named selection sets -----------------------------------------

int SplineSelMod::FindSet(TSTR &setName,int level)
	{
	for (int i=0; i<namedSel[level-1].Count(); i++) {
		if (setName == *namedSel[level-1][i]) {
			return i;			
			}
		}
	return -1;
	}

void SplineSelMod::AddSet(TSTR &setName,int level)
	{
	TSTR *name = new TSTR(setName);
	namedSel[level-1].Append(1,&name);
	}

void SplineSelMod::RemoveSet(TSTR &setName,int level)
	{
	int i = FindSet(setName,level);
	if (i>=0) {
		delete namedSel[level-1][i];
		namedSel[level-1].Delete(i,1);
		}
	}

void SplineSelMod::ClearSetNames()
	{
	for (int i=0; i<3; i++) {
		for (int j=0; j<namedSel[i].Count(); j++) {
			delete namedSel[i][j];
			namedSel[i][j] = NULL;
			}
		}
	}

void SplineSelMod::ActivateSubSelSet(TSTR &setName)
	{ int i;
	ModContextList mcList;
	INodeTab nodes;
	if (!ip) return;
	i = FindSet(setName,selLevel);
	if (i<0) return;
	ip->GetModContexts(mcList,nodes);

	for (int index = 0; index < mcList.Count(); index++) {
		SplineSelData *ShapeData = (SplineSelData*)mcList[index]->localData;
		if (!ShapeData) continue;
		if (theHold.Holding() && !ShapeData->held) theHold.Put(new SplSelRestore(this,ShapeData));

		switch (selLevel) {
			case SEL_VERTEX:
			if (!(ShapeData->NvselSet[i]).IsCompatible(*ShapeData->shape))
				(ShapeData->NvselSet[i]).SetSize(*ShapeData->shape, TRUE);
			ShapeData->vertSel = ShapeData->NvselSet[i];
			break;

			case SEL_SEGMENT:
			if (!ShapeData->NsegselSet[i].IsCompatible(*ShapeData->shape))
				ShapeData->NsegselSet[i].SetSize(*ShapeData->shape, TRUE);
			ShapeData->SegSel = ShapeData->NsegselSet[i];
			break;

			case SEL_SPLINE:
			if (!ShapeData->NsplselSet[i].IsCompatible(*ShapeData->shape))
				ShapeData->NsplselSet[i].SetSize(*ShapeData->shape, TRUE);
			ShapeData->SplineSel = ShapeData->NsplselSet[i];
			break;
			}		
		}
	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);	
	ip->RedrawViews(ip->GetTime());
	}

void SplineSelMod::NewSetFromCurSel(TSTR &setName)
	{
	ModContextList mcList;
	INodeTab nodes;	
	int index = FindSet(setName,selLevel);	
	
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		SplineSelData *ShapeData = (SplineSelData*)mcList[i]->localData;
		if (!ShapeData) continue;
		
		switch (selLevel) {
			case SEL_VERTEX:	
				if (index>=0) ShapeData->NvselSet[index] = ShapeData->vertSel;
				else ShapeData->NvselSet.AppendSet(ShapeData->vertSel);				
				break;

			case SEL_SEGMENT:
				if (index>=0) ShapeData->NsegselSet[index] = ShapeData->SegSel;
				else ShapeData->NsegselSet.AppendSet(ShapeData->SegSel);					
				break;

			case SEL_SPLINE:
				if (index>=0) ShapeData->NsplselSet[index] = ShapeData->SplineSel;
				else ShapeData->NsplselSet.AppendSet(ShapeData->SplineSel);				
				break;
			}		
		}	
	
	if (index<0) AddSet(setName,selLevel);		
	nodes.DisposeTemporary();
	}

void SplineSelMod::RemoveSubSelSet(TSTR &setName)
	{
	ModContextList mcList;
	INodeTab nodes;
	int index = FindSet(setName,selLevel);

	if (index<0 || !ip) return;		
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		SplineSelData *ShapeData = (SplineSelData*)mcList[i]->localData;
		if (!ShapeData) continue;		

		switch (selLevel) {
			case SEL_VERTEX:	
				if (theHold.Holding()) {
					theHold.Put(new DeleteVertSetRestore(index,&ShapeData->NvselSet));
					}
				ShapeData->NvselSet.DeleteSet(index);
				break;

			case SEL_SEGMENT:
				if (theHold.Holding()) {
					theHold.Put(new DeleteSegSetRestore(index,&ShapeData->NsegselSet));
					}
				ShapeData->NsegselSet.DeleteSet(index);
				break;

			case SEL_SPLINE:
				if (theHold.Holding()) {
					theHold.Put(new DeletePolySetRestore(index,&ShapeData->NsplselSet));
					}
				ShapeData->NsplselSet.DeleteSet(index);
				break;
			}		
		}
	
	if (theHold.Holding()) {
		theHold.Put(new DeleteSetNameRestore(index,&namedSel[selLevel-1],this));
		}			
	RemoveSet(setName,selLevel);
	ip->ClearCurNamedSelSet();
	nodes.DisposeTemporary();
	}

void SplineSelMod::SetupNamedSelDropDown()
	{	
	if (selLevel != SEL_OBJECT) {
		ip->ClearSubObjectNamedSelSets();
		for (int i=0; i<namedSel[selLevel-1].Count(); i++) {
			ip->AppendSubObjectNamedSelSet(*namedSel[selLevel-1][i]);
			}
		}	
	}

int SplineSelMod::NumNamedSelSets()
	{
	return namedSel[selLevel-1].Count();
	}

TSTR SplineSelMod::GetNamedSelSetName(int i)
	{
	return *namedSel[selLevel-1][i];
	}

void SplineSelMod::SetNamedSelSetName(int i,TSTR &newName)
{	if (theHold.Holding())
		theHold.Put(new SetNameRestore(i,&namedSel[selLevel-1],this));
	*namedSel[selLevel-1][i] = newName;
}

void SplineSelMod::NewSetByOperator(TSTR &newName,Tab<int> &sets,int op)
{	ModContextList mcList;
	INodeTab nodes;	
	int poly;
	
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		SplineSelData *ShapeData = (SplineSelData*)mcList[i]->localData;
		if (!ShapeData) continue;

	switch(selLevel) {
		case SEL_VERTEX: {
			NVertSelSetList	*vselList= &ShapeData->NvselSet;
			ShapeVSel bits = (*vselList)[sets[0]];
			for(poly = 0; poly < bits.polys; ++poly) {
				for (i=1; i<sets.Count(); i++) {
					ShapeVSel bit2 = (*vselList)[sets[i]];
					switch (op) {
						case NEWSET_MERGE:
							bits[poly] |= bit2[poly];
							break;

						case NEWSET_INTERSECTION:
							bits[poly] &= bit2[poly];
							break;

						case NEWSET_SUBTRACT:
							bits[poly] &= ~(bit2[poly]);
							break;
						}
					}
				}
			ShapeData->NvselSet.AppendSet(bits);
			if (theHold.Holding())
				theHold.Put(new AppendVertSetRestore(&ShapeData->NvselSet));
			}
			break;
		case SEL_SEGMENT: {
			NSegSelSetList sselSet= ShapeData->NsegselSet;
			ShapeSSel bits = *sselSet.sets[sets[0]];
			for(poly = 0; poly < bits.polys; ++poly) {
				for (i=1; i<sets.Count(); i++) {
					ShapeSSel &bit2 = *sselSet.sets[sets[i]];
					switch (op) {
						case NEWSET_MERGE:
							bits[poly] |= bit2[poly];
							break;

						case NEWSET_INTERSECTION:
							bits[poly] &= bit2[poly];
							break;

						case NEWSET_SUBTRACT:
							bits[poly] &= ~(bit2[poly]);
							break;
						}
					}
				}
			ShapeData->NsegselSet.AppendSet(bits);
			if (theHold.Holding())
				theHold.Put(new AppendSegSetRestore(&ShapeData->NsegselSet));
			}
			break;
		case SEL_SPLINE: {
			NPolySelSetList pselSet= ShapeData->NsplselSet;
			ShapePSel bits = *pselSet.sets[sets[0]];
			for (i=1; i<sets.Count(); i++) {
				ShapePSel &bit2 = *pselSet.sets[sets[i]];
				switch (op) {
					case NEWSET_MERGE:
						bits.sel |= bit2.sel;
						break;

					case NEWSET_INTERSECTION:
						bits.sel &= bit2.sel;
						break;

					case NEWSET_SUBTRACT:
						bits.sel &= ~(bit2.sel);
						break;
					}
				}
			ShapeData->NsplselSet.AppendSet(bits);
			if (theHold.Holding())
				theHold.Put(new AppendPolySetRestore(&ShapeData->NsplselSet));
			}
			break;
		}
	}
	AddSet(newName,selLevel);
	if (theHold.Holding()) {
		theHold.Put(new NAppendSetNameRestore(this,&namedSel[selLevel-1]));
		}
}

void SplineSelMod::NSCopy()
	{
	int index = SelectNamedSet();
	if (index>=0) {		
		ModContextList mcList;
		INodeTab nodes;			
		
		// Enable the paste button
		ICustButton *but;
		ip->GetModContexts(mcList,nodes);
		for (int i = 0; i < mcList.Count(); i++) {
			SplineSelData *ShapeData = (SplineSelData*)mcList[i]->localData;
			if (!ShapeData) continue;

			switch (selLevel) {
				case SEL_VERTEX:
				{ ShapeNamedVertSelClip *clip = new ShapeNamedVertSelClip(*namedSel[selLevel-1][index]);
				  ShapeVSel *sel = new ShapeVSel(ShapeData->NvselSet[index]);
				  clip->sets.Append(1,&sel);
				  SetShapeNamedVertSelClip(clip);
				  but = GetICustButton(GetDlgItem(hParams,IDC_VERT_PASTENS));
				  break;				
				}
				case SEL_SEGMENT:
				{ ShapeNamedSegSelClip *clip = new ShapeNamedSegSelClip(*namedSel[selLevel-1][index]);
				  ShapeSSel *sel = new ShapeSSel(ShapeData->NsegselSet[index]);
				  clip->sets.Append(1,&sel);
				  SetShapeNamedSegSelClip(clip);
				  but = GetICustButton(GetDlgItem(hParams,IDC_SEG_PASTENS));
 				  break;
				}
				case SEL_SPLINE: 
				{ ShapeNamedPolySelClip *clip = new ShapeNamedPolySelClip(*namedSel[selLevel-1][index]);
				  ShapePSel *sel = new ShapePSel(ShapeData->NsplselSet[index]);
				  clip->sets.Append(1,&sel);
				  SetShapeNamedPolySelClip(clip);
				  but = GetICustButton(GetDlgItem(hParams,IDC_SPLINE_PASTENS));
 				  break;
				}		
			}
		but->Enable();
		ReleaseICustButton(but);
		}	
	}
}

void SplineSelMod::NSPaste()
	{
	TSTR name;

	ModContextList mcList;
	INodeTab nodes;		
	
	theHold.Begin();
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		SplineSelData *ShapeData = (SplineSelData*)mcList[i]->localData;
		if (!ShapeData) continue;

		switch (selLevel) {
			case SEL_VERTEX:
			{ ShapeNamedVertSelClip *clip = GetShapeNamedVertSelClip();
			  if (!clip) return;	
			  name = clip->name;
			  if (!GetUniqueSetName(name)) return;
			  ShapeData->NvselSet.AppendSet(*clip->sets[0]);	
			  theHold.Put(new AppendVertSetRestore(&ShapeData->NvselSet));
			}
			break;				
			case SEL_SEGMENT:
			{ ShapeNamedSegSelClip *clip = GetShapeNamedSegSelClip();
			  if (!clip) return;
			  name = clip->name;
			  if (!GetUniqueSetName(name)) return;
			  ShapeData->NsegselSet.AppendSet(*clip->sets[0]);	
			  theHold.Put(new AppendSegSetRestore(&ShapeData->NsegselSet));
			}
			break;			
			case SEL_SPLINE:
			{ ShapeNamedPolySelClip *clip = GetShapeNamedPolySelClip();
			  if (!clip) return;
			  name = clip->name;
			  if (!GetUniqueSetName(name)) return;
			  ShapeData->NsplselSet.AppendSet(*clip->sets[0]);	
			  theHold.Put(new AppendPolySetRestore(&ShapeData->NsplselSet));
			}
			break;			
			}
	}
	AddSet(name,selLevel);	
	theHold.Put(new NAppendSetNameRestore(this,&namedSel[selLevel-1]));	
	ActivateSubSelSet(name);
	ip->SetCurNamedSelSet(name);
	theHold.Accept(_T("Paste Named Selection"));
	SetupNamedSelDropDown();	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\app.cpp ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 19, 1998
 App.cpp - Main Application and Search Methods
 ***************************************************************************/
#include "pch.h"
#include "app.h"
#include "resource.h"

LRESULT	CALLBACK AppWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT	CALLBACK StaticWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK statPanDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam );
BOOL BrowseFolder(HINSTANCE hInstance, HWND hParent);

static char* useFolder;

App::App(HINSTANCE hInst, int cshow)
{
	hInstance = hInst;
	cmdShow = cshow;
	hPropDialog = NULL;
	InitializeCriticalSection(&cs);
	bSearchActive = FALSE;
	hThreadExitRequest = CreateEvent(NULL, TRUE, FALSE, NULL);
}

App::~App()
	{
	DeleteCriticalSection(&cs);
	CloseHandle(hThreadExitRequest);
	if (hFont) DeleteObject(hFont);
	}

BOOL App::Init()
	{
	WNDCLASSEX	wc;

	wc.cbSize		 = sizeof(WNDCLASSEX);
	wc.style         = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc   = AppWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInstance;
//	wc.hIconSm		 = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MAINWND));
//	wc.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MAINWND));
	wc.hIconSm		 = NULL;
	wc.hIcon         = NULL;
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = NULL; //(HBRUSH)(COLOR_MENU+1);
	wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MAINMENU);
	wc.lpszClassName = THECLASSNAME;

	if (!RegisterClassEx(&wc))
		return FALSE;

	wc.cbSize		 = sizeof(WNDCLASSEX);
	wc.style         = 0;
	wc.lpfnWndProc   = StaticWndProc;
	wc.cbClsExtra    = 0;
	wc.cbWndExtra    = 0;
	wc.hInstance     = hInstance;
	wc.hIconSm		 = NULL;
	wc.hIcon         = NULL;
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_MENU+1);
	wc.lpszMenuName  = NULL;
	wc.lpszClassName = "CJSTATIC";

	if (!RegisterClassEx(&wc))
		return FALSE;

	LOGFONT lf;
	GetObject(GetStockObject(SYSTEM_FONT), sizeof(lf), &lf);
	lf.lfWeight = 400;
	lf.lfHeight = 14;
	lf.lfWidth = 0;
	strcpy((char *)&lf.lfFaceName, GetString(IDS_APP_FONT)); // mjm - 2.10.99 - for localization
//	strcpy((char *)&lf.lfFaceName, "MS Sans Serif");
	hFont = CreateFontIndirect(&lf);

	GetRegSettings();

	return TRUE;
	}

void App::GetRegSettings()
	{
	HKEY	hKey;

	regsettings.x = CW_USEDEFAULT;
	regsettings.y = CW_USEDEFAULT;
	regsettings.w = 500;
	regsettings.h = 500;
	regsettings.filespec = 0;
	regsettings.propdlgx = 100;
	regsettings.propdlgy = 100;

	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS) {
		DWORD nSize = sizeof(DWORD);
		RegQueryValueEx(hKey, "InitX", 0, 0, (LPBYTE)&regsettings.x, &nSize);
		nSize = sizeof(DWORD);
		RegQueryValueEx(hKey, "InitY", 0, 0, (LPBYTE)&regsettings.y, &nSize);
		nSize = sizeof(DWORD);
		RegQueryValueEx(hKey, "InitW", 0, 0, (LPBYTE)&regsettings.w, &nSize);
		nSize = sizeof(DWORD);
		RegQueryValueEx(hKey, "InitH", 0, 0, (LPBYTE)&regsettings.h, &nSize);
		nSize = sizeof(DWORD);
		RegQueryValueEx(hKey, "InitFileSpec", 0, 0, (LPBYTE)&regsettings.filespec, &nSize);
		nSize = sizeof(DWORD);
		RegQueryValueEx(hKey, "InitPropDlgX", 0, 0, (LPBYTE)&regsettings.propdlgx, &nSize);
		nSize = sizeof(DWORD);
		RegQueryValueEx(hKey, "InitPropDlgY", 0, 0, (LPBYTE)&regsettings.propdlgy, &nSize);
		}
	}

void App::SetRegSettings()
	{
	HKEY	hKey;
	DWORD	disp;
	if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGISTRY_KEY, 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &disp) == ERROR_SUCCESS) {
		RegSetValueEx(hKey, "InitX", 0, REG_DWORD, (LPBYTE)&regsettings.x, sizeof(DWORD));
		RegSetValueEx(hKey, "InitY", 0, REG_DWORD, (LPBYTE)&regsettings.y, sizeof(DWORD));
		RegSetValueEx(hKey, "InitW", 0, REG_DWORD, (LPBYTE)&regsettings.w, sizeof(DWORD));
		RegSetValueEx(hKey, "InitH", 0, REG_DWORD, (LPBYTE)&regsettings.h, sizeof(DWORD));
		RegSetValueEx(hKey, "InitFileSpec", 0, REG_DWORD, (LPBYTE)&regsettings.filespec, sizeof(DWORD));
		RegSetValueEx(hKey, "InitPropDlgX", 0, REG_DWORD, (LPBYTE)&regsettings.propdlgx, sizeof(DWORD));
		RegSetValueEx(hKey, "InitPropDlgY", 0, REG_DWORD, (LPBYTE)&regsettings.propdlgy, sizeof(DWORD));
		}
	}


void App::PostInit()
	{
	SendMessage(hFileSpec, CB_ADDSTRING, 0, (LPARAM)"*.max");
	SendMessage(hFileSpec, CB_SETCURSEL, regsettings.filespec, 0);
	PostMessage(hFileSpec, CB_SETEDITSEL, 0, MAKELPARAM(-1, 0));

	int idx;
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_ALL));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)ALL_PROPERTIES);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_TITLE));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)TITLE_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_SUBJECT));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)SUBJECT_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_AUTHOR));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)AUTHOR_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_MANAGER));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)MANAGER_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_COMPANY));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)COMPANY_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_CATEGORY));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)CATEGORY_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_KEYWORDS));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)KEYWORDS_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_COMMENTS));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)COMMENTS_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_EXTDEP));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)EXT_DEPEND_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_PLUGINS));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)PLUGINS_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_OBJECTS));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)OBJECTS_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_MATERIALS));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)MATERIALS_PROP);
	idx = SendMessage(hProperty, CB_ADDSTRING, 0, (LPARAM)GetString(IDS_PROP_CUSTOM));
		SendMessage(hProperty, CB_SETITEMDATA, idx, (LPARAM)USER_PROP);
	
	SendMessage(hProperty, CB_SETCURSEL, 0, 0);

	SendMessage(hCheckSubdirs, BM_SETCHECK, BST_CHECKED, 0);

	SetFocus(hSearchText);
	DoStatusDirectory();
	}

void App::CreateControls()
	{
	hControlPane = CreateDialogParam(hInstance,
				MAKEINTRESOURCE(IDD_PANEL),
				hMainWnd,
				statPanDlgProc,
				(LPARAM)this);

	hTxtSearch		= GetDlgItem(hControlPane, IDC_TXTSEARCH);
	hTxtFileSpec	= GetDlgItem(hControlPane, IDC_TXTFILESPEC);
	hTxtProperty	= GetDlgItem(hControlPane, IDC_TXTPROPERTY);
	hFindButton		= GetDlgItem(hControlPane, IDC_START);
	hCDButton		= GetDlgItem(hControlPane, IDC_BROWSE);
	hFileSpec		= GetDlgItem(hControlPane, IDC_FILESPEC);
	hProperty		= GetDlgItem(hControlPane, IDC_PROPERTY);
	hSearchText		= GetDlgItem(hControlPane, IDC_SEARCHEDIT);
	hCheckSubdirs	= GetDlgItem(hControlPane, IDC_SUBDIRS);
	hStatusPanel	= GetDlgItem(hControlPane, IDC_STATUSPANEL);
	hDlgFrame		= GetDlgItem(hControlPane, IDC_BORDER);

	hListBox = CreateWindow("LISTBOX",
				 "",
				 WS_VISIBLE | WS_CHILD | WS_BORDER | LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP | LBS_NOTIFY,
				 0, 0,
				 0, 0,
				 hMainWnd,
				 (HMENU)IDC_LISTBOX,
				 hInstance,
				 NULL);

	SendMessage(hListBox, WM_SETFONT, (WPARAM)GetAppFont(), 0);

	}

void App::Move()
	{
	RECT	wr;
	GetWindowRect(hMainWnd, &wr);

	regsettings.x = wr.left;
	regsettings.y = wr.top;
	regsettings.w = wr.right-wr.left;
	regsettings.h = wr.bottom-wr.top;
	}

void App::Resize(int flags, int width, int height)
	{
	RECT	r, wr;
	GetClientRect(hMainWnd, &r);
	GetWindowRect(hMainWnd, &wr);

	regsettings.x = wr.left;
	regsettings.y = wr.top;
	regsettings.w = wr.right-wr.left;
	regsettings.h = wr.bottom-wr.top;

	int		editWidth = (r.right)/3;


	int		btnHeight = 20;
	int		editHeight = 23;
	int		txtHeight = 15;
	int		statusHeight = 16;

	int		toolbarHeight = 91;

	int		startFindBtn = r.left+5;
	int		widthFindBtn = 70;
	int		startCDBtn = startFindBtn+widthFindBtn+15;
	int		widthCDBtn = 70;
	int		startSubdir = startCDBtn+widthCDBtn+15;

	MoveWindow(hControlPane, r.left, 0, r.right, toolbarHeight, TRUE);
	MoveWindow(hDlgFrame, r.left, 0, r.right, toolbarHeight, TRUE);

	MoveWindow(hTxtSearch, r.left+5, 5, editWidth-10, txtHeight, TRUE);
	MoveWindow(hTxtFileSpec, editWidth, 5, editWidth-10, txtHeight, TRUE);
	MoveWindow(hTxtProperty, 2*editWidth, 5, editWidth-10, txtHeight, TRUE);

	MoveWindow(hSearchText, r.left+5, txtHeight+4, editWidth-10, editHeight-1, TRUE);
	MoveWindow(hFileSpec, editWidth, txtHeight+5, editWidth-10, editHeight+200, TRUE);
	MoveWindow(hProperty, 2*editWidth, txtHeight+5, editWidth-10, editHeight+200, TRUE);


	MoveWindow(hFindButton, startFindBtn, editHeight+txtHeight+10, widthFindBtn, btnHeight, TRUE);
	MoveWindow(hCDButton, startCDBtn, editHeight+txtHeight+10, widthCDBtn, btnHeight, TRUE);
	MoveWindow(hCheckSubdirs, startSubdir, editHeight+txtHeight+10, 120, 18, TRUE);
	
	MoveWindow(hStatusPanel, r.left+5, toolbarHeight-statusHeight-4, r.right-10, statusHeight, TRUE);

	MoveWindow(hListBox, r.left, r.top+toolbarHeight, r.right, r.bottom-toolbarHeight, TRUE);
	}

void App::Reset()
	{
	SendMessage(hListBox, LB_RESETCONTENT, 0, 0);
	}

void App::AppIsIdle()
	{
	WaitMessage();
	}

HINSTANCE App::GetInstance()
	{
	return hInstance;
	}

void App::SetHWnd(HWND wnd)
	{
	hMainWnd = wnd;
	}

HWND App::GetHWnd()
	{
	return hMainWnd;
	}

HDC App::GetDC()
	{
	return hMainWndDC;
	}

void App::SetDC(HDC dc)
	{
	hMainWndDC = dc;
	}

void App::SetHMenu(HMENU menu)
	{
	hMenu = menu;
	}

HMENU App::GetHMenu()
	{
	return hMenu;
	}

HFONT App::GetAppFont()
	{
	return hFont;
	}


void App::DoCD()
	{
	BROWSEINFO	browseInfo;
	char		dir[_MAX_PATH];
	int			image = 0;

	browseInfo.hwndOwner = GetHWnd();
    browseInfo.pidlRoot = NULL;
    browseInfo.pszDisplayName = dir;
    browseInfo.lpszTitle = GetString(IDS_SELFOLDERTITLE);
    browseInfo.ulFlags = 0;
    browseInfo.lpfn = NULL;
    browseInfo.lParam = NULL;
    browseInfo.iImage = image;

	ITEMIDLIST* item = SHBrowseForFolder(&browseInfo);
	if (item) {
		SHGetPathFromIDList(item, dir);
		if (strcmp(dir, "")) {
			SetCurrentDirectory(dir);
			DoStatusDirectory();
			}
		}
	}


// From MSJ, August 94, p. 70
BOOL CenterWindow(HWND hWndChild, HWND hWndParent)
{
	RECT	rChild, rParent;
	int		wChild, hChild, wParent, hParent;
	int		wScreen, hScreen, xNew, yNew;
	HDC		hdc = GetDC(hWndChild);

	// get the display limits
	wScreen = GetDeviceCaps(hdc, HORZRES);
	hScreen = GetDeviceCaps(hdc, VERTRES);

	// Get the Height and Width of the parent window
	if(hWndParent)
		GetWindowRect(hWndParent, &rParent);
	else {
		rParent.left = 0;
		rParent.right = wScreen;
		rParent.top = 0;
		rParent.bottom = hScreen;
	}
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// get the Height and Width of the child window
	GetWindowRect(hWndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) / 2);
	if(xNew < 0)
		xNew = 0;
	else if ((xNew + wChild) > wScreen)
		xNew = wScreen - wChild;

	// calculate new Y position, then adjust for screen
	yNew = rParent.top + ((hParent - hChild) / 2);
	if(yNew < 0)
		yNew = 0;
	else if((yNew + hChild) > hScreen)
		yNew = hScreen - hChild;

	ReleaseDC(hWndChild, hdc);
	// set it, and return
	return SetWindowPos(hWndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

void App::DoStatusDirectory()
	{
	char dir[_MAX_PATH];
	char status[_MAX_PATH+32];

	GetCurrentDirectory(_MAX_PATH, dir);
	strcpy(status, GetString(IDS_CURDIR));
	strcat(status, dir);
	SendMessage(hStatusPanel, WM_SETTEXT, 0, (LPARAM)status);
	}


void App::EnableUI(BOOL status)
	{
	EnableWindow(hCDButton, status);
	EnableWindow(hSearchText, status);
	EnableWindow(hFileSpec, status);
	EnableWindow(hProperty, status);
	EnableWindow(hCheckSubdirs, status);

	SendMessage(hFindButton, WM_SETTEXT, 0, (LPARAM)(status ? GetString(IDS_BTNSTART) : GetString(IDS_BTNCANCEL)));
	}


BOOL App::ScanDirectory(char* path, char* filespec, HWND hList)
	{
	WIN32_FIND_DATA	findData;
	char*	dirSpec = "*";
	char	buf[_MAX_PATH];
	char	filespecbuf[_MAX_PATH];
	char	curDir[_MAX_PATH+32];
	BOOL	bQuitRequest = FALSE;
	HANDLE	hFind;
	char*	pathPtr;
	char*	pathToken;


	GetCurrentDirectory(_MAX_PATH, curDir);

	strcpy(buf, GetString(IDS_SEARCHDIR));
	strcat(buf, path);

	SendMessage(hStatusPanel, WM_SETTEXT, 0, (LPARAM)buf);

	strcpy(filespecbuf, filespec);
	pathPtr = filespecbuf;

	while ((pathToken = strtok(pathPtr, ";, "))) {
		pathPtr = NULL;

		strcpy(buf, path);
		if (path[strlen(path)-1] != '\\')
			strcat(buf, "\\");

		strcat(buf, pathToken);

		hFind = FindFirstFile(buf, &findData);
		if (hFind != INVALID_HANDLE_VALUE) {
			do {
				if (WaitForSingleObject(hThreadExitRequest, 0) == WAIT_OBJECT_0) {
					bQuitRequest = TRUE;
					break;
					}
				if (!(findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
					!(findData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) &&
					!(findData.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) &&
					!(findData.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY)) {

					strcpy(buf, path);
					if (path[strlen(path)-1] != '\\')
						strcat(buf, "\\");
					strcat(buf, findData.cFileName);
					if (Qualify(buf)) {
						SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)buf);
						}
					}
				}while (FindNextFile(hFind, &findData));
			}

		FindClose(hFind);

		if (bQuitRequest) {
			return FALSE;
			}
		}

	if (SendMessage(hCheckSubdirs, BM_GETCHECK, 0, 0) == BST_CHECKED) {
		strcpy(buf, path);
		if (path[strlen(path)-1] != '\\')
			strcat(buf, "\\");

		strcat(buf, dirSpec);

		hFind = FindFirstFile(buf, &findData);
		if (hFind == INVALID_HANDLE_VALUE) return TRUE;
		do {
			if (WaitForSingleObject(hThreadExitRequest, 0) == WAIT_OBJECT_0) {
				bQuitRequest = TRUE;
				break;
				}

			if (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				if (strcmp(findData.cFileName, ".") &&
					strcmp(findData.cFileName, "..")) {
					strcpy(buf, path);
					if (path[strlen(path)-1] != '\\')
						strcat(buf, "\\");
					strcat(buf, findData.cFileName);
					if (!ScanDirectory(buf, filespec, hList)) {
						bQuitRequest = TRUE;
						break;
						}
					}
				}
			}while (!bQuitRequest && FindNextFile(hFind, &findData));
		FindClose(hFind);
		}

	return !bQuitRequest;
	}

DWORD WINAPI StartFinder(void* lparg)
	{
	char path[_MAX_PATH];
	char filespec[_MAX_PATH];
	App*	pApp = (App*)lparg;

	pApp->bSearchActive = TRUE;

	pApp->EnableUI(FALSE);
	pApp->Reset();
	GetCurrentDirectory(_MAX_PATH, path);
	SendMessage(pApp->GetFileSpecDropDown(), WM_GETTEXT, _MAX_PATH, (LPARAM)filespec);

	pApp->ScanDirectory(path, filespec, pApp->GetMainListBox());

	pApp->DoStatusDirectory();
	pApp->EnableUI(TRUE);
	pApp->bSearchActive = FALSE;
	return 0;
	}

void App::DoFind()
	{
	if (!bSearchActive) {
		ResetEvent(hThreadExitRequest);
		CreateThread(NULL, 0, StartFinder, this, 0, &wWorkerThread);
		}
	else {
		SetEvent(hThreadExitRequest);
		}
	}

void App::ViewFile()
	{
	ShowProperties();
	}

BOOL App::Qualify(char* filename)
	{
	LPSTORAGE				pStorage = NULL;
	IPropertySetStorage*	pPropertySetStorage = NULL;
	IPropertyStorage*		pSummaryInfoStorage = NULL;
	IPropertyStorage*		pDocumentSummaryInfoStorage = NULL;
	IPropertyStorage*		pUserDefinedPropertyStorage = NULL;
	wchar_t					wfilename[_MAX_PATH];
	char					szSearchString[_MAX_PATH];

	int						propFlags = 0;

	int idx = SendMessage(hProperty, CB_GETCURSEL, 0, 0);
	if (idx == CB_ERR) {
		return FALSE;
		}

	propFlags = SendMessage(hProperty, CB_GETITEMDATA, idx, 0);

	SendMessage(hSearchText, WM_GETTEXT, _MAX_PATH, (LPARAM)szSearchString);

	if ((propFlags == ALL_PROPERTIES) && (strcmp(szSearchString, "") == 0)) {
		// Qualify all files if we don't search for anything
		return TRUE;
		}

	MultiByteToWideChar(CP_ACP, 0, filename, -1, wfilename, _MAX_PATH);
	HRESULT	res = StgOpenStorage(wfilename, (LPSTORAGE)0, STGM_DIRECT|STGM_READ|STGM_SHARE_EXCLUSIVE,	NULL,0,&pStorage);
	if (res!=S_OK) {
		return FALSE;
		}


	// Get the Storage interface
	if (S_OK != pStorage->QueryInterface(IID_IPropertySetStorage, (void**)&pPropertySetStorage)) {
		pStorage->Release();
		return FALSE;
		}

	// Get the SummaryInfo property set interface
	if (propFlags & PROPSET_SUMINFO) {
		if (S_OK == pPropertySetStorage->Open(FMTID_SummaryInformation, STGM_READ|STGM_SHARE_EXCLUSIVE, &pSummaryInfoStorage)) {
			BOOL bFound = FALSE;

			PROPSPEC	PropSpec[5];
			PROPVARIANT	PropVar[5];

			PropSpec[0].ulKind = PRSPEC_PROPID;
			PropSpec[0].propid = PID_TITLE;

			PropSpec[1].ulKind = PRSPEC_PROPID;
			PropSpec[1].propid = PID_SUBJECT;

			PropSpec[2].ulKind = PRSPEC_PROPID;
			PropSpec[2].propid = PID_AUTHOR;

			PropSpec[3].ulKind = PRSPEC_PROPID;
			PropSpec[3].propid = PID_KEYWORDS;

			PropSpec[4].ulKind = PRSPEC_PROPID;
			PropSpec[4].propid = PID_COMMENTS;

			HRESULT hr = pSummaryInfoStorage->ReadMultiple(5, PropSpec, PropVar);
			if (S_OK == hr) {
				if ((propFlags & TITLE_PROP) && (PropVar[0].vt == VT_LPSTR)) {
					if (Compare(PropVar[0].pszVal, szSearchString)) {
						bFound = TRUE;
						}
					}

				if (!bFound && (propFlags & SUBJECT_PROP) && (PropVar[1].vt == VT_LPSTR)) {
					if (Compare(PropVar[1].pszVal, szSearchString)) {
						bFound = TRUE;
						}
					}

				if (!bFound && (propFlags & AUTHOR_PROP) && (PropVar[2].vt == VT_LPSTR)) {
					if (Compare(PropVar[2].pszVal, szSearchString)) {
						bFound = TRUE;
						}
					}

				if (!bFound && (propFlags & KEYWORDS_PROP) && (PropVar[3].vt == VT_LPSTR)) {
					if (Compare(PropVar[3].pszVal, szSearchString)) {
						bFound = TRUE;
						}
					}

				if (!bFound && (propFlags & COMMENTS_PROP) && (PropVar[4].vt == VT_LPSTR)) {
					if (Compare(PropVar[4].pszVal, szSearchString)) {
						bFound = TRUE;
						}
					}
				}

			FreePropVariantArray(5, PropVar);

			pSummaryInfoStorage->Release();
			if (bFound) {

				pPropertySetStorage->Release();
				pStorage->Release();
				return TRUE;
				}
			}
		}

	// Get the DocumentSummaryInfo property set interface
	if (propFlags & PROPSET_DOCSUMINFO) {
		if (S_OK == pPropertySetStorage->Open(FMTID_DocSummaryInformation, STGM_READ|STGM_SHARE_EXCLUSIVE, &pDocumentSummaryInfoStorage)) {
			BOOL bFound = FALSE;

			PROPSPEC	PropSpec[5];
			PROPVARIANT	PropVar[5];

			PropSpec[0].ulKind = PRSPEC_PROPID;
			PropSpec[0].propid = PID_MANAGER;

			PropSpec[1].ulKind = PRSPEC_PROPID;
			PropSpec[1].propid = PID_COMPANY;

			PropSpec[2].ulKind = PRSPEC_PROPID;
			PropSpec[2].propid = PID_CATEGORY;

			PropSpec[3].ulKind = PRSPEC_PROPID;
			PropSpec[3].propid = PID_HEADINGPAIR;

			PropSpec[4].ulKind = PRSPEC_PROPID;
			PropSpec[4].propid = PID_DOCPARTS;

			HRESULT hr = pDocumentSummaryInfoStorage->ReadMultiple(5, PropSpec, PropVar);
			if (S_OK == hr) {
				if ((propFlags & MANAGER_PROP) && (PropVar[0].vt == VT_LPSTR)) {
					if (Compare(PropVar[0].pszVal, szSearchString)) {
						bFound = TRUE;
						}
					}

				if (!bFound && (propFlags & COMPANY_PROP) && (PropVar[1].vt == VT_LPSTR)) {
					if (Compare(PropVar[1].pszVal, szSearchString)) {
						bFound = TRUE;
						}
					}

				if (!bFound && (propFlags & CATEGORY_PROP) && (PropVar[2].vt == VT_LPSTR)) {
					if (Compare(PropVar[2].pszVal, szSearchString)) {
						bFound = TRUE;
						}
					}

				// Scan through document contents
				if (!bFound && (PropVar[3].vt == (VT_VARIANT | VT_VECTOR)) && (PropVar[4].vt == (VT_LPSTR | VT_VECTOR))) {
					CAPROPVARIANT*	pHeading = &PropVar[3].capropvar;
					CALPSTR*		pDocPart = &PropVar[4].calpstr;

					// Headings:
					// =========
					// 0  - General
					// 2  - Mesh Totals
					// 4  - Scene Totals
					// 6  - External Dependencies
					// 8  - Objects
					// 10 - Materials
					// 12 - Plug-Ins
					int nDocPart = 0;
					for (UINT i=0; i<pHeading->cElems; i+=2) {
						BOOL bCompare = FALSE;

						if ((i==6) && (propFlags & EXT_DEPEND_PROP)) bCompare = TRUE;
						if ((i==8) && (propFlags & OBJECTS_PROP)) bCompare = TRUE;
						if ((i==10) && (propFlags & MATERIALS_PROP)) bCompare = TRUE;
						if ((i==12) && (propFlags & PLUGINS_PROP)) bCompare = TRUE;

						for (int j=0; j<pHeading->pElems[i+1].lVal; j++) {
							if (!bFound && bCompare) {
								if (Compare(pDocPart->pElems[nDocPart], szSearchString)) {
									bFound = TRUE;
									}
								}
							nDocPart++;
							}
						}
					}
				}

			FreePropVariantArray(5, PropVar);

			pDocumentSummaryInfoStorage->Release();
			if (bFound) {
				pPropertySetStorage->Release();
				pStorage->Release();
				return TRUE;
				}
			}
		}

	// Get the User Defined property set interface
	if (propFlags & PROPSET_USERDEF) {
		if (S_OK == pPropertySetStorage->Open(FMTID_UserDefinedProperties, STGM_READ|STGM_SHARE_EXCLUSIVE, &pUserDefinedPropertyStorage)) {
			BOOL	bFound = FALSE;
			int		numUserProps = 0;

			// First we need to count the properties
			IEnumSTATPROPSTG*	pIPropertyEnum;
			if (S_OK == pUserDefinedPropertyStorage->Enum(&pIPropertyEnum)) {
				STATPROPSTG property;
				while (pIPropertyEnum->Next(1, &property, NULL) == S_OK) {
					if (property.lpwstrName) {
						CoTaskMemFree(property.lpwstrName);
						property.lpwstrName = NULL;
						numUserProps++;
						}
					}

				PROPSPEC* pPropSpec = new PROPSPEC[numUserProps];
				PROPVARIANT* pPropVar = new PROPVARIANT[numUserProps];

				ZeroMemory(pPropVar, numUserProps*sizeof(PROPVARIANT));
				ZeroMemory(pPropSpec, numUserProps*sizeof(PROPSPEC));

				pIPropertyEnum->Reset();
				int idx = 0;
				while (pIPropertyEnum->Next(1, &property, NULL) == S_OK) {
					if (property.lpwstrName) {
						pPropSpec[idx].ulKind = PRSPEC_LPWSTR;
						pPropSpec[idx].lpwstr = (LPWSTR)CoTaskMemAlloc(sizeof(wchar_t)*(wcslen(property.lpwstrName)+1));
						wcscpy(pPropSpec[idx].lpwstr, property.lpwstrName);
						idx++;
						CoTaskMemFree(property.lpwstrName);
						property.lpwstrName = NULL;
						}
					}
				pIPropertyEnum->Release();

				HRESULT hr = pUserDefinedPropertyStorage->ReadMultiple(idx, pPropSpec, pPropVar);
				if (S_OK == hr) {
					for (int i=0; i<idx; i++) {
						if (pPropVar[i].vt == VT_LPSTR) {
							if (Compare(pPropVar[i].pszVal, szSearchString)) {
								bFound = TRUE;
								break;
								}
							}
						else if (pPropVar[i].vt == VT_LPWSTR) {
							int nSize = wcslen(pPropVar[i].pwszVal)+1;
							char* tempVal = (char*)malloc(nSize);
							if (tempVal) {
								WideCharToMultiByte(CP_ACP, 0, pPropVar[i].pwszVal, -1, tempVal, nSize, NULL, NULL);
								if (Compare(tempVal, szSearchString)) {
									bFound = TRUE;
									free(tempVal);
									break;
									}
								free(tempVal);
								}
							}
						}
					}

				for (int i=0; i<idx; i++) {
					CoTaskMemFree(pPropSpec[i].lpwstr);
					}

				FreePropVariantArray(numUserProps, pPropVar);

				delete [] pPropSpec;
				delete [] pPropVar;
				}

			pUserDefinedPropertyStorage->Release();
			if (bFound) {
				pPropertySetStorage->Release();
				pStorage->Release();
				return TRUE;
				}
			}
		}

	pPropertySetStorage->Release();
	pStorage->Release();

	return FALSE;
	}


BOOL App::Compare(char* s1, char* s2)
	{
	if (strcmp(s1, "")==0) return FALSE;

	char* lcs1 = (char*)malloc(strlen(s1)+1);
	char* lcs2 = (char*)malloc(strlen(s2)+1);

	if (!lcs1 && !lcs2) return FALSE;

	strcpy(lcs1, s1);
	strcpy(lcs2, s2);

	strlwr(lcs1);
	strlwr(lcs2);

	BOOL bFound = strstr(lcs1, lcs2) != NULL;

	free(lcs1);
	free(lcs2);

	if (bFound)
		return TRUE;

	return FALSE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\app.h ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 19, 1998
 App.h - Main Application header
 ***************************************************************************/
#define THECLASSNAME	"CJMAXFINDER_WNDCLASS"

#define REGISTRY_KEY "SOFTWARE\\Autodesk\\3D Studio MAX\\3.0\\MAX Finder"

#define IDC_LISTBOX				0x1000
//#define IDC_FILESPEC			0x1010

#define PROPSET_SUMINFO			0x000000ff
#define PROPSET_DOCSUMINFO		0x0000ff00
#define PROPSET_USERDEF			0x00ff0000

#define ALL_PROPERTIES			0xffffffff	// All props
#define TITLE_PROP				0x00000001	// Summary Info
#define SUBJECT_PROP			0x00000002	// Summary Info
#define AUTHOR_PROP				0x00000004	// Summary Info
#define KEYWORDS_PROP			0x00000008	// Summary Info
#define COMMENTS_PROP			0x00000010	// Summary Info
#define MANAGER_PROP			0x00000100	// Document Summary Info
#define COMPANY_PROP			0x00000200	// Document Summary Info
#define CATEGORY_PROP			0x00000400	// Document Summary Info
#define EXT_DEPEND_PROP			0x00000800	// Document Summary Info
#define PLUGINS_PROP			0x00001000	// Document Summary Info
#define OBJECTS_PROP			0x00002000	// Document Summary Info
#define MATERIALS_PROP			0x00004000	// Document Summary Info
#define USER_PROP				0x00010000	// User Defined Properties

#define PID_TITLE				0x00000002
#define PID_SUBJECT				0x00000003
#define PID_AUTHOR				0x00000004
#define PID_KEYWORDS			0x00000005
#define PID_COMMENTS			0x00000006

#define PID_MANAGER				0x0000000E
#define PID_COMPANY				0x0000000F
#define PID_CATEGORY			0x00000002
#define PID_HEADINGPAIR			0x0000000C
#define PID_DOCPARTS			0x0000000D

BOOL	CenterWindow(HWND hWndChild, HWND hWndParent);

class RegSettings {
	public:
		int x;
		int y;
		int w;
		int h;
		int filespec;
		int propdlgx;
		int propdlgy;
	};

class App {
	public:

	// Initialization
	App(HINSTANCE hInst, int cshow);
	~App();

	void		CreateControls();
	BOOL		Init();
	void		PostInit();
	void		Reset();
	void		Resize(int flags, int width, int height);
	void		Move();

	void		DoFind();
	void		DoCD();
	void		ViewFile();
	BOOL		Qualify(char* filename);
	BOOL		Compare(char* s1, char* s2);

	void		ShowProperties();
	void		GetProperties();

	// Interface
	HINSTANCE	GetInstance();
	void		SetHWnd(HWND wnd);
	HWND		GetHWnd();
	void		SetDC(HDC dc);
	HDC			GetDC();
	void		SetHMenu(HMENU menu);
	HMENU		GetHMenu();
	HFONT		GetAppFont();
	HWND		GetFileSpecDropDown() { return hFileSpec; }
	HWND		GetMainListBox() { return hListBox; }
	HWND		GetPanel() { return hControlPane; }

	void		GetRegSettings();
	void		SetRegSettings();

	// Message pump
	void		AppIsIdle();

	// Utilities
	TCHAR*		GetString(int id);
	void		DoAboutBox();
	BOOL		ChooseDir(char *title, char *dir);
	void		DoStatusDirectory();
	BOOL		ScanDirectory(char* path, char* filespec, HWND hList);
	void		EnableUI(BOOL status);

	void		AppIsClosing() { SetEvent(hThreadExitRequest); }

	BOOL		bSearchActive;
	RegSettings	regsettings;
	HWND		hListBox;
	HWND		hPropDialog;

	private:

	// Windows, DC's n' stuff
	HWND		hMainWnd;
	HMENU		hMenu;
	HINSTANCE	hInstance;
	HDC			hMainWndDC;
	HFONT		hFont;

	// Controls
	HWND		hFindButton;
	HWND		hStatusPanel;
	HWND		hCDButton;
	HWND		hSearchText;
	HWND		hFileSpec;
	HWND		hProperty;
	HWND		hControlPane;
	HWND		hCheckSubdirs;
	HWND		hDlgFrame;

	HWND		hTxtSearch;
	HWND		hTxtFileSpec;
	HWND		hTxtProperty;

	CRITICAL_SECTION	cs;
	ULONG		wWorkerThread;
	HANDLE		hThreadExitRequest;

	// Data
	int			cmdShow;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\lattice\spindle.cpp ===
#include "mods2.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "windows.h"

// in mods.cpp
extern HINSTANCE hInstance;

#define BIGFLOAT	float(999999)

static Class_ID SPINDLEOSM_CLASS_ID(0x11d527a5, 0x3a5149a4);

float squareit(float valuein)
{	return (valuein*valuein);
}

class SpindleMod : public SimpleMod {
	public:
		static IParamMap *pmapParam;

		SpindleMod();		
				
		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_EP_SPINDLEMOD); }  
		virtual Class_ID ClassID() { return SPINDLEOSM_CLASS_ID;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next );
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_EP_SPINDLE); }		
		IOResult Load(ILoad *iload);

		// From simple mod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		BOOL GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};


class SpindleDeformer: public Deformer {
	public:
		Matrix3 tm,invtm;
		Box3 bbox;
		TimeValue time;
		float ks1,ks2;
		float kq1,kq2;
		float kbias;
		float kvol;
		float fromQ, toQ;
		int doRegionQ;
		SpindleDeformer();
		SpindleDeformer(
			TimeValue t, ModContext &mc, 
			float  amt, float crv,
			float  amtQ, float crvQ,
			float fromQ, float toQ, int doRegionQ,
			float bias, float vol,
			Matrix3& modmat, Matrix3& modinv);
		void SetAxis(Matrix3 &tmAxis);
		void SetKS(float K1, float K2) { ks1 = K1; ks2 = K2; }
		void SetKQ(float K1, float K2) { kq1 = K1; kq2 = K2; }
		void SetBias(float K1) { kbias = K1;}
		void SetVol(float K1) { kvol = K1;}
		Point3 Map(int i, Point3 p); 
	};

#define SPINDLEWSM_CLASSID	Class_ID(SPINDLEOSM_CLASS_ID,1)

class SpindleWSM : public SimpleOSMToWSMObject {
	public:
		SpindleWSM() {}
		SpindleWSM(SpindleMod *m) : SimpleOSMToWSMObject(m) {}
		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return SPINDLEOSM_CLASS_ID;} 
		TCHAR *GetObjectName() {return GetString(IDS_EP_SPINDLE);}
		RefTargetHandle Clone(RemapDir& remap)
			{return (new SpindleWSM((SpindleMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);}
	};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap *SpindleMod::pmapParam;

class SpindleClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SpindleMod; }
	const TCHAR *	ClassName() { return GetString(IDS_EP_SPINDLE); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return SPINDLEOSM_CLASS_ID; }
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static SpindleClassDesc taperDesc;
extern ClassDesc* GetSpindleModDesc() { return &taperDesc; }

class SpindleWSMClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) 
		{if (loading) return new SpindleWSM; else return new SpindleWSM(new SpindleMod);}
	const TCHAR *	ClassName() { return GetString(IDS_EP_SPINDLE); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return SPINDLEOSM_CLASS_ID; }
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_MODBASED);}
	};

static SpindleWSMClassDesc taperWSMDesc;
extern ClassDesc* GetSpindleWSMDesc() { return &taperWSMDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_AMT			0
#define PB_CRV			1

#define PB_AMTQ			2
#define PB_CRVQ			3
#define PB_DOREGIONQ	4
#define PB_FROMQ		5
#define PB_TOQ			6

#define PB_BIAS			7
#define PB_VOL			8


//
//
// Parameters

static ParamUIDesc descParam[] = {

	// Amount
	ParamUIDesc(
		PB_AMT,
		EDITTYPE_FLOAT,
		IDC_AMT,IDC_AMTSPINNER,
		-100.0f,100.0f,
		0.01f),

	// Curve
	ParamUIDesc(
		PB_CRV,
		EDITTYPE_FLOAT,
		IDC_CRV,IDC_CRVSPINNER,
		-100.0f,100.0f,
		0.01f),
	
	// Amount
	ParamUIDesc(
		PB_AMTQ,
		EDITTYPE_FLOAT,
		IDC_AMT2,IDC_AMT2SPIN,
		-100.0f,100.0f,
		0.01f),

	// Curve
	ParamUIDesc(
		PB_CRVQ,
		EDITTYPE_FLOAT,
		IDC_CRV2,IDC_CRV2SPIN,
		0.0f,100.0f,
		0.01f),
	
	// Affect region
	ParamUIDesc(PB_DOREGIONQ,TYPE_SINGLECHEKBOX,IDC_SQUEEZE_AFFECTREGION),

	// From
	ParamUIDesc(
		PB_FROMQ,
		EDITTYPE_UNIVERSE,
		IDC_SQUEEZE_FROM,IDC_SQUEEZE_FROMSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// To
	ParamUIDesc(
		PB_TOQ,
		EDITTYPE_UNIVERSE,
		IDC_SQUEEZE_TO,IDC_SQUEEZE_TOSPIN,
		-BIGFLOAT,BIGFLOAT,		
		SPIN_AUTOSCALE),	

	// Bias
	ParamUIDesc(
		PB_BIAS,
		EDITTYPE_FLOAT,
		IDC_SQUEEZE_BIAS,IDC_SQUEEZE_BIASSPIN,
		-100.0f,100.0f,		
		1.0f,
		stdPercentDim),	

	// Vol
	ParamUIDesc(
		PB_VOL,
		EDITTYPE_FLOAT,
		IDC_SQUEEZE_VOLUME,IDC_SQUEEZE_VOLUMESPIN,
		0.0f,1000.0f,		
		1.0f,
		stdPercentDim),	
		
};

#define PARAMDESC_LENGH 9


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },

	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 6 },

	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
};

#define PBLOCK_LENGTH	9

// Array of old versions
//static ParamVersionDesc versions[] = {
//	ParamVersionDesc(descVer0,3,0)
//	};
#define NUM_OLDVERSIONS	0

// Current version
#define CURRENT_VERSION	0

static ParamVersionDesc curVersion(descVer0,PBLOCK_LENGTH,CURRENT_VERSION);


//--- SpindleDlgProc -------------------------------

class SpindleDlgProc : public ParamMapUserDlgProc {
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {}
	};
static SpindleDlgProc theSpindleProc;

BOOL SpindleDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_X:
				case IDC_Y:
				case IDC_Z:
					break;		
				}
			break;

		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_SQUEEZE_FROMSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROMQ,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TOQ,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_TOQ,t,from);
						map->Invalidate();
						}
					break;
					}
				
				case IDC_SQUEEZE_TOSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROMQ,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TOQ,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_FROMQ,t,to);
						map->Invalidate();
						}
					break;
					}
				}
			break;
		}
	return FALSE;
	}

//--- Bend methods -------------------------------


SpindleMod::SpindleMod()
{	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));

	pblock->SetValue(PB_AMT, TimeValue(0), 0.0f);
	pblock->SetValue(PB_CRV, TimeValue(0), 2.0f);

	pblock->SetValue(PB_AMTQ, TimeValue(0), 0.0f);
	pblock->SetValue(PB_CRVQ, TimeValue(0), 2.0f);
	pblock->SetValue(PB_DOREGIONQ, TimeValue(0), 0);
	pblock->SetValue(PB_FROMQ, TimeValue(0), -50.0f);
	pblock->SetValue(PB_TOQ, TimeValue(0), 50.0f);

	pblock->SetValue(PB_BIAS, TimeValue(0), 0.0f);
	pblock->SetValue(PB_VOL, TimeValue(0), 1.0f);
}

IOResult SpindleMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
//	iload->RegisterPostLoadCallback(
//		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,SIMPMOD_PBLOCKREF));
	return IO_OK;
	}

void SpindleMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_SPINDLEPARAM),
		GetString(IDS_AP_PARAMETERS),
		0);	
	pmapParam->SetUserDlgProc(&theSpindleProc);
	}
		
void SpindleMod::EndEditParams(IObjParam *ip, ULONG flags,Animatable *next)
	{
	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval SpindleMod::GetValidity(TimeValue t)
{	float f;	
	Interval valid = FOREVER;
	pblock->GetValue(PB_AMT,t,f,valid);
	pblock->GetValue(PB_CRV,t,f,valid);

	pblock->GetValue(PB_AMTQ,t,f,valid);
	pblock->GetValue(PB_CRVQ,t,f,valid);
	pblock->GetValue(PB_FROMQ,t,f,valid);
	pblock->GetValue(PB_TOQ,t,f,valid);

	pblock->GetValue(PB_BIAS,t,f,valid);
	pblock->GetValue(PB_VOL,t,f,valid);
	return valid;
}

BOOL SpindleMod::GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis)
{	int limit;
	pblock->GetValue(PB_DOREGIONQ,t,limit,FOREVER);
	pblock->GetValue(PB_FROMQ,t,zmin,FOREVER);
	pblock->GetValue(PB_TOQ,t,zmax,FOREVER);
	axis=2;
	return limit?TRUE:FALSE;
}

RefTargetHandle SpindleMod::Clone(RemapDir& remap) 
	{	
	SpindleMod* newmod = new SpindleMod();
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newmod->SimpleModClone(this);
	return(newmod);
	}

SpindleDeformer::SpindleDeformer() 
{ 	tm.IdentityMatrix();
	time = 0;	
}

void SpindleDeformer::SetAxis(Matrix3 &tmAxis)
{	Matrix3 itm = Inverse(tmAxis);
	tm    = tm*tmAxis;
	invtm =	itm*invtm;
}

Point3 SpindleDeformer::Map(int i, Point3 p)
{	float sqeez, len, maxR;

	Point3 wvector;

	len = 0.5f*(bbox.pmax[2]-bbox.pmin[2]);

	wvector = (bbox.pmax - bbox.pmin);
	wvector[2] = 0.0f;
	maxR = Length(wvector)*0.5f;

	if (FloatEQ0(len)||FloatEQ0(maxR)) return p;

	p = p * tm;

	float eff_r, bulge, radiusfalloff;

	eff_r = (float)sqrt(p.x*p.x + p.y*p.y)/maxR;

	radiusfalloff = 1.0f/(1.0f+float(pow(eff_r,ks2)));

	bulge = kvol*(1.0f+kbias)*((float)fabs(p.z)/len)*ks1*radiusfalloff;

	if (doRegionQ)
	{	if (p.z<fromQ)
		{	sqeez = (float)fabs(fromQ)/len;
		}
		else if (p.z>toQ)
		{	sqeez = (float)fabs(toQ)/len;
		}
		else
		{	sqeez = (float)fabs(p.z)/len;
		}
	}
	else
	{	sqeez = (float)fabs(p.z)/len;
	}	

//	sqeez =  1.0f + sqeez*kq1 + kq2*sqeez*(1.0f - sqeez);
	sqeez =  (1.0f/(1.0f+(float)fabs(kq1))) + 
			 kvol*(1.0f-kbias)*(kq1/(1.0f+(float)fabs(kq1)))*(float)pow(sqeez,kq2);

  	p.x *= sqeez;
  	p.y *= sqeez;
	p.z *= (1.0f + bulge);

	p = p * invtm;

	return p;
}

SpindleDeformer::SpindleDeformer(
		TimeValue t, ModContext &mc, 
		float  amt, float crv,
		float  amtQ, float crvQ,
		float fromQ, float toQ, int doRegionQ,
		float bias, float vol,
 		Matrix3& modmat, Matrix3& modinv)
{	this->doRegionQ = doRegionQ;
	this->fromQ = fromQ;
	this->toQ   = toQ;
	Interval valid;
	Matrix3 mat;	
	time   = t;	
	tm = modmat;
	invtm = modinv;
	mat.IdentityMatrix();
	SetKS(amt,crv);
	SetKQ(amtQ,crvQ);
	SetBias(bias);
	SetVol(vol);
	SetAxis( mat );
	bbox = *mc.box;
	}


Deformer& SpindleMod::GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
{
	static SpindleDeformer deformer;
	float amt, crv;
	float amtQ, crvQ, fromQ, toQ;
	int doRegionQ;
	float bias,vol;

	pblock->GetValue(PB_AMT,t,amt,FOREVER);
	pblock->GetValue(PB_CRV,t,crv,FOREVER);

	pblock->GetValue(PB_AMTQ,t,amtQ,FOREVER);
	pblock->GetValue(PB_CRVQ,t,crvQ,FOREVER);
	pblock->GetValue(PB_FROMQ,t,fromQ,FOREVER);
	pblock->GetValue(PB_TOQ,t,toQ,FOREVER);
	pblock->GetValue(PB_DOREGIONQ,t,doRegionQ,FOREVER);

	pblock->GetValue(PB_BIAS,t,bias,FOREVER);
	pblock->GetValue(PB_VOL,t,vol,FOREVER);
	
	deformer = SpindleDeformer(t,mc,amt,crv,
									amtQ,crvQ,fromQ,toQ,doRegionQ,bias,vol,
									mat,invmat);
	return deformer;
}

ParamDimension *SpindleMod::GetParameterDim(int pbIndex)
{
	switch (pbIndex)
	{
		case PB_AMT: 		return stdNormalizedDim; 
		case PB_CRV:		return stdNormalizedDim;		

		case PB_AMTQ: 		return stdNormalizedDim; 
		case PB_CRVQ:		return stdNormalizedDim;		
		case PB_FROMQ:		return stdWorldDim;
		case PB_TOQ:		return stdWorldDim;

		case PB_VOL:		return stdPercentDim;
		case PB_BIAS:		return stdPercentDim;

		default:			return defaultDim;
	}
}

TSTR SpindleMod::GetParameterName(int pbIndex)
{	switch (pbIndex)
	{
		case PB_AMT:		return GetString(IDS_EP_AMOUNT);
		case PB_CRV:		return GetString(IDS_EP_CURVITURE);

		case PB_AMTQ:		return GetString(IDS_EP_AMOUNTQ);
		case PB_CRVQ:		return GetString(IDS_EP_CURVITUREQ);
		case PB_FROMQ:		return GetString(IDS_EP_FROMQ);
		case PB_TOQ:		return GetString(IDS_EP_TOQ);
		case PB_DOREGIONQ:	return GetString(IDS_EP_REGIONQ);

		case PB_BIAS:		return GetString(IDS_EP_BIAS);
		case PB_VOL:		return GetString(IDS_EP_VOLUME);

		default:			return TSTR(_T(""));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\cmdmode.h ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 20, 1998
 CmdMode.h - Header for Virtual TrackBall
 ***************************************************************************/
class ICommandMode {
public:
	virtual BOOL	Init(HWND hWnd, int nWidth, int nHeight) = 0;
	virtual BOOL	Resize(int nWidth, int nHeight) = 0;

	virtual BOOL	OnLMouseDown(short x, short y) = 0;
	virtual BOOL	OnLMouseUp(short x, short y) = 0;
	virtual BOOL	OnMMouseDown(short x, short y) = 0;
	virtual BOOL	OnMMouseUp(short x, short y) = 0;
	virtual BOOL	OnRMouseDown(short x, short y) = 0;
	virtual BOOL	OnRMouseUp(short x, short y) = 0;
	virtual BOOL	OnMouseMove(DWORD keyFlags, short x, short y) = 0;

	virtual BOOL	HasMotion() = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\geometry.h ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 20, 1998
 Geometry.h - Object definition of a teapot
 Format: [Normal x, y, z, Vertex x, y, z]
 ***************************************************************************/
float objectDef[] = {
	-0.964791f, 0.063500f, -0.255236f, 0.217793f, 0.000000f, 0.373359f,
	-0.866654f, 0.428240f, -0.255973f, 0.200914f, -0.085484f, 0.373359f,
	-0.899595f, 0.362922f, 0.242934f, 0.198111f, -0.084291f, 0.384844f,

	-0.899595f, 0.362922f, 0.242934f, 0.198111f, -0.084291f, 0.384844f,
	-0.970157f, -0.008432f, 0.242333f, 0.214754f, 0.000000f, 0.384844f,
	-0.964791f, 0.063500f, -0.255236f, 0.217793f, 0.000000f, 0.373359f,

	-0.970157f, -0.008432f, 0.242333f, 0.214754f, 0.000000f, 0.384844f,
	-0.899595f, 0.362922f, 0.242934f, 0.198111f, -0.084291f, 0.384844f,
	-0.171775f, 0.016279f, 0.985002f, 0.201362f, -0.085675f, 0.388673f,

	-0.171775f, 0.016279f, 0.985002f, 0.201362f, -0.085675f, 0.388673f,
	-0.164811f, -0.050113f, 0.985051f, 0.218279f, 0.000000f, 0.388673f,
	-0.970157f, -0.008432f, 0.242333f, 0.214754f, 0.000000f, 0.384844f,

	-0.164811f, -0.050113f, 0.985051f, 0.218279f, 0.000000f, 0.388673f,
	-0.171775f, 0.016279f, 0.985002f, 0.201362f, -0.085675f, 0.388673f,
	0.609666f, -0.265067f, 0.747025f, 0.207977f, -0.088489f, 0.384844f,

	0.609666f, -0.265067f, 0.747025f, 0.207977f, -0.088489f, 0.384844f,
	0.665537f, -0.011761f, 0.746272f, 0.225450f, 0.000000f, 0.384844f,
	-0.164811f, -0.050113f, 0.985051f, 0.218279f, 0.000000f, 0.388673f,

	0.665537f, -0.011761f, 0.746272f, 0.225450f, 0.000000f, 0.384844f,
	0.609666f, -0.265067f, 0.747025f, 0.207977f, -0.088489f, 0.384844f,
	0.800360f, -0.334021f, 0.497848f, 0.215265f, -0.091590f, 0.373359f,

	0.800360f, -0.334021f, 0.497848f, 0.215265f, -0.091590f, 0.373359f,
	0.867772f, -0.002629f, 0.496956f, 0.233350f, 0.000000f, 0.373359f,
	0.665537f, -0.011761f, 0.746272f, 0.225450f, 0.000000f, 0.384844f,

	-0.866654f, 0.428240f, -0.255973f, 0.200914f, -0.085484f, 0.373359f,
	-0.636980f, 0.727058f, -0.256209f, 0.154633f, -0.154633f, 0.373359f,
	-0.691927f, 0.679896f, 0.242856f, 0.152476f, -0.152476f, 0.384844f,

	-0.691927f, 0.679896f, 0.242856f, 0.152476f, -0.152476f, 0.384844f,
	-0.899595f, 0.362922f, 0.242934f, 0.198111f, -0.084291f, 0.384844f,
	-0.866654f, 0.428240f, -0.255973f, 0.200914f, -0.085484f, 0.373359f,

	-0.899595f, 0.362922f, 0.242934f, 0.198111f, -0.084291f, 0.384844f,
	-0.691927f, 0.679896f, 0.242856f, 0.152476f, -0.152476f, 0.384844f,
	-0.151837f, 0.081001f, 0.985081f, 0.154978f, -0.154978f, 0.388673f,

	-0.151837f, 0.081001f, 0.985081f, 0.154978f, -0.154978f, 0.388673f,
	-0.171775f, 0.016279f, 0.985002f, 0.201362f, -0.085675f, 0.388673f,
	-0.899595f, 0.362922f, 0.242934f, 0.198111f, -0.084291f, 0.384844f,

	-0.171775f, 0.016279f, 0.985002f, 0.201362f, -0.085675f, 0.388673f,
	-0.151837f, 0.081001f, 0.985081f, 0.154978f, -0.154978f, 0.388673f,
	0.461297f, -0.478005f, 0.747473f, 0.160069f, -0.160069f, 0.384844f,

	0.461297f, -0.478005f, 0.747473f, 0.160069f, -0.160069f, 0.384844f,
	0.609666f, -0.265067f, 0.747025f, 0.207977f, -0.088489f, 0.384844f,
	-0.171775f, 0.016279f, 0.985002f, 0.201362f, -0.085675f, 0.388673f,

	0.609666f, -0.265067f, 0.747025f, 0.207977f, -0.088489f, 0.384844f,
	0.461297f, -0.478005f, 0.747473f, 0.160069f, -0.160069f, 0.384844f,
	0.611121f, -0.614869f, 0.498465f, 0.165678f, -0.165678f, 0.373359f,

	0.611121f, -0.614869f, 0.498465f, 0.165678f, -0.165678f, 0.373359f,
	0.800360f, -0.334021f, 0.497848f, 0.215265f, -0.091590f, 0.373359f,
	0.609666f, -0.265067f, 0.747025f, 0.207977f, -0.088489f, 0.384844f,

	-0.636980f, 0.727058f, -0.256209f, 0.154633f, -0.154633f, 0.373359f,
	-0.309409f, 0.915918f, -0.255656f, 0.085484f, -0.200914f, 0.373359f,
	-0.378799f, 0.893156f, 0.242452f, 0.084291f, -0.198111f, 0.384844f,

	-0.378799f, 0.893156f, 0.242452f, 0.084291f, -0.198111f, 0.384844f,
	-0.691927f, 0.679896f, 0.242856f, 0.152476f, -0.152476f, 0.384844f,
	-0.636980f, 0.727058f, -0.256209f, 0.154633f, -0.154633f, 0.373359f,

	-0.691927f, 0.679896f, 0.242856f, 0.152476f, -0.152476f, 0.384844f,
	-0.378799f, 0.893156f, 0.242452f, 0.084291f, -0.198111f, 0.384844f,
	-0.109658f, 0.132497f, 0.985099f, 0.085675f, -0.201362f, 0.388673f,

	-0.109658f, 0.132497f, 0.985099f, 0.085675f, -0.201362f, 0.388673f,
	-0.151837f, 0.081001f, 0.985081f, 0.154978f, -0.154978f, 0.388673f,
	-0.691927f, 0.679896f, 0.242856f, 0.152476f, -0.152476f, 0.384844f,

	-0.151837f, 0.081001f, 0.985081f, 0.154978f, -0.154978f, 0.388673f,
	-0.109658f, 0.132497f, 0.985099f, 0.085675f, -0.201362f, 0.388673f,
	0.243047f, -0.618800f, 0.747004f, 0.088489f, -0.207977f, 0.384844f,

	0.243047f, -0.618800f, 0.747004f, 0.088489f, -0.207977f, 0.384844f,
	0.461297f, -0.478005f, 0.747473f, 0.160069f, -0.160069f, 0.384844f,
	-0.151837f, 0.081001f, 0.985081f, 0.154978f, -0.154978f, 0.388673f,

	0.461297f, -0.478005f, 0.747473f, 0.160069f, -0.160069f, 0.384844f,
	0.243047f, -0.618800f, 0.747004f, 0.088489f, -0.207977f, 0.384844f,
	0.329078f, -0.802376f, 0.497897f, 0.091590f, -0.215265f, 0.373359f,

	0.329078f, -0.802376f, 0.497897f, 0.091590f, -0.215265f, 0.373359f,
	0.611121f, -0.614869f, 0.498465f, 0.165678f, -0.165678f, 0.373359f,
	0.461297f, -0.478005f, 0.747473f, 0.160069f, -0.160069f, 0.384844f,

	-0.309409f, 0.915918f, -0.255656f, 0.085484f, -0.200914f, 0.373359f,
	0.056910f, 0.960836f, -0.271213f, 0.000000f, -0.217793f, 0.373359f,
	-0.009203f, 0.972221f, 0.233882f, 0.000000f, -0.214754f, 0.384844f,

	-0.009203f, 0.972221f, 0.233882f, 0.000000f, -0.214754f, 0.384844f,
	-0.378799f, 0.893156f, 0.242452f, 0.084291f, -0.198111f, 0.384844f,
	-0.309409f, 0.915918f, -0.255656f, 0.085484f, -0.200914f, 0.373359f,

	-0.378799f, 0.893156f, 0.242452f, 0.084291f, -0.198111f, 0.384844f,
	-0.009203f, 0.972221f, 0.233882f, 0.000000f, -0.214754f, 0.384844f,
	-0.050508f, 0.163565f, 0.985239f, 0.000000f, -0.218279f, 0.388673f,

	-0.050508f, 0.163565f, 0.985239f, 0.000000f, -0.218279f, 0.388673f,
	-0.109658f, 0.132497f, 0.985099f, 0.085675f, -0.201362f, 0.388673f,
	-0.378799f, 0.893156f, 0.242452f, 0.084291f, -0.198111f, 0.384844f,

	-0.109658f, 0.132497f, 0.985099f, 0.085675f, -0.201362f, 0.388673f,
	-0.050508f, 0.163565f, 0.985239f, 0.000000f, -0.218279f, 0.388673f,
	-0.011738f, -0.665675f, 0.746149f, 0.000000f, -0.225450f, 0.384844f,

	-0.011738f, -0.665675f, 0.746149f, 0.000000f, -0.225450f, 0.384844f,
	0.243047f, -0.618800f, 0.747004f, 0.088489f, -0.207977f, 0.384844f,
	-0.109658f, 0.132497f, 0.985099f, 0.085675f, -0.201362f, 0.388673f,

	0.243047f, -0.618800f, 0.747004f, 0.088489f, -0.207977f, 0.384844f,
	-0.011738f, -0.665675f, 0.746149f, 0.000000f, -0.225450f, 0.384844f,
	-0.002629f, -0.867772f, 0.496956f, 0.000000f, -0.233350f, 0.373359f,

	-0.002629f, -0.867772f, 0.496956f, 0.000000f, -0.233350f, 0.373359f,
	0.329078f, -0.802376f, 0.497897f, 0.091590f, -0.215265f, 0.373359f,
	0.243047f, -0.618800f, 0.747004f, 0.088489f, -0.207977f, 0.384844f,

	0.056910f, 0.960836f, -0.271213f, 0.000000f, -0.217793f, 0.373359f,
	0.408654f, 0.837540f, -0.362668f, -0.091390f, -0.200914f, 0.373359f,
	0.370984f, 0.916036f, 0.152475f, -0.086783f, -0.198111f, 0.384844f,

	0.370984f, 0.916036f, 0.152475f, -0.086783f, -0.198111f, 0.384844f,
	-0.009203f, 0.972221f, 0.233882f, 0.000000f, -0.214754f, 0.384844f,
	0.056910f, 0.960836f, -0.271213f, 0.000000f, -0.217793f, 0.373359f,

	-0.009203f, 0.972221f, 0.233882f, 0.000000f, -0.214754f, 0.384844f,
	0.370984f, 0.916036f, 0.152475f, -0.086783f, -0.198111f, 0.384844f,
	0.024406f, 0.194989f, 0.980502f, -0.086413f, -0.201362f, 0.388673f,

	0.024406f, 0.194989f, 0.980502f, -0.086413f, -0.201362f, 0.388673f,
	-0.050508f, 0.163565f, 0.985239f, 0.000000f, -0.218279f, 0.388673f,
	-0.009203f, 0.972221f, 0.233882f, 0.000000f, -0.214754f, 0.384844f,

	-0.050508f, 0.163565f, 0.985239f, 0.000000f, -0.218279f, 0.388673f,
	0.024406f, 0.194989f, 0.980502f, -0.086413f, -0.201362f, 0.388673f,
	-0.267120f, -0.613717f, 0.742965f, -0.088581f, -0.207977f, 0.384844f,

	-0.267120f, -0.613717f, 0.742965f, -0.088581f, -0.207977f, 0.384844f,
	-0.011738f, -0.665675f, 0.746149f, 0.000000f, -0.225450f, 0.384844f,
	-0.050508f, 0.163565f, 0.985239f, 0.000000f, -0.218279f, 0.388673f,

	-0.011738f, -0.665675f, 0.746149f, 0.000000f, -0.225450f, 0.384844f,
	-0.267120f, -0.613717f, 0.742965f, -0.088581f, -0.207977f, 0.384844f,
	-0.334163f, -0.800677f, 0.497243f, -0.091590f, -0.215265f, 0.373359f,

	-0.334163f, -0.800677f, 0.497243f, -0.091590f, -0.215265f, 0.373359f,
	-0.002629f, -0.867772f, 0.496956f, 0.000000f, -0.233350f, 0.373359f,
	-0.011738f, -0.665675f, 0.746149f, 0.000000f, -0.225450f, 0.384844f,

	0.408654f, 0.837540f, -0.362668f, -0.091390f, -0.200914f, 0.373359f,
	0.704191f, 0.595663f, -0.386395f, -0.159883f, -0.154633f, 0.373359f,
	0.705860f, 0.702532f, 0.090615f, -0.154691f, -0.152476f, 0.384844f,

	0.705860f, 0.702532f, 0.090615f, -0.154691f, -0.152476f, 0.384844f,
	0.370984f, 0.916036f, 0.152475f, -0.086783f, -0.198111f, 0.384844f,
	0.408654f, 0.837540f, -0.362668f, -0.091390f, -0.200914f, 0.373359f,

	0.370984f, 0.916036f, 0.152475f, -0.086783f, -0.198111f, 0.384844f,
	0.705860f, 0.702532f, 0.090615f, -0.154691f, -0.152476f, 0.384844f,
	0.127861f, 0.208507f, 0.969627f, -0.155634f, -0.154978f, 0.388673f,

	0.127861f, 0.208507f, 0.969627f, -0.155634f, -0.154978f, 0.388673f,
	0.024406f, 0.194989f, 0.980502f, -0.086413f, -0.201362f, 0.388673f,
	0.370984f, 0.916036f, 0.152475f, -0.086783f, -0.198111f, 0.384844f,

	0.024406f, 0.194989f, 0.980502f, -0.086413f, -0.201362f, 0.388673f,
	0.127861f, 0.208507f, 0.969627f, -0.155634f, -0.154978f, 0.388673f,
	-0.484887f, -0.468394f, 0.738574f, -0.160151f, -0.160069f, 0.384844f,

	-0.484887f, -0.468394f, 0.738574f, -0.160151f, -0.160069f, 0.384844f,
	-0.267120f, -0.613717f, 0.742965f, -0.088581f, -0.207977f, 0.384844f,
	0.024406f, 0.194989f, 0.980502f, -0.086413f, -0.201362f, 0.388673f,

	-0.267120f, -0.613717f, 0.742965f, -0.088581f, -0.207977f, 0.384844f,
	-0.484887f, -0.468394f, 0.738574f, -0.160151f, -0.160069f, 0.384844f,
	-0.615438f, -0.611722f, 0.497023f, -0.165678f, -0.165678f, 0.373359f,

	-0.615438f, -0.611722f, 0.497023f, -0.165678f, -0.165678f, 0.373359f,
	-0.334163f, -0.800677f, 0.497243f, -0.091590f, -0.215265f, 0.373359f,
	-0.267120f, -0.613717f, 0.742965f, -0.088581f, -0.207977f, 0.384844f,

	0.704191f, 0.595663f, -0.386395f, -0.159883f, -0.154633f, 0.373359f,
	0.907465f, 0.283910f, -0.309681f, -0.202883f, -0.085484f, 0.373359f,
	0.915929f, 0.369963f, 0.155569f, -0.198942f, -0.084291f, 0.384844f,

	0.915929f, 0.369963f, 0.155569f, -0.198942f, -0.084291f, 0.384844f,
	0.705860f, 0.702532f, 0.090615f, -0.154691f, -0.152476f, 0.384844f,
	0.704191f, 0.595663f, -0.386395f, -0.159883f, -0.154633f, 0.373359f,

	0.705860f, 0.702532f, 0.090615f, -0.154691f, -0.152476f, 0.384844f,
	0.915929f, 0.369963f, 0.155569f, -0.198942f, -0.084291f, 0.384844f,
	0.183345f, 0.136578f, 0.973515f, -0.201609f, -0.085675f, 0.388673f,

	0.183345f, 0.136578f, 0.973515f, -0.201609f, -0.085675f, 0.388673f,
	0.127861f, 0.208507f, 0.969627f, -0.155634f, -0.154978f, 0.388673f,
	0.705860f, 0.702532f, 0.090615f, -0.154691f, -0.152476f, 0.384844f,

	0.127861f, 0.208507f, 0.969627f, -0.155634f, -0.154978f, 0.388673f,
	0.183345f, 0.136578f, 0.973515f, -0.201609f, -0.085675f, 0.388673f,
	-0.625202f, -0.246027f, 0.740671f, -0.208008f, -0.088489f, 0.384844f,

	-0.625202f, -0.246027f, 0.740671f, -0.208008f, -0.088489f, 0.384844f,
	-0.484887f, -0.468394f, 0.738574f, -0.160151f, -0.160069f, 0.384844f,
	0.127861f, 0.208507f, 0.969627f, -0.155634f, -0.154978f, 0.388673f,

	-0.484887f, -0.468394f, 0.738574f, -0.160151f, -0.160069f, 0.384844f,
	-0.625202f, -0.246027f, 0.740671f, -0.208008f, -0.088489f, 0.384844f,
	-0.802948f, -0.329317f, 0.496814f, -0.215265f, -0.091590f, 0.373359f,

	-0.802948f, -0.329317f, 0.496814f, -0.215265f, -0.091590f, 0.373359f,
	-0.615438f, -0.611722f, 0.497023f, -0.165678f, -0.165678f, 0.373359f,
	-0.484887f, -0.468394f, 0.738574f, -0.160151f, -0.160069f, 0.384844f,

	0.907465f, 0.283910f, -0.309681f, -0.202883f, -0.085484f, 0.373359f,
	0.964333f, -0.070564f, -0.255115f, -0.217793f, 0.000000f, 0.373359f,
	0.973733f, 0.000322f, 0.227693f, -0.214754f, 0.000000f, 0.384844f,

	0.973733f, 0.000322f, 0.227693f, -0.214754f, 0.000000f, 0.384844f,
	0.915929f, 0.369963f, 0.155569f, -0.198942f, -0.084291f, 0.384844f,
	0.907465f, 0.283910f, -0.309681f, -0.202883f, -0.085484f, 0.373359f,

	0.915929f, 0.369963f, 0.155569f, -0.198942f, -0.084291f, 0.384844f,
	0.973733f, 0.000322f, 0.227693f, -0.214754f, 0.000000f, 0.384844f,
	0.179026f, 0.051399f, 0.982501f, -0.218279f, 0.000000f, 0.388673f,

	0.179026f, 0.051399f, 0.982501f, -0.218279f, 0.000000f, 0.388673f,
	0.183345f, 0.136578f, 0.973515f, -0.201609f, -0.085675f, 0.388673f,
	0.915929f, 0.369963f, 0.155569f, -0.198942f, -0.084291f, 0.384844f,

	0.183345f, 0.136578f, 0.973515f, -0.201609f, -0.085675f, 0.388673f,
	0.179026f, 0.051399f, 0.982501f, -0.218279f, 0.000000f, 0.388673f,
	-0.667145f, 0.011683f, 0.744837f, -0.225450f, 0.000000f, 0.384844f,

	-0.667145f, 0.011683f, 0.744837f, -0.225450f, 0.000000f, 0.384844f,
	-0.625202f, -0.246027f, 0.740671f, -0.208008f, -0.088489f, 0.384844f,
	0.183345f, 0.136578f, 0.973515f, -0.201609f, -0.085675f, 0.388673f,

	-0.625202f, -0.246027f, 0.740671f, -0.208008f, -0.088489f, 0.384844f,
	-0.667145f, 0.011683f, 0.744837f, -0.225450f, 0.000000f, 0.384844f,
	-0.867923f, 0.002642f, 0.496692f, -0.233350f, 0.000000f, 0.373359f,

	-0.867923f, 0.002642f, 0.496692f, -0.233350f, 0.000000f, 0.373359f,
	-0.802948f, -0.329317f, 0.496814f, -0.215265f, -0.091590f, 0.373359f,
	-0.625202f, -0.246027f, 0.740671f, -0.208008f, -0.088489f, 0.384844f,

	0.964333f, -0.070564f, -0.255115f, -0.217793f, 0.000000f, 0.373359f,
	0.866654f, -0.428240f, -0.255973f, -0.200914f, 0.085484f, 0.373359f,
	0.899595f, -0.362922f, 0.242934f, -0.198111f, 0.084291f, 0.384844f,

	0.899595f, -0.362922f, 0.242934f, -0.198111f, 0.084291f, 0.384844f,
	0.973733f, 0.000322f, 0.227693f, -0.214754f, 0.000000f, 0.384844f,
	0.964333f, -0.070564f, -0.255115f, -0.217793f, 0.000000f, 0.373359f,

	0.973733f, 0.000322f, 0.227693f, -0.214754f, 0.000000f, 0.384844f,
	0.899595f, -0.362922f, 0.242934f, -0.198111f, 0.084291f, 0.384844f,
	0.171775f, -0.016279f, 0.985002f, -0.201362f, 0.085675f, 0.388673f,

	0.171775f, -0.016279f, 0.985002f, -0.201362f, 0.085675f, 0.388673f,
	0.179026f, 0.051399f, 0.982501f, -0.218279f, 0.000000f, 0.388673f,
	0.973733f, 0.000322f, 0.227693f, -0.214754f, 0.000000f, 0.384844f,

	0.179026f, 0.051399f, 0.982501f, -0.218279f, 0.000000f, 0.388673f,
	0.171775f, -0.016279f, 0.985002f, -0.201362f, 0.085675f, 0.388673f,
	-0.609666f, 0.265067f, 0.747025f, -0.207977f, 0.088489f, 0.384844f,

	-0.609666f, 0.265067f, 0.747025f, -0.207977f, 0.088489f, 0.384844f,
	-0.667145f, 0.011683f, 0.744837f, -0.225450f, 0.000000f, 0.384844f,
	0.179026f, 0.051399f, 0.982501f, -0.218279f, 0.000000f, 0.388673f,

	-0.667145f, 0.011683f, 0.744837f, -0.225450f, 0.000000f, 0.384844f,
	-0.609666f, 0.265067f, 0.747025f, -0.207977f, 0.088489f, 0.384844f,
	-0.800360f, 0.334021f, 0.497848f, -0.215265f, 0.091590f, 0.373359f,

	-0.800360f, 0.334021f, 0.497848f, -0.215265f, 0.091590f, 0.373359f,
	-0.867923f, 0.002642f, 0.496692f, -0.233350f, 0.000000f, 0.373359f,
	-0.667145f, 0.011683f, 0.744837f, -0.225450f, 0.000000f, 0.384844f,

	0.866654f, -0.428240f, -0.255973f, -0.200914f, 0.085484f, 0.373359f,
	0.636980f, -0.727058f, -0.256209f, -0.154633f, 0.154633f, 0.373359f,
	0.691927f, -0.679896f, 0.242856f, -0.152476f, 0.152476f, 0.384844f,

	0.691927f, -0.679896f, 0.242856f, -0.152476f, 0.152476f, 0.384844f,
	0.899595f, -0.362922f, 0.242934f, -0.198111f, 0.084291f, 0.384844f,
	0.866654f, -0.428240f, -0.255973f, -0.200914f, 0.085484f, 0.373359f,

	0.899595f, -0.362922f, 0.242934f, -0.198111f, 0.084291f, 0.384844f,
	0.691927f, -0.679896f, 0.242856f, -0.152476f, 0.152476f, 0.384844f,
	0.151837f, -0.081001f, 0.985081f, -0.154978f, 0.154978f, 0.388673f,

	0.151837f, -0.081001f, 0.985081f, -0.154978f, 0.154978f, 0.388673f,
	0.171775f, -0.016279f, 0.985002f, -0.201362f, 0.085675f, 0.388673f,
	0.899595f, -0.362922f, 0.242934f, -0.198111f, 0.084291f, 0.384844f,

	0.171775f, -0.016279f, 0.985002f, -0.201362f, 0.085675f, 0.388673f,
	0.151837f, -0.081001f, 0.985081f, -0.154978f, 0.154978f, 0.388673f,
	-0.461297f, 0.478005f, 0.747473f, -0.160069f, 0.160069f, 0.384844f,

	-0.461297f, 0.478005f, 0.747473f, -0.160069f, 0.160069f, 0.384844f,
	-0.609666f, 0.265067f, 0.747025f, -0.207977f, 0.088489f, 0.384844f,
	0.171775f, -0.016279f, 0.985002f, -0.201362f, 0.085675f, 0.388673f,

	-0.609666f, 0.265067f, 0.747025f, -0.207977f, 0.088489f, 0.384844f,
	-0.461297f, 0.478005f, 0.747473f, -0.160069f, 0.160069f, 0.384844f,
	-0.611121f, 0.614869f, 0.498465f, -0.165678f, 0.165678f, 0.373359f,

	-0.611121f, 0.614869f, 0.498465f, -0.165678f, 0.165678f, 0.373359f,
	-0.800360f, 0.334021f, 0.497848f, -0.215265f, 0.091590f, 0.373359f,
	-0.609666f, 0.265067f, 0.747025f, -0.207977f, 0.088489f, 0.384844f,

	0.636980f, -0.727058f, -0.256209f, -0.154633f, 0.154633f, 0.373359f,
	0.309409f, -0.915918f, -0.255656f, -0.085484f, 0.200914f, 0.373359f,
	0.378799f, -0.893156f, 0.242452f, -0.084291f, 0.198111f, 0.384844f,

	0.378799f, -0.893156f, 0.242452f, -0.084291f, 0.198111f, 0.384844f,
	0.691927f, -0.679896f, 0.242856f, -0.152476f, 0.152476f, 0.384844f,
	0.636980f, -0.727058f, -0.256209f, -0.154633f, 0.154633f, 0.373359f,

	0.691927f, -0.679896f, 0.242856f, -0.152476f, 0.152476f, 0.384844f,
	0.378799f, -0.893156f, 0.242452f, -0.084291f, 0.198111f, 0.384844f,
	0.109658f, -0.132497f, 0.985099f, -0.085675f, 0.201362f, 0.388673f,

	0.109658f, -0.132497f, 0.985099f, -0.085675f, 0.201362f, 0.388673f,
	0.151837f, -0.081001f, 0.985081f, -0.154978f, 0.154978f, 0.388673f,
	0.691927f, -0.679896f, 0.242856f, -0.152476f, 0.152476f, 0.384844f,

	0.151837f, -0.081001f, 0.985081f, -0.154978f, 0.154978f, 0.388673f,
	0.109658f, -0.132497f, 0.985099f, -0.085675f, 0.201362f, 0.388673f,
	-0.243047f, 0.618800f, 0.747004f, -0.088489f, 0.207977f, 0.384844f,

	-0.243047f, 0.618800f, 0.747004f, -0.088489f, 0.207977f, 0.384844f,
	-0.461297f, 0.478005f, 0.747473f, -0.160069f, 0.160069f, 0.384844f,
	0.151837f, -0.081001f, 0.985081f, -0.154978f, 0.154978f, 0.388673f,

	-0.461297f, 0.478005f, 0.747473f, -0.160069f, 0.160069f, 0.384844f,
	-0.243047f, 0.618800f, 0.747004f, -0.088489f, 0.207977f, 0.384844f,
	-0.329078f, 0.802376f, 0.497897f, -0.091590f, 0.215265f, 0.373359f,

	-0.329078f, 0.802376f, 0.497897f, -0.091590f, 0.215265f, 0.373359f,
	-0.611121f, 0.614869f, 0.498465f, -0.165678f, 0.165678f, 0.373359f,
	-0.461297f, 0.478005f, 0.747473f, -0.160069f, 0.160069f, 0.384844f,

	0.309409f, -0.915918f, -0.255656f, -0.085484f, 0.200914f, 0.373359f,
	-0.063500f, -0.964791f, -0.255236f, 0.000000f, 0.217793f, 0.373359f,
	0.008432f, -0.970157f, 0.242333f, 0.000000f, 0.214754f, 0.384844f,

	0.008432f, -0.970157f, 0.242333f, 0.000000f, 0.214754f, 0.384844f,
	0.378799f, -0.893156f, 0.242452f, -0.084291f, 0.198111f, 0.384844f,
	0.309409f, -0.915918f, -0.255656f, -0.085484f, 0.200914f, 0.373359f,

	0.378799f, -0.893156f, 0.242452f, -0.084291f, 0.198111f, 0.384844f,
	0.008432f, -0.970157f, 0.242333f, 0.000000f, 0.214754f, 0.384844f,
	0.050113f, -0.164811f, 0.985051f, 0.000000f, 0.218279f, 0.388673f,

	0.050113f, -0.164811f, 0.985051f, 0.000000f, 0.218279f, 0.388673f,
	0.109658f, -0.132497f, 0.985099f, -0.085675f, 0.201362f, 0.388673f,
	0.378799f, -0.893156f, 0.242452f, -0.084291f, 0.198111f, 0.384844f,

	0.109658f, -0.132497f, 0.985099f, -0.085675f, 0.201362f, 0.388673f,
	0.050113f, -0.164811f, 0.985051f, 0.000000f, 0.218279f, 0.388673f,
	0.011761f, 0.665537f, 0.746272f, 0.000000f, 0.225450f, 0.384844f,

	0.011761f, 0.665537f, 0.746272f, 0.000000f, 0.225450f, 0.384844f,
	-0.243047f, 0.618800f, 0.747004f, -0.088489f, 0.207977f, 0.384844f,
	0.109658f, -0.132497f, 0.985099f, -0.085675f, 0.201362f, 0.388673f,

	-0.243047f, 0.618800f, 0.747004f, -0.088489f, 0.207977f, 0.384844f,
	0.011761f, 0.665537f, 0.746272f, 0.000000f, 0.225450f, 0.384844f,
	0.002629f, 0.867772f, 0.496956f, 0.000000f, 0.233350f, 0.373359f,

	0.002629f, 0.867772f, 0.496956f, 0.000000f, 0.233350f, 0.373359f,
	-0.329078f, 0.802376f, 0.497897f, -0.091590f, 0.215265f, 0.373359f,
	-0.243047f, 0.618800f, 0.747004f, -0.088489f, 0.207977f, 0.384844f,

	-0.063500f, -0.964791f, -0.255236f, 0.000000f, 0.217793f, 0.373359f,
	-0.428240f, -0.866654f, -0.255973f, 0.085484f, 0.200914f, 0.373359f,
	-0.362922f, -0.899595f, 0.242934f, 0.084291f, 0.198111f, 0.384844f,

	-0.362922f, -0.899595f, 0.242934f, 0.084291f, 0.198111f, 0.384844f,
	0.008432f, -0.970157f, 0.242333f, 0.000000f, 0.214754f, 0.384844f,
	-0.063500f, -0.964791f, -0.255236f, 0.000000f, 0.217793f, 0.373359f,

	0.008432f, -0.970157f, 0.242333f, 0.000000f, 0.214754f, 0.384844f,
	-0.362922f, -0.899595f, 0.242934f, 0.084291f, 0.198111f, 0.384844f,
	-0.016279f, -0.171775f, 0.985002f, 0.085675f, 0.201362f, 0.388673f,

	-0.016279f, -0.171775f, 0.985002f, 0.085675f, 0.201362f, 0.388673f,
	0.050113f, -0.164811f, 0.985051f, 0.000000f, 0.218279f, 0.388673f,
	0.008432f, -0.970157f, 0.242333f, 0.000000f, 0.214754f, 0.384844f,

	0.050113f, -0.164811f, 0.985051f, 0.000000f, 0.218279f, 0.388673f,
	-0.016279f, -0.171775f, 0.985002f, 0.085675f, 0.201362f, 0.388673f,
	0.265067f, 0.609666f, 0.747025f, 0.088489f, 0.207977f, 0.384844f,

	0.265067f, 0.609666f, 0.747025f, 0.088489f, 0.207977f, 0.384844f,
	0.011761f, 0.665537f, 0.746272f, 0.000000f, 0.225450f, 0.384844f,
	0.050113f, -0.164811f, 0.985051f, 0.000000f, 0.218279f, 0.388673f,

	0.011761f, 0.665537f, 0.746272f, 0.000000f, 0.225450f, 0.384844f,
	0.265067f, 0.609666f, 0.747025f, 0.088489f, 0.207977f, 0.384844f,
	0.334021f, 0.800360f, 0.497848f, 0.091590f, 0.215265f, 0.373359f,

	0.334021f, 0.800360f, 0.497848f, 0.091590f, 0.215265f, 0.373359f,
	0.002629f, 0.867772f, 0.496956f, 0.000000f, 0.233350f, 0.373359f,
	0.011761f, 0.665537f, 0.746272f, 0.000000f, 0.225450f, 0.384844f,

	-0.428240f, -0.866654f, -0.255973f, 0.085484f, 0.200914f, 0.373359f,
	-0.727058f, -0.636980f, -0.256209f, 0.154633f, 0.154633f, 0.373359f,
	-0.679896f, -0.691927f, 0.242856f, 0.152476f, 0.152476f, 0.384844f,

	-0.679896f, -0.691927f, 0.242856f, 0.152476f, 0.152476f, 0.384844f,
	-0.362922f, -0.899595f, 0.242934f, 0.084291f, 0.198111f, 0.384844f,
	-0.428240f, -0.866654f, -0.255973f, 0.085484f, 0.200914f, 0.373359f,

	-0.362922f, -0.899595f, 0.242934f, 0.084291f, 0.198111f, 0.384844f,
	-0.679896f, -0.691927f, 0.242856f, 0.152476f, 0.152476f, 0.384844f,
	-0.081001f, -0.151837f, 0.985081f, 0.154978f, 0.154978f, 0.388673f,

	-0.081001f, -0.151837f, 0.985081f, 0.154978f, 0.154978f, 0.388673f,
	-0.016279f, -0.171775f, 0.985002f, 0.085675f, 0.201362f, 0.388673f,
	-0.362922f, -0.899595f, 0.242934f, 0.084291f, 0.198111f, 0.384844f,

	-0.016279f, -0.171775f, 0.985002f, 0.085675f, 0.201362f, 0.388673f,
	-0.081001f, -0.151837f, 0.985081f, 0.154978f, 0.154978f, 0.388673f,
	0.478005f, 0.461297f, 0.747473f, 0.160069f, 0.160069f, 0.384844f,

	0.478005f, 0.461297f, 0.747473f, 0.160069f, 0.160069f, 0.384844f,
	0.265067f, 0.609666f, 0.747025f, 0.088489f, 0.207977f, 0.384844f,
	-0.016279f, -0.171775f, 0.985002f, 0.085675f, 0.201362f, 0.388673f,

	0.265067f, 0.609666f, 0.747025f, 0.088489f, 0.207977f, 0.384844f,
	0.478005f, 0.461297f, 0.747473f, 0.160069f, 0.160069f, 0.384844f,
	0.614869f, 0.611121f, 0.498465f, 0.165678f, 0.165678f, 0.373359f,

	0.614869f, 0.611121f, 0.498465f, 0.165678f, 0.165678f, 0.373359f,
	0.334021f, 0.800360f, 0.497848f, 0.091590f, 0.215265f, 0.373359f,
	0.265067f, 0.609666f, 0.747025f, 0.088489f, 0.207977f, 0.384844f,

	-0.727058f, -0.636980f, -0.256209f, 0.154633f, 0.154633f, 0.373359f,
	-0.915918f, -0.309409f, -0.255656f, 0.200914f, 0.085484f, 0.373359f,
	-0.893156f, -0.378799f, 0.242452f, 0.198111f, 0.084291f, 0.384844f,

	-0.893156f, -0.378799f, 0.242452f, 0.198111f, 0.084291f, 0.384844f,
	-0.679896f, -0.691927f, 0.242856f, 0.152476f, 0.152476f, 0.384844f,
	-0.727058f, -0.636980f, -0.256209f, 0.154633f, 0.154633f, 0.373359f,

	-0.679896f, -0.691927f, 0.242856f, 0.152476f, 0.152476f, 0.384844f,
	-0.893156f, -0.378799f, 0.242452f, 0.198111f, 0.084291f, 0.384844f,
	-0.132497f, -0.109658f, 0.985099f, 0.201362f, 0.085675f, 0.388673f,

	-0.132497f, -0.109658f, 0.985099f, 0.201362f, 0.085675f, 0.388673f,
	-0.081001f, -0.151837f, 0.985081f, 0.154978f, 0.154978f, 0.388673f,
	-0.679896f, -0.691927f, 0.242856f, 0.152476f, 0.152476f, 0.384844f,

	-0.081001f, -0.151837f, 0.985081f, 0.154978f, 0.154978f, 0.388673f,
	-0.132497f, -0.109658f, 0.985099f, 0.201362f, 0.085675f, 0.388673f,
	0.618800f, 0.243047f, 0.747004f, 0.207977f, 0.088489f, 0.384844f,

	0.618800f, 0.243047f, 0.747004f, 0.207977f, 0.088489f, 0.384844f,
	0.478005f, 0.461297f, 0.747473f, 0.160069f, 0.160069f, 0.384844f,
	-0.081001f, -0.151837f, 0.985081f, 0.154978f, 0.154978f, 0.388673f,

	0.478005f, 0.461297f, 0.747473f, 0.160069f, 0.160069f, 0.384844f,
	0.618800f, 0.243047f, 0.747004f, 0.207977f, 0.088489f, 0.384844f,
	0.802376f, 0.329078f, 0.497897f, 0.215265f, 0.091590f, 0.373359f,

	0.802376f, 0.329078f, 0.497897f, 0.215265f, 0.091590f, 0.373359f,
	0.614869f, 0.611121f, 0.498465f, 0.165678f, 0.165678f, 0.373359f,
	0.478005f, 0.461297f, 0.747473f, 0.160069f, 0.160069f, 0.384844f,

	-0.915918f, -0.309409f, -0.255656f, 0.200914f, 0.085484f, 0.373359f,
	-0.964791f, 0.063500f, -0.255236f, 0.217793f, 0.000000f, 0.373359f,
	-0.970157f, -0.008432f, 0.242333f, 0.214754f, 0.000000f, 0.384844f,

	-0.970157f, -0.008432f, 0.242333f, 0.214754f, 0.000000f, 0.384844f,
	-0.893156f, -0.378799f, 0.242452f, 0.198111f, 0.084291f, 0.384844f,
	-0.915918f, -0.309409f, -0.255656f, 0.200914f, 0.085484f, 0.373359f,

	-0.893156f, -0.378799f, 0.242452f, 0.198111f, 0.084291f, 0.384844f,
	-0.970157f, -0.008432f, 0.242333f, 0.214754f, 0.000000f, 0.384844f,
	-0.164811f, -0.050113f, 0.985051f, 0.218279f, 0.000000f, 0.388673f,

	-0.164811f, -0.050113f, 0.985051f, 0.218279f, 0.000000f, 0.388673f,
	-0.132497f, -0.109658f, 0.985099f, 0.201362f, 0.085675f, 0.388673f,
	-0.893156f, -0.378799f, 0.242452f, 0.198111f, 0.084291f, 0.384844f,

	-0.132497f, -0.109658f, 0.985099f, 0.201362f, 0.085675f, 0.388673f,
	-0.164811f, -0.050113f, 0.985051f, 0.218279f, 0.000000f, 0.388673f,
	0.665537f, -0.011761f, 0.746272f, 0.225450f, 0.000000f, 0.384844f,

	0.665537f, -0.011761f, 0.746272f, 0.225450f, 0.000000f, 0.384844f,
	0.618800f, 0.243047f, 0.747004f, 0.207977f, 0.088489f, 0.384844f,
	-0.132497f, -0.109658f, 0.985099f, 0.201362f, 0.085675f, 0.388673f,

	0.618800f, 0.243047f, 0.747004f, 0.207977f, 0.088489f, 0.384844f,
	0.665537f, -0.011761f, 0.746272f, 0.225450f, 0.000000f, 0.384844f,
	0.867772f, -0.002629f, 0.496956f, 0.233350f, 0.000000f, 0.373359f,

	0.867772f, -0.002629f, 0.496956f, 0.233350f, 0.000000f, 0.373359f,
	0.802376f, 0.329078f, 0.497897f, 0.215265f, 0.091590f, 0.373359f,
	0.618800f, 0.243047f, 0.747004f, 0.207977f, 0.088489f, 0.384844f,

	0.867772f, -0.002629f, 0.496956f, 0.233350f, 0.000000f, 0.373359f,
	0.800360f, -0.334021f, 0.497848f, 0.215265f, -0.091590f, 0.373359f,
	0.844816f, -0.350176f, 0.404552f, 0.241612f, -0.102800f, 0.312287f,

	0.844816f, -0.350176f, 0.404552f, 0.241612f, -0.102800f, 0.312287f,
	0.914880f, -0.000563f, 0.403725f, 0.261911f, 0.000000f, 0.312287f,
	0.867772f, -0.002629f, 0.496956f, 0.233350f, 0.000000f, 0.373359f,

	0.914880f, -0.000563f, 0.403725f, 0.261911f, 0.000000f, 0.312287f,
	0.844816f, -0.350176f, 0.404552f, 0.241612f, -0.102800f, 0.312287f,
	0.868962f, -0.360724f, 0.338796f, 0.264596f, -0.112579f, 0.252309f,

	0.868962f, -0.360724f, 0.338796f, 0.264596f, -0.112579f, 0.252309f,
	0.941117f, -0.001052f, 0.338080f, 0.286825f, 0.000000f, 0.252309f,
	0.914880f, -0.000563f, 0.403725f, 0.261911f, 0.000000f, 0.312287f,

	0.941117f, -0.001052f, 0.338080f, 0.286825f, 0.000000f, 0.252309f,
	0.868962f, -0.360724f, 0.338796f, 0.264596f, -0.112579f, 0.252309f,
	0.903357f, -0.375090f, 0.207976f, 0.280853f, -0.119496f, 0.194519f,

	0.903357f, -0.375090f, 0.207976f, 0.280853f, -0.119496f, 0.194519f,
	0.978226f, -0.001148f, 0.207541f, 0.304448f, 0.000000f, 0.194519f,
	0.941117f, -0.001052f, 0.338080f, 0.286825f, 0.000000f, 0.252309f,

	0.978226f, -0.001148f, 0.207541f, 0.304448f, 0.000000f, 0.194519f,
	0.903357f, -0.375090f, 0.207976f, 0.280853f, -0.119496f, 0.194519f,
	0.922181f, -0.380711f, -0.068131f, 0.287020f, -0.122120f, 0.140010f,

	0.922181f, -0.380711f, -0.068131f, 0.287020f, -0.122120f, 0.140010f,
	0.997695f, 0.000826f, -0.067851f, 0.311133f, 0.000000f, 0.140010f,
	0.978226f, -0.001148f, 0.207541f, 0.304448f, 0.000000f, 0.194519f,

	0.800360f, -0.334021f, 0.497848f, 0.215265f, -0.091590f, 0.373359f,
	0.611121f, -0.614869f, 0.498465f, 0.165678f, -0.165678f, 0.373359f,
	0.646085f, -0.646888f, 0.405105f, 0.185956f, -0.185956f, 0.312287f,

	0.646085f, -0.646888f, 0.405105f, 0.185956f, -0.185956f, 0.312287f,
	0.844816f, -0.350176f, 0.404552f, 0.241612f, -0.102800f, 0.312287f,
	0.800360f, -0.334021f, 0.497848f, 0.215265f, -0.091590f, 0.373359f,

	0.844816f, -0.350176f, 0.404552f, 0.241612f, -0.102800f, 0.312287f,
	0.646085f, -0.646888f, 0.405105f, 0.185956f, -0.185956f, 0.312287f,
	0.664409f, -0.665911f, 0.339299f, 0.203646f, -0.203646f, 0.252309f,

	0.664409f, -0.665911f, 0.339299f, 0.203646f, -0.203646f, 0.252309f,
	0.868962f, -0.360724f, 0.338796f, 0.264596f, -0.112579f, 0.252309f,
	0.844816f, -0.350176f, 0.404552f, 0.241612f, -0.102800f, 0.312287f,

	0.868962f, -0.360724f, 0.338796f, 0.264596f, -0.112579f, 0.252309f,
	0.664409f, -0.665911f, 0.339299f, 0.203646f, -0.203646f, 0.252309f,
	0.690769f, -0.692410f, 0.208342f, 0.216158f, -0.216158f, 0.194519f,

	0.690769f, -0.692410f, 0.208342f, 0.216158f, -0.216158f, 0.194519f,
	0.903357f, -0.375090f, 0.207976f, 0.280853f, -0.119496f, 0.194519f,
	0.868962f, -0.360724f, 0.338796f, 0.264596f, -0.112579f, 0.252309f,

	0.903357f, -0.375090f, 0.207976f, 0.280853f, -0.119496f, 0.194519f,
	0.690769f, -0.692410f, 0.208342f, 0.216158f, -0.216158f, 0.194519f,
	0.706055f, -0.704874f, -0.068109f, 0.220904f, -0.220904f, 0.140010f,

	0.706055f, -0.704874f, -0.068109f, 0.220904f, -0.220904f, 0.140010f,
	0.922181f, -0.380711f, -0.068131f, 0.287020f, -0.122120f, 0.140010f,
	0.903357f, -0.375090f, 0.207976f, 0.280853f, -0.119496f, 0.194519f,

	0.611121f, -0.614869f, 0.498465f, 0.165678f, -0.165678f, 0.373359f,
	0.329078f, -0.802376f, 0.497897f, 0.091590f, -0.215265f, 0.373359f,
	0.349116f, -0.845246f, 0.404570f, 0.102800f, -0.241612f, 0.312287f,

	0.349116f, -0.845246f, 0.404570f, 0.102800f, -0.241612f, 0.312287f,
	0.646085f, -0.646888f, 0.405105f, 0.185956f, -0.185956f, 0.312287f,
	0.611121f, -0.614869f, 0.498465f, 0.165678f, -0.165678f, 0.373359f,

	0.646085f, -0.646888f, 0.405105f, 0.185956f, -0.185956f, 0.312287f,
	0.349116f, -0.845246f, 0.404570f, 0.102800f, -0.241612f, 0.312287f,
	0.358742f, -0.869764f, 0.338843f, 0.112579f, -0.264596f, 0.252309f,

	0.358742f, -0.869764f, 0.338843f, 0.112579f, -0.264596f, 0.252309f,
	0.664409f, -0.665911f, 0.339299f, 0.203646f, -0.203646f, 0.252309f,
	0.646085f, -0.646888f, 0.405105f, 0.185956f, -0.185956f, 0.312287f,

	0.664409f, -0.665911f, 0.339299f, 0.203646f, -0.203646f, 0.252309f,
	0.358742f, -0.869764f, 0.338843f, 0.112579f, -0.264596f, 0.252309f,
	0.372924f, -0.904230f, 0.208079f, 0.119496f, -0.280853f, 0.194519f,

	0.372924f, -0.904230f, 0.208079f, 0.119496f, -0.280853f, 0.194519f,
	0.690769f, -0.692410f, 0.208342f, 0.216158f, -0.216158f, 0.194519f,
	0.664409f, -0.665911f, 0.339299f, 0.203646f, -0.203646f, 0.252309f,

	0.690769f, -0.692410f, 0.208342f, 0.216158f, -0.216158f, 0.194519f,
	0.372924f, -0.904230f, 0.208079f, 0.119496f, -0.280853f, 0.194519f,
	0.382270f, -0.921554f, -0.067888f, 0.122120f, -0.287020f, 0.140010f,

	0.382270f, -0.921554f, -0.067888f, 0.122120f, -0.287020f, 0.140010f,
	0.706055f, -0.704874f, -0.068109f, 0.220904f, -0.220904f, 0.140010f,
	0.690769f, -0.692410f, 0.208342f, 0.216158f, -0.216158f, 0.194519f,

	0.329078f, -0.802376f, 0.497897f, 0.091590f, -0.215265f, 0.373359f,
	-0.002629f, -0.867772f, 0.496956f, 0.000000f, -0.233350f, 0.373359f,
	-0.000563f, -0.914880f, 0.403725f, 0.000000f, -0.261911f, 0.312287f,

	-0.000563f, -0.914880f, 0.403725f, 0.000000f, -0.261911f, 0.312287f,
	0.349116f, -0.845246f, 0.404570f, 0.102800f, -0.241612f, 0.312287f,
	0.329078f, -0.802376f, 0.497897f, 0.091590f, -0.215265f, 0.373359f,

	0.349116f, -0.845246f, 0.404570f, 0.102800f, -0.241612f, 0.312287f,
	-0.000563f, -0.914880f, 0.403725f, 0.000000f, -0.261911f, 0.312287f,
	-0.001052f, -0.941117f, 0.338080f, 0.000000f, -0.286825f, 0.252309f,

	-0.001052f, -0.941117f, 0.338080f, 0.000000f, -0.286825f, 0.252309f,
	0.358742f, -0.869764f, 0.338843f, 0.112579f, -0.264596f, 0.252309f,
	0.349116f, -0.845246f, 0.404570f, 0.102800f, -0.241612f, 0.312287f,

	0.358742f, -0.869764f, 0.338843f, 0.112579f, -0.264596f, 0.252309f,
	-0.001052f, -0.941117f, 0.338080f, 0.000000f, -0.286825f, 0.252309f,
	-0.001148f, -0.978226f, 0.207541f, 0.000000f, -0.304448f, 0.194519f,

	-0.001148f, -0.978226f, 0.207541f, 0.000000f, -0.304448f, 0.194519f,
	0.372924f, -0.904230f, 0.208079f, 0.119496f, -0.280853f, 0.194519f,
	0.358742f, -0.869764f, 0.338843f, 0.112579f, -0.264596f, 0.252309f,

	0.372924f, -0.904230f, 0.208079f, 0.119496f, -0.280853f, 0.194519f,
	-0.001148f, -0.978226f, 0.207541f, 0.000000f, -0.304448f, 0.194519f,
	0.000826f, -0.997695f, -0.067851f, 0.000000f, -0.311133f, 0.140010f,

	0.000826f, -0.997695f, -0.067851f, 0.000000f, -0.311133f, 0.140010f,
	0.382270f, -0.921554f, -0.067888f, 0.122120f, -0.287020f, 0.140010f,
	0.372924f, -0.904230f, 0.208079f, 0.119496f, -0.280853f, 0.194519f,

	-0.002629f, -0.867772f, 0.496956f, 0.000000f, -0.233350f, 0.373359f,
	-0.334163f, -0.800677f, 0.497243f, -0.091590f, -0.215265f, 0.373359f,
	-0.350176f, -0.844816f, 0.404552f, -0.102800f, -0.241612f, 0.312287f,

	-0.350176f, -0.844816f, 0.404552f, -0.102800f, -0.241612f, 0.312287f,
	-0.000563f, -0.914880f, 0.403725f, 0.000000f, -0.261911f, 0.312287f,
	-0.002629f, -0.867772f, 0.496956f, 0.000000f, -0.233350f, 0.373359f,

	-0.000563f, -0.914880f, 0.403725f, 0.000000f, -0.261911f, 0.312287f,
	-0.350176f, -0.844816f, 0.404552f, -0.102800f, -0.241612f, 0.312287f,
	-0.360724f, -0.868962f, 0.338796f, -0.112579f, -0.264596f, 0.252309f,

	-0.360724f, -0.868962f, 0.338796f, -0.112579f, -0.264596f, 0.252309f,
	-0.001052f, -0.941117f, 0.338080f, 0.000000f, -0.286825f, 0.252309f,
	-0.000563f, -0.914880f, 0.403725f, 0.000000f, -0.261911f, 0.312287f,

	-0.001052f, -0.941117f, 0.338080f, 0.000000f, -0.286825f, 0.252309f,
	-0.360724f, -0.868962f, 0.338796f, -0.112579f, -0.264596f, 0.252309f,
	-0.375090f, -0.903357f, 0.207976f, -0.119496f, -0.280853f, 0.194519f,

	-0.375090f, -0.903357f, 0.207976f, -0.119496f, -0.280853f, 0.194519f,
	-0.001148f, -0.978226f, 0.207541f, 0.000000f, -0.304448f, 0.194519f,
	-0.001052f, -0.941117f, 0.338080f, 0.000000f, -0.286825f, 0.252309f,

	-0.001148f, -0.978226f, 0.207541f, 0.000000f, -0.304448f, 0.194519f,
	-0.375090f, -0.903357f, 0.207976f, -0.119496f, -0.280853f, 0.194519f,
	-0.380711f, -0.922181f, -0.068131f, -0.122120f, -0.287020f, 0.140010f,

	-0.380711f, -0.922181f, -0.068131f, -0.122120f, -0.287020f, 0.140010f,
	0.000826f, -0.997695f, -0.067851f, 0.000000f, -0.311133f, 0.140010f,
	-0.001148f, -0.978226f, 0.207541f, 0.000000f, -0.304448f, 0.194519f,

	-0.334163f, -0.800677f, 0.497243f, -0.091590f, -0.215265f, 0.373359f,
	-0.615438f, -0.611722f, 0.497023f, -0.165678f, -0.165678f, 0.373359f,
	-0.646888f, -0.646085f, 0.405105f, -0.185956f, -0.185956f, 0.312287f,

	-0.646888f, -0.646085f, 0.405105f, -0.185956f, -0.185956f, 0.312287f,
	-0.350176f, -0.844816f, 0.404552f, -0.102800f, -0.241612f, 0.312287f,
	-0.334163f, -0.800677f, 0.497243f, -0.091590f, -0.215265f, 0.373359f,

	-0.350176f, -0.844816f, 0.404552f, -0.102800f, -0.241612f, 0.312287f,
	-0.646888f, -0.646085f, 0.405105f, -0.185956f, -0.185956f, 0.312287f,
	-0.665911f, -0.664409f, 0.339299f, -0.203646f, -0.203646f, 0.252309f,

	-0.665911f, -0.664409f, 0.339299f, -0.203646f, -0.203646f, 0.252309f,
	-0.360724f, -0.868962f, 0.338796f, -0.112579f, -0.264596f, 0.252309f,
	-0.350176f, -0.844816f, 0.404552f, -0.102800f, -0.241612f, 0.312287f,

	-0.360724f, -0.868962f, 0.338796f, -0.112579f, -0.264596f, 0.252309f,
	-0.665911f, -0.664409f, 0.339299f, -0.203646f, -0.203646f, 0.252309f,
	-0.692410f, -0.690769f, 0.208342f, -0.216158f, -0.216158f, 0.194519f,

	-0.692410f, -0.690769f, 0.208342f, -0.216158f, -0.216158f, 0.194519f,
	-0.375090f, -0.903357f, 0.207976f, -0.119496f, -0.280853f, 0.194519f,
	-0.360724f, -0.868962f, 0.338796f, -0.112579f, -0.264596f, 0.252309f,

	-0.375090f, -0.903357f, 0.207976f, -0.119496f, -0.280853f, 0.194519f,
	-0.692410f, -0.690769f, 0.208342f, -0.216158f, -0.216158f, 0.194519f,
	-0.704874f, -0.706055f, -0.068109f, -0.220904f, -0.220904f, 0.140010f,

	-0.704874f, -0.706055f, -0.068109f, -0.220904f, -0.220904f, 0.140010f,
	-0.380711f, -0.922181f, -0.068131f, -0.122120f, -0.287020f, 0.140010f,
	-0.375090f, -0.903357f, 0.207976f, -0.119496f, -0.280853f, 0.194519f,

	-0.615438f, -0.611722f, 0.497023f, -0.165678f, -0.165678f, 0.373359f,
	-0.802948f, -0.329317f, 0.496814f, -0.215265f, -0.091590f, 0.373359f,
	-0.845246f, -0.349116f, 0.404570f, -0.241612f, -0.102800f, 0.312287f,

	-0.845246f, -0.349116f, 0.404570f, -0.241612f, -0.102800f, 0.312287f,
	-0.646888f, -0.646085f, 0.405105f, -0.185956f, -0.185956f, 0.312287f,
	-0.615438f, -0.611722f, 0.497023f, -0.165678f, -0.165678f, 0.373359f,

	-0.646888f, -0.646085f, 0.405105f, -0.185956f, -0.185956f, 0.312287f,
	-0.845246f, -0.349116f, 0.404570f, -0.241612f, -0.102800f, 0.312287f,
	-0.869764f, -0.358742f, 0.338843f, -0.264596f, -0.112579f, 0.252309f,

	-0.869764f, -0.358742f, 0.338843f, -0.264596f, -0.112579f, 0.252309f,
	-0.665911f, -0.664409f, 0.339299f, -0.203646f, -0.203646f, 0.252309f,
	-0.646888f, -0.646085f, 0.405105f, -0.185956f, -0.185956f, 0.312287f,

	-0.665911f, -0.664409f, 0.339299f, -0.203646f, -0.203646f, 0.252309f,
	-0.869764f, -0.358742f, 0.338843f, -0.264596f, -0.112579f, 0.252309f,
	-0.904230f, -0.372924f, 0.208079f, -0.280853f, -0.119496f, 0.194519f,

	-0.904230f, -0.372924f, 0.208079f, -0.280853f, -0.119496f, 0.194519f,
	-0.692410f, -0.690769f, 0.208342f, -0.216158f, -0.216158f, 0.194519f,
	-0.665911f, -0.664409f, 0.339299f, -0.203646f, -0.203646f, 0.252309f,

	-0.692410f, -0.690769f, 0.208342f, -0.216158f, -0.216158f, 0.194519f,
	-0.904230f, -0.372924f, 0.208079f, -0.280853f, -0.119496f, 0.194519f,
	-0.921554f, -0.382270f, -0.067888f, -0.287020f, -0.122120f, 0.140010f,

	-0.921554f, -0.382270f, -0.067888f, -0.287020f, -0.122120f, 0.140010f,
	-0.704874f, -0.706055f, -0.068109f, -0.220904f, -0.220904f, 0.140010f,
	-0.692410f, -0.690769f, 0.208342f, -0.216158f, -0.216158f, 0.194519f,

	-0.802948f, -0.329317f, 0.496814f, -0.215265f, -0.091590f, 0.373359f,
	-0.867923f, 0.002642f, 0.496692f, -0.233350f, 0.000000f, 0.373359f,
	-0.914880f, 0.000563f, 0.403725f, -0.261911f, 0.000000f, 0.312287f,

	-0.914880f, 0.000563f, 0.403725f, -0.261911f, 0.000000f, 0.312287f,
	-0.845246f, -0.349116f, 0.404570f, -0.241612f, -0.102800f, 0.312287f,
	-0.802948f, -0.329317f, 0.496814f, -0.215265f, -0.091590f, 0.373359f,

	-0.845246f, -0.349116f, 0.404570f, -0.241612f, -0.102800f, 0.312287f,
	-0.914880f, 0.000563f, 0.403725f, -0.261911f, 0.000000f, 0.312287f,
	-0.941117f, 0.001052f, 0.338080f, -0.286825f, 0.000000f, 0.252309f,

	-0.941117f, 0.001052f, 0.338080f, -0.286825f, 0.000000f, 0.252309f,
	-0.869764f, -0.358742f, 0.338843f, -0.264596f, -0.112579f, 0.252309f,
	-0.845246f, -0.349116f, 0.404570f, -0.241612f, -0.102800f, 0.312287f,

	-0.869764f, -0.358742f, 0.338843f, -0.264596f, -0.112579f, 0.252309f,
	-0.941117f, 0.001052f, 0.338080f, -0.286825f, 0.000000f, 0.252309f,
	-0.978226f, 0.001148f, 0.207541f, -0.304448f, 0.000000f, 0.194519f,

	-0.978226f, 0.001148f, 0.207541f, -0.304448f, 0.000000f, 0.194519f,
	-0.904230f, -0.372924f, 0.208079f, -0.280853f, -0.119496f, 0.194519f,
	-0.869764f, -0.358742f, 0.338843f, -0.264596f, -0.112579f, 0.252309f,

	-0.904230f, -0.372924f, 0.208079f, -0.280853f, -0.119496f, 0.194519f,
	-0.978226f, 0.001148f, 0.207541f, -0.304448f, 0.000000f, 0.194519f,
	-0.997695f, -0.000826f, -0.067851f, -0.311133f, 0.000000f, 0.140010f,

	-0.997695f, -0.000826f, -0.067851f, -0.311133f, 0.000000f, 0.140010f,
	-0.921554f, -0.382270f, -0.067888f, -0.287020f, -0.122120f, 0.140010f,
	-0.904230f, -0.372924f, 0.208079f, -0.280853f, -0.119496f, 0.194519f,

	-0.867923f, 0.002642f, 0.496692f, -0.233350f, 0.000000f, 0.373359f,
	-0.800360f, 0.334021f, 0.497848f, -0.215265f, 0.091590f, 0.373359f,
	-0.844816f, 0.350176f, 0.404552f, -0.241612f, 0.102800f, 0.312287f,

	-0.844816f, 0.350176f, 0.404552f, -0.241612f, 0.102800f, 0.312287f,
	-0.914880f, 0.000563f, 0.403725f, -0.261911f, 0.000000f, 0.312287f,
	-0.867923f, 0.002642f, 0.496692f, -0.233350f, 0.000000f, 0.373359f,

	-0.914880f, 0.000563f, 0.403725f, -0.261911f, 0.000000f, 0.312287f,
	-0.844816f, 0.350176f, 0.404552f, -0.241612f, 0.102800f, 0.312287f,
	-0.868962f, 0.360724f, 0.338796f, -0.264596f, 0.112579f, 0.252309f,

	-0.868962f, 0.360724f, 0.338796f, -0.264596f, 0.112579f, 0.252309f,
	-0.941117f, 0.001052f, 0.338080f, -0.286825f, 0.000000f, 0.252309f,
	-0.914880f, 0.000563f, 0.403725f, -0.261911f, 0.000000f, 0.312287f,

	-0.941117f, 0.001052f, 0.338080f, -0.286825f, 0.000000f, 0.252309f,
	-0.868962f, 0.360724f, 0.338796f, -0.264596f, 0.112579f, 0.252309f,
	-0.903357f, 0.375090f, 0.207976f, -0.280853f, 0.119496f, 0.194519f,

	-0.903357f, 0.375090f, 0.207976f, -0.280853f, 0.119496f, 0.194519f,
	-0.978226f, 0.001148f, 0.207541f, -0.304448f, 0.000000f, 0.194519f,
	-0.941117f, 0.001052f, 0.338080f, -0.286825f, 0.000000f, 0.252309f,

	-0.978226f, 0.001148f, 0.207541f, -0.304448f, 0.000000f, 0.194519f,
	-0.903357f, 0.375090f, 0.207976f, -0.280853f, 0.119496f, 0.194519f,
	-0.922181f, 0.380711f, -0.068131f, -0.287020f, 0.122120f, 0.140010f,

	-0.922181f, 0.380711f, -0.068131f, -0.287020f, 0.122120f, 0.140010f,
	-0.997695f, -0.000826f, -0.067851f, -0.311133f, 0.000000f, 0.140010f,
	-0.978226f, 0.001148f, 0.207541f, -0.304448f, 0.000000f, 0.194519f,

	-0.800360f, 0.334021f, 0.497848f, -0.215265f, 0.091590f, 0.373359f,
	-0.611121f, 0.614869f, 0.498465f, -0.165678f, 0.165678f, 0.373359f,
	-0.646085f, 0.646888f, 0.405105f, -0.185956f, 0.185956f, 0.312287f,

	-0.646085f, 0.646888f, 0.405105f, -0.185956f, 0.185956f, 0.312287f,
	-0.844816f, 0.350176f, 0.404552f, -0.241612f, 0.102800f, 0.312287f,
	-0.800360f, 0.334021f, 0.497848f, -0.215265f, 0.091590f, 0.373359f,

	-0.844816f, 0.350176f, 0.404552f, -0.241612f, 0.102800f, 0.312287f,
	-0.646085f, 0.646888f, 0.405105f, -0.185956f, 0.185956f, 0.312287f,
	-0.664409f, 0.665911f, 0.339299f, -0.203646f, 0.203646f, 0.252309f,

	-0.664409f, 0.665911f, 0.339299f, -0.203646f, 0.203646f, 0.252309f,
	-0.868962f, 0.360724f, 0.338796f, -0.264596f, 0.112579f, 0.252309f,
	-0.844816f, 0.350176f, 0.404552f, -0.241612f, 0.102800f, 0.312287f,

	-0.868962f, 0.360724f, 0.338796f, -0.264596f, 0.112579f, 0.252309f,
	-0.664409f, 0.665911f, 0.339299f, -0.203646f, 0.203646f, 0.252309f,
	-0.690769f, 0.692410f, 0.208342f, -0.216158f, 0.216158f, 0.194519f,

	-0.690769f, 0.692410f, 0.208342f, -0.216158f, 0.216158f, 0.194519f,
	-0.903357f, 0.375090f, 0.207976f, -0.280853f, 0.119496f, 0.194519f,
	-0.868962f, 0.360724f, 0.338796f, -0.264596f, 0.112579f, 0.252309f,

	-0.903357f, 0.375090f, 0.207976f, -0.280853f, 0.119496f, 0.194519f,
	-0.690769f, 0.692410f, 0.208342f, -0.216158f, 0.216158f, 0.194519f,
	-0.706055f, 0.704874f, -0.068109f, -0.220904f, 0.220904f, 0.140010f,

	-0.706055f, 0.704874f, -0.068109f, -0.220904f, 0.220904f, 0.140010f,
	-0.922181f, 0.380711f, -0.068131f, -0.287020f, 0.122120f, 0.140010f,
	-0.903357f, 0.375090f, 0.207976f, -0.280853f, 0.119496f, 0.194519f,

	-0.611121f, 0.614869f, 0.498465f, -0.165678f, 0.165678f, 0.373359f,
	-0.329078f, 0.802376f, 0.497897f, -0.091590f, 0.215265f, 0.373359f,
	-0.349116f, 0.845246f, 0.404570f, -0.102800f, 0.241612f, 0.312287f,

	-0.349116f, 0.845246f, 0.404570f, -0.102800f, 0.241612f, 0.312287f,
	-0.646085f, 0.646888f, 0.405105f, -0.185956f, 0.185956f, 0.312287f,
	-0.611121f, 0.614869f, 0.498465f, -0.165678f, 0.165678f, 0.373359f,

	-0.646085f, 0.646888f, 0.405105f, -0.185956f, 0.185956f, 0.312287f,
	-0.349116f, 0.845246f, 0.404570f, -0.102800f, 0.241612f, 0.312287f,
	-0.358742f, 0.869764f, 0.338843f, -0.112579f, 0.264596f, 0.252309f,

	-0.358742f, 0.869764f, 0.338843f, -0.112579f, 0.264596f, 0.252309f,
	-0.664409f, 0.665911f, 0.339299f, -0.203646f, 0.203646f, 0.252309f,
	-0.646085f, 0.646888f, 0.405105f, -0.185956f, 0.185956f, 0.312287f,

	-0.664409f, 0.665911f, 0.339299f, -0.203646f, 0.203646f, 0.252309f,
	-0.358742f, 0.869764f, 0.338843f, -0.112579f, 0.264596f, 0.252309f,
	-0.372924f, 0.904230f, 0.208079f, -0.119496f, 0.280853f, 0.194519f,

	-0.372924f, 0.904230f, 0.208079f, -0.119496f, 0.280853f, 0.194519f,
	-0.690769f, 0.692410f, 0.208342f, -0.216158f, 0.216158f, 0.194519f,
	-0.664409f, 0.665911f, 0.339299f, -0.203646f, 0.203646f, 0.252309f,

	-0.690769f, 0.692410f, 0.208342f, -0.216158f, 0.216158f, 0.194519f,
	-0.372924f, 0.904230f, 0.208079f, -0.119496f, 0.280853f, 0.194519f,
	-0.382270f, 0.921554f, -0.067888f, -0.122120f, 0.287020f, 0.140010f,

	-0.382270f, 0.921554f, -0.067888f, -0.122120f, 0.287020f, 0.140010f,
	-0.706055f, 0.704874f, -0.068109f, -0.220904f, 0.220904f, 0.140010f,
	-0.690769f, 0.692410f, 0.208342f, -0.216158f, 0.216158f, 0.194519f,

	-0.329078f, 0.802376f, 0.497897f, -0.091590f, 0.215265f, 0.373359f,
	0.002629f, 0.867772f, 0.496956f, 0.000000f, 0.233350f, 0.373359f,
	0.000563f, 0.914880f, 0.403725f, 0.000000f, 0.261911f, 0.312287f,

	0.000563f, 0.914880f, 0.403725f, 0.000000f, 0.261911f, 0.312287f,
	-0.349116f, 0.845246f, 0.404570f, -0.102800f, 0.241612f, 0.312287f,
	-0.329078f, 0.802376f, 0.497897f, -0.091590f, 0.215265f, 0.373359f,

	-0.349116f, 0.845246f, 0.404570f, -0.102800f, 0.241612f, 0.312287f,
	0.000563f, 0.914880f, 0.403725f, 0.000000f, 0.261911f, 0.312287f,
	0.001052f, 0.941117f, 0.338080f, 0.000000f, 0.286825f, 0.252309f,

	0.001052f, 0.941117f, 0.338080f, 0.000000f, 0.286825f, 0.252309f,
	-0.358742f, 0.869764f, 0.338843f, -0.112579f, 0.264596f, 0.252309f,
	-0.349116f, 0.845246f, 0.404570f, -0.102800f, 0.241612f, 0.312287f,

	-0.358742f, 0.869764f, 0.338843f, -0.112579f, 0.264596f, 0.252309f,
	0.001052f, 0.941117f, 0.338080f, 0.000000f, 0.286825f, 0.252309f,
	0.001148f, 0.978226f, 0.207541f, 0.000000f, 0.304448f, 0.194519f,

	0.001148f, 0.978226f, 0.207541f, 0.000000f, 0.304448f, 0.194519f,
	-0.372924f, 0.904230f, 0.208079f, -0.119496f, 0.280853f, 0.194519f,
	-0.358742f, 0.869764f, 0.338843f, -0.112579f, 0.264596f, 0.252309f,

	-0.372924f, 0.904230f, 0.208079f, -0.119496f, 0.280853f, 0.194519f,
	0.001148f, 0.978226f, 0.207541f, 0.000000f, 0.304448f, 0.194519f,
	-0.000826f, 0.997695f, -0.067851f, 0.000000f, 0.311133f, 0.140010f,

	-0.000826f, 0.997695f, -0.067851f, 0.000000f, 0.311133f, 0.140010f,
	-0.382270f, 0.921554f, -0.067888f, -0.122120f, 0.287020f, 0.140010f,
	-0.372924f, 0.904230f, 0.208079f, -0.119496f, 0.280853f, 0.194519f,

	0.002629f, 0.867772f, 0.496956f, 0.000000f, 0.233350f, 0.373359f,
	0.334021f, 0.800360f, 0.497848f, 0.091590f, 0.215265f, 0.373359f,
	0.350176f, 0.844816f, 0.404552f, 0.102800f, 0.241612f, 0.312287f,

	0.350176f, 0.844816f, 0.404552f, 0.102800f, 0.241612f, 0.312287f,
	0.000563f, 0.914880f, 0.403725f, 0.000000f, 0.261911f, 0.312287f,
	0.002629f, 0.867772f, 0.496956f, 0.000000f, 0.233350f, 0.373359f,

	0.000563f, 0.914880f, 0.403725f, 0.000000f, 0.261911f, 0.312287f,
	0.350176f, 0.844816f, 0.404552f, 0.102800f, 0.241612f, 0.312287f,
	0.360724f, 0.868962f, 0.338796f, 0.112579f, 0.264596f, 0.252309f,

	0.360724f, 0.868962f, 0.338796f, 0.112579f, 0.264596f, 0.252309f,
	0.001052f, 0.941117f, 0.338080f, 0.000000f, 0.286825f, 0.252309f,
	0.000563f, 0.914880f, 0.403725f, 0.000000f, 0.261911f, 0.312287f,

	0.001052f, 0.941117f, 0.338080f, 0.000000f, 0.286825f, 0.252309f,
	0.360724f, 0.868962f, 0.338796f, 0.112579f, 0.264596f, 0.252309f,
	0.375090f, 0.903357f, 0.207976f, 0.119496f, 0.280853f, 0.194519f,

	0.375090f, 0.903357f, 0.207976f, 0.119496f, 0.280853f, 0.194519f,
	0.001148f, 0.978226f, 0.207541f, 0.000000f, 0.304448f, 0.194519f,
	0.001052f, 0.941117f, 0.338080f, 0.000000f, 0.286825f, 0.252309f,

	0.001148f, 0.978226f, 0.207541f, 0.000000f, 0.304448f, 0.194519f,
	0.375090f, 0.903357f, 0.207976f, 0.119496f, 0.280853f, 0.194519f,
	0.380711f, 0.922181f, -0.068131f, 0.122120f, 0.287020f, 0.140010f,

	0.380711f, 0.922181f, -0.068131f, 0.122120f, 0.287020f, 0.140010f,
	-0.000826f, 0.997695f, -0.067851f, 0.000000f, 0.311133f, 0.140010f,
	0.001148f, 0.978226f, 0.207541f, 0.000000f, 0.304448f, 0.194519f,

	0.334021f, 0.800360f, 0.497848f, 0.091590f, 0.215265f, 0.373359f,
	0.614869f, 0.611121f, 0.498465f, 0.165678f, 0.165678f, 0.373359f,
	0.646888f, 0.646085f, 0.405105f, 0.185956f, 0.185956f, 0.312287f,

	0.646888f, 0.646085f, 0.405105f, 0.185956f, 0.185956f, 0.312287f,
	0.350176f, 0.844816f, 0.404552f, 0.102800f, 0.241612f, 0.312287f,
	0.334021f, 0.800360f, 0.497848f, 0.091590f, 0.215265f, 0.373359f,

	0.350176f, 0.844816f, 0.404552f, 0.102800f, 0.241612f, 0.312287f,
	0.646888f, 0.646085f, 0.405105f, 0.185956f, 0.185956f, 0.312287f,
	0.665911f, 0.664409f, 0.339299f, 0.203646f, 0.203646f, 0.252309f,

	0.665911f, 0.664409f, 0.339299f, 0.203646f, 0.203646f, 0.252309f,
	0.360724f, 0.868962f, 0.338796f, 0.112579f, 0.264596f, 0.252309f,
	0.350176f, 0.844816f, 0.404552f, 0.102800f, 0.241612f, 0.312287f,

	0.360724f, 0.868962f, 0.338796f, 0.112579f, 0.264596f, 0.252309f,
	0.665911f, 0.664409f, 0.339299f, 0.203646f, 0.203646f, 0.252309f,
	0.692410f, 0.690769f, 0.208342f, 0.216158f, 0.216158f, 0.194519f,

	0.692410f, 0.690769f, 0.208342f, 0.216158f, 0.216158f, 0.194519f,
	0.375090f, 0.903357f, 0.207976f, 0.119496f, 0.280853f, 0.194519f,
	0.360724f, 0.868962f, 0.338796f, 0.112579f, 0.264596f, 0.252309f,

	0.375090f, 0.903357f, 0.207976f, 0.119496f, 0.280853f, 0.194519f,
	0.692410f, 0.690769f, 0.208342f, 0.216158f, 0.216158f, 0.194519f,
	0.704874f, 0.706055f, -0.068109f, 0.220904f, 0.220904f, 0.140010f,

	0.704874f, 0.706055f, -0.068109f, 0.220904f, 0.220904f, 0.140010f,
	0.380711f, 0.922181f, -0.068131f, 0.122120f, 0.287020f, 0.140010f,
	0.375090f, 0.903357f, 0.207976f, 0.119496f, 0.280853f, 0.194519f,

	0.614869f, 0.611121f, 0.498465f, 0.165678f, 0.165678f, 0.373359f,
	0.802376f, 0.329078f, 0.497897f, 0.215265f, 0.091590f, 0.373359f,
	0.845246f, 0.349116f, 0.404570f, 0.241612f, 0.102800f, 0.312287f,

	0.845246f, 0.349116f, 0.404570f, 0.241612f, 0.102800f, 0.312287f,
	0.646888f, 0.646085f, 0.405105f, 0.185956f, 0.185956f, 0.312287f,
	0.614869f, 0.611121f, 0.498465f, 0.165678f, 0.165678f, 0.373359f,

	0.646888f, 0.646085f, 0.405105f, 0.185956f, 0.185956f, 0.312287f,
	0.845246f, 0.349116f, 0.404570f, 0.241612f, 0.102800f, 0.312287f,
	0.869764f, 0.358742f, 0.338843f, 0.264596f, 0.112579f, 0.252309f,

	0.869764f, 0.358742f, 0.338843f, 0.264596f, 0.112579f, 0.252309f,
	0.665911f, 0.664409f, 0.339299f, 0.203646f, 0.203646f, 0.252309f,
	0.646888f, 0.646085f, 0.405105f, 0.185956f, 0.185956f, 0.312287f,

	0.665911f, 0.664409f, 0.339299f, 0.203646f, 0.203646f, 0.252309f,
	0.869764f, 0.358742f, 0.338843f, 0.264596f, 0.112579f, 0.252309f,
	0.904230f, 0.372924f, 0.208079f, 0.280853f, 0.119496f, 0.194519f,

	0.904230f, 0.372924f, 0.208079f, 0.280853f, 0.119496f, 0.194519f,
	0.692410f, 0.690769f, 0.208342f, 0.216158f, 0.216158f, 0.194519f,
	0.665911f, 0.664409f, 0.339299f, 0.203646f, 0.203646f, 0.252309f,

	0.692410f, 0.690769f, 0.208342f, 0.216158f, 0.216158f, 0.194519f,
	0.904230f, 0.372924f, 0.208079f, 0.280853f, 0.119496f, 0.194519f,
	0.921554f, 0.382270f, -0.067888f, 0.287020f, 0.122120f, 0.140010f,

	0.921554f, 0.382270f, -0.067888f, 0.287020f, 0.122120f, 0.140010f,
	0.704874f, 0.706055f, -0.068109f, 0.220904f, 0.220904f, 0.140010f,
	0.692410f, 0.690769f, 0.208342f, 0.216158f, 0.216158f, 0.194519f,

	0.802376f, 0.329078f, 0.497897f, 0.215265f, 0.091590f, 0.373359f,
	0.867772f, -0.002629f, 0.496956f, 0.233350f, 0.000000f, 0.373359f,
	0.914880f, -0.000563f, 0.403725f, 0.261911f, 0.000000f, 0.312287f,

	0.914880f, -0.000563f, 0.403725f, 0.261911f, 0.000000f, 0.312287f,
	0.845246f, 0.349116f, 0.404570f, 0.241612f, 0.102800f, 0.312287f,
	0.802376f, 0.329078f, 0.497897f, 0.215265f, 0.091590f, 0.373359f,

	0.845246f, 0.349116f, 0.404570f, 0.241612f, 0.102800f, 0.312287f,
	0.914880f, -0.000563f, 0.403725f, 0.261911f, 0.000000f, 0.312287f,
	0.941117f, -0.001052f, 0.338080f, 0.286825f, 0.000000f, 0.252309f,

	0.941117f, -0.001052f, 0.338080f, 0.286825f, 0.000000f, 0.252309f,
	0.869764f, 0.358742f, 0.338843f, 0.264596f, 0.112579f, 0.252309f,
	0.845246f, 0.349116f, 0.404570f, 0.241612f, 0.102800f, 0.312287f,

	0.869764f, 0.358742f, 0.338843f, 0.264596f, 0.112579f, 0.252309f,
	0.941117f, -0.001052f, 0.338080f, 0.286825f, 0.000000f, 0.252309f,
	0.978226f, -0.001148f, 0.207541f, 0.304448f, 0.000000f, 0.194519f,

	0.978226f, -0.001148f, 0.207541f, 0.304448f, 0.000000f, 0.194519f,
	0.904230f, 0.372924f, 0.208079f, 0.280853f, 0.119496f, 0.194519f,
	0.869764f, 0.358742f, 0.338843f, 0.264596f, 0.112579f, 0.252309f,

	0.904230f, 0.372924f, 0.208079f, 0.280853f, 0.119496f, 0.194519f,
	0.978226f, -0.001148f, 0.207541f, 0.304448f, 0.000000f, 0.194519f,
	0.997695f, 0.000826f, -0.067851f, 0.311133f, 0.000000f, 0.140010f,

	0.997695f, 0.000826f, -0.067851f, 0.311133f, 0.000000f, 0.140010f,
	0.921554f, 0.382270f, -0.067888f, 0.287020f, 0.122120f, 0.140010f,
	0.904230f, 0.372924f, 0.208079f, 0.280853f, 0.119496f, 0.194519f,

	0.997695f, 0.000826f, -0.067851f, 0.311133f, 0.000000f, 0.140010f,
	0.922181f, -0.380711f, -0.068131f, 0.287020f, -0.122120f, 0.140010f,
	0.829015f, -0.336542f, -0.446624f, 0.275808f, -0.117349f, 0.093887f,

	0.829015f, -0.336542f, -0.446624f, 0.275808f, -0.117349f, 0.093887f,
	0.895151f, 0.005877f, -0.445725f, 0.298979f, 0.000000f, 0.093887f,
	0.997695f, 0.000826f, -0.067851f, 0.311133f, 0.000000f, 0.140010f,

	0.895151f, 0.005877f, -0.445725f, 0.298979f, 0.000000f, 0.093887f,
	0.829015f, -0.336542f, -0.446624f, 0.275808f, -0.117349f, 0.093887f,
	0.669850f, -0.272366f, -0.690737f, 0.251142f, -0.106855f, 0.059796f,

	0.669850f, -0.272366f, -0.690737f, 0.251142f, -0.106855f, 0.059796f,
	0.723936f, 0.004286f, -0.689854f, 0.272241f, 0.000000f, 0.059796f,
	0.895151f, 0.005877f, -0.445725f, 0.298979f, 0.000000f, 0.093887f,

	0.723936f, 0.004286f, -0.689854f, 0.272241f, 0.000000f, 0.059796f,
	0.669850f, -0.272366f, -0.690737f, 0.251142f, -0.106855f, 0.059796f,
	0.642819f, -0.268850f, -0.717289f, 0.226477f, -0.096360f, 0.036643f,

	0.642819f, -0.268850f, -0.717289f, 0.226477f, -0.096360f, 0.036643f,
	0.697653f, -0.002711f, -0.716431f, 0.245503f, 0.000000f, 0.036643f,
	0.723936f, 0.004286f, -0.689854f, 0.272241f, 0.000000f, 0.059796f,

	0.697653f, -0.002711f, -0.716431f, 0.245503f, 0.000000f, 0.036643f,
	0.642819f, -0.268850f, -0.717289f, 0.226477f, -0.096360f, 0.036643f,
	0.735451f, -0.308230f, -0.603413f, 0.215265f, -0.091590f, 0.023335f,

	0.735451f, -0.308230f, -0.603413f, 0.215265f, -0.091590f, 0.023335f,
	0.798118f, -0.003633f, -0.602490f, 0.233350f, 0.000000f, 0.023335f,
	0.697653f, -0.002711f, -0.716431f, 0.245503f, 0.000000f, 0.036643f,

	0.922181f, -0.380711f, -0.068131f, 0.287020f, -0.122120f, 0.140010f,
	0.706055f, -0.704874f, -0.068109f, 0.220904f, -0.220904f, 0.140010f,
	0.636684f, -0.628300f, -0.447071f, 0.212275f, -0.212275f, 0.093887f,

	0.636684f, -0.628300f, -0.447071f, 0.212275f, -0.212275f, 0.093887f,
	0.829015f, -0.336542f, -0.446624f, 0.275808f, -0.117349f, 0.093887f,
	0.922181f, -0.380711f, -0.068131f, 0.287020f, -0.122120f, 0.140010f,

	0.829015f, -0.336542f, -0.446624f, 0.275808f, -0.117349f, 0.093887f,
	0.636684f, -0.628300f, -0.447071f, 0.212275f, -0.212275f, 0.093887f,
	0.513969f, -0.507875f, -0.691303f, 0.193291f, -0.193291f, 0.059796f,

	0.513969f, -0.507875f, -0.691303f, 0.193291f, -0.193291f, 0.059796f,
	0.669850f, -0.272366f, -0.690737f, 0.251142f, -0.106855f, 0.059796f,
	0.829015f, -0.336542f, -0.446624f, 0.275808f, -0.117349f, 0.093887f,

	0.669850f, -0.272366f, -0.690737f, 0.251142f, -0.106855f, 0.059796f,
	0.513969f, -0.507875f, -0.691303f, 0.193291f, -0.193291f, 0.059796f,
	0.490360f, -0.494214f, -0.717843f, 0.174307f, -0.174307f, 0.036643f,

	0.490360f, -0.494214f, -0.717843f, 0.174307f, -0.174307f, 0.036643f,
	0.642819f, -0.268850f, -0.717289f, 0.226477f, -0.096360f, 0.036643f,
	0.669850f, -0.272366f, -0.690737f, 0.251142f, -0.106855f, 0.059796f,

	0.642819f, -0.268850f, -0.717289f, 0.226477f, -0.096360f, 0.036643f,
	0.490360f, -0.494214f, -0.717843f, 0.174307f, -0.174307f, 0.036643f,
	0.560944f, -0.566117f, -0.604031f, 0.165678f, -0.165678f, 0.023335f,

	0.560944f, -0.566117f, -0.604031f, 0.165678f, -0.165678f, 0.023335f,
	0.735451f, -0.308230f, -0.603413f, 0.215265f, -0.091590f, 0.023335f,
	0.642819f, -0.268850f, -0.717289f, 0.226477f, -0.096360f, 0.036643f,

	0.706055f, -0.704874f, -0.068109f, 0.220904f, -0.220904f, 0.140010f,
	0.382270f, -0.921554f, -0.067888f, 0.122120f, -0.287020f, 0.140010f,
	0.347602f, -0.824517f, -0.446481f, 0.117349f, -0.275808f, 0.093887f,

	0.347602f, -0.824517f, -0.446481f, 0.117349f, -0.275808f, 0.093887f,
	0.636684f, -0.628300f, -0.447071f, 0.212275f, -0.212275f, 0.093887f,
	0.706055f, -0.704874f, -0.068109f, 0.220904f, -0.220904f, 0.140010f,

	0.636684f, -0.628300f, -0.447071f, 0.212275f, -0.212275f, 0.093887f,
	0.347602f, -0.824517f, -0.446481f, 0.117349f, -0.275808f, 0.093887f,
	0.280399f, -0.666533f, -0.690732f, 0.106855f, -0.251142f, 0.059796f,

	0.280399f, -0.666533f, -0.690732f, 0.106855f, -0.251142f, 0.059796f,
	0.513969f, -0.507875f, -0.691303f, 0.193291f, -0.193291f, 0.059796f,
	0.636684f, -0.628300f, -0.447071f, 0.212275f, -0.212275f, 0.093887f,

	0.513969f, -0.507875f, -0.691303f, 0.193291f, -0.193291f, 0.059796f,
	0.280399f, -0.666533f, -0.690732f, 0.106855f, -0.251142f, 0.059796f,
	0.263770f, -0.644922f, -0.717287f, 0.096360f, -0.226477f, 0.036643f,

	0.263770f, -0.644922f, -0.717287f, 0.096360f, -0.226477f, 0.036643f,
	0.490360f, -0.494214f, -0.717843f, 0.174307f, -0.174307f, 0.036643f,
	0.513969f, -0.507875f, -0.691303f, 0.193291f, -0.193291f, 0.059796f,

	0.490360f, -0.494214f, -0.717843f, 0.174307f, -0.174307f, 0.036643f,
	0.263770f, -0.644922f, -0.717287f, 0.096360f, -0.226477f, 0.036643f,
	0.301408f, -0.738250f, -0.603440f, 0.091590f, -0.215265f, 0.023335f,

	0.301408f, -0.738250f, -0.603440f, 0.091590f, -0.215265f, 0.023335f,
	0.560944f, -0.566117f, -0.604031f, 0.165678f, -0.165678f, 0.023335f,
	0.490360f, -0.494214f, -0.717843f, 0.174307f, -0.174307f, 0.036643f,

	0.382270f, -0.921554f, -0.067888f, 0.122120f, -0.287020f, 0.140010f,
	0.000826f, -0.997695f, -0.067851f, 0.000000f, -0.311133f, 0.140010f,
	0.005877f, -0.895151f, -0.445725f, 0.000000f, -0.298979f, 0.093887f,

	0.005877f, -0.895151f, -0.445725f, 0.000000f, -0.298979f, 0.093887f,
	0.347602f, -0.824517f, -0.446481f, 0.117349f, -0.275808f, 0.093887f,
	0.382270f, -0.921554f, -0.067888f, 0.122120f, -0.287020f, 0.140010f,

	0.347602f, -0.824517f, -0.446481f, 0.117349f, -0.275808f, 0.093887f,
	0.005877f, -0.895151f, -0.445725f, 0.000000f, -0.298979f, 0.093887f,
	0.004286f, -0.723936f, -0.689854f, 0.000000f, -0.272241f, 0.059796f,

	0.004286f, -0.723936f, -0.689854f, 0.000000f, -0.272241f, 0.059796f,
	0.280399f, -0.666533f, -0.690732f, 0.106855f, -0.251142f, 0.059796f,
	0.347602f, -0.824517f, -0.446481f, 0.117349f, -0.275808f, 0.093887f,

	0.280399f, -0.666533f, -0.690732f, 0.106855f, -0.251142f, 0.059796f,
	0.004286f, -0.723936f, -0.689854f, 0.000000f, -0.272241f, 0.059796f,
	-0.002711f, -0.697653f, -0.716431f, 0.000000f, -0.245503f, 0.036643f,

	-0.002711f, -0.697653f, -0.716431f, 0.000000f, -0.245503f, 0.036643f,
	0.263770f, -0.644922f, -0.717287f, 0.096360f, -0.226477f, 0.036643f,
	0.280399f, -0.666533f, -0.690732f, 0.106855f, -0.251142f, 0.059796f,

	0.263770f, -0.644922f, -0.717287f, 0.096360f, -0.226477f, 0.036643f,
	-0.002711f, -0.697653f, -0.716431f, 0.000000f, -0.245503f, 0.036643f,
	-0.003633f, -0.798118f, -0.602490f, 0.000000f, -0.233350f, 0.023335f,

	-0.003633f, -0.798118f, -0.602490f, 0.000000f, -0.233350f, 0.023335f,
	0.301408f, -0.738250f, -0.603440f, 0.091590f, -0.215265f, 0.023335f,
	0.263770f, -0.644922f, -0.717287f, 0.096360f, -0.226477f, 0.036643f,

	0.000826f, -0.997695f, -0.067851f, 0.000000f, -0.311133f, 0.140010f,
	-0.380711f, -0.922181f, -0.068131f, -0.122120f, -0.287020f, 0.140010f,
	-0.336542f, -0.829015f, -0.446624f, -0.117349f, -0.275808f, 0.093887f,

	-0.336542f, -0.829015f, -0.446624f, -0.117349f, -0.275808f, 0.093887f,
	0.005877f, -0.895151f, -0.445725f, 0.000000f, -0.298979f, 0.093887f,
	0.000826f, -0.997695f, -0.067851f, 0.000000f, -0.311133f, 0.140010f,

	0.005877f, -0.895151f, -0.445725f, 0.000000f, -0.298979f, 0.093887f,
	-0.336542f, -0.829015f, -0.446624f, -0.117349f, -0.275808f, 0.093887f,
	-0.272366f, -0.669850f, -0.690737f, -0.106855f, -0.251142f, 0.059796f,

	-0.272366f, -0.669850f, -0.690737f, -0.106855f, -0.251142f, 0.059796f,
	0.004286f, -0.723936f, -0.689854f, 0.000000f, -0.272241f, 0.059796f,
	0.005877f, -0.895151f, -0.445725f, 0.000000f, -0.298979f, 0.093887f,

	0.004286f, -0.723936f, -0.689854f, 0.000000f, -0.272241f, 0.059796f,
	-0.272366f, -0.669850f, -0.690737f, -0.106855f, -0.251142f, 0.059796f,
	-0.268850f, -0.642819f, -0.717289f, -0.096360f, -0.226477f, 0.036643f,

	-0.268850f, -0.642819f, -0.717289f, -0.096360f, -0.226477f, 0.036643f,
	-0.002711f, -0.697653f, -0.716431f, 0.000000f, -0.245503f, 0.036643f,
	0.004286f, -0.723936f, -0.689854f, 0.000000f, -0.272241f, 0.059796f,

	-0.002711f, -0.697653f, -0.716431f, 0.000000f, -0.245503f, 0.036643f,
	-0.268850f, -0.642819f, -0.717289f, -0.096360f, -0.226477f, 0.036643f,
	-0.308230f, -0.735451f, -0.603412f, -0.091590f, -0.215265f, 0.023335f,

	-0.308230f, -0.735451f, -0.603412f, -0.091590f, -0.215265f, 0.023335f,
	-0.003633f, -0.798118f, -0.602490f, 0.000000f, -0.233350f, 0.023335f,
	-0.002711f, -0.697653f, -0.716431f, 0.000000f, -0.245503f, 0.036643f,

	-0.380711f, -0.922181f, -0.068131f, -0.122120f, -0.287020f, 0.140010f,
	-0.704874f, -0.706055f, -0.068109f, -0.220904f, -0.220904f, 0.140010f,
	-0.628300f, -0.636684f, -0.447071f, -0.212275f, -0.212275f, 0.093887f,

	-0.628300f, -0.636684f, -0.447071f, -0.212275f, -0.212275f, 0.093887f,
	-0.336542f, -0.829015f, -0.446624f, -0.117349f, -0.275808f, 0.093887f,
	-0.380711f, -0.922181f, -0.068131f, -0.122120f, -0.287020f, 0.140010f,

	-0.336542f, -0.829015f, -0.446624f, -0.117349f, -0.275808f, 0.093887f,
	-0.628300f, -0.636684f, -0.447071f, -0.212275f, -0.212275f, 0.093887f,
	-0.507875f, -0.513969f, -0.691303f, -0.193291f, -0.193291f, 0.059796f,

	-0.507875f, -0.513969f, -0.691303f, -0.193291f, -0.193291f, 0.059796f,
	-0.272366f, -0.669850f, -0.690737f, -0.106855f, -0.251142f, 0.059796f,
	-0.336542f, -0.829015f, -0.446624f, -0.117349f, -0.275808f, 0.093887f,

	-0.272366f, -0.669850f, -0.690737f, -0.106855f, -0.251142f, 0.059796f,
	-0.507875f, -0.513969f, -0.691303f, -0.193291f, -0.193291f, 0.059796f,
	-0.494214f, -0.490360f, -0.717843f, -0.174307f, -0.174307f, 0.036643f,

	-0.494214f, -0.490360f, -0.717843f, -0.174307f, -0.174307f, 0.036643f,
	-0.268850f, -0.642819f, -0.717289f, -0.096360f, -0.226477f, 0.036643f,
	-0.272366f, -0.669850f, -0.690737f, -0.106855f, -0.251142f, 0.059796f,

	-0.268850f, -0.642819f, -0.717289f, -0.096360f, -0.226477f, 0.036643f,
	-0.494214f, -0.490360f, -0.717843f, -0.174307f, -0.174307f, 0.036643f,
	-0.566117f, -0.560944f, -0.604031f, -0.165678f, -0.165678f, 0.023335f,

	-0.566117f, -0.560944f, -0.604031f, -0.165678f, -0.165678f, 0.023335f,
	-0.308230f, -0.735451f, -0.603412f, -0.091590f, -0.215265f, 0.023335f,
	-0.268850f, -0.642819f, -0.717289f, -0.096360f, -0.226477f, 0.036643f,

	-0.704874f, -0.706055f, -0.068109f, -0.220904f, -0.220904f, 0.140010f,
	-0.921554f, -0.382270f, -0.067888f, -0.287020f, -0.122120f, 0.140010f,
	-0.824517f, -0.347602f, -0.446481f, -0.275808f, -0.117349f, 0.093887f,

	-0.824517f, -0.347602f, -0.446481f, -0.275808f, -0.117349f, 0.093887f,
	-0.628300f, -0.636684f, -0.447071f, -0.212275f, -0.212275f, 0.093887f,
	-0.704874f, -0.706055f, -0.068109f, -0.220904f, -0.220904f, 0.140010f,

	-0.628300f, -0.636684f, -0.447071f, -0.212275f, -0.212275f, 0.093887f,
	-0.824517f, -0.347602f, -0.446481f, -0.275808f, -0.117349f, 0.093887f,
	-0.666533f, -0.280399f, -0.690732f, -0.251142f, -0.106855f, 0.059796f,

	-0.666533f, -0.280399f, -0.690732f, -0.251142f, -0.106855f, 0.059796f,
	-0.507875f, -0.513969f, -0.691303f, -0.193291f, -0.193291f, 0.059796f,
	-0.628300f, -0.636684f, -0.447071f, -0.212275f, -0.212275f, 0.093887f,

	-0.507875f, -0.513969f, -0.691303f, -0.193291f, -0.193291f, 0.059796f,
	-0.666533f, -0.280399f, -0.690732f, -0.251142f, -0.106855f, 0.059796f,
	-0.644922f, -0.263770f, -0.717287f, -0.226477f, -0.096360f, 0.036643f,

	-0.644922f, -0.263770f, -0.717287f, -0.226477f, -0.096360f, 0.036643f,
	-0.494214f, -0.490360f, -0.717843f, -0.174307f, -0.174307f, 0.036643f,
	-0.507875f, -0.513969f, -0.691303f, -0.193291f, -0.193291f, 0.059796f,

	-0.494214f, -0.490360f, -0.717843f, -0.174307f, -0.174307f, 0.036643f,
	-0.644922f, -0.263770f, -0.717287f, -0.226477f, -0.096360f, 0.036643f,
	-0.738250f, -0.301408f, -0.603440f, -0.215265f, -0.091590f, 0.023335f,

	-0.738250f, -0.301408f, -0.603440f, -0.215265f, -0.091590f, 0.023335f,
	-0.566117f, -0.560944f, -0.604031f, -0.165678f, -0.165678f, 0.023335f,
	-0.494214f, -0.490360f, -0.717843f, -0.174307f, -0.174307f, 0.036643f,

	-0.921554f, -0.382270f, -0.067888f, -0.287020f, -0.122120f, 0.140010f,
	-0.997695f, -0.000826f, -0.067851f, -0.311133f, 0.000000f, 0.140010f,
	-0.895151f, -0.005877f, -0.445725f, -0.298979f, 0.000000f, 0.093887f,

	-0.895151f, -0.005877f, -0.445725f, -0.298979f, 0.000000f, 0.093887f,
	-0.824517f, -0.347602f, -0.446481f, -0.275808f, -0.117349f, 0.093887f,
	-0.921554f, -0.382270f, -0.067888f, -0.287020f, -0.122120f, 0.140010f,

	-0.824517f, -0.347602f, -0.446481f, -0.275808f, -0.117349f, 0.093887f,
	-0.895151f, -0.005877f, -0.445725f, -0.298979f, 0.000000f, 0.093887f,
	-0.723936f, -0.004286f, -0.689854f, -0.272241f, 0.000000f, 0.059796f,

	-0.723936f, -0.004286f, -0.689854f, -0.272241f, 0.000000f, 0.059796f,
	-0.666533f, -0.280399f, -0.690732f, -0.251142f, -0.106855f, 0.059796f,
	-0.824517f, -0.347602f, -0.446481f, -0.275808f, -0.117349f, 0.093887f,

	-0.666533f, -0.280399f, -0.690732f, -0.251142f, -0.106855f, 0.059796f,
	-0.723936f, -0.004286f, -0.689854f, -0.272241f, 0.000000f, 0.059796f,
	-0.697653f, 0.002711f, -0.716431f, -0.245503f, 0.000000f, 0.036643f,

	-0.697653f, 0.002711f, -0.716431f, -0.245503f, 0.000000f, 0.036643f,
	-0.644922f, -0.263770f, -0.717287f, -0.226477f, -0.096360f, 0.036643f,
	-0.666533f, -0.280399f, -0.690732f, -0.251142f, -0.106855f, 0.059796f,

	-0.644922f, -0.263770f, -0.717287f, -0.226477f, -0.096360f, 0.036643f,
	-0.697653f, 0.002711f, -0.716431f, -0.245503f, 0.000000f, 0.036643f,
	-0.798118f, 0.003633f, -0.602490f, -0.233350f, 0.000000f, 0.023335f,

	-0.798118f, 0.003633f, -0.602490f, -0.233350f, 0.000000f, 0.023335f,
	-0.738250f, -0.301408f, -0.603440f, -0.215265f, -0.091590f, 0.023335f,
	-0.644922f, -0.263770f, -0.717287f, -0.226477f, -0.096360f, 0.036643f,

	-0.997695f, -0.000826f, -0.067851f, -0.311133f, 0.000000f, 0.140010f,
	-0.922181f, 0.380711f, -0.068131f, -0.287020f, 0.122120f, 0.140010f,
	-0.829015f, 0.336542f, -0.446624f, -0.275808f, 0.117349f, 0.093887f,

	-0.829015f, 0.336542f, -0.446624f, -0.275808f, 0.117349f, 0.093887f,
	-0.895151f, -0.005877f, -0.445725f, -0.298979f, 0.000000f, 0.093887f,
	-0.997695f, -0.000826f, -0.067851f, -0.311133f, 0.000000f, 0.140010f,

	-0.895151f, -0.005877f, -0.445725f, -0.298979f, 0.000000f, 0.093887f,
	-0.829015f, 0.336542f, -0.446624f, -0.275808f, 0.117349f, 0.093887f,
	-0.669850f, 0.272366f, -0.690737f, -0.251142f, 0.106855f, 0.059796f,

	-0.669850f, 0.272366f, -0.690737f, -0.251142f, 0.106855f, 0.059796f,
	-0.723936f, -0.004286f, -0.689854f, -0.272241f, 0.000000f, 0.059796f,
	-0.895151f, -0.005877f, -0.445725f, -0.298979f, 0.000000f, 0.093887f,

	-0.723936f, -0.004286f, -0.689854f, -0.272241f, 0.000000f, 0.059796f,
	-0.669850f, 0.272366f, -0.690737f, -0.251142f, 0.106855f, 0.059796f,
	-0.642819f, 0.268850f, -0.717289f, -0.226477f, 0.096360f, 0.036643f,

	-0.642819f, 0.268850f, -0.717289f, -0.226477f, 0.096360f, 0.036643f,
	-0.697653f, 0.002711f, -0.716431f, -0.245503f, 0.000000f, 0.036643f,
	-0.723936f, -0.004286f, -0.689854f, -0.272241f, 0.000000f, 0.059796f,

	-0.697653f, 0.002711f, -0.716431f, -0.245503f, 0.000000f, 0.036643f,
	-0.642819f, 0.268850f, -0.717289f, -0.226477f, 0.096360f, 0.036643f,
	-0.735451f, 0.308230f, -0.603413f, -0.215265f, 0.091590f, 0.023335f,

	-0.735451f, 0.308230f, -0.603413f, -0.215265f, 0.091590f, 0.023335f,
	-0.798118f, 0.003633f, -0.602490f, -0.233350f, 0.000000f, 0.023335f,
	-0.697653f, 0.002711f, -0.716431f, -0.245503f, 0.000000f, 0.036643f,

	-0.922181f, 0.380711f, -0.068131f, -0.287020f, 0.122120f, 0.140010f,
	-0.706055f, 0.704874f, -0.068109f, -0.220904f, 0.220904f, 0.140010f,
	-0.636684f, 0.628300f, -0.447071f, -0.212275f, 0.212275f, 0.093887f,

	-0.636684f, 0.628300f, -0.447071f, -0.212275f, 0.212275f, 0.093887f,
	-0.829015f, 0.336542f, -0.446624f, -0.275808f, 0.117349f, 0.093887f,
	-0.922181f, 0.380711f, -0.068131f, -0.287020f, 0.122120f, 0.140010f,

	-0.829015f, 0.336542f, -0.446624f, -0.275808f, 0.117349f, 0.093887f,
	-0.636684f, 0.628300f, -0.447071f, -0.212275f, 0.212275f, 0.093887f,
	-0.513969f, 0.507875f, -0.691303f, -0.193291f, 0.193291f, 0.059796f,

	-0.513969f, 0.507875f, -0.691303f, -0.193291f, 0.193291f, 0.059796f,
	-0.669850f, 0.272366f, -0.690737f, -0.251142f, 0.106855f, 0.059796f,
	-0.829015f, 0.336542f, -0.446624f, -0.275808f, 0.117349f, 0.093887f,

	-0.669850f, 0.272366f, -0.690737f, -0.251142f, 0.106855f, 0.059796f,
	-0.513969f, 0.507875f, -0.691303f, -0.193291f, 0.193291f, 0.059796f,
	-0.490360f, 0.494214f, -0.717843f, -0.174307f, 0.174307f, 0.036643f,

	-0.490360f, 0.494214f, -0.717843f, -0.174307f, 0.174307f, 0.036643f,
	-0.642819f, 0.268850f, -0.717289f, -0.226477f, 0.096360f, 0.036643f,
	-0.669850f, 0.272366f, -0.690737f, -0.251142f, 0.106855f, 0.059796f,

	-0.642819f, 0.268850f, -0.717289f, -0.226477f, 0.096360f, 0.036643f,
	-0.490360f, 0.494214f, -0.717843f, -0.174307f, 0.174307f, 0.036643f,
	-0.560944f, 0.566117f, -0.604031f, -0.165678f, 0.165678f, 0.023335f,

	-0.560944f, 0.566117f, -0.604031f, -0.165678f, 0.165678f, 0.023335f,
	-0.735451f, 0.308230f, -0.603413f, -0.215265f, 0.091590f, 0.023335f,
	-0.642819f, 0.268850f, -0.717289f, -0.226477f, 0.096360f, 0.036643f,

	-0.706055f, 0.704874f, -0.068109f, -0.220904f, 0.220904f, 0.140010f,
	-0.382270f, 0.921554f, -0.067888f, -0.122120f, 0.287020f, 0.140010f,
	-0.347602f, 0.824517f, -0.446481f, -0.117349f, 0.275808f, 0.093887f,

	-0.347602f, 0.824517f, -0.446481f, -0.117349f, 0.275808f, 0.093887f,
	-0.636684f, 0.628300f, -0.447071f, -0.212275f, 0.212275f, 0.093887f,
	-0.706055f, 0.704874f, -0.068109f, -0.220904f, 0.220904f, 0.140010f,

	-0.636684f, 0.628300f, -0.447071f, -0.212275f, 0.212275f, 0.093887f,
	-0.347602f, 0.824517f, -0.446481f, -0.117349f, 0.275808f, 0.093887f,
	-0.280399f, 0.666533f, -0.690732f, -0.106855f, 0.251142f, 0.059796f,

	-0.280399f, 0.666533f, -0.690732f, -0.106855f, 0.251142f, 0.059796f,
	-0.513969f, 0.507875f, -0.691303f, -0.193291f, 0.193291f, 0.059796f,
	-0.636684f, 0.628300f, -0.447071f, -0.212275f, 0.212275f, 0.093887f,

	-0.513969f, 0.507875f, -0.691303f, -0.193291f, 0.193291f, 0.059796f,
	-0.280399f, 0.666533f, -0.690732f, -0.106855f, 0.251142f, 0.059796f,
	-0.263770f, 0.644922f, -0.717287f, -0.096360f, 0.226477f, 0.036643f,

	-0.263770f, 0.644922f, -0.717287f, -0.096360f, 0.226477f, 0.036643f,
	-0.490360f, 0.494214f, -0.717843f, -0.174307f, 0.174307f, 0.036643f,
	-0.513969f, 0.507875f, -0.691303f, -0.193291f, 0.193291f, 0.059796f,

	-0.490360f, 0.494214f, -0.717843f, -0.174307f, 0.174307f, 0.036643f,
	-0.263770f, 0.644922f, -0.717287f, -0.096360f, 0.226477f, 0.036643f,
	-0.301408f, 0.738250f, -0.603440f, -0.091590f, 0.215265f, 0.023335f,

	-0.301408f, 0.738250f, -0.603440f, -0.091590f, 0.215265f, 0.023335f,
	-0.560944f, 0.566117f, -0.604031f, -0.165678f, 0.165678f, 0.023335f,
	-0.490360f, 0.494214f, -0.717843f, -0.174307f, 0.174307f, 0.036643f,

	-0.382270f, 0.921554f, -0.067888f, -0.122120f, 0.287020f, 0.140010f,
	-0.000826f, 0.997695f, -0.067851f, 0.000000f, 0.311133f, 0.140010f,
	-0.005877f, 0.895151f, -0.445725f, 0.000000f, 0.298979f, 0.093887f,

	-0.005877f, 0.895151f, -0.445725f, 0.000000f, 0.298979f, 0.093887f,
	-0.347602f, 0.824517f, -0.446481f, -0.117349f, 0.275808f, 0.093887f,
	-0.382270f, 0.921554f, -0.067888f, -0.122120f, 0.287020f, 0.140010f,

	-0.347602f, 0.824517f, -0.446481f, -0.117349f, 0.275808f, 0.093887f,
	-0.005877f, 0.895151f, -0.445725f, 0.000000f, 0.298979f, 0.093887f,
	-0.004286f, 0.723936f, -0.689854f, 0.000000f, 0.272241f, 0.059796f,

	-0.004286f, 0.723936f, -0.689854f, 0.000000f, 0.272241f, 0.059796f,
	-0.280399f, 0.666533f, -0.690732f, -0.106855f, 0.251142f, 0.059796f,
	-0.347602f, 0.824517f, -0.446481f, -0.117349f, 0.275808f, 0.093887f,

	-0.280399f, 0.666533f, -0.690732f, -0.106855f, 0.251142f, 0.059796f,
	-0.004286f, 0.723936f, -0.689854f, 0.000000f, 0.272241f, 0.059796f,
	0.002711f, 0.697653f, -0.716431f, 0.000000f, 0.245503f, 0.036643f,

	0.002711f, 0.697653f, -0.716431f, 0.000000f, 0.245503f, 0.036643f,
	-0.263770f, 0.644922f, -0.717287f, -0.096360f, 0.226477f, 0.036643f,
	-0.280399f, 0.666533f, -0.690732f, -0.106855f, 0.251142f, 0.059796f,

	-0.263770f, 0.644922f, -0.717287f, -0.096360f, 0.226477f, 0.036643f,
	0.002711f, 0.697653f, -0.716431f, 0.000000f, 0.245503f, 0.036643f,
	0.003633f, 0.798118f, -0.602490f, 0.000000f, 0.233350f, 0.023335f,

	0.003633f, 0.798118f, -0.602490f, 0.000000f, 0.233350f, 0.023335f,
	-0.301408f, 0.738250f, -0.603440f, -0.091590f, 0.215265f, 0.023335f,
	-0.263770f, 0.644922f, -0.717287f, -0.096360f, 0.226477f, 0.036643f,

	-0.000826f, 0.997695f, -0.067851f, 0.000000f, 0.311133f, 0.140010f,
	0.380711f, 0.922181f, -0.068131f, 0.122120f, 0.287020f, 0.140010f,
	0.336542f, 0.829015f, -0.446624f, 0.117349f, 0.275808f, 0.093887f,

	0.336542f, 0.829015f, -0.446624f, 0.117349f, 0.275808f, 0.093887f,
	-0.005877f, 0.895151f, -0.445725f, 0.000000f, 0.298979f, 0.093887f,
	-0.000826f, 0.997695f, -0.067851f, 0.000000f, 0.311133f, 0.140010f,

	-0.005877f, 0.895151f, -0.445725f, 0.000000f, 0.298979f, 0.093887f,
	0.336542f, 0.829015f, -0.446624f, 0.117349f, 0.275808f, 0.093887f,
	0.272366f, 0.669850f, -0.690737f, 0.106855f, 0.251142f, 0.059796f,

	0.272366f, 0.669850f, -0.690737f, 0.106855f, 0.251142f, 0.059796f,
	-0.004286f, 0.723936f, -0.689854f, 0.000000f, 0.272241f, 0.059796f,
	-0.005877f, 0.895151f, -0.445725f, 0.000000f, 0.298979f, 0.093887f,

	-0.004286f, 0.723936f, -0.689854f, 0.000000f, 0.272241f, 0.059796f,
	0.272366f, 0.669850f, -0.690737f, 0.106855f, 0.251142f, 0.059796f,
	0.268850f, 0.642819f, -0.717289f, 0.096360f, 0.226477f, 0.036643f,

	0.268850f, 0.642819f, -0.717289f, 0.096360f, 0.226477f, 0.036643f,
	0.002711f, 0.697653f, -0.716431f, 0.000000f, 0.245503f, 0.036643f,
	-0.004286f, 0.723936f, -0.689854f, 0.000000f, 0.272241f, 0.059796f,

	0.002711f, 0.697653f, -0.716431f, 0.000000f, 0.245503f, 0.036643f,
	0.268850f, 0.642819f, -0.717289f, 0.096360f, 0.226477f, 0.036643f,
	0.308230f, 0.735451f, -0.603412f, 0.091590f, 0.215265f, 0.023335f,

	0.308230f, 0.735451f, -0.603412f, 0.091590f, 0.215265f, 0.023335f,
	0.003633f, 0.798118f, -0.602490f, 0.000000f, 0.233350f, 0.023335f,
	0.002711f, 0.697653f, -0.716431f, 0.000000f, 0.245503f, 0.036643f,

	0.380711f, 0.922181f, -0.068131f, 0.122120f, 0.287020f, 0.140010f,
	0.704874f, 0.706055f, -0.068109f, 0.220904f, 0.220904f, 0.140010f,
	0.628300f, 0.636684f, -0.447071f, 0.212275f, 0.212275f, 0.093887f,

	0.628300f, 0.636684f, -0.447071f, 0.212275f, 0.212275f, 0.093887f,
	0.336542f, 0.829015f, -0.446624f, 0.117349f, 0.275808f, 0.093887f,
	0.380711f, 0.922181f, -0.068131f, 0.122120f, 0.287020f, 0.140010f,

	0.336542f, 0.829015f, -0.446624f, 0.117349f, 0.275808f, 0.093887f,
	0.628300f, 0.636684f, -0.447071f, 0.212275f, 0.212275f, 0.093887f,
	0.507875f, 0.513969f, -0.691303f, 0.193291f, 0.193291f, 0.059796f,

	0.507875f, 0.513969f, -0.691303f, 0.193291f, 0.193291f, 0.059796f,
	0.272366f, 0.669850f, -0.690737f, 0.106855f, 0.251142f, 0.059796f,
	0.336542f, 0.829015f, -0.446624f, 0.117349f, 0.275808f, 0.093887f,

	0.272366f, 0.669850f, -0.690737f, 0.106855f, 0.251142f, 0.059796f,
	0.507875f, 0.513969f, -0.691303f, 0.193291f, 0.193291f, 0.059796f,
	0.494214f, 0.490360f, -0.717843f, 0.174307f, 0.174307f, 0.036643f,

	0.494214f, 0.490360f, -0.717843f, 0.174307f, 0.174307f, 0.036643f,
	0.268850f, 0.642819f, -0.717289f, 0.096360f, 0.226477f, 0.036643f,
	0.272366f, 0.669850f, -0.690737f, 0.106855f, 0.251142f, 0.059796f,

	0.268850f, 0.642819f, -0.717289f, 0.096360f, 0.226477f, 0.036643f,
	0.494214f, 0.490360f, -0.717843f, 0.174307f, 0.174307f, 0.036643f,
	0.566117f, 0.560944f, -0.604031f, 0.165678f, 0.165678f, 0.023335f,

	0.566117f, 0.560944f, -0.604031f, 0.165678f, 0.165678f, 0.023335f,
	0.308230f, 0.735451f, -0.603412f, 0.091590f, 0.215265f, 0.023335f,
	0.268850f, 0.642819f, -0.717289f, 0.096360f, 0.226477f, 0.036643f,

	0.704874f, 0.706055f, -0.068109f, 0.220904f, 0.220904f, 0.140010f,
	0.921554f, 0.382270f, -0.067888f, 0.287020f, 0.122120f, 0.140010f,
	0.824517f, 0.347602f, -0.446481f, 0.275808f, 0.117349f, 0.093887f,

	0.824517f, 0.347602f, -0.446481f, 0.275808f, 0.117349f, 0.093887f,
	0.628300f, 0.636684f, -0.447071f, 0.212275f, 0.212275f, 0.093887f,
	0.704874f, 0.706055f, -0.068109f, 0.220904f, 0.220904f, 0.140010f,

	0.628300f, 0.636684f, -0.447071f, 0.212275f, 0.212275f, 0.093887f,
	0.824517f, 0.347602f, -0.446481f, 0.275808f, 0.117349f, 0.093887f,
	0.666533f, 0.280399f, -0.690732f, 0.251142f, 0.106855f, 0.059796f,

	0.666533f, 0.280399f, -0.690732f, 0.251142f, 0.106855f, 0.059796f,
	0.507875f, 0.513969f, -0.691303f, 0.193291f, 0.193291f, 0.059796f,
	0.628300f, 0.636684f, -0.447071f, 0.212275f, 0.212275f, 0.093887f,

	0.507875f, 0.513969f, -0.691303f, 0.193291f, 0.193291f, 0.059796f,
	0.666533f, 0.280399f, -0.690732f, 0.251142f, 0.106855f, 0.059796f,
	0.644922f, 0.263770f, -0.717287f, 0.226477f, 0.096360f, 0.036643f,

	0.644922f, 0.263770f, -0.717287f, 0.226477f, 0.096360f, 0.036643f,
	0.494214f, 0.490360f, -0.717843f, 0.174307f, 0.174307f, 0.036643f,
	0.507875f, 0.513969f, -0.691303f, 0.193291f, 0.193291f, 0.059796f,

	0.494214f, 0.490360f, -0.717843f, 0.174307f, 0.174307f, 0.036643f,
	0.644922f, 0.263770f, -0.717287f, 0.226477f, 0.096360f, 0.036643f,
	0.738250f, 0.301408f, -0.603440f, 0.215265f, 0.091590f, 0.023335f,

	0.738250f, 0.301408f, -0.603440f, 0.215265f, 0.091590f, 0.023335f,
	0.566117f, 0.560944f, -0.604031f, 0.165678f, 0.165678f, 0.023335f,
	0.494214f, 0.490360f, -0.717843f, 0.174307f, 0.174307f, 0.036643f,

	0.921554f, 0.382270f, -0.067888f, 0.287020f, 0.122120f, 0.140010f,
	0.997695f, 0.000826f, -0.067851f, 0.311133f, 0.000000f, 0.140010f,
	0.895151f, 0.005877f, -0.445725f, 0.298979f, 0.000000f, 0.093887f,

	0.895151f, 0.005877f, -0.445725f, 0.298979f, 0.000000f, 0.093887f,
	0.824517f, 0.347602f, -0.446481f, 0.275808f, 0.117349f, 0.093887f,
	0.921554f, 0.382270f, -0.067888f, 0.287020f, 0.122120f, 0.140010f,

	0.824517f, 0.347602f, -0.446481f, 0.275808f, 0.117349f, 0.093887f,
	0.895151f, 0.005877f, -0.445725f, 0.298979f, 0.000000f, 0.093887f,
	0.723936f, 0.004286f, -0.689854f, 0.272241f, 0.000000f, 0.059796f,

	0.723936f, 0.004286f, -0.689854f, 0.272241f, 0.000000f, 0.059796f,
	0.666533f, 0.280399f, -0.690732f, 0.251142f, 0.106855f, 0.059796f,
	0.824517f, 0.347602f, -0.446481f, 0.275808f, 0.117349f, 0.093887f,

	0.666533f, 0.280399f, -0.690732f, 0.251142f, 0.106855f, 0.059796f,
	0.723936f, 0.004286f, -0.689854f, 0.272241f, 0.000000f, 0.059796f,
	0.697653f, -0.002711f, -0.716431f, 0.245503f, 0.000000f, 0.036643f,

	0.697653f, -0.002711f, -0.716431f, 0.245503f, 0.000000f, 0.036643f,
	0.644922f, 0.263770f, -0.717287f, 0.226477f, 0.096360f, 0.036643f,
	0.666533f, 0.280399f, -0.690732f, 0.251142f, 0.106855f, 0.059796f,

	0.644922f, 0.263770f, -0.717287f, 0.226477f, 0.096360f, 0.036643f,
	0.697653f, -0.002711f, -0.716431f, 0.245503f, 0.000000f, 0.036643f,
	0.798118f, -0.003633f, -0.602490f, 0.233350f, 0.000000f, 0.023335f,

	0.798118f, -0.003633f, -0.602490f, 0.233350f, 0.000000f, 0.023335f,
	0.738250f, 0.301408f, -0.603440f, 0.215265f, 0.091590f, 0.023335f,
	0.644922f, 0.263770f, -0.717287f, 0.226477f, 0.096360f, 0.036643f,

	0.798118f, -0.003633f, -0.602490f, 0.233350f, 0.000000f, 0.023335f,
	0.735451f, -0.308230f, -0.603413f, 0.215265f, -0.091590f, 0.023335f,
	0.556004f, -0.207146f, -0.804954f, 0.210388f, -0.089515f, 0.014767f,

	0.556004f, -0.207146f, -0.804954f, 0.210388f, -0.089515f, 0.014767f,
	0.593653f, 0.020841f, -0.804452f, 0.228063f, 0.000000f, 0.014767f,
	0.798118f, -0.003633f, -0.602490f, 0.233350f, 0.000000f, 0.023335f,

	0.593653f, 0.020841f, -0.804452f, 0.228063f, 0.000000f, 0.014767f,
	0.556004f, -0.207146f, -0.804954f, 0.210388f, -0.089515f, 0.014767f,
	0.155628f, -0.057830f, -0.986122f, 0.184321f, -0.078424f, 0.007292f,

	0.155628f, -0.057830f, -0.986122f, 0.184321f, -0.078424f, 0.007292f,
	0.166252f, 0.005949f, -0.986065f, 0.199806f, 0.000000f, 0.007292f,
	0.593653f, 0.020841f, -0.804452f, 0.228063f, 0.000000f, 0.014767f,

	0.166252f, 0.005949f, -0.986065f, 0.199806f, 0.000000f, 0.007292f,
	0.155628f, -0.057830f, -0.986122f, 0.184321f, -0.078424f, 0.007292f,
	0.048650f, -0.016849f, -0.998674f, 0.119909f, -0.051018f, 0.002005f,

	0.048650f, -0.016849f, -0.998674f, 0.119909f, -0.051018f, 0.002005f,
	0.051492f, 0.002983f, -0.998669f, 0.129983f, 0.000000f, 0.002005f,
	0.166252f, 0.005949f, -0.986065f, 0.199806f, 0.000000f, 0.007292f,

	0.051492f, 0.002983f, -0.998669f, 0.129983f, 0.000000f, 0.002005f,
	0.048650f, -0.016849f, -0.998674f, 0.119909f, -0.051018f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	0.051492f, 0.002983f, -0.998669f, 0.129983f, 0.000000f, 0.002005f,

	0.735451f, -0.308230f, -0.603413f, 0.215265f, -0.091590f, 0.023335f,
	0.560944f, -0.566117f, -0.604031f, 0.165678f, -0.165678f, 0.023335f,
	0.433746f, -0.404180f, -0.805296f, 0.161925f, -0.161925f, 0.014767f,

	0.433746f, -0.404180f, -0.805296f, 0.161925f, -0.161925f, 0.014767f,
	0.556004f, -0.207146f, -0.804954f, 0.210388f, -0.089515f, 0.014767f,
	0.735451f, -0.308230f, -0.603413f, 0.215265f, -0.091590f, 0.023335f,

	0.556004f, -0.207146f, -0.804954f, 0.210388f, -0.089515f, 0.014767f,
	0.433746f, -0.404180f, -0.805296f, 0.161925f, -0.161925f, 0.014767f,
	0.121305f, -0.112895f, -0.986174f, 0.141862f, -0.141862f, 0.007292f,

	0.121305f, -0.112895f, -0.986174f, 0.141862f, -0.141862f, 0.007292f,
	0.155628f, -0.057830f, -0.986122f, 0.184321f, -0.078424f, 0.007292f,
	0.556004f, -0.207146f, -0.804954f, 0.210388f, -0.089515f, 0.014767f,

	0.155628f, -0.057830f, -0.986122f, 0.184321f, -0.078424f, 0.007292f,
	0.121305f, -0.112895f, -0.986174f, 0.141862f, -0.141862f, 0.007292f,
	0.038370f, -0.034155f, -0.998680f, 0.092288f, -0.092288f, 0.002005f,

	0.038370f, -0.034155f, -0.998680f, 0.092288f, -0.092288f, 0.002005f,
	0.048650f, -0.016849f, -0.998674f, 0.119909f, -0.051018f, 0.002005f,
	0.155628f, -0.057830f, -0.986122f, 0.184321f, -0.078424f, 0.007292f,

	0.048650f, -0.016849f, -0.998674f, 0.119909f, -0.051018f, 0.002005f,
	0.038370f, -0.034155f, -0.998680f, 0.092288f, -0.092288f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	0.048650f, -0.016849f, -0.998674f, 0.119909f, -0.051018f, 0.002005f,

	0.560944f, -0.566117f, -0.604031f, 0.165678f, -0.165678f, 0.023335f,
	0.301408f, -0.738250f, -0.603440f, 0.091590f, -0.215265f, 0.023335f,
	0.246112f, -0.539771f, -0.805032f, 0.089515f, -0.210388f, 0.014767f,

	0.246112f, -0.539771f, -0.805032f, 0.089515f, -0.210388f, 0.014767f,
	0.433746f, -0.404180f, -0.805296f, 0.161925f, -0.161925f, 0.014767f,
	0.560944f, -0.566117f, -0.604031f, 0.165678f, -0.165678f, 0.023335f,

	0.433746f, -0.404180f, -0.805296f, 0.161925f, -0.161925f, 0.014767f,
	0.246112f, -0.539771f, -0.805032f, 0.089515f, -0.210388f, 0.014767f,
	0.068900f, -0.150926f, -0.986141f, 0.078424f, -0.184321f, 0.007292f,

	0.068900f, -0.150926f, -0.986141f, 0.078424f, -0.184321f, 0.007292f,
	0.121305f, -0.112895f, -0.986174f, 0.141862f, -0.141862f, 0.007292f,
	0.433746f, -0.404180f, -0.805296f, 0.161925f, -0.161925f, 0.014767f,

	0.121305f, -0.112895f, -0.986174f, 0.141862f, -0.141862f, 0.007292f,
	0.068900f, -0.150926f, -0.986141f, 0.078424f, -0.184321f, 0.007292f,
	0.022397f, -0.046289f, -0.998677f, 0.051018f, -0.119909f, 0.002005f,

	0.022397f, -0.046289f, -0.998677f, 0.051018f, -0.119909f, 0.002005f,
	0.038370f, -0.034155f, -0.998680f, 0.092288f, -0.092288f, 0.002005f,
	0.121305f, -0.112895f, -0.986174f, 0.141862f, -0.141862f, 0.007292f,

	0.038370f, -0.034155f, -0.998680f, 0.092288f, -0.092288f, 0.002005f,
	0.022397f, -0.046289f, -0.998677f, 0.051018f, -0.119909f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	0.038370f, -0.034155f, -0.998680f, 0.092288f, -0.092288f, 0.002005f,

	0.301408f, -0.738250f, -0.603440f, 0.091590f, -0.215265f, 0.023335f,
	-0.003633f, -0.798118f, -0.602490f, 0.000000f, -0.233350f, 0.023335f,
	0.020841f, -0.593653f, -0.804452f, 0.000000f, -0.228063f, 0.014767f,

	0.020841f, -0.593653f, -0.804452f, 0.000000f, -0.228063f, 0.014767f,
	0.246112f, -0.539771f, -0.805032f, 0.089515f, -0.210388f, 0.014767f,
	0.301408f, -0.738250f, -0.603440f, 0.091590f, -0.215265f, 0.023335f,

	0.246112f, -0.539771f, -0.805032f, 0.089515f, -0.210388f, 0.014767f,
	0.020841f, -0.593653f, -0.804452f, 0.000000f, -0.228063f, 0.014767f,
	0.005949f, -0.166252f, -0.986065f, 0.000000f, -0.199806f, 0.007292f,

	0.005949f, -0.166252f, -0.986065f, 0.000000f, -0.199806f, 0.007292f,
	0.068900f, -0.150926f, -0.986141f, 0.078424f, -0.184321f, 0.007292f,
	0.246112f, -0.539771f, -0.805032f, 0.089515f, -0.210388f, 0.014767f,

	0.068900f, -0.150926f, -0.986141f, 0.078424f, -0.184321f, 0.007292f,
	0.005949f, -0.166252f, -0.986065f, 0.000000f, -0.199806f, 0.007292f,
	0.002983f, -0.051492f, -0.998669f, 0.000000f, -0.129983f, 0.002005f,

	0.002983f, -0.051492f, -0.998669f, 0.000000f, -0.129983f, 0.002005f,
	0.022397f, -0.046289f, -0.998677f, 0.051018f, -0.119909f, 0.002005f,
	0.068900f, -0.150926f, -0.986141f, 0.078424f, -0.184321f, 0.007292f,

	0.022397f, -0.046289f, -0.998677f, 0.051018f, -0.119909f, 0.002005f,
	0.002983f, -0.051492f, -0.998669f, 0.000000f, -0.129983f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	0.022397f, -0.046289f, -0.998677f, 0.051018f, -0.119909f, 0.002005f,

	-0.003633f, -0.798118f, -0.602490f, 0.000000f, -0.233350f, 0.023335f,
	-0.308230f, -0.735451f, -0.603412f, -0.091590f, -0.215265f, 0.023335f,
	-0.207146f, -0.556004f, -0.804954f, -0.089515f, -0.210388f, 0.014767f,

	-0.207146f, -0.556004f, -0.804954f, -0.089515f, -0.210388f, 0.014767f,
	0.020841f, -0.593653f, -0.804452f, 0.000000f, -0.228063f, 0.014767f,
	-0.003633f, -0.798118f, -0.602490f, 0.000000f, -0.233350f, 0.023335f,

	0.020841f, -0.593653f, -0.804452f, 0.000000f, -0.228063f, 0.014767f,
	-0.207146f, -0.556004f, -0.804954f, -0.089515f, -0.210388f, 0.014767f,
	-0.057830f, -0.155628f, -0.986122f, -0.078424f, -0.184321f, 0.007292f,

	-0.057830f, -0.155628f, -0.986122f, -0.078424f, -0.184321f, 0.007292f,
	0.005949f, -0.166252f, -0.986065f, 0.000000f, -0.199806f, 0.007292f,
	0.020841f, -0.593653f, -0.804452f, 0.000000f, -0.228063f, 0.014767f,

	0.005949f, -0.166252f, -0.986065f, 0.000000f, -0.199806f, 0.007292f,
	-0.057830f, -0.155628f, -0.986122f, -0.078424f, -0.184321f, 0.007292f,
	-0.016849f, -0.048650f, -0.998674f, -0.051018f, -0.119909f, 0.002005f,

	-0.016849f, -0.048650f, -0.998674f, -0.051018f, -0.119909f, 0.002005f,
	0.002983f, -0.051492f, -0.998669f, 0.000000f, -0.129983f, 0.002005f,
	0.005949f, -0.166252f, -0.986065f, 0.000000f, -0.199806f, 0.007292f,

	0.002983f, -0.051492f, -0.998669f, 0.000000f, -0.129983f, 0.002005f,
	-0.016849f, -0.048650f, -0.998674f, -0.051018f, -0.119909f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	0.002983f, -0.051492f, -0.998669f, 0.000000f, -0.129983f, 0.002005f,

	-0.308230f, -0.735451f, -0.603412f, -0.091590f, -0.215265f, 0.023335f,
	-0.566117f, -0.560944f, -0.604031f, -0.165678f, -0.165678f, 0.023335f,
	-0.404180f, -0.433746f, -0.805296f, -0.161925f, -0.161925f, 0.014767f,

	-0.404180f, -0.433746f, -0.805296f, -0.161925f, -0.161925f, 0.014767f,
	-0.207146f, -0.556004f, -0.804954f, -0.089515f, -0.210388f, 0.014767f,
	-0.308230f, -0.735451f, -0.603412f, -0.091590f, -0.215265f, 0.023335f,

	-0.207146f, -0.556004f, -0.804954f, -0.089515f, -0.210388f, 0.014767f,
	-0.404180f, -0.433746f, -0.805296f, -0.161925f, -0.161925f, 0.014767f,
	-0.112895f, -0.121305f, -0.986174f, -0.141862f, -0.141862f, 0.007292f,

	-0.112895f, -0.121305f, -0.986174f, -0.141862f, -0.141862f, 0.007292f,
	-0.057830f, -0.155628f, -0.986122f, -0.078424f, -0.184321f, 0.007292f,
	-0.207146f, -0.556004f, -0.804954f, -0.089515f, -0.210388f, 0.014767f,

	-0.057830f, -0.155628f, -0.986122f, -0.078424f, -0.184321f, 0.007292f,
	-0.112895f, -0.121305f, -0.986174f, -0.141862f, -0.141862f, 0.007292f,
	-0.034155f, -0.038370f, -0.998680f, -0.092288f, -0.092288f, 0.002005f,

	-0.034155f, -0.038370f, -0.998680f, -0.092288f, -0.092288f, 0.002005f,
	-0.016849f, -0.048650f, -0.998674f, -0.051018f, -0.119909f, 0.002005f,
	-0.057830f, -0.155628f, -0.986122f, -0.078424f, -0.184321f, 0.007292f,

	-0.016849f, -0.048650f, -0.998674f, -0.051018f, -0.119909f, 0.002005f,
	-0.034155f, -0.038370f, -0.998680f, -0.092288f, -0.092288f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.016849f, -0.048650f, -0.998674f, -0.051018f, -0.119909f, 0.002005f,

	-0.566117f, -0.560944f, -0.604031f, -0.165678f, -0.165678f, 0.023335f,
	-0.738250f, -0.301408f, -0.603440f, -0.215265f, -0.091590f, 0.023335f,
	-0.539771f, -0.246112f, -0.805032f, -0.210388f, -0.089515f, 0.014767f,

	-0.539771f, -0.246112f, -0.805032f, -0.210388f, -0.089515f, 0.014767f,
	-0.404180f, -0.433746f, -0.805296f, -0.161925f, -0.161925f, 0.014767f,
	-0.566117f, -0.560944f, -0.604031f, -0.165678f, -0.165678f, 0.023335f,

	-0.404180f, -0.433746f, -0.805296f, -0.161925f, -0.161925f, 0.014767f,
	-0.539771f, -0.246112f, -0.805032f, -0.210388f, -0.089515f, 0.014767f,
	-0.150926f, -0.068900f, -0.986141f, -0.184321f, -0.078424f, 0.007292f,

	-0.150926f, -0.068900f, -0.986141f, -0.184321f, -0.078424f, 0.007292f,
	-0.112895f, -0.121305f, -0.986174f, -0.141862f, -0.141862f, 0.007292f,
	-0.404180f, -0.433746f, -0.805296f, -0.161925f, -0.161925f, 0.014767f,

	-0.112895f, -0.121305f, -0.986174f, -0.141862f, -0.141862f, 0.007292f,
	-0.150926f, -0.068900f, -0.986141f, -0.184321f, -0.078424f, 0.007292f,
	-0.046289f, -0.022397f, -0.998677f, -0.119909f, -0.051018f, 0.002005f,

	-0.046289f, -0.022397f, -0.998677f, -0.119909f, -0.051018f, 0.002005f,
	-0.034155f, -0.038370f, -0.998680f, -0.092288f, -0.092288f, 0.002005f,
	-0.112895f, -0.121305f, -0.986174f, -0.141862f, -0.141862f, 0.007292f,

	-0.034155f, -0.038370f, -0.998680f, -0.092288f, -0.092288f, 0.002005f,
	-0.046289f, -0.022397f, -0.998677f, -0.119909f, -0.051018f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.034155f, -0.038370f, -0.998680f, -0.092288f, -0.092288f, 0.002005f,

	-0.738250f, -0.301408f, -0.603440f, -0.215265f, -0.091590f, 0.023335f,
	-0.798118f, 0.003633f, -0.602490f, -0.233350f, 0.000000f, 0.023335f,
	-0.593653f, -0.020841f, -0.804452f, -0.228063f, 0.000000f, 0.014767f,

	-0.593653f, -0.020841f, -0.804452f, -0.228063f, 0.000000f, 0.014767f,
	-0.539771f, -0.246112f, -0.805032f, -0.210388f, -0.089515f, 0.014767f,
	-0.738250f, -0.301408f, -0.603440f, -0.215265f, -0.091590f, 0.023335f,

	-0.539771f, -0.246112f, -0.805032f, -0.210388f, -0.089515f, 0.014767f,
	-0.593653f, -0.020841f, -0.804452f, -0.228063f, 0.000000f, 0.014767f,
	-0.166252f, -0.005949f, -0.986065f, -0.199806f, 0.000000f, 0.007292f,

	-0.166252f, -0.005949f, -0.986065f, -0.199806f, 0.000000f, 0.007292f,
	-0.150926f, -0.068900f, -0.986141f, -0.184321f, -0.078424f, 0.007292f,
	-0.539771f, -0.246112f, -0.805032f, -0.210388f, -0.089515f, 0.014767f,

	-0.150926f, -0.068900f, -0.986141f, -0.184321f, -0.078424f, 0.007292f,
	-0.166252f, -0.005949f, -0.986065f, -0.199806f, 0.000000f, 0.007292f,
	-0.051492f, -0.002983f, -0.998669f, -0.129983f, 0.000000f, 0.002005f,

	-0.051492f, -0.002983f, -0.998669f, -0.129983f, 0.000000f, 0.002005f,
	-0.046289f, -0.022397f, -0.998677f, -0.119909f, -0.051018f, 0.002005f,
	-0.150926f, -0.068900f, -0.986141f, -0.184321f, -0.078424f, 0.007292f,

	-0.046289f, -0.022397f, -0.998677f, -0.119909f, -0.051018f, 0.002005f,
	-0.051492f, -0.002983f, -0.998669f, -0.129983f, 0.000000f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.046289f, -0.022397f, -0.998677f, -0.119909f, -0.051018f, 0.002005f,

	-0.798118f, 0.003633f, -0.602490f, -0.233350f, 0.000000f, 0.023335f,
	-0.735451f, 0.308230f, -0.603413f, -0.215265f, 0.091590f, 0.023335f,
	-0.556004f, 0.207146f, -0.804954f, -0.210388f, 0.089515f, 0.014767f,

	-0.556004f, 0.207146f, -0.804954f, -0.210388f, 0.089515f, 0.014767f,
	-0.593653f, -0.020841f, -0.804452f, -0.228063f, 0.000000f, 0.014767f,
	-0.798118f, 0.003633f, -0.602490f, -0.233350f, 0.000000f, 0.023335f,

	-0.593653f, -0.020841f, -0.804452f, -0.228063f, 0.000000f, 0.014767f,
	-0.556004f, 0.207146f, -0.804954f, -0.210388f, 0.089515f, 0.014767f,
	-0.155628f, 0.057830f, -0.986122f, -0.184321f, 0.078424f, 0.007292f,

	-0.155628f, 0.057830f, -0.986122f, -0.184321f, 0.078424f, 0.007292f,
	-0.166252f, -0.005949f, -0.986065f, -0.199806f, 0.000000f, 0.007292f,
	-0.593653f, -0.020841f, -0.804452f, -0.228063f, 0.000000f, 0.014767f,

	-0.166252f, -0.005949f, -0.986065f, -0.199806f, 0.000000f, 0.007292f,
	-0.155628f, 0.057830f, -0.986122f, -0.184321f, 0.078424f, 0.007292f,
	-0.048650f, 0.016849f, -0.998674f, -0.119909f, 0.051018f, 0.002005f,

	-0.048650f, 0.016849f, -0.998674f, -0.119909f, 0.051018f, 0.002005f,
	-0.051492f, -0.002983f, -0.998669f, -0.129983f, 0.000000f, 0.002005f,
	-0.166252f, -0.005949f, -0.986065f, -0.199806f, 0.000000f, 0.007292f,

	-0.051492f, -0.002983f, -0.998669f, -0.129983f, 0.000000f, 0.002005f,
	-0.048650f, 0.016849f, -0.998674f, -0.119909f, 0.051018f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.051492f, -0.002983f, -0.998669f, -0.129983f, 0.000000f, 0.002005f,

	-0.735451f, 0.308230f, -0.603413f, -0.215265f, 0.091590f, 0.023335f,
	-0.560944f, 0.566117f, -0.604031f, -0.165678f, 0.165678f, 0.023335f,
	-0.433746f, 0.404180f, -0.805296f, -0.161925f, 0.161925f, 0.014767f,

	-0.433746f, 0.404180f, -0.805296f, -0.161925f, 0.161925f, 0.014767f,
	-0.556004f, 0.207146f, -0.804954f, -0.210388f, 0.089515f, 0.014767f,
	-0.735451f, 0.308230f, -0.603413f, -0.215265f, 0.091590f, 0.023335f,

	-0.556004f, 0.207146f, -0.804954f, -0.210388f, 0.089515f, 0.014767f,
	-0.433746f, 0.404180f, -0.805296f, -0.161925f, 0.161925f, 0.014767f,
	-0.121305f, 0.112895f, -0.986174f, -0.141862f, 0.141862f, 0.007292f,

	-0.121305f, 0.112895f, -0.986174f, -0.141862f, 0.141862f, 0.007292f,
	-0.155628f, 0.057830f, -0.986122f, -0.184321f, 0.078424f, 0.007292f,
	-0.556004f, 0.207146f, -0.804954f, -0.210388f, 0.089515f, 0.014767f,

	-0.155628f, 0.057830f, -0.986122f, -0.184321f, 0.078424f, 0.007292f,
	-0.121305f, 0.112895f, -0.986174f, -0.141862f, 0.141862f, 0.007292f,
	-0.038370f, 0.034155f, -0.998680f, -0.092288f, 0.092288f, 0.002005f,

	-0.038370f, 0.034155f, -0.998680f, -0.092288f, 0.092288f, 0.002005f,
	-0.048650f, 0.016849f, -0.998674f, -0.119909f, 0.051018f, 0.002005f,
	-0.155628f, 0.057830f, -0.986122f, -0.184321f, 0.078424f, 0.007292f,

	-0.048650f, 0.016849f, -0.998674f, -0.119909f, 0.051018f, 0.002005f,
	-0.038370f, 0.034155f, -0.998680f, -0.092288f, 0.092288f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.048650f, 0.016849f, -0.998674f, -0.119909f, 0.051018f, 0.002005f,

	-0.560944f, 0.566117f, -0.604031f, -0.165678f, 0.165678f, 0.023335f,
	-0.301408f, 0.738250f, -0.603440f, -0.091590f, 0.215265f, 0.023335f,
	-0.246112f, 0.539771f, -0.805032f, -0.089515f, 0.210388f, 0.014767f,

	-0.246112f, 0.539771f, -0.805032f, -0.089515f, 0.210388f, 0.014767f,
	-0.433746f, 0.404180f, -0.805296f, -0.161925f, 0.161925f, 0.014767f,
	-0.560944f, 0.566117f, -0.604031f, -0.165678f, 0.165678f, 0.023335f,

	-0.433746f, 0.404180f, -0.805296f, -0.161925f, 0.161925f, 0.014767f,
	-0.246112f, 0.539771f, -0.805032f, -0.089515f, 0.210388f, 0.014767f,
	-0.068900f, 0.150926f, -0.986141f, -0.078424f, 0.184321f, 0.007292f,

	-0.068900f, 0.150926f, -0.986141f, -0.078424f, 0.184321f, 0.007292f,
	-0.121305f, 0.112895f, -0.986174f, -0.141862f, 0.141862f, 0.007292f,
	-0.433746f, 0.404180f, -0.805296f, -0.161925f, 0.161925f, 0.014767f,

	-0.121305f, 0.112895f, -0.986174f, -0.141862f, 0.141862f, 0.007292f,
	-0.068900f, 0.150926f, -0.986141f, -0.078424f, 0.184321f, 0.007292f,
	-0.022397f, 0.046289f, -0.998677f, -0.051018f, 0.119909f, 0.002005f,

	-0.022397f, 0.046289f, -0.998677f, -0.051018f, 0.119909f, 0.002005f,
	-0.038370f, 0.034155f, -0.998680f, -0.092288f, 0.092288f, 0.002005f,
	-0.121305f, 0.112895f, -0.986174f, -0.141862f, 0.141862f, 0.007292f,

	-0.038370f, 0.034155f, -0.998680f, -0.092288f, 0.092288f, 0.002005f,
	-0.022397f, 0.046289f, -0.998677f, -0.051018f, 0.119909f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.038370f, 0.034155f, -0.998680f, -0.092288f, 0.092288f, 0.002005f,

	-0.301408f, 0.738250f, -0.603440f, -0.091590f, 0.215265f, 0.023335f,
	0.003633f, 0.798118f, -0.602490f, 0.000000f, 0.233350f, 0.023335f,
	-0.020841f, 0.593653f, -0.804452f, 0.000000f, 0.228063f, 0.014767f,

	-0.020841f, 0.593653f, -0.804452f, 0.000000f, 0.228063f, 0.014767f,
	-0.246112f, 0.539771f, -0.805032f, -0.089515f, 0.210388f, 0.014767f,
	-0.301408f, 0.738250f, -0.603440f, -0.091590f, 0.215265f, 0.023335f,

	-0.246112f, 0.539771f, -0.805032f, -0.089515f, 0.210388f, 0.014767f,
	-0.020841f, 0.593653f, -0.804452f, 0.000000f, 0.228063f, 0.014767f,
	-0.005949f, 0.166252f, -0.986065f, 0.000000f, 0.199806f, 0.007292f,

	-0.005949f, 0.166252f, -0.986065f, 0.000000f, 0.199806f, 0.007292f,
	-0.068900f, 0.150926f, -0.986141f, -0.078424f, 0.184321f, 0.007292f,
	-0.246112f, 0.539771f, -0.805032f, -0.089515f, 0.210388f, 0.014767f,

	-0.068900f, 0.150926f, -0.986141f, -0.078424f, 0.184321f, 0.007292f,
	-0.005949f, 0.166252f, -0.986065f, 0.000000f, 0.199806f, 0.007292f,
	-0.002983f, 0.051492f, -0.998669f, 0.000000f, 0.129983f, 0.002005f,

	-0.002983f, 0.051492f, -0.998669f, 0.000000f, 0.129983f, 0.002005f,
	-0.022397f, 0.046289f, -0.998677f, -0.051018f, 0.119909f, 0.002005f,
	-0.068900f, 0.150926f, -0.986141f, -0.078424f, 0.184321f, 0.007292f,

	-0.022397f, 0.046289f, -0.998677f, -0.051018f, 0.119909f, 0.002005f,
	-0.002983f, 0.051492f, -0.998669f, 0.000000f, 0.129983f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.022397f, 0.046289f, -0.998677f, -0.051018f, 0.119909f, 0.002005f,

	0.003633f, 0.798118f, -0.602490f, 0.000000f, 0.233350f, 0.023335f,
	0.308230f, 0.735451f, -0.603412f, 0.091590f, 0.215265f, 0.023335f,
	0.207146f, 0.556004f, -0.804954f, 0.089515f, 0.210388f, 0.014767f,

	0.207146f, 0.556004f, -0.804954f, 0.089515f, 0.210388f, 0.014767f,
	-0.020841f, 0.593653f, -0.804452f, 0.000000f, 0.228063f, 0.014767f,
	0.003633f, 0.798118f, -0.602490f, 0.000000f, 0.233350f, 0.023335f,

	-0.020841f, 0.593653f, -0.804452f, 0.000000f, 0.228063f, 0.014767f,
	0.207146f, 0.556004f, -0.804954f, 0.089515f, 0.210388f, 0.014767f,
	0.057830f, 0.155628f, -0.986122f, 0.078424f, 0.184321f, 0.007292f,

	0.057830f, 0.155628f, -0.986122f, 0.078424f, 0.184321f, 0.007292f,
	-0.005949f, 0.166252f, -0.986065f, 0.000000f, 0.199806f, 0.007292f,
	-0.020841f, 0.593653f, -0.804452f, 0.000000f, 0.228063f, 0.014767f,

	-0.005949f, 0.166252f, -0.986065f, 0.000000f, 0.199806f, 0.007292f,
	0.057830f, 0.155628f, -0.986122f, 0.078424f, 0.184321f, 0.007292f,
	0.016849f, 0.048650f, -0.998674f, 0.051018f, 0.119909f, 0.002005f,

	0.016849f, 0.048650f, -0.998674f, 0.051018f, 0.119909f, 0.002005f,
	-0.002983f, 0.051492f, -0.998669f, 0.000000f, 0.129983f, 0.002005f,
	-0.005949f, 0.166252f, -0.986065f, 0.000000f, 0.199806f, 0.007292f,

	-0.002983f, 0.051492f, -0.998669f, 0.000000f, 0.129983f, 0.002005f,
	0.016849f, 0.048650f, -0.998674f, 0.051018f, 0.119909f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.002983f, 0.051492f, -0.998669f, 0.000000f, 0.129983f, 0.002005f,

	0.308230f, 0.735451f, -0.603412f, 0.091590f, 0.215265f, 0.023335f,
	0.566117f, 0.560944f, -0.604031f, 0.165678f, 0.165678f, 0.023335f,
	0.404180f, 0.433746f, -0.805296f, 0.161925f, 0.161925f, 0.014767f,

	0.404180f, 0.433746f, -0.805296f, 0.161925f, 0.161925f, 0.014767f,
	0.207146f, 0.556004f, -0.804954f, 0.089515f, 0.210388f, 0.014767f,
	0.308230f, 0.735451f, -0.603412f, 0.091590f, 0.215265f, 0.023335f,

	0.207146f, 0.556004f, -0.804954f, 0.089515f, 0.210388f, 0.014767f,
	0.404180f, 0.433746f, -0.805296f, 0.161925f, 0.161925f, 0.014767f,
	0.112895f, 0.121305f, -0.986174f, 0.141862f, 0.141862f, 0.007292f,

	0.112895f, 0.121305f, -0.986174f, 0.141862f, 0.141862f, 0.007292f,
	0.057830f, 0.155628f, -0.986122f, 0.078424f, 0.184321f, 0.007292f,
	0.207146f, 0.556004f, -0.804954f, 0.089515f, 0.210388f, 0.014767f,

	0.057830f, 0.155628f, -0.986122f, 0.078424f, 0.184321f, 0.007292f,
	0.112895f, 0.121305f, -0.986174f, 0.141862f, 0.141862f, 0.007292f,
	0.034155f, 0.038370f, -0.998680f, 0.092288f, 0.092288f, 0.002005f,

	0.034155f, 0.038370f, -0.998680f, 0.092288f, 0.092288f, 0.002005f,
	0.016849f, 0.048650f, -0.998674f, 0.051018f, 0.119909f, 0.002005f,
	0.057830f, 0.155628f, -0.986122f, 0.078424f, 0.184321f, 0.007292f,

	0.016849f, 0.048650f, -0.998674f, 0.051018f, 0.119909f, 0.002005f,
	0.034155f, 0.038370f, -0.998680f, 0.092288f, 0.092288f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	0.016849f, 0.048650f, -0.998674f, 0.051018f, 0.119909f, 0.002005f,

	0.566117f, 0.560944f, -0.604031f, 0.165678f, 0.165678f, 0.023335f,
	0.738250f, 0.301408f, -0.603440f, 0.215265f, 0.091590f, 0.023335f,
	0.539771f, 0.246112f, -0.805032f, 0.210388f, 0.089515f, 0.014767f,

	0.539771f, 0.246112f, -0.805032f, 0.210388f, 0.089515f, 0.014767f,
	0.404180f, 0.433746f, -0.805296f, 0.161925f, 0.161925f, 0.014767f,
	0.566117f, 0.560944f, -0.604031f, 0.165678f, 0.165678f, 0.023335f,

	0.404180f, 0.433746f, -0.805296f, 0.161925f, 0.161925f, 0.014767f,
	0.539771f, 0.246112f, -0.805032f, 0.210388f, 0.089515f, 0.014767f,
	0.150926f, 0.068900f, -0.986141f, 0.184321f, 0.078424f, 0.007292f,

	0.150926f, 0.068900f, -0.986141f, 0.184321f, 0.078424f, 0.007292f,
	0.112895f, 0.121305f, -0.986174f, 0.141862f, 0.141862f, 0.007292f,
	0.404180f, 0.433746f, -0.805296f, 0.161925f, 0.161925f, 0.014767f,

	0.112895f, 0.121305f, -0.986174f, 0.141862f, 0.141862f, 0.007292f,
	0.150926f, 0.068900f, -0.986141f, 0.184321f, 0.078424f, 0.007292f,
	0.046289f, 0.022397f, -0.998677f, 0.119909f, 0.051018f, 0.002005f,

	0.046289f, 0.022397f, -0.998677f, 0.119909f, 0.051018f, 0.002005f,
	0.034155f, 0.038370f, -0.998680f, 0.092288f, 0.092288f, 0.002005f,
	0.112895f, 0.121305f, -0.986174f, 0.141862f, 0.141862f, 0.007292f,

	0.034155f, 0.038370f, -0.998680f, 0.092288f, 0.092288f, 0.002005f,
	0.046289f, 0.022397f, -0.998677f, 0.119909f, 0.051018f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	0.034155f, 0.038370f, -0.998680f, 0.092288f, 0.092288f, 0.002005f,

	0.738250f, 0.301408f, -0.603440f, 0.215265f, 0.091590f, 0.023335f,
	0.798118f, -0.003633f, -0.602490f, 0.233350f, 0.000000f, 0.023335f,
	0.593653f, 0.020841f, -0.804452f, 0.228063f, 0.000000f, 0.014767f,

	0.593653f, 0.020841f, -0.804452f, 0.228063f, 0.000000f, 0.014767f,
	0.539771f, 0.246112f, -0.805032f, 0.210388f, 0.089515f, 0.014767f,
	0.738250f, 0.301408f, -0.603440f, 0.215265f, 0.091590f, 0.023335f,

	0.539771f, 0.246112f, -0.805032f, 0.210388f, 0.089515f, 0.014767f,
	0.593653f, 0.020841f, -0.804452f, 0.228063f, 0.000000f, 0.014767f,
	0.166252f, 0.005949f, -0.986065f, 0.199806f, 0.000000f, 0.007292f,

	0.166252f, 0.005949f, -0.986065f, 0.199806f, 0.000000f, 0.007292f,
	0.150926f, 0.068900f, -0.986141f, 0.184321f, 0.078424f, 0.007292f,
	0.539771f, 0.246112f, -0.805032f, 0.210388f, 0.089515f, 0.014767f,

	0.150926f, 0.068900f, -0.986141f, 0.184321f, 0.078424f, 0.007292f,
	0.166252f, 0.005949f, -0.986065f, 0.199806f, 0.000000f, 0.007292f,
	0.051492f, 0.002983f, -0.998669f, 0.129983f, 0.000000f, 0.002005f,

	0.051492f, 0.002983f, -0.998669f, 0.129983f, 0.000000f, 0.002005f,
	0.046289f, 0.022397f, -0.998677f, 0.119909f, 0.051018f, 0.002005f,
	0.150926f, 0.068900f, -0.986141f, 0.184321f, 0.078424f, 0.007292f,

	0.046289f, 0.022397f, -0.998677f, 0.119909f, 0.051018f, 0.002005f,
	0.051492f, 0.002983f, -0.998669f, 0.129983f, 0.000000f, 0.002005f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,

	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	-0.000000f, -0.000000f, -1.000000f, 0.000000f, 0.000000f, 0.000000f,
	0.046289f, 0.022397f, -0.998677f, 0.119909f, 0.051018f, 0.002005f,

	0.007726f, -0.068401f, -0.997628f, -0.248906f, 0.000000f, 0.315022f,
	0.006517f, -0.643194f, -0.765676f, -0.246475f, -0.026252f, 0.320491f,
	0.035044f, -0.539351f, -0.841351f, -0.323750f, -0.026252f, 0.319859f,

	0.035044f, -0.539351f, -0.841351f, -0.323750f, -0.026252f, 0.319859f,
	0.040558f, 0.001831f, -0.999175f, -0.321585f, 0.000000f, 0.314475f,
	0.007726f, -0.068401f, -0.997628f, -0.248906f, 0.000000f, 0.315022f,

	0.040558f, 0.001831f, -0.999175f, -0.321585f, 0.000000f, 0.314475f,
	0.035044f, -0.539351f, -0.841351f, -0.323750f, -0.026252f, 0.319859f,
	0.163008f, -0.551287f, -0.818237f, -0.380469f, -0.026252f, 0.315432f,

	0.163008f, -0.551287f, -0.818237f, -0.380469f, -0.026252f, 0.315432f,
	0.191280f, 0.002565f, -0.981532f, -0.375304f, 0.000000f, 0.310647f,
	0.040558f, 0.001831f, -0.999175f, -0.321585f, 0.000000f, 0.314475f,

	0.191280f, 0.002565f, -0.981532f, -0.375304f, 0.000000f, 0.310647f,
	0.163008f, -0.551287f, -0.818237f, -0.380469f, -0.026252f, 0.315432f,
	0.485723f, -0.611746f, -0.624372f, -0.415403f, -0.026252f, 0.303417f,

	0.485723f, -0.611746f, -0.624372f, -0.415403f, -0.026252f, 0.303417f,
	0.635539f, -0.000642f, -0.772068f, -0.408605f, 0.000000f, 0.300255f,
	0.191280f, 0.002565f, -0.981532f, -0.375304f, 0.000000f, 0.310647f,

	0.635539f, -0.000642f, -0.772068f, -0.408605f, 0.000000f, 0.300255f,
	0.485723f, -0.611746f, -0.624372f, -0.415403f, -0.026252f, 0.303417f,
	0.762032f, -0.630861f, -0.146018f, -0.427321f, -0.026252f, 0.280019f,

	0.762032f, -0.630861f, -0.146018f, -0.427321f, -0.026252f, 0.280019f,
	0.987948f, 0.003395f, -0.154746f, -0.420029f, 0.000000f, 0.280019f,
	0.635539f, -0.000642f, -0.772068f, -0.408605f, 0.000000f, 0.300255f,

	0.006517f, -0.643194f, -0.765676f, -0.246475f, -0.026252f, 0.320491f,
	-0.002460f, -0.971276f, 0.237943f, -0.241128f, -0.035002f, 0.332523f,
	-0.011485f, -0.999931f, 0.002277f, -0.328512f, -0.035002f, 0.331703f,

	-0.011485f, -0.999931f, 0.002277f, -0.328512f, -0.035002f, 0.331703f,
	0.035044f, -0.539351f, -0.841351f, -0.323750f, -0.026252f, 0.319859f,
	0.006517f, -0.643194f, -0.765676f, -0.246475f, -0.026252f, 0.320491f,

	0.035044f, -0.539351f, -0.841351f, -0.323750f, -0.026252f, 0.319859f,
	-0.011485f, -0.999931f, 0.002277f, -0.328512f, -0.035002f, 0.331703f,
	-0.039179f, -0.999168f, -0.011304f, -0.391833f, -0.035002f, 0.325960f,

	-0.039179f, -0.999168f, -0.011304f, -0.391833f, -0.035002f, 0.325960f,
	0.163008f, -0.551287f, -0.818237f, -0.380469f, -0.026252f, 0.315432f,
	0.035044f, -0.539351f, -0.841351f, -0.323750f, -0.026252f, 0.319859f,

	0.163008f, -0.551287f, -0.818237f, -0.380469f, -0.026252f, 0.315432f,
	-0.039179f, -0.999168f, -0.011304f, -0.391833f, -0.035002f, 0.325960f,
	-0.059168f, -0.996038f, -0.066392f, -0.430360f, -0.035002f, 0.310373f,

	-0.059168f, -0.996038f, -0.066392f, -0.430360f, -0.035002f, 0.310373f,
	0.485723f, -0.611746f, -0.624372f, -0.415403f, -0.026252f, 0.303417f,
	0.163008f, -0.551287f, -0.818237f, -0.380469f, -0.026252f, 0.315432f,

	0.485723f, -0.611746f, -0.624372f, -0.415403f, -0.026252f, 0.303417f,
	-0.059168f, -0.996038f, -0.066392f, -0.430360f, -0.035002f, 0.310373f,
	-0.010065f, -0.998112f, -0.060596f, -0.443364f, -0.035002f, 0.280019f,

	-0.010065f, -0.998112f, -0.060596f, -0.443364f, -0.035002f, 0.280019f,
	0.762032f, -0.630861f, -0.146018f, -0.427321f, -0.026252f, 0.280019f,
	0.485723f, -0.611746f, -0.624372f, -0.415403f, -0.026252f, 0.303417f,

	-0.002460f, -0.971276f, 0.237943f, -0.241128f, -0.035002f, 0.332523f,
	-0.009468f, -0.429504f, 0.903015f, -0.235780f, -0.026252f, 0.344555f,
	-0.050213f, -0.542566f, 0.838511f, -0.333275f, -0.026252f, 0.343547f,

	-0.050213f, -0.542566f, 0.838511f, -0.333275f, -0.026252f, 0.343547f,
	-0.011485f, -0.999931f, 0.002277f, -0.328512f, -0.035002f, 0.331703f,
	-0.002460f, -0.971276f, 0.237943f, -0.241128f, -0.035002f, 0.332523f,

	-0.011485f, -0.999931f, 0.002277f, -0.328512f, -0.035002f, 0.331703f,
	-0.050213f, -0.542566f, 0.838511f, -0.333275f, -0.026252f, 0.343547f,
	-0.225761f, -0.562948f, 0.795061f, -0.403196f, -0.026252f, 0.336488f,

	-0.225761f, -0.562948f, 0.795061f, -0.403196f, -0.026252f, 0.336488f,
	-0.039179f, -0.999168f, -0.011304f, -0.391833f, -0.035002f, 0.325960f,
	-0.011485f, -0.999931f, 0.002277f, -0.328512f, -0.035002f, 0.331703f,

	-0.039179f, -0.999168f, -0.011304f, -0.391833f, -0.035002f, 0.325960f,
	-0.225761f, -0.562948f, 0.795061f, -0.403196f, -0.026252f, 0.336488f,
	-0.585671f, -0.621896f, 0.519840f, -0.445316f, -0.026252f, 0.317329f,

	-0.585671f, -0.621896f, 0.519840f, -0.445316f, -0.026252f, 0.317329f,
	-0.059168f, -0.996038f, -0.066392f, -0.430360f, -0.035002f, 0.310373f,
	-0.039179f, -0.999168f, -0.011304f, -0.391833f, -0.035002f, 0.325960f,

	-0.059168f, -0.996038f, -0.066392f, -0.430360f, -0.035002f, 0.310373f,
	-0.585671f, -0.621896f, 0.519840f, -0.445316f, -0.026252f, 0.317329f,
	-0.775985f, -0.629264f, 0.043293f, -0.459407f, -0.026252f, 0.280019f,

	-0.775985f, -0.629264f, 0.043293f, -0.459407f, -0.026252f, 0.280019f,
	-0.010065f, -0.998112f, -0.060596f, -0.443364f, -0.035002f, 0.280019f,
	-0.059168f, -0.996038f, -0.066392f, -0.430360f, -0.035002f, 0.310373f,

	-0.009468f, -0.429504f, 0.903015f, -0.235780f, -0.026252f, 0.344555f,
	-0.010565f, 0.068512f, 0.997594f, -0.233350f, 0.000000f, 0.350024f,
	-0.056893f, -0.000914f, 0.998380f, -0.335440f, 0.000000f, 0.348930f,

	-0.056893f, -0.000914f, 0.998380f, -0.335440f, 0.000000f, 0.348930f,
	-0.050213f, -0.542566f, 0.838511f, -0.333275f, -0.026252f, 0.343547f,
	-0.009468f, -0.429504f, 0.903015f, -0.235780f, -0.026252f, 0.344555f,

	-0.050213f, -0.542566f, 0.838511f, -0.333275f, -0.026252f, 0.343547f,
	-0.056893f, -0.000914f, 0.998380f, -0.335440f, 0.000000f, 0.348930f,
	-0.266734f, 0.001036f, 0.963770f, -0.408362f, 0.000000f, 0.341274f,

	-0.266734f, 0.001036f, 0.963770f, -0.408362f, 0.000000f, 0.341274f,
	-0.225761f, -0.562948f, 0.795061f, -0.403196f, -0.026252f, 0.336488f,
	-0.050213f, -0.542566f, 0.838511f, -0.333275f, -0.026252f, 0.343547f,

	-0.225761f, -0.562948f, 0.795061f, -0.403196f, -0.026252f, 0.336488f,
	-0.266734f, 0.001036f, 0.963770f, -0.408362f, 0.000000f, 0.341274f,
	-0.735585f, 0.002660f, 0.677427f, -0.452115f, 0.000000f, 0.320491f,

	-0.735585f, 0.002660f, 0.677427f, -0.452115f, 0.000000f, 0.320491f,
	-0.585671f, -0.621896f, 0.519840f, -0.445316f, -0.026252f, 0.317329f,
	-0.225761f, -0.562948f, 0.795061f, -0.403196f, -0.026252f, 0.336488f,

	-0.585671f, -0.621896f, 0.519840f, -0.445316f, -0.026252f, 0.317329f,
	-0.735585f, 0.002660f, 0.677427f, -0.452115f, 0.000000f, 0.320491f,
	-0.997079f, -0.001993f, 0.076346f, -0.466699f, 0.000000f, 0.280019f,

	-0.997079f, -0.001993f, 0.076346f, -0.466699f, 0.000000f, 0.280019f,
	-0.775985f, -0.629264f, 0.043293f, -0.459407f, -0.026252f, 0.280019f,
	-0.585671f, -0.621896f, 0.519840f, -0.445316f, -0.026252f, 0.317329f,

	-0.010565f, 0.068512f, 0.997594f, -0.233350f, 0.000000f, 0.350024f,
	-0.007719f, 0.643253f, 0.765615f, -0.235780f, 0.026252f, 0.344555f,
	-0.042506f, 0.541111f, 0.839876f, -0.333275f, 0.026252f, 0.343547f,

	-0.042506f, 0.541111f, 0.839876f, -0.333275f, 0.026252f, 0.343547f,
	-0.056893f, -0.000914f, 0.998380f, -0.335440f, 0.000000f, 0.348930f,
	-0.010565f, 0.068512f, 0.997594f, -0.233350f, 0.000000f, 0.350024f,

	-0.056893f, -0.000914f, 0.998380f, -0.335440f, 0.000000f, 0.348930f,
	-0.042506f, 0.541111f, 0.839876f, -0.333275f, 0.026252f, 0.343547f,
	-0.198514f, 0.562383f, 0.802694f, -0.403196f, 0.026252f, 0.336488f,

	-0.198514f, 0.562383f, 0.802694f, -0.403196f, 0.026252f, 0.336488f,
	-0.266734f, 0.001036f, 0.963770f, -0.408362f, 0.000000f, 0.341274f,
	-0.056893f, -0.000914f, 0.998380f, -0.335440f, 0.000000f, 0.348930f,

	-0.266734f, 0.001036f, 0.963770f, -0.408362f, 0.000000f, 0.341274f,
	-0.198514f, 0.562383f, 0.802694f, -0.403196f, 0.026252f, 0.336488f,
	-0.540688f, 0.623079f, 0.565180f, -0.445316f, 0.026252f, 0.317329f,

	-0.540688f, 0.623079f, 0.565180f, -0.445316f, 0.026252f, 0.317329f,
	-0.735585f, 0.002660f, 0.677427f, -0.452115f, 0.000000f, 0.320491f,
	-0.266734f, 0.001036f, 0.963770f, -0.408362f, 0.000000f, 0.341274f,

	-0.735585f, 0.002660f, 0.677427f, -0.452115f, 0.000000f, 0.320491f,
	-0.540688f, 0.623079f, 0.565180f, -0.445316f, 0.026252f, 0.317329f,
	-0.773136f, 0.628364f, 0.086140f, -0.459407f, 0.026252f, 0.280019f,

	-0.773136f, 0.628364f, 0.086140f, -0.459407f, 0.026252f, 0.280019f,
	-0.997079f, -0.001993f, 0.076346f, -0.466699f, 0.000000f, 0.280019f,
	-0.735585f, 0.002660f, 0.677427f, -0.452115f, 0.000000f, 0.320491f,

	-0.007719f, 0.643253f, 0.765615f, -0.235780f, 0.026252f, 0.344555f,
	0.001947f, 0.971318f, -0.237778f, -0.241128f, 0.035002f, 0.332523f,
	0.008552f, 0.999959f, -0.003133f, -0.328512f, 0.035002f, 0.331703f,

	0.008552f, 0.999959f, -0.003133f, -0.328512f, 0.035002f, 0.331703f,
	-0.042506f, 0.541111f, 0.839876f, -0.333275f, 0.026252f, 0.343547f,
	-0.007719f, 0.643253f, 0.765615f, -0.235780f, 0.026252f, 0.344555f,

	-0.042506f, 0.541111f, 0.839876f, -0.333275f, 0.026252f, 0.343547f,
	0.008552f, 0.999959f, -0.003133f, -0.328512f, 0.035002f, 0.331703f,
	0.028290f, 0.999597f, 0.002364f, -0.391833f, 0.035002f, 0.325960f,

	0.028290f, 0.999597f, 0.002364f, -0.391833f, 0.035002f, 0.325960f,
	-0.198514f, 0.562383f, 0.802694f, -0.403196f, 0.026252f, 0.336488f,
	-0.042506f, 0.541111f, 0.839876f, -0.333275f, 0.026252f, 0.343547f,

	-0.198514f, 0.562383f, 0.802694f, -0.403196f, 0.026252f, 0.336488f,
	0.028290f, 0.999597f, 0.002364f, -0.391833f, 0.035002f, 0.325960f,
	0.047023f, 0.997805f, 0.046624f, -0.430360f, 0.035002f, 0.310373f,

	0.047023f, 0.997805f, 0.046624f, -0.430360f, 0.035002f, 0.310373f,
	-0.540688f, 0.623079f, 0.565180f, -0.445316f, 0.026252f, 0.317329f,
	-0.198514f, 0.562383f, 0.802694f, -0.403196f, 0.026252f, 0.336488f,

	-0.540688f, 0.623079f, 0.565180f, -0.445316f, 0.026252f, 0.317329f,
	0.047023f, 0.997805f, 0.046624f, -0.430360f, 0.035002f, 0.310373f,
	0.008931f, 0.998776f, 0.048646f, -0.443364f, 0.035002f, 0.280019f,

	0.008931f, 0.998776f, 0.048646f, -0.443364f, 0.035002f, 0.280019f,
	-0.773136f, 0.628364f, 0.086140f, -0.459407f, 0.026252f, 0.280019f,
	-0.540688f, 0.623079f, 0.565180f, -0.445316f, 0.026252f, 0.317329f,

	0.001947f, 0.971318f, -0.237778f, -0.241128f, 0.035002f, 0.332523f,
	0.007161f, 0.429674f, -0.902956f, -0.246475f, 0.026252f, 0.320491f,
	0.037502f, 0.541127f, -0.840104f, -0.323750f, 0.026252f, 0.319859f,

	0.037502f, 0.541127f, -0.840104f, -0.323750f, 0.026252f, 0.319859f,
	0.008552f, 0.999959f, -0.003133f, -0.328512f, 0.035002f, 0.331703f,
	0.001947f, 0.971318f, -0.237778f, -0.241128f, 0.035002f, 0.332523f,

	0.008552f, 0.999959f, -0.003133f, -0.328512f, 0.035002f, 0.331703f,
	0.037502f, 0.541127f, -0.840104f, -0.323750f, 0.026252f, 0.319859f,
	0.173069f, 0.551822f, -0.815806f, -0.380469f, 0.026252f, 0.315432f,

	0.173069f, 0.551822f, -0.815806f, -0.380469f, 0.026252f, 0.315432f,
	0.028290f, 0.999597f, 0.002364f, -0.391833f, 0.035002f, 0.325960f,
	0.008552f, 0.999959f, -0.003133f, -0.328512f, 0.035002f, 0.331703f,

	0.028290f, 0.999597f, 0.002364f, -0.391833f, 0.035002f, 0.325960f,
	0.173069f, 0.551822f, -0.815806f, -0.380469f, 0.026252f, 0.315432f,
	0.533710f, 0.610485f, -0.585202f, -0.415403f, 0.026252f, 0.303417f,

	0.533710f, 0.610485f, -0.585202f, -0.415403f, 0.026252f, 0.303417f,
	0.047023f, 0.997805f, 0.046624f, -0.430360f, 0.035002f, 0.310373f,
	0.028290f, 0.999597f, 0.002364f, -0.391833f, 0.035002f, 0.325960f,

	0.047023f, 0.997805f, 0.046624f, -0.430360f, 0.035002f, 0.310373f,
	0.533710f, 0.610485f, -0.585202f, -0.415403f, 0.026252f, 0.303417f,
	0.771143f, 0.632324f, -0.074189f, -0.427321f, 0.026252f, 0.280019f,

	0.771143f, 0.632324f, -0.074189f, -0.427321f, 0.026252f, 0.280019f,
	0.008931f, 0.998776f, 0.048646f, -0.443364f, 0.035002f, 0.280019f,
	0.047023f, 0.997805f, 0.046624f, -0.430360f, 0.035002f, 0.310373f,

	0.007161f, 0.429674f, -0.902956f, -0.246475f, 0.026252f, 0.320491f,
	0.007726f, -0.068401f, -0.997628f, -0.248906f, 0.000000f, 0.315022f,
	0.040558f, 0.001831f, -0.999175f, -0.321585f, 0.000000f, 0.314475f,

	0.040558f, 0.001831f, -0.999175f, -0.321585f, 0.000000f, 0.314475f,
	0.037502f, 0.541127f, -0.840104f, -0.323750f, 0.026252f, 0.319859f,
	0.007161f, 0.429674f, -0.902956f, -0.246475f, 0.026252f, 0.320491f,

	0.037502f, 0.541127f, -0.840104f, -0.323750f, 0.026252f, 0.319859f,
	0.040558f, 0.001831f, -0.999175f, -0.321585f, 0.000000f, 0.314475f,
	0.191280f, 0.002565f, -0.981532f, -0.375304f, 0.000000f, 0.310647f,

	0.191280f, 0.002565f, -0.981532f, -0.375304f, 0.000000f, 0.310647f,
	0.173069f, 0.551822f, -0.815806f, -0.380469f, 0.026252f, 0.315432f,
	0.037502f, 0.541127f, -0.840104f, -0.323750f, 0.026252f, 0.319859f,

	0.173069f, 0.551822f, -0.815806f, -0.380469f, 0.026252f, 0.315432f,
	0.191280f, 0.002565f, -0.981532f, -0.375304f, 0.000000f, 0.310647f,
	0.635539f, -0.000642f, -0.772068f, -0.408605f, 0.000000f, 0.300255f,

	0.635539f, -0.000642f, -0.772068f, -0.408605f, 0.000000f, 0.300255f,
	0.533710f, 0.610485f, -0.585202f, -0.415403f, 0.026252f, 0.303417f,
	0.173069f, 0.551822f, -0.815806f, -0.380469f, 0.026252f, 0.315432f,

	0.533710f, 0.610485f, -0.585202f, -0.415403f, 0.026252f, 0.303417f,
	0.635539f, -0.000642f, -0.772068f, -0.408605f, 0.000000f, 0.300255f,
	0.987948f, 0.003395f, -0.154746f, -0.420029f, 0.000000f, 0.280019f,

	0.987948f, 0.003395f, -0.154746f, -0.420029f, 0.000000f, 0.280019f,
	0.771143f, 0.632324f, -0.074189f, -0.427321f, 0.026252f, 0.280019f,
	0.533710f, 0.610485f, -0.585202f, -0.415403f, 0.026252f, 0.303417f,

	0.987948f, 0.003395f, -0.154746f, -0.420029f, 0.000000f, 0.280019f,
	0.762032f, -0.630861f, -0.146018f, -0.427321f, -0.026252f, 0.280019f,
	0.746397f, -0.615086f, 0.254087f, -0.420580f, -0.026252f, 0.245236f,

	0.746397f, -0.615086f, 0.254087f, -0.420580f, -0.026252f, 0.245236f,
	0.945639f, 0.005239f, 0.325175f, -0.413952f, 0.000000f, 0.248298f,
	0.987948f, 0.003395f, -0.154746f, -0.420029f, 0.000000f, 0.280019f,

	0.945639f, 0.005239f, 0.325175f, -0.413952f, 0.000000f, 0.248298f,
	0.746397f, -0.615086f, 0.254087f, -0.420580f, -0.026252f, 0.245236f,
	0.665749f, -0.583295f, 0.465345f, -0.399459f, -0.026252f, 0.205343f,

	0.665749f, -0.583295f, 0.465345f, -0.399459f, -0.026252f, 0.205343f,
	0.823675f, 0.013832f, 0.566893f, -0.394750f, 0.000000f, 0.210015f,
	0.945639f, 0.005239f, 0.325175f, -0.413952f, 0.000000f, 0.248298f,

	0.823675f, 0.013832f, 0.566893f, -0.394750f, 0.000000f, 0.210015f,
	0.665749f, -0.583295f, 0.465345f, -0.399459f, -0.026252f, 0.205343f,
	0.540019f, -0.544890f, 0.641463f, -0.362615f, -0.026252f, 0.165962f,

	0.540019f, -0.544890f, 0.641463f, -0.362615f, -0.026252f, 0.165962f,
	0.644146f, 0.011269f, 0.764819f, -0.360963f, 0.000000f, 0.171731f,
	0.823675f, 0.013832f, 0.566893f, -0.394750f, 0.000000f, 0.210015f,

	0.644146f, 0.011269f, 0.764819f, -0.360963f, 0.000000f, 0.171731f,
	0.540019f, -0.544890f, 0.641463f, -0.362615f, -0.026252f, 0.165962f,
	0.482140f, -0.413376f, 0.772438f, -0.308702f, -0.026252f, 0.132718f,

	0.482140f, -0.413376f, 0.772438f, -0.308702f, -0.026252f, 0.132718f,
	0.531524f, 0.073585f, 0.843841f, -0.311133f, 0.000000f, 0.140010f,
	0.644146f, 0.011269f, 0.764819f, -0.360963f, 0.000000f, 0.171731f,

	0.762032f, -0.630861f, -0.146018f, -0.427321f, -0.026252f, 0.280019f,
	-0.010065f, -0.998112f, -0.060596f, -0.443364f, -0.035002f, 0.280019f,
	0.005692f, -0.999341f, -0.035850f, -0.435160f, -0.035002f, 0.238500f,

	0.005692f, -0.999341f, -0.035850f, -0.435160f, -0.035002f, 0.238500f,
	0.746397f, -0.615086f, 0.254087f, -0.420580f, -0.026252f, 0.245236f,
	0.762032f, -0.630861f, -0.146018f, -0.427321f, -0.026252f, 0.280019f,

	0.746397f, -0.615086f, 0.254087f, -0.420580f, -0.026252f, 0.245236f,
	0.005692f, -0.999341f, -0.035850f, -0.435160f, -0.035002f, 0.238500f,
	0.005875f, -0.999020f, -0.043879f, -0.409820f, -0.035002f, 0.195066f,

	0.005875f, -0.999020f, -0.043879f, -0.409820f, -0.035002f, 0.195066f,
	0.665749f, -0.583295f, 0.465345f, -0.399459f, -0.026252f, 0.205343f,
	0.746397f, -0.615086f, 0.254087f, -0.420580f, -0.026252f, 0.245236f,

	0.665749f, -0.583295f, 0.465345f, -0.399459f, -0.026252f, 0.205343f,
	0.005875f, -0.999020f, -0.043879f, -0.409820f, -0.035002f, 0.195066f,
	0.017965f, -0.999157f, -0.036914f, -0.366249f, -0.035002f, 0.153272f,

	0.017965f, -0.999157f, -0.036914f, -0.366249f, -0.035002f, 0.153272f,
	0.540019f, -0.544890f, 0.641463f, -0.362615f, -0.026252f, 0.165962f,
	0.665749f, -0.583295f, 0.465345f, -0.399459f, -0.026252f, 0.205343f,

	0.540019f, -0.544890f, 0.641463f, -0.362615f, -0.026252f, 0.165962f,
	0.017965f, -0.999157f, -0.036914f, -0.366249f, -0.035002f, 0.153272f,
	0.123349f, -0.972205f, 0.199003f, -0.303354f, -0.035002f, 0.116675f,

	0.123349f, -0.972205f, 0.199003f, -0.303354f, -0.035002f, 0.116675f,
	0.482140f, -0.413376f, 0.772438f, -0.308702f, -0.026252f, 0.132718f,
	0.540019f, -0.544890f, 0.641463f, -0.362615f, -0.026252f, 0.165962f,

	-0.010065f, -0.998112f, -0.060596f, -0.443364f, -0.035002f, 0.280019f,
	-0.775985f, -0.629264f, 0.043293f, -0.459407f, -0.026252f, 0.280019f,
	-0.721620f, -0.620416f, -0.307162f, -0.449741f, -0.026252f, 0.231763f,

	-0.721620f, -0.620416f, -0.307162f, -0.449741f, -0.026252f, 0.231763f,
	0.005692f, -0.999341f, -0.035850f, -0.435160f, -0.035002f, 0.238500f,
	-0.010065f, -0.998112f, -0.060596f, -0.443364f, -0.035002f, 0.280019f,

	0.005692f, -0.999341f, -0.035850f, -0.435160f, -0.035002f, 0.238500f,
	-0.721620f, -0.620416f, -0.307162f, -0.449741f, -0.026252f, 0.231763f,
	-0.602360f, -0.597115f, -0.529731f, -0.420181f, -0.026252f, 0.184788f,

	-0.602360f, -0.597115f, -0.529731f, -0.420181f, -0.026252f, 0.184788f,
	0.005875f, -0.999020f, -0.043879f, -0.409820f, -0.035002f, 0.195066f,
	0.005692f, -0.999341f, -0.035850f, -0.435160f, -0.035002f, 0.238500f,

	0.005875f, -0.999020f, -0.043879f, -0.409820f, -0.035002f, 0.195066f,
	-0.602360f, -0.597115f, -0.529731f, -0.420181f, -0.026252f, 0.184788f,
	-0.473480f, -0.559989f, -0.679874f, -0.369884f, -0.026252f, 0.140582f,

	-0.473480f, -0.559989f, -0.679874f, -0.369884f, -0.026252f, 0.140582f,
	0.017965f, -0.999157f, -0.036914f, -0.366249f, -0.035002f, 0.153272f,
	0.005875f, -0.999020f, -0.043879f, -0.409820f, -0.035002f, 0.195066f,

	0.017965f, -0.999157f, -0.036914f, -0.366249f, -0.035002f, 0.153272f,
	-0.473480f, -0.559989f, -0.679874f, -0.369884f, -0.026252f, 0.140582f,
	-0.376284f, -0.641886f, -0.668126f, -0.298007f, -0.026252f, 0.100632f,

	-0.376284f, -0.641886f, -0.668126f, -0.298007f, -0.026252f, 0.100632f,
	0.123349f, -0.972205f, 0.199003f, -0.303354f, -0.035002f, 0.116675f,
	0.017965f, -0.999157f, -0.036914f, -0.366249f, -0.035002f, 0.153272f,

	-0.775985f, -0.629264f, 0.043293f, -0.459407f, -0.026252f, 0.280019f,
	-0.997079f, -0.001993f, 0.076346f, -0.466699f, 0.000000f, 0.280019f,
	-0.926971f, -0.003891f, -0.375113f, -0.456368f, 0.000000f, 0.228701f,

	-0.926971f, -0.003891f, -0.375113f, -0.456368f, 0.000000f, 0.228701f,
	-0.721620f, -0.620416f, -0.307162f, -0.449741f, -0.026252f, 0.231763f,
	-0.775985f, -0.629264f, 0.043293f, -0.459407f, -0.026252f, 0.280019f,

	-0.721620f, -0.620416f, -0.307162f, -0.449741f, -0.026252f, 0.231763f,
	-0.926971f, -0.003891f, -0.375113f, -0.456368f, 0.000000f, 0.228701f,
	-0.754307f, -0.010519f, -0.656438f, -0.424891f, 0.000000f, 0.180117f,

	-0.754307f, -0.010519f, -0.656438f, -0.424891f, 0.000000f, 0.180117f,
	-0.602360f, -0.597115f, -0.529731f, -0.420181f, -0.026252f, 0.184788f,
	-0.721620f, -0.620416f, -0.307162f, -0.449741f, -0.026252f, 0.231763f,

	-0.602360f, -0.597115f, -0.529731f, -0.420181f, -0.026252f, 0.184788f,
	-0.754307f, -0.010519f, -0.656438f, -0.424891f, 0.000000f, 0.180117f,
	-0.569473f, -0.008128f, -0.821970f, -0.371536f, 0.000000f, 0.134814f,

	-0.569473f, -0.008128f, -0.821970f, -0.371536f, 0.000000f, 0.134814f,
	-0.473480f, -0.559989f, -0.679874f, -0.369884f, -0.026252f, 0.140582f,
	-0.602360f, -0.597115f, -0.529731f, -0.420181f, -0.026252f, 0.184788f,

	-0.473480f, -0.559989f, -0.679874f, -0.369884f, -0.026252f, 0.140582f,
	-0.569473f, -0.008128f, -0.821970f, -0.371536f, 0.000000f, 0.134814f,
	-0.480128f, -0.073376f, -0.874124f, -0.295576f, 0.000000f, 0.093340f,

	-0.480128f, -0.073376f, -0.874124f, -0.295576f, 0.000000f, 0.093340f,
	-0.376284f, -0.641886f, -0.668126f, -0.298007f, -0.026252f, 0.100632f,
	-0.473480f, -0.559989f, -0.679874f, -0.369884f, -0.026252f, 0.140582f,

	-0.997079f, -0.001993f, 0.076346f, -0.466699f, 0.000000f, 0.280019f,
	-0.773136f, 0.628364f, 0.086140f, -0.459407f, 0.026252f, 0.280019f,
	-0.736761f, 0.617685f, -0.275043f, -0.449741f, 0.026252f, 0.231763f,

	-0.736761f, 0.617685f, -0.275043f, -0.449741f, 0.026252f, 0.231763f,
	-0.926971f, -0.003891f, -0.375113f, -0.456368f, 0.000000f, 0.228701f,
	-0.997079f, -0.001993f, 0.076346f, -0.466699f, 0.000000f, 0.280019f,

	-0.926971f, -0.003891f, -0.375113f, -0.456368f, 0.000000f, 0.228701f,
	-0.736761f, 0.617685f, -0.275043f, -0.449741f, 0.026252f, 0.231763f,
	-0.623051f, 0.588138f, -0.515657f, -0.420181f, 0.026252f, 0.184788f,

	-0.623051f, 0.588138f, -0.515657f, -0.420181f, 0.026252f, 0.184788f,
	-0.754307f, -0.010519f, -0.656438f, -0.424891f, 0.000000f, 0.180117f,
	-0.926971f, -0.003891f, -0.375113f, -0.456368f, 0.000000f, 0.228701f,

	-0.754307f, -0.010519f, -0.656438f, -0.424891f, 0.000000f, 0.180117f,
	-0.623051f, 0.588138f, -0.515657f, -0.420181f, 0.026252f, 0.184788f,
	-0.485642f, 0.552400f, -0.677500f, -0.369884f, 0.026252f, 0.140582f,

	-0.485642f, 0.552400f, -0.677500f, -0.369884f, 0.026252f, 0.140582f,
	-0.569473f, -0.008128f, -0.821970f, -0.371536f, 0.000000f, 0.134814f,
	-0.754307f, -0.010519f, -0.656438f, -0.424891f, 0.000000f, 0.180117f,

	-0.569473f, -0.008128f, -0.821970f, -0.371536f, 0.000000f, 0.134814f,
	-0.485642f, 0.552400f, -0.677500f, -0.369884f, 0.026252f, 0.140582f,
	-0.437310f, 0.425733f, -0.792156f, -0.298007f, 0.026252f, 0.100632f,

	-0.437310f, 0.425733f, -0.792156f, -0.298007f, 0.026252f, 0.100632f,
	-0.480128f, -0.073376f, -0.874124f, -0.295576f, 0.000000f, 0.093340f,
	-0.569473f, -0.008128f, -0.821970f, -0.371536f, 0.000000f, 0.134814f,

	-0.773136f, 0.628364f, 0.086140f, -0.459407f, 0.026252f, 0.280019f,
	0.008931f, 0.998776f, 0.048646f, -0.443364f, 0.035002f, 0.280019f,
	-0.002454f, 0.999573f, 0.029106f, -0.435160f, 0.035002f, 0.238500f,

	-0.002454f, 0.999573f, 0.029106f, -0.435160f, 0.035002f, 0.238500f,
	-0.736761f, 0.617685f, -0.275043f, -0.449741f, 0.026252f, 0.231763f,
	-0.773136f, 0.628364f, 0.086140f, -0.459407f, 0.026252f, 0.280019f,

	-0.736761f, 0.617685f, -0.275043f, -0.449741f, 0.026252f, 0.231763f,
	-0.002454f, 0.999573f, 0.029106f, -0.435160f, 0.035002f, 0.238500f,
	0.006245f, 0.999502f, 0.030937f, -0.409820f, 0.035002f, 0.195066f,

	0.006245f, 0.999502f, 0.030937f, -0.409820f, 0.035002f, 0.195066f,
	-0.623051f, 0.588138f, -0.515657f, -0.420181f, 0.026252f, 0.184788f,
	-0.736761f, 0.617685f, -0.275043f, -0.449741f, 0.026252f, 0.231763f,

	-0.623051f, 0.588138f, -0.515657f, -0.420181f, 0.026252f, 0.184788f,
	0.006245f, 0.999502f, 0.030937f, -0.409820f, 0.035002f, 0.195066f,
	-0.001529f, 0.999561f, 0.029588f, -0.366249f, 0.035002f, 0.153272f,

	-0.001529f, 0.999561f, 0.029588f, -0.366249f, 0.035002f, 0.153272f,
	-0.485642f, 0.552400f, -0.677500f, -0.369884f, 0.026252f, 0.140582f,
	-0.623051f, 0.588138f, -0.515657f, -0.420181f, 0.026252f, 0.184788f,

	-0.485642f, 0.552400f, -0.677500f, -0.369884f, 0.026252f, 0.140582f,
	-0.001529f, 0.999561f, 0.029588f, -0.366249f, 0.035002f, 0.153272f,
	-0.109008f, 0.974329f, -0.196977f, -0.303354f, 0.035002f, 0.116675f,

	-0.109008f, 0.974329f, -0.196977f, -0.303354f, 0.035002f, 0.116675f,
	-0.437310f, 0.425733f, -0.792156f, -0.298007f, 0.026252f, 0.100632f,
	-0.485642f, 0.552400f, -0.677500f, -0.369884f, 0.026252f, 0.140582f,

	0.008931f, 0.998776f, 0.048646f, -0.443364f, 0.035002f, 0.280019f,
	0.771143f, 0.632324f, -0.074189f, -0.427321f, 0.026252f, 0.280019f,
	0.738318f, 0.617932f, 0.270271f, -0.420580f, 0.026252f, 0.245236f,

	0.738318f, 0.617932f, 0.270271f, -0.420580f, 0.026252f, 0.245236f,
	-0.002454f, 0.999573f, 0.029106f, -0.435160f, 0.035002f, 0.238500f,
	0.008931f, 0.998776f, 0.048646f, -0.443364f, 0.035002f, 0.280019f,

	-0.002454f, 0.999573f, 0.029106f, -0.435160f, 0.035002f, 0.238500f,
	0.738318f, 0.617932f, 0.270271f, -0.420580f, 0.026252f, 0.245236f,
	0.648653f, 0.594158f, 0.475632f, -0.399459f, 0.026252f, 0.205343f,

	0.648653f, 0.594158f, 0.475632f, -0.399459f, 0.026252f, 0.205343f,
	0.006245f, 0.999502f, 0.030937f, -0.409820f, 0.035002f, 0.195066f,
	-0.002454f, 0.999573f, 0.029106f, -0.435160f, 0.035002f, 0.238500f,

	0.006245f, 0.999502f, 0.030937f, -0.409820f, 0.035002f, 0.195066f,
	0.648653f, 0.594158f, 0.475632f, -0.399459f, 0.026252f, 0.205343f,
	0.515385f, 0.556494f, 0.651685f, -0.362615f, 0.026252f, 0.165962f,

	0.515385f, 0.556494f, 0.651685f, -0.362615f, 0.026252f, 0.165962f,
	-0.001529f, 0.999561f, 0.029588f, -0.366249f, 0.035002f, 0.153272f,
	0.006245f, 0.999502f, 0.030937f, -0.409820f, 0.035002f, 0.195066f,

	-0.001529f, 0.999561f, 0.029588f, -0.366249f, 0.035002f, 0.153272f,
	0.515385f, 0.556494f, 0.651685f, -0.362615f, 0.026252f, 0.165962f,
	0.399315f, 0.638178f, 0.658237f, -0.308702f, 0.026252f, 0.132718f,

	0.399315f, 0.638178f, 0.658237f, -0.308702f, 0.026252f, 0.132718f,
	-0.109008f, 0.974329f, -0.196977f, -0.303354f, 0.035002f, 0.116675f,
	-0.001529f, 0.999561f, 0.029588f, -0.366249f, 0.035002f, 0.153272f,

	0.771143f, 0.632324f, -0.074189f, -0.427321f, 0.026252f, 0.280019f,
	0.987948f, 0.003395f, -0.154746f, -0.420029f, 0.000000f, 0.280019f,
	0.945639f, 0.005239f, 0.325175f, -0.413952f, 0.000000f, 0.248298f,

	0.945639f, 0.005239f, 0.325175f, -0.413952f, 0.000000f, 0.248298f,
	0.738318f, 0.617932f, 0.270271f, -0.420580f, 0.026252f, 0.245236f,
	0.771143f, 0.632324f, -0.074189f, -0.427321f, 0.026252f, 0.280019f,

	0.738318f, 0.617932f, 0.270271f, -0.420580f, 0.026252f, 0.245236f,
	0.945639f, 0.005239f, 0.325175f, -0.413952f, 0.000000f, 0.248298f,
	0.823675f, 0.013832f, 0.566893f, -0.394750f, 0.000000f, 0.210015f,

	0.823675f, 0.013832f, 0.566893f, -0.394750f, 0.000000f, 0.210015f,
	0.648653f, 0.594158f, 0.475632f, -0.399459f, 0.026252f, 0.205343f,
	0.738318f, 0.617932f, 0.270271f, -0.420580f, 0.026252f, 0.245236f,

	0.648653f, 0.594158f, 0.475632f, -0.399459f, 0.026252f, 0.205343f,
	0.823675f, 0.013832f, 0.566893f, -0.394750f, 0.000000f, 0.210015f,
	0.644146f, 0.011269f, 0.764819f, -0.360963f, 0.000000f, 0.171731f,

	0.644146f, 0.011269f, 0.764819f, -0.360963f, 0.000000f, 0.171731f,
	0.515385f, 0.556494f, 0.651685f, -0.362615f, 0.026252f, 0.165962f,
	0.648653f, 0.594158f, 0.475632f, -0.399459f, 0.026252f, 0.205343f,

	0.515385f, 0.556494f, 0.651685f, -0.362615f, 0.026252f, 0.165962f,
	0.644146f, 0.011269f, 0.764819f, -0.360963f, 0.000000f, 0.171731f,
	0.531524f, 0.073585f, 0.843841f, -0.311133f, 0.000000f, 0.140010f,

	0.531524f, 0.073585f, 0.843841f, -0.311133f, 0.000000f, 0.140010f,
	0.399315f, 0.638178f, 0.658237f, -0.308702f, 0.026252f, 0.132718f,
	0.515385f, 0.556494f, 0.651685f, -0.362615f, 0.026252f, 0.165962f,

	-0.229992f, -0.100414f, 0.967998f, 0.264463f, 0.000000f, 0.221682f,
	-0.131683f, -0.762088f, 0.633941f, 0.264463f, -0.057754f, 0.201629f,
	-0.323244f, -0.653304f, 0.684622f, 0.344783f, -0.052148f, 0.223949f,

	-0.323244f, -0.653304f, 0.684622f, 0.344783f, -0.052148f, 0.223949f,
	-0.539636f, 0.009488f, 0.841845f, 0.339086f, 0.000000f, 0.238819f,
	-0.229992f, -0.100414f, 0.967998f, 0.264463f, 0.000000f, 0.221682f,

	-0.539636f, 0.009488f, 0.841845f, 0.339086f, 0.000000f, 0.238819f,
	-0.323244f, -0.653304f, 0.684622f, 0.344783f, -0.052148f, 0.223949f,
	-0.608860f, -0.631104f, 0.480622f, 0.378707f, -0.039815f, 0.271360f,

	-0.608860f, -0.631104f, 0.480622f, 0.378707f, -0.039815f, 0.271360f,
	-0.870758f, -0.013331f, 0.491531f, 0.371415f, 0.000000f, 0.280019f,
	-0.539636f, 0.009488f, 0.841845f, 0.339086f, 0.000000f, 0.238819f,

	-0.870758f, -0.013331f, 0.491531f, 0.371415f, 0.000000f, 0.280019f,
	-0.608860f, -0.631104f, 0.480622f, 0.378707f, -0.039815f, 0.271360f,
	-0.616470f, -0.666104f, 0.419844f, 0.398046f, -0.027482f, 0.326837f,

	-0.616470f, -0.666104f, 0.419844f, 0.398046f, -0.027482f, 0.326837f,
	-0.875840f, -0.041591f, 0.480806f, 0.389159f, 0.000000f, 0.329971f,
	-0.870758f, -0.013331f, 0.491531f, 0.371415f, 0.000000f, 0.280019f,

	-0.875840f, -0.041591f, 0.480806f, 0.389159f, 0.000000f, 0.329971f,
	-0.616470f, -0.666104f, 0.419844f, 0.398046f, -0.027482f, 0.326837f,
	-0.447228f, -0.667563f, 0.595270f, 0.434614f, -0.021877f, 0.373359f,

	-0.447228f, -0.667563f, 0.595270f, 0.434614f, -0.021877f, 0.373359f,
	-0.654399f, -0.007163f, 0.756116f, 0.420029f, 0.000000f, 0.373359f,
	-0.875840f, -0.041591f, 0.480806f, 0.389159f, 0.000000f, 0.329971f,

	-0.131683f, -0.762088f, 0.633941f, 0.264463f, -0.057754f, 0.201629f,
	0.130084f, -0.981621f, -0.139633f, 0.264463f, -0.077005f, 0.157511f,
	0.184613f, -0.977688f, 0.100221f, 0.357316f, -0.069531f, 0.191237f,

	0.184613f, -0.977688f, 0.100221f, 0.357316f, -0.069531f, 0.191237f,
	-0.323244f, -0.653304f, 0.684622f, 0.344783f, -0.052148f, 0.223949f,
	-0.131683f, -0.762088f, 0.633941f, 0.264463f, -0.057754f, 0.201629f,

	-0.323244f, -0.653304f, 0.684622f, 0.344783f, -0.052148f, 0.223949f,
	0.184613f, -0.977688f, 0.100221f, 0.357316f, -0.069531f, 0.191237f,
	0.142094f, -0.971804f, 0.188166f, 0.394750f, -0.053087f, 0.252309f,

	0.142094f, -0.971804f, 0.188166f, 0.394750f, -0.053087f, 0.252309f,
	-0.608860f, -0.631104f, 0.480622f, 0.378707f, -0.039815f, 0.271360f,
	-0.323244f, -0.653304f, 0.684622f, 0.344783f, -0.052148f, 0.223949f,

	-0.608860f, -0.631104f, 0.480622f, 0.378707f, -0.039815f, 0.271360f,
	0.142094f, -0.971804f, 0.188166f, 0.394750f, -0.053087f, 0.252309f,
	0.012364f, -0.990270f, 0.138612f, 0.417598f, -0.036643f, 0.319944f,

	0.012364f, -0.990270f, 0.138612f, 0.417598f, -0.036643f, 0.319944f,
	-0.616470f, -0.666104f, 0.419844f, 0.398046f, -0.027482f, 0.326837f,
	-0.608860f, -0.631104f, 0.480622f, 0.378707f, -0.039815f, 0.271360f,

	-0.616470f, -0.666104f, 0.419844f, 0.398046f, -0.027482f, 0.326837f,
	0.012364f, -0.990270f, 0.138612f, 0.417598f, -0.036643f, 0.319944f,
	-0.008458f, -0.991428f, 0.130379f, 0.466699f, -0.029169f, 0.373359f,

	-0.008458f, -0.991428f, 0.130379f, 0.466699f, -0.029169f, 0.373359f,
	-0.447228f, -0.667563f, 0.595270f, 0.434614f, -0.021877f, 0.373359f,
	-0.616470f, -0.666104f, 0.419844f, 0.398046f, -0.027482f, 0.326837f,

	0.130084f, -0.981621f, -0.139633f, 0.264463f, -0.077005f, 0.157511f,
	0.358242f, -0.534308f, -0.765623f, 0.264463f, -0.057754f, 0.113393f,
	0.587433f, -0.626319f, -0.512491f, 0.369850f, -0.052148f, 0.158525f,

	0.587433f, -0.626319f, -0.512491f, 0.369850f, -0.052148f, 0.158525f,
	0.184613f, -0.977688f, 0.100221f, 0.357316f, -0.069531f, 0.191237f,
	0.130084f, -0.981621f, -0.139633f, 0.264463f, -0.077005f, 0.157511f,

	0.184613f, -0.977688f, 0.100221f, 0.357316f, -0.069531f, 0.191237f,
	0.587433f, -0.626319f, -0.512491f, 0.369850f, -0.052148f, 0.158525f,
	0.783688f, -0.572435f, -0.241146f, 0.410792f, -0.039815f, 0.233258f,

	0.783688f, -0.572435f, -0.241146f, 0.410792f, -0.039815f, 0.233258f,
	0.142094f, -0.971804f, 0.188166f, 0.394750f, -0.053087f, 0.252309f,
	0.184613f, -0.977688f, 0.100221f, 0.357316f, -0.069531f, 0.191237f,

	0.142094f, -0.971804f, 0.188166f, 0.394750f, -0.053087f, 0.252309f,
	0.783688f, -0.572435f, -0.241146f, 0.410792f, -0.039815f, 0.233258f,
	0.658870f, -0.672724f, -0.336649f, 0.437151f, -0.027482f, 0.313051f,

	0.658870f, -0.672724f, -0.336649f, 0.437151f, -0.027482f, 0.313051f,
	0.012364f, -0.990270f, 0.138612f, 0.417598f, -0.036643f, 0.319944f,
	0.142094f, -0.971804f, 0.188166f, 0.394750f, -0.053087f, 0.252309f,

	0.012364f, -0.990270f, 0.138612f, 0.417598f, -0.036643f, 0.319944f,
	0.658870f, -0.672724f, -0.336649f, 0.437151f, -0.027482f, 0.313051f,
	0.425912f, -0.720365f, -0.547425f, 0.498785f, -0.021877f, 0.373359f,

	0.425912f, -0.720365f, -0.547425f, 0.498785f, -0.021877f, 0.373359f,
	-0.008458f, -0.991428f, 0.130379f, 0.466699f, -0.029169f, 0.373359f,
	0.012364f, -0.990270f, 0.138612f, 0.417598f, -0.036643f, 0.319944f,

	0.358242f, -0.534308f, -0.765623f, 0.264463f, -0.057754f, 0.113393f,
	0.408904f, 0.101526f, -0.906913f, 0.264463f, 0.000000f, 0.093340f,
	0.689450f, -0.009139f, -0.724276f, 0.375547f, 0.000000f, 0.143656f,

	0.689450f, -0.009139f, -0.724276f, 0.375547f, 0.000000f, 0.143656f,
	0.587433f, -0.626319f, -0.512491f, 0.369850f, -0.052148f, 0.158525f,
	0.358242f, -0.534308f, -0.765623f, 0.264463f, -0.057754f, 0.113393f,

	0.587433f, -0.626319f, -0.512491f, 0.369850f, -0.052148f, 0.158525f,
	0.689450f, -0.009139f, -0.724276f, 0.375547f, 0.000000f, 0.143656f,
	0.924140f, 0.016993f, -0.381675f, 0.418085f, 0.000000f, 0.224599f,

	0.924140f, 0.016993f, -0.381675f, 0.418085f, 0.000000f, 0.224599f,
	0.783688f, -0.572435f, -0.241146f, 0.410792f, -0.039815f, 0.233258f,
	0.587433f, -0.626319f, -0.512491f, 0.369850f, -0.052148f, 0.158525f,

	0.783688f, -0.572435f, -0.241146f, 0.410792f, -0.039815f, 0.233258f,
	0.924140f, 0.016993f, -0.381675f, 0.418085f, 0.000000f, 0.224599f,
	0.852329f, 0.033867f, -0.521908f, 0.446038f, 0.000000f, 0.309917f,

	0.852329f, 0.033867f, -0.521908f, 0.446038f, 0.000000f, 0.309917f,
	0.658870f, -0.672724f, -0.336649f, 0.437151f, -0.027482f, 0.313051f,
	0.783688f, -0.572435f, -0.241146f, 0.410792f, -0.039815f, 0.233258f,

	0.658870f, -0.672724f, -0.336649f, 0.437151f, -0.027482f, 0.313051f,
	0.852329f, 0.033867f, -0.521908f, 0.446038f, 0.000000f, 0.309917f,
	0.575860f, 0.001784f, -0.817547f, 0.513369f, 0.000000f, 0.373359f,

	0.575860f, 0.001784f, -0.817547f, 0.513369f, 0.000000f, 0.373359f,
	0.425912f, -0.720365f, -0.547425f, 0.498785f, -0.021877f, 0.373359f,
	0.658870f, -0.672724f, -0.336649f, 0.437151f, -0.027482f, 0.313051f,

	0.408904f, 0.101526f, -0.906913f, 0.264463f, 0.000000f, 0.093340f,
	0.293438f, 0.749941f, -0.592860f, 0.264463f, 0.057754f, 0.113393f,
	0.564215f, 0.622238f, -0.542661f, 0.369850f, 0.052148f, 0.158525f,

	0.564215f, 0.622238f, -0.542661f, 0.369850f, 0.052148f, 0.158525f,
	0.689450f, -0.009139f, -0.724276f, 0.375547f, 0.000000f, 0.143656f,
	0.408904f, 0.101526f, -0.906913f, 0.264463f, 0.000000f, 0.093340f,

	0.689450f, -0.009139f, -0.724276f, 0.375547f, 0.000000f, 0.143656f,
	0.564215f, 0.622238f, -0.542661f, 0.369850f, 0.052148f, 0.158525f,
	0.770625f, 0.589367f, -0.242454f, 0.410792f, 0.039815f, 0.233258f,

	0.770625f, 0.589367f, -0.242454f, 0.410792f, 0.039815f, 0.233258f,
	0.924140f, 0.016993f, -0.381675f, 0.418085f, 0.000000f, 0.224599f,
	0.689450f, -0.009139f, -0.724276f, 0.375547f, 0.000000f, 0.143656f,

	0.924140f, 0.016993f, -0.381675f, 0.418085f, 0.000000f, 0.224599f,
	0.770625f, 0.589367f, -0.242454f, 0.410792f, 0.039815f, 0.233258f,
	0.663789f, 0.686526f, -0.296760f, 0.437151f, 0.027482f, 0.313051f,

	0.663789f, 0.686526f, -0.296760f, 0.437151f, 0.027482f, 0.313051f,
	0.852329f, 0.033867f, -0.521908f, 0.446038f, 0.000000f, 0.309917f,
	0.924140f, 0.016993f, -0.381675f, 0.418085f, 0.000000f, 0.224599f,

	0.852329f, 0.033867f, -0.521908f, 0.446038f, 0.000000f, 0.309917f,
	0.663789f, 0.686526f, -0.296760f, 0.437151f, 0.027482f, 0.313051f,
	0.447928f, 0.731143f, -0.514578f, 0.498785f, 0.021877f, 0.373359f,

	0.447928f, 0.731143f, -0.514578f, 0.498785f, 0.021877f, 0.373359f,
	0.575860f, 0.001784f, -0.817547f, 0.513369f, 0.000000f, 0.373359f,
	0.852329f, 0.033867f, -0.521908f, 0.446038f, 0.000000f, 0.309917f,

	0.293438f, 0.749941f, -0.592860f, 0.264463f, 0.057754f, 0.113393f,
	0.028672f, 0.986048f, 0.163973f, 0.264463f, 0.077005f, 0.157511f,
	0.091185f, 0.994484f, 0.051840f, 0.357316f, 0.069531f, 0.191237f,

	0.091185f, 0.994484f, 0.051840f, 0.357316f, 0.069531f, 0.191237f,
	0.564215f, 0.622238f, -0.542661f, 0.369850f, 0.052148f, 0.158525f,
	0.293438f, 0.749941f, -0.592860f, 0.264463f, 0.057754f, 0.113393f,

	0.564215f, 0.622238f, -0.542661f, 0.369850f, 0.052148f, 0.158525f,
	0.091185f, 0.994484f, 0.051840f, 0.357316f, 0.069531f, 0.191237f,
	0.163595f, 0.977265f, 0.134868f, 0.394750f, 0.053087f, 0.252309f,

	0.163595f, 0.977265f, 0.134868f, 0.394750f, 0.053087f, 0.252309f,
	0.770625f, 0.589367f, -0.242454f, 0.410792f, 0.039815f, 0.233258f,
	0.564215f, 0.622238f, -0.542661f, 0.369850f, 0.052148f, 0.158525f,

	0.770625f, 0.589367f, -0.242454f, 0.410792f, 0.039815f, 0.233258f,
	0.163595f, 0.977265f, 0.134868f, 0.394750f, 0.053087f, 0.252309f,
	0.109339f, 0.983880f, 0.141513f, 0.417598f, 0.036643f, 0.319944f,

	0.109339f, 0.983880f, 0.141513f, 0.417598f, 0.036643f, 0.319944f,
	0.663789f, 0.686526f, -0.296760f, 0.437151f, 0.027482f, 0.313051f,
	0.770625f, 0.589367f, -0.242454f, 0.410792f, 0.039815f, 0.233258f,

	0.663789f, 0.686526f, -0.296760f, 0.437151f, 0.027482f, 0.313051f,
	0.109339f, 0.983880f, 0.141513f, 0.417598f, 0.036643f, 0.319944f,
	0.039616f, 0.987420f, 0.153078f, 0.466699f, 0.029169f, 0.373359f,

	0.039616f, 0.987420f, 0.153078f, 0.466699f, 0.029169f, 0.373359f,
	0.447928f, 0.731143f, -0.514578f, 0.498785f, 0.021877f, 0.373359f,
	0.663789f, 0.686526f, -0.296760f, 0.437151f, 0.027482f, 0.313051f,

	0.028672f, 0.986048f, 0.163973f, 0.264463f, 0.077005f, 0.157511f,
	-0.179654f, 0.552298f, 0.814058f, 0.264463f, 0.057754f, 0.201629f,
	-0.396952f, 0.663419f, 0.634275f, 0.344783f, 0.052148f, 0.223949f,

	-0.396952f, 0.663419f, 0.634275f, 0.344783f, 0.052148f, 0.223949f,
	0.091185f, 0.994484f, 0.051840f, 0.357316f, 0.069531f, 0.191237f,
	0.028672f, 0.986048f, 0.163973f, 0.264463f, 0.077005f, 0.157511f,

	0.091185f, 0.994484f, 0.051840f, 0.357316f, 0.069531f, 0.191237f,
	-0.396952f, 0.663419f, 0.634275f, 0.344783f, 0.052148f, 0.223949f,
	-0.621577f, 0.644387f, 0.445429f, 0.378707f, 0.039815f, 0.271360f,

	-0.621577f, 0.644387f, 0.445429f, 0.378707f, 0.039815f, 0.271360f,
	0.163595f, 0.977265f, 0.134868f, 0.394750f, 0.053087f, 0.252309f,
	0.091185f, 0.994484f, 0.051840f, 0.357316f, 0.069531f, 0.191237f,

	0.163595f, 0.977265f, 0.134868f, 0.394750f, 0.053087f, 0.252309f,
	-0.621577f, 0.644387f, 0.445429f, 0.378707f, 0.039815f, 0.271360f,
	-0.587611f, 0.674281f, 0.447279f, 0.398046f, 0.027482f, 0.326837f,

	-0.587611f, 0.674281f, 0.447279f, 0.398046f, 0.027482f, 0.326837f,
	0.109339f, 0.983880f, 0.141513f, 0.417598f, 0.036643f, 0.319944f,
	0.163595f, 0.977265f, 0.134868f, 0.394750f, 0.053087f, 0.252309f,

	0.109339f, 0.983880f, 0.141513f, 0.417598f, 0.036643f, 0.319944f,
	-0.587611f, 0.674281f, 0.447279f, 0.398046f, 0.027482f, 0.326837f,
	-0.411960f, 0.673650f, 0.613583f, 0.434614f, 0.021877f, 0.373359f,

	-0.411960f, 0.673650f, 0.613583f, 0.434614f, 0.021877f, 0.373359f,
	0.039616f, 0.987420f, 0.153078f, 0.466699f, 0.029169f, 0.373359f,
	0.109339f, 0.983880f, 0.141513f, 0.417598f, 0.036643f, 0.319944f,

	-0.179654f, 0.552298f, 0.814058f, 0.264463f, 0.057754f, 0.201629f,
	-0.229992f, -0.100414f, 0.967998f, 0.264463f, 0.000000f, 0.221682f,
	-0.539636f, 0.009488f, 0.841845f, 0.339086f, 0.000000f, 0.238819f,

	-0.539636f, 0.009488f, 0.841845f, 0.339086f, 0.000000f, 0.238819f,
	-0.396952f, 0.663419f, 0.634275f, 0.344783f, 0.052148f, 0.223949f,
	-0.179654f, 0.552298f, 0.814058f, 0.264463f, 0.057754f, 0.201629f,

	-0.396952f, 0.663419f, 0.634275f, 0.344783f, 0.052148f, 0.223949f,
	-0.539636f, 0.009488f, 0.841845f, 0.339086f, 0.000000f, 0.238819f,
	-0.870758f, -0.013331f, 0.491531f, 0.371415f, 0.000000f, 0.280019f,

	-0.870758f, -0.013331f, 0.491531f, 0.371415f, 0.000000f, 0.280019f,
	-0.621577f, 0.644387f, 0.445429f, 0.378707f, 0.039815f, 0.271360f,
	-0.396952f, 0.663419f, 0.634275f, 0.344783f, 0.052148f, 0.223949f,

	-0.621577f, 0.644387f, 0.445429f, 0.378707f, 0.039815f, 0.271360f,
	-0.870758f, -0.013331f, 0.491531f, 0.371415f, 0.000000f, 0.280019f,
	-0.875840f, -0.041591f, 0.480806f, 0.389159f, 0.000000f, 0.329971f,

	-0.875840f, -0.041591f, 0.480806f, 0.389159f, 0.000000f, 0.329971f,
	-0.587611f, 0.674281f, 0.447279f, 0.398046f, 0.027482f, 0.326837f,
	-0.621577f, 0.644387f, 0.445429f, 0.378707f, 0.039815f, 0.271360f,

	-0.587611f, 0.674281f, 0.447279f, 0.398046f, 0.027482f, 0.326837f,
	-0.875840f, -0.041591f, 0.480806f, 0.389159f, 0.000000f, 0.329971f,
	-0.654399f, -0.007163f, 0.756116f, 0.420029f, 0.000000f, 0.373359f,

	-0.654399f, -0.007163f, 0.756116f, 0.420029f, 0.000000f, 0.373359f,
	-0.411960f, 0.673650f, 0.613583f, 0.434614f, 0.021877f, 0.373359f,
	-0.587611f, 0.674281f, 0.447279f, 0.398046f, 0.027482f, 0.326837f,

	-0.654399f, -0.007163f, 0.756116f, 0.420029f, 0.000000f, 0.373359f,
	-0.447228f, -0.667563f, 0.595270f, 0.434614f, -0.021877f, 0.373359f,
	-0.272791f, -0.449689f, 0.850509f, 0.446830f, -0.020509f, 0.380243f,

	-0.272791f, -0.449689f, 0.850509f, 0.446830f, -0.020509f, 0.380243f,
	-0.372445f, 0.020246f, 0.927833f, 0.431210f, 0.000000f, 0.379922f,
	-0.654399f, -0.007163f, 0.756116f, 0.420029f, 0.000000f, 0.373359f,

	-0.372445f, 0.020246f, 0.927833f, 0.431210f, 0.000000f, 0.379922f,
	-0.272791f, -0.449689f, 0.850509f, 0.446830f, -0.020509f, 0.380243f,
	0.017882f, 0.165120f, 0.986111f, 0.454135f, -0.017501f, 0.382623f,

	0.017882f, 0.165120f, 0.986111f, 0.454135f, -0.017501f, 0.382623f,
	0.192191f, 0.131682f, 0.972483f, 0.439475f, 0.000000f, 0.382110f,
	-0.372445f, 0.020246f, 0.927833f, 0.431210f, 0.000000f, 0.379922f,

	0.192191f, 0.131682f, 0.972483f, 0.439475f, 0.000000f, 0.382110f,
	0.017882f, 0.165120f, 0.986111f, 0.454135f, -0.017501f, 0.382623f,
	0.454322f, 0.847881f, 0.273294f, 0.454354f, -0.014493f, 0.380371f,

	0.454322f, 0.847881f, 0.273294f, 0.454354f, -0.014493f, 0.380371f,
	0.999464f, -0.009588f, 0.031311f, 0.441906f, 0.000000f, 0.379922f,
	0.192191f, 0.131682f, 0.972483f, 0.439475f, 0.000000f, 0.382110f,

	0.999464f, -0.009588f, 0.031311f, 0.441906f, 0.000000f, 0.379922f,
	0.454322f, 0.847881f, 0.273294f, 0.454354f, -0.014493f, 0.380371f,
	0.517162f, 0.703389f, -0.487634f, 0.445309f, -0.013126f, 0.373359f,

	0.517162f, 0.703389f, -0.487634f, 0.445309f, -0.013126f, 0.373359f,
	0.688257f, -0.179010f, -0.703034f, 0.435586f, 0.000000f, 0.373359f,
	0.999464f, -0.009588f, 0.031311f, 0.441906f, 0.000000f, 0.379922f,

	-0.447228f, -0.667563f, 0.595270f, 0.434614f, -0.021877f, 0.373359f,
	-0.008458f, -0.991428f, 0.130379f, 0.466699f, -0.029169f, 0.373359f,
	-0.008179f, -0.823588f, 0.567129f, 0.481192f, -0.027346f, 0.380948f,

	-0.008179f, -0.823588f, 0.567129f, 0.481192f, -0.027346f, 0.380948f,
	-0.272791f, -0.449689f, 0.850509f, 0.446830f, -0.020509f, 0.380243f,
	-0.447228f, -0.667563f, 0.595270f, 0.434614f, -0.021877f, 0.373359f,

	-0.272791f, -0.449689f, 0.850509f, 0.446830f, -0.020509f, 0.380243f,
	-0.008179f, -0.823588f, 0.567129f, 0.481192f, -0.027346f, 0.380948f,
	-0.052221f, -0.027849f, 0.998247f, 0.486388f, -0.023335f, 0.383751f,

	-0.052221f, -0.027849f, 0.998247f, 0.486388f, -0.023335f, 0.383751f,
	0.017882f, 0.165120f, 0.986111f, 0.454135f, -0.017501f, 0.382623f,
	-0.272791f, -0.449689f, 0.850509f, 0.446830f, -0.020509f, 0.380243f,

	0.017882f, 0.165120f, 0.986111f, 0.454135f, -0.017501f, 0.382623f,
	-0.052221f, -0.027849f, 0.998247f, 0.486388f, -0.023335f, 0.383751f,
	-0.021371f, 0.776191f, 0.630135f, 0.481739f, -0.019324f, 0.381358f,

	-0.021371f, 0.776191f, 0.630135f, 0.481739f, -0.019324f, 0.381358f,
	0.454322f, 0.847881f, 0.273294f, 0.454354f, -0.014493f, 0.380371f,
	0.017882f, 0.165120f, 0.986111f, 0.454135f, -0.017501f, 0.382623f,

	0.454322f, 0.847881f, 0.273294f, 0.454354f, -0.014493f, 0.380371f,
	-0.021371f, 0.776191f, 0.630135f, 0.481739f, -0.019324f, 0.381358f,
	0.072464f, 0.990147f, 0.119824f, 0.466699f, -0.017501f, 0.373359f,

	0.072464f, 0.990147f, 0.119824f, 0.466699f, -0.017501f, 0.373359f,
	0.517162f, 0.703389f, -0.487634f, 0.445309f, -0.013126f, 0.373359f,
	0.454322f, 0.847881f, 0.273294f, 0.454354f, -0.014493f, 0.380371f,

	-0.008458f, -0.991428f, 0.130379f, 0.466699f, -0.029169f, 0.373359f,
	0.425912f, -0.720365f, -0.547425f, 0.498785f, -0.021877f, 0.373359f,
	0.492198f, -0.834680f, -0.247086f, 0.515555f, -0.020509f, 0.381653f,

	0.492198f, -0.834680f, -0.247086f, 0.515555f, -0.020509f, 0.381653f,
	-0.008179f, -0.823588f, 0.567129f, 0.481192f, -0.027346f, 0.380948f,
	-0.008458f, -0.991428f, 0.130379f, 0.466699f, -0.029169f, 0.373359f,

	-0.008179f, -0.823588f, 0.567129f, 0.481192f, -0.027346f, 0.380948f,
	0.492198f, -0.834680f, -0.247086f, 0.515555f, -0.020509f, 0.381653f,
	0.108410f, -0.314074f, 0.943189f, 0.518641f, -0.017501f, 0.384879f,

	0.108410f, -0.314074f, 0.943189f, 0.518641f, -0.017501f, 0.384879f,
	-0.052221f, -0.027849f, 0.998247f, 0.486388f, -0.023335f, 0.383751f,
	-0.008179f, -0.823588f, 0.567129f, 0.481192f, -0.027346f, 0.380948f,

	-0.052221f, -0.027849f, 0.998247f, 0.486388f, -0.023335f, 0.383751f,
	0.108410f, -0.314074f, 0.943189f, 0.518641f, -0.017501f, 0.384879f,
	-0.227419f, 0.412282f, 0.882215f, 0.509125f, -0.014493f, 0.382345f,

	-0.227419f, 0.412282f, 0.882215f, 0.509125f, -0.014493f, 0.382345f,
	-0.021371f, 0.776191f, 0.630135f, 0.481739f, -0.019324f, 0.381358f,
	-0.052221f, -0.027849f, 0.998247f, 0.486388f, -0.023335f, 0.383751f,

	-0.021371f, 0.776191f, 0.630135f, 0.481739f, -0.019324f, 0.381358f,
	-0.227419f, 0.412282f, 0.882215f, 0.509125f, -0.014493f, 0.382345f,
	-0.248317f, 0.689202f, 0.680690f, 0.488089f, -0.013126f, 0.373359f,

	-0.248317f, 0.689202f, 0.680690f, 0.488089f, -0.013126f, 0.373359f,
	0.072464f, 0.990147f, 0.119824f, 0.466699f, -0.017501f, 0.373359f,
	-0.021371f, 0.776191f, 0.630135f, 0.481739f, -0.019324f, 0.381358f,

	0.425912f, -0.720365f, -0.547425f, 0.498785f, -0.021877f, 0.373359f,
	0.575860f, 0.001784f, -0.817547f, 0.513369f, 0.000000f, 0.373359f,
	0.688887f, 0.064895f, -0.721958f, 0.531174f, 0.000000f, 0.381973f,

	0.688887f, 0.064895f, -0.721958f, 0.531174f, 0.000000f, 0.381973f,
	0.492198f, -0.834680f, -0.247086f, 0.515555f, -0.020509f, 0.381653f,
	0.425912f, -0.720365f, -0.547425f, 0.498785f, -0.021877f, 0.373359f,

	0.492198f, -0.834680f, -0.247086f, 0.515555f, -0.020509f, 0.381653f,
	0.688887f, 0.064895f, -0.721958f, 0.531174f, 0.000000f, 0.381973f,
	0.604405f, -0.295734f, 0.739754f, 0.533301f, 0.000000f, 0.385391f,

	0.604405f, -0.295734f, 0.739754f, 0.533301f, 0.000000f, 0.385391f,
	0.108410f, -0.314074f, 0.943189f, 0.518641f, -0.017501f, 0.384879f,
	0.492198f, -0.834680f, -0.247086f, 0.515555f, -0.020509f, 0.381653f,

	0.108410f, -0.314074f, 0.943189f, 0.518641f, -0.017501f, 0.384879f,
	0.604405f, -0.295734f, 0.739754f, 0.533301f, 0.000000f, 0.385391f,
	-0.293059f, -0.020939f, 0.955865f, 0.521573f, 0.000000f, 0.382794f,

	-0.293059f, -0.020939f, 0.955865f, 0.521573f, 0.000000f, 0.382794f,
	-0.227419f, 0.412282f, 0.882215f, 0.509125f, -0.014493f, 0.382345f,
	0.108410f, -0.314074f, 0.943189f, 0.518641f, -0.017501f, 0.384879f,

	-0.227419f, 0.412282f, 0.882215f, 0.509125f, -0.014493f, 0.382345f,
	-0.293059f, -0.020939f, 0.955865f, 0.521573f, 0.000000f, 0.382794f,
	-0.370064f, 0.097326f, 0.923894f, 0.497812f, 0.000000f, 0.373359f,

	-0.370064f, 0.097326f, 0.923894f, 0.497812f, 0.000000f, 0.373359f,
	-0.248317f, 0.689202f, 0.680690f, 0.488089f, -0.013126f, 0.373359f,
	-0.227419f, 0.412282f, 0.882215f, 0.509125f, -0.014493f, 0.382345f,

	0.575860f, 0.001784f, -0.817547f, 0.513369f, 0.000000f, 0.373359f,
	0.447928f, 0.731143f, -0.514578f, 0.498785f, 0.021877f, 0.373359f,
	0.490982f, 0.850980f, -0.186466f, 0.515555f, 0.020509f, 0.381653f,

	0.490982f, 0.850980f, -0.186466f, 0.515555f, 0.020509f, 0.381653f,
	0.688887f, 0.064895f, -0.721958f, 0.531174f, 0.000000f, 0.381973f,
	0.575860f, 0.001784f, -0.817547f, 0.513369f, 0.000000f, 0.373359f,

	0.688887f, 0.064895f, -0.721958f, 0.531174f, 0.000000f, 0.381973f,
	0.490982f, 0.850980f, -0.186466f, 0.515555f, 0.020509f, 0.381653f,
	0.373475f, 0.305185f, 0.876001f, 0.518641f, 0.017501f, 0.384879f,

	0.373475f, 0.305185f, 0.876001f, 0.518641f, 0.017501f, 0.384879f,
	0.604405f, -0.295734f, 0.739754f, 0.533301f, 0.000000f, 0.385391f,
	0.688887f, 0.064895f, -0.721958f, 0.531174f, 0.000000f, 0.381973f,

	0.604405f, -0.295734f, 0.739754f, 0.533301f, 0.000000f, 0.385391f,
	0.373475f, 0.305185f, 0.876001f, 0.518641f, 0.017501f, 0.384879f,
	-0.219802f, -0.479647f, 0.849486f, 0.509125f, 0.014493f, 0.382345f,

	-0.219802f, -0.479647f, 0.849486f, 0.509125f, 0.014493f, 0.382345f,
	-0.293059f, -0.020939f, 0.955865f, 0.521573f, 0.000000f, 0.382794f,
	0.604405f, -0.295734f, 0.739754f, 0.533301f, 0.000000f, 0.385391f,

	-0.293059f, -0.020939f, 0.955865f, 0.521573f, 0.000000f, 0.382794f,
	-0.219802f, -0.479647f, 0.849486f, 0.509125f, 0.014493f, 0.382345f,
	-0.313198f, -0.486838f, 0.815412f, 0.488089f, 0.013126f, 0.373359f,

	-0.313198f, -0.486838f, 0.815412f, 0.488089f, 0.013126f, 0.373359f,
	-0.370064f, 0.097326f, 0.923894f, 0.497812f, 0.000000f, 0.373359f,
	-0.293059f, -0.020939f, 0.955865f, 0.521573f, 0.000000f, 0.382794f,

	0.447928f, 0.731143f, -0.514578f, 0.498785f, 0.021877f, 0.373359f,
	0.039616f, 0.987420f, 0.153078f, 0.466699f, 0.029169f, 0.373359f,
	0.026273f, 0.854777f, 0.518331f, 0.481192f, 0.027346f, 0.380948f,

	0.026273f, 0.854777f, 0.518331f, 0.481192f, 0.027346f, 0.380948f,
	0.490982f, 0.850980f, -0.186466f, 0.515555f, 0.020509f, 0.381653f,
	0.447928f, 0.731143f, -0.514578f, 0.498785f, 0.021877f, 0.373359f,

	0.490982f, 0.850980f, -0.186466f, 0.515555f, 0.020509f, 0.381653f,
	0.026273f, 0.854777f, 0.518331f, 0.481192f, 0.027346f, 0.380948f,
	0.034912f, 0.069814f, 0.996949f, 0.486388f, 0.023335f, 0.383751f,

	0.034912f, 0.069814f, 0.996949f, 0.486388f, 0.023335f, 0.383751f,
	0.373475f, 0.305185f, 0.876001f, 0.518641f, 0.017501f, 0.384879f,
	0.490982f, 0.850980f, -0.186466f, 0.515555f, 0.020509f, 0.381653f,

	0.373475f, 0.305185f, 0.876001f, 0.518641f, 0.017501f, 0.384879f,
	0.034912f, 0.069814f, 0.996949f, 0.486388f, 0.023335f, 0.383751f,
	0.012311f, -0.819062f, 0.573572f, 0.481739f, 0.019324f, 0.381358f,

	0.012311f, -0.819062f, 0.573572f, 0.481739f, 0.019324f, 0.381358f,
	-0.219802f, -0.479647f, 0.849486f, 0.509125f, 0.014493f, 0.382345f,
	0.373475f, 0.305185f, 0.876001f, 0.518641f, 0.017501f, 0.384879f,

	-0.219802f, -0.479647f, 0.849486f, 0.509125f, 0.014493f, 0.382345f,
	0.012311f, -0.819062f, 0.573572f, 0.481739f, 0.019324f, 0.381358f,
	-0.050040f, -0.947581f, 0.315574f, 0.466699f, 0.017501f, 0.373359f,

	-0.050040f, -0.947581f, 0.315574f, 0.466699f, 0.017501f, 0.373359f,
	-0.313198f, -0.486838f, 0.815412f, 0.488089f, 0.013126f, 0.373359f,
	-0.219802f, -0.479647f, 0.849486f, 0.509125f, 0.014493f, 0.382345f,

	0.039616f, 0.987420f, 0.153078f, 0.466699f, 0.029169f, 0.373359f,
	-0.411960f, 0.673650f, 0.613583f, 0.434614f, 0.021877f, 0.373359f,
	-0.249613f, 0.495176f, 0.832163f, 0.446830f, 0.020509f, 0.380243f,

	-0.249613f, 0.495176f, 0.832163f, 0.446830f, 0.020509f, 0.380243f,
	0.026273f, 0.854777f, 0.518331f, 0.481192f, 0.027346f, 0.380948f,
	0.039616f, 0.987420f, 0.153078f, 0.466699f, 0.029169f, 0.373359f,

	0.026273f, 0.854777f, 0.518331f, 0.481192f, 0.027346f, 0.380948f,
	-0.249613f, 0.495176f, 0.832163f, 0.446830f, 0.020509f, 0.380243f,
	0.148008f, -0.100290f, 0.983888f, 0.454135f, 0.017501f, 0.382623f,

	0.148008f, -0.100290f, 0.983888f, 0.454135f, 0.017501f, 0.382623f,
	0.034912f, 0.069814f, 0.996949f, 0.486388f, 0.023335f, 0.383751f,
	0.026273f, 0.854777f, 0.518331f, 0.481192f, 0.027346f, 0.380948f,

	0.034912f, 0.069814f, 0.996949f, 0.486388f, 0.023335f, 0.383751f,
	0.148008f, -0.100290f, 0.983888f, 0.454135f, 0.017501f, 0.382623f,
	0.486354f, -0.841119f, 0.236599f, 0.454354f, 0.014493f, 0.380371f,

	0.486354f, -0.841119f, 0.236599f, 0.454354f, 0.014493f, 0.380371f,
	0.012311f, -0.819062f, 0.573572f, 0.481739f, 0.019324f, 0.381358f,
	0.034912f, 0.069814f, 0.996949f, 0.486388f, 0.023335f, 0.383751f,

	0.012311f, -0.819062f, 0.573572f, 0.481739f, 0.019324f, 0.381358f,
	0.486354f, -0.841119f, 0.236599f, 0.454354f, 0.014493f, 0.380371f,
	0.354712f, -0.879462f, -0.317375f, 0.445309f, 0.013126f, 0.373359f,

	0.354712f, -0.879462f, -0.317375f, 0.445309f, 0.013126f, 0.373359f,
	-0.050040f, -0.947581f, 0.315574f, 0.466699f, 0.017501f, 0.373359f,
	0.012311f, -0.819062f, 0.573572f, 0.481739f, 0.019324f, 0.381358f,

	-0.411960f, 0.673650f, 0.613583f, 0.434614f, 0.021877f, 0.373359f,
	-0.654399f, -0.007163f, 0.756116f, 0.420029f, 0.000000f, 0.373359f,
	-0.372445f, 0.020246f, 0.927833f, 0.431210f, 0.000000f, 0.379922f,

	-0.372445f, 0.020246f, 0.927833f, 0.431210f, 0.000000f, 0.379922f,
	-0.249613f, 0.495176f, 0.832163f, 0.446830f, 0.020509f, 0.380243f,
	-0.411960f, 0.673650f, 0.613583f, 0.434614f, 0.021877f, 0.373359f,

	-0.249613f, 0.495176f, 0.832163f, 0.446830f, 0.020509f, 0.380243f,
	-0.372445f, 0.020246f, 0.927833f, 0.431210f, 0.000000f, 0.379922f,
	0.192191f, 0.131682f, 0.972483f, 0.439475f, 0.000000f, 0.382110f,

	0.192191f, 0.131682f, 0.972483f, 0.439475f, 0.000000f, 0.382110f,
	0.148008f, -0.100290f, 0.983888f, 0.454135f, 0.017501f, 0.382623f,
	-0.249613f, 0.495176f, 0.832163f, 0.446830f, 0.020509f, 0.380243f,

	0.148008f, -0.100290f, 0.983888f, 0.454135f, 0.017501f, 0.382623f,
	0.192191f, 0.131682f, 0.972483f, 0.439475f, 0.000000f, 0.382110f,
	0.999464f, -0.009588f, 0.031311f, 0.441906f, 0.000000f, 0.379922f,

	0.999464f, -0.009588f, 0.031311f, 0.441906f, 0.000000f, 0.379922f,
	0.486354f, -0.841119f, 0.236599f, 0.454354f, 0.014493f, 0.380371f,
	0.148008f, -0.100290f, 0.983888f, 0.454135f, 0.017501f, 0.382623f,

	0.486354f, -0.841119f, 0.236599f, 0.454354f, 0.014493f, 0.380371f,
	0.999464f, -0.009588f, 0.031311f, 0.441906f, 0.000000f, 0.379922f,
	0.688257f, -0.179010f, -0.703034f, 0.435586f, 0.000000f, 0.373359f,

	0.688257f, -0.179010f, -0.703034f, 0.435586f, 0.000000f, 0.373359f,
	0.354712f, -0.879462f, -0.317375f, 0.445309f, 0.013126f, 0.373359f,
	0.486354f, -0.841119f, 0.236599f, 0.454354f, 0.014493f, 0.380371f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.805552f, -0.390958f, 0.445239f, 0.048902f, -0.020854f, 0.482377f,

	0.805552f, -0.390958f, 0.445239f, 0.048902f, -0.020854f, 0.482377f,
	0.893838f, -0.053226f, 0.445221f, 0.052990f, 0.000000f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	0.893838f, -0.053226f, 0.445221f, 0.052990f, 0.000000f, 0.482377f,
	0.805552f, -0.390958f, 0.445239f, 0.048902f, -0.020854f, 0.482377f,
	0.845311f, -0.339954f, -0.412166f, 0.046657f, -0.019894f, 0.463782f,

	0.845311f, -0.339954f, -0.412166f, 0.046657f, -0.019894f, 0.463782f,
	0.911613f, 0.007758f, -0.410976f, 0.050559f, 0.000000f, 0.463782f,
	0.893838f, -0.053226f, 0.445221f, 0.052990f, 0.000000f, 0.482377f,

	0.911613f, 0.007758f, -0.410976f, 0.050559f, 0.000000f, 0.463782f,
	0.845311f, -0.339954f, -0.412166f, 0.046657f, -0.019894f, 0.463782f,
	0.865515f, -0.366645f, -0.341256f, 0.028260f, -0.012040f, 0.440812f,

	0.865515f, -0.366645f, -0.341256f, 0.028260f, -0.012040f, 0.440812f,
	0.940245f, -0.008552f, -0.340390f, 0.030627f, 0.000000f, 0.440812f,
	0.911613f, 0.007758f, -0.410976f, 0.050559f, 0.000000f, 0.463782f,

	0.940245f, -0.008552f, -0.340390f, 0.030627f, 0.000000f, 0.440812f,
	0.865515f, -0.366645f, -0.341256f, 0.028260f, -0.012040f, 0.440812f,
	0.753279f, -0.282480f, 0.593949f, 0.028702f, -0.012212f, 0.420029f,

	0.753279f, -0.282480f, 0.593949f, 0.028702f, -0.012212f, 0.420029f,
	0.804409f, 0.026273f, 0.593494f, 0.031113f, 0.000000f, 0.420029f,
	0.940245f, -0.008552f, -0.340390f, 0.030627f, 0.000000f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.593802f, -0.670274f, 0.445119f, 0.037672f, -0.037672f, 0.482377f,

	0.593802f, -0.670274f, 0.445119f, 0.037672f, -0.037672f, 0.482377f,
	0.805552f, -0.390958f, 0.445239f, 0.048902f, -0.020854f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	0.805552f, -0.390958f, 0.445239f, 0.048902f, -0.020854f, 0.482377f,
	0.593802f, -0.670274f, 0.445119f, 0.037672f, -0.037672f, 0.482377f,
	0.649754f, -0.638331f, -0.412738f, 0.035941f, -0.035941f, 0.463782f,

	0.649754f, -0.638331f, -0.412738f, 0.035941f, -0.035941f, 0.463782f,
	0.845311f, -0.339954f, -0.412166f, 0.046657f, -0.019894f, 0.463782f,
	0.805552f, -0.390958f, 0.445239f, 0.048902f, -0.020854f, 0.482377f,

	0.845311f, -0.339954f, -0.412166f, 0.046657f, -0.019894f, 0.463782f,
	0.649754f, -0.638331f, -0.412738f, 0.035941f, -0.035941f, 0.463782f,
	0.658530f, -0.670307f, -0.342092f, 0.021762f, -0.021762f, 0.440812f,

	0.658530f, -0.670307f, -0.342092f, 0.021762f, -0.021762f, 0.440812f,
	0.865515f, -0.366645f, -0.341256f, 0.028260f, -0.012040f, 0.440812f,
	0.845311f, -0.339954f, -0.412166f, 0.046657f, -0.019894f, 0.463782f,

	0.865515f, -0.366645f, -0.341256f, 0.028260f, -0.012040f, 0.440812f,
	0.658530f, -0.670307f, -0.342092f, 0.021762f, -0.021762f, 0.440812f,
	0.587537f, -0.549763f, 0.593769f, 0.022090f, -0.022090f, 0.420029f,

	0.587537f, -0.549763f, 0.593769f, 0.022090f, -0.022090f, 0.420029f,
	0.753279f, -0.282480f, 0.593949f, 0.028702f, -0.012212f, 0.420029f,
	0.865515f, -0.366645f, -0.341256f, 0.028260f, -0.012040f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.290481f, -0.846896f, 0.445408f, 0.020854f, -0.048902f, 0.482377f,

	0.290481f, -0.846896f, 0.445408f, 0.020854f, -0.048902f, 0.482377f,
	0.593802f, -0.670274f, 0.445119f, 0.037672f, -0.037672f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	0.593802f, -0.670274f, 0.445119f, 0.037672f, -0.037672f, 0.482377f,
	0.290481f, -0.846896f, 0.445408f, 0.020854f, -0.048902f, 0.482377f,
	0.354855f, -0.839302f, -0.411886f, 0.019894f, -0.046657f, 0.463782f,

	0.354855f, -0.839302f, -0.411886f, 0.019894f, -0.046657f, 0.463782f,
	0.649754f, -0.638331f, -0.412738f, 0.035941f, -0.035941f, 0.463782f,
	0.593802f, -0.670274f, 0.445119f, 0.037672f, -0.037672f, 0.482377f,

	0.649754f, -0.638331f, -0.412738f, 0.035941f, -0.035941f, 0.463782f,
	0.354855f, -0.839302f, -0.411886f, 0.019894f, -0.046657f, 0.463782f,
	0.350892f, -0.871915f, -0.341525f, 0.012040f, -0.028260f, 0.440812f,

	0.350892f, -0.871915f, -0.341525f, 0.012040f, -0.028260f, 0.440812f,
	0.658530f, -0.670307f, -0.342092f, 0.021762f, -0.021762f, 0.440812f,
	0.649754f, -0.638331f, -0.412738f, 0.035941f, -0.035941f, 0.463782f,

	0.658530f, -0.670307f, -0.342092f, 0.021762f, -0.021762f, 0.440812f,
	0.350892f, -0.871915f, -0.341525f, 0.012040f, -0.028260f, 0.440812f,
	0.332142f, -0.733000f, 0.593627f, 0.012212f, -0.028702f, 0.420029f,

	0.332142f, -0.733000f, 0.593627f, 0.012212f, -0.028702f, 0.420029f,
	0.587537f, -0.549763f, 0.593769f, 0.022090f, -0.022090f, 0.420029f,
	0.658530f, -0.670307f, -0.342092f, 0.021762f, -0.021762f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	-0.053226f, -0.893838f, 0.445221f, 0.000000f, -0.052990f, 0.482377f,

	-0.053226f, -0.893838f, 0.445221f, 0.000000f, -0.052990f, 0.482377f,
	0.290481f, -0.846896f, 0.445408f, 0.020854f, -0.048902f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	0.290481f, -0.846896f, 0.445408f, 0.020854f, -0.048902f, 0.482377f,
	-0.053226f, -0.893838f, 0.445221f, 0.000000f, -0.052990f, 0.482377f,
	0.007758f, -0.911613f, -0.410976f, 0.000000f, -0.050559f, 0.463782f,

	0.007758f, -0.911613f, -0.410976f, 0.000000f, -0.050559f, 0.463782f,
	0.354855f, -0.839302f, -0.411886f, 0.019894f, -0.046657f, 0.463782f,
	0.290481f, -0.846896f, 0.445408f, 0.020854f, -0.048902f, 0.482377f,

	0.354855f, -0.839302f, -0.411886f, 0.019894f, -0.046657f, 0.463782f,
	0.007758f, -0.911613f, -0.410976f, 0.000000f, -0.050559f, 0.463782f,
	-0.008552f, -0.940245f, -0.340390f, 0.000000f, -0.030627f, 0.440812f,

	-0.008552f, -0.940245f, -0.340390f, 0.000000f, -0.030627f, 0.440812f,
	0.350892f, -0.871915f, -0.341525f, 0.012040f, -0.028260f, 0.440812f,
	0.354855f, -0.839302f, -0.411886f, 0.019894f, -0.046657f, 0.463782f,

	0.350892f, -0.871915f, -0.341525f, 0.012040f, -0.028260f, 0.440812f,
	-0.008552f, -0.940245f, -0.340390f, 0.000000f, -0.030627f, 0.440812f,
	0.026273f, -0.804409f, 0.593494f, 0.000000f, -0.031113f, 0.420029f,

	0.026273f, -0.804409f, 0.593494f, 0.000000f, -0.031113f, 0.420029f,
	0.332142f, -0.733000f, 0.593627f, 0.012212f, -0.028702f, 0.420029f,
	0.350892f, -0.871915f, -0.341525f, 0.012040f, -0.028260f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	-0.390958f, -0.805552f, 0.445239f, -0.020854f, -0.048902f, 0.482377f,

	-0.390958f, -0.805552f, 0.445239f, -0.020854f, -0.048902f, 0.482377f,
	-0.053226f, -0.893838f, 0.445221f, 0.000000f, -0.052990f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	-0.053226f, -0.893838f, 0.445221f, 0.000000f, -0.052990f, 0.482377f,
	-0.390958f, -0.805552f, 0.445239f, -0.020854f, -0.048902f, 0.482377f,
	-0.339954f, -0.845311f, -0.412166f, -0.019894f, -0.046657f, 0.463782f,

	-0.339954f, -0.845311f, -0.412166f, -0.019894f, -0.046657f, 0.463782f,
	0.007758f, -0.911613f, -0.410976f, 0.000000f, -0.050559f, 0.463782f,
	-0.053226f, -0.893838f, 0.445221f, 0.000000f, -0.052990f, 0.482377f,

	0.007758f, -0.911613f, -0.410976f, 0.000000f, -0.050559f, 0.463782f,
	-0.339954f, -0.845311f, -0.412166f, -0.019894f, -0.046657f, 0.463782f,
	-0.366645f, -0.865515f, -0.341256f, -0.012040f, -0.028260f, 0.440812f,

	-0.366645f, -0.865515f, -0.341256f, -0.012040f, -0.028260f, 0.440812f,
	-0.008552f, -0.940245f, -0.340390f, 0.000000f, -0.030627f, 0.440812f,
	0.007758f, -0.911613f, -0.410976f, 0.000000f, -0.050559f, 0.463782f,

	-0.008552f, -0.940245f, -0.340390f, 0.000000f, -0.030627f, 0.440812f,
	-0.366645f, -0.865515f, -0.341256f, -0.012040f, -0.028260f, 0.440812f,
	-0.282480f, -0.753279f, 0.593949f, -0.012212f, -0.028702f, 0.420029f,

	-0.282480f, -0.753279f, 0.593949f, -0.012212f, -0.028702f, 0.420029f,
	0.026273f, -0.804409f, 0.593494f, 0.000000f, -0.031113f, 0.420029f,
	-0.008552f, -0.940245f, -0.340390f, 0.000000f, -0.030627f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	-0.670274f, -0.593802f, 0.445119f, -0.037672f, -0.037672f, 0.482377f,

	-0.670274f, -0.593802f, 0.445119f, -0.037672f, -0.037672f, 0.482377f,
	-0.390958f, -0.805552f, 0.445239f, -0.020854f, -0.048902f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	-0.390958f, -0.805552f, 0.445239f, -0.020854f, -0.048902f, 0.482377f,
	-0.670274f, -0.593802f, 0.445119f, -0.037672f, -0.037672f, 0.482377f,
	-0.638331f, -0.649754f, -0.412738f, -0.035941f, -0.035941f, 0.463782f,

	-0.638331f, -0.649754f, -0.412738f, -0.035941f, -0.035941f, 0.463782f,
	-0.339954f, -0.845311f, -0.412166f, -0.019894f, -0.046657f, 0.463782f,
	-0.390958f, -0.805552f, 0.445239f, -0.020854f, -0.048902f, 0.482377f,

	-0.339954f, -0.845311f, -0.412166f, -0.019894f, -0.046657f, 0.463782f,
	-0.638331f, -0.649754f, -0.412738f, -0.035941f, -0.035941f, 0.463782f,
	-0.670307f, -0.658530f, -0.342092f, -0.021762f, -0.021762f, 0.440812f,

	-0.670307f, -0.658530f, -0.342092f, -0.021762f, -0.021762f, 0.440812f,
	-0.366645f, -0.865515f, -0.341256f, -0.012040f, -0.028260f, 0.440812f,
	-0.339954f, -0.845311f, -0.412166f, -0.019894f, -0.046657f, 0.463782f,

	-0.366645f, -0.865515f, -0.341256f, -0.012040f, -0.028260f, 0.440812f,
	-0.670307f, -0.658530f, -0.342092f, -0.021762f, -0.021762f, 0.440812f,
	-0.549763f, -0.587537f, 0.593769f, -0.022090f, -0.022090f, 0.420029f,

	-0.549763f, -0.587537f, 0.593769f, -0.022090f, -0.022090f, 0.420029f,
	-0.282480f, -0.753279f, 0.593949f, -0.012212f, -0.028702f, 0.420029f,
	-0.366645f, -0.865515f, -0.341256f, -0.012040f, -0.028260f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	-0.846896f, -0.290481f, 0.445408f, -0.048902f, -0.020854f, 0.482377f,

	-0.846896f, -0.290481f, 0.445408f, -0.048902f, -0.020854f, 0.482377f,
	-0.670274f, -0.593802f, 0.445119f, -0.037672f, -0.037672f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	-0.670274f, -0.593802f, 0.445119f, -0.037672f, -0.037672f, 0.482377f,
	-0.846896f, -0.290481f, 0.445408f, -0.048902f, -0.020854f, 0.482377f,
	-0.839302f, -0.354855f, -0.411886f, -0.046657f, -0.019894f, 0.463782f,

	-0.839302f, -0.354855f, -0.411886f, -0.046657f, -0.019894f, 0.463782f,
	-0.638331f, -0.649754f, -0.412738f, -0.035941f, -0.035941f, 0.463782f,
	-0.670274f, -0.593802f, 0.445119f, -0.037672f, -0.037672f, 0.482377f,

	-0.638331f, -0.649754f, -0.412738f, -0.035941f, -0.035941f, 0.463782f,
	-0.839302f, -0.354855f, -0.411886f, -0.046657f, -0.019894f, 0.463782f,
	-0.871915f, -0.350892f, -0.341525f, -0.028260f, -0.012040f, 0.440812f,

	-0.871915f, -0.350892f, -0.341525f, -0.028260f, -0.012040f, 0.440812f,
	-0.670307f, -0.658530f, -0.342092f, -0.021762f, -0.021762f, 0.440812f,
	-0.638331f, -0.649754f, -0.412738f, -0.035941f, -0.035941f, 0.463782f,

	-0.670307f, -0.658530f, -0.342092f, -0.021762f, -0.021762f, 0.440812f,
	-0.871915f, -0.350892f, -0.341525f, -0.028260f, -0.012040f, 0.440812f,
	-0.733000f, -0.332142f, 0.593627f, -0.028702f, -0.012212f, 0.420029f,

	-0.733000f, -0.332142f, 0.593627f, -0.028702f, -0.012212f, 0.420029f,
	-0.549763f, -0.587537f, 0.593769f, -0.022090f, -0.022090f, 0.420029f,
	-0.670307f, -0.658530f, -0.342092f, -0.021762f, -0.021762f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	-0.893838f, 0.053226f, 0.445221f, -0.052990f, 0.000000f, 0.482377f,

	-0.893838f, 0.053226f, 0.445221f, -0.052990f, 0.000000f, 0.482377f,
	-0.846896f, -0.290481f, 0.445408f, -0.048902f, -0.020854f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	-0.846896f, -0.290481f, 0.445408f, -0.048902f, -0.020854f, 0.482377f,
	-0.893838f, 0.053226f, 0.445221f, -0.052990f, 0.000000f, 0.482377f,
	-0.911613f, -0.007758f, -0.410976f, -0.050559f, 0.000000f, 0.463782f,

	-0.911613f, -0.007758f, -0.410976f, -0.050559f, 0.000000f, 0.463782f,
	-0.839302f, -0.354855f, -0.411886f, -0.046657f, -0.019894f, 0.463782f,
	-0.846896f, -0.290481f, 0.445408f, -0.048902f, -0.020854f, 0.482377f,

	-0.839302f, -0.354855f, -0.411886f, -0.046657f, -0.019894f, 0.463782f,
	-0.911613f, -0.007758f, -0.410976f, -0.050559f, 0.000000f, 0.463782f,
	-0.940245f, 0.008552f, -0.340390f, -0.030627f, 0.000000f, 0.440812f,

	-0.940245f, 0.008552f, -0.340390f, -0.030627f, 0.000000f, 0.440812f,
	-0.871915f, -0.350892f, -0.341525f, -0.028260f, -0.012040f, 0.440812f,
	-0.839302f, -0.354855f, -0.411886f, -0.046657f, -0.019894f, 0.463782f,

	-0.871915f, -0.350892f, -0.341525f, -0.028260f, -0.012040f, 0.440812f,
	-0.940245f, 0.008552f, -0.340390f, -0.030627f, 0.000000f, 0.440812f,
	-0.804409f, -0.026273f, 0.593494f, -0.031113f, 0.000000f, 0.420029f,

	-0.804409f, -0.026273f, 0.593494f, -0.031113f, 0.000000f, 0.420029f,
	-0.733000f, -0.332142f, 0.593627f, -0.028702f, -0.012212f, 0.420029f,
	-0.871915f, -0.350892f, -0.341525f, -0.028260f, -0.012040f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	-0.805552f, 0.390958f, 0.445239f, -0.048902f, 0.020854f, 0.482377f,

	-0.805552f, 0.390958f, 0.445239f, -0.048902f, 0.020854f, 0.482377f,
	-0.893838f, 0.053226f, 0.445221f, -0.052990f, 0.000000f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	-0.893838f, 0.053226f, 0.445221f, -0.052990f, 0.000000f, 0.482377f,
	-0.805552f, 0.390958f, 0.445239f, -0.048902f, 0.020854f, 0.482377f,
	-0.845311f, 0.339954f, -0.412166f, -0.046657f, 0.019894f, 0.463782f,

	-0.845311f, 0.339954f, -0.412166f, -0.046657f, 0.019894f, 0.463782f,
	-0.911613f, -0.007758f, -0.410976f, -0.050559f, 0.000000f, 0.463782f,
	-0.893838f, 0.053226f, 0.445221f, -0.052990f, 0.000000f, 0.482377f,

	-0.911613f, -0.007758f, -0.410976f, -0.050559f, 0.000000f, 0.463782f,
	-0.845311f, 0.339954f, -0.412166f, -0.046657f, 0.019894f, 0.463782f,
	-0.865515f, 0.366645f, -0.341256f, -0.028260f, 0.012040f, 0.440812f,

	-0.865515f, 0.366645f, -0.341256f, -0.028260f, 0.012040f, 0.440812f,
	-0.940245f, 0.008552f, -0.340390f, -0.030627f, 0.000000f, 0.440812f,
	-0.911613f, -0.007758f, -0.410976f, -0.050559f, 0.000000f, 0.463782f,

	-0.940245f, 0.008552f, -0.340390f, -0.030627f, 0.000000f, 0.440812f,
	-0.865515f, 0.366645f, -0.341256f, -0.028260f, 0.012040f, 0.440812f,
	-0.753279f, 0.282480f, 0.593949f, -0.028702f, 0.012212f, 0.420029f,

	-0.753279f, 0.282480f, 0.593949f, -0.028702f, 0.012212f, 0.420029f,
	-0.804409f, -0.026273f, 0.593494f, -0.031113f, 0.000000f, 0.420029f,
	-0.940245f, 0.008552f, -0.340390f, -0.030627f, 0.000000f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	-0.593802f, 0.670274f, 0.445119f, -0.037672f, 0.037672f, 0.482377f,

	-0.593802f, 0.670274f, 0.445119f, -0.037672f, 0.037672f, 0.482377f,
	-0.805552f, 0.390958f, 0.445239f, -0.048902f, 0.020854f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	-0.805552f, 0.390958f, 0.445239f, -0.048902f, 0.020854f, 0.482377f,
	-0.593802f, 0.670274f, 0.445119f, -0.037672f, 0.037672f, 0.482377f,
	-0.649754f, 0.638331f, -0.412738f, -0.035941f, 0.035941f, 0.463782f,

	-0.649754f, 0.638331f, -0.412738f, -0.035941f, 0.035941f, 0.463782f,
	-0.845311f, 0.339954f, -0.412166f, -0.046657f, 0.019894f, 0.463782f,
	-0.805552f, 0.390958f, 0.445239f, -0.048902f, 0.020854f, 0.482377f,

	-0.845311f, 0.339954f, -0.412166f, -0.046657f, 0.019894f, 0.463782f,
	-0.649754f, 0.638331f, -0.412738f, -0.035941f, 0.035941f, 0.463782f,
	-0.658530f, 0.670307f, -0.342092f, -0.021762f, 0.021762f, 0.440812f,

	-0.658530f, 0.670307f, -0.342092f, -0.021762f, 0.021762f, 0.440812f,
	-0.865515f, 0.366645f, -0.341256f, -0.028260f, 0.012040f, 0.440812f,
	-0.845311f, 0.339954f, -0.412166f, -0.046657f, 0.019894f, 0.463782f,

	-0.865515f, 0.366645f, -0.341256f, -0.028260f, 0.012040f, 0.440812f,
	-0.658530f, 0.670307f, -0.342092f, -0.021762f, 0.021762f, 0.440812f,
	-0.587537f, 0.549763f, 0.593769f, -0.022090f, 0.022090f, 0.420029f,

	-0.587537f, 0.549763f, 0.593769f, -0.022090f, 0.022090f, 0.420029f,
	-0.753279f, 0.282480f, 0.593949f, -0.028702f, 0.012212f, 0.420029f,
	-0.865515f, 0.366645f, -0.341256f, -0.028260f, 0.012040f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	-0.290481f, 0.846896f, 0.445408f, -0.020854f, 0.048902f, 0.482377f,

	-0.290481f, 0.846896f, 0.445408f, -0.020854f, 0.048902f, 0.482377f,
	-0.593802f, 0.670274f, 0.445119f, -0.037672f, 0.037672f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	-0.593802f, 0.670274f, 0.445119f, -0.037672f, 0.037672f, 0.482377f,
	-0.290481f, 0.846896f, 0.445408f, -0.020854f, 0.048902f, 0.482377f,
	-0.354855f, 0.839302f, -0.411886f, -0.019894f, 0.046657f, 0.463782f,

	-0.354855f, 0.839302f, -0.411886f, -0.019894f, 0.046657f, 0.463782f,
	-0.649754f, 0.638331f, -0.412738f, -0.035941f, 0.035941f, 0.463782f,
	-0.593802f, 0.670274f, 0.445119f, -0.037672f, 0.037672f, 0.482377f,

	-0.649754f, 0.638331f, -0.412738f, -0.035941f, 0.035941f, 0.463782f,
	-0.354855f, 0.839302f, -0.411886f, -0.019894f, 0.046657f, 0.463782f,
	-0.350892f, 0.871915f, -0.341525f, -0.012040f, 0.028260f, 0.440812f,

	-0.350892f, 0.871915f, -0.341525f, -0.012040f, 0.028260f, 0.440812f,
	-0.658530f, 0.670307f, -0.342092f, -0.021762f, 0.021762f, 0.440812f,
	-0.649754f, 0.638331f, -0.412738f, -0.035941f, 0.035941f, 0.463782f,

	-0.658530f, 0.670307f, -0.342092f, -0.021762f, 0.021762f, 0.440812f,
	-0.350892f, 0.871915f, -0.341525f, -0.012040f, 0.028260f, 0.440812f,
	-0.332142f, 0.733000f, 0.593627f, -0.012212f, 0.028702f, 0.420029f,

	-0.332142f, 0.733000f, 0.593627f, -0.012212f, 0.028702f, 0.420029f,
	-0.587537f, 0.549763f, 0.593769f, -0.022090f, 0.022090f, 0.420029f,
	-0.658530f, 0.670307f, -0.342092f, -0.021762f, 0.021762f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.053226f, 0.893838f, 0.445221f, 0.000000f, 0.052990f, 0.482377f,

	0.053226f, 0.893838f, 0.445221f, 0.000000f, 0.052990f, 0.482377f,
	-0.290481f, 0.846896f, 0.445408f, -0.020854f, 0.048902f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	-0.290481f, 0.846896f, 0.445408f, -0.020854f, 0.048902f, 0.482377f,
	0.053226f, 0.893838f, 0.445221f, 0.000000f, 0.052990f, 0.482377f,
	-0.007758f, 0.911613f, -0.410976f, 0.000000f, 0.050559f, 0.463782f,

	-0.007758f, 0.911613f, -0.410976f, 0.000000f, 0.050559f, 0.463782f,
	-0.354855f, 0.839302f, -0.411886f, -0.019894f, 0.046657f, 0.463782f,
	-0.290481f, 0.846896f, 0.445408f, -0.020854f, 0.048902f, 0.482377f,

	-0.354855f, 0.839302f, -0.411886f, -0.019894f, 0.046657f, 0.463782f,
	-0.007758f, 0.911613f, -0.410976f, 0.000000f, 0.050559f, 0.463782f,
	0.008552f, 0.940245f, -0.340390f, 0.000000f, 0.030627f, 0.440812f,

	0.008552f, 0.940245f, -0.340390f, 0.000000f, 0.030627f, 0.440812f,
	-0.350892f, 0.871915f, -0.341525f, -0.012040f, 0.028260f, 0.440812f,
	-0.354855f, 0.839302f, -0.411886f, -0.019894f, 0.046657f, 0.463782f,

	-0.350892f, 0.871915f, -0.341525f, -0.012040f, 0.028260f, 0.440812f,
	0.008552f, 0.940245f, -0.340390f, 0.000000f, 0.030627f, 0.440812f,
	-0.026273f, 0.804409f, 0.593494f, 0.000000f, 0.031113f, 0.420029f,

	-0.026273f, 0.804409f, 0.593494f, 0.000000f, 0.031113f, 0.420029f,
	-0.332142f, 0.733000f, 0.593627f, -0.012212f, 0.028702f, 0.420029f,
	-0.350892f, 0.871915f, -0.341525f, -0.012040f, 0.028260f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.390958f, 0.805552f, 0.445239f, 0.020854f, 0.048902f, 0.482377f,

	0.390958f, 0.805552f, 0.445239f, 0.020854f, 0.048902f, 0.482377f,
	0.053226f, 0.893838f, 0.445221f, 0.000000f, 0.052990f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	0.053226f, 0.893838f, 0.445221f, 0.000000f, 0.052990f, 0.482377f,
	0.390958f, 0.805552f, 0.445239f, 0.020854f, 0.048902f, 0.482377f,
	0.339954f, 0.845311f, -0.412166f, 0.019894f, 0.046657f, 0.463782f,

	0.339954f, 0.845311f, -0.412166f, 0.019894f, 0.046657f, 0.463782f,
	-0.007758f, 0.911613f, -0.410976f, 0.000000f, 0.050559f, 0.463782f,
	0.053226f, 0.893838f, 0.445221f, 0.000000f, 0.052990f, 0.482377f,

	-0.007758f, 0.911613f, -0.410976f, 0.000000f, 0.050559f, 0.463782f,
	0.339954f, 0.845311f, -0.412166f, 0.019894f, 0.046657f, 0.463782f,
	0.366645f, 0.865515f, -0.341256f, 0.012040f, 0.028260f, 0.440812f,

	0.366645f, 0.865515f, -0.341256f, 0.012040f, 0.028260f, 0.440812f,
	0.008552f, 0.940245f, -0.340390f, 0.000000f, 0.030627f, 0.440812f,
	-0.007758f, 0.911613f, -0.410976f, 0.000000f, 0.050559f, 0.463782f,

	0.008552f, 0.940245f, -0.340390f, 0.000000f, 0.030627f, 0.440812f,
	0.366645f, 0.865515f, -0.341256f, 0.012040f, 0.028260f, 0.440812f,
	0.282480f, 0.753279f, 0.593949f, 0.012212f, 0.028702f, 0.420029f,

	0.282480f, 0.753279f, 0.593949f, 0.012212f, 0.028702f, 0.420029f,
	-0.026273f, 0.804409f, 0.593494f, 0.000000f, 0.031113f, 0.420029f,
	0.008552f, 0.940245f, -0.340390f, 0.000000f, 0.030627f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.670274f, 0.593802f, 0.445119f, 0.037672f, 0.037672f, 0.482377f,

	0.670274f, 0.593802f, 0.445119f, 0.037672f, 0.037672f, 0.482377f,
	0.390958f, 0.805552f, 0.445239f, 0.020854f, 0.048902f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	0.390958f, 0.805552f, 0.445239f, 0.020854f, 0.048902f, 0.482377f,
	0.670274f, 0.593802f, 0.445119f, 0.037672f, 0.037672f, 0.482377f,
	0.638331f, 0.649754f, -0.412738f, 0.035941f, 0.035941f, 0.463782f,

	0.638331f, 0.649754f, -0.412738f, 0.035941f, 0.035941f, 0.463782f,
	0.339954f, 0.845311f, -0.412166f, 0.019894f, 0.046657f, 0.463782f,
	0.390958f, 0.805552f, 0.445239f, 0.020854f, 0.048902f, 0.482377f,

	0.339954f, 0.845311f, -0.412166f, 0.019894f, 0.046657f, 0.463782f,
	0.638331f, 0.649754f, -0.412738f, 0.035941f, 0.035941f, 0.463782f,
	0.670307f, 0.658530f, -0.342092f, 0.021762f, 0.021762f, 0.440812f,

	0.670307f, 0.658530f, -0.342092f, 0.021762f, 0.021762f, 0.440812f,
	0.366645f, 0.865515f, -0.341256f, 0.012040f, 0.028260f, 0.440812f,
	0.339954f, 0.845311f, -0.412166f, 0.019894f, 0.046657f, 0.463782f,

	0.366645f, 0.865515f, -0.341256f, 0.012040f, 0.028260f, 0.440812f,
	0.670307f, 0.658530f, -0.342092f, 0.021762f, 0.021762f, 0.440812f,
	0.549763f, 0.587537f, 0.593769f, 0.022090f, 0.022090f, 0.420029f,

	0.549763f, 0.587537f, 0.593769f, 0.022090f, 0.022090f, 0.420029f,
	0.282480f, 0.753279f, 0.593949f, 0.012212f, 0.028702f, 0.420029f,
	0.366645f, 0.865515f, -0.341256f, 0.012040f, 0.028260f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.846896f, 0.290481f, 0.445408f, 0.048902f, 0.020854f, 0.482377f,

	0.846896f, 0.290481f, 0.445408f, 0.048902f, 0.020854f, 0.482377f,
	0.670274f, 0.593802f, 0.445119f, 0.037672f, 0.037672f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	0.670274f, 0.593802f, 0.445119f, 0.037672f, 0.037672f, 0.482377f,
	0.846896f, 0.290481f, 0.445408f, 0.048902f, 0.020854f, 0.482377f,
	0.839302f, 0.354855f, -0.411886f, 0.046657f, 0.019894f, 0.463782f,

	0.839302f, 0.354855f, -0.411886f, 0.046657f, 0.019894f, 0.463782f,
	0.638331f, 0.649754f, -0.412738f, 0.035941f, 0.035941f, 0.463782f,
	0.670274f, 0.593802f, 0.445119f, 0.037672f, 0.037672f, 0.482377f,

	0.638331f, 0.649754f, -0.412738f, 0.035941f, 0.035941f, 0.463782f,
	0.839302f, 0.354855f, -0.411886f, 0.046657f, 0.019894f, 0.463782f,
	0.871915f, 0.350892f, -0.341525f, 0.028260f, 0.012040f, 0.440812f,

	0.871915f, 0.350892f, -0.341525f, 0.028260f, 0.012040f, 0.440812f,
	0.670307f, 0.658530f, -0.342092f, 0.021762f, 0.021762f, 0.440812f,
	0.638331f, 0.649754f, -0.412738f, 0.035941f, 0.035941f, 0.463782f,

	0.670307f, 0.658530f, -0.342092f, 0.021762f, 0.021762f, 0.440812f,
	0.871915f, 0.350892f, -0.341525f, 0.028260f, 0.012040f, 0.440812f,
	0.733000f, 0.332142f, 0.593627f, 0.028702f, 0.012212f, 0.420029f,

	0.733000f, 0.332142f, 0.593627f, 0.028702f, 0.012212f, 0.420029f,
	0.549763f, 0.587537f, 0.593769f, 0.022090f, 0.022090f, 0.420029f,
	0.670307f, 0.658530f, -0.342092f, 0.021762f, 0.021762f, 0.440812f,

	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,
	0.893838f, -0.053226f, 0.445221f, 0.052990f, 0.000000f, 0.482377f,

	0.893838f, -0.053226f, 0.445221f, 0.052990f, 0.000000f, 0.482377f,
	0.846896f, 0.290481f, 0.445408f, 0.048902f, 0.020854f, 0.482377f,
	0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.490034f,

	0.846896f, 0.290481f, 0.445408f, 0.048902f, 0.020854f, 0.482377f,
	0.893838f, -0.053226f, 0.445221f, 0.052990f, 0.000000f, 0.482377f,
	0.911613f, 0.007758f, -0.410976f, 0.050559f, 0.000000f, 0.463782f,

	0.911613f, 0.007758f, -0.410976f, 0.050559f, 0.000000f, 0.463782f,
	0.839302f, 0.354855f, -0.411886f, 0.046657f, 0.019894f, 0.463782f,
	0.846896f, 0.290481f, 0.445408f, 0.048902f, 0.020854f, 0.482377f,

	0.839302f, 0.354855f, -0.411886f, 0.046657f, 0.019894f, 0.463782f,
	0.911613f, 0.007758f, -0.410976f, 0.050559f, 0.000000f, 0.463782f,
	0.940245f, -0.008552f, -0.340390f, 0.030627f, 0.000000f, 0.440812f,

	0.940245f, -0.008552f, -0.340390f, 0.030627f, 0.000000f, 0.440812f,
	0.871915f, 0.350892f, -0.341525f, 0.028260f, 0.012040f, 0.440812f,
	0.839302f, 0.354855f, -0.411886f, 0.046657f, 0.019894f, 0.463782f,

	0.871915f, 0.350892f, -0.341525f, 0.028260f, 0.012040f, 0.440812f,
	0.940245f, -0.008552f, -0.340390f, 0.030627f, 0.000000f, 0.440812f,
	0.804409f, 0.026273f, 0.593494f, 0.031113f, 0.000000f, 0.420029f,

	0.804409f, 0.026273f, 0.593494f, 0.031113f, 0.000000f, 0.420029f,
	0.733000f, 0.332142f, 0.593627f, 0.028702f, 0.012212f, 0.420029f,
	0.871915f, 0.350892f, -0.341525f, 0.028260f, 0.012040f, 0.440812f,

	0.804409f, 0.026273f, 0.593494f, 0.031113f, 0.000000f, 0.420029f,
	0.753279f, -0.282480f, 0.593949f, 0.028702f, -0.012212f, 0.420029f,
	0.229426f, -0.088891f, 0.969258f, 0.065476f, -0.027859f, 0.406174f,

	0.229426f, -0.088891f, 0.969258f, 0.065476f, -0.027859f, 0.406174f,
	0.246499f, 0.005445f, 0.969128f, 0.070977f, 0.000000f, 0.406174f,
	0.804409f, 0.026273f, 0.593494f, 0.031113f, 0.000000f, 0.420029f,

	0.246499f, 0.005445f, 0.969128f, 0.070977f, 0.000000f, 0.406174f,
	0.229426f, -0.088891f, 0.969258f, 0.065476f, -0.027859f, 0.406174f,
	0.158332f, -0.066096f, 0.985171f, 0.118396f, -0.050374f, 0.396694f,

	0.158332f, -0.066096f, 0.985171f, 0.118396f, -0.050374f, 0.396694f,
	0.171991f, -0.000588f, 0.985098f, 0.128342f, 0.000000f, 0.396694f,
	0.246499f, 0.005445f, 0.969128f, 0.070977f, 0.000000f, 0.406174f,

	0.171991f, -0.000588f, 0.985098f, 0.128342f, 0.000000f, 0.396694f,
	0.158332f, -0.066096f, 0.985171f, 0.118396f, -0.050374f, 0.396694f,
	0.327101f, -0.147859f, 0.933350f, 0.165933f, -0.070600f, 0.387214f,

	0.327101f, -0.147859f, 0.933350f, 0.165933f, -0.070600f, 0.387214f,
	0.359594f, -0.011522f, 0.933038f, 0.179874f, 0.000000f, 0.387214f,
	0.171991f, -0.000588f, 0.985098f, 0.128342f, 0.000000f, 0.396694f,

	0.359594f, -0.011522f, 0.933038f, 0.179874f, 0.000000f, 0.387214f,
	0.327101f, -0.147859f, 0.933350f, 0.165933f, -0.070600f, 0.387214f,
	0.499161f, -0.168496f, 0.849969f, 0.186563f, -0.079378f, 0.373359f,

	0.499161f, -0.168496f, 0.849969f, 0.186563f, -0.079378f, 0.373359f,
	0.526357f, 0.034643f, 0.849558f, 0.202236f, 0.000000f, 0.373359f,
	0.359594f, -0.011522f, 0.933038f, 0.179874f, 0.000000f, 0.387214f,

	0.753279f, -0.282480f, 0.593949f, 0.028702f, -0.012212f, 0.420029f,
	0.587537f, -0.549763f, 0.593769f, 0.022090f, -0.022090f, 0.420029f,
	0.177494f, -0.169793f, 0.969364f, 0.050394f, -0.050394f, 0.406174f,

	0.177494f, -0.169793f, 0.969364f, 0.050394f, -0.050394f, 0.406174f,
	0.229426f, -0.088891f, 0.969258f, 0.065476f, -0.027859f, 0.406174f,
	0.753279f, -0.282480f, 0.593949f, 0.028702f, -0.012212f, 0.420029f,

	0.229426f, -0.088891f, 0.969258f, 0.065476f, -0.027859f, 0.406174f,
	0.177494f, -0.169793f, 0.969364f, 0.050394f, -0.050394f, 0.406174f,
	0.120720f, -0.121551f, 0.985217f, 0.091123f, -0.091123f, 0.396694f,

	0.120720f, -0.121551f, 0.985217f, 0.091123f, -0.091123f, 0.396694f,
	0.158332f, -0.066096f, 0.985171f, 0.118396f, -0.050374f, 0.396694f,
	0.229426f, -0.088891f, 0.969258f, 0.065476f, -0.027859f, 0.406174f,

	0.158332f, -0.066096f, 0.985171f, 0.118396f, -0.050374f, 0.396694f,
	0.120720f, -0.121551f, 0.985217f, 0.091123f, -0.091123f, 0.396694f,
	0.245276f, -0.261583f, 0.933496f, 0.127710f, -0.127710f, 0.387214f,

	0.245276f, -0.261583f, 0.933496f, 0.127710f, -0.127710f, 0.387214f,
	0.327101f, -0.147859f, 0.933350f, 0.165933f, -0.070600f, 0.387214f,
	0.158332f, -0.066096f, 0.985171f, 0.118396f, -0.050374f, 0.396694f,

	0.327101f, -0.147859f, 0.933350f, 0.165933f, -0.070600f, 0.387214f,
	0.245276f, -0.261583f, 0.933496f, 0.127710f, -0.127710f, 0.387214f,
	0.395598f, -0.346586f, 0.850518f, 0.143588f, -0.143588f, 0.373359f,

	0.395598f, -0.346586f, 0.850518f, 0.143588f, -0.143588f, 0.373359f,
	0.499161f, -0.168496f, 0.849969f, 0.186563f, -0.079378f, 0.373359f,
	0.327101f, -0.147859f, 0.933350f, 0.165933f, -0.070600f, 0.387214f,

	0.587537f, -0.549763f, 0.593769f, 0.022090f, -0.022090f, 0.420029f,
	0.332142f, -0.733000f, 0.593627f, 0.012212f, -0.028702f, 0.420029f,
	0.099029f, -0.225129f, 0.969283f, 0.027859f, -0.065476f, 0.406174f,

	0.099029f, -0.225129f, 0.969283f, 0.027859f, -0.065476f, 0.406174f,
	0.177494f, -0.169793f, 0.969364f, 0.050394f, -0.050394f, 0.406174f,
	0.587537f, -0.549763f, 0.593769f, 0.022090f, -0.022090f, 0.420029f,

	0.177494f, -0.169793f, 0.969364f, 0.050394f, -0.050394f, 0.406174f,
	0.099029f, -0.225129f, 0.969283f, 0.027859f, -0.065476f, 0.406174f,
	0.065002f, -0.158797f, 0.985169f, 0.050374f, -0.118396f, 0.396694f,

	0.065002f, -0.158797f, 0.985169f, 0.050374f, -0.118396f, 0.396694f,
	0.120720f, -0.121551f, 0.985217f, 0.091123f, -0.091123f, 0.396694f,
	0.177494f, -0.169793f, 0.969364f, 0.050394f, -0.050394f, 0.406174f,

	0.120720f, -0.121551f, 0.985217f, 0.091123f, -0.091123f, 0.396694f,
	0.065002f, -0.158797f, 0.985169f, 0.050374f, -0.118396f, 0.396694f,
	0.126386f, -0.336164f, 0.933285f, 0.070600f, -0.165933f, 0.387214f,

	0.126386f, -0.336164f, 0.933285f, 0.070600f, -0.165933f, 0.387214f,
	0.245276f, -0.261583f, 0.933496f, 0.127710f, -0.127710f, 0.387214f,
	0.120720f, -0.121551f, 0.985217f, 0.091123f, -0.091123f, 0.396694f,

	0.245276f, -0.261583f, 0.933496f, 0.127710f, -0.127710f, 0.387214f,
	0.126386f, -0.336164f, 0.933285f, 0.070600f, -0.165933f, 0.387214f,
	0.233051f, -0.471909f, 0.850288f, 0.079378f, -0.186563f, 0.373359f,

	0.233051f, -0.471909f, 0.850288f, 0.079378f, -0.186563f, 0.373359f,
	0.395598f, -0.346586f, 0.850518f, 0.143588f, -0.143588f, 0.373359f,
	0.245276f, -0.261583f, 0.933496f, 0.127710f, -0.127710f, 0.387214f,

	0.332142f, -0.733000f, 0.593627f, 0.012212f, -0.028702f, 0.420029f,
	0.026273f, -0.804409f, 0.593494f, 0.000000f, -0.031113f, 0.420029f,
	0.005445f, -0.246499f, 0.969128f, 0.000000f, -0.070977f, 0.406174f,

	0.005445f, -0.246499f, 0.969128f, 0.000000f, -0.070977f, 0.406174f,
	0.099029f, -0.225129f, 0.969283f, 0.027859f, -0.065476f, 0.406174f,
	0.332142f, -0.733000f, 0.593627f, 0.012212f, -0.028702f, 0.420029f,

	0.099029f, -0.225129f, 0.969283f, 0.027859f, -0.065476f, 0.406174f,
	0.005445f, -0.246499f, 0.969128f, 0.000000f, -0.070977f, 0.406174f,
	-0.000588f, -0.171991f, 0.985098f, 0.000000f, -0.128342f, 0.396694f,

	-0.000588f, -0.171991f, 0.985098f, 0.000000f, -0.128342f, 0.396694f,
	0.065002f, -0.158797f, 0.985169f, 0.050374f, -0.118396f, 0.396694f,
	0.099029f, -0.225129f, 0.969283f, 0.027859f, -0.065476f, 0.406174f,

	0.065002f, -0.158797f, 0.985169f, 0.050374f, -0.118396f, 0.396694f,
	-0.000588f, -0.171991f, 0.985098f, 0.000000f, -0.128342f, 0.396694f,
	-0.011522f, -0.359594f, 0.933038f, 0.000000f, -0.179874f, 0.387214f,

	-0.011522f, -0.359594f, 0.933038f, 0.000000f, -0.179874f, 0.387214f,
	0.126386f, -0.336164f, 0.933285f, 0.070600f, -0.165933f, 0.387214f,
	0.065002f, -0.158797f, 0.985169f, 0.050374f, -0.118396f, 0.396694f,

	0.126386f, -0.336164f, 0.933285f, 0.070600f, -0.165933f, 0.387214f,
	-0.011522f, -0.359594f, 0.933038f, 0.000000f, -0.179874f, 0.387214f,
	0.034643f, -0.526357f, 0.849558f, 0.000000f, -0.202236f, 0.373359f,

	0.034643f, -0.526357f, 0.849558f, 0.000000f, -0.202236f, 0.373359f,
	0.233051f, -0.471909f, 0.850288f, 0.079378f, -0.186563f, 0.373359f,
	0.126386f, -0.336164f, 0.933285f, 0.070600f, -0.165933f, 0.387214f,

	0.026273f, -0.804409f, 0.593494f, 0.000000f, -0.031113f, 0.420029f,
	-0.282480f, -0.753279f, 0.593949f, -0.012212f, -0.028702f, 0.420029f,
	-0.088891f, -0.229426f, 0.969258f, -0.027859f, -0.065476f, 0.406174f,

	-0.088891f, -0.229426f, 0.969258f, -0.027859f, -0.065476f, 0.406174f,
	0.005445f, -0.246499f, 0.969128f, 0.000000f, -0.070977f, 0.406174f,
	0.026273f, -0.804409f, 0.593494f, 0.000000f, -0.031113f, 0.420029f,

	0.005445f, -0.246499f, 0.969128f, 0.000000f, -0.070977f, 0.406174f,
	-0.088891f, -0.229426f, 0.969258f, -0.027859f, -0.065476f, 0.406174f,
	-0.066096f, -0.158332f, 0.985171f, -0.050374f, -0.118396f, 0.396694f,

	-0.066096f, -0.158332f, 0.985171f, -0.050374f, -0.118396f, 0.396694f,
	-0.000588f, -0.171991f, 0.985098f, 0.000000f, -0.128342f, 0.396694f,
	0.005445f, -0.246499f, 0.969128f, 0.000000f, -0.070977f, 0.406174f,

	-0.000588f, -0.171991f, 0.985098f, 0.000000f, -0.128342f, 0.396694f,
	-0.066096f, -0.158332f, 0.985171f, -0.050374f, -0.118396f, 0.396694f,
	-0.147859f, -0.327101f, 0.933350f, -0.070600f, -0.165933f, 0.387214f,

	-0.147859f, -0.327101f, 0.933350f, -0.070600f, -0.165933f, 0.387214f,
	-0.011522f, -0.359594f, 0.933038f, 0.000000f, -0.179874f, 0.387214f,
	-0.000588f, -0.171991f, 0.985098f, 0.000000f, -0.128342f, 0.396694f,

	-0.011522f, -0.359594f, 0.933038f, 0.000000f, -0.179874f, 0.387214f,
	-0.147859f, -0.327101f, 0.933350f, -0.070600f, -0.165933f, 0.387214f,
	-0.168496f, -0.499161f, 0.849969f, -0.079378f, -0.186563f, 0.373359f,

	-0.168496f, -0.499161f, 0.849969f, -0.079378f, -0.186563f, 0.373359f,
	0.034643f, -0.526357f, 0.849558f, 0.000000f, -0.202236f, 0.373359f,
	-0.011522f, -0.359594f, 0.933038f, 0.000000f, -0.179874f, 0.387214f,

	-0.282480f, -0.753279f, 0.593949f, -0.012212f, -0.028702f, 0.420029f,
	-0.549763f, -0.587537f, 0.593769f, -0.022090f, -0.022090f, 0.420029f,
	-0.169793f, -0.177494f, 0.969364f, -0.050394f, -0.050394f, 0.406174f,

	-0.169793f, -0.177494f, 0.969364f, -0.050394f, -0.050394f, 0.406174f,
	-0.088891f, -0.229426f, 0.969258f, -0.027859f, -0.065476f, 0.406174f,
	-0.282480f, -0.753279f, 0.593949f, -0.012212f, -0.028702f, 0.420029f,

	-0.088891f, -0.229426f, 0.969258f, -0.027859f, -0.065476f, 0.406174f,
	-0.169793f, -0.177494f, 0.969364f, -0.050394f, -0.050394f, 0.406174f,
	-0.121551f, -0.120720f, 0.985217f, -0.091123f, -0.091123f, 0.396694f,

	-0.121551f, -0.120720f, 0.985217f, -0.091123f, -0.091123f, 0.396694f,
	-0.066096f, -0.158332f, 0.985171f, -0.050374f, -0.118396f, 0.396694f,
	-0.088891f, -0.229426f, 0.969258f, -0.027859f, -0.065476f, 0.406174f,

	-0.066096f, -0.158332f, 0.985171f, -0.050374f, -0.118396f, 0.396694f,
	-0.121551f, -0.120720f, 0.985217f, -0.091123f, -0.091123f, 0.396694f,
	-0.261583f, -0.245276f, 0.933496f, -0.127710f, -0.127710f, 0.387214f,

	-0.261583f, -0.245276f, 0.933496f, -0.127710f, -0.127710f, 0.387214f,
	-0.147859f, -0.327101f, 0.933350f, -0.070600f, -0.165933f, 0.387214f,
	-0.066096f, -0.158332f, 0.985171f, -0.050374f, -0.118396f, 0.396694f,

	-0.147859f, -0.327101f, 0.933350f, -0.070600f, -0.165933f, 0.387214f,
	-0.261583f, -0.245276f, 0.933496f, -0.127710f, -0.127710f, 0.387214f,
	-0.346586f, -0.395598f, 0.850518f, -0.143588f, -0.143588f, 0.373359f,

	-0.346586f, -0.395598f, 0.850518f, -0.143588f, -0.143588f, 0.373359f,
	-0.168496f, -0.499161f, 0.849969f, -0.079378f, -0.186563f, 0.373359f,
	-0.147859f, -0.327101f, 0.933350f, -0.070600f, -0.165933f, 0.387214f,

	-0.549763f, -0.587537f, 0.593769f, -0.022090f, -0.022090f, 0.420029f,
	-0.733000f, -0.332142f, 0.593627f, -0.028702f, -0.012212f, 0.420029f,
	-0.225129f, -0.099029f, 0.969283f, -0.065476f, -0.027859f, 0.406174f,

	-0.225129f, -0.099029f, 0.969283f, -0.065476f, -0.027859f, 0.406174f,
	-0.169793f, -0.177494f, 0.969364f, -0.050394f, -0.050394f, 0.406174f,
	-0.549763f, -0.587537f, 0.593769f, -0.022090f, -0.022090f, 0.420029f,

	-0.169793f, -0.177494f, 0.969364f, -0.050394f, -0.050394f, 0.406174f,
	-0.225129f, -0.099029f, 0.969283f, -0.065476f, -0.027859f, 0.406174f,
	-0.158797f, -0.065002f, 0.985169f, -0.118396f, -0.050374f, 0.396694f,

	-0.158797f, -0.065002f, 0.985169f, -0.118396f, -0.050374f, 0.396694f,
	-0.121551f, -0.120720f, 0.985217f, -0.091123f, -0.091123f, 0.396694f,
	-0.169793f, -0.177494f, 0.969364f, -0.050394f, -0.050394f, 0.406174f,

	-0.121551f, -0.120720f, 0.985217f, -0.091123f, -0.091123f, 0.396694f,
	-0.158797f, -0.065002f, 0.985169f, -0.118396f, -0.050374f, 0.396694f,
	-0.336164f, -0.126386f, 0.933285f, -0.165933f, -0.070600f, 0.387214f,

	-0.336164f, -0.126386f, 0.933285f, -0.165933f, -0.070600f, 0.387214f,
	-0.261583f, -0.245276f, 0.933496f, -0.127710f, -0.127710f, 0.387214f,
	-0.121551f, -0.120720f, 0.985217f, -0.091123f, -0.091123f, 0.396694f,

	-0.261583f, -0.245276f, 0.933496f, -0.127710f, -0.127710f, 0.387214f,
	-0.336164f, -0.126386f, 0.933285f, -0.165933f, -0.070600f, 0.387214f,
	-0.471909f, -0.233051f, 0.850288f, -0.186563f, -0.079378f, 0.373359f,

	-0.471909f, -0.233051f, 0.850288f, -0.186563f, -0.079378f, 0.373359f,
	-0.346586f, -0.395598f, 0.850518f, -0.143588f, -0.143588f, 0.373359f,
	-0.261583f, -0.245276f, 0.933496f, -0.127710f, -0.127710f, 0.387214f,

	-0.733000f, -0.332142f, 0.593627f, -0.028702f, -0.012212f, 0.420029f,
	-0.804409f, -0.026273f, 0.593494f, -0.031113f, 0.000000f, 0.420029f,
	-0.246499f, -0.005445f, 0.969128f, -0.070977f, 0.000000f, 0.406174f,

	-0.246499f, -0.005445f, 0.969128f, -0.070977f, 0.000000f, 0.406174f,
	-0.225129f, -0.099029f, 0.969283f, -0.065476f, -0.027859f, 0.406174f,
	-0.733000f, -0.332142f, 0.593627f, -0.028702f, -0.012212f, 0.420029f,

	-0.225129f, -0.099029f, 0.969283f, -0.065476f, -0.027859f, 0.406174f,
	-0.246499f, -0.005445f, 0.969128f, -0.070977f, 0.000000f, 0.406174f,
	-0.171991f, 0.000588f, 0.985098f, -0.128342f, 0.000000f, 0.396694f,

	-0.171991f, 0.000588f, 0.985098f, -0.128342f, 0.000000f, 0.396694f,
	-0.158797f, -0.065002f, 0.985169f, -0.118396f, -0.050374f, 0.396694f,
	-0.225129f, -0.099029f, 0.969283f, -0.065476f, -0.027859f, 0.406174f,

	-0.158797f, -0.065002f, 0.985169f, -0.118396f, -0.050374f, 0.396694f,
	-0.171991f, 0.000588f, 0.985098f, -0.128342f, 0.000000f, 0.396694f,
	-0.359594f, 0.011522f, 0.933038f, -0.179874f, 0.000000f, 0.387214f,

	-0.359594f, 0.011522f, 0.933038f, -0.179874f, 0.000000f, 0.387214f,
	-0.336164f, -0.126386f, 0.933285f, -0.165933f, -0.070600f, 0.387214f,
	-0.158797f, -0.065002f, 0.985169f, -0.118396f, -0.050374f, 0.396694f,

	-0.336164f, -0.126386f, 0.933285f, -0.165933f, -0.070600f, 0.387214f,
	-0.359594f, 0.011522f, 0.933038f, -0.179874f, 0.000000f, 0.387214f,
	-0.526357f, -0.034643f, 0.849558f, -0.202236f, 0.000000f, 0.373359f,

	-0.526357f, -0.034643f, 0.849558f, -0.202236f, 0.000000f, 0.373359f,
	-0.471909f, -0.233051f, 0.850288f, -0.186563f, -0.079378f, 0.373359f,
	-0.336164f, -0.126386f, 0.933285f, -0.165933f, -0.070600f, 0.387214f,

	-0.804409f, -0.026273f, 0.593494f, -0.031113f, 0.000000f, 0.420029f,
	-0.753279f, 0.282480f, 0.593949f, -0.028702f, 0.012212f, 0.420029f,
	-0.229426f, 0.088891f, 0.969258f, -0.065476f, 0.027859f, 0.406174f,

	-0.229426f, 0.088891f, 0.969258f, -0.065476f, 0.027859f, 0.406174f,
	-0.246499f, -0.005445f, 0.969128f, -0.070977f, 0.000000f, 0.406174f,
	-0.804409f, -0.026273f, 0.593494f, -0.031113f, 0.000000f, 0.420029f,

	-0.246499f, -0.005445f, 0.969128f, -0.070977f, 0.000000f, 0.406174f,
	-0.229426f, 0.088891f, 0.969258f, -0.065476f, 0.027859f, 0.406174f,
	-0.158332f, 0.066096f, 0.985171f, -0.118396f, 0.050374f, 0.396694f,

	-0.158332f, 0.066096f, 0.985171f, -0.118396f, 0.050374f, 0.396694f,
	-0.171991f, 0.000588f, 0.985098f, -0.128342f, 0.000000f, 0.396694f,
	-0.246499f, -0.005445f, 0.969128f, -0.070977f, 0.000000f, 0.406174f,

	-0.171991f, 0.000588f, 0.985098f, -0.128342f, 0.000000f, 0.396694f,
	-0.158332f, 0.066096f, 0.985171f, -0.118396f, 0.050374f, 0.396694f,
	-0.327101f, 0.147859f, 0.933350f, -0.165933f, 0.070600f, 0.387214f,

	-0.327101f, 0.147859f, 0.933350f, -0.165933f, 0.070600f, 0.387214f,
	-0.359594f, 0.011522f, 0.933038f, -0.179874f, 0.000000f, 0.387214f,
	-0.171991f, 0.000588f, 0.985098f, -0.128342f, 0.000000f, 0.396694f,

	-0.359594f, 0.011522f, 0.933038f, -0.179874f, 0.000000f, 0.387214f,
	-0.327101f, 0.147859f, 0.933350f, -0.165933f, 0.070600f, 0.387214f,
	-0.499161f, 0.168496f, 0.849969f, -0.186563f, 0.079378f, 0.373359f,

	-0.499161f, 0.168496f, 0.849969f, -0.186563f, 0.079378f, 0.373359f,
	-0.526357f, -0.034643f, 0.849558f, -0.202236f, 0.000000f, 0.373359f,
	-0.359594f, 0.011522f, 0.933038f, -0.179874f, 0.000000f, 0.387214f,

	-0.753279f, 0.282480f, 0.593949f, -0.028702f, 0.012212f, 0.420029f,
	-0.587537f, 0.549763f, 0.593769f, -0.022090f, 0.022090f, 0.420029f,
	-0.177494f, 0.169793f, 0.969364f, -0.050394f, 0.050394f, 0.406174f,

	-0.177494f, 0.169793f, 0.969364f, -0.050394f, 0.050394f, 0.406174f,
	-0.229426f, 0.088891f, 0.969258f, -0.065476f, 0.027859f, 0.406174f,
	-0.753279f, 0.282480f, 0.593949f, -0.028702f, 0.012212f, 0.420029f,

	-0.229426f, 0.088891f, 0.969258f, -0.065476f, 0.027859f, 0.406174f,
	-0.177494f, 0.169793f, 0.969364f, -0.050394f, 0.050394f, 0.406174f,
	-0.120720f, 0.121551f, 0.985217f, -0.091123f, 0.091123f, 0.396694f,

	-0.120720f, 0.121551f, 0.985217f, -0.091123f, 0.091123f, 0.396694f,
	-0.158332f, 0.066096f, 0.985171f, -0.118396f, 0.050374f, 0.396694f,
	-0.229426f, 0.088891f, 0.969258f, -0.065476f, 0.027859f, 0.406174f,

	-0.158332f, 0.066096f, 0.985171f, -0.118396f, 0.050374f, 0.396694f,
	-0.120720f, 0.121551f, 0.985217f, -0.091123f, 0.091123f, 0.396694f,
	-0.245276f, 0.261583f, 0.933496f, -0.127710f, 0.127710f, 0.387214f,

	-0.245276f, 0.261583f, 0.933496f, -0.127710f, 0.127710f, 0.387214f,
	-0.327101f, 0.147859f, 0.933350f, -0.165933f, 0.070600f, 0.387214f,
	-0.158332f, 0.066096f, 0.985171f, -0.118396f, 0.050374f, 0.396694f,

	-0.327101f, 0.147859f, 0.933350f, -0.165933f, 0.070600f, 0.387214f,
	-0.245276f, 0.261583f, 0.933496f, -0.127710f, 0.127710f, 0.387214f,
	-0.395598f, 0.346586f, 0.850518f, -0.143588f, 0.143588f, 0.373359f,

	-0.395598f, 0.346586f, 0.850518f, -0.143588f, 0.143588f, 0.373359f,
	-0.499161f, 0.168496f, 0.849969f, -0.186563f, 0.079378f, 0.373359f,
	-0.327101f, 0.147859f, 0.933350f, -0.165933f, 0.070600f, 0.387214f,

	-0.587537f, 0.549763f, 0.593769f, -0.022090f, 0.022090f, 0.420029f,
	-0.332142f, 0.733000f, 0.593627f, -0.012212f, 0.028702f, 0.420029f,
	-0.099029f, 0.225129f, 0.969283f, -0.027859f, 0.065476f, 0.406174f,

	-0.099029f, 0.225129f, 0.969283f, -0.027859f, 0.065476f, 0.406174f,
	-0.177494f, 0.169793f, 0.969364f, -0.050394f, 0.050394f, 0.406174f,
	-0.587537f, 0.549763f, 0.593769f, -0.022090f, 0.022090f, 0.420029f,

	-0.177494f, 0.169793f, 0.969364f, -0.050394f, 0.050394f, 0.406174f,
	-0.099029f, 0.225129f, 0.969283f, -0.027859f, 0.065476f, 0.406174f,
	-0.065002f, 0.158797f, 0.985169f, -0.050374f, 0.118396f, 0.396694f,

	-0.065002f, 0.158797f, 0.985169f, -0.050374f, 0.118396f, 0.396694f,
	-0.120720f, 0.121551f, 0.985217f, -0.091123f, 0.091123f, 0.396694f,
	-0.177494f, 0.169793f, 0.969364f, -0.050394f, 0.050394f, 0.406174f,

	-0.120720f, 0.121551f, 0.985217f, -0.091123f, 0.091123f, 0.396694f,
	-0.065002f, 0.158797f, 0.985169f, -0.050374f, 0.118396f, 0.396694f,
	-0.126386f, 0.336164f, 0.933285f, -0.070600f, 0.165933f, 0.387214f,

	-0.126386f, 0.336164f, 0.933285f, -0.070600f, 0.165933f, 0.387214f,
	-0.245276f, 0.261583f, 0.933496f, -0.127710f, 0.127710f, 0.387214f,
	-0.120720f, 0.121551f, 0.985217f, -0.091123f, 0.091123f, 0.396694f,

	-0.245276f, 0.261583f, 0.933496f, -0.127710f, 0.127710f, 0.387214f,
	-0.126386f, 0.336164f, 0.933285f, -0.070600f, 0.165933f, 0.387214f,
	-0.233051f, 0.471909f, 0.850288f, -0.079378f, 0.186563f, 0.373359f,

	-0.233051f, 0.471909f, 0.850288f, -0.079378f, 0.186563f, 0.373359f,
	-0.395598f, 0.346586f, 0.850518f, -0.143588f, 0.143588f, 0.373359f,
	-0.245276f, 0.261583f, 0.933496f, -0.127710f, 0.127710f, 0.387214f,

	-0.332142f, 0.733000f, 0.593627f, -0.012212f, 0.028702f, 0.420029f,
	-0.026273f, 0.804409f, 0.593494f, 0.000000f, 0.031113f, 0.420029f,
	-0.005445f, 0.246499f, 0.969128f, 0.000000f, 0.070977f, 0.406174f,

	-0.005445f, 0.246499f, 0.969128f, 0.000000f, 0.070977f, 0.406174f,
	-0.099029f, 0.225129f, 0.969283f, -0.027859f, 0.065476f, 0.406174f,
	-0.332142f, 0.733000f, 0.593627f, -0.012212f, 0.028702f, 0.420029f,

	-0.099029f, 0.225129f, 0.969283f, -0.027859f, 0.065476f, 0.406174f,
	-0.005445f, 0.246499f, 0.969128f, 0.000000f, 0.070977f, 0.406174f,
	0.000588f, 0.171991f, 0.985098f, 0.000000f, 0.128342f, 0.396694f,

	0.000588f, 0.171991f, 0.985098f, 0.000000f, 0.128342f, 0.396694f,
	-0.065002f, 0.158797f, 0.985169f, -0.050374f, 0.118396f, 0.396694f,
	-0.099029f, 0.225129f, 0.969283f, -0.027859f, 0.065476f, 0.406174f,

	-0.065002f, 0.158797f, 0.985169f, -0.050374f, 0.118396f, 0.396694f,
	0.000588f, 0.171991f, 0.985098f, 0.000000f, 0.128342f, 0.396694f,
	0.011522f, 0.359594f, 0.933038f, 0.000000f, 0.179874f, 0.387214f,

	0.011522f, 0.359594f, 0.933038f, 0.000000f, 0.179874f, 0.387214f,
	-0.126386f, 0.336164f, 0.933285f, -0.070600f, 0.165933f, 0.387214f,
	-0.065002f, 0.158797f, 0.985169f, -0.050374f, 0.118396f, 0.396694f,

	-0.126386f, 0.336164f, 0.933285f, -0.070600f, 0.165933f, 0.387214f,
	0.011522f, 0.359594f, 0.933038f, 0.000000f, 0.179874f, 0.387214f,
	-0.034643f, 0.526357f, 0.849558f, 0.000000f, 0.202236f, 0.373359f,

	-0.034643f, 0.526357f, 0.849558f, 0.000000f, 0.202236f, 0.373359f,
	-0.233051f, 0.471909f, 0.850288f, -0.079378f, 0.186563f, 0.373359f,
	-0.126386f, 0.336164f, 0.933285f, -0.070600f, 0.165933f, 0.387214f,

	-0.026273f, 0.804409f, 0.593494f, 0.000000f, 0.031113f, 0.420029f,
	0.282480f, 0.753279f, 0.593949f, 0.012212f, 0.028702f, 0.420029f,
	0.088891f, 0.229426f, 0.969258f, 0.027859f, 0.065476f, 0.406174f,

	0.088891f, 0.229426f, 0.969258f, 0.027859f, 0.065476f, 0.406174f,
	-0.005445f, 0.246499f, 0.969128f, 0.000000f, 0.070977f, 0.406174f,
	-0.026273f, 0.804409f, 0.593494f, 0.000000f, 0.031113f, 0.420029f,

	-0.005445f, 0.246499f, 0.969128f, 0.000000f, 0.070977f, 0.406174f,
	0.088891f, 0.229426f, 0.969258f, 0.027859f, 0.065476f, 0.406174f,
	0.066096f, 0.158332f, 0.985171f, 0.050374f, 0.118396f, 0.396694f,

	0.066096f, 0.158332f, 0.985171f, 0.050374f, 0.118396f, 0.396694f,
	0.000588f, 0.171991f, 0.985098f, 0.000000f, 0.128342f, 0.396694f,
	-0.005445f, 0.246499f, 0.969128f, 0.000000f, 0.070977f, 0.406174f,

	0.000588f, 0.171991f, 0.985098f, 0.000000f, 0.128342f, 0.396694f,
	0.066096f, 0.158332f, 0.985171f, 0.050374f, 0.118396f, 0.396694f,
	0.147859f, 0.327101f, 0.933350f, 0.070600f, 0.165933f, 0.387214f,

	0.147859f, 0.327101f, 0.933350f, 0.070600f, 0.165933f, 0.387214f,
	0.011522f, 0.359594f, 0.933038f, 0.000000f, 0.179874f, 0.387214f,
	0.000588f, 0.171991f, 0.985098f, 0.000000f, 0.128342f, 0.396694f,

	0.011522f, 0.359594f, 0.933038f, 0.000000f, 0.179874f, 0.387214f,
	0.147859f, 0.327101f, 0.933350f, 0.070600f, 0.165933f, 0.387214f,
	0.168496f, 0.499161f, 0.849969f, 0.079378f, 0.186563f, 0.373359f,

	0.168496f, 0.499161f, 0.849969f, 0.079378f, 0.186563f, 0.373359f,
	-0.034643f, 0.526357f, 0.849558f, 0.000000f, 0.202236f, 0.373359f,
	0.011522f, 0.359594f, 0.933038f, 0.000000f, 0.179874f, 0.387214f,

	0.282480f, 0.753279f, 0.593949f, 0.012212f, 0.028702f, 0.420029f,
	0.549763f, 0.587537f, 0.593769f, 0.022090f, 0.022090f, 0.420029f,
	0.169793f, 0.177494f, 0.969364f, 0.050394f, 0.050394f, 0.406174f,

	0.169793f, 0.177494f, 0.969364f, 0.050394f, 0.050394f, 0.406174f,
	0.088891f, 0.229426f, 0.969258f, 0.027859f, 0.065476f, 0.406174f,
	0.282480f, 0.753279f, 0.593949f, 0.012212f, 0.028702f, 0.420029f,

	0.088891f, 0.229426f, 0.969258f, 0.027859f, 0.065476f, 0.406174f,
	0.169793f, 0.177494f, 0.969364f, 0.050394f, 0.050394f, 0.406174f,
	0.121551f, 0.120720f, 0.985217f, 0.091123f, 0.091123f, 0.396694f,

	0.121551f, 0.120720f, 0.985217f, 0.091123f, 0.091123f, 0.396694f,
	0.066096f, 0.158332f, 0.985171f, 0.050374f, 0.118396f, 0.396694f,
	0.088891f, 0.229426f, 0.969258f, 0.027859f, 0.065476f, 0.406174f,

	0.066096f, 0.158332f, 0.985171f, 0.050374f, 0.118396f, 0.396694f,
	0.121551f, 0.120720f, 0.985217f, 0.091123f, 0.091123f, 0.396694f,
	0.261583f, 0.245276f, 0.933496f, 0.127710f, 0.127710f, 0.387214f,

	0.261583f, 0.245276f, 0.933496f, 0.127710f, 0.127710f, 0.387214f,
	0.147859f, 0.327101f, 0.933350f, 0.070600f, 0.165933f, 0.387214f,
	0.066096f, 0.158332f, 0.985171f, 0.050374f, 0.118396f, 0.396694f,

	0.147859f, 0.327101f, 0.933350f, 0.070600f, 0.165933f, 0.387214f,
	0.261583f, 0.245276f, 0.933496f, 0.127710f, 0.127710f, 0.387214f,
	0.346586f, 0.395598f, 0.850518f, 0.143588f, 0.143588f, 0.373359f,

	0.346586f, 0.395598f, 0.850518f, 0.143588f, 0.143588f, 0.373359f,
	0.168496f, 0.499161f, 0.849969f, 0.079378f, 0.186563f, 0.373359f,
	0.147859f, 0.327101f, 0.933350f, 0.070600f, 0.165933f, 0.387214f,

	0.549763f, 0.587537f, 0.593769f, 0.022090f, 0.022090f, 0.420029f,
	0.733000f, 0.332142f, 0.593627f, 0.028702f, 0.012212f, 0.420029f,
	0.225129f, 0.099029f, 0.969283f, 0.065476f, 0.027859f, 0.406174f,

	0.225129f, 0.099029f, 0.969283f, 0.065476f, 0.027859f, 0.406174f,
	0.169793f, 0.177494f, 0.969364f, 0.050394f, 0.050394f, 0.406174f,
	0.549763f, 0.587537f, 0.593769f, 0.022090f, 0.022090f, 0.420029f,

	0.169793f, 0.177494f, 0.969364f, 0.050394f, 0.050394f, 0.406174f,
	0.225129f, 0.099029f, 0.969283f, 0.065476f, 0.027859f, 0.406174f,
	0.158797f, 0.065002f, 0.985169f, 0.118396f, 0.050374f, 0.396694f,

	0.158797f, 0.065002f, 0.985169f, 0.118396f, 0.050374f, 0.396694f,
	0.121551f, 0.120720f, 0.985217f, 0.091123f, 0.091123f, 0.396694f,
	0.169793f, 0.177494f, 0.969364f, 0.050394f, 0.050394f, 0.406174f,

	0.121551f, 0.120720f, 0.985217f, 0.091123f, 0.091123f, 0.396694f,
	0.158797f, 0.065002f, 0.985169f, 0.118396f, 0.050374f, 0.396694f,
	0.336164f, 0.126386f, 0.933285f, 0.165933f, 0.070600f, 0.387214f,

	0.336164f, 0.126386f, 0.933285f, 0.165933f, 0.070600f, 0.387214f,
	0.261583f, 0.245276f, 0.933496f, 0.127710f, 0.127710f, 0.387214f,
	0.121551f, 0.120720f, 0.985217f, 0.091123f, 0.091123f, 0.396694f,

	0.261583f, 0.245276f, 0.933496f, 0.127710f, 0.127710f, 0.387214f,
	0.336164f, 0.126386f, 0.933285f, 0.165933f, 0.070600f, 0.387214f,
	0.471909f, 0.233051f, 0.850288f, 0.186563f, 0.079378f, 0.373359f,

	0.471909f, 0.233051f, 0.850288f, 0.186563f, 0.079378f, 0.373359f,
	0.346586f, 0.395598f, 0.850518f, 0.143588f, 0.143588f, 0.373359f,
	0.261583f, 0.245276f, 0.933496f, 0.127710f, 0.127710f, 0.387214f,

	0.733000f, 0.332142f, 0.593627f, 0.028702f, 0.012212f, 0.420029f,
	0.804409f, 0.026273f, 0.593494f, 0.031113f, 0.000000f, 0.420029f,
	0.246499f, 0.005445f, 0.969128f, 0.070977f, 0.000000f, 0.406174f,

	0.246499f, 0.005445f, 0.969128f, 0.070977f, 0.000000f, 0.406174f,
	0.225129f, 0.099029f, 0.969283f, 0.065476f, 0.027859f, 0.406174f,
	0.733000f, 0.332142f, 0.593627f, 0.028702f, 0.012212f, 0.420029f,

	0.225129f, 0.099029f, 0.969283f, 0.065476f, 0.027859f, 0.406174f,
	0.246499f, 0.005445f, 0.969128f, 0.070977f, 0.000000f, 0.406174f,
	0.171991f, -0.000588f, 0.985098f, 0.128342f, 0.000000f, 0.396694f,

	0.171991f, -0.000588f, 0.985098f, 0.128342f, 0.000000f, 0.396694f,
	0.158797f, 0.065002f, 0.985169f, 0.118396f, 0.050374f, 0.396694f,
	0.225129f, 0.099029f, 0.969283f, 0.065476f, 0.027859f, 0.406174f,

	0.158797f, 0.065002f, 0.985169f, 0.118396f, 0.050374f, 0.396694f,
	0.171991f, -0.000588f, 0.985098f, 0.128342f, 0.000000f, 0.396694f,
	0.359594f, -0.011522f, 0.933038f, 0.179874f, 0.000000f, 0.387214f,

	0.359594f, -0.011522f, 0.933038f, 0.179874f, 0.000000f, 0.387214f,
	0.336164f, 0.126386f, 0.933285f, 0.165933f, 0.070600f, 0.387214f,
	0.158797f, 0.065002f, 0.985169f, 0.118396f, 0.050374f, 0.396694f,

	0.336164f, 0.126386f, 0.933285f, 0.165933f, 0.070600f, 0.387214f,
	0.359594f, -0.011522f, 0.933038f, 0.179874f, 0.000000f, 0.387214f,
	0.526357f, 0.034643f, 0.849558f, 0.202236f, 0.000000f, 0.373359f,

	0.526357f, 0.034643f, 0.849558f, 0.202236f, 0.000000f, 0.373359f,
	0.471909f, 0.233051f, 0.850288f, 0.186563f, 0.079378f, 0.373359f,
	0.336164f, 0.126386f, 0.933285f, 0.165933f, 0.070600f, 0.387214f,

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\pch.h ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 19, 1998
 Pch.h - Precompiled header
 ***************************************************************************/
#define STRICT

#include "Windows.h"
#include "commctrl.h"
#include "stdio.h"
#include "shlobj.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\gtypes.h ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 20, 1998
 GTypes.h - Some useful data types
 ***************************************************************************/

#ifndef __GTYPES_H__
#define __GTYPES_H__

#define BIGFLOAT 1.0e30f

class Point3 {
	public:

	Point3();
	Point3(float ix, float iy, float iz);

	Point3	operator / (float f);
	Point3&	operator += (Point3 p);
	Point3&	operator /= (float f);

	float	length()	{ return (float)sqrt(x*x + y*y + z*z); }
	Point3&	normalize()
	{
		float len = length();
		x /= len;
		y /= len;
		z /= len;
		return *this;
	}


	float x, y, z;
};

typedef Point3 Color3;

class Box3 {
	public:
	Box3();
	Box3(Point3 pMin, Point3 pMax);

	void	SetEmpty();
	BOOL	IsEmpty();
	void	IncludePoint(Point3 p);
	void	IncludeBox(Box3 b);
	BOOL	PointIncluded(Point3 p);

	Point3	min;
	Point3	max;
};

class Vertex {
public:
	Point3	pos;
	Point3	normal;
};

class Face {
public:
	int		v[3];

	void	CalcNormal(Vertex* vertArray);
	Point3	Normal();

//private:
	Point3	normal;
};


class TriMesh {
public:
	TriMesh();
	~TriMesh();
	void	SetNumVerts(int n);
	void	SetNumFaces(int n);
	int		GetNumVerts();
	int		GetNumFaces();
	void	SetVert(int n, Vertex p);
	void	SetVert(int n, Point3 p);
	void	SetFace(int n, Face f);
	Vertex&	GetVert(int n);
	Face&	GetFace(int n);
	void	Normalize(float factor = 0.0f);
	void	BuildNormals();

private:
	int		numVerts;
	int		numFaces;
	Vertex*	vertArray;
	Face*	faceArray;
};

#endif // __GTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\MaxFind.cpp ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 19, 1998
 MaxFind.cpp - Main Window Proc Implementation
 ***************************************************************************/
#include "pch.h"
#include "app.h"
#include "resource.h"
#include "..\..\include\buildver.h"

App* pApp = NULL;
#define	WM_INITAFTERCREATE	(WM_USER+42)

BOOL CommandHandler(HWND hWnd, int cmd, int code, HWND hControl);	// Handle WM_COMMAND messages

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpszCmdLine, int nCmdShow)
{
    MSG 	msg;
	BOOL	bRetVal = FALSE;
	HWND	hWnd;
	BOOL	done = FALSE;	

	pApp = new App(hInstance, nCmdShow);
	pApp->Init();

    hWnd = CreateWindowEx(
					WS_EX_CONTROLPARENT,
					THECLASSNAME,
#ifndef DESIGN_VER
					pApp->GetString(IDS_APPTITLE),
#else
					pApp->GetString(IDS_VIZ_APPTITLE),
#endif
					WS_OVERLAPPEDWINDOW,
					pApp->regsettings.x, pApp->regsettings.y,
					pApp->regsettings.w, pApp->regsettings.h,
					NULL, NULL, hInstance, NULL);

	if (!hWnd) {
		char msg[128];
		strcpy(msg, pApp->GetString(IDS_FATAL_ERROR));
		MessageBox(NULL, pApp->GetString(IDS_NOWIN_ERROR), msg, MB_OK);
		return 0;
	}

	// My own post-creation initializations
	SendMessage(hWnd, WM_INITAFTERCREATE, 0, 0);

    ShowWindow(hWnd, nCmdShow);
    if (nCmdShow != SW_HIDE)
        UpdateWindow(hWnd);

	while (!done) {
		while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE) == TRUE) {
			if (GetMessage(&msg, NULL, 0,0 )) {
				if (!IsDialogMessage(pApp->GetPanel(), &msg)) {
					TranslateMessage(&msg);
					DispatchMessage(&msg);
					}
			}
			else {
				done = TRUE;
			}
		}
		pApp->AppIsIdle(); 
	}

	pApp->SetRegSettings();

	return bRetVal;
}

LRESULT CALLBACK AppWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
	char		buf[256];

//	sprintf(buf, "AppMsg: %08x\n", message);
//	OutputDebugString(buf);

    switch (message) {
    case WM_CREATE: {
        pApp->SetHWnd(hWnd);
        pApp->SetHMenu(GetMenu(hWnd));
		pApp->SetDC(GetDC(hWnd));
		pApp->CreateControls();
		DragAcceptFiles(hWnd, TRUE);
        HICON hIcon= LoadIcon(pApp->GetInstance(), MAKEINTRESOURCE(IDI_MAINWND));
        SetClassLong(hWnd, GCL_HICON, (LONG) hIcon);
        
		return FALSE; }

    case WM_INITAFTERCREATE:
		pApp->PostInit();
		break;

	case WM_ENABLE:
		break;

	case WM_WINDOWPOSCHANGING: {
		WINDOWPOS *wp = (WINDOWPOS*)lParam;
		if (wp->cx<310) {
			wp->cx=310;
		}
		if (wp->cy<170) {
			wp->cy=170;
		}
		break;
		}
	case WM_MOVE:
		pApp->Move();
		break;

	case WM_SIZE:
		pApp->Resize(wParam, LOWORD(lParam), HIWORD(lParam));
		break;

    case WM_DROPFILES:
		DragQueryFile((HDROP)wParam, 0, buf, 256);
		DragFinish((HDROP)wParam);
		return 0;

    case WM_COMMAND:
		if (!CommandHandler(hWnd, LOWORD(wParam), HIWORD(wParam), (HWND)lParam)) {
			return FALSE;
		}
		break;

    case WM_TIMER:
		break;

	case WM_LBUTTONDOWN:
		break;
	case WM_LBUTTONUP:
		break;

	case WM_MBUTTONDOWN:
		break;
	case WM_MBUTTONUP:
		break;

	case WM_RBUTTONDOWN:
		break;
	case WM_RBUTTONUP:
		break;

	case WM_MOUSEMOVE:
		break;

	case WM_CHAR:
		if((TCHAR)wParam != VK_ESCAPE)
			break;
		//pApp->statusPanel->setCancel(1);
		break;
	
	case WM_QUERYENDSESSION:
		return FALSE;

	case WM_ERASEBKGND:
		break;

	case WM_PAINT:
		break;

    case WM_CLOSE:
		pApp->AppIsClosing();
        DestroyWindow(hWnd);
        return TRUE;

    case WM_DESTROY:
		pApp->AppIsClosing();
        DragAcceptFiles(hWnd, 0);
        PostQuitMessage(0);
        return FALSE;

    default:
		break;
    }
    return (DefWindowProc(hWnd, message, wParam, lParam));
}

BOOL CommandHandler(HWND hWnd, int cmd, int code, HWND hControl)
{
	switch(cmd) {
		case ID_FILE_RESET:
			pApp->Reset();
			break;
		case ID_FILE_EXIT:
			pApp->AppIsClosing();
		    DragAcceptFiles(hWnd, 0);
		    PostQuitMessage(0);
			return FALSE;

		case ID_HELP_ABOUT:
			pApp->DoAboutBox();
			break;

		case IDC_START:
			pApp->DoFind();
			break;
		case IDC_BROWSE:
			pApp->DoCD();
			break;
		case IDC_FILESPEC:
			if (code == CBN_SELENDOK) {
				int idx = SendMessage(hControl, CB_GETCURSEL, 0, 0);
				pApp->regsettings.filespec = idx;
				}
			break;
		case IDC_LISTBOX:
			if (code == LBN_DBLCLK) {
				pApp->ViewFile();
				}
			break;
	}
	return TRUE;
}



LRESULT CALLBACK StaticWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
	PAINTSTRUCT	ps;
//	char buf[256];

//	sprintf(buf, "StaticMsg: %08x\n", message);
//	OutputDebugString(buf);

    switch (message) {
	case WM_COMMAND:
		if (!CommandHandler(hWnd, LOWORD(wParam), HIWORD(wParam), (HWND)lParam)) {
			return FALSE;
		}
		break;
	case WM_PAINT: {
		RECT rect;

		BeginPaint(hWnd, &ps);

		HDC hDC = ps.hdc;
		GetClientRect(hWnd, &rect);
		rect.bottom -= 2;

		SelectObject(hDC, CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DSHADOW)));
		MoveToEx(hDC,rect.left,rect.bottom,NULL);
		LineTo(hDC,rect.left,rect.top);
		LineTo(hDC,rect.right,rect.top);

		DeleteObject(SelectObject(hDC, CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DHIGHLIGHT))));
		MoveToEx(hDC,rect.left+1,rect.bottom,NULL);
		LineTo(hDC,rect.left+1,rect.top+1);
		LineTo(hDC,rect.right,rect.top+1);

		SelectObject(hDC, CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DHIGHLIGHT)));
		MoveToEx(hDC,rect.left+1,rect.bottom,NULL);
		LineTo(hDC,rect.right,rect.bottom);
		LineTo(hDC,rect.right,rect.top);

		DeleteObject(SelectObject(hDC, CreatePen(PS_SOLID, 0, GetSysColor(COLOR_3DSHADOW))));
		MoveToEx(hDC,rect.left+1,rect.bottom-1,NULL);
		LineTo(hDC,rect.right-1,rect.bottom-1);
		LineTo(hDC,rect.right-1,rect.top-1);

		DeleteObject(SelectObject(hDC, GetStockObject(BLACK_PEN)));
		EndPaint(hWnd, &ps);
		}
		break;

    default:
		break;
    }
    return (DefWindowProc(hWnd, message, wParam, lParam));
}

BOOL CALLBACK statPanDlgProc( HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
	{
//	char buf[256];
//	sprintf(buf, "StatPanMsg: %08x\n", message);
//	OutputDebugString(buf);

	switch (message) {
	case WM_COMMAND:
		if (CommandHandler(hwnd, LOWORD(wParam), HIWORD(wParam), (HWND)lParam)) {
			return FALSE;
			}
		break;
		}
	return FALSE;
	}

TCHAR *App::GetString(int id)
{
	static TCHAR buf[256];

	if (GetInstance())
		return LoadString(GetInstance(), id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MaxFind.rc
//
#define IDR_MAINMENU                    101
#define IDI_MAINWND                     102
#define IDD_PANEL                       104
#define IDD_ABOUTBOX                    105
#define IDD_ABOUTBOX_TINY               106
#define IDD_SHOW_PROPERTIES             109
#define IDD_VIZ_ABOUTBOX                110
#define IDD_CHOOSE_DIR                  317
#define IDC_PROPERTY                    1003
#define IDC_SEARCHTEXT                  1004
#define IDC_FIND                        1005
#define IDC_CD                          1006
#define IDC_SUBDIR                      1007
#define IDC_TXTSEARCH                   1008
#define IDC_TXTFILESPEC                 1009
#define IDC_TXTPROPERTY                 1010
#define IDC_DLGFRAME                    1011
#define IDC_DESC_EDIT                   1012
#define IDC_IMAGE                       1012
#define IDC_TITLE                       1014
#define IDC_SUBJECT                     1015
#define IDC_AUTHOR                      1016
#define IDC_MANAGER                     1017
#define IDC_COMPANY                     1018
#define IDC_CATEGORY                    1019
#define IDC_KEYWORDS                    1020
#define IDC_COMMENTS                    1021
#define IDC_CUSTOM                      1023
#define IDC_CONTENTS                    1024
#define IDC_PREV                        1025
#define IDC_NEXT                        1026
#define IDC_SEARCHEDIT                  1030
#define IDC_FILESPEC                    1031
#define IDC_START                       1033
#define IDC_BROWSE                      1034
#define IDC_SUBDIRS                     1035
#define IDC_STATUSPANEL                 1036
#define IDC_BORDER                      1040
#define IDC_MY_OK                       1286
#define ID_FILE_EXIT                    40002
#define ID_FILE_RESET                   40003
#define IDS_PROP_ALL                    40004
#define IDS_PROP_TITLE                  40005
#define ID_HELP_ABOUT                   40006
#define IDS_PROP_SUBJECT                40006
#define IDS_PROP_AUTHOR                 40007
#define IDS_PROP_MANAGER                40008
#define IDS_PROP_COMPANY                40009
#define IDS_PROP_CATEGORY               40010
#define IDS_PROP_KEYWORDS               40011
#define IDS_PROP_COMMENTS               40012
#define IDS_PROP_EXTDEP                 40013
#define IDS_PROP_PLUGINS                40014
#define IDS_PROP_OBJECTS                40015
#define IDS_PROP_MATERIALS              40016
#define IDS_PROP_CUSTOM                 40017
#define IDS_SEARCHTEXT                  40018
#define IDS_FILESPEC                    40019
#define IDS_PROPERTY                    40020
#define IDS_START                       40021
#define IDS_BROWSE                      40022
#define IDS_SUBFOLDERS                  40023
#define IDS_SELFOLDERTITLE              40024
#define IDS_CURDIR                      40025
#define IDS_BTNCANCEL                   40026
#define IDS_BTNSTART                    40027
#define IDS_SEARCHDIR                   40028
#define IDS_CUST_NAME                   40029
#define IDS_CUST_VALUE                  40030
#define IDS_CUST_TYPE                   40031
#define IDS_TYPE_TEXT                   40032
#define IDS_TYPE_DATE                   40033
#define IDS_TYPE_NUMBER                 40034
#define IDS_TYPE_BOOL                   40035
#define IDS_VAL_YES                     40036
#define IDS_VAL_NO                      40037
#define IDS_APPTITLE                    40038
#define IDS_NOWIN_ERROR                 40039
#define IDS_FATAL_ERROR                 40040
#define IDS_APP_FONT                    40041
#define IDS_VIZ_APPTITLE                40042

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1041
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\gtypes.cpp ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 20, 1998
 GTypes.cpp - Some useful data types
 ***************************************************************************/

#include "pch.h"
#include <stdlib.h>
#include <math.h>
#include "gtypes.h"

//***************************************************************************
//
// Point3
//
//****************************************************************************

Point3::Point3()
{
	x = 0.0f;
	y = 0.0f;
	z = 0.0f;
}

Point3::Point3(float ix, float iy, float iz)
{
	x = ix;
	y = iy;
	z = iz;
}

Point3 Point3::operator / (float f)
{
	return Point3(x/f, y/f, z/f);
}

Point3& Point3::operator += (Point3 p)
{
	x += p.x;
	y += p.y;
	z += p.z;
	return *this;
}

Point3& Point3::operator /= (float f)
{
	x /= f;
	y /= f;
	z /= f;
	return *this;
}

//***************************************************************************
//
// Box3
//
//****************************************************************************

Box3::Box3()
{
	SetEmpty();
}

Box3::Box3(Point3 pMin, Point3 pMax)
{
	min = pMin;
	max = pMax;
}

void Box3::SetEmpty()
{
	min = Point3( BIGFLOAT,  BIGFLOAT,  BIGFLOAT);
	max = Point3(-BIGFLOAT, -BIGFLOAT, -BIGFLOAT);
}

BOOL Box3::IsEmpty()
{
	BOOL bEmpty = TRUE;

	if (max.x > min.x)
		bEmpty = FALSE;
	if (max.y > min.y)
		bEmpty = FALSE;
	if (max.y > min.y)
		bEmpty = FALSE;
	return bEmpty;
}

void Box3::IncludePoint(Point3 p)
{
	if (p.x < min.x)
		min.x = p.x;
	if (p.y < min.y)
		min.y = p.y;
	if (p.z < min.z)
		min.z = p.z;

	if (p.x > max.x)
		max.x = p.x;
	if (p.y > max.y)
		max.y = p.y;
	if (p.z > max.z)
		max.z = p.z;
}

void Box3::IncludeBox(Box3 b)
{
	IncludePoint(b.min);
	IncludePoint(b.max);
}

BOOL Box3::PointIncluded(Point3 p)
{
	BOOL bInside = FALSE;

	if ((p.x >= min.x) && (p.y >= min.y) && (p.z >= min.z) &&
		(p.x <= max.x) && (p.y <= max.y) && (p.z <= max.z)) {
		bInside = TRUE;
	}

	return bInside;
}

//***************************************************************************
//
// Face
//
//***************************************************************************

// Points p1, p2, & p3 specified in counter clock-wise order
void calcNormal(float v[3][3], float out[3])
{
	float v1[3],v2[3];
	static const int x = 0;
	static const int y = 1;
	static const int z = 2;

	// Calculate two vectors from the three points
	v1[x] = v[0][x] - v[1][x];
	v1[y] = v[0][y] - v[1][y];
	v1[z] = v[0][z] - v[1][z];

	v2[x] = v[1][x] - v[2][x];
	v2[y] = v[1][y] - v[2][y];
	v2[z] = v[1][z] - v[2][z];

	// Take the cross product of the two vectors to get
	// the normal vector which will be stored in out
	out[x] = v1[y]*v2[z] - v1[z]*v2[y];
	out[y] = v1[z]*v2[x] - v1[x]*v2[z];
	out[z] = v1[x]*v2[y] - v1[y]*v2[x];

	// Normalize the vector (shorten length to one)
    //
    float l = (float)sqrt(out[0]*out[0]+out[1]*out[1]+out[2]*out[2]);
	out[0] /= l;
	out[1] /= l;
	out[2] /= l;
}

void Face::CalcNormal(Vertex* vertArray)
{
	float n[3];
	float p[3][3];

	p[0][0] = vertArray[v[0]].pos.x;
	p[0][1] = vertArray[v[0]].pos.y;
	p[0][2] = vertArray[v[0]].pos.z;

	p[1][0] = vertArray[v[1]].pos.x;
	p[1][1] = vertArray[v[1]].pos.y;
	p[1][2] = vertArray[v[1]].pos.z;

	p[2][0] = vertArray[v[2]].pos.x;
	p[2][1] = vertArray[v[2]].pos.y;
	p[2][2] = vertArray[v[2]].pos.z;

	calcNormal(p, n);

	normal.x = n[0];
	normal.y = n[1];
	normal.z = n[2];
}

Point3 Face::Normal()
{
	return normal;
}



//***************************************************************************
//
// TriMesh
//
//***************************************************************************

TriMesh::TriMesh()
{
	numVerts = 0;
	numFaces = 0;
	vertArray = NULL;
	faceArray = NULL;
}

TriMesh::~TriMesh()
{
	delete [] vertArray;
	delete [] faceArray;
}

void TriMesh::SetNumVerts(int n)
{
	delete [] vertArray;

	vertArray = new Vertex[n];
	numVerts = n;
}

void TriMesh::SetNumFaces(int n)
{
	delete [] faceArray;

	faceArray = new Face[n];
	numFaces = n;
}

int TriMesh::GetNumVerts()
{
	return numVerts;
}

int TriMesh::GetNumFaces()
{
	return numFaces;
}

void TriMesh::SetVert(int n, Vertex v)
{
	vertArray[n] = v;
}

void TriMesh::SetVert(int n, Point3 p)
{
	vertArray[n].pos = p;
}

void TriMesh::SetFace(int n, Face f)
{
	faceArray[n] = f;
}

Vertex& TriMesh::GetVert(int n)
{
	return vertArray[n];
}

Face& TriMesh::GetFace(int n)
{
	return faceArray[n];
}

void TriMesh::Normalize(float factor)
{
	float scale = 0.0f;

	if (scale == 0.0f) {
		for (int v = 0; v < numVerts; v++) {
			if (scale > vertArray[v].pos.x || scale > vertArray[v].pos.y || scale > vertArray[v].pos.z)
				scale = (float)max(vertArray[v].pos.x, (float)max(vertArray[v].pos.y, vertArray[v].pos.z));
		}
	}

	for (int v = 0; v < numVerts; v++) {
		vertArray[v].pos.x /= factor;
		vertArray[v].pos.y /= factor;
		vertArray[v].pos.z /= factor;
	}
}

void TriMesh::BuildNormals()
{
#if 1
	int f, v;
	int* numNormals = new int[numVerts];

	for (v = 0; v < numVerts; v++) {
		numNormals[v] = 0;
	}

	for (f = 0; f < numFaces; f++) {
		faceArray[f].CalcNormal(vertArray);
		for (int c = 0; c < 3; c++) {
			int vert = faceArray[f].v[c];
			vertArray[vert].normal += faceArray[f].normal;
			numNormals[vert]++;
		}
	}

	for (v = 0; v < numVerts; v++) {
		vertArray[v].normal /= (float)numNormals[v];
		vertArray[v].normal.normalize();
	}

	delete [] numNormals;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\ShowPropDlg.cpp ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 20, 1998
 ShowPropDlg.cpp - Property dialog implementation
 ***************************************************************************/
#include "pch.h"
#include "app.h"
#include "resource.h"

BOOL CALLBACK	PropDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
void VariantToString(App* pApp, PROPVARIANT* pProp, char* szString, int bufSize);
void TypeNameFromVariant(App* pApp, PROPVARIANT* pProp, char* szString, int bufSize);


HINSTANCE		hInstance;

void App::ShowProperties()
	{
	hInstance = GetInstance();

	if (!hPropDialog) {
		hPropDialog = CreateDialogParam(
			GetInstance(),
			MAKEINTRESOURCE(IDD_SHOW_PROPERTIES),
			GetHWnd(),
			(DLGPROC)PropDlgProc,
			(LPARAM)this);
		}
	else {
		SetActiveWindow(hPropDialog);
		GetProperties();
		}
	}

BOOL CALLBACK PropDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
	{
	App* pApp = (App*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (message) {
		case WM_INITDIALOG:
			{
			pApp = (App*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			//CenterWindow(hWnd, GetParent(hWnd));
			SetWindowPos(hWnd, HWND_TOP, pApp->regsettings.propdlgx, pApp->regsettings.propdlgy, 0, 0, 
				SWP_NOOWNERZORDER|SWP_NOSIZE);

			pApp->hPropDialog = hWnd;

			// Arrange the columns in the list view
			LV_COLUMN column;
			column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
			column.fmt = LVCFMT_LEFT;
			column.pszText = pApp->GetString(IDS_CUST_NAME);
			column.cx = 80;
			ListView_InsertColumn(GetDlgItem(hWnd, IDC_CUSTOM), 0, &column);
			column.pszText = pApp->GetString(IDS_CUST_VALUE);
			ListView_InsertColumn(GetDlgItem(hWnd, IDC_CUSTOM), 1, &column);
			column.pszText = pApp->GetString(IDS_CUST_TYPE);
			ListView_InsertColumn(GetDlgItem(hWnd, IDC_CUSTOM), 2, &column);

			pApp->GetProperties();
			}
			return 1;
        case WM_CLOSE:
            DestroyWindow(hWnd);
            break;
        case WM_DESTROY:
			{
			RECT wr;
			GetWindowRect(hWnd, &wr);
			pApp->regsettings.propdlgx = wr.left;
			pApp->regsettings.propdlgy = wr.top;
			}
            pApp->hPropDialog = NULL;
            break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
				case IDCANCEL:
					DestroyWindow(hWnd);
					break;
				case IDC_PREV:
					{
					int cur = SendMessage(pApp->hListBox, LB_GETCURSEL, 0, 0);
					//int tot = SendMessage(pApp->hListBox, LB_GETCOUNT, 0, 0);
					if (cur > 0) {
						SendMessage(pApp->hListBox, LB_SETCURSEL, cur-1, 0);
						pApp->GetProperties();
						}
					}
					break;
				case IDC_NEXT:
					{
					int cur = SendMessage(pApp->hListBox, LB_GETCURSEL, 0, 0);
					int tot = SendMessage(pApp->hListBox, LB_GETCOUNT, 0, 0);
					if (cur < (tot-1)) {
						SendMessage(pApp->hListBox, LB_SETCURSEL, cur+1, 0);
						pApp->GetProperties();
						}
					}
					break;

				}
			return 1;
		}
	return 0;
	}

void App::GetProperties()
	{
	LPSTORAGE				pStorage = NULL;
	IPropertySetStorage*	pPropertySetStorage = NULL;
	IPropertyStorage*		pSummaryInfoStorage = NULL;
	IPropertyStorage*		pDocumentSummaryInfoStorage = NULL;
	IPropertyStorage*		pUserDefinedPropertyStorage = NULL;
	wchar_t					wfilename[_MAX_PATH];
	char					szBuf[256];
	char					filename[MAX_PATH];

	SendMessage(GetDlgItem(hPropDialog, IDC_TITLE), WM_SETTEXT, 0, (LPARAM)"");
	SendMessage(GetDlgItem(hPropDialog, IDC_SUBJECT), WM_SETTEXT, 0, (LPARAM)"");
	SendMessage(GetDlgItem(hPropDialog, IDC_AUTHOR), WM_SETTEXT, 0, (LPARAM)"");
	SendMessage(GetDlgItem(hPropDialog, IDC_MANAGER), WM_SETTEXT, 0, (LPARAM)"");
	SendMessage(GetDlgItem(hPropDialog, IDC_COMPANY), WM_SETTEXT, 0, (LPARAM)"");
	SendMessage(GetDlgItem(hPropDialog, IDC_CATEGORY), WM_SETTEXT, 0, (LPARAM)"");
	SendMessage(GetDlgItem(hPropDialog, IDC_KEYWORDS), WM_SETTEXT, 0, (LPARAM)"");
	SendMessage(GetDlgItem(hPropDialog, IDC_COMMENTS), WM_SETTEXT, 0, (LPARAM)"");
	SendMessage(GetDlgItem(hPropDialog, IDC_CONTENTS), LB_RESETCONTENT, 0, 0);
	ListView_DeleteAllItems(GetDlgItem(hPropDialog, IDC_CUSTOM));

	int idx = SendMessage(hListBox, LB_GETCURSEL, 0, 0);

	SendMessage(hListBox, LB_GETTEXT, idx, (LPARAM)filename);
	SetWindowText(hPropDialog, filename);

	MultiByteToWideChar(CP_ACP, 0, filename, -1, wfilename, _MAX_PATH);
	HRESULT	res = StgOpenStorage(wfilename, (LPSTORAGE)0, STGM_DIRECT|STGM_READ|STGM_SHARE_EXCLUSIVE,	NULL,0,&pStorage);
	if (res!=S_OK) {
		return;
		}


	// Get the Storage interface
	if (S_OK != pStorage->QueryInterface(IID_IPropertySetStorage, (void**)&pPropertySetStorage)) {
		pStorage->Release();
		return;
		}

	// Get the SummaryInfo property set interface
	if (S_OK == pPropertySetStorage->Open(FMTID_SummaryInformation, STGM_READ|STGM_SHARE_EXCLUSIVE, &pSummaryInfoStorage)) {
		BOOL bFound = FALSE;

		PROPSPEC	PropSpec[5];
		PROPVARIANT	PropVar[5];

		PropSpec[0].ulKind = PRSPEC_PROPID;
		PropSpec[0].propid = PID_TITLE;

		PropSpec[1].ulKind = PRSPEC_PROPID;
		PropSpec[1].propid = PID_SUBJECT;

		PropSpec[2].ulKind = PRSPEC_PROPID;
		PropSpec[2].propid = PID_AUTHOR;

		PropSpec[3].ulKind = PRSPEC_PROPID;
		PropSpec[3].propid = PID_KEYWORDS;

		PropSpec[4].ulKind = PRSPEC_PROPID;
		PropSpec[4].propid = PID_COMMENTS;

		HRESULT hr = pSummaryInfoStorage->ReadMultiple(5, PropSpec, PropVar);
		if (S_OK == hr) {
			if (PropVar[0].vt == VT_LPSTR) {
				SendMessage(GetDlgItem(hPropDialog, IDC_TITLE), WM_SETTEXT, 0, (LPARAM)PropVar[0].pszVal);
				}
			if (PropVar[1].vt == VT_LPSTR) {
				SendMessage(GetDlgItem(hPropDialog, IDC_SUBJECT), WM_SETTEXT, 0, (LPARAM)PropVar[1].pszVal);
				}
			if (PropVar[2].vt == VT_LPSTR) {
				SendMessage(GetDlgItem(hPropDialog, IDC_AUTHOR), WM_SETTEXT, 0, (LPARAM)PropVar[2].pszVal);
				}
			if (PropVar[3].vt == VT_LPSTR) {
				SendMessage(GetDlgItem(hPropDialog, IDC_KEYWORDS), WM_SETTEXT, 0, (LPARAM)PropVar[3].pszVal);
				}
			if (PropVar[4].vt == VT_LPSTR) {
				SendMessage(GetDlgItem(hPropDialog, IDC_COMMENTS), WM_SETTEXT, 0, (LPARAM)PropVar[4].pszVal);
				}
			}

		FreePropVariantArray(5, PropVar);
		pSummaryInfoStorage->Release();
		}


	// Get the DocumentSummaryInfo property set interface
	if (S_OK == pPropertySetStorage->Open(FMTID_DocSummaryInformation, STGM_READ|STGM_SHARE_EXCLUSIVE, &pDocumentSummaryInfoStorage)) {
		BOOL bFound = FALSE;

		PROPSPEC	PropSpec[5];
		PROPVARIANT	PropVar[5];

		PropSpec[0].ulKind = PRSPEC_PROPID;
		PropSpec[0].propid = PID_MANAGER;

		PropSpec[1].ulKind = PRSPEC_PROPID;
		PropSpec[1].propid = PID_COMPANY;

		PropSpec[2].ulKind = PRSPEC_PROPID;
		PropSpec[2].propid = PID_CATEGORY;

		PropSpec[3].ulKind = PRSPEC_PROPID;
		PropSpec[3].propid = PID_HEADINGPAIR;

		PropSpec[4].ulKind = PRSPEC_PROPID;
		PropSpec[4].propid = PID_DOCPARTS;

		HRESULT hr = pDocumentSummaryInfoStorage->ReadMultiple(5, PropSpec, PropVar);
		if (S_OK == hr) {
			if (PropVar[0].vt == VT_LPSTR) {
				SendMessage(GetDlgItem(hPropDialog, IDC_MANAGER), WM_SETTEXT, 0, (LPARAM)PropVar[0].pszVal);
				}
			if (PropVar[1].vt == VT_LPSTR) {
				SendMessage(GetDlgItem(hPropDialog, IDC_COMPANY), WM_SETTEXT, 0, (LPARAM)PropVar[1].pszVal);
				}
			if (PropVar[2].vt == VT_LPSTR) {
				SendMessage(GetDlgItem(hPropDialog, IDC_CATEGORY), WM_SETTEXT, 0, (LPARAM)PropVar[2].pszVal);
				}
			if ((PropVar[3].vt == (VT_VARIANT | VT_VECTOR)) && (PropVar[4].vt == (VT_LPSTR | VT_VECTOR))) {
				CAPROPVARIANT*	pHeading = &PropVar[3].capropvar;
				CALPSTR*		pDocPart = &PropVar[4].calpstr;

				// Headings:
				// =========
				// 0  - General
				// 2  - Mesh Totals
				// 4  - Scene Totals
				// 6  - External Dependencies
				// 8  - Objects
				// 10 - Materials
				// 12 - Plug-Ins

				int nDocPart = 0;
				for (UINT i=0; i<pHeading->cElems; i+=2) {
					SendMessage(GetDlgItem(hPropDialog, IDC_CONTENTS), LB_ADDSTRING, 0, (LPARAM)pHeading->pElems[i].pszVal);
					for (int j=0; j<pHeading->pElems[i+1].lVal; j++) {
						sprintf(szBuf, "\t%s", pDocPart->pElems[nDocPart]);
						SendMessage(GetDlgItem(hPropDialog, IDC_CONTENTS), LB_ADDSTRING, 0, (LPARAM)szBuf);
						nDocPart++;
						}
					}

				}

			}

		FreePropVariantArray(5, PropVar);
		pDocumentSummaryInfoStorage->Release();
		}

	if (S_OK == pPropertySetStorage->Open(FMTID_UserDefinedProperties, STGM_READ|STGM_SHARE_EXCLUSIVE, &pUserDefinedPropertyStorage)) {
		int		numUserProps = 0;

		// First we need to count the properties
		IEnumSTATPROPSTG*	pIPropertyEnum;
		if (S_OK == pUserDefinedPropertyStorage->Enum(&pIPropertyEnum)) {
			STATPROPSTG property;
			while (pIPropertyEnum->Next(1, &property, NULL) == S_OK) {
				if (property.lpwstrName) {
					CoTaskMemFree(property.lpwstrName);
					property.lpwstrName = NULL;
					numUserProps++;
					}
				}

			PROPSPEC* pPropSpec = new PROPSPEC[numUserProps];
			PROPVARIANT* pPropVar = new PROPVARIANT[numUserProps];

			ZeroMemory(pPropVar, numUserProps*sizeof(PROPVARIANT));
			ZeroMemory(pPropSpec, numUserProps*sizeof(PROPSPEC));

			pIPropertyEnum->Reset();
			int idx = 0;
			while (pIPropertyEnum->Next(1, &property, NULL) == S_OK) {
				if (property.lpwstrName) {
					pPropSpec[idx].ulKind = PRSPEC_LPWSTR;
					pPropSpec[idx].lpwstr = (LPWSTR)CoTaskMemAlloc(sizeof(wchar_t)*(wcslen(property.lpwstrName)+1));
					wcscpy(pPropSpec[idx].lpwstr, property.lpwstrName);
					idx++;
					CoTaskMemFree(property.lpwstrName);
					property.lpwstrName = NULL;
					}
				}
			pIPropertyEnum->Release();

			ListView_DeleteAllItems(GetDlgItem(hPropDialog, IDC_CUSTOM));
			HRESULT hr = pUserDefinedPropertyStorage->ReadMultiple(idx, pPropSpec, pPropVar);
			if (S_OK == hr) {
				for (int i=0; i<idx; i++) {
					wcstombs(szBuf, pPropSpec[i].lpwstr, 255);
					LV_ITEM item;
					item.mask = LVIF_TEXT;
					item.iItem = i;
					item.iSubItem = 0;
					item.pszText = szBuf;
					item.cchTextMax = strlen(szBuf);
					ListView_InsertItem(GetDlgItem(hPropDialog, IDC_CUSTOM), &item);

					VariantToString(this, &pPropVar[i], szBuf, 255);
					item.iSubItem = 1;
					item.pszText = szBuf;
					item.cchTextMax = strlen(szBuf);
					ListView_SetItem(GetDlgItem(hPropDialog, IDC_CUSTOM), &item);

					TypeNameFromVariant(this, &pPropVar[i], szBuf, 255);
					item.iSubItem = 2;
					item.pszText = szBuf;
					item.cchTextMax = strlen(szBuf);
					ListView_SetItem(GetDlgItem(hPropDialog, IDC_CUSTOM), &item);
					}
				}

			for (int i=0; i<idx; i++) {
				CoTaskMemFree(pPropSpec[i].lpwstr);
				}

			FreePropVariantArray(numUserProps, pPropVar);

			delete [] pPropSpec;
			delete [] pPropVar;
			}

		pUserDefinedPropertyStorage->Release();
		}

	pPropertySetStorage->Release();
	pStorage->Release();
	}

void TypeNameFromVariant(App* pApp, PROPVARIANT* pProp, char* szString, int bufSize)
	{
	switch (pProp->vt) {
		case VT_LPWSTR:
		case VT_LPSTR:
			strcpy(szString, pApp->GetString(IDS_TYPE_TEXT));
			break;
		case VT_I4:
		case VT_R4:
		case VT_R8:
			strcpy(szString, pApp->GetString(IDS_TYPE_NUMBER));
			break;
		case VT_BOOL:
			strcpy(szString, pApp->GetString(IDS_TYPE_BOOL));
			break;
		case VT_FILETIME:
			strcpy(szString, pApp->GetString(IDS_TYPE_DATE));
			break;
		default:
			strcpy(szString, "");
			break;
		}
	}

void VariantToString(App* pApp, PROPVARIANT* pProp, char* szString, int bufSize)
	{
	switch (pProp->vt) {
		case VT_LPWSTR:
			wcstombs(szString, pProp->pwszVal, bufSize);
			break;
		case VT_LPSTR:
			strcpy(szString, pProp->pszVal);
			break;
		case VT_I4:
			sprintf(szString, "%ld", pProp->lVal);
			break;
		case VT_R4:
			sprintf(szString, "%f", pProp->fltVal);
			break;
		case VT_R8:
			sprintf(szString, "%lf", pProp->dblVal);
			break;
		case VT_BOOL:
			sprintf(szString, "%s", pProp->boolVal ? pApp->GetString(IDS_VAL_YES) : pApp->GetString(IDS_VAL_NO));
			break;
		case VT_FILETIME:
			SYSTEMTIME sysTime;
			FileTimeToSystemTime(&pProp->filetime, &sysTime);
			GetDateFormat(LOCALE_SYSTEM_DEFAULT,
						  DATE_SHORTDATE,
						  &sysTime,
						  NULL,
						  szString,
						  bufSize);
			break;
		default:
			strcpy(szString, "");
			break;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Melt\RESOURCE.H ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Melt.rc
//
#define IDS_MELTMOD                     1
#define IDS_TITLE                       2
#define IDS_LIBDESC                     3
#define IDS_CATEGORY                    8
#define IDS_MELTAMOUNT                  9
#define IDS_SPREAD                      10
#define IDS_CUTOFF                      11
#define IDS_CONFINE                     12
#define IDS_SOLIDITY                    13
#define IDS_SOLIDITYVAL                 14
#define IDS_AXIS                        15
#define IDS_NEGAXIS                     16
#define IDC_AX                          1001
#define IDC_AY                          1003
#define IDC_AZ                          1004
#define IDC_SPREAD_EDIT                 1010
#define IDC_SPREAD_SPIN                 1011
#define IDC_S3                          1014
#define IDC_S4                          1015
#define IDC_AMT_EDIT                    1016
#define IDC_AMT_SPIN                    1017
#define IDC_S1                          1018
#define IDC_S2                          1019
#define IDC_S5                          1020
#define IDC_VIS_EDIT                    1021
#define IDC_VIS_SPIN                    1022
#define IDC_CONFINE                     1023
#define IDC_NEGATIVE                    1024
#define IDD_MELT                        1032

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1025
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Melt\MELT.CPP ===
/*===========================================================================*\
 | 
 |  FILE:	melt.cpp
 |			Simple melting modifier
 | 
 |  AUTHOR: Harry Denholm
 |			All Rights Reserved. Copyright(c) Kinetix 1998
 |
 |	HIST:	3-6-98 : Ported
 |					 This is pretty self-contained. Bit messy..
 | 
\*===========================================================================*/


#include "max.h"
#include "iparamm.h"
#include "simpmod.h"
#include "resource.h"


#define BIGFLOAT	float(999999)
float sign(float x) { return (x < 0.0f ? -1.0f : 1.0f); }


#define MELT_ID1 0x36d04fa5
#define MELT_ID2 0x500727b3


// The DLL instance handle
HINSTANCE hInstance;
extern TCHAR *GetString(int sid);



/*===========================================================================*\
 | Melt Modifier
\*===========================================================================*/

class MeltMod : public SimpleMod {	
	public:
		static IParamMap *pmapParam;

		MeltMod();

		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= TSTR(GetString(IDS_MELTMOD)); }  
		virtual Class_ID ClassID() { return Class_ID(MELT_ID1,MELT_ID2);}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_MELTMOD); }
						
		IOResult Load(ILoad *iload);

		// From simple mod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,
			Matrix3& invmat);		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
};


/*===========================================================================*\
 | Deformer (map) function
\*===========================================================================*/

class MeltDeformer: public Deformer {
	public:
		float cx, cy, cz, xsize, ysize, zsize, size;
		Matrix3 tm,invtm;
		TimeValue time;
		Box3 bbox;

		float bulger;
		float ybr,zbr,visvaluea;
		int confiner,axis,vistypea,negaxis;


		MeltDeformer();
		MeltDeformer(
			TimeValue t, ModContext &mc,
			float bulgea,float yba,float zba ,int confinea, int vistype, 
			float visvalue, int axisa, int negaxisa,
			Matrix3& modmat, Matrix3& modinv);
		void SetAxis(Matrix3 &tmAxis);

		Point3 Map(int i, Point3 p); 
	};



IParamMap *MeltMod::pmapParam = NULL;




/*===========================================================================*\
 | Variable Handling Stuff & PUID
\*===========================================================================*/

#define PB_MELTAMT	0
#define PB_CONFINE	1
#define PB_YB		2
#define PB_ZB		3

#define PB_VISTYPE  4
#define PB_VISVAL   5

#define PB_AXIS		6
#define PB_NEGAXIS	7


static int visIDs[] = {IDC_S1,IDC_S2,IDC_S3,IDC_S4,IDC_S5};
static int axisIDs[] = {IDC_AX,IDC_AY,IDC_AZ};


static ParamUIDesc descParam[] = {
	ParamUIDesc(
		PB_MELTAMT,
		EDITTYPE_FLOAT,
		IDC_AMT_EDIT,IDC_AMT_SPIN,
		0.0f,1000.0f,
		1.0f),
	ParamUIDesc(
		PB_YB,
		EDITTYPE_FLOAT,
		IDC_SPREAD_EDIT,IDC_SPREAD_SPIN,
		0.0f,100.0f,
		0.1f),
	ParamUIDesc(PB_VISTYPE,TYPE_RADIO,visIDs,5),
	ParamUIDesc(
		PB_VISVAL,
		EDITTYPE_FLOAT,
		IDC_VIS_EDIT,IDC_VIS_SPIN,
		0.2f,30.0f,
		0.02f),
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),
	ParamUIDesc(PB_NEGAXIS,TYPE_SINGLECHEKBOX,IDC_NEGATIVE),
};

#define PARAMDESC_LENGH 6



/*===========================================================================*\
 | ParamBlocks
\*===========================================================================*/

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
 };

static ParamBlockDescID descVer2[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
 };

static ParamBlockDescID descVer3[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
 };

static ParamBlockDescID descVer4[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, FALSE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 },
	{ TYPE_INT, NULL, FALSE, 7 },
 };

#define PBLOCK_LENGTH	8

/*===========================================================================*\
 | Old Versions (as this is a port, keep it compatible)
\*===========================================================================*/

static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer1,4,1),
	ParamVersionDesc(descVer2,6,2),
	ParamVersionDesc(descVer3,7,3)
	};
#define NUM_OLDVERSIONS	3


#define CURRENT_VERSION	4
static ParamVersionDesc curVersion(descVer4,PBLOCK_LENGTH,CURRENT_VERSION);




/*===========================================================================*\
 | Register PLCB at load time
\*===========================================================================*/

IOResult MeltMod::Load(ILoad *iload)
	{
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,
			SIMPMOD_PBLOCKREF));
	return IO_OK;
	}



/*===========================================================================*\
 | Melt Stuff
\*===========================================================================*/

MeltMod::MeltMod() : SimpleMod()
	{
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descVer4, PBLOCK_LENGTH, CURRENT_VERSION));

	pblock->SetValue(PB_MELTAMT,0,0);

	pblock->SetValue(PB_YB,0,19.0f);
	pblock->SetValue(PB_ZB,0,0);

	pblock->SetValue(PB_CONFINE,0,0);
	pblock->SetValue(PB_VISTYPE,0,0);
	pblock->SetValue(PB_VISVAL,0,1.0f);

	pblock->SetValue(PB_AXIS,0,0);
	pblock->SetValue(PB_NEGAXIS,0,0);
	}



/*===========================================================================*\
 | BeginEditParams - called when user opens mod
\*===========================================================================*/

void MeltMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_MELT),
		GetString(IDS_TITLE),
		0);	
	}
		


/*===========================================================================*\
 | EndEditParams - Hmm guess what this does
\*===========================================================================*/

void MeltMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}



/*===========================================================================*\
 | Calculate validity
\*===========================================================================*/

Interval MeltMod::GetValidity(TimeValue t)
	{
	float f;

	Interval valid = FOREVER;

	pblock->GetValue(PB_MELTAMT,t,f,valid);
	pblock->GetValue(PB_YB,t,f,valid);
	pblock->GetValue(PB_ZB,t,f,valid);
	pblock->GetValue(PB_CONFINE,t,f,valid);
	pblock->GetValue(PB_VISTYPE,t,f,valid);
	pblock->GetValue(PB_VISVAL,t,f,valid);
	pblock->GetValue(PB_AXIS,t,f,valid);
	pblock->GetValue(PB_NEGAXIS,t,f,valid);

	return valid;
}



/*===========================================================================*\
 | Clone Method
\*===========================================================================*/

RefTargetHandle MeltMod::Clone(RemapDir& remap) {	
	MeltMod* newmod = new MeltMod();	
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newmod->SimpleModClone(this);
	return(newmod);
	}




/*===========================================================================*\
 | Melt Deformer
\*===========================================================================*/

MeltDeformer::MeltDeformer() 
	{ 
	tm.IdentityMatrix();
	invtm = Inverse(tm);
	time = 0;	

	// to make purify happy:
	cx=cy=cz=xsize=ysize=zsize=size=bulger=ybr=zbr=visvaluea=0.0f;
	bbox.Init();
	confiner=axis=vistypea=negaxis=0;
	}

void MeltDeformer::SetAxis(Matrix3 &tmAxis)
	{
	Matrix3 itm = Inverse(tmAxis);
	tm    = tm*tmAxis;
	invtm =	itm*invtm;
	}



/*===========================================================================*\
 | Actual deforming function
\*===========================================================================*/

Point3 MeltDeformer::Map(int i, Point3 p)
	{

	float x, y, z;
	float xw,yw,zw;
	float vdist,mfac,dx,dy;
	float defsinex,coldef,realmax;
	
	// Mult by mc
	p = p*tm;


	x = p.x; y = p.y; z = p.z;
	xw= x-cx; yw= y-cy; zw= z-cz;

	if(xw==0.0 && yw==0.0 && zw==0.0) xw=yw=zw=1.0f; // Kill singularity for XW,YW,ZW
	if(x==0.0 && y==0.0 && z==0.0) x=y=z=1.0f; // Kill singularity for XYZ

	// Find distance from centre
	vdist=(float) sqrt(xw*xw+yw*yw+zw*zw);
	
	mfac=size/vdist;

	if(axis==0){
		dx = xw+sign(xw)*((float) (fabs(xw*mfac))*(bulger*ybr));
		dy = yw+sign(yw)*((float) (fabs(yw*mfac))*(bulger*ybr));
		x=(dx+cx);
		y=(dy+cy);
	}
	if(axis==1){
		dx = xw+sign(xw)*((float) (fabs(xw*mfac))*(bulger*ybr));
		dy = zw+sign(zw)*((float) (fabs(zw*mfac))*(bulger*ybr));
		x=(dx+cx);
		z=(dy+cz);
	}
	if(axis==2){
		dx = zw+sign(zw)*((float) (fabs(zw*mfac))*(bulger*ybr));
		dy = yw+sign(yw)*((float) (fabs(yw*mfac))*(bulger*ybr));
		z=(dx+cz);
		y=(dy+cy);
	}


	if(axis==0) if(p.z<(bbox.pmin.z+zbr)) goto skipmelt;
	if(axis==1) if(p.y<(bbox.pmin.y+zbr)) goto skipmelt;
	if(axis==2) if(p.x<(bbox.pmin.x+zbr)) goto skipmelt;


	if(axis==0) realmax = (float)hypot( (bbox.pmax.x-cx),(bbox.pmax.y-cy) );
	if(axis==1) realmax = (float)hypot( (bbox.pmax.x-cx),(bbox.pmax.z-cz) );
	if(axis==2) realmax = (float)hypot( (bbox.pmax.z-cz),(bbox.pmax.y-cy) );


	if(axis==0){
	defsinex = (float)hypot( (x-cx),(y-cy) );
	coldef = realmax - (float)hypot( (x-cx),(y-cy) );
	}
	if(axis==1){
	defsinex = (float)hypot( (x-cx),(z-cz) );
	coldef = realmax - (float)hypot( (x-cx),(z-cz) );
	}
	if(axis==2){
	defsinex = (float)hypot( (z-cz),(y-cy) );
	coldef = realmax - (float)hypot( (z-cz),(y-cy) );
	}


	if (coldef<0.0f) coldef=0.0f;


	defsinex+=(coldef/visvaluea);

	// Melt me!
	if(axis==0){
		if(!negaxis)
		{
			z-=(defsinex*bulger);
			if(z<=bbox.pmin.z) z=bbox.pmin.z;
			if(z<=(bbox.pmin.z+zbr)) z=(bbox.pmin.z+zbr);
		}
		else
		{
			z+=(defsinex*bulger);
			if(z>=bbox.pmax.z) z=bbox.pmax.z;
			if(z>=(bbox.pmax.z+zbr)) z=(bbox.pmax.z+zbr);
		}
	}
	if(axis==1){
		if(!negaxis)
		{
			y-=(defsinex*bulger);
			if(y<=bbox.pmin.y) y=bbox.pmin.y;
			if(y<=(bbox.pmin.y+zbr)) y=(bbox.pmin.y+zbr);
		}
		else
		{
			y+=(defsinex*bulger);
			if(y>=bbox.pmax.y) y=bbox.pmax.y;
			if(y>=(bbox.pmax.y+zbr)) y=(bbox.pmax.y+zbr);
		}
	}
	if(axis==2){
		if(!negaxis)
		{
			x-=(defsinex*bulger);
			if(x<=bbox.pmin.x) x=bbox.pmin.x;
			if(x<=(bbox.pmin.x+zbr)) x=(bbox.pmin.x+zbr);
		}
		else
		{
			x+=(defsinex*bulger);
			if(x>=bbox.pmax.x) x=bbox.pmax.x;
			if(x>=(bbox.pmax.x+zbr)) x=(bbox.pmax.x+zbr);
		}
	}


	// [jump point] don't melt this point...
	skipmelt:

	p.x = x; p.y = y; p.z = z;
	p = p*invtm;
	return p;

}


MeltDeformer::MeltDeformer(
		TimeValue t, ModContext &mc,
			float bulgea, float yba, float zba,int confinea, int vistype, 
			float visvalue, int axisa, int negaxisa,
		Matrix3& modmat, Matrix3& modinv) 
	{
	// Save the tm and inverse tm
	tm = modmat; invtm = modinv;
	time = t; // mjm - 5.14.99

	ybr = yba;
	zbr = zba;
	bulger = bulgea;
	confiner = confinea;
	vistypea=vistype;
	visvaluea=visvalue;
	axis=axisa;
	negaxis=negaxisa;

	// Save the bounding box
	assert(mc.box);
	bbox = *mc.box;
	cx = bbox.Center().x;
	cy = bbox.Center().y;
	cz = bbox.Center().z;
	// Compute the size and center
	xsize = bbox.pmax.x - bbox.pmin.x;
	ysize = bbox.pmax.y - bbox.pmin.y;
	zsize = bbox.pmax.z - bbox.pmin.z;
	size=(xsize>ysize) ? xsize:ysize;
	size=(zsize>size) ? zsize:size;
	size /= 2.0f;
	ybr/= 100.0f;
	zbr/= 10.0f;
	bulger/=100.0f;
} 


// Provides a reference to our callback object to handle the deformation.
Deformer& MeltMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	float yb,zb,bulge,visvaluer;
	int confine,vistyper,axis,negaxis;
	pblock->GetValue(PB_MELTAMT,t,bulge,FOREVER);

	pblock->GetValue(PB_YB,t,yb,FOREVER);
	pblock->GetValue(PB_ZB,t,zb,FOREVER);
	pblock->GetValue(PB_CONFINE,t,confine,FOREVER);

	pblock->GetValue(PB_VISTYPE,t,vistyper,FOREVER);
	pblock->GetValue(PB_VISVAL,t,visvaluer,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	pblock->GetValue(PB_NEGAXIS,t,negaxis,FOREVER);

	// Evaluate the presets to values
	// used to be called Viscosity, which is why this is vis<...>
	if(vistyper==0) visvaluer=2.0f;
	if(vistyper==1) visvaluer=12.0f;
	if(vistyper==2) visvaluer=0.4f;
	if(vistyper==3) visvaluer=0.7f;
	if(vistyper==4) visvaluer=visvaluer;

	// Build and return deformer
	static MeltDeformer deformer;
	deformer = MeltDeformer(t,mc,bulge,yb,zb,confine,vistyper,visvaluer,
		axis,negaxis,mat,invmat);

	return deformer;
	}



/*===========================================================================*\
 | Get parameter types
\*===========================================================================*/

ParamDimension *MeltMod::GetParameterDim(int pbIndex)
	{
	return defaultDim;  
	}



/*===========================================================================*\
 | Returns parameter names
\*===========================================================================*/

TSTR MeltMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_MELTAMT:		return TSTR(GetString(IDS_MELTAMOUNT));
		case PB_YB:			return TSTR(GetString(IDS_SPREAD));
		case PB_ZB:			return TSTR(GetString(IDS_CUTOFF));
		case PB_CONFINE:	return TSTR(GetString(IDS_CONFINE));
		case PB_VISTYPE:	return TSTR(GetString(IDS_SOLIDITY));
		case PB_VISVAL:		return TSTR(GetString(IDS_SOLIDITYVAL));
		case PB_AXIS:		return TSTR(GetString(IDS_AXIS));
		case PB_NEGAXIS:	return TSTR(GetString(IDS_NEGAXIS));
		default:			return TSTR(_T(""));
		}
	}



/*===========================================================================*\
 | The Class Descriptor
\*===========================================================================*/
class DecayClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new MeltMod; }
	const TCHAR *	ClassName() { return GetString(IDS_MELTMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(MELT_ID1,MELT_ID2); }
	const TCHAR* 	Category() { return GetString(IDS_CATEGORY); }
	};

static DecayClassDesc decayDesc;
ClassDesc* GetMeltModDesc() { return &decayDesc; }




/*===========================================================================*\
 | The DLL Functions
\*===========================================================================*/

int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

	if (! controlsInit) {
		controlsInit = TRUE;
		
		InitCustomControls(hInstance);
		InitCommonControls();
	}
	
	return(TRUE);
	}




/*===========================================================================*\
 | Plugin interface code
\*===========================================================================*/

__declspec( dllexport ) int LibNumberClasses() {return 1;}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetMeltModDesc();		
		default: return 0;
		}
	}

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIBDESC); }

__declspec( dllexport ) ULONG
LibVersion() {  return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\vtrackbl.cpp ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 20, 1998
 VTrackBl.h - Virtual TrackBall Implementation
 Guts of the Virtual Trackball has been stolen from Microsoft Sample Code
 ***************************************************************************/
#define STRICT 

#include <windows.h>
#include <math.h>

#include "stdio.h"
#include "stdlib.h"

#include "vtrackbl.h"

// Support code

static void		AddQuats(float *q1, float *q2, float *dest);
static void		BuildRotmatrix(float m[4][4], float q[4]);
static void		AxisToQuat(float a[3], float phi, float q[4]);
static void		vzero(float *v);
static void		vset(float *v, float x, float y, float z);
static void		vsub(const float *src1, const float *src2, float *dst);
static void		vcopy(const float *v1, float *v2);
static void		vcross(const float *v1, const float *v2, float *cross);
static float	vlength(const float *v);
static void		vscale(float *v, float div);
static void		vnormal(float *v);
static float	vdot(const float *v1, const float *v2);
static void		vadd(const float *src1, const float *src2, float *dst);


BOOL VirtualTrackball::Init(HWND hWnd, int w, int h)
{
	hWndCapture	= hWnd;
	nWidth		= w;
	nHeight		= h;

	// Initialize to the initial display angle
	CalcQuat(curquat, 0.0f, 0.0f, 0.0f, 0.8f);
	// Initial spin
	CalcQuat(lastquat, 0.0f, 0.0f, 0.0f, 0.0f);

	return TRUE;
}

BOOL VirtualTrackball::Resize(int w, int h)
{
	nWidth	= w;
	nHeight	= h;

	return TRUE;
}

BOOL VirtualTrackball::OnLMouseDown(short x, short y)
{
	nMouseDownX	= x;
	nMouseDownY	= y;
	bButtonDown = TRUE;

	nMousePosX	= x;
	nMousePosY	= y;
	return TRUE;
}

BOOL VirtualTrackball::OnLMouseUp(short x, short y)
{
	bButtonDown = FALSE;
	nMousePosX	= x;
	nMousePosY	= y;

	return TRUE;
}

BOOL VirtualTrackball::OnMMouseDown(short x, short y)
{
	return FALSE;
}

BOOL VirtualTrackball::OnMMouseUp(short x, short y)
{
	return FALSE;
}

BOOL VirtualTrackball::OnRMouseDown(short x, short y)
{
	return FALSE;
}

BOOL VirtualTrackball::OnRMouseUp(short x, short y)
{
	return FALSE;
}

BOOL VirtualTrackball::OnMouseMove(DWORD keyFlags, short x, short y)
{
	BOOL	bRetval = FALSE;

	if (keyFlags & MK_LBUTTON) {
		nMousePosX	= x;
		nMousePosY	= y;
		bRetval = TRUE;
	}

	return bRetval;
}

BOOL VirtualTrackball::HasMotion()
{
	return bSpinning;
}




VirtualTrackball::VirtualTrackball()
{
	bButtonDown = FALSE;
	bSpinning = FALSE;
	bCanSpin = TRUE;
	bDamping = TRUE;
}


// Call to retrieve current matrix
void VirtualTrackball::CalcRotMatrix(float matRot[4][4])
{
	static bCallAfterMouseUp = FALSE;
    if (bButtonDown || bCallAfterMouseUp)
    {
		bCallAfterMouseUp = TRUE;
		// If mouse has moved since button was pressed, change quaternion.
        if (nMousePosX != nMouseDownX || nMousePosY != nMouseDownY)
        {
			// Negate all params for proper operation with glTranslate(-z)
            CalcQuat(lastquat,
                      -(2.0f * ( nWidth - nMouseDownX ) / nWidth - 1.0f),
                      -(2.0f * nMouseDownY / nHeight - 1.0f),
                      -(2.0f * ( nWidth - nMousePosX ) / nWidth - 1.0f),
                      -(2.0f * nMousePosY / nHeight - 1.0f)
                     );

            bSpinning = TRUE;
        }
        else
            bSpinning = FALSE;

        nMouseDownX = nMousePosX;
        nMouseDownY = nMousePosY;
    }

	if (!bButtonDown) {
		bCallAfterMouseUp = FALSE;
		}

    if ((bCanSpin || bButtonDown) && bSpinning) {
        AddQuats(lastquat, curquat, curquat);
	}

	// Damp the value
	if (bSpinning && !bButtonDown && IsDamping()) {
		CalcQuat(lastquat,
			lastCalcVal[0] - lastCalcVal[0]/50.0f,
			lastCalcVal[1] - lastCalcVal[1]/50.0f,
			lastCalcVal[2] - lastCalcVal[2]/50.0f,
			lastCalcVal[3] - lastCalcVal[3]/50.0f
         );

		// Stop spinning when rotation is near 0
		if (lastCalcVal[0] < 0.0002f &&
			lastCalcVal[1] < 0.0002f &&
			lastCalcVal[2] < 0.0002f &&
			lastCalcVal[3] < 0.0002f) {
			bSpinning = FALSE;
		}
	}

    BuildRotmatrix(matRot, curquat);
}

void VirtualTrackball::SetCanSpin(BOOL bSpin)
{
	bCanSpin = bSpin;
}

BOOL VirtualTrackball::GetCanSpin()
{
	return bCanSpin;
}

BOOL VirtualTrackball::IsDamping()
{
	return bDamping;
}

void VirtualTrackball::SetDamping(BOOL bDamp)
{
	bDamping = bDamp;
}

/*
 * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet
 * if we are away from the center of the sphere.
 */
float ProjectToSphere(float r, float x, float y)
{
    float d, t, z;

    d = (float) sqrt(x*x + y*y);
    if (d < r * 0.70710678118654752440f) {    /* Inside sphere */
		z = (float) sqrt(r*r - d*d);
    } else {           /* On hyperbola */
        t = r / 1.41421356237309504880f;
        z = t*t / d;
    }
    return z;
}

/*
 *  Given an axis and angle, compute quaternion.
 */
void AxisToQuat(float a[3], float phi, float q[4])
{
    vnormal(a);
    vcopy(a,q);
    vscale(q,(float) sin(phi/2.0f));
    q[3] = (float) cos(phi/2.0f);
}

/*
 * Ok, simulate a track-ball.  Project the points onto the virtual
 * trackball, then figure out the axis of rotation, which is the cross
 * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0)
 * Note:  This is a deformed trackball-- is a trackball in the center,
 * but is deformed into a hyperbolic sheet of rotation away from the
 * center.  This particular function was chosen after trying out
 * several variations.
 * 
 * It is assumed that the arguments to this routine are in the range
 * (-1.0 ... 1.0)
 */
void VirtualTrackball::CalcQuat(float q[4], float p1x, float p1y, float p2x, float p2y)
{
    float a[3]; /* Axis of rotation */
    float phi;  /* how much to rotate about axis */
    float p1[3], p2[3], d[3];
    float t;

	/*
	char tbuf[255];
	sprintf(tbuf, "%f %f %f %f", p1x, p1y, p2x, p2y);
	SetWindowText(hWndCapture, tbuf);
	*/

	lastCalcVal[0] = p1x;
	lastCalcVal[1] = p1y;
	lastCalcVal[2] = p2x;
	lastCalcVal[3] = p2y;

    if (p1x == p2x && p1y == p2y) {
	/* Zero rotation */
        vzero(q); 
	q[3] = 1.0f; 
        return;
    }

    /*
     * First, figure out z-coordinates for projection of P1 and P2 to
     * deformed sphere
     */
    vset(p1,p1x,p1y,ProjectToSphere(TRACKBALLSIZE,p1x,p1y));
    vset(p2,p2x,p2y,ProjectToSphere(TRACKBALLSIZE,p2x,p2y));

    /*
     *  Now, we want the cross product of P1 and P2
     */
    vcross(p2,p1,a);

    /*
     *  Figure out how much to rotate around that axis.
     */
    vsub(p1,p2,d);
    t = vlength(d) / (2.0f*TRACKBALLSIZE);

    /*
     * Avoid problems with out-of-control values...
     */
    if (t > 1.0f) t = 1.0f;
    if (t < -1.0f) t = -1.0f;
    phi = 2.0f * (float) asin(t);

    AxisToQuat(a,phi,q);
}


/*
 * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0
 * If they don't add up to 1.0, dividing by their magnitued will
 * renormalize them.
 *
 * Note: See the following for more information on quaternions:
 * 
 * - Shoemake, K., Animating rotation with quaternion curves, Computer
 *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985.
 * - Pletinckx, D., Quaternion calculus as a basic tool in computer
 *   graphics, The Visual Computer 5, 2-13, 1989.
 */
void NormalizeQuat(float q[4])
{
    int i;
    float mag;

    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
    for (i = 0; i < 4; i++) q[i] /= mag;
}

/*
 * Given two rotations, e1 and e2, expressed as quaternion rotations,
 * figure out the equivalent single rotation and stuff it into dest.
 * 
 * This routine also normalizes the result every RENORMCOUNT times it is
 * called, to keep error from creeping in.
 *
 * NOTE: This routine is written so that q1 or q2 may be the same
 * as dest (or each other).
 */

#define RENORMCOUNT 97

void AddQuats(float q1[4], float q2[4], float dest[4])
{
    static int count=0;
    float t1[4], t2[4], t3[4];
    float tf[4];

    vcopy(q1,t1); 
    vscale(t1,q2[3]);

    vcopy(q2,t2); 
    vscale(t2,q1[3]);

    vcross(q2,q1,t3);
    vadd(t1,t2,tf);
    vadd(t3,tf,tf);
    tf[3] = q1[3] * q2[3] - vdot(q1,q2);

    dest[0] = tf[0];
    dest[1] = tf[1];
    dest[2] = tf[2];
    dest[3] = tf[3];

    if (++count > RENORMCOUNT) {
        count = 0;
        NormalizeQuat(dest);
    }
}

/*
 * Build a rotation matrix, given a quaternion rotation.
 *
 */
void BuildRotmatrix(float m[4][4], float q[4])
{
    m[0][0] = 1.0f - 2.0f * (q[1] * q[1] + q[2] * q[2]);
    m[0][1] = 2.0f * (q[0] * q[1] - q[2] * q[3]);
    m[0][2] = 2.0f * (q[2] * q[0] + q[1] * q[3]);
    m[0][3] = 0.0f;

    m[1][0] = 2.0f * (q[0] * q[1] + q[2] * q[3]);
    m[1][1]= 1.0f - 2.0f * (q[2] * q[2] + q[0] * q[0]);
    m[1][2] = 2.0f * (q[1] * q[2] - q[0] * q[3]);
    m[1][3] = 0.0f;

    m[2][0] = 2.0f * (q[2] * q[0] - q[1] * q[3]);
    m[2][1] = 2.0f * (q[1] * q[2] + q[0] * q[3]);
    m[2][2] = 1.0f - 2.0f * (q[1] * q[1] + q[0] * q[0]);
    m[2][3] = 0.0f;

    m[3][0] = 0.0f;
    m[3][1] = 0.0f;
    m[3][2] = 0.0f;
    m[3][3] = 1.0f;
}



// Support code

void vzero(float *v)
{
    v[0] = 0.0f;
    v[1] = 0.0f;
    v[2] = 0.0f;
}

void vset(float *v, float x, float y, float z)
{
    v[0] = x;
    v[1] = y;
    v[2] = z;
}

void vsub(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] - src2[0];
    dst[1] = src1[1] - src2[1];
    dst[2] = src1[2] - src2[2];
}

void vcopy(const float *v1, float *v2)
{
    register int i;
    for (i = 0 ; i < 3 ; i++)
        v2[i] = v1[i];
}

void vcross(const float *v1, const float *v2, float *cross)
{
    float temp[3];

    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    vcopy(temp, cross);
}

float vlength(const float *v)
{
    return (float) sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

void vscale(float *v, float div)
{
    v[0] *= div;
    v[1] *= div;
    v[2] *= div;
}

void vnormal(float *v)
{
    vscale(v,1.0f/vlength(v));
}

float vdot(const float *v1, const float *v2)
{
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

void vadd(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\afregion.cpp ===
/**********************************************************************
 *<
	FILE: afregion.cpp

	DESCRIPTION:  Affect region modifier

	CREATED BY: Rolf Berteig

	HISTORY: 10/16/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"

#define PBLOCK_REF	0
#define POINT1_REF	1
#define POINT2_REF	2

class AFRMod : public Modifier {	
	public:
		IParamBlock *pblock;
		Control *p1, *p2;
		BYTE sel[2];

		static IObjParam *ip;
		static IParamMap *pmapParam;
		static AFRMod *editMod;
		static MoveModBoxCMode *moveMode;
		
		AFRMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_AFRMOD);}  
		virtual Class_ID ClassID() { return Class_ID(AFFECTREGION_CLASS_ID,0);}		
		void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_AFRMOD);}
		int SubNumToRefNum(int subNum);
		BOOL AssignController(Animatable *control,int subAnim);

		// From modifier
		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE;}
		ChannelMask ChannelsChanged() {return PART_GEOM;}
		Class_ID InputType() {return defObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);		
		void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void ActivateSubobjSel(int level, XFormModes& modes);
		void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert=FALSE);
		void ClearSelection(int selLevel);
		void SelectAll(int selLevel);
		void InvertSelection(int selLevel);

		int NumRefs() {return 3;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		int NumSubs() {return 3;}
		Animatable* SubAnim(int i) {return GetReference(i);}
		TSTR SubAnimName(int i);

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		Matrix3 CompMatrix(TimeValue t,INode *inode,ModContext *mc);
	};


class AFRDeformer : public Deformer {
	public:		
		float falloff, pinch, bubble;
		Point3 p1, p2;
		Tab<Point3> *normals;
		AFRDeformer(
			ModContext &mc, float f, float p, float b,
			Point3 pt1, Point3 pt2, Tab<Point3> *n=NULL);
		Point3 Map(int i, Point3 p);
	};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap       *AFRMod::pmapParam = NULL;
IObjParam       *AFRMod::ip        = NULL;
AFRMod          *AFRMod::editMod   = NULL;
MoveModBoxCMode *AFRMod::moveMode  = NULL;
		

class AFRClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new AFRMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_AFRMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(AFFECTREGION_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static AFRClassDesc afrDesc;
extern ClassDesc* GetAFRModDesc() {return &afrDesc;}


//--- Parameter map/block descriptors -------------------------------

#define PB_FALLOFF		0
#define PB_BACKFACE		1
#define PB_PINCH		2
#define PB_BUBBLE		3

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Falloff
	ParamUIDesc(
		PB_FALLOFF,
		EDITTYPE_FLOAT,
		IDC_AFR_FALLOFF,IDC_AFR_FALLOFFSPIN,
		0.0f,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Backface
	ParamUIDesc(PB_BACKFACE,TYPE_SINGLECHEKBOX,IDC_AFR_BACKFACE),

	// Pinch
	ParamUIDesc(
		PB_PINCH,
		EDITTYPE_FLOAT,
		IDC_AFR_PINCH,IDC_AFR_PINCHSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Bubble
	ParamUIDesc(
		PB_BUBBLE,
		EDITTYPE_FLOAT,
		IDC_AFR_BUBBLE,IDC_AFR_BUBBLESPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	};
#define PARAMDESC_LENGTH	4

static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE,  0 },		// Falloff	
	{ TYPE_INT,   NULL, FALSE, 1 },		// Backface
	{ TYPE_FLOAT, NULL, TRUE,  2 },		// Pinch
	{ TYPE_FLOAT, NULL, TRUE,  3 },		// Bubble
	};
#define PBLOCK_LENGTH	4

#define CURRENT_VERSION	0



//--- Affect region mod methods -------------------------------

AFRMod::AFRMod() 
	{
	MakeRefByID(
		FOREVER, PBLOCK_REF, 
		CreateParameterBlock(
			descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	
	p1 = p2 = NULL;
	MakeRefByID(FOREVER,POINT1_REF,NewDefaultPoint3Controller()); 
	MakeRefByID(FOREVER,POINT2_REF,NewDefaultPoint3Controller());
	sel[0] = sel[1] = 0;
	pblock->SetValue(PB_FALLOFF,0,20.0f);
	Point3 pt(0,0,25);
	p2->SetValue(0,&pt);
	}

void AFRMod::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editMod  = this;

	// Add our sub object type
	TSTR type1(GetString(IDS_RB_AFRPOINTS));
	const TCHAR *ptype[] = {type1};
	ip->RegisterSubObjectTypes(ptype, 1);

	// Create sub object editing modes.
	moveMode    = new MoveModBoxCMode(this,ip);
	
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGTH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_AFRPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	}

void AFRMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);

	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->DeleteMode(moveMode);	
	if (moveMode) delete moveMode;
	moveMode = NULL;	

	DestroyCPParamMap(pmapParam);
	}

RefTargetHandle AFRMod::Clone(RemapDir& remap)
	{
	AFRMod *mod = new AFRMod();
	mod->ReplaceReference(PBLOCK_REF,pblock->Clone(remap));
	mod->ReplaceReference(POINT1_REF,p1->Clone(remap));
	mod->ReplaceReference(POINT2_REF,p2->Clone(remap));
	return mod;
	}


void AFRMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{	
	Interval iv = FOREVER;
	float f, p, b;
	int backface;
	Point3 pt1, pt2;
	pblock->GetValue(PB_FALLOFF,t,f,iv);
	pblock->GetValue(PB_PINCH,t,p,iv);
	pblock->GetValue(PB_BUBBLE,t,b,iv);
	pblock->GetValue(PB_BACKFACE,t,backface,iv);
	p1->GetValue(t,&pt1,iv,CTRL_ABSOLUTE);
	p2->GetValue(t,&pt2,iv,CTRL_ABSOLUTE);
	if (f==0.0) {
		os->obj->UpdateValidity(GEOM_CHAN_NUM,iv);	
		return;
		}	
	if (backface && os->obj->IsSubClassOf(triObjectClassID)) {
		TriObject *tobj = (TriObject*)os->obj;
		Mesh &mesh = tobj->GetMesh();
		Tab<Point3> normals;
		normals.SetCount(mesh.getNumVerts());
		for (int i=0; i<mesh.getNumVerts(); i++) {
			normals[i] = Point3(0,0,0);
			}
		for (i=0; i<mesh.getNumFaces(); i++) {
			Point3 norm = 
				(mesh.verts[mesh.faces[i].v[1]]-mesh.verts[mesh.faces[i].v[0]]) ^
				(mesh.verts[mesh.faces[i].v[2]]-mesh.verts[mesh.faces[i].v[1]]);
			for (int j=0; j<3; j++) {				
				normals[mesh.faces[i].v[j]] += norm;
				}
			}
		AFRDeformer deformer(mc,f,p,b,pt1,pt2,&normals);
		os->obj->Deform(&deformer, TRUE);
	} else {
		AFRDeformer deformer(mc,f,p,b,pt1,pt2);
		os->obj->Deform(&deformer, TRUE);
		}	
	os->obj->UpdateValidity(GEOM_CHAN_NUM,iv);	
	}

Interval AFRMod::LocalValidity(TimeValue t)
	{
	Interval iv = FOREVER;
	float v;
	Point3 pt;
	pblock->GetValue(PB_FALLOFF,t,v,iv);
	pblock->GetValue(PB_PINCH,t,v,iv);
	pblock->GetValue(PB_BUBBLE,t,v,iv);
	p1->GetValue(t,&pt,iv,CTRL_ABSOLUTE);
	p2->GetValue(t,&pt,iv,CTRL_ABSOLUTE);
	return iv;
	}


Matrix3 AFRMod::CompMatrix(TimeValue t,INode *inode,ModContext *mc)
	{
	Interval iv;
	Matrix3 tm(1);	
	if (mc && mc->tm) tm = Inverse(*(mc->tm));
	if (inode) tm = tm * inode->GetObjTMBeforeWSM(t,&iv);
	return tm;
	}

int AFRMod::HitTest(
		TimeValue t, INode* inode, 
		int type, int crossing, int flags, 
		IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{
	GraphicsWindow *gw = vpt->getGW();
	Point3 pt;
	HitRegion hr;
	int savedLimits, res = 0;
	Matrix3 tm = CompMatrix(t,inode,mc);

	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);	
	gw->setTransform(tm);

	// Hit test start point
	if ((flags&HIT_SELONLY   &&  sel[0]) ||
		(flags&HIT_UNSELONLY && !sel[0]) ||
		!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) {
	
		gw->clearHitCode();
		p1->GetValue(t,&pt,FOREVER,CTRL_ABSOLUTE);
		gw->marker(&pt,HOLLOW_BOX_MRKR);
		if (gw->checkHitCode()) {
			vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
			res = 1;
			}
		}

	// Hit test end point
	if ((flags&HIT_SELONLY   &&  sel[1]) ||
		(flags&HIT_UNSELONLY && !sel[1]) ||
		!(flags&(HIT_UNSELONLY|HIT_SELONLY)) ) {
	
		gw->clearHitCode();
		p2->GetValue(t,&pt,FOREVER,CTRL_ABSOLUTE);
		gw->marker(&pt,HOLLOW_BOX_MRKR);
		if (gw->checkHitCode()) {
			vpt->LogHit(inode, mc, gw->getHitDistance(), 1, NULL); 
			res = 1;
			}
		}

	gw->setRndLimits(savedLimits);
	return res;
	}

int AFRMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flagst, ModContext *mc)
	{
	GraphicsWindow *gw = vpt->getGW();
	Point3 pt[4];
	Matrix3 tm = CompMatrix(t,inode,mc);
	int savedLimits;

	gw->setRndLimits((savedLimits = gw->getRndLimits()) & ~GW_ILLUM);
	gw->setTransform(tm);
	
	// Draw start point
	if (ip && ip->GetSubObjectLevel() == 1) {
		if (sel[0]) 
			 gw->setColor(LINE_COLOR, (float)1.0, (float)0.0, (float)0.0);			 
		else //gw->setColor(LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
			 gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}	
	p1->GetValue(t,&pt[0],FOREVER,CTRL_ABSOLUTE);
	gw->marker(&pt[0],HOLLOW_BOX_MRKR);

	// Draw end point
	if (ip && ip->GetSubObjectLevel() == 1) {
		if (sel[1]) 
			 gw->setColor(LINE_COLOR, (float)1.0, (float)0.0, (float)0.0);
		else //gw->setColor(LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
			   gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}	
	p2->GetValue(t,&pt[1],FOREVER,CTRL_ABSOLUTE);
	gw->marker(&pt[1],HOLLOW_BOX_MRKR);

	// Draw a line inbetween
	if (ip && ip->GetSubObjectLevel() == 1) {
		//gw->setColor(LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor(LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}
	gw->polyline(2, pt, NULL, NULL, 0, NULL);
	
	// Draw arrowhead
	Matrix3 vtm;
	vpt->GetAffineTM(vtm);
	Point3 vz = vtm.GetRow(2) * Inverse(tm);
	Point3 dp = (pt[1]-pt[0]);
	Point3 v = Normalize(vz^dp) * Length(dp) * 0.2f;
	pt[0] = pt[1] - (0.2f*dp) + v;
	pt[2] = pt[1] - (0.2f*dp) - v;
	gw->polyline(3, pt, NULL, NULL, 0, NULL);
	v = Normalize(v^dp) * Length(dp) * 0.2f;
	pt[0] = pt[1] - (0.2f*dp) + v;
	pt[2] = pt[1] - (0.2f*dp) - v;
	gw->polyline(3, pt, NULL, NULL, 0, NULL);

	gw->setRndLimits(savedLimits);
	return 0;
	}

void AFRMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, 
		Box3& box, ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,inode,mc);
	Point3 pt1, pt2;
	box.Init();
	p1->GetValue(t,&pt1,FOREVER,CTRL_ABSOLUTE);
	box += pt1 * tm;
	p2->GetValue(t,&pt2,FOREVER,CTRL_ABSOLUTE);
	box += pt2 * tm;
	
	Matrix3 vtm;
	vpt->GetAffineTM(vtm);
	Point3 vz = vtm.GetRow(2) * Inverse(tm);
	Point3 dp = (pt2-pt1);
	Point3 v = Normalize(vz^dp) * Length(dp) * 0.2f;
	box += (pt2 - (0.2f*dp) + v) * tm;
	box += (pt2 - (0.2f*dp) - v) * tm;
	v = Normalize(v^dp) * Length(dp) * 0.2f;
	box += (pt2 - (0.2f*dp) + v) * tm;
	box += (pt2 - (0.2f*dp) - v) * tm;	
	}

void AFRMod::Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin)
	{
	if (sel[0]) {
		p1->SetValue(
			t,VectorTransform(tmAxis*Inverse(partm),val),
			TRUE,CTRL_RELATIVE);
		}
	if (sel[1]) {
		p2->SetValue(
			t,VectorTransform(tmAxis*Inverse(partm),val),
			TRUE,CTRL_RELATIVE);
		}
	}

void AFRMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,node,mc);
	Point3 pt(0,0,0), p;
	int c=0;
	if (sel[0]) {
		p1->GetValue(t,&p,FOREVER,CTRL_ABSOLUTE);
		pt += p;
		c++;
		}
	if (sel[1]) {
		p2->GetValue(t,&p,FOREVER,CTRL_ABSOLUTE);
		pt += p;
		c++;
		}
	if (c) pt /= float(c);
	tm.PreTranslate(pt);
	cb->Center(tm.GetTrans(),0);
	}

void AFRMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,
		INode *node,ModContext *mc)
	{
	Matrix3 tm = CompMatrix(t,node,mc);
	cb->TM(tm,0);
	}


void AFRMod::SelectSubComponent(
		HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert)
	{
	//if (theHold.Holding()) theHold.Put(new SelRestore(this));
	while (hitRec) {
		assert(hitRec->hitInfo<=1);
		BOOL state = selected;
		if (invert) state = !sel[hitRec->hitInfo];
		if (state) sel[hitRec->hitInfo] = 1;
		else       sel[hitRec->hitInfo] = 0;
		if (!all) break;
		hitRec = hitRec->Next();
		}	
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void AFRMod::ClearSelection(int selLevel)
	{
	//if (theHold.Holding()) theHold.Put(new SelRestore(this));
	sel[0] = sel[1] = 0;
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void AFRMod::SelectAll(int selLevel)
	{
	//if (theHold.Holding()) theHold.Put(new SelRestore(this));
	sel[0] = sel[1] = 1;
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void AFRMod::InvertSelection(int selLevel)
	{
	//if (theHold.Holding()) theHold.Put(new SelRestore(this));
	sel[0] = !sel[0];
	sel[1] = !sel[1];
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void AFRMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
	switch (level) {
		case 1: // Points
			modes = XFormModes(moveMode,NULL,NULL,NULL,NULL,NULL);
			break;		
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}

BOOL AFRMod::AssignController(Animatable *control,int subAnim)
	{
	ReplaceReference(subAnim,(Control*)control);
	NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
	NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	return TRUE;
	}

int AFRMod::SubNumToRefNum(int subNum)
	{
	switch (subNum) {
		case POINT1_REF: return POINT1_REF;
		case POINT2_REF: return POINT2_REF;		
		}
	return -1;
	}

RefTargetHandle AFRMod::GetReference(int i)
	{
	switch (i) {
		case PBLOCK_REF: return pblock;
		case POINT1_REF: return p1;
		case POINT2_REF: return p2;
		default: return NULL;
		}
	}

void AFRMod::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case PBLOCK_REF: pblock = (IParamBlock*)rtarg; break;
		case POINT1_REF: p1     = (Control*)rtarg; break;
		case POINT2_REF: p2     = (Control*)rtarg; break;
		}
	}

TSTR AFRMod::SubAnimName(int i)
	{
	switch (i) {
		case POINT1_REF: return GetString(IDS_RB_STARTPOINT); break;
		case POINT2_REF: return GetString(IDS_RB_ENDPOINT); break;
		default: return _T(""); break;
		}
	}

RefResult AFRMod::NotifyRefChanged(
		Interval changeInt,RefTargetHandle hTarget, 
		PartID& partID, RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this && pmapParam) pmapParam->Invalidate();
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_FALLOFF: gpd->dim = stdWorldDim; break;
				case PB_PINCH:   
				case PB_BUBBLE:	 gpd->dim = stdNormalizedDim; break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;			
			switch (gpn->index) {
				case PB_FALLOFF: gpn->name = GetString(IDS_AFR_FALLOFF); break;
				case PB_PINCH:   gpn->name = GetString(IDS_AFR_PINCH); break;
				case PB_BUBBLE:	 gpn->name = GetString(IDS_AFR_BUBBLE); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}

AFRDeformer::AFRDeformer(
		ModContext &mc, float f, float p, float b,
		Point3 pt1, Point3 pt2, Tab<Point3> *n)
	{
	Matrix3 tm, itm;
	if (mc.tm) tm = *mc.tm;
	else tm.IdentityMatrix();
	itm     = Inverse(tm);	
	falloff = f;
	pinch   = p;
	bubble  = b;
	pt1 = pt1 * itm;
	pt2 = pt2 * itm;
	p1      = pt1;
	p2      = pt2-p1;
	normals = n;
	}

Point3 AFRDeformer::Map(int i, Point3 p)
	{
	float dist = Length(p-p1), d;
	if (dist>falloff) return p;
	if (normals) {		
		d = DotProd(p2,(*normals)[i]);
		if (d<0.0) return p;
		}
	float u = ((falloff - dist)/falloff);	
	float u2 = u*u, s = 1.0f-u;	
	return p + p2 * ((3*u*bubble*s + 3*u2*(1.0f-pinch))*s + u*u2);	
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\MaxFind\vtrackbl.h ===
/****************************************************************************
 MAX File Finder
 Christer Janson
 September 20, 1998
 VTrackBl.h - Header for Virtual TrackBall
 Guts of the Virtual Trackball has been stolen from Microsoft Sample Code
 ***************************************************************************/

#ifndef __VTRACKBL_H__
#define __VTRACKBL_H__

#include "cmdmode.h"

class VirtualTrackball : public ICommandMode {
public:
	VirtualTrackball();

	virtual BOOL	Init(HWND hWnd, int nWidth, int nHeight);
	virtual BOOL	Resize(int nWidth, int nHeight);
	virtual BOOL	OnLMouseDown(short x, short y);
	virtual BOOL	OnLMouseUp(short x, short y);
	virtual BOOL	OnMMouseDown(short x, short y);
	virtual BOOL	OnMMouseUp(short x, short y);
	virtual BOOL	OnRMouseDown(short x, short y);
	virtual BOOL	OnRMouseUp(short x, short y);
	virtual BOOL	OnMouseMove(DWORD keyFlags, short x, short y);
	virtual BOOL	HasMotion();


	// Call to retrieve current matrix
	void	CalcRotMatrix(float matRot[4][4]);

	void	SetCanSpin(BOOL bSpin);
	BOOL	GetCanSpin();
	BOOL	IsDamping();
	void	SetDamping(BOOL bDamp);

private:
	void	CalcQuat(float q[4], float p1x, float p1y, float p2x, float p2y);

private:
	HWND	hWndCapture;
	int		nWidth;
	int		nHeight;

	int		nMouseDownX;
	int		nMouseDownY;
	int		nMousePosX;
	int		nMousePosY;
	BOOL	bButtonDown;
	BOOL	bSpinning;
	BOOL	bCanSpin;
	BOOL	bDamping;

	float	curquat[4];
	float	lastquat[4];

	float	lastCalcVal[4];
};

/*
 * This size should really be based on the distance from the center of
 * rotation to the point on the object underneath the mouse.  That
 * point would then track the mouse as closely as possible.  This is a
 * simple example, though, so that is left as an Exercise for the
 * Programmer.
 */
#define TRACKBALLSIZE  (0.8f)

#endif __VTRACKBL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\bomb.cpp ===
/**********************************************************************
 *<
	FILE: bomb.cpp

	DESCRIPTION:  A bomb space warp

	CREATED BY: Rolf Berteig

	HISTORY: created 27 July, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"


static int waitPostLoad = 0;

// in mods.cpp
extern HINSTANCE hInstance;

#define PB_STRENGTH		0
#define PB_GRAVITY		1
#define PB_CHAOS		2
#define PB_DETONATION	3
#define PB_SPIN			4
#define PB_FALLOFF		5
#define PB_FALLOFFON	6
#define PB_MINFRAG		7
#define PB_MAXFRAG		8
#define PB_SEED			9


#define OB_REF 		0
#define NODE_REF 	1

inline float Rand1() {return float(rand())/float(RAND_MAX);}

static BOOL CALLBACK BombParamProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);	
static void DrawFalloffSphere(float radius, PolyLineProc& lp);

class BombObject: public WSMObject {
	public:	
		IParamBlock *pblock;		
		Mesh mesh;
		
		static HWND hParam, hSot;
		static IObjParam *ip;
		static ISpinnerControl *strengthSpin;	
		static ISpinnerControl *gravSpin;
		static ISpinnerControl *detSpin;
		static ISpinnerControl *chaosSpin;
		static ISpinnerControl *spinSpin;
		static ISpinnerControl *falloffSpin;
		static ISpinnerControl *minFragSpin;
		static ISpinnerControl *maxFragSpin;
		static ISpinnerControl *seedSpin;

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

		void UpdateUI(TimeValue t);				
		void BuildMesh(TimeValue t,Mesh &mesh);

	public:
		BombObject();
		~BombObject();

		void SetStrength(TimeValue t, float f);
		void SetGravity(TimeValue t, float f);
		void SetChaos(TimeValue t, float f);
		void SetDetonation(TimeValue t,TimeValue det);
		void SetSpin(TimeValue t, float f);
		void SetFalloff(TimeValue t, float f);
		void SetFalloffOn(TimeValue t,int onOff);
		void SetMinFrag(TimeValue t,int m);
		void SetMaxFrag(TimeValue t,int m);
		void SetSeed(TimeValue t,int m);

		float GetStrength(TimeValue t, Interval& valid = Interval(0,0));
		float GetGravity(TimeValue t, Interval& valid = Interval(0,0));
		float GetChaos(TimeValue t, Interval& valid = Interval(0,0));
		TimeValue GetDetonation(TimeValue t, Interval& valid = Interval(0,0));	
		float GetSpin(TimeValue t, Interval& valid = Interval(0,0));
		float GetFalloff(TimeValue t, Interval& valid = Interval(0,0));
		int GetFalloffOn(TimeValue t, Interval& valid = Interval(0,0));
		int GetMinFrag(TimeValue t, Interval& valid = Interval(0,0));
		int GetMaxFrag(TimeValue t, Interval& valid = Interval(0,0));
		int GetSeed(TimeValue t, Interval& valid = Interval(0,0));

		//  inherited virtual methods:

		// From Animatable
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_BOMBOBJECT_CLASS); }  
		Class_ID ClassID() { return Class_ID(BOMB_OBJECT_CLASS_ID,0); }  		
		void DeleteThis() {delete this;}
		void MapKeys(TimeMap *map,DWORD flags);

		// From ref
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return pblock;}
		void SetReference(int i, RefTargetHandle rtarg) {pblock=(IParamBlock*)rtarg;}		
		IOResult Load(ILoad *iload);

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		void GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box );
		TCHAR *GetObjectName() { return GetString(IDS_RB_BOMB);}
		
		// from object
		int IsRenderable() { return FALSE; }
		int DoOwnSelectHilite() { return TRUE; }
		ObjectHandle ApplyTransform(Matrix3& matrix) { return this; }
		Interval ObjectValidity(TimeValue time);
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) {s = GetString(IDS_RB_BOMB);}

		// From WSMObject
		Modifier *CreateWSMMod(INode *node);

		
		// from Animatable
		int NumSubs() { return 1; }  
		Animatable* SubAnim(int i) { return pblock; }
		TSTR SubAnimName(int i) { return TSTR(GetString(IDS_RB_PARAMETERS));}
	};

HWND BombObject::hParam             		= NULL;
HWND BombObject::hSot             		    = NULL;
IObjParam *BombObject::ip       			= NULL;
ISpinnerControl* BombObject::strengthSpin   = NULL;
ISpinnerControl* BombObject::gravSpin   	= NULL;
ISpinnerControl* BombObject::detSpin  		= NULL;
ISpinnerControl* BombObject::chaosSpin  	= NULL;
ISpinnerControl* BombObject::spinSpin  		= NULL;
ISpinnerControl* BombObject::falloffSpin  	= NULL;
ISpinnerControl* BombObject::minFragSpin  	= NULL;
ISpinnerControl* BombObject::maxFragSpin  	= NULL;
ISpinnerControl* BombObject::seedSpin   	= NULL;

class BombClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new BombObject; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_BOMB_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(BOMB_OBJECT_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF);  }
	};

static BombClassDesc bombDesc;
ClassDesc* GetBombObjDesc() { return &bombDesc; }


class BombMod : public Modifier {
	
	private:
		BombObject  *obRef;
		INode       *nodeRef;		

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );	

	public:
		BombMod();
		BombMod(INode *node,BombObject *obj);
		~BombMod();

		Interval LocalValidity(TimeValue t);
		ChannelMask ChannelsUsed()  { return PART_GEOM|PART_TOPO; }
		ChannelMask ChannelsChanged() { return PART_GEOM|PART_TOPO; }
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os,INode *node);
		Class_ID InputType() { return Class_ID(TRIOBJ_CLASS_ID,0); }

		//  inherited virtual methods:

		// From Animatable
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_BOMBMOD); }  
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }
		Class_ID ClassID() { return Class_ID(BOMB_CLASS_ID,0); } 
		void DeleteThis() {delete this;}
		
		// From ref
		int NumRefs() { return 2; }
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		// From BaseObject
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next );
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_RB_BOMBBINDING); }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}

		BombObject *GetWSMObject(TimeValue t);
	};

class BombModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new BombMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_BOMB_CLASS); }
	SClass_ID		SuperClassID() { return WSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(BOMB_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};

static BombModClassDesc bombModDesc;
ClassDesc* GetBombModDesc() { return &bombModDesc; }


static BOOL CALLBACK BombParamProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
	{
	BombObject *bo = (BombObject *)GetWindowLong(hWnd,GWL_USERDATA);
	if (!bo && message != WM_INITDIALOG) return FALSE;
	
	switch ( message ) {
		case WM_INITDIALOG:
			bo = (BombObject *)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,(LONG)bo);			
			
			bo->strengthSpin = GetISpinner(GetDlgItem(hWnd,IDC_STRENGTHSPIN));			
			bo->strengthSpin->SetLimits(-9999999, 9999999, FALSE);
			bo->strengthSpin->SetAutoScale();
			bo->strengthSpin->SetValue(bo->GetStrength(bo->ip->GetTime()),FALSE);
			bo->strengthSpin->LinkToEdit(GetDlgItem(hWnd,IDC_STRENGTH),EDITTYPE_FLOAT);
			
			bo->gravSpin = GetISpinner(GetDlgItem(hWnd,IDC_GRAVITYSPIN));			
			bo->gravSpin->SetLimits( -9999999, 9999999, FALSE);
			bo->gravSpin->SetScale(0.01f);
			bo->gravSpin->SetValue(bo->GetGravity(bo->ip->GetTime()),FALSE);
			bo->gravSpin->LinkToEdit(GetDlgItem(hWnd,IDC_GRAVITY),EDITTYPE_FLOAT);
			
			bo->detSpin = GetISpinner(GetDlgItem(hWnd,IDC_DETONATIONSPIN));
			bo->detSpin->SetLimits(-9999999,9999999,FALSE);
			bo->detSpin->SetScale(10.0f);
			bo->detSpin->SetValue(bo->GetDetonation(bo->ip->GetTime()), FALSE);
			bo->detSpin->LinkToEdit(GetDlgItem(hWnd,IDC_DETONATION),EDITTYPE_TIME);
			
			bo->chaosSpin = GetISpinner(GetDlgItem(hWnd,IDC_BOMB_CHAOSSPIN));
			bo->chaosSpin->SetLimits(0,10,FALSE);
			bo->chaosSpin->SetScale(0.01f);
			bo->chaosSpin->SetValue(bo->GetChaos(bo->ip->GetTime()), FALSE);
			bo->chaosSpin->LinkToEdit(GetDlgItem(hWnd,IDC_BOMB_CHAOS),EDITTYPE_FLOAT);

			bo->spinSpin = GetISpinner(GetDlgItem(hWnd,IDC_SPINSPIN));
			bo->spinSpin->SetLimits(0.0f,9999999.0f,FALSE);
			bo->spinSpin->SetScale(0.01f);			
			bo->spinSpin->LinkToEdit(GetDlgItem(hWnd,IDC_SPIN),EDITTYPE_FLOAT);
			bo->spinSpin->SetValue(bo->GetSpin(bo->ip->GetTime()), FALSE);

			bo->falloffSpin = GetISpinner(GetDlgItem(hWnd,IDC_FALLOFFSPIN));
			bo->falloffSpin->SetLimits(0.0f,9999999.0f,FALSE);
			bo->falloffSpin->SetAutoScale();
			bo->falloffSpin->LinkToEdit(GetDlgItem(hWnd,IDC_FALLOFF),EDITTYPE_UNIVERSE);
			bo->falloffSpin->SetValue(bo->GetFalloff(bo->ip->GetTime()), FALSE);

			bo->minFragSpin = GetISpinner(GetDlgItem(hWnd,IDC_MINFRAGSPIN));
			bo->minFragSpin->SetLimits(1,9999999,FALSE);
			bo->minFragSpin->SetScale(0.1f);
			bo->minFragSpin->LinkToEdit(GetDlgItem(hWnd,IDC_MINFRAG),EDITTYPE_INT);
			bo->minFragSpin->SetValue(bo->GetMinFrag(bo->ip->GetTime()), FALSE);
			
			bo->maxFragSpin = GetISpinner(GetDlgItem(hWnd,IDC_MAXFRAGSPIN));
			bo->maxFragSpin->SetLimits(1,9999999,FALSE);
			bo->maxFragSpin->SetScale(0.1f);
			bo->maxFragSpin->LinkToEdit(GetDlgItem(hWnd,IDC_MAXFRAG),EDITTYPE_INT);
			bo->maxFragSpin->SetValue(bo->GetMaxFrag(bo->ip->GetTime()), FALSE);

			bo->seedSpin = GetISpinner(GetDlgItem(hWnd,IDC_SEEDSPIN));
			bo->seedSpin->SetLimits(0,9999999,FALSE);
			bo->seedSpin->SetScale(0.1f);
			bo->seedSpin->LinkToEdit(GetDlgItem(hWnd,IDC_SEED),EDITTYPE_INT);
			bo->seedSpin->SetValue(bo->GetSeed(bo->ip->GetTime()), FALSE);

			CheckDlgButton(hWnd,IDC_FALLOFF_ON,bo->GetFalloffOn(bo->ip->GetTime()));
			return TRUE;

		case WM_DESTROY:
			ReleaseISpinner(bo->strengthSpin);
			ReleaseISpinner(bo->gravSpin);
			ReleaseISpinner(bo->detSpin);			
			ReleaseISpinner(bo->chaosSpin);
			ReleaseISpinner(bo->spinSpin);
			ReleaseISpinner(bo->falloffSpin);
			ReleaseISpinner(bo->minFragSpin);
			ReleaseISpinner(bo->maxFragSpin);
			ReleaseISpinner(bo->seedSpin);
			return FALSE;

		case CC_SPINNER_BUTTONDOWN:
			theHold.Begin();
			return TRUE;

		case CC_SPINNER_CHANGE:
			if (!theHold.Holding()) theHold.Begin();

			switch (LOWORD(wParam) ) {
				case IDC_STRENGTHSPIN:
					bo->SetStrength(bo->ip->GetTime(),bo->strengthSpin->GetFVal());						
					break;
				case IDC_GRAVITYSPIN:
					bo->SetGravity(bo->ip->GetTime(),bo->gravSpin->GetFVal());
					break;
				case IDC_DETONATIONSPIN:
					bo->SetDetonation(bo->ip->GetTime(),bo->detSpin->GetIVal());
					break;
				case IDC_BOMB_CHAOSSPIN:
					bo->SetChaos(bo->ip->GetTime(),bo->chaosSpin->GetFVal());
					break;

				case IDC_SPINSPIN:
					bo->SetSpin(bo->ip->GetTime(),bo->spinSpin->GetFVal());
					break;

				case IDC_FALLOFFSPIN:
					bo->SetFalloff(bo->ip->GetTime(),bo->falloffSpin->GetFVal());
					break;

				case IDC_MINFRAGSPIN:
					bo->SetMinFrag(bo->ip->GetTime(),bo->minFragSpin->GetIVal());
					break;

				case IDC_MAXFRAGSPIN:
					bo->SetMaxFrag(bo->ip->GetTime(),bo->maxFragSpin->GetIVal());
					break;

				case IDC_SEEDSPIN:
					bo->SetSeed(bo->ip->GetTime(),bo->seedSpin->GetIVal());
					break;

				}
			bo->ip->RedrawViews(bo->ip->GetTime(),REDRAW_INTERACTIVE);
			return TRUE;
		
		case WM_CUSTEDIT_ENTER:
		case CC_SPINNER_BUTTONUP:
			if (!HIWORD(wParam) && message!=WM_CUSTEDIT_ENTER) {
				theHold.Cancel();
			} else {
				theHold.Accept(GetString (IDS_PARAM_CHANGE));				
				}
			bo->ip->RedrawViews(bo->ip->GetTime(),REDRAW_END);
			return TRUE;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_FALLOFF_ON:
					bo->SetFalloffOn(bo->ip->GetTime(),IsDlgButtonChecked(hWnd,IDC_FALLOFF_ON));
					bo->ip->RedrawViews(bo->ip->GetTime(),REDRAW_END);
					break;
				}
			return TRUE;
		
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			bo->ip->RollupMouseMessage(hWnd,message,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	}


Modifier *BombObject::CreateWSMMod(INode *node)
	{
	return new BombMod(node,this);
	}


void BombObject::BeginEditParams(IObjParam *ip,ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	
	if (!hParam) {
		hSot = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_BOMB_SOT),
				DefaultSOTProc,
				GetString(IDS_RB_SOT), 
				(LPARAM)ip,APPENDROLL_CLOSED);

		hParam = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_BOMBPARAMS),
				BombParamProc,
				GetString(IDS_RB_BOMBPARAMS), 
				(LPARAM)this );
	} else {
		SetWindowLong(hParam, GWL_USERDATA, (LONG)this);		

		// Init the dialog to our values.
		strengthSpin->SetValue(GetStrength(ip->GetTime()),FALSE);
		gravSpin->SetValue(GetGravity(ip->GetTime()),FALSE );
		chaosSpin->SetValue(GetChaos(ip->GetTime()),FALSE );
		detSpin->SetValue(GetDetonation(ip->GetTime()),FALSE );
		spinSpin->SetValue(GetSpin(ip->GetTime()),FALSE);
		falloffSpin->SetValue(GetFalloff(ip->GetTime()),FALSE);
		minFragSpin->SetValue(GetMinFrag(ip->GetTime()),FALSE);
		maxFragSpin->SetValue(GetMaxFrag(ip->GetTime()),FALSE);
		seedSpin->SetValue(GetSeed(ip->GetTime()),FALSE);
		CheckDlgButton(hParam,IDC_FALLOFF_ON,GetFalloffOn(ip->GetTime()));
		}

	if (GetFalloffOn(ip->GetTime())) {
		NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime());
		}
	}

void BombObject::EndEditParams(IObjParam *ip,ULONG flags,Animatable *next)
	{
	if (flags&END_EDIT_REMOVEUI) {		
		ip->DeleteRollupPage(hParam);
		ip->DeleteRollupPage(hSot);
		hParam = NULL;
		hSot   = NULL;
	} else {		
		SetWindowLong(hParam, GWL_USERDATA, 0);		
		}
	
	if (GetFalloffOn(ip->GetTime())) {
		NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime());
		}
	this->ip = NULL;
	}


// The current version of bomb
#define BOMB_VERSION	2

// parameters for version 0
static ParamBlockDescID descV0[] = {
		{ TYPE_FLOAT, NULL, TRUE, 1 },
		{ TYPE_FLOAT, NULL, TRUE, 2 },
		{ TYPE_INT, NULL, FALSE, 3 }};

// parameters for version 1
static ParamBlockDescID descV1[] = {
		{ TYPE_FLOAT, NULL, TRUE, 1 },
		{ TYPE_FLOAT, NULL, TRUE, 2 },
		{ TYPE_FLOAT, NULL, TRUE, 4 },
		{ TYPE_INT, NULL, FALSE, 3 }};

// parameters for version 2
static ParamBlockDescID descV2[] = {
		{ TYPE_FLOAT, NULL, TRUE, 1 },
		{ TYPE_FLOAT, NULL, TRUE, 2 },
		{ TYPE_FLOAT, NULL, TRUE, 4 },
		{ TYPE_INT, NULL, FALSE, 3 },
		{ TYPE_FLOAT, NULL, TRUE, 5 }, // spin
		{ TYPE_FLOAT, NULL, TRUE, 6 }, // falloff
		{ TYPE_INT, NULL, FALSE, 7 },  // falloff on
		{ TYPE_INT, NULL, FALSE, 8 },  // min frag
		{ TYPE_INT, NULL, FALSE, 9 },  // max frag
		{ TYPE_INT, NULL, FALSE, 10 },  // seed
	};

		
BombObject::BombObject()
	{
	MakeRefByID(FOREVER,0,CreateParameterBlock(descV2,10,BOMB_VERSION));	
	pblock->SetValue(PB_STRENGTH, TimeValue(0), 1.0f);
	pblock->SetValue(PB_GRAVITY, TimeValue(0), 1.0f);
	pblock->SetValue(PB_DETONATION, TimeValue(0), 800); 
	pblock->SetValue(PB_MINFRAG, TimeValue(0), 1); 
	pblock->SetValue(PB_MAXFRAG, TimeValue(0), 1); 
	pblock->SetValue(PB_FALLOFF, TimeValue(0), 100.0f); 
	BuildMesh(TimeValue(0),mesh);
	mesh.EnableEdgeList(1);
	}


class BombPostLoad : public PostLoadCallback {
	public:
		BombObject *bo;
		BombPostLoad(BombObject *b) {bo=b;}
		void proc(ILoad *iload) {			
			if (bo->pblock->GetVersion()!=BOMB_VERSION) {
				switch (bo->pblock->GetVersion()) {
					case 0:
						bo->ReplaceReference(0,
							UpdateParameterBlock(
								descV0, 3, bo->pblock,
								descV1, 4, BOMB_VERSION));
						iload->SetObsolete();
						break;

					case 1:
						bo->ReplaceReference(0,
							UpdateParameterBlock(
								descV1, 4, bo->pblock,
								descV2, 10, BOMB_VERSION));
						iload->SetObsolete();
						break;

					default:
						assert(0);
						break;
					}
				}
			waitPostLoad--;
			delete this;
			}
	};

IOResult BombObject::Load(ILoad *iload) 
	{	
	waitPostLoad++;
	iload->RegisterPostLoadCallback(new BombPostLoad(this));
	return IO_OK;
	}



BombObject::~BombObject()
	{
	DeleteAllRefsFromMe();
	pblock = NULL;
	}


void BombObject::SetStrength(TimeValue t,float f)
	{
	pblock->SetValue(PB_STRENGTH, t, f);		
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void BombObject::SetGravity(TimeValue t, float f)
	{
	pblock->SetValue(PB_GRAVITY, t, f);		
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void BombObject::SetChaos(TimeValue t, float f)
	{
	pblock->SetValue(PB_CHAOS, t, f);		
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void BombObject::SetDetonation(TimeValue t,TimeValue det)
	{
	pblock->SetValue(PB_DETONATION, t, det);		
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
	}

void BombObject::SetSpin(TimeValue t, float f)
	{
	pblock->SetValue(PB_SPIN, t, f);	
	}

void BombObject::SetFalloff(TimeValue t, float f)
	{
	pblock->SetValue(PB_FALLOFF, t, f);
	}

void BombObject::SetFalloffOn(TimeValue t,int onOff)
	{
	pblock->SetValue(PB_FALLOFFON, t, onOff);
	}

void BombObject::SetMinFrag(TimeValue t,int m)
	{
	pblock->SetValue(PB_MINFRAG, t, m);
	}

void BombObject::SetMaxFrag(TimeValue t,int m)
	{
	pblock->SetValue(PB_MAXFRAG, t, m);
	}

void BombObject::SetSeed(TimeValue t,int m)
	{
	pblock->SetValue(PB_SEED, t, m);
	}

float BombObject::GetStrength(TimeValue t, Interval& valid)
	{
	float f;
	pblock->GetValue(PB_STRENGTH, t, f, valid);
	return f;
	}

float BombObject::GetGravity(TimeValue t, Interval& valid)
	{
	float f;
	pblock->GetValue(PB_GRAVITY, t, f, valid);
	return f;
	}

float BombObject::GetChaos(TimeValue t, Interval& valid)
	{
	float f;
	pblock->GetValue(PB_CHAOS, t, f, valid);
	return f;
	}

TimeValue BombObject::GetDetonation(TimeValue t, Interval& valid)
	{
	int det;
	pblock->GetValue(PB_DETONATION, t, det, valid);
	return TimeValue(det);
	}

float BombObject::GetSpin(TimeValue t, Interval& valid)
	{
	float f;
	pblock->GetValue(PB_SPIN, t, f, valid);
	return f;
	}

float BombObject::GetFalloff(TimeValue t, Interval& valid)
	{
	float f;
	pblock->GetValue(PB_FALLOFF, t, f, valid);
	return f;
	}

int BombObject::GetFalloffOn(TimeValue t, Interval& valid)
	{
	int i;
	pblock->GetValue(PB_FALLOFFON, t, i, valid);
	return i;
	}

int BombObject::GetMinFrag(TimeValue t, Interval& valid)
	{
	int i;
	pblock->GetValue(PB_MINFRAG, t, i, valid);
	return i;
	}

int BombObject::GetMaxFrag(TimeValue t, Interval& valid)
	{
	int i;
	pblock->GetValue(PB_MAXFRAG, t, i, valid);
	return i;
	}

int BombObject::GetSeed(TimeValue t, Interval& valid)
	{
	int i;
	pblock->GetValue(PB_SEED, t, i, valid);
	return i;
	}

void BombObject::MapKeys(TimeMap *map,DWORD flags)
	{
	TimeValue det = GetDetonation(0);
	det = map->map(det);
	SetDetonation(0,det);
	}

static void MakeTri(Face *f, int a,  int b , int c) {
	f[0].setVerts(a,b,c);
	f[0].setSmGroup(0);
	f[0].setEdgeVisFlags(1,1,1);	
	}


class BombMtl: public Material {
	public:
	BombMtl();
	};
static BombMtl swMtl;

#define BOMB_R	float(.7)
#define BOMB_G	float(0)
#define BOMB_B	float(0)

BombMtl::BombMtl():Material() {
	Kd[0] = BOMB_R;
	Kd[1] = BOMB_G;
	Kd[2] = BOMB_B;
	Ks[0] = BOMB_R;
	Ks[1] = BOMB_G;
	Ks[2] = BOMB_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME|GW_BACKCULL;
	selfIllum = (float)1.0;
	}


void BombObject::BuildMesh(TimeValue t,Mesh &mesh)
	{		
	float s = 10.0f;
	mesh.setNumVerts(4);
	mesh.setNumFaces(4);
	mesh.setVert(0,s*Point3(0.0f,1.0f,0.0f));
	mesh.setVert(1,s*Point3(-float(cos(DegToRad(30.0f))),-float(sin(DegToRad(30.0f))),0.0f));
	mesh.setVert(2,s*Point3(float(cos(DegToRad(30.0f))),-float(sin(DegToRad(30.0f))),0.0f));
	mesh.setVert(3,s*Point3(0.0f,0.0f,1.0f));
	MakeTri(&(mesh.faces[0]),2,1,0);
	MakeTri(&(mesh.faces[1]),3,0,1);
	MakeTri(&(mesh.faces[2]),3,1,2);
	MakeTri(&(mesh.faces[3]),3,2,0);
	mesh.InvalidateGeomCache();	
	}


int BombObject::HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt)
	{		
	Point2 pt( (float)p[0].x, (float)p[0].y );
	HitRegion hitRegion;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = &swMtl; 
	Matrix3 mat = inode->GetObjectTM(t);	
	gw->setTransform(mat);

	MakeHitRegion(hitRegion, type, crossing, 4, p);

	return mesh.select(gw, mtl, &hitRegion, flags & HIT_ABORTONHIT);
	}

void BombObject::Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt) {
	Matrix3 tm = inode->GetObjectTM(t);	
	GraphicsWindow *gw = vpt->getGW();	   	
	gw->setTransform(tm);
	mesh.snap(gw, snap, p, tm);
	}

int BombObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
	{
	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = &swMtl;
	Matrix3 mat = inode->GetObjectTM(t);
 	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|/*GW_BACKCULL|*/ (rlim&GW_Z_BUFFER?GW_Z_BUFFER:0) );//removed BC 2/16/99 DB

	gw->setTransform(mat);
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, GetSelColor());
	else if(!inode->IsFrozen())
		//gw->setColor( LINE_COLOR, swMtl.Kd[0], swMtl.Kd[1], swMtl.Kd[2]);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SPACE_WARPS));
	mesh.render(gw, mtl, NULL, COMP_ALL);
		
	if (hParam && GetWindowLong(hParam,GWL_USERDATA)==(LONG)this &&
		GetFalloffOn(t)) {
		DrawLineProc lp(gw);
		DrawFalloffSphere(GetFalloff(t),lp);
		}

	gw->setRndLimits(rlim);
	return(0);
	}

class BombObjCreateCallBack: public CreateMouseCallBack {	
	BombObject *ob;	
	public:
		int proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		void SetObj(BombObject *obj) { ob = obj; }
	};

int BombObjCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat ) {
	Point3 pt;

	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				pt = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE); //vpt->GetPointOnCP(m);
				mat.SetTrans(pt);
				break;
			case 1:								
				pt = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE); //vpt->GetPointOnCP(m);
				mat.SetTrans(pt);
				if (msg==MOUSE_POINT) 
					return CREATE_STOP;
				break;
			}
		}
	else
	if (msg == MOUSE_ABORT)
		return CREATE_ABORT;
	else
	if (msg == MOUSE_FREEMOVE) {
		vpt->SnapPreview(m,m);
		}

	return TRUE;
	}

static BombObjCreateCallBack bombCreateCB;


CreateMouseCallBack* BombObject::GetCreateMouseCallBack()
	{
	bombCreateCB.SetObj(this);
	return &bombCreateCB;
	}


RefTargetHandle BombObject::Clone(RemapDir& remap) {
	BombObject* newob = new BombObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return(newob);
	}

void BombObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{
	Box3 meshBox;
	Matrix3 mat = inode->GetObjectTM(t);
	box.Init();
	if (hParam && GetWindowLong(hParam,GWL_USERDATA)==(LONG)this &&
		GetFalloffOn(t)) {
		BoxLineProc bproc(&mat);
		DrawFalloffSphere(GetFalloff(t),bproc);
		box = bproc.Box();
		}
	GetLocalBoundBox(t,inode,vpt,meshBox);	
	for(int i = 0; i < 8; i++)
		box += mat * meshBox[i];
	}

void BombObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
	{		
	box = mesh.getBoundingBox();
	}

void BombObject::UpdateUI(TimeValue t)
	{
	if (hParam && !waitPostLoad) {
		if (this == (BombObject *)GetWindowLong(hParam,GWL_USERDATA)) {
			strengthSpin->SetValue(GetStrength(t),FALSE);
			gravSpin->SetValue(GetGravity(t),FALSE);
			chaosSpin->SetValue(GetChaos(t),FALSE);			
			falloffSpin->SetValue(GetFalloff(t),FALSE);
			spinSpin->SetValue(GetSpin(t),FALSE);

			if (pblock->KeyFrameAtTime(PB_STRENGTH,t))
				 strengthSpin->SetKeyBrackets(TRUE);
			else strengthSpin->SetKeyBrackets(FALSE);

			if (pblock->KeyFrameAtTime(PB_GRAVITY,t))
				 gravSpin->SetKeyBrackets(TRUE);
			else gravSpin->SetKeyBrackets(FALSE);

			if (pblock->KeyFrameAtTime(PB_CHAOS,t))
				 chaosSpin->SetKeyBrackets(TRUE);
			else chaosSpin->SetKeyBrackets(FALSE);

			if (pblock->KeyFrameAtTime(PB_SPIN,t))
				 spinSpin->SetKeyBrackets(TRUE);
			else spinSpin->SetKeyBrackets(FALSE);

			if (pblock->KeyFrameAtTime(PB_FALLOFF,t))
				 falloffSpin->SetKeyBrackets(TRUE);
			else falloffSpin->SetKeyBrackets(FALSE);
			}
		}
	}

ObjectState BombObject::Eval(TimeValue time)	
	{	
	return ObjectState(this);
	}

Interval BombObject::ObjectValidity(TimeValue time) 
	{	
	Interval ivalid = FOREVER;
	if (!waitPostLoad) {
		GetStrength(time,ivalid);
		GetGravity(time,ivalid);	
		GetFalloff(time,ivalid);
		GetChaos(time,ivalid);
		GetSpin(time,ivalid);
		UpdateUI(time);
		}
	return ivalid;	
	}


RefResult BombObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{					
	switch (message) {				
		case REFMSG_CHANGE:
			if (ip) UpdateUI(ip->GetTime());
			break;

		case REFMSG_GET_PARAM_DIM: { 
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_STRENGTH:
					gpd->dim = stdNormalizedDim;
					break;
				case PB_GRAVITY:
					gpd->dim = stdNormalizedDim;
					break;	
				case PB_CHAOS:
					gpd->dim = stdNormalizedDim;
					break;	
				case PB_DETONATION:
					gpd->dim = stdTimeDim;
					break;
				case PB_SPIN:
					gpd->dim = defaultDim;
					break;
				case PB_FALLOFF:
					gpd->dim = stdWorldDim;
					break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_STRENGTH:
					gpn->name = GetString(IDS_RB_STRENGTH2);
					break;
				case PB_GRAVITY:
					gpn->name = GetString(IDS_RB_GRAVITY);
					break;	
				case PB_CHAOS:
					gpn->name = GetString(IDS_RB_CHAOS);
					break;	
				case PB_DETONATION:
					gpn->name = GetString(IDS_RB_DETONATION);
					break;
				case PB_SPIN:
					gpn->name = GetString(IDS_RB_SPIN);
					break;
				case PB_FALLOFF:
					gpn->name = GetString(IDS_RB_FALLOFF);
					break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}




/*----------------------------------------------------------------*/
// Bomb modifier


void BombMod::BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev )
	{	
	}

void BombMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{	
	}


RefTargetHandle BombMod::GetReference(int i) {
	switch(i) {
		case OB_REF: return (RefTargetHandle)obRef;
		case NODE_REF: return (RefTargetHandle)nodeRef;		
		default: return NULL;
		}
	}

void BombMod::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case OB_REF: obRef = (BombObject *)rtarg; return;
		case NODE_REF: nodeRef = (INode *)rtarg;  return;		
		}
	}

BombMod::BombMod()
	{
	obRef   = NULL;
	nodeRef = NULL;	
	}

BombMod::BombMod(INode *node,BombObject *obj)
	{	
	MakeRefByID(FOREVER,OB_REF,obj);
	MakeRefByID(FOREVER,NODE_REF,node);	
	}

BombMod::~BombMod()
	{
	DeleteAllRefsFromMe();	
	}

BombObject *BombMod::GetWSMObject(TimeValue t)
	{
	if (nodeRef) {
		ObjectState os = nodeRef->EvalWorldState(t);
		assert(os.obj && os.obj->SuperClassID()==WSM_OBJECT_CLASS_ID);
		return (BombObject*)os.obj;		
	} else {
		return NULL;
		}
	}

Interval BombMod::LocalValidity(TimeValue t)
	{
	BombObject *obj = GetWSMObject(t);

	if (obj && nodeRef && !waitPostLoad) {
		// Force a cache of input if being edited.
		if (TestAFlag(A_MOD_BEING_EDITED))
			return NEVER;  
		Interval valid = FOREVER;
		Matrix3 tm;		
		obj->GetStrength(t,valid);
		obj->GetGravity(t,valid);
		obj->GetDetonation(t,valid);		
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}


#define GRAVITY_CONSTANT	(-0.0001f * (1200.0f*1200.0f)/(float(TIME_TICKSPERSEC)*float(TIME_TICKSPERSEC)))
#define STRENGTH_CONSTANT	(5.0f * (1200.0f/float(TIME_TICKSPERSEC)))

#define CHAOS		float(0.5)
#define CHAOSBASE	(float(1)-CHAOS/2)

#define UNDEFINED	0xffffffff

void BombMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{	
	BombObject *bobj = GetWSMObject(t);

	if (bobj && nodeRef) {
		assert(os->obj->IsSubClassOf(triObjectClassID));
		TriObject *triOb = (TriObject *)os->obj;
		Interval valid = FOREVER;

		if (os->GetTM()) {
			Matrix3 tm = *(os->GetTM());
			for (int i=0; i<triOb->GetMesh().getNumVerts(); i++) {
				triOb->GetMesh().verts[i] = triOb->GetMesh().verts[i] * tm;
				}			
			os->obj->UpdateValidity(GEOM_CHAN_NUM,os->tmValid());
			os->SetTM(NULL,FOREVER);
			}
		
		if (waitPostLoad) {
			valid.SetInstant(t);
			triOb->UpdateValidity(GEOM_CHAN_NUM,valid);
			triOb->UpdateValidity(TOPO_CHAN_NUM,valid);
			return;
			}		

		Matrix3 tm;		
		TimeValue det  = bobj->GetDetonation(t,valid);	
		float strength = bobj->GetStrength(t,valid) * STRENGTH_CONSTANT;
		float grav     = bobj->GetGravity(t,valid);		
		float chaos    = bobj->GetChaos(t,valid);
		float chaosBase = (float(1)-chaos/2);
		float rotSpeed = bobj->GetSpin(t,valid) * TWOPI/float(TIME_TICKSPERSEC);
		int minClust = bobj->GetMinFrag(t,valid), maxClust = bobj->GetMaxFrag(t,valid);
		if (minClust<1) minClust = 1;
		if (maxClust<1) maxClust = 1;
		int clustVar = maxClust-minClust+1;
		float falloff = bobj->GetFalloff(t,valid);
		int useFalloff = bobj->GetFalloffOn(t,valid);
		int seed = bobj->GetSeed(t,valid);		

		//tm = nodeRef->GetNodeTM(t,&valid);		
		tm = nodeRef->GetObjectTM(t,&valid);
		
		if (t<det) {
			valid.Set(TIME_NegInfinity,det-1);
			triOb->UpdateValidity(GEOM_CHAN_NUM,valid);
			triOb->UpdateValidity(TOPO_CHAN_NUM,valid);
			triOb->PointsWereChanged();		
			return;		
			}

		float dt = float(t-det);
		valid.SetInstant(t);

		int n0=0,n1=1,n2=2,nv;
		Point3 *verts, v, p0, p1, g(0.0f,0.0f,grav*GRAVITY_CONSTANT);
		Face *f = triOb->GetMesh().faces;
		float dot;		

		Mesh &mesh = triOb->GetMesh();

		// First, segment the faces.
		srand((unsigned int)seed);		
		Tab<DWORD> vclust;
		Tab<DWORD> vmap;
		Tab<Point3> nverts;
		vclust.SetCount(mesh.getNumVerts());
		vmap.SetCount(mesh.getNumVerts());		
		int numClust = 0;

		if (minClust==1 && maxClust==1) {
			// Simple case... 1 face per cluster
			nv = triOb->GetMesh().getNumFaces() * 3;
			verts = new Point3[nv];
			vclust.SetCount(nv);
			for (int i=0; i<nv; i++) {
				vclust[i] = i/3;
				}
			int j=0;
			for (i=0; i<mesh.getNumFaces(); i++) {
				verts[j]   = mesh.verts[mesh.faces[i].v[0]];
				verts[j+1] = mesh.verts[mesh.faces[i].v[1]];
				verts[j+2] = mesh.verts[mesh.faces[i].v[2]];
				mesh.faces[i].v[0] = j;
				mesh.faces[i].v[1] = j+1;
				mesh.faces[i].v[2] = j+2;
				j += 3;
				}
			numClust = triOb->GetMesh().getNumFaces();
		} else {
			// More complex case... clusters are randomely sized
			for (int i=0; i<mesh.getNumVerts(); i++) {
				vclust[i] = UNDEFINED;
				vmap[i] = i;
				}
			int cnum = 0;
			for (i=0; i<mesh.getNumFaces(); ) {
				int csize = int(Rand1()*float(clustVar)+float(minClust));
				if (i+csize>mesh.getNumFaces()) {
					csize = mesh.getNumFaces()-i;					
					}
				
				// Make sure each face in the cluster has at least 2 verts in common with another face.
				BOOL verified = FALSE;
				while (!verified) {
					verified = TRUE;
					if (csize<2) break;

					for (int j=0; j<csize; j++) {
						BOOL match = FALSE;
						for (int k=0; k<csize; k++) {
							if (k==j) continue;
							int common = 0;
							for (int i1=0; i1<3; i1++) {
								for (int i2=0; i2<3; i2++) {
									if (mesh.faces[i+j].v[i1]==
										mesh.faces[i+k].v[i2]) common++;
									}
								}
							if (common>=2) {
								match = TRUE;
								break;
								}
							}
						if (!match) {
							csize = j;
							verified = FALSE; // Have to check again
							break;
							}
						}
					}
				if (csize==0) csize = 1;

				// Clear the vert map
				for (int j=0; j<mesh.getNumVerts(); j++) vmap[j] = UNDEFINED;			

				// Go through the cluster and remap verts.
				for (j=0;j<csize; j++) {
					for (int k=0; k<3; k++) {
						if (vclust[mesh.faces[i+j].v[k]]==UNDEFINED) {
							vclust[mesh.faces[i+j].v[k]] = cnum;
						} else
						if (vclust[mesh.faces[i+j].v[k]]!=(DWORD)cnum) {
							if (vmap[mesh.faces[i+j].v[k]]==UNDEFINED) {
								vclust.Append(1,(DWORD*)&cnum,50);
								nverts.Append(1,&mesh.verts[mesh.faces[i+j].v[k]],50);
								mesh.faces[i+j].v[k] =
									vmap[mesh.faces[i+j].v[k]] = 
										mesh.getNumVerts()+nverts.Count()-1;
							} else {
								mesh.faces[i+j].v[k] =
									vmap[mesh.faces[i+j].v[k]];
								}
							}
						}
					}
				
				cnum++;
				numClust++;
				i += csize;
				}

			nv = mesh.getNumVerts() + nverts.Count();
			verts = new Point3[nv];
			for (i=0; i<mesh.getNumVerts(); i++) {
				verts[i] = mesh.verts[i];
				}
			for (   ; i<mesh.getNumVerts()+nverts.Count(); i++) {
				verts[i] = nverts[i-mesh.getNumVerts()];
				}
			}

		// Find the center of all clusters
		Tab<Point3> clustCent;
		Tab<DWORD> clustCounts;
		clustCent.SetCount(numClust);
		clustCounts.SetCount(numClust);
		for (int i=0; i<numClust; i++) {
			clustCent[i]   = Point3(0,0,0);
			clustCounts[i] = 0;
			}
		for (i=0; i<nv; i++) {
			if (vclust[i]==UNDEFINED) continue;
			clustCent[vclust[i]] += verts[i];
			clustCounts[vclust[i]]++;
			}

		// Build transformations for all clusters
		Tab<Matrix3> mats;
		mats.SetCount(numClust);
		srand((unsigned int)seed);
		for (i=0; i<numClust; i++) {
			if (clustCounts[i]) clustCent[i] /= float(clustCounts[i]);

			v   = clustCent[i] - tm.GetTrans();
			float u = 1.0f;
			if (useFalloff) {
				u = 1.0f - Length(v)/falloff;
				if (u<0.0f) u = 0.0f;
				}
			dot = DotProd(v,v);
			if (dot==0.0f) dot = 0.000001f;
			v  = v / dot * strength * u;
			v.x *= chaosBase + chaos * Rand1();
			v.y *= chaosBase + chaos * Rand1();
			v.z *= chaosBase + chaos * Rand1();
			p1 = v*dt + 0.5f*g*dt*dt; // projectile motion

			// Set rotation
			Point3 axis;
			axis.x = -1.0f + 2.0f*Rand1();
			axis.y = -1.0f + 2.0f*Rand1();
			axis.z = -1.0f + 2.0f*Rand1();
			axis = Normalize(axis);
			float angle = dt*rotSpeed*(chaosBase + chaos * Rand1())*u;
			Quat q = QFromAngAxis(angle, axis);
			q.MakeMatrix(mats[i]);
			
			mats[i].PreTranslate(-clustCent[i]);
			mats[i].Translate(clustCent[i]+p1);			
			}

		// Now transform the clusters
		for (i=0; i<nv; i++) {
			if (vclust[i]==UNDEFINED) continue;
			verts[i] = verts[i] * mats[vclust[i]];
			}
			
		/*
		// Seed the random number generator with num verts.
		srand((unsigned int)nv);		
		
		for (int i=0; i<triOb->mesh.getNumFaces(); i++,f++) {			
			p0  = verts[n0] = triOb->mesh.verts[f->v[0]];
			p0 += verts[n1] = triOb->mesh.verts[f->v[1]];
			p0 += verts[n2] = triOb->mesh.verts[f->v[2]];
			p0 /= 3.0f;
			v   = p0 - tm.GetTrans();
			dot = DotProd(v,v);
			if (dot==0.0f) dot = 0.000001f;
			v  = v / dot * strength;
			v.x *= chaosBase + chaos * Rand1();
			v.y *= chaosBase + chaos * Rand1();
			v.z *= chaosBase + chaos * Rand1();
			p1 = v*dt + 0.5f*g*dt*dt; // projectile motion

			verts[n0] += p1;
			verts[n1] += p1;
			verts[n2] += p1;

			f->setVerts(n0,n1,n2);
			f->setEdgeVisFlags(1,1,1);
			n0 += 3;
			n1 += 3;
			n2 += 3;
			}
		*/
		
		triOb->UpdateValidity(GEOM_CHAN_NUM,valid);
		triOb->UpdateValidity(TOPO_CHAN_NUM,valid);
		triOb->PointsWereChanged();		

		delete[] triOb->GetMesh().verts;
		triOb->GetMesh().verts    = verts;
		triOb->GetMesh().numVerts = nv;
		triOb->GetMesh().vertSel.SetSize(nv,TRUE);
		triOb->GetMesh().InvalidateTopologyCache ();
		}		 
	}

RefTargetHandle BombMod::Clone(RemapDir& remap) 
	{
	BombMod *newob = new BombMod(nodeRef,obRef);		
	return newob;
	}

RefResult BombMod::NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message ) 
	{ 
	switch ( message ) {
		case REFMSG_TARGET_DELETED:			
			// THis means the Bomb node is being deleted. As a result,
			// we must delete ourselves. 
			DeleteMe();  // also deletes all refs and 
						 // sends REFMSG_TARGET_DELETED to all Dependents			
			return REF_STOP; 		
		};

	return REF_SUCCEED; 
	}	


#define NUM_SEGS	32

static void DrawFalloffSphere(float radius, PolyLineProc& lp)
	{
	float u;
	Point3 pt[3];
	
	lp.SetLineColor(GetUIColor(COLOR_SEL_GIZMOS));	
	
	// XY
	pt[0] = Point3(radius,0.0f,0.0f);
	for (int i=1; i<=NUM_SEGS; i++) {
		u = float(i)/float(NUM_SEGS) * TWOPI;
		pt[1].x = (float)cos(u) * radius;
		pt[1].y = (float)sin(u) * radius;
		pt[1].z = 0.0f;
		lp.proc(pt,2);
		pt[0] = pt[1];
		}

	// YZ	
	pt[0] = Point3(0.0f,radius,0.0f);
	for (i=1; i<=NUM_SEGS; i++) {
		u = float(i)/float(NUM_SEGS) * TWOPI;
		pt[1].y = (float)cos(u) * radius;
		pt[1].z = (float)sin(u) * radius;
		pt[1].x = 0.0f;
		lp.proc(pt,2);
		pt[0] = pt[1];
		}
	
	// ZX	
	pt[0] = Point3(0.0f,0.0f,radius);
	for (i=1; i<=NUM_SEGS; i++) {
		u = float(i)/float(NUM_SEGS) * TWOPI;
		pt[1].z = (float)cos(u) * radius;
		pt[1].x = (float)sin(u) * radius;
		pt[1].y = 0.0f;
		lp.proc(pt,2);
		pt[0] = pt[1];
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\bend.cpp ===
/**********************************************************************
 *<
	FILE: bend.cpp

	DESCRIPTION:  Bend OSM

	CREATED BY: Dan Silva & Rolf Berteig

	HISTORY: created 30 Jauary, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"

#define BIGFLOAT	float(999999)

class BendMod : public SimpleMod {	
	public:
		static IParamMap *pmapParam;

		BendMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_BENDMOD); }  
		virtual Class_ID ClassID() { return Class_ID(BENDOSM_CLASS_ID,0);}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() { return GetString(IDS_RB_BEND2);}
		IOResult Load(ILoad *iload);

		// From simple mod
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);		
		Interval GetValidity(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);
		BOOL GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis);
		void InvalidateUI() {if (pmapParam) pmapParam->Invalidate();}
	};

class BendDeformer: public Deformer {
	public:
		Matrix3 tm,invtm, tmAbove, tmBelow;
		Box3 bbox;
		TimeValue time;
		float r, from, to;
		int doRegion;
		BendDeformer();
		BendDeformer(
			TimeValue t, ModContext &mc,
			float angle, float dir, int naxis, 
			float from, float to, int doRegion, 
			Matrix3& modmat, Matrix3& modinv);
		void SetAxis(Matrix3 &tmAxis);
		void CalcR(int axis, float angle);
		Point3 Map(int i, Point3 p); 
	};


#define BENDWSM_CLASSID	Class_ID(BENDOSM_CLASS_ID,1)

class BendWSM : public SimpleOSMToWSMObject {
	public:
		BendWSM() {}
		BendWSM(BendMod *m) : SimpleOSMToWSMObject(m) {}
		void DeleteThis() { delete this; }
		SClass_ID SuperClassID() {return WSM_OBJECT_CLASS_ID;}
		Class_ID ClassID() {return BENDWSM_CLASSID;} 
		TCHAR *GetObjectName() {return GetString(IDS_RB_BEND2);}
		RefTargetHandle Clone(RemapDir& remap)
			{return (new BendWSM((BendMod*)mod->Clone(remap)))->SimpleOSMToWSMClone(this,remap);}
	};

//--- ClassDescriptor and class vars ---------------------------------

IParamMap *BendMod::pmapParam = NULL;


class BendClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new BendMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_BEND_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(BENDOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static BendClassDesc bendDesc;
extern ClassDesc* GetBendModDesc() { return &bendDesc; }

class BendWSMClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) 
		{if (loading) return new BendWSM; else return new BendWSM(new BendMod);}
	const TCHAR *	ClassName() { return GetString(IDS_RB_BEND_CLASS); }
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() { return BENDWSM_CLASSID; }
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_MODBASED);}
	};

static BendWSMClassDesc bendWSMDesc;
extern ClassDesc* GetBendWSMDesc() { return &bendWSMDesc; }


//--- Parameter map/block descriptors -------------------------------

#define PB_ANGLE	0
#define PB_DIR		1
#define PB_AXIS		2
#define PB_DOREGION	3
#define PB_FROM		4
#define PB_TO		5


//
//
// Parameters

static int axisIDs[] = {IDC_X,IDC_Y,IDC_Z};

static ParamUIDesc descParam[] = {
	// Angle
	ParamUIDesc(
		PB_ANGLE,
		EDITTYPE_FLOAT,
		IDC_ANGLE,IDC_ANGLESPINNER,
		-BIGFLOAT,BIGFLOAT,
		0.5f),

	// Direction
	ParamUIDesc(
		PB_DIR,
		EDITTYPE_FLOAT,
		IDC_DIR,IDC_DIRSPINNER,
		-BIGFLOAT,BIGFLOAT,
		0.5f),

	// Axis
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),

	// Affect region
	ParamUIDesc(PB_DOREGION,TYPE_SINGLECHEKBOX,IDC_BEND_AFFECTREGION),

	// From
	ParamUIDesc(
		PB_FROM,
		EDITTYPE_UNIVERSE,
		IDC_BEND_FROM,IDC_BEND_FROMSPIN,
		-BIGFLOAT,0.0f,
		SPIN_AUTOSCALE),

	// To
	ParamUIDesc(
		PB_TO,
		EDITTYPE_UNIVERSE,
		IDC_BEND_TO,IDC_BEND_TOSPIN,
		0.0f,BIGFLOAT,		
		SPIN_AUTOSCALE),	
	};
#define PARAMDESC_LENGH 6


static ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_INT, NULL, FALSE, 2 } };

static ParamBlockDescID descVer1[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },	
	{ TYPE_INT, NULL, FALSE, 2 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_FLOAT, NULL, TRUE, 4 },
	{ TYPE_FLOAT, NULL, TRUE, 5 } };

#define PBLOCK_LENGTH	6

// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,3,0)
	};
#define NUM_OLDVERSIONS	1

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1,PBLOCK_LENGTH,CURRENT_VERSION);

//--- BendDlgProc -------------------------------


class BendDlgProc : public ParamMapUserDlgProc {
	public:
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DeleteThis() {}
	};
static BendDlgProc theBendProc;

BOOL BendDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case CC_SPINNER_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_BEND_FROMSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_TO,t,from);
						map->Invalidate();
						}
					break;
					}
				
				case IDC_BEND_TOSPIN: {
					float from, to;
					map->GetParamBlock()->GetValue(PB_FROM,t,from,FOREVER);
					map->GetParamBlock()->GetValue(PB_TO,t,to,FOREVER);
					if (from>to) {
						map->GetParamBlock()->SetValue(PB_FROM,t,to);
						map->Invalidate();
						}
					break;
					}
				}
			break;
		}
	return FALSE;
	}

//--- Bend methods -------------------------------


BendMod::BendMod() : SimpleMod()
	{	
	MakeRefByID(FOREVER, SIMPMOD_PBLOCKREF, 
		CreateParameterBlock(descVer1, PBLOCK_LENGTH, CURRENT_VERSION));
	
	pblock->SetValue(PB_AXIS, TimeValue(0), 2/*Z*/);
	}

IOResult BendMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,SIMPMOD_PBLOCKREF));
	return IO_OK;
	}

void BendMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	SimpleMod::BeginEditParams(ip,flags,prev);
		
	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_BENDPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);	
	pmapParam->SetUserDlgProc(&theBendProc);
	}
		
void BendMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	SimpleMod::EndEditParams(ip,flags,next);
	DestroyCPParamMap(pmapParam);
	}

Interval BendMod::GetValidity(TimeValue t)
	{
	float f;	
	Interval valid = FOREVER;
	pblock->GetValue(PB_ANGLE,t,f,valid);
	pblock->GetValue(PB_DIR,t,f,valid);	
	pblock->GetValue(PB_FROM,t,f,valid);
	pblock->GetValue(PB_TO,t,f,valid);
	return valid;
	}

BOOL BendMod::GetModLimits(TimeValue t,float &zmin, float &zmax, int &axis)
	{
	int limit;
	pblock->GetValue(PB_DOREGION,t,limit,FOREVER);
	pblock->GetValue(PB_FROM,t,zmin,FOREVER);
	pblock->GetValue(PB_TO,t,zmax,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	return limit?TRUE:FALSE;
	}

RefTargetHandle BendMod::Clone(RemapDir& remap) {	
	BendMod* newmod = new BendMod();	
	newmod->ReplaceReference(SIMPMOD_PBLOCKREF,pblock->Clone(remap));
	newmod->SimpleModClone(this);
	return(newmod);
	}

BendDeformer::BendDeformer() 
	{ 
	tm.IdentityMatrix();
	time = 0;	
	}

void BendDeformer::SetAxis(Matrix3 &tmAxis)
	{
	Matrix3 itm = Inverse(tmAxis);
	tm    = tm*tmAxis;
	invtm =	itm*invtm;
	}

void BendDeformer::CalcR(int axis, float angle)
	{
	float len = float(0);
	if (!doRegion) {
		switch (axis) {
			case 0:  len = bbox.pmax.x - bbox.pmin.x; break;
			case 1:	 len = bbox.pmax.y - bbox.pmin.y; break;
			case 2:  len = bbox.pmax.z - bbox.pmin.z; break;
			}
	} else {
		len = to-from;
		}

	// Skip the singularity
	if (fabs(angle) <0.0001) {
		r = float(0);
	} else {
		r = len/angle;
		}	
	}

Point3 BendDeformer::Map(int i, Point3 p)
	{
	float x, y, c, s, yr;
	if (r==0 && !doRegion) return p;
	p = p * tm;
	if (doRegion) {
		if (p.z<from) {
			return tmBelow * p * invtm;			
		} else 
		if (p.z>to) {
			return tmAbove * p * invtm;
			}
		}	
	if (r==0) return p * invtm;
	x = p.x;
	y = p.z;
	yr = y/r;
	c = float(cos(PI-yr));
	s = float(sin(PI-yr));
	p.x = r*c + r - x*c;
	p.z = r*s - x*s;
	p = p * invtm;
	return p;
	}

BendDeformer::BendDeformer(
		TimeValue t, ModContext &mc,
		float angle, float dir, int naxis, 
		float from, float to, int doRegion,
		Matrix3& modmat, Matrix3& modinv) 
	{	
	this->doRegion = doRegion;
	this->from = from;
	this->to   = to;
	Matrix3 mat;
	Interval valid;	
	time   = t;	

	tm = modmat;
	invtm = modinv;
	mat.IdentityMatrix();
	
	switch (naxis) {
		case 0: mat.RotateY( -HALFPI );	 break; //X
		case 1: mat.RotateX( HALFPI );  break; //Y
		case 2: break;  //Z
		}
	mat.RotateZ(DegToRad(dir));	
	SetAxis(mat);	
	assert (mc.box);
	bbox = *mc.box;
	CalcR(naxis,DegToRad(angle));
	
	// Turn this off for a sec.
	this->doRegion = FALSE;
		
	float len  = to-from;
	float rat1, rat2;
	if (len==0.0f) {
		rat1 = rat2 = 1.0f;
	} else {
		rat1 = to/len;
		rat2 = from/len;
		}
	Point3 pt;
	tmAbove.IdentityMatrix();
	tmAbove.Translate(Point3(0.0f,0.0f,-to));
	tmAbove.RotateY(DegToRad(angle * rat1));
	tmAbove.Translate(Point3(0.0f,0.0f,to));
	pt = Point3(0.0f,0.0f,to);
	tmAbove.Translate((Map(0,pt*invtm)*tm)-pt);

	tmBelow.IdentityMatrix();
	tmBelow.Translate(Point3(0.0f,0.0f,-from));
	tmBelow.RotateY(DegToRad(angle * rat2));	
	tmBelow.Translate(Point3(0.0f,0.0f,from));
	pt = Point3(0.0f,0.0f,from);
	tmBelow.Translate((Map(0,pt*invtm)*tm)-pt);	
	
	this->doRegion = doRegion;
	} 


Deformer& BendMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	float angle, dir, from, to;
	int axis;	
	int doRegion;
	pblock->GetValue(PB_ANGLE,t,angle,FOREVER);
	pblock->GetValue(PB_DIR,t,dir,FOREVER);
	pblock->GetValue(PB_AXIS,t,axis,FOREVER);
	pblock->GetValue(PB_FROM,t,from,FOREVER);
	pblock->GetValue(PB_TO,t,to,FOREVER);
	pblock->GetValue(PB_DOREGION,t,doRegion,FOREVER);
	static BendDeformer deformer;
	deformer = BendDeformer(t,mc,angle,dir,axis,from,to,doRegion,mat,invmat);
	return deformer;
	}

ParamDimension *BendMod::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ANGLE: 	return defaultDim; // Note: doesn't use angleDim because the bend has been storing the angle in degrees not radians. Changing this would invalidate old files.
		case PB_DIR:	return defaultDim;
		case PB_FROM:	return stdWorldDim;
		case PB_TO:		return stdWorldDim;
		default:		return defaultDim;
		}
	}

TSTR BendMod::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_ANGLE:	return GetString(IDS_RB_ANGLE);
		case PB_DIR:	return GetString(IDS_RB_DIRECTION);
		case PB_FROM:	return GetString(IDS_RB_FROM);
		case PB_TO:		return GetString(IDS_RB_TO);
		default:		return _T("");
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\delmod.cpp ===
/**********************************************************************
 *<
	FILE: delmod.cpp

	DESCRIPTION:  A deletion modifier

	CREATED BY: Rolf Berteig

	HISTORY: 10/23/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"


class DeleteMod : public Modifier {	
	public:		
		DeleteMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s = GetString(IDS_RB_DELETEMOD);}  
		virtual Class_ID ClassID() { return Class_ID(DELETE_CLASS_ID,0);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_DELETEMOD);}

		// From modifier
		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE|PART_VERTCOLOR|TEXMAP_CHANNEL;}
		ChannelMask ChannelsChanged() {return PART_GEOM|PART_TOPO|PART_SELECT|PART_VERTCOLOR|TEXMAP_CHANNEL;}
		Class_ID InputType() {return triObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t) {return FOREVER;}

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		
		int NumRefs() {return 0;}
		RefTargetHandle GetReference(int i) {return NULL;}
		void SetReference(int i, RefTargetHandle rtarg) {}

		int NumSubs() {return 0;}
		Animatable* SubAnim(int i) {return NULL;}
		TSTR SubAnimName(int i) {return _T("");}

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message) {return REF_SUCCEED;}
	};


//--- ClassDescriptor and class vars ---------------------------------

class DeleteClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new DeleteMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_DELETEMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(DELETE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static DeleteClassDesc deleteDesc;
ClassDesc* GetDeleteModDesc() {return &deleteDesc;}


//--- Delete mod methods -------------------------------

DeleteMod::DeleteMod()
	{

	}

RefTargetHandle DeleteMod::Clone(RemapDir& remap)
	{
	return new DeleteMod();
	}

void DeleteMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	if (os->obj->IsSubClassOf(triObjectClassID)) {
		TriObject *tobj = (TriObject*)os->obj;
		tobj->GetMesh().DeleteSelected();
		tobj->GetMesh().InvalidateTopologyCache ();
		tobj->GetMesh().InvalidateGeomCache ();
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\deflect.cpp ===
/**********************************************************************
 *<
	FILE: deflect.cpp

	DESCRIPTION: A simple deflector object for particles

	CREATED BY: Rolf Berteig

	HISTORY: 10-31-95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"

class DeflectObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
					
		DeflectObject();

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		Class_ID ClassID() {return Class_ID(DEFLECTOBJECT_CLASS_ID,0);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_DEFLECTOR);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack();		
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *DeflectObject::ip        = NULL;
IParamMap *DeflectObject::pmapParam = NULL;
HWND       DeflectObject::hSot      = NULL;

class DeflectorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new DeflectObject;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_DEFLECTOR_CLASS);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return Class_ID(DEFLECTOBJECT_CLASS_ID,0);}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_PARTICLES);}
	};

static DeflectorClassDesc deflectDesc;
ClassDesc* GetDeflectObjDesc() {return &deflectDesc;}

//--- DeflectMod -----------------------------------------------------

class DeflectorField : public CollisionObject {
	public:		
		DeflectObject *obj;
		INode *node;
		Matrix3 tm, invtm;
		Interval tmValid;		
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index, float *ct,BOOL UpdatePastCollide);
		Object *GetSWObject();
	};

class DeflectMod : public SimpleWSMMod {
	public:				
		DeflectorField deflect;

		DeflectMod() {}
		DeflectMod(INode *node,DeflectObject *obj);		

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_RB_DEFLECTMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return Class_ID(DEFLECTMOD_CLASS_ID,0);}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_DEFLECTORBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class DeflectorModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new DeflectMod;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_DEFLECTMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return Class_ID(DEFLECTMOD_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static DeflectorModClassDesc deflectModDesc;
ClassDesc* GetDeflectModDesc() {return &deflectModDesc;}

//--- DeflectObject Parameter map/block descriptors ------------------

#define PB_BOUNCE	0
#define PB_WIDTH	1
#define PB_HEIGHT	2

static ParamUIDesc descParam[] = {
	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_DEFLECT_BOUNCE,IDC_DEFLECT_BOUNCESPIN,
		0.0f, 9999999.0f,
		0.01f),
	
	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_DEFLECT_WIDTH,IDC_DEFLECT_WIDTHSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),
	
	// height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_DEFLECT_HEIGHT,IDC_DEFLECT_HEIGHTSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE)
	};

#define PARAMDESC_LENGTH	3

ParamBlockDescID descVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 }};
#define PBLOCK_LENGTH	3

#define CURRENT_VERSION	0


//--- Deflect object methods -----------------------------------------

DeflectObject::DeflectObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_BOUNCE,0,1.0f);
	}

Modifier *DeflectObject::CreateWSMMod(INode *node)
	{
	return new DeflectMod(node,this);
	}

RefTargetHandle DeflectObject::Clone(RemapDir& remap) 
	{
	DeflectObject* newob = new DeflectObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	return newob;
	}

void DeflectObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_WINDRAIN_SOT),
			DefaultSOTProc,
			GetString(IDS_RB_SOT), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_DEFLECTORPARAM),
			GetString(IDS_RB_PARAMETERS),
			0);
		}
	}

void DeflectObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}


void DeflectObject::BuildMesh(TimeValue t)
	{
	float width, height;
	ivalid = FOREVER;
	pblock->GetValue(PB_WIDTH,t,width,ivalid);
	pblock->GetValue(PB_HEIGHT,t,height,ivalid);
	width  *= 0.5f;
	height *= 0.5f;

	mesh.setNumVerts(4);
	mesh.setNumFaces(2);
	mesh.setVert(0, Point3(-width,-height, 0.0f));
	mesh.setVert(1, Point3( width,-height, 0.0f));
	mesh.setVert(2, Point3( width, height, 0.0f));
	mesh.setVert(3, Point3(-width, height, 0.0f));
	
	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[0].setSmGroup(1);
	mesh.faces[0].setVerts(0,1,3);

	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(1);
	mesh.faces[1].setVerts(1,2,3);	
	mesh.InvalidateGeomCache();	
	}


class DeflectObjCreateCallback : public CreateMouseCallBack {
	public:
		DeflectObject *ob;	
		Point3 p0, p1;
		IPoint2 sp0, sp1;
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
	};

int DeflectObjCreateCallback::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				mat.SetTrans(p0);
				ob->pblock->SetValue(PB_WIDTH,0,0.01f);
				ob->pblock->SetValue(PB_HEIGHT,0,0.01f);
				ob->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				p1  = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				ob->pblock->SetValue(PB_WIDTH,0,(float)fabs(p1.x-p0.x));
				ob->pblock->SetValue(PB_HEIGHT,0,(float)fabs(p1.y-p0.y));
				ob->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
		} 
	else 
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		}	
	else
	if (msg == MOUSE_FREEMOVE) {
		vpt->SnapPreview(m,m);
		}

	return TRUE;
	}
static DeflectObjCreateCallback deflectCreateCB;

CreateMouseCallBack* DeflectObject::GetCreateMouseCallBack()
	{
	deflectCreateCB.ob = this;
	return &deflectCreateCB;
	}

void DeflectObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *DeflectObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case 0:
		default: return defaultDim;
		}
	}

TSTR DeflectObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_BOUNCE: 	return GetString(IDS_RB_BOUNCE);
		case PB_WIDTH:		return GetString(IDS_RB_WIDTH);
		case PB_HEIGHT:		return GetString(IDS_RB_LENGTH);
		default: 			return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

DeflectMod::DeflectMod(INode *node,DeflectObject *obj)
	{	
	//MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef = NULL;
	}

Interval DeflectMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		DeflectObject *obj = (DeflectObject*)GetWSMObject(t);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_WIDTH,t,f,valid);
		obj->pblock->GetValue(PB_HEIGHT,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {
		return FOREVER;
		}
	}

class DeflectDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static DeflectDeformer ddeformer;

Deformer& DeflectMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return ddeformer;
	}

RefTargetHandle DeflectMod::Clone(RemapDir& remap) 
	{
	DeflectMod *newob = new DeflectMod(nodeRef,(DeflectObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}


void DeflectMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (DeflectObject*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.tmValid.SetEmpty();		
		obj->ApplyCollisionObject(&deflect);
		}
	}

Object *DeflectorField::GetSWObject()
{ return obj;
}

BOOL DeflectorField::CheckCollision(
		TimeValue t,Point3 &pos, Point3 &vel, float dt, int index, float *ct,BOOL UpdatePastCollide)
{	if (!tmValid.InInterval(t)) 
	{	tmValid = FOREVER;
		tm    = node->GetObjectTM(t,&tmValid);
		invtm = Inverse(tm);
	}
	
	Point3 p, v, ph;
	float width, height, at, bounce;

	obj->pblock->GetValue(PB_WIDTH,t,width,FOREVER);
	obj->pblock->GetValue(PB_HEIGHT,t,height,FOREVER);
	obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
	width  *= 0.5f;
	height *= 0.5f;

	// Transform the point and velocity into our space
	p = pos * invtm; 
	v = VectorTransform(invtm,vel);

	// Compute the point of intersection
	if (fabs(p.z)<0.001) 
	{	v.z = 0.0f;
		at  = 0.0f;		
	} 
	else 
	{	if (v.z==0.0f) 
			return FALSE;
		at = -p.z/v.z;
		if (at < 0.0f || at > dt) 
			return FALSE;
	}
	ph = p + at*v;

	// See if the point is within our range
	if (ph.x<-width || ph.x>width || ph.y<-height || ph.y>height) 
		return FALSE;

	// Remove the part of dt we used to get to the collision point
	float holddt = dt;
	dt -= at;

	// Reflect the velocity about the XY plane and attenuate with the bounce factor
	v.z = -v.z;
	if (bounce!=1.0f) 
		v = v*bounce;

	if (UpdatePastCollide)
	{	ph += v * dt;  //uses up the rest of the time with the new velocity
		if (ct) (*ct) = holddt;
	}
	else
	{	if (ct) (*ct) = at;
	}

	// Tranform back into world space.
	pos = ph * tm;
	vel = VectorTransform(tm,v);
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\dispApprox.cpp ===
/**********************************************************************
 *<
	FILE: dispApprox.cpp

	DESCRIPTION:  Displacement Approximation OSM

	CREATED BY: Charlie Thaeler

	HISTORY: created 14 December, 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "MeshDLib.h"

#define DISP_APPROX_CLASSID Class_ID(0x79f61cd0, 0x75511f8c)
#define MESH_MESHER_CLASSID Class_ID(0x291e236b, 0x24474d5d)



class DispApproxMod : public Modifier {
protected:
	static HWND mshWnd;
	TessApprox mApprox;
	bool mDoSubdiv;
	bool mSplitMesh;
	bool mCustomApprox;
public:
	DispApproxMod();
	void DeleteThis() { delete this; }
	RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message ) { return REF_SUCCEED; }
	CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 
	ChannelMask ChannelsUsed()  { return PART_GEOM | PART_TOPO | PART_DISP_APPROX | PART_TEXMAP; }
	ChannelMask ChannelsChanged() { return PART_DISP_APPROX; }

	void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	Class_ID ClassID() { return DISP_APPROX_CLASSID; }
	Class_ID InputType() { return triObjectClassID; }
	void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
	void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);
	TCHAR *GetObjectName() {return GetString(IDS_CT_DISP_APPROX);}

	TessApprox& DisplacmentApprox() { return mApprox; }
	bool& DoSubdivisionDisplacment() { return mDoSubdiv; }
	bool& SplitMeshForDisplacement() { return mSplitMesh; }
	void SetDisplacmentApproxToPreset(int preset);
	bool& CustomApprox() { return mCustomApprox; }
};

class MeshMesherMod : public DispApproxMod {
public:
	MeshMesherMod();
	void DeleteThis() { delete this; }
	RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message ) { return REF_SUCCEED; }
	CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 
	ChannelMask ChannelsUsed()  { return PART_GEOM | PART_TOPO | PART_DISP_APPROX | PART_TEXMAP; }
	ChannelMask ChannelsChanged() { return PART_ALL; }

	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
	Class_ID ClassID() { return MESH_MESHER_CLASSID; }
    SClass_ID SuperClassID() { return WSM_CLASS_ID; }
	Class_ID InputType() { return triObjectClassID; }
	void BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev);
	void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);
	TCHAR *GetObjectName() {return GetString(IDS_CT_MESH_MESHER);}
	Interval LocalValidity(TimeValue t) { return FOREVER; }

	TessApprox& DisplacmentApprox() { return mApprox; }
	bool &DoSubdivisionDisplacment() { return mDoSubdiv; }
	bool& SplitMeshForDisplacement() { return mSplitMesh; }
	bool &UseCustomApprox() { return mCustomApprox; }
	void SetDisplacmentApproxToPreset(int preset);
	bool CustomApprox() { return mCustomApprox; }
};




class DispApproxClassDesc:public ClassDesc {
public:
	int 			IsPublic() { return GetSystemSetting(SYSSET_ENABLE_EDITMESHMOD); }
	void *			Create(BOOL loading = FALSE ) { return new DispApproxMod; }
	const TCHAR *	ClassName() { return GetString(IDS_CT_DISPAPPROX_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return DISP_APPROX_CLASSID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFEDIT);}
	void			ResetClassParams(BOOL fileReset) { /* Noop */ }
};
class MeshMesherClassDesc : public ClassDesc {
public:
	int 			IsPublic() { return GetSystemSetting(SYSSET_ENABLE_EDITMESHMOD); }
	void *			Create(BOOL loading = FALSE ) { return new MeshMesherMod; }
	const TCHAR *	ClassName() { return GetString(IDS_CT_MESH_MESHER_CLASS); }
	SClass_ID		SuperClassID() { return WSM_CLASS_ID; }
	Class_ID		ClassID() { return MESH_MESHER_CLASSID; }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFEDIT);}
	void			ResetClassParams(BOOL fileReset) { /* Noop */ }
};



static DispApproxClassDesc sDispApproxDesc;
extern ClassDesc* GetDispApproxModDesc() { return &sDispApproxDesc; }

static MeshMesherClassDesc sMeshMesherDesc;
extern ClassDesc* GetMeshMesherWSMDesc() { return &sMeshMesherDesc; }







HWND DispApproxMod::mshWnd = NULL;

DispApproxMod::DispApproxMod()
{
	SetDisplacmentApproxToPreset(1);
	mDoSubdiv = TRUE;
	mSplitMesh = TRUE;
	mCustomApprox = TRUE;
}

#define APPROX_CHUNKID		5000
#define DO_SUBDIV_CHUNKID	5001
#define SPLITMESH_CHUNKID	5002
#define MOD_CHUNK           5003

IOResult
DispApproxMod::Save(ISave *isave)
{
	IOResult res;
	ULONG nb;

	isave->BeginChunk(APPROX_CHUNKID);
	res = mApprox.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(DO_SUBDIV_CHUNKID);
	BOOL subdiv = mDoSubdiv?TRUE:FALSE;
	isave->Write(&subdiv, sizeof(BOOL), &nb);
	isave->EndChunk();

	isave->BeginChunk(SPLITMESH_CHUNKID);
	BOOL split = mSplitMesh?TRUE:FALSE;
	isave->Write(&split, sizeof(BOOL), &nb);
	isave->EndChunk();

	isave->BeginChunk(MOD_CHUNK);
    Modifier::Save(isave);
	isave->EndChunk();

	return res;
}


IOResult
DispApproxMod::Load(ILoad *iload)
{
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		case APPROX_CHUNKID:
			mApprox.Load(iload);
			break;
        case DO_SUBDIV_CHUNKID: {
			BOOL subdiv;
            iload->Read(&subdiv, sizeof(BOOL), &nb);
			mDoSubdiv = subdiv?true:false;
            break; }
        case SPLITMESH_CHUNKID: {
			BOOL split;
            iload->Read(&split, sizeof(BOOL), &nb);
			mSplitMesh = split?true:false;
            break; }

        case MOD_CHUNK:
            Modifier::Load(iload);
            break;

		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	return IO_OK;
}

void
DispApproxMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{
	TriObject *pTriObj = (TriObject*)os->obj;
	pTriObj->DisplacmentApprox() = mApprox;
	pTriObj->DoSubdivisionDisplacment() = mDoSubdiv;
	pTriObj->SplitMeshForDisplacement() = mSplitMesh;
	pTriObj->SetChannelValidity(DISP_APPROX_CHAN_NUM, FOREVER);
}

RefTargetHandle 
DispApproxMod::Clone(RemapDir& remap)
{
    DispApproxMod* pMod = new DispApproxMod();
	pMod->mApprox = mApprox;
	pMod->mDoSubdiv = mDoSubdiv;
	pMod->mSplitMesh = mSplitMesh;
	pMod->mCustomApprox = mCustomApprox;
    return pMod;
}

class AdvParams {
public:
	TessSubdivStyle mStyle;
	int mMin, mMax;
	int mTris;
};
static AdvParams sParams;

static ISpinnerControl* psUSpin = NULL;
static ISpinnerControl* psEdgeSpin = NULL;
static ISpinnerControl* psDistSpin = NULL;
static ISpinnerControl* psAngSpin = NULL;

static HWND sHwnd = NULL;

static void
SetupApproxUI(HWND hWnd, TessApprox tapprox, bool dosubdiv, bool custom, bool splitmesh)
{
	if (GetDlgItem(hWnd, IDC_CUSTOM)) {
		EnableWindow( GetDlgItem(hWnd, IDC_CUSTOM), TRUE);
		CheckDlgButton( hWnd, IDC_CUSTOM, custom?TRUE:FALSE);
	}

	if (custom) {
		EnableWindow( GetDlgItem(hWnd, IDC_DO_SUBDIV), TRUE);
	} else {
		EnableWindow( GetDlgItem(hWnd, IDC_DO_SUBDIV), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_SPLITMESH), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_ADVANCED), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_VIEW_DEP), FALSE);

		EnableWindow( GetDlgItem(hWnd, IDC_PRESET1), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_PRESET2), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_PRESET3), FALSE);

		EnableWindow( GetDlgItem(hWnd, IDC_TESS_REGULAR), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_SPATIAL), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_CURV), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_LDA), FALSE);
		psUSpin->Disable();
		psEdgeSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();
		return;
	}
	CheckDlgButton( hWnd, IDC_DO_SUBDIV, dosubdiv);
	CheckDlgButton( hWnd, IDC_SPLITMESH, splitmesh);
	if (!dosubdiv) {
		EnableWindow( GetDlgItem(hWnd, IDC_SPLITMESH), FALSE);

		EnableWindow( GetDlgItem(hWnd, IDC_ADVANCED), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_VIEW_DEP), FALSE);

		EnableWindow( GetDlgItem(hWnd, IDC_PRESET1), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_PRESET2), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_PRESET3), FALSE);

		EnableWindow( GetDlgItem(hWnd, IDC_TESS_REGULAR), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_SPATIAL), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_CURV), FALSE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_LDA), FALSE);
		psUSpin->Disable();
		psEdgeSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();
		return;
	}
	EnableWindow( GetDlgItem(hWnd, IDC_SPLITMESH), TRUE);

    EnableWindow( GetDlgItem(hWnd, IDC_ADVANCED), FALSE);
    EnableWindow( GetDlgItem(hWnd, IDC_TESS_VIEW_DEP), FALSE);
	CheckDlgButton( hWnd, IDC_TESS_REGULAR, FALSE);
	CheckDlgButton( hWnd, IDC_TESS_SPATIAL, FALSE);
	CheckDlgButton( hWnd, IDC_TESS_CURV, FALSE);
	CheckDlgButton( hWnd, IDC_TESS_LDA, FALSE);

	psUSpin->Enable();
	psEdgeSpin->Enable();
	psDistSpin->Enable();
	psAngSpin->Enable();

	EnableWindow( GetDlgItem(hWnd, IDC_PRESET1), TRUE);
	EnableWindow( GetDlgItem(hWnd, IDC_PRESET2), TRUE);
	EnableWindow( GetDlgItem(hWnd, IDC_PRESET3), TRUE);

	EnableWindow( GetDlgItem(hWnd, IDC_TESS_REGULAR), TRUE);
	EnableWindow( GetDlgItem(hWnd, IDC_TESS_SPATIAL), TRUE);
	EnableWindow( GetDlgItem(hWnd, IDC_TESS_CURV), TRUE);
	EnableWindow( GetDlgItem(hWnd, IDC_TESS_LDA), TRUE);

	psUSpin->SetValue(tapprox.u, FALSE);
	psEdgeSpin->SetValue(tapprox.edge, FALSE);
	psDistSpin->SetValue(tapprox.dist, FALSE);
	psAngSpin->SetValue(tapprox.ang, FALSE);

	switch(tapprox.type) {
	case TESS_REGULAR:
		psEdgeSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();
		CheckDlgButton( hWnd, IDC_TESS_REGULAR, TRUE);
		break;
	case TESS_SPATIAL:
        EnableWindow( GetDlgItem(hWnd, IDC_ADVANCED), TRUE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_VIEW_DEP), TRUE);
		psUSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();
		CheckDlgButton( hWnd, IDC_TESS_SPATIAL, TRUE);
		break;
	case TESS_CURVE:
        EnableWindow( GetDlgItem(hWnd, IDC_ADVANCED), TRUE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_VIEW_DEP), TRUE);
		psEdgeSpin->Disable();
		psUSpin->Disable();
		CheckDlgButton( hWnd, IDC_TESS_CURV, TRUE);
		break;
	case TESS_LDA:
        EnableWindow( GetDlgItem(hWnd, IDC_ADVANCED), TRUE);
		EnableWindow( GetDlgItem(hWnd, IDC_TESS_VIEW_DEP), TRUE);
		psUSpin->Disable();
		CheckDlgButton( hWnd, IDC_TESS_LDA, TRUE);
		break;
	}
}

class UIApproxRestore : public RestoreObj {
public:		
	DispApproxMod *mpMod;
	TessApprox mApprox, mApproxR;
	bool mDoSubdiv, mDoSubdivR;
	bool mSplitMesh, mSplitMeshR;
	bool mCustom, mCustomR;

    UIApproxRestore(DispApproxMod *pMod);

    void Restore(int isUndo);
    void Redo();
};

UIApproxRestore::UIApproxRestore(DispApproxMod *pMod)
{
	mpMod = pMod;
	mApprox = pMod->DisplacmentApprox();
	mDoSubdiv = pMod->DoSubdivisionDisplacment();
	mSplitMesh = pMod->DoSubdivisionDisplacment();
	mCustom = pMod->CustomApprox();
}

void
UIApproxRestore::Restore(int isUndo)
{
	if (isUndo) {
		mApproxR = mpMod->DisplacmentApprox();
		mDoSubdiv = mpMod->DoSubdivisionDisplacment();
		mSplitMesh = mpMod->SplitMeshForDisplacement();
	}
	mpMod->DisplacmentApprox() = mApprox;
	mpMod->DoSubdivisionDisplacment() = mDoSubdiv;
	mpMod->SplitMeshForDisplacement() = mSplitMesh;
	mpMod->CustomApprox() = mCustom;
	if (sHwnd)
		SetupApproxUI(sHwnd, mApprox, mDoSubdiv, mCustom, mSplitMesh);
}

void
UIApproxRestore::Redo()
{
	mpMod->DisplacmentApprox() = mApproxR;
	mpMod->DoSubdivisionDisplacment() = mDoSubdivR;
	mpMod->SplitMeshForDisplacement() = mSplitMeshR;
	mpMod->CustomApprox() = mCustomR;
	if (sHwnd)
		SetupApproxUI(sHwnd, mApproxR, mDoSubdivR, mCustomR, mSplitMeshR);
}



static void
Notify(DispApproxMod *pMod)
{
    pMod->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
    GetCOREInterface()->RedrawViews(GetCOREInterface()->GetTime());
}


#define MAX_F 1000.0f
BOOL CALLBACK MeshAdvParametersDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );

BOOL CALLBACK
DispApproxDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	DispApproxMod *pMod = (DispApproxMod*)GetWindowLong(hWnd,GWL_USERDATA);


	switch (msg) {
	case WM_INITDIALOG: {
		pMod = (DispApproxMod*)lParam;
		sHwnd = hWnd;
		SetWindowLong(hWnd, GWL_USERDATA, lParam);
		psUSpin = SetupIntSpinner( hWnd, IDC_TESS_U_SPINNER, IDC_TESS_U, 1, 100,
									pMod->DisplacmentApprox().u);
		psEdgeSpin = SetupFloatSpinner( hWnd, IDC_TESS_EDGE_SPINNER, IDC_TESS_EDGE, 0.0f, MAX_F,
									pMod->DisplacmentApprox().edge);
		psDistSpin = SetupFloatSpinner( hWnd, IDC_TESS_DIST_SPINNER, IDC_TESS_DIST, 0.0f, MAX_F,
									pMod->DisplacmentApprox().dist);
		psAngSpin =  SetupFloatSpinner( hWnd, IDC_TESS_ANG_SPINNER,  IDC_TESS_ANG, 0.0f, 180.0f,
									pMod->DisplacmentApprox().ang);
		CheckDlgButton(hWnd, IDC_TESS_VIEW_DEP, pMod->DisplacmentApprox().view);
		SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
							pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
		break; }

	case CC_SPINNER_BUTTONDOWN:
		theHold.Begin();
		theHold.Put(new UIApproxRestore(pMod));
		break;


    case CC_SPINNER_CHANGE:
		if (!HIWORD(wParam)) {
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
		}
		switch ( LOWORD(wParam) ) {
		case IDC_TESS_U_SPINNER:
			pMod->DisplacmentApprox().u = psUSpin->GetIVal();
			break;
		case IDC_TESS_EDGE_SPINNER:
			pMod->DisplacmentApprox().edge = psEdgeSpin->GetFVal();
			break;
		case IDC_TESS_DIST_SPINNER:
			pMod->DisplacmentApprox().dist = psDistSpin->GetFVal();
			break;
		case IDC_TESS_ANG_SPINNER:
			pMod->DisplacmentApprox().ang = psAngSpin->GetFVal();
			break;
		}
  		if (!HIWORD(wParam)) {
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
		}
      break;

	case CC_SPINNER_BUTTONUP:
		if (HIWORD(wParam)) {
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
		} else {
			theHold.Cancel();
		}
		break;

    case WM_COMMAND:
		switch ( LOWORD(wParam) ) {
        case IDC_UPDATE:
			Notify(pMod);
            break;

		case IDC_CUSTOM:
			assert(GetDlgItem(hWnd, IDC_CUSTOM));
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->CustomApprox() = IsDlgButtonChecked(hWnd, IDC_CUSTOM)?true:false;
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;

		case IDC_DO_SUBDIV:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->DoSubdivisionDisplacment() = IsDlgButtonChecked(hWnd, IDC_DO_SUBDIV)?true:false;
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;
		case IDC_SPLITMESH:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->SplitMeshForDisplacement() = IsDlgButtonChecked(hWnd, IDC_SPLITMESH)?true:false;
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;
		case IDC_PRESET1:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->SetDisplacmentApproxToPreset(0);
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;
		case IDC_PRESET2:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->SetDisplacmentApproxToPreset(1);
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;
		case IDC_PRESET3:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->SetDisplacmentApproxToPreset(2);
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;

		case IDC_TESS_REGULAR:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->DisplacmentApprox().type = TESS_REGULAR;
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;
		case IDC_TESS_SPATIAL:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->DisplacmentApprox().type = TESS_SPATIAL;
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;
		case IDC_TESS_CURV:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->DisplacmentApprox().type = TESS_CURVE;
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;
		case IDC_TESS_LDA:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->DisplacmentApprox().type = TESS_LDA;
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			SetupApproxUI(hWnd, pMod->DisplacmentApprox(), pMod->DoSubdivisionDisplacment(),
								pMod->CustomApprox(), pMod->SplitMeshForDisplacement());
			break;

		case IDC_TESS_VIEW_DEP:
			theHold.Begin();
			theHold.Put(new UIApproxRestore(pMod));
			pMod->DisplacmentApprox().view = IsDlgButtonChecked(hWnd, IDC_TESS_VIEW_DEP);
			Notify(pMod);
			theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
			break;
		case IDC_ADVANCED: {
			sParams.mStyle = pMod->DisplacmentApprox().subdiv;
			sParams.mMin = pMod->DisplacmentApprox().minSub;
			sParams.mMax = pMod->DisplacmentApprox().maxSub;
			sParams.mTris = pMod->DisplacmentApprox().maxTris;
			int retval = DialogBoxParam( hInstance,
						MAKEINTRESOURCE(IDD_DISP_APPROX_ADV),
						hWnd, MeshAdvParametersDialogProc, (LPARAM)pMod);
			if (retval == 1) {
				BOOL confirm = FALSE;
				if ((sParams.mStyle == SUBDIV_DELAUNAY && sParams.mTris > 200000) ||
					(sParams.mStyle != SUBDIV_DELAUNAY && sParams.mMax > 5)) {
					// warning!
					TSTR title = GetString(IDS_ADV_DISP_APPROX_WARNING_TITLE),
						warning = GetString(IDS_ADV_DISP_APPROX_WARNING);
					if (MessageBox(hWnd, warning, title,
						MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 ) == IDYES)
						confirm = TRUE;
 
				} else
					confirm = TRUE;
				if (confirm) {
					theHold.Begin();
					theHold.Put(new UIApproxRestore(pMod));
					pMod->DisplacmentApprox().subdiv = sParams.mStyle;
					pMod->DisplacmentApprox().minSub = sParams.mMin;
					pMod->DisplacmentApprox().maxSub = sParams.mMax;
					pMod->DisplacmentApprox().maxTris = sParams.mTris;
					Notify(pMod);
					theHold.Accept(GetString(IDS_CT_DISP_APPROX_CHANGE));
				}
			}
			break; }
		}
        break;

		
	case WM_DESTROY:
		sHwnd = NULL;
		if( psUSpin ) {
			ReleaseISpinner(psUSpin);
			psUSpin = NULL;
		}
		if( psEdgeSpin ) {
			ReleaseISpinner(psEdgeSpin);
			psEdgeSpin = NULL;
		}
		if( psDistSpin ) {
			ReleaseISpinner(psDistSpin);
			psDistSpin = NULL;
		}
		if( psAngSpin ) {
			ReleaseISpinner(psAngSpin);
			psAngSpin = NULL;
		}
        break;
	default:
		return FALSE;
	}
	return TRUE;
}

static ISpinnerControl* psMinSpin = NULL;
static ISpinnerControl* psMaxSpin = NULL;
static ISpinnerControl* psMaxTrisSpin = NULL;
// this max matches the MI max.
#define MAX_SUBDIV 7

static BOOL initing = FALSE; // this is a hack but CenterWindow causes bad commands

BOOL CALLBACK
MeshAdvParametersDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg) {
    case WM_INITDIALOG: {
		initing = TRUE;
        CenterWindow(hDlg, GetCOREInterface()->GetMAXHWnd());
		initing = FALSE;
		psMinSpin = SetupIntSpinner( hDlg, IDC_TESS_MIN_REC_SPINNER, IDC_TESS_MIN_REC,
			0, sParams.mMax, sParams.mMin);
		psMaxSpin = SetupIntSpinner( hDlg, IDC_TESS_MAX_REC_SPINNER, IDC_TESS_MAX_REC,
			sParams.mMin, MAX_SUBDIV, sParams.mMax);
		psMaxTrisSpin = SetupIntSpinner( hDlg, IDC_TESS_MAX_TRIS_SPINNER, IDC_TESS_MAX_TRIS,
			0, 2000000, sParams.mTris);
		switch (sParams.mStyle) {
		case SUBDIV_GRID:
			CheckDlgButton( hDlg, IDC_GRID, TRUE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			psMinSpin->Enable();
			psMaxSpin->Enable();
			psMaxTrisSpin->Disable();
			break;
		case SUBDIV_TREE:
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, TRUE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			psMinSpin->Enable();
			psMaxSpin->Enable();
			psMaxTrisSpin->Disable();
			break;
		case SUBDIV_DELAUNAY:
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, TRUE);
			psMinSpin->Disable();
			psMaxSpin->Disable();
			psMaxTrisSpin->Enable();
			break;
		}
		break; }

    case WM_COMMAND:
		if (initing) return FALSE;
		switch ( LOWORD(wParam) ) {
		case IDOK:
			EndDialog(hDlg, 1);
			break;
		case IDCANCEL:
			EndDialog(hDlg, 0);
			break;
		case IDC_GRID:
			sParams.mStyle = SUBDIV_GRID;
			CheckDlgButton( hDlg, IDC_GRID, TRUE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			psMinSpin->Enable();
			psMaxSpin->Enable();
			psMaxTrisSpin->Disable();
			break;
		case IDC_TREE:
			sParams.mStyle = SUBDIV_TREE;
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, TRUE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			psMinSpin->Enable();
			psMaxSpin->Enable();
			psMaxTrisSpin->Disable();
			break;
		case IDC_DELAUNAY:
			sParams.mStyle = SUBDIV_DELAUNAY;
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, TRUE);
			psMinSpin->Disable();
			psMaxSpin->Disable();
			psMaxTrisSpin->Enable();
			break;
		}
		break;

    case CC_SPINNER_CHANGE:
		switch ( LOWORD(wParam) ) {
		case IDC_TESS_MIN_REC_SPINNER:
			sParams.mMin = psMinSpin->GetIVal();
			psMinSpin->SetLimits(0, sParams.mMax, FALSE);
			psMaxSpin->SetLimits(sParams.mMin, MAX_SUBDIV, FALSE);
			break;
		case IDC_TESS_MAX_REC_SPINNER:
			sParams.mMax = psMaxSpin->GetIVal();
			psMinSpin->SetLimits(0, sParams.mMax, FALSE);
			psMaxSpin->SetLimits(sParams.mMin, MAX_SUBDIV, FALSE);
			break;
		case IDC_TESS_MAX_TRIS_SPINNER:
			sParams.mTris = psMaxTrisSpin->GetIVal();
			break;
		}
		break;

	case WM_DESTROY:
		if( psMinSpin ) {
			ReleaseISpinner(psMinSpin);
			psMinSpin = NULL;
		}
		if( psMaxSpin ) {
			ReleaseISpinner(psMaxSpin);
			psMaxSpin = NULL;
		}
		if( psMaxTrisSpin ) {
			ReleaseISpinner(psMaxTrisSpin);
			psMaxTrisSpin = NULL;
		}
		break;
	}

	return FALSE;
}

void
DispApproxMod::BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev)
{
    if (!mshWnd) {
		mshWnd = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_DISP_APPROX),
			DispApproxDlgProc,
			GetString(IDS_CT_DISP_APPROX), 
			(LPARAM)this, 0);
	}
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	SetAFlag(A_MOD_BEING_EDITED);
}

void
DispApproxMod::EndEditParams(IObjParam *ip,ULONG flags,Animatable *next)
{
	ip->ClearPickMode ();
    if (flags & END_EDIT_REMOVEUI) {
        ip->DeleteRollupPage(mshWnd);
        mshWnd = NULL;
    }

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
}


void
DispApproxMod::SetDisplacmentApproxToPreset(int preset)
{
	TriObject t;
	t.SetDisplacmentApproxToPreset(preset);
	TessApprox approx = t.DisplacmentApprox();
	mApprox = approx;
}














MeshMesherMod::MeshMesherMod()
{
	SetDisplacmentApproxToPreset(1);
	mDoSubdiv = TRUE;
	mCustomApprox = FALSE;
}

#define MESHER_APPROX_CHUNKID		5000
#define MESHER_DO_SUBDIV_CHUNKID	5001
#define MESHER_CUSTOM_CHUNKID		5002
#define MESHER_SPLITMESH_CHUNKID	5003
#define MESHER_MOD_CHUNK            5004

IOResult
MeshMesherMod::Save(ISave *isave)
{
	IOResult res;
	ULONG nb;
	isave->BeginChunk(MESHER_APPROX_CHUNKID);
	res = mApprox.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(MESHER_DO_SUBDIV_CHUNKID);
	BOOL subdiv = mDoSubdiv?TRUE:FALSE;
	isave->Write(&subdiv, sizeof(BOOL), &nb);
	isave->EndChunk();

	isave->BeginChunk(MESHER_SPLITMESH_CHUNKID);
	BOOL split = mSplitMesh?TRUE:FALSE;
	isave->Write(&split, sizeof(BOOL), &nb);
	isave->EndChunk();

	isave->BeginChunk(MESHER_CUSTOM_CHUNKID);
	BOOL cust = mCustomApprox?TRUE:FALSE;
	isave->Write(&cust, sizeof(BOOL), &nb);
	isave->EndChunk();

	isave->BeginChunk(MESHER_MOD_CHUNK);
    Modifier::Save(isave);
	isave->EndChunk();
	return res;
}


IOResult
MeshMesherMod::Load(ILoad *iload)
{
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
		case MESHER_APPROX_CHUNKID:
			mApprox.Load(iload);
			break;
        case MESHER_DO_SUBDIV_CHUNKID: {
			BOOL subdiv;
            iload->Read(&subdiv, sizeof(BOOL), &nb);
			mDoSubdiv = subdiv?true:false;
            break; }
        case MESHER_SPLITMESH_CHUNKID: {
			BOOL split;
            iload->Read(&split, sizeof(BOOL), &nb);
			mSplitMesh = split?true:false;
            break; }
        case MESHER_CUSTOM_CHUNKID: {
			BOOL cust;
            iload->Read(&cust, sizeof(BOOL), &nb);
			mCustomApprox = cust?true:false;
            break; }
        case MESHER_MOD_CHUNK:
            Modifier::Load(iload);
            break;

		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	return IO_OK;
}

void
MeshMesherMod::BeginEditParams(IObjParam  *ip, ULONG flags,Animatable *prev)
{
    if (!mshWnd) {
		mshWnd = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_MESHER_DISP_APPROX),
			DispApproxDlgProc,
			GetString(IDS_CT_DISP_APPROX), 
			(LPARAM)this, 0);
	}
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	SetAFlag(A_MOD_BEING_EDITED);
}

void
MeshMesherMod::EndEditParams(IObjParam *ip,ULONG flags,Animatable *next)
{
	ip->ClearPickMode ();
    if (flags & END_EDIT_REMOVEUI) {
        ip->DeleteRollupPage(mshWnd);
        mshWnd = NULL;
    }

	// NOTE: This flag must be cleared before sending the REFMSG_END_EDIT
	ClearAFlag(A_MOD_BEING_EDITED);
	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
}


void
MeshMesherMod::SetDisplacmentApproxToPreset(int preset)
{
	TriObject t;
	t.SetDisplacmentApproxToPreset(preset);
	TessApprox approx = t.DisplacmentApprox();
	mApprox = approx;
}


class MesherOrthoView : public View {
public:
    MesherOrthoView() {
        projType = 1; // orthographic
        pixelSize = 1.0f;
        screenH = 10.0f;
        screenW = 10.0f;
    }
    virtual Point2 ViewToScreen(Point3 p) { return Point2(0.0f,0.0f); }
};

static int LoadAllMapFiles(Texmap *tm,TimeValue t) 
{
	tm->LoadMapFiles(t);
	for (int i=0; i<tm->NumSubTexmaps(); i++) {
		Texmap *st = tm->GetSubTexmap(i); 
		if (st) 
			LoadAllMapFiles(st,t);
    }
	return 1;
}

// CALL THIS TO LOAD ALL DISPLACEMENT MAPS IN THE MATERIAL
static int LoadDisplaceMaps(MtlBase *mb, TimeValue t) 
{
	for (int i=0; i<mb->NumSubTexmaps(); i++) {
		Texmap *st = mb->GetSubTexmap(i); 
		if (st) {
			if (mb->MapSlotType(i)==MAPSLOT_DISPLACEMENT) 
				LoadAllMapFiles(st,t);
			else
				LoadDisplaceMaps(st,t);
        }
    }
	if (IsMtl(mb)) {
		Mtl *m = (Mtl *)mb;
		for (i=0; i<m->NumSubMtls(); i++) {
			Mtl *sm = m->GetSubMtl(i);
			if (sm) 
				LoadDisplaceMaps(sm,t);
        }
    }
	return 1;
}



void
MeshMesherMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{
    // Update the material.  When loading a file, it might not be up to date yet.
    if (node) {
        Mtl* pMtl = node->GetMtl();
        if (pMtl) {
            pMtl->Validity(t);
            LoadDisplaceMaps(pMtl, t);
        }
    }

	TriObject *pInTriObj = (TriObject*)os->obj;
	if (!pInTriObj->CanDoDisplacementMapping())
		return;

	if (mCustomApprox) {
		pInTriObj->DoSubdivisionDisplacment() = mDoSubdiv;
		pInTriObj->SplitMeshForDisplacement() = mSplitMesh;
		pInTriObj->DisplacmentApprox() = mApprox;
	}

    TriObject *pTriObj = CreateNewTriObject();
	pTriObj->DisableDisplacementMapping(TRUE);

    MesherOrthoView view;
	BOOL needDelete = FALSE;
    Mesh* pMesh = pInTriObj->GetRenderMesh(t, node, view, needDelete);
    pTriObj->GetMesh() = *pMesh;

	if (needDelete)
		delete pMesh;

	Interval tmValid = FOREVER;

	// Make sure the object's points are in world space. We do this
	// by multiplying by the ObjectState TM. If the points are
	// already in world space this matrix will be NULL so
	// there is no need to do this. Otherwise we will transform
	// the points by this TM thus putting them in world space.
	if (os->GetTM()) {
		Matrix3 tm = *(os->GetTM());
        int nVerts = pTriObj->GetMesh().getNumVerts();
		for (int i=0; i<nVerts; i++)
			pTriObj->GetMesh().verts[i] = pTriObj->GetMesh().verts[i]*tm;

		// Set the geometry channel interval to be the same
		// as the ObjectState TM interval since its validity
		// now governs the interval of the modified points
        tmValid &= os->tmValid();
		// Once the points are transformed the matrix needs to set to NULL
		os->SetTM(NULL, FOREVER);
	}

	Interval valid = FOREVER;

    valid &= os->obj->ChannelValidity(t, GEOM_CHAN_NUM);
    valid &= os->obj->ChannelValidity(t, TOPO_CHAN_NUM);
    valid &= os->obj->ChannelValidity(t, TEXMAP_CHAN_NUM);
    valid &= os->obj->ChannelValidity(t, DISP_APPROX_CHAN_NUM);

	pTriObj->SetChannelValidity(TOPO_CHAN_NUM, valid);
	pTriObj->SetChannelValidity(GEOM_CHAN_NUM, valid);
	pTriObj->SetChannelValidity(TEXMAP_CHAN_NUM, valid);

    pTriObj->SetChannelValidity(MTL_CHAN_NUM, valid);
    pTriObj->SetChannelValidity(SELECT_CHAN_NUM, valid);
    pTriObj->SetChannelValidity(SUBSEL_TYPE_CHAN_NUM, valid);
    
	pTriObj->SetChannelValidity(DISP_APPROX_CHAN_NUM, valid);

    os->obj = pTriObj;
    os->obj->UpdateValidity(GEOM_CHAN_NUM, LocalValidity(t) & tmValid);	
	
	// RB 3/9/99: Gotta unlock the object since nobody owns it yet.
	os->obj->UnlockObject();
}


RefTargetHandle 
MeshMesherMod::Clone(RemapDir& remap)
{
    MeshMesherMod* pMod = new MeshMesherMod();
	pMod->mApprox = mApprox;
	pMod->mDoSubdiv = mDoSubdiv;
	pMod->mSplitMesh = mSplitMesh;
	pMod->mCustomApprox = mCustomApprox;
    return pMod;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\dispmod.cpp ===
/**********************************************************************
 *<
	FILE: dispmod.cpp

	DESCRIPTION:  Displacement mapping modifier

	CREATED BY: Rolf Berteig

	HISTORY: 10/21/95

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "iparamm.h"
#include "bmmlib.h"
#include "texutil.h"
#include "simpobj.h"
#include "simpmod.h"
#include "mapping.h"
#include "sctex.h"

#define IDC_SET_MAPNAME 0x9999

class DispMod : public MappingMod {	
	public:
		IParamBlock *pblock;		
		Bitmap *thebm;
		BitmapInfo bi;
		Texmap *tmap;

		static IParamMap *pmapParam;
		static MoveModBoxCMode *moveMode;
		static RotateModBoxCMode *rotMode;
		static UScaleModBoxCMode *uscaleMode;
		static NUScaleModBoxCMode *nuscaleMode;
		static SquashModBoxCMode *squashMode;		
		static FaceAlignMode *faceAlignMode;
		static RegionFitMode *regionFitMode;
		static PickAcquire pickAcquire;
		static DispMod *editMod;

		DispMod(BOOL create);
		~DispMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_DISPMOD); }  
		virtual Class_ID ClassID() { return Class_ID(DISPLACEOSM_CLASS_ID,0);}
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() { return GetString(IDS_RB_DISPLACE); }
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		BOOL AssignController(Animatable *control,int subAnim);
		int SubNumToRefNum(int subNum);

		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE|TEXMAP_CHANNEL;}
		ChannelMask ChannelsChanged() {return PART_GEOM|TEXMAP_CHANNEL; }		
		Class_ID InputType() {return defObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);

		int NumRefs() {return 3;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);
		void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) {
			bi.EnumAuxFiles(nameEnum,flags);
			if (tmap) tmap->EnumAuxFiles(nameEnum,flags);
			}

		int NumSubs() {return 3;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);

		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
		
		void FreeBitmap();
		void LoadBitmap();
		void SetImageTime(TimeValue t);
	
		void ActivateSubobjSel(int level, XFormModes& modes);

		// From mapping mod
		void EnterNormalAlign();
		void ExitNormalAlign();
		void EnterRegionFit();
		void ExitRegionFit();
		int GetMapType();
		void SetMapType(int type);
		int GetMapChannel ();
		void SetMapChannel (int chan);
		float GetTile(TimeValue t,int which);
		void SetTile(TimeValue t,int which, float tile);
		BOOL GetFlip(int which);
		void SetFlip(int which,BOOL flip);
		void EnterAcquire();
		void ExitAcquire();
		float GetLength(TimeValue t);
		float GetWidth(TimeValue t);
		float GetHeight(TimeValue t);
		int GetAxis();
		void SetLength(TimeValue t,float v);
		void SetWidth(TimeValue t,float v);
		void SetHeight(TimeValue t,float v);
		void SetAxis(int v);
		int GetFirstParamVer() {return 5;}
		int GetPBlockVersion() {return pblock->GetVersion();}
	};


class DisplaceObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		Bitmap *thebm;
		BitmapInfo bi;
		Texmap *tmap;
		BOOL initParams;

		DisplaceObject();		
		~DisplaceObject();

		void FreeBitmap();
		void LoadBitmap();
		void SetImageTime(TimeValue t);

		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev );
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() {return GetString(IDS_RB_DISPLACE);}
		Class_ID ClassID() {return Class_ID(DISPLACE_OBJECT_CLASS_ID,0);}		
		void EnumAuxFiles(NameEnumCallback& nameEnum, DWORD flags) {
			bi.EnumAuxFiles(nameEnum,flags);
			if (tmap) tmap->EnumAuxFiles(nameEnum,flags);
			}
		int NumSubs() {return 2;}  
		Animatable* SubAnim(int i) {return GetReference(i);}
		TSTR SubAnimName(int i) 
			{if (i==0) return SimpleWSMObject::SubAnimName(i); else return _T("Displacement Map");}
		
		// from object		
		int DoOwnSelectHilite() {return TRUE;}
		CreateMouseCallBack* GetCreateMouseCallBack();		

		// From ref
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i) { if (i==0) return pblock; else return tmap;}
		void SetReference(int i, RefTargetHandle rtarg);			

		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
		ForceField *GetForceField(INode *node);

		void BuildMesh(TimeValue);
		void InvalidateUI();
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
	};

class DisplaceField : public ForceField {
	public:
		DisplaceObject *dobj;		
		Bitmap *thebm;
		INode *node;
		Matrix3 tm, invtm;
		Interval tmValid;
		Point3 Force(TimeValue t,const Point3 &pos, const Point3 &vel,int index);
		void DeleteThis() {delete this;} // RB 5/12/99
	};

class DisplaceWSMod : public SimpleWSMMod {
	public:
		DisplaceField force;

		DisplaceWSMod() {}
		DisplaceWSMod(INode *node,DisplaceObject *obj);		

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From Animatable
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_DISPLACEMOD);}
		SClass_ID SuperClassID() { return WSM_CLASS_ID; }		
		void DeleteThis() {delete this;}		
		Class_ID ClassID() { return Class_ID(DISPLACE_WSM_CLASS_ID,0); } 		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_RB_DISPLACEBINDING);}
		
		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};


//--- ClassDescriptor and class vars ---------------------------------

IParamMap*          DispMod::pmapParam     = NULL;
MoveModBoxCMode*    DispMod::moveMode      = NULL;
RotateModBoxCMode*  DispMod::rotMode       = NULL;
UScaleModBoxCMode*  DispMod::uscaleMode    = NULL;
NUScaleModBoxCMode* DispMod::nuscaleMode   = NULL;
SquashModBoxCMode*  DispMod::squashMode    = NULL;
FaceAlignMode*      DispMod::faceAlignMode = NULL;
RegionFitMode*      DispMod::regionFitMode = NULL;
PickAcquire         DispMod::pickAcquire;
DispMod*            DispMod::editMod       = NULL;

class DispClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new DispMod(!loading); }
	const TCHAR *	ClassName() { return GetString(IDS_RB_DISPLACE_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(DISPLACEOSM_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static DispClassDesc dispDesc;
extern ClassDesc* GetDispModDesc() {return &dispDesc;}


IParamMap *DisplaceObject::pmapParam = NULL;
IObjParam *DisplaceObject::ip        = NULL;
HWND       DisplaceObject::hSot      = NULL;

class DispObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new DisplaceObject;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_DISPLACE_CLASS);}
	SClass_ID		SuperClassID() { return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return Class_ID(DISPLACE_OBJECT_CLASS_ID,0);}
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF);}
	};

static DispObjClassDesc dispObjDesc;
extern ClassDesc* GetDispObjDesc() {return &dispObjDesc;}


class DispWSModeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) {return new DisplaceWSMod;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_DISPLACE_CLASS);}
	SClass_ID		SuperClassID() { return WSM_CLASS_ID; }
	Class_ID		ClassID() {return Class_ID(DISPLACE_WSM_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static DispWSModeClassDesc dispWSModDesc;
extern ClassDesc* GetDispWSModDesc() {return &dispWSModDesc;}

//--- Parameter map/block descriptors -------------------------------

#define PB_MAPTYPE		0
#define PB_UTILE		1
#define PB_VTILE		2
#define PB_WTILE		3
#define PB_BLUR			4
#define PB_USEMAP		5
#define PB_APPLYMAP		6
#define PB_STRENGTH		7
#define PB_DECAY		8
#define PB_CENTERLUM	9
#define PB_UFLIP		10
#define PB_VFLIP		11
#define PB_WFLIP		12
#define PB_CENTERL		13
#define PB_CAP			14
#define PB_LENGTH		15
#define PB_WIDTH		16
#define PB_HEIGHT		17
#define PB_AXIS			18
#define PB_CHANNEL  19
#define PB_MAPCHANNEL 20

//
//
// Parameters

static int mapIDs[] = {IDC_DISP_PLANAR,IDC_DISP_CYL,IDC_DISP_SPHERE,IDC_DISP_BALL};
static int axisIDs[] = {IDC_DISP_X,IDC_DISP_Y,IDC_DISP_Z};
static int chanIDs[] = { IDC_DISP_TEXMAP, IDC_DISP_VERTCOL };

static ParamUIDesc descParam[] = {
	// Map type
	ParamUIDesc(PB_MAPTYPE,TYPE_RADIO,mapIDs,4),
	
	// U Tile
	ParamUIDesc(
		PB_UTILE,
		EDITTYPE_FLOAT,
		IDC_DISP_UTILE,IDC_DISP_UTILESPIN,
		-999999999.0f,999999999.0f,
		0.01f),

	// V Tile
	ParamUIDesc(
		PB_VTILE,
		EDITTYPE_FLOAT,
		IDC_DISP_VTILE,IDC_DISP_VTILESPIN,
		-999999999.0f,999999999.0f,
		0.01f),

	// W Tile
	ParamUIDesc(
		PB_WTILE,
		EDITTYPE_FLOAT,
		IDC_DISP_WTILE,IDC_DISP_WTILESPIN,
		-999999999.0f,999999999.0f,
		0.01f),

	// Blur
	ParamUIDesc(
		PB_BLUR,
		EDITTYPE_FLOAT,
		IDC_DISP_BLUR,IDC_DISP_BLURSPIN,
		0.0f,10.0f,
		0.01f),	

	// Strength
	ParamUIDesc(
		PB_STRENGTH,
		EDITTYPE_UNIVERSE,
		IDC_DISP_STRENGTH,IDC_DISP_STRENGTHSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),
	
	// Decay
	ParamUIDesc(
		PB_DECAY,
		EDITTYPE_FLOAT,
		IDC_DISP_DECAY,IDC_DISP_DECAYSPIN,
		-999999999.0f,999999999.0f,
		0.005f),
	
	// Center lum
	ParamUIDesc(PB_CENTERLUM,TYPE_SINGLECHEKBOX,IDC_DISP_CENTERLUM),

	// U Flip
	ParamUIDesc(PB_UFLIP,TYPE_SINGLECHEKBOX,IDC_DISP_UFLIP),

	// V Flip
	ParamUIDesc(PB_VFLIP,TYPE_SINGLECHEKBOX,IDC_DISP_VFLIP),

	// W Flip
	ParamUIDesc(PB_WFLIP,TYPE_SINGLECHEKBOX,IDC_DISP_WFLIP),	

	// Center
	ParamUIDesc(
		PB_CENTERL,
		EDITTYPE_FLOAT,
		IDC_DISP_CENTERL,IDC_DISP_CENTERLSPIN,
		0.0f,1.0f,
		0.005f),	

	// Length
	ParamUIDesc(
		PB_LENGTH,
		EDITTYPE_UNIVERSE,
		IDC_DISP_LENGTH,IDC_DISP_LENGTHSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Width
	ParamUIDesc(
		PB_WIDTH,
		EDITTYPE_UNIVERSE,
		IDC_DISP_WIDTH,IDC_DISP_WIDTHSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),

	// Height
	ParamUIDesc(
		PB_HEIGHT,
		EDITTYPE_UNIVERSE,
		IDC_DISP_HEIGHT,IDC_DISP_HEIGHTSPIN,
		-999999999.0f,999999999.0f,
		SPIN_AUTOSCALE),
	
	// Cap
	ParamUIDesc(PB_CAP,TYPE_SINGLECHEKBOX,IDC_DISP_CAP),

	// Axis
	ParamUIDesc(PB_AXIS,TYPE_RADIO,axisIDs,3),

	// Use existing mapping
	ParamUIDesc(PB_USEMAP,TYPE_SINGLECHEKBOX,IDC_DISP_USEMAP),

	// Apply mapping
	ParamUIDesc(PB_APPLYMAP,TYPE_SINGLECHEKBOX,IDC_DISP_APPLYMAP),	
	
	// Texture map or vertex color channel?
	ParamUIDesc (PB_CHANNEL, TYPE_RADIO, chanIDs, 2),

	// Which map channel?
	ParamUIDesc (PB_MAPCHANNEL, EDITTYPE_POS_INT,
		IDC_DISP_CHAN, IDC_DISP_CHAN_SPIN, 1, MAX_MESHMAPS-1, SPIN_AUTOSCALE),
	};
#define PARAMDESC_LENGH 21
#define PARAMDESC_LENGH_SW 16

static ParamBlockDescID descVer0[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },	
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },	
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_INT, NULL, FALSE, 6 }
};

static ParamBlockDescID descVer1[] = {
	{ TYPE_INT, NULL, FALSE, 0 },	
	{ TYPE_FLOAT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, TRUE, 2 },	
	{ TYPE_FLOAT, NULL, TRUE, 7 },
	{ TYPE_INT, NULL, FALSE, 3 },
	{ TYPE_INT, NULL, FALSE, 4 },	
	{ TYPE_FLOAT, NULL, TRUE, 5 },
	{ TYPE_FLOAT, NULL, TRUE, 8 },
	{ TYPE_INT, NULL, FALSE, 6 }};

static ParamBlockDescID descVer2[] = {
	{ TYPE_INT, NULL, FALSE, 0 },		// map type
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// utile
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// vtile
	{ TYPE_FLOAT, NULL, TRUE, 9 },		// wtile
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// blur
	{ TYPE_INT, NULL, FALSE, 3 },		// use map
	{ TYPE_INT, NULL, FALSE, 4 },		// apply map
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// strength
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// decay
	{ TYPE_INT, NULL, FALSE, 6 },		// center lum
	{ TYPE_INT, NULL, FALSE, 10 },		// U flip
	{ TYPE_INT, NULL, FALSE, 11 },		// V flip
	{ TYPE_INT, NULL, FALSE, 12 },		// W flip	
	};		

static ParamBlockDescID descVer3[] = {
	{ TYPE_INT, NULL, FALSE, 0 },		// map type
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// utile
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// vtile
	{ TYPE_FLOAT, NULL, TRUE, 9 },		// wtile
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// blur
	{ TYPE_INT, NULL, FALSE, 3 },		// use map
	{ TYPE_INT, NULL, FALSE, 4 },		// apply map
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// strength
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// decay
	{ TYPE_INT, NULL, FALSE, 6 },		// center lum
	{ TYPE_INT, NULL, FALSE, 10 },		// U flip
	{ TYPE_INT, NULL, FALSE, 11 },		// V flip
	{ TYPE_INT, NULL, FALSE, 12 },		// W flip	
	{ TYPE_FLOAT, NULL, TRUE, 13 },		// center L
	};		

static ParamBlockDescID descVer4[] = {
	{ TYPE_INT, NULL, FALSE, 0 },		// map type
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// utile
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// vtile
	{ TYPE_FLOAT, NULL, TRUE, 9 },		// wtile
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// blur
	{ TYPE_INT, NULL, FALSE, 3 },		// use map
	{ TYPE_INT, NULL, FALSE, 4 },		// apply map
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// strength
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// decay
	{ TYPE_INT, NULL, FALSE, 6 },		// center lum
	{ TYPE_INT, NULL, FALSE, 10 },		// U flip
	{ TYPE_INT, NULL, FALSE, 11 },		// V flip
	{ TYPE_INT, NULL, FALSE, 12 },		// W flip	
	{ TYPE_FLOAT, NULL, TRUE, 13 },		// center L
	{ TYPE_INT, NULL, FALSE, 14 },		// cap
	};		

static ParamBlockDescID descVer5[] = {
	{ TYPE_INT, NULL, FALSE, 0 },		// map type
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// utile
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// vtile
	{ TYPE_FLOAT, NULL, TRUE, 9 },		// wtile
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// blur
	{ TYPE_INT, NULL, FALSE, 3 },		// use map
	{ TYPE_INT, NULL, FALSE, 4 },		// apply map
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// strength
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// decay
	{ TYPE_INT, NULL, FALSE, 6 },		// center lum
	{ TYPE_INT, NULL, FALSE, 10 },		// U flip
	{ TYPE_INT, NULL, FALSE, 11 },		// V flip
	{ TYPE_INT, NULL, FALSE, 12 },		// W flip	
	{ TYPE_FLOAT, NULL, TRUE, 13 },		// center L
	{ TYPE_INT, NULL, FALSE, 14 },		// cap
	{ TYPE_FLOAT, NULL, TRUE, 15 },		// length
	{ TYPE_FLOAT, NULL, TRUE, 16 },		// width
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// height
	{ TYPE_INT, NULL, FALSE, 18 },		// axis
	};		

static ParamBlockDescID descVer6[] = {
	{ TYPE_INT, NULL, FALSE, 0 },		// map type
	{ TYPE_FLOAT, NULL, TRUE, 1 },		// utile
	{ TYPE_FLOAT, NULL, TRUE, 2 },		// vtile
	{ TYPE_FLOAT, NULL, TRUE, 9 },		// wtile
	{ TYPE_FLOAT, NULL, TRUE, 7 },		// blur
	{ TYPE_INT, NULL, FALSE, 3 },		// use map
	{ TYPE_INT, NULL, FALSE, 4 },		// apply map
	{ TYPE_FLOAT, NULL, TRUE, 5 },		// strength
	{ TYPE_FLOAT, NULL, TRUE, 8 },		// decay
	{ TYPE_INT, NULL, FALSE, 6 },		// center lum
	{ TYPE_INT, NULL, FALSE, 10 },		// U flip
	{ TYPE_INT, NULL, FALSE, 11 },		// V flip
	{ TYPE_INT, NULL, FALSE, 12 },		// W flip	
	{ TYPE_FLOAT, NULL, TRUE, 13 },		// center L
	{ TYPE_INT, NULL, FALSE, 14 },		// cap
	{ TYPE_FLOAT, NULL, TRUE, 15 },		// length
	{ TYPE_FLOAT, NULL, TRUE, 16 },		// width
	{ TYPE_FLOAT, NULL, TRUE, 17 },		// height
	{ TYPE_INT, NULL, FALSE, 18 },		// axis
	{ TYPE_INT, NULL, FALSE, PB_CHANNEL },
	{ TYPE_INT, NULL, FALSE, PB_MAPCHANNEL },
	};		

#define PBLOCK_LENGTH	21


// Array of old versions
static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,7,0),
	ParamVersionDesc(descVer1,9,1),
	ParamVersionDesc(descVer2,13,2),
	ParamVersionDesc(descVer3,14,3),
	ParamVersionDesc(descVer4,15,4),
	ParamVersionDesc(descVer5,19,5),
	};
#define NUM_OLDVERSIONS	6

// Current version
#define CURRENT_VERSION	6
static ParamVersionDesc curVersion(descVer6,PBLOCK_LENGTH,CURRENT_VERSION);


//--- DispDlgProc -------------------------------------------------------

class DispDlgProc : public ParamMapUserDlgProc, DADMgr {
	public:
		HWND hWnd;
		DispMod *mod;
		DisplaceObject *obj;
		DispDlgProc(DispMod *m) {mod = m;obj = NULL;}
		DispDlgProc(DisplaceObject *o) {mod = NULL;obj = o;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void DoBitmapFit(HWND hWnd);
		void SetImageName(HWND hWnd);
		void PickImage(HWND hWnd);
		void RemoveImage(HWND hWnd);
		void SetMapName(HWND hWnd);
		void PickMap(HWND hWnd);
		void RemoveMap(HWND hWnd);
		void DeleteThis() {delete this;}
		void RedrawViews() { 
			Interface *ip = obj?obj->ip:mod->ip;
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
			}
		// From DADMgr
		SClass_ID GetDragType(HWND hwnd, POINT p) {
			if (hwnd == GetDlgItem(hWnd,IDC_DISP_PICKMAP)) 
				return TEXMAP_CLASS_ID;
			if (hwnd == GetDlgItem(hWnd,IDC_DISP_PICKIMAGE)) 
				return BITMAPDAD_CLASS_ID;
			else return NULL;
			}		
		BOOL OkToDrop(ReferenceTarget *dropThis, HWND hfrom, HWND hto, POINT p, SClass_ID type, BOOL isNew) {
			if (hfrom==hto) return FALSE;
			if (hto == GetDlgItem(hWnd,IDC_DISP_PICKMAP)) 
				return type==TEXMAP_CLASS_ID;
			if (hto == GetDlgItem(hWnd,IDC_DISP_PICKIMAGE)) 
				return type==BITMAPDAD_CLASS_ID;
			return NULL;
			}
		int SlotOwner() {return OWNER_SCENE;}
		ReferenceTarget *GetInstance(HWND hwnd, POINT p, SClass_ID type) {
			if (hwnd == GetDlgItem(hWnd,IDC_DISP_PICKMAP)) {
				return obj? obj->tmap: mod->tmap;
				}
			if (hwnd == GetDlgItem(hWnd,IDC_DISP_PICKIMAGE)) {
				DADBitmapCarrier *bmc = GetDADBitmapCarrier();
				BitmapInfo *pbi = obj? &obj->bi: &mod->bi;
				TSTR nm = pbi->Name();
				bmc->SetName(nm);
				return bmc;
				}
			return NULL;
			}
		void Drop(ReferenceTarget *dropThis, HWND hwnd, POINT p, SClass_ID type) {
			if (hwnd == GetDlgItem(hWnd,IDC_DISP_PICKMAP)) {
				if (mod) {
					mod->ReplaceReference(2,dropThis);
					mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
					mod->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
				} else {
					obj->ReplaceReference(1,dropThis);
					obj->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
					obj->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
					}
				RedrawViews();
				SetMapName(hWnd);
				}
			else if (hwnd == GetDlgItem(hWnd,IDC_DISP_PICKIMAGE)) {
				assert(dropThis->SuperClassID()==BITMAPDAD_CLASS_ID);
				DADBitmapCarrier *bmc = (DADBitmapCarrier*)dropThis;
				if (mod) {
					mod->bi.SetName(bmc->GetName());	
					mod->FreeBitmap();
					mod->LoadBitmap();
					mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
				} else {
					assert(obj);
					obj->bi.SetName(bmc->GetName());	
					obj->FreeBitmap();
					obj->LoadBitmap();
					obj->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
					}
				RedrawViews();
				SetImageName(hWnd);
				}
			}
		BOOL AutoTooltip() { return TRUE; }
	};


static void GetBMName(BitmapInfo& bi, TSTR &fname) { 
	TSTR fullName;
	if (bi.Name()[0]==0)
		fullName = bi.Device();
	else 
		fullName =  bi.Name();
	SplitPathFile(fullName,NULL,&fname);
	}

void DispDlgProc::SetImageName(HWND hWnd)
	{ 	
	/*
	if ((mod&&mod->thebm) || (obj&&obj->thebm)) {
		TSTR fname;
		if (mod) 
			GetBMName(mod->bi, fname); 
		else 
			GetBMName(obj->bi, fname); 
		SetDlgItemText(hWnd, IDC_DISP_PICKIMAGE,fname);
	} else {
		SetDlgItemText(hWnd, IDC_DISP_PICKIMAGE, GetString(IDS_RB_NONE));
		}
	*/
	// RB 3/2/98: Display the name even if the bitmap can't be found.
	TSTR fname;
	if (mod) GetBMName(mod->bi, fname);
	if (obj) GetBMName(obj->bi, fname);
	
	if (fname.length()>0) 
		 SetDlgItemText(hWnd, IDC_DISP_PICKIMAGE,fname);
	else SetDlgItemText(hWnd, IDC_DISP_PICKIMAGE, GetString(IDS_RB_NONE));
	InvalidateRect(GetDlgItem(hWnd,IDC_DISP_PICKIMAGE),NULL,TRUE);
	
	// RB 3/16/99: This is the right way to set text for a custom button.
	// there seems to be a problem refreshing the button when SetDlgItemText() is used.
	/*
	ICustButton *but = GetICustButton(GetDlgItem(hWnd, IDC_DISP_PICKIMAGE));
	if (but) {
		if (fname.length()>0) 
			 but->SetText(fname);
		else but->SetText(GetString(IDS_RB_NONE));
		ReleaseICustButton(but);
		}
		*/
	}

void DispDlgProc::PickImage(HWND hWnd)
	{	
	BitmapInfo *bi = mod ? &mod->bi : &obj->bi;
	if(TheManager->SelectFileInputEx(
		bi, GetCOREInterface()->GetMAXHWnd(), GetString(IDS_RB_SELECTDISPIMAGE)))
		{
		if (mod) {
			mod->FreeBitmap();
			mod->LoadBitmap();
			mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
		} else {
			obj->FreeBitmap();
			obj->LoadBitmap();
			obj->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
			}
		SetImageName(hWnd);
		}
	}

void DispDlgProc::RemoveImage(HWND hWnd)
	{
	if (mod) {
		mod->bi.SetName(_T(""));
		mod->bi.SetDevice(_T(""));
		mod->FreeBitmap();
		mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
	} else {
		obj->bi.SetName(_T(""));
		obj->bi.SetDevice(_T(""));
		obj->FreeBitmap();
		obj->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
		}
	SetImageName(hWnd);
	}

void DispDlgProc::SetMapName(HWND hWnd)
	{
	if ((mod&&mod->tmap) || (obj&&obj->tmap)) {
		TSTR fname;
		if (mod)  fname = mod->tmap->GetFullName();
		else      fname = obj->tmap->GetFullName();		
		SetDlgItemText(hWnd, IDC_DISP_PICKMAP,fname);
		InvalidateRect(GetDlgItem(hWnd,IDC_DISP_PICKMAP),NULL,TRUE);
	} else {
		SetDlgItemText(hWnd, IDC_DISP_PICKMAP, GetString(IDS_RB_NONE));
		InvalidateRect(GetDlgItem(hWnd,IDC_DISP_PICKMAP),NULL,TRUE);
		}
	}

void DispDlgProc::PickMap(HWND hWnd)
	{
	BOOL newMat=FALSE, cancel=FALSE;
	Interface *ip = mod?mod->ip:obj->ip;
	MtlBase *mtl = ip->DoMaterialBrowseDlg(
		GetCOREInterface()->GetMAXHWnd(),
		BROWSE_MAPSONLY|BROWSE_INCNONE|BROWSE_INSTANCEONLY,
		newMat,cancel);
	if (cancel) {
		if (newMat) mtl->DeleteThis();
		return;
		}
	if (mod) {
		mod->ReplaceReference(2,mtl);
		mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
		mod->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	} else {
		obj->ReplaceReference(1,mtl);
		obj->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
		obj->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
		}
	SetMapName(hWnd);
	}

void DispDlgProc::RemoveMap(HWND hWnd)
	{
	if (mod) {
		mod->ReplaceReference(2,NULL);
		mod->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
		mod->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
	} else {
		obj->ReplaceReference(1,NULL);
		obj->NotifyDependents(FOREVER,PART_GEOM,REFMSG_CHANGE);
		obj->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
		}
	SetMapName(hWnd);
	}

void DispDlgProc::DoBitmapFit(HWND hWnd)
	{
	BitmapInfo bi;
	if (TheManager->SelectFileInputEx(
		&bi, GetCOREInterface()->GetMAXHWnd(), GetString(IDS_RB_SELECTIMAGE)))
		{		
		TheManager->GetImageInfo(&bi);
		mod->aspect = bi.Aspect() * float(bi.Width())/float(bi.Height());
		mod->flags |= CONTROL_ASPECT|CONTROL_HOLD;
		mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
		}
	}

BOOL DispDlgProc::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG: {
			this->hWnd = hWnd;
			SendMessage(GetDlgItem(hWnd,IDC_DISP_FITREGION),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SendMessage(GetDlgItem(hWnd,IDC_DISP_FITREGION),CC_COMMAND,CC_CMD_HILITE_COLOR,GREEN_WASH);
			SendMessage(GetDlgItem(hWnd,IDC_DISP_NORMALALIGN),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SendMessage(GetDlgItem(hWnd,IDC_DISP_NORMALALIGN),CC_COMMAND,CC_CMD_HILITE_COLOR,GREEN_WASH);
			SendMessage(GetDlgItem(hWnd,IDC_DISP_ACQUIRE),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SendMessage(GetDlgItem(hWnd,IDC_DISP_ACQUIRE),CC_COMMAND,CC_CMD_HILITE_COLOR,GREEN_WASH);
			SetImageName(hWnd);
			SetMapName(hWnd);
			ICustButton *but = GetICustButton(GetDlgItem(hWnd,IDC_DISP_PICKMAP));
			but->SetDADMgr(this);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hWnd,IDC_DISP_PICKIMAGE));
			but->SetDADMgr(this);
			ReleaseICustButton(but);
			break;
			}
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_DISP_SPHERE:
				case IDC_DISP_BALL:
					if (!mod) break;
					mod->flags |= CONTROL_UNIFORM|CONTROL_HOLD;
					mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
					break;

				case IDC_DISP_FIT:
					if (!mod) break;
					mod->flags |= CONTROL_FIT|CONTROL_HOLD;
					mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
					break;

				case IDC_DISP_CENTER:
					if (!mod) break;
					mod->flags |= CONTROL_CENTER|CONTROL_HOLD;
					mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
					break;

				case IDC_DISP_BITMAPFIT:
					if (!mod) break;
					DoBitmapFit(hWnd);
					break;

				case IDC_DISP_ACQUIRE:
					mod->ip->SetPickMode(&mod->pickAcquire);					
					break;

				case IDC_DISP_NORMALALIGN:
					if (!mod) break;
					if (mod->ip->GetCommandMode()->ID()==CID_FACEALIGNMAP) {
						mod->ip->SetStdCommandMode(CID_OBJMOVE);
					} else {
						mod->ip->SetCommandMode(mod->faceAlignMode);
						}
					break;

				case IDC_DISP_RESET:
					if (!mod) break;
					theHold.Begin();
					mod->ReplaceReference(TM_REF,NULL);
					mod->flags |= CONTROL_FIT|CONTROL_CENTER|CONTROL_INIT;
					theHold.Accept(0);
					mod->NotifyDependents(FOREVER,PART_TEXMAP,REFMSG_CHANGE);
					break;
				
				case IDC_SET_MAPNAME:
					SetMapName(hWnd);
					break;
				case IDC_DISP_PICKIMAGE:
					PickImage(hWnd);
					break;
				
				case IDC_DISP_REMOVEIMAGE:
					RemoveImage(hWnd);
					break;

				case IDC_DISP_PICKMAP:
					PickMap(hWnd);
					break;
				
				case IDC_DISP_REMOVEMAP:
					RemoveMap(hWnd);
					break;

				case IDC_DISP_VIEWALIGN:
					theHold.Begin();
					mod->ViewportAlign();
					theHold.Accept(0);
					break;

				case IDC_DISP_FITREGION:
					if (!mod) break;
					if (mod->ip->GetCommandMode()->ID()==CID_REGIONFIT) {
						mod->ip->SetStdCommandMode(CID_OBJMOVE);
					} else {
						mod->ip->SetCommandMode(mod->regionFitMode);
						}
					break;
				}
			break;
		}
	
	return FALSE;
	}

//--- Displace methods -------------------------------

DispMod::DispMod(BOOL create)
	{	
	SetAFlag(A_PLUGIN1);
	if (create) flags = CONTROL_CENTER|CONTROL_FIT|CONTROL_INIT;
	else flags = 0;

	MakeRefByID(FOREVER, PBLOCK_REF, 
		CreateParameterBlock(descVer6, PBLOCK_LENGTH, CURRENT_VERSION));	
	
	thebm = NULL;
	pblock->SetValue(PB_UTILE,0,1.0f);
	pblock->SetValue(PB_VTILE,0,1.0f);
	pblock->SetValue(PB_WTILE,0,1.0f);
	pblock->SetValue(PB_CENTERL,0,0.5f);
	pblock->SetValue(PB_LENGTH,0,1.0f);
	pblock->SetValue(PB_WIDTH,0,1.0f);
	pblock->SetValue(PB_HEIGHT,0,1.0f);
	pblock->SetValue(PB_AXIS,0,2);
	pblock->SetValue (PB_MAPCHANNEL, 0, 1);
	tmControl = NULL;

	tmap = NULL;
	}

DispMod::~DispMod()
	{
	FreeBitmap();
	}

void DispMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	editMod  = this;

	// Add our sub object type
	TSTR type1( GetString(IDS_RB_APPARATUS));
	const TCHAR *ptype[] = {type1};
	ip->RegisterSubObjectTypes(ptype, 1);

	// Create sub object editing modes.
	moveMode      = new MoveModBoxCMode(this,ip);
	rotMode       = new RotateModBoxCMode(this,ip);
	uscaleMode    = new UScaleModBoxCMode(this,ip);
	nuscaleMode   = new NUScaleModBoxCMode(this,ip);
	squashMode    = new SquashModBoxCMode(this,ip);	
	faceAlignMode = new FaceAlignMode(this,ip);
	regionFitMode = new RegionFitMode(this,ip);
	
	pickAcquire.mod = this;
	pickAcquire.ip  = ip;

	pmapParam = CreateCPParamMap(
		descParam,PARAMDESC_LENGH,
		pblock,
		ip,
		hInstance,
		MAKEINTRESOURCE(IDD_DISPLACEPARAM),
		GetString(IDS_RB_PARAMETERS),
		0);		
 	pmapParam->SetUserDlgProc(new DispDlgProc(this));

 	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);
	}
		
void DispMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{	
	this->ip = NULL;
	editMod  = NULL;

	TimeValue t = ip->GetTime();
	ClearAFlag(A_MOD_BEING_EDITED);
 	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);

	ip->ClearPickMode();
	pickAcquire.mod = NULL;
	pickAcquire.ip  = NULL;	

	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);	
	ip->DeleteMode(faceAlignMode);
	ip->DeleteMode(regionFitMode);
	delete moveMode; moveMode = NULL;
	delete rotMode; rotMode = NULL;
	delete uscaleMode; uscaleMode = NULL;
	delete nuscaleMode; nuscaleMode = NULL;
	delete squashMode; squashMode = NULL;
	delete faceAlignMode; faceAlignMode = NULL;
	delete regionFitMode; regionFitMode = NULL;

	DestroyCPParamMap(pmapParam);
	}

void DispMod::EnterNormalAlign()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_DISP_NORMALALIGN),CC_COMMAND,CC_CMD_SET_STATE,1);
	}

void DispMod::ExitNormalAlign()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_DISP_NORMALALIGN),CC_COMMAND,CC_CMD_SET_STATE,0);
	}

void DispMod::EnterRegionFit()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_DISP_FITREGION),CC_COMMAND,CC_CMD_SET_STATE,1);
	}

void DispMod::ExitRegionFit()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_DISP_FITREGION),CC_COMMAND,CC_CMD_SET_STATE,0);
	}

void DispMod::EnterAcquire()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_DISP_ACQUIRE),CC_COMMAND,CC_CMD_SET_STATE,1);
	}

void DispMod::ExitAcquire()
	{
	SendMessage(GetDlgItem(pmapParam->GetHWnd(),IDC_DISP_ACQUIRE),CC_COMMAND,CC_CMD_SET_STATE,0);
	}

int DispMod::GetMapType()
	{
	int type;
	pblock->GetValue(PB_MAPTYPE,0,type,FOREVER);
	return type;
	}

void DispMod::SetMapType(int type)
	{
	switch (type) {
		case MAP_PLANAR:
		case MAP_CYLINDRICAL:
		case MAP_SPHERICAL:
		case MAP_BALL:
			pblock->SetValue(PB_MAPTYPE,0,type);
			if (pmapParam) pmapParam->Invalidate();
			break;
		}
	}

int DispMod::GetMapChannel ()
	{
	int chan;
	pblock->GetValue(PB_CHANNEL,0,chan,FOREVER);
	if (chan) return 0;
	pblock->GetValue (PB_MAPCHANNEL, 0, chan, FOREVER);
	return chan;
	}

void DispMod::SetMapChannel (int chan)
	{
	if (!chan) {
		pblock->SetValue (PB_CHANNEL, 0, 1);
	} else {
		pblock->SetValue (PB_CHANNEL, 0, 0);
		pblock->SetValue (PB_MAPCHANNEL, 0, chan);
	}
}

float DispMod::GetTile(TimeValue t,int which)
	{
	float tile;
	pblock->GetValue(PB_UTILE+which,t,tile,FOREVER);
	return tile;
	}

void DispMod::SetTile(TimeValue t,int which, float tile)
	{
	pblock->SetValue(PB_UTILE+which,t,tile);
	if (pmapParam) pmapParam->Invalidate();
	}

BOOL DispMod::GetFlip(int which)
	{
	int flip;
	pblock->GetValue(PB_UFLIP+which,0,flip,FOREVER);
	return flip;
	}

void DispMod::SetFlip(int which,BOOL flip)
	{
	pblock->SetValue(PB_UFLIP+which,0,flip);
	if (pmapParam) pmapParam->Invalidate();
	}

float DispMod::GetLength(TimeValue t)
	{
	float f;
	pblock->GetValue(PB_LENGTH,t,f,FOREVER);
	return f;
	}

float DispMod::GetWidth(TimeValue t)
	{
	float f;
	pblock->GetValue(PB_WIDTH,t,f,FOREVER);
	return f;
	}

float DispMod::GetHeight(TimeValue t)
	{
	float f;
	pblock->GetValue(PB_HEIGHT,t,f,FOREVER);
	return f;
	}

int DispMod::GetAxis()
	{
	int a;
	pblock->GetValue(PB_AXIS,0,a,FOREVER);
	return a;
	}

void DispMod::SetLength(TimeValue t,float v)
	{
	pblock->SetValue(PB_LENGTH,t,v);
	}

void DispMod::SetWidth(TimeValue t,float v)
	{
	pblock->SetValue(PB_WIDTH,t,v);
	}

void DispMod::SetHeight(TimeValue t,float v)
	{
	pblock->SetValue(PB_HEIGHT,t,v);
	}

void DispMod::SetAxis(int v)
	{
	pblock->SetValue(PB_AXIS,0,v);
	}

Interval DispMod::LocalValidity(TimeValue t)
	{	
	float f;		
	Interval valid = FOREVER;
	pblock->GetValue(PB_UTILE,t,f,valid);
	pblock->GetValue(PB_VTILE,t,f,valid);
	pblock->GetValue(PB_WTILE,t,f,valid);
	pblock->GetValue(PB_STRENGTH,t,f,valid);	
	pblock->GetValue(PB_DECAY,t,f,valid);
	pblock->GetValue(PB_BLUR,t,f,valid);
	pblock->GetValue(PB_CENTERL,t,f,valid);
	pblock->GetValue(PB_LENGTH,t,f,valid);
	pblock->GetValue(PB_WIDTH,t,f,valid);
	pblock->GetValue(PB_HEIGHT,t,f,valid);	
	if (thebm) {
		if (bi.FirstFrame()!=bi.LastFrame()) {
			valid.SetInstant(t);
			return valid;
			}
		}
	if (tmap) {
		valid &= tmap->Validity(t);
		}
	if (tmControl) {
		Matrix3 tm(1);
		tmControl->GetValue(t,&tm,valid,CTRL_RELATIVE);
		}
	return valid;
	}

RefTargetHandle DispMod::Clone(RemapDir& remap) 
	{
	DispMod* newmod = new DispMod(FALSE);	
	if (TestAFlag(A_PLUGIN1)) 
		 newmod->SetAFlag(A_PLUGIN1);
	else newmod->ClearAFlag(A_PLUGIN1);
	newmod->ReplaceReference(PBLOCK_REF,pblock->Clone(remap));	
	if (tmap) newmod->ReplaceReference(2,tmap);
	if (tmControl) {
		newmod->MakeRefByID(FOREVER,TM_REF,tmControl->Clone(remap));
		}
	newmod->bi = bi;
	if (bi.Name()[0]!=0||bi.Device()[0]!=0) {
		newmod->LoadBitmap();
		}
	newmod->aspect = aspect;
	newmod->flags  = flags;
	return newmod;
	}

static void SetTMapTime(TimeValue t,Texmap *tmap)
	{
	if (!tmap) return;
	tmap->LoadMapFiles(t);
	tmap->Update(t,FOREVER);
	for (int i=0; i<tmap->NumSubTexmaps(); i++) {
		SetTMapTime(t,tmap->GetSubTexmap(i));
		}
	}

void DispMod::SetImageTime(TimeValue t)
	{
	if (thebm) {
		int length = bi.LastFrame()-bi.FirstFrame()+1;
		int frame = (t/GetTicksPerFrame())%length;
		if (frame<0) frame += length;
		frame += bi.FirstFrame();
		bi.SetCurrentFrame(frame);
		thebm->GoTo(&bi);
		}
	if (tmap) {
		SetTMapTime(t,tmap);
		}
	}

void DispMod::LoadBitmap() 
	{
	if (bi.Name()[0]==0&&bi.Device()[0]==0)
		return;
	thebm = TheManager->Load(&bi);
	}

void DispMod::FreeBitmap()
	{
	if (thebm) {
		thebm->DeleteThis();
		thebm = NULL;
		}
	}

BOOL DispMod::AssignController(Animatable *control,int subAnim)
	{
	if (subAnim==TM_REF) {
		ReplaceReference(TM_REF,(ReferenceTarget*)control);
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		return TRUE;
	} else {
		return FALSE;
		}
	}

int DispMod::SubNumToRefNum(int subNum)
	{
	switch (subNum) {
		case TM_REF: return TM_REF;
		case 2:      return 2;
		default:     return -1;
		}
	}

RefTargetHandle DispMod::GetReference(int i)
	{
	switch (i) {
		case TM_REF: 		return tmControl;
		case PBLOCK_REF:	return pblock;
		case 2:             return tmap;
		default: 			return NULL;
		}
	}

void DispMod::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case TM_REF: 		tmControl = (Control*)rtarg; break;
		case PBLOCK_REF:	pblock = (IParamBlock*)rtarg; break;
		case 2:             
			tmap = (Texmap*)rtarg; 
			if (editMod==this && pmapParam) {
				((DispDlgProc*)pmapParam->GetUserDlgProc())->SetMapName(
					pmapParam->GetHWnd());
				}
			break;
		}
	}

Animatable* DispMod::SubAnim(int i)
	{
	switch (i) {
		case TM_REF: 		return tmControl;
		case PBLOCK_REF:	return pblock;
		case 2:             return tmap;
		default: 			return NULL;   
		}
	}

TSTR DispMod::SubAnimName(int i)
	{
	switch (i) {
		case TM_REF: 		return GetString(IDS_RB_GIZMO);
		case PBLOCK_REF:	return GetString(IDS_RB_PARAMETERS);
		case 2:             return _T("Displacement Map");
		default: 			return TSTR(_T(""));
		}
	}

RefResult DispMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message) 
   	{
	switch (message) {
		case REFMSG_CHANGE:
			if (editMod==this && pmapParam) pmapParam->Invalidate();
			break;

		case REFMSG_NODE_NAMECHANGE:
			if (pmapParam) 
				SendMessage(pmapParam->GetHWnd(),WM_COMMAND,IDC_SET_MAPNAME,1);
			break;

		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_LENGTH:
				case PB_WIDTH:
				case PB_HEIGHT:
				case PB_STRENGTH:	gpd->dim = stdWorldDim; break;
				default:			gpd->dim = defaultDim; break;
				}			
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {
				case PB_UTILE:		gpn->name = GetString(IDS_RB_UTILE); break;
				case PB_VTILE:		gpn->name = GetString(IDS_RB_VTILE); break;
				case PB_WTILE:		gpn->name = GetString(IDS_RB_WTILE); break;
				case PB_STRENGTH:	gpn->name = GetString(IDS_RB_STRENGTH2); break;
				case PB_BLUR:		gpn->name = GetString(IDS_RB_BLUR); break;
				case PB_DECAY:		gpn->name = GetString(IDS_RB_DECAY); break;
				case PB_CENTERL:	gpn->name = GetString(IDS_RB_CENTERPOINT); break;
				case PB_LENGTH:		gpn->name = GetString(IDS_RB_LENGTH); break;
				case PB_WIDTH:		gpn->name = GetString(IDS_RB_WIDTH); break;
				case PB_HEIGHT:		gpn->name = GetString(IDS_RB_HEIGHT); break;
				case PB_CHANNEL: gpn->name = GetString (IDS_UVWX_CHANNEL); break;
				case PB_MAPCHANNEL: gpn->name = GetString (IDS_UVWX_MAPCHANNEL); break;
				default:			gpn->name = TSTR(_T("")); break;
				}
			return REF_STOP; 
			}
		}
	return REF_SUCCEED;
	}


void DispMod::ActivateSubobjSel(int level, XFormModes& modes )
	{	
	switch (level) {
		case 1: // Modifier box
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,NULL);
			break;		
		}
	NotifyDependents(FOREVER,PART_DISPLAY,REFMSG_CHANGE);
	}


// Following is necessary to make sure mapchannel doesn't come in as zero;
// this happens when loading up an old scene -- the pblock with the defaults
// is overwritten.
class DispSetChannelToOne : public PostLoadCallback {
public:
	DispMod *mm;
	DispSetChannelToOne (DispMod *mapMod) { mm = mapMod; }
	void proc (ILoad *iload) {
		if (mm && mm->pblock) {
			int mapChan;
			mm->pblock->GetValue (PB_MAPCHANNEL, 0, mapChan, FOREVER);
			if (!mapChan) mm->pblock->SetValue (PB_MAPCHANNEL, 0, 1);
		}
		delete this;
	}
};

#define MAPNAME_CHUNK	0x0100
#define BMIO_CHUNK	0x0200
#define NEWMAP_CHUNKID	0x0300

IOResult DispMod::Load(ILoad *iload)
	{	
	IOResult res = IO_OK;
	Modifier::Load(iload);

	iload->RegisterPostLoadCallback(
		new FixDimsPLCB(this));

	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,PBLOCK_REF));

	iload->RegisterPostLoadCallback (new DispSetChannelToOne(this));

	ClearAFlag(A_PLUGIN1);

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case MAPNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				bi.SetName(buf);
				FreeBitmap();
				LoadBitmap();
				break;
				}
			case BMIO_CHUNK: 
				res = bi.Load(iload);
				FreeBitmap();
				LoadBitmap();
				break;

			case NEWMAP_CHUNKID:
				SetAFlag(A_PLUGIN1);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}	
	
	return IO_OK;
	}

IOResult DispMod::Save(ISave *isave)
	{
	Modifier::Save(isave);
	isave->BeginChunk(BMIO_CHUNK);
	bi.Save(isave);
	isave->EndChunk();
	if (TestAFlag(A_PLUGIN1)) {
		isave->BeginChunk(NEWMAP_CHUNKID);
		isave->EndChunk();
		}
	return IO_OK;
	}


// --- Modify Object ---------------------------------------------------


class DispDeformer: public Deformer {
	public:
		Matrix3 tm,invtm;
		Bitmap *thebm;
		Texmap *tmap;
		int type, uflip, vflip, cap;
		float utile, vtile;
		float offset, mult, blur, decay;		
		Tab<Point3> *existing; // RB 3/26/99: Changed to Point3 from Point2
		Tab<Point3> *normals;		
		
		DispDeformer() {}
		DispDeformer(
			Matrix3 &tm, Matrix3 &invtm, 
			Bitmap *bm, Texmap *tmap, int type,
			float strength, float utile, float vtile,
			int uflip, int vflip,
			float blur, float decay,
			int centerLum, float center, int cap,
			Tab<Point3> *existing, // RB 3/26/99: Changed to Point3 from Point2
			Tab<Point3> *normals);
		Point3 Map(int i, Point3 p); 
		Point3 MapForce(Point3 p); 
		Point2 MapPoint(Point3 p,Point3 &v,float &dist,Point3 norm);
		float GetPixel(Point3 pt,float u, float v, float w); // RB 3/26/99: Added w
		BOOL InRange(Point2 &uv);
	};

DispDeformer::DispDeformer(
		Matrix3 &tm, Matrix3 &invtm, 
		Bitmap *bm, Texmap *tmap, int type,
		float strength, float utile, float vtile,
		int uflip, int vflip,
		float blur, float decay,
		int centerLum, float center, int cap,
		Tab<Point3> *existing, // RB 3/26/99: Changed to Point3 from Point2
		Tab<Point3> *normals)
	{
	this->tm       = tm;
	this->invtm    = invtm;
	thebm          = bm;
	this->type     = type;
	this->utile    = utile;
	this->vtile    = vtile;
	this->uflip    = uflip;
	this->vflip    = vflip;
	this->blur     = blur;
	this->decay    = decay;
	this->existing = existing;
	this->normals  = normals;
	this->tmap     = tmap;	
	this->cap      = cap;

	mult = strength;
	if (centerLum) {
		offset = -center; //-0.5f;
	} else {
		offset = 0.0f;
		}

	}

static int LargestComponent(Point3 &p)
	{
	int l = 0;
	if (fabs(p.y)>fabs(p[l])) l = 1;
	if (fabs(p.z)>fabs(p[l])) l = 2;
	return l;
	}

Point2 DispDeformer::MapPoint(Point3 p,Point3 &v, float &dist,Point3 norm)
	{
	switch (type) {		
		case MAP_PLANAR:
			v    = Point3(0,0,1);
			dist = (float)fabs(p.z);
			return Point2((p.x+1.0f)/2.0f,(p.y+1.0f)/2.0f);
		
		case MAP_BALL:
		case MAP_SPHERICAL: {
			Point2 uv;
			dist = Length(p);
			if (dist==0.0f) dist = 1.0f;
			v = p/dist;
			if (!thebm && !tmap) return Point2(0.5f,0.5f);
			float a1 = (float)atan2(v.x,v.y);
			float a2 = (float)asin(v.z);
			
			if (type==MAP_BALL) {
				float r = 0.5f-(a2+HALFPI)/TWOPI;
				uv.x = -(0.5f + r * (float)cos(a1+HALFPI));
				uv.y = 0.5f + r * (float)sin(a1+HALFPI);				
			} else {
				//uv.x = a1/TWOPI;
				uv.x = -(a1+HALFPI)/TWOPI;
				uv.y = (a2+HALFPI)/PI;
				}
			return uv;
			}				

		case MAP_CYLINDRICAL: {			
			Point2 uv;
			dist = Length(Point3(p.x, p.y, 0.0f));
			if (dist==0.0f) dist = 1.0f;
			v = Point3(p.x/dist, p.y/dist, 0.0f);
			if (!thebm && !tmap) return Point2(0.5f,p.z+0.5f);
			if (cap && (LargestComponent(norm)==2)) {
				if (norm.z<0) v = Point3(0,0,-1);
				else          v = Point3(0,0,1);
				// Do a planar mapping on the cap.				
				return Point2((p.x+1.0f)/2.0f,(p.y+1.0f)/2.0f);
			} else {
				float a1 = (float)atan2(v.x,v.y);
				//uv.x = a1/TWOPI;
				uv.x = -(a1+HALFPI)/TWOPI;
				uv.y = p.z+0.5f;
				return uv;
				}			
			}
		}
	//assert(0);
	return Point2(0.0f,0.0f);
	}

float DispDeformer::GetPixel(Point3 pt,float u, float v, float w)
	{
	if (!thebm && !tmap) return 1.0f;
	float f = 0.0f;
	if (thebm) {
		BMM_Color_64 c;
		if (blur==0.0f) {
			int w = thebm->Width()-1;
			int h = thebm->Height()-1;
			int x = (int)(frac(u)*(float)w);
			int y = h - (int)(frac(v)*(float)h);
			thebm->GetLinearPixels(x,y,1,&c);
		} else {		
			float wb = (blur*10.0f+1.0f)/float(thebm->Width());
			float hb = (blur*10.0f+1.0f)/float(thebm->Height());
			thebm->GetFiltered(frac(u),1.0f-frac(v),wb,hb,&c);
			}
		f += float(c.r)/float(0xFFFF) * 0.299f;
		f += float(c.g)/float(0xFFFF) * 0.587f;
		f += float(c.b)/float(0xFFFF) * 0.114f;		
		} 
	if (tmap) {
		SCTex shadeContext;
		shadeContext.scale = 1.0f;
		shadeContext.duvw  = Point3(blur/10.0f+0.001f,blur/10.0f+0.001f,blur/10.0f+0.001f/*0.0f*/);
		shadeContext.scrPos.x = int(u);
		shadeContext.scrPos.y = int(v);		
		shadeContext.uvw.x = u;
		shadeContext.uvw.y = v;
		shadeContext.uvw.z = w; //0.0f; RB 3/26/99: Don't want to loose w since 3D textures need it.
		shadeContext.pt = pt;
		shadeContext.dpt = Point3(blur/10.0f+0.001f,blur/10.0f+0.001f,blur/10.0f+0.001f);
		AColor c;
		c  = tmap->EvalColor(shadeContext);
		f += c.r * 0.299f;
		f += c.g * 0.587f;
		f += c.b * 0.114f;		
		}
	return f;
	}

BOOL DispDeformer::InRange(Point2 &uv)
	{
	switch (type) {
		case MAP_PLANAR:
			if (uv.x<0.0f || uv.x>1.0f || uv.y<0.0f || uv.y>1.0f)
				 return FALSE;
			else return TRUE;
		
		case MAP_BALL:
		case MAP_SPHERICAL:
			return TRUE;

		case MAP_CYLINDRICAL:
			if (uv.y<0.0f || uv.y>1.0f) return FALSE;
			else return TRUE;
		}
	
	return FALSE;
	}

Point3 DispDeformer::Map(int i, Point3 p)
	{
	Point3 v, op=p;
	Point3 uv; // RB 3/26/99: Changed to Point3 from Point2
	float s, dist, m;

	p = p * tm;	
	if (existing) {
		uv   = existing->operator[](i);
		dist = Length(p);
		v    = normals->operator[](i);
	} else {		
		//uv = MapPoint(p,v,dist,normals?normals->operator[](i):Point3(1,0,0));
		Point2 uv2 = MapPoint(p,v,dist,normals?normals->operator[](i):Point3(1,0,0));
		uv = Point3(uv2.x, uv2.y, 0.0f);
		}
	if (!InRange(Point2(uv.x, uv.y))) return p * invtm;
	if (decay!=0.0f) m = mult * (float)exp(-decay*dist);
	else m = mult;
	if (uflip) uv.x = 1.0f-uv.x;
	if (vflip) uv.y = 1.0f-uv.y;
	s = GetPixel(op, uv.x * utile, uv.y * vtile, uv.z); // RB 3/26/99: Added z component to support 3D textures. Do we need a z tile param?
	s = (s+offset)*m;	
	p = p * invtm;
	if (!existing) {
		v = Normalize(VectorTransform(invtm,v));
		}
	p += s*v;
	return p;
	}

// This is an adjustment to forces to make the independent of time scale.
// They were previously dependent on the old 1200 ticks per second constant.
// Note that the constants are being squared because we are dealing with acceleration not velocity.
static float forceScaleFactor = float(1200*1200)/float(TIME_TICKSPERSEC*TIME_TICKSPERSEC);

Point3 DispDeformer::MapForce(Point3 p)
	{
	Point3 v, op=p;
	Point2 uv;
	float s, dist, m;

	p = p * tm;	
	uv = MapPoint(p,v,dist,Point3(1,0,0));
	if (!InRange(uv)) return Point3(0,0,0);
	if (decay!=0.0f) m = mult * (float)exp(-decay*dist);
	else m = mult;
	if (m>9999999.0f) m = 9999999.0f;
	if (m<-9999999.0f) m = -9999999.0f;
	s = GetPixel(op, uv.x * utile, uv.y * vtile, 0.0f);
	s = (s+offset)*m;	
	v = Normalize(VectorTransform(invtm,v));
	return s*v * 0.00001f * forceScaleFactor;	
	}



void DispMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{	
	int type, centerLum, uflip, vflip, wflip, apply, useExisting, cap;
	float strength, utile, vtile, wtile, blur, decay, center;

	pblock->GetValue(PB_MAPTYPE,t,type,FOREVER);
	pblock->GetValue(PB_CENTERLUM,t,centerLum,FOREVER);
	pblock->GetValue(PB_UTILE,t,utile,FOREVER);
	pblock->GetValue(PB_VTILE,t,vtile,FOREVER);
	pblock->GetValue(PB_WTILE,t,wtile,FOREVER);
	pblock->GetValue(PB_UFLIP,t,uflip,FOREVER);
	pblock->GetValue(PB_VFLIP,t,vflip,FOREVER);
	pblock->GetValue(PB_WFLIP,t,wflip,FOREVER);
	pblock->GetValue(PB_STRENGTH,t,strength,FOREVER);
	pblock->GetValue(PB_BLUR,t,blur,FOREVER);
	pblock->GetValue(PB_DECAY,t,decay,FOREVER);	
	pblock->GetValue(PB_APPLYMAP,t,apply,FOREVER);	
	pblock->GetValue(PB_USEMAP,t,useExisting,FOREVER);	
	pblock->GetValue(PB_CENTERL,t,center,FOREVER);	
	pblock->GetValue(PB_CAP,t,cap,FOREVER);
	int chan = GetMapChannel ();

	// Set the image to the correct frame
	SetImageTime(t);

	// Prepare the controller and set up mats
	if (!tmControl || (flags&CONTROL_OP) || (flags&CONTROL_INITPARAMS)) 
		InitControl(mc,os->obj,type,t);	

	Interval valid = LocalValidity(t);
	Matrix3 tm, invtm;	
	invtm = CompMatrix(t,&mc,NULL);
	tm    = Inverse(invtm);		

	if (thebm) {
		if (blur==0.0f) {
			thebm->SetFilter(BMM_FILTER_NONE);
		} else {
			thebm->SetFilter(BMM_FILTER_SUM);
			}
		}

	// If we're going to use existing mapping coords, we'll need to
	// build a table that corrisponds witht he points of this object.
	Tab<Point3> existing; // RB 3/26/99: Changed to Point3 from Point2
	Tab<Point3> normals;

	if ((cap||useExisting) && os->obj->IsSubClassOf(triObjectClassID)) {
		TriObject *obj = (TriObject*)os->obj;
		Mesh &mesh = obj->GetMesh();
		TVFace *tf = mesh.mapFaces (chan);
		UVVert *tv = mesh.mapVerts (chan);		
		if (tf || cap) { 
			// RB 2/12/99: Added "&& useExisting" to "if (tf)" conditions because we may be
			// in this block of code ONLY because cap is on (so we need normals) but we don't
			// want to confuse things so that we and up using existing (which is what was happening).

			if (tf && useExisting) existing.SetCount (mesh.getNumVerts());
			normals.SetCount (mesh.getNumVerts());			
			for (int i=0; i<mesh.getNumVerts(); i++) {
				if (tf && useExisting) existing[i] = Point3(0.0f,0.0f,0.0f);  // RB 3/26/99: Changed to Point3 from Point2
				normals[i]  = Point3(0,0,0);				
			}

			for (i=0; i<mesh.getNumFaces(); i++) {
				Point3 v0 = mesh.verts[mesh.faces[i].v[1]] - mesh.verts[mesh.faces[i].v[0]];
				Point3 v1 = mesh.verts[mesh.faces[i].v[2]] - mesh.verts[mesh.faces[i].v[1]];
				Point3 n  = v0^v1;

				for (int j=0; j<3; j++) {
					if (tf && useExisting) {
						// RB 3/26/99: Changed to Point3 from Point2
						//Point3 pt = tv[tf[i].t[j]];
						//existing[mesh.faces[i].v[j]] = Point2(pt.x,pt.y);
						existing[mesh.faces[i].v[j]] = tv[tf[i].t[j]];
					}
					normals[mesh.faces[i].v[j]] += n;					
				}
			}
			
			for (i=0; i<mesh.getNumVerts(); i++) {
				normals[i] = Normalize(normals[i]);
				}
			}
		}

	// Apply works on all objects now.
	if (apply) {
		os->obj->ApplyUVWMap (type, utile, vtile, wtile, uflip, vflip, wflip, FALSE, tm, chan);
		}
	/*
	// Apply the mapping if it's a tri-object and we want to apply
	if (apply && os->obj->IsSubClassOf(triObjectClassID)) {
		TriObject *obj = (TriObject*)os->obj;
		Mesh &mesh = obj->mesh;
		mesh.ApplyUVWMap(type,utile,vtile,wtile,
			uflip,vflip,wflip,FALSE,tm);
		}
	*/
	
	DispDeformer deformer (tm,invtm,thebm,tmap,type, strength,utile,vtile, uflip, vflip,
		blur,decay,centerLum, center, cap, existing.Count()?&existing:NULL,
		normals.Count()?&normals:NULL);

	os->obj->Deform(&deformer, TRUE);
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	
	}


//--- Displace Object ------------------------------------------------------

DisplaceObject::DisplaceObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descVer6, PBLOCK_LENGTH, CURRENT_VERSION));	
	
	thebm = NULL;
	pblock->SetValue(PB_UTILE,0,1.0f);
	pblock->SetValue(PB_VTILE,0,1.0f);
	pblock->SetValue(PB_WTILE,0,1.0f);
	pblock->SetValue(PB_CENTERL,0,0.5f);
	pblock->SetValue(PB_LENGTH,0,1.0f);
	pblock->SetValue(PB_WIDTH,0,1.0f);
	pblock->SetValue(PB_HEIGHT,0,1.0f);	
	tmap = NULL;
	initParams = FALSE;
	}

DisplaceObject::~DisplaceObject()
	{
	FreeBitmap();
	}

void DisplaceObject::SetReference(int i, RefTargetHandle rtarg) 
	{
	if (i==0) 
		pblock = (IParamBlock*)rtarg; 
	else {
		tmap = (Texmap*)rtarg;
		if (pmapParam && pmapParam->GetParamBlock()==pblock) {
			((DispDlgProc*)pmapParam->GetUserDlgProc())->SetMapName(
				pmapParam->GetHWnd());
			}
		}
	}

void DisplaceObject::BeginEditParams(
		IObjParam  *ip, ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	
	if (pmapParam) {				
		pmapParam->SetParamBlock(pblock);
	} else {
		hSot = ip->AddRollupPage( 
				hInstance, 
				MAKEINTRESOURCE(IDD_DISPLACE_SOT),
				DefaultSOTProc,
				GetString(IDS_RB_SOT), 
				(LPARAM)ip,APPENDROLL_CLOSED);

		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGH_SW,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_DISPLACEPARAM_WS),
			GetString(IDS_RB_PARAMETERS),
			0);		
		}
 	pmapParam->SetUserDlgProc(new DispDlgProc(this)); 	
	}

void DisplaceObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {				
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	}

RefTargetHandle DisplaceObject::Clone(RemapDir& remap)
	{
	DisplaceObject* newob = new DisplaceObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));	
	if (tmap) newob->ReplaceReference(1,tmap);
	newob->bi = bi;
	newob->LoadBitmap();
	return newob;
	}

void DisplaceObject::FreeBitmap()
	{
	if (thebm) {
		thebm->DeleteThis();
		thebm = NULL;
		}
	}

void DisplaceObject::LoadBitmap() 
	{
	if (bi.Name()[0]==0&&bi.Device()[0]==0)
		return;	
	thebm = TheManager->Load(&bi);
	}

void DisplaceObject::SetImageTime(TimeValue t)
	{
	if (thebm) {
		int length = bi.LastFrame()-bi.FirstFrame()+1;
		int frame = (t/GetTicksPerFrame())%length;
		if (frame<0) frame += length;
		frame += bi.FirstFrame();
		bi.SetCurrentFrame(frame);
		thebm->GoTo(&bi);
		}
	if (tmap) {
		//tmap->LoadMapFiles(t);
		//tmap->Update(t,FOREVER);
		SetTMapTime(t,tmap);
		}
	}

class FixDimsWSPLCB1 : public PostLoadCallback {
	public:
		DisplaceObject *obj;
		FixDimsWSPLCB1(DisplaceObject *o) {obj=o;}
		void proc(ILoad *iload);
	};

void FixDimsWSPLCB1::proc(ILoad *iload)
	{
	if (obj->pblock->GetVersion()<5) {
		obj->initParams = TRUE;
		}
	delete this;
	}

class FixDimsWSPLCB2 : public PostLoadCallback {
	public:
		DisplaceObject *obj;
		FixDimsWSPLCB2(DisplaceObject *o) {obj=o;}
		void proc(ILoad *iload);
	};

void FixDimsWSPLCB2::proc(ILoad *iload)
	{
	if (obj->initParams) {
		obj->pblock->SetValue(PB_LENGTH,0,1.0f);
		obj->pblock->SetValue(PB_WIDTH,0,1.0f);
		obj->pblock->SetValue(PB_HEIGHT,0,1.0f);
		obj->initParams = FALSE;
		}
	delete this;
	}

IOResult DisplaceObject::Load(ILoad *iload)
	{
	IOResult res = IO_OK;
	
	iload->RegisterPostLoadCallback(
		new FixDimsWSPLCB1(this));

	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(versions,NUM_OLDVERSIONS,&curVersion,this,0));

	iload->RegisterPostLoadCallback(
		new FixDimsWSPLCB2(this));

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case MAPNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				bi.SetName(buf);
				FreeBitmap();
				LoadBitmap();
				break;
				}
			case BMIO_CHUNK: 
				res = bi.Load(iload);
				FreeBitmap();
				LoadBitmap();
				break;			
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}	
	
	return IO_OK;
	}

IOResult DisplaceObject::Save(ISave *isave)
	{
	isave->BeginChunk(BMIO_CHUNK);
	bi.Save(isave);
	isave->EndChunk();
	return IO_OK;
	}

Modifier *DisplaceObject::CreateWSMMod(INode *node)
	{
	return new DisplaceWSMod(node,this);
	}

ForceField *DisplaceObject::GetForceField(INode *node)
	{
	DisplaceField *df = new DisplaceField;
	df->dobj   = this;
	df->thebm  = thebm;
	df->node   = node;
	df->tmValid.SetEmpty();
	return df;
	}

void DisplaceObject::InvalidateUI()
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *DisplaceObject::GetParameterDim(int pbIndex)
	{
	switch (pbIndex) {
		case PB_STRENGTH:
		case PB_LENGTH:
		case PB_WIDTH:
		case PB_HEIGHT:
			return stdWorldDim;
		default:
			return defaultDim;
		}	
	}

TSTR DisplaceObject::GetParameterName(int pbIndex)
	{
	switch (pbIndex) {
		case PB_UTILE: 		return GetString(IDS_RB_UTILE);
		case PB_VTILE: 		return GetString(IDS_RB_VTILE);
		case PB_WTILE: 		return GetString(IDS_RB_WTILE);
		case PB_BLUR:		return GetString(IDS_RB_BLUR);
		case PB_STRENGTH:	return GetString(IDS_RB_STRENGTH2);
		case PB_DECAY:		return GetString(IDS_RB_DECAY);
		case PB_CENTERL:	return GetString(IDS_RB_CENTERPOINT);
		case PB_LENGTH:		return GetString(IDS_RB_LENGTH);
		case PB_WIDTH:		return GetString(IDS_RB_WIDTH);
		case PB_HEIGHT:		return GetString(IDS_RB_HEIGHT);
		default: 			return TSTR(_T(""));
		}
	}

void DisplaceObject::BuildMesh(TimeValue t)
	{
	int type;
	float u;
#define NUM_SEGS	16
	ivalid = FOREVER;
	pblock->GetValue(PB_MAPTYPE,0,type,ivalid);	
	if (type==MAP_PLANAR) {
		mesh.setNumVerts(4);
		mesh.setNumFaces(2);
		mesh.setVert(0,-1.0f,-1.0f,0.0f);
		mesh.setVert(1, 1.0f,-1.0f,0.0f);
		mesh.setVert(2, 1.0f, 1.0f,0.0f);
		mesh.setVert(3,-1.0f, 1.0f,0.0f);
		mesh.faces[0].setEdgeVisFlags(1,0,1);
		mesh.faces[0].setSmGroup(1);
		mesh.faces[0].setVerts(0,1,3);
		mesh.faces[1].setEdgeVisFlags(1,1,0);
		mesh.faces[1].setSmGroup(1);
		mesh.faces[1].setVerts(1,2,3);
	} else 
	if (type==MAP_SPHERICAL||type==MAP_BALL) {		
		mesh.setNumVerts(3*NUM_SEGS+1);
		mesh.setNumFaces(3*NUM_SEGS);

		for (int i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i, Point3((float)cos(u), (float)sin(u), 0.0f));
			}
		for (i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i+NUM_SEGS, Point3(0.0f, (float)cos(u), (float)sin(u)));
			}
		for (i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i+2*NUM_SEGS, Point3((float)cos(u), 0.0f, (float)sin(u)));
			}		
		mesh.setVert(3*NUM_SEGS, Point3(0.0f, 0.0f, 0.0f));
		
		for (i=0; i<3*NUM_SEGS; i++) {
			int i1 = i+1;
			if (i1%NUM_SEGS==0) i1 -= NUM_SEGS;
			mesh.faces[i].setEdgeVisFlags(1,0,0);
			mesh.faces[i].setSmGroup(1);
			mesh.faces[i].setVerts(i,i1,3*NUM_SEGS);
			}
	} else
	if (type==MAP_CYLINDRICAL) {
		mesh.setNumVerts(2*NUM_SEGS);
		mesh.setNumFaces(2*NUM_SEGS);

		for (int i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i, Point3((float)cos(u), (float)sin(u), -0.5f));
			}
		for (i=0; i<NUM_SEGS; i++) {
			u = float(i)/float(NUM_SEGS) * TWOPI;
			mesh.setVert(i+NUM_SEGS, Point3((float)cos(u), (float)sin(u), 0.5f));
			}
		
		for (i=0; i<NUM_SEGS; i++) {
			int i1 = i+1;
			if (i1%NUM_SEGS==0) i1 -= NUM_SEGS;
			mesh.faces[i*2].setEdgeVisFlags(1,0,1);
			mesh.faces[i*2].setSmGroup(1);
			mesh.faces[i*2].setVerts(i,i1,i+NUM_SEGS);

			mesh.faces[i*2+1].setEdgeVisFlags(1,1,0);
			mesh.faces[i*2+1].setSmGroup(1);
			mesh.faces[i*2+1].setVerts(i1,i1+NUM_SEGS,i+NUM_SEGS);
			}
		}	

	float l, w, h;
	pblock->GetValue(PB_LENGTH,t,l,ivalid);
	pblock->GetValue(PB_WIDTH,t,w,ivalid);
	pblock->GetValue(PB_HEIGHT,t,h,ivalid);
	for (int i=0; i<mesh.getNumVerts(); i++) {
		mesh.verts[i].x *= w;
		mesh.verts[i].y *= l;
		mesh.verts[i].z *= h;
 		}

	mesh.InvalidateGeomCache();
	}

class DisplaceObjCreateCallBack: public CreateMouseCallBack {	
	public:
		DisplaceObject *ob;		
		Point3 p0, p1;
		IPoint2 sp0, sp1;	
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);		
	};

int DisplaceObjCreateCallBack::proc(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat) 
	{
	float d;
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:  // only happens with MOUSE_POINT msg
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE); //vpt->GetPointOnCP(m);
				mat.SetTrans(p0);
				break;
			case 1:				
				p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE); // vpt->GetPointOnCP(m);
				d  = Length(p1-p0)/2.0f;				
				mat.IdentityMatrix();
				//mat.Scale(Point3(d,d,d));
				ob->pblock->SetValue(PB_LENGTH,0,d);
				ob->pblock->SetValue(PB_WIDTH,0,d);
				ob->pblock->SetValue(PB_HEIGHT,0,d);
				mat.SetTrans(p0);
				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<4) return CREATE_ABORT;
					else return CREATE_STOP;
					}
				break;
			}
		} 
	else
	if (msg == MOUSE_ABORT) {
		return CREATE_ABORT;
		} 
	else
	if (msg == MOUSE_FREEMOVE) {
		vpt->SnapPreview(m,m);
		}

	return TRUE;
	}

static DisplaceObjCreateCallBack displaceCreateCB;

CreateMouseCallBack* DisplaceObject::GetCreateMouseCallBack()
	{
	displaceCreateCB.ob = this;
	return &displaceCreateCB;
	}



//--- Displace World space modifier ---------------------------------------


DisplaceWSMod::DisplaceWSMod(INode *node,DisplaceObject *obj)
	{	
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;	
	obRef = NULL;
	}

RefTargetHandle DisplaceWSMod::Clone(RemapDir& remap)
	{
	DisplaceWSMod *newob = new DisplaceWSMod(nodeRef,(DisplaceObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}

Interval DisplaceWSMod::GetValidity(TimeValue t)
	{
	if (nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		DisplaceObject *dobj = (DisplaceObject*)GetWSMObject(t);
		dobj->pblock->GetValue(PB_UTILE,t,f,valid);
		dobj->pblock->GetValue(PB_VTILE,t,f,valid);
		dobj->pblock->GetValue(PB_STRENGTH,t,f,valid);	
		dobj->pblock->GetValue(PB_DECAY,t,f,valid);
		dobj->pblock->GetValue(PB_BLUR,t,f,valid);
		dobj->pblock->GetValue(PB_CENTERL,t,f,valid);
		dobj->pblock->GetValue(PB_LENGTH,t,f,valid);
		dobj->pblock->GetValue(PB_WIDTH,t,f,valid);
		dobj->pblock->GetValue(PB_HEIGHT,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		if (dobj->thebm) {
			if (dobj->bi.FirstFrame()!=dobj->bi.LastFrame()) {
				valid.SetInstant(t);				
				}
			}
		if (dobj->tmap) {
			valid &= dobj->tmap->Validity(t);
			}
		return valid;
	} else {
		return FOREVER;
		}
	}


static DispDeformer deformer;

Deformer& DisplaceWSMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{		
	int type, centerLum, uflip, vflip, cap;
	float strength, utile, vtile, blur, decay, center;
	Matrix3 tm, invtm;
	Point3 s;

	DisplaceObject *dobj = (DisplaceObject*)GetWSMObject(t);
	dobj->pblock->GetValue(PB_MAPTYPE,t,type,FOREVER);
	dobj->pblock->GetValue(PB_CENTERLUM,t,centerLum,FOREVER);
	dobj->pblock->GetValue(PB_UTILE,t,utile,FOREVER);
	dobj->pblock->GetValue(PB_VTILE,t,vtile,FOREVER);
	dobj->pblock->GetValue(PB_UFLIP,t,uflip,FOREVER);
	dobj->pblock->GetValue(PB_VFLIP,t,vflip,FOREVER);
	dobj->pblock->GetValue(PB_STRENGTH,t,strength,FOREVER);
	dobj->pblock->GetValue(PB_BLUR,t,blur,FOREVER);
	dobj->pblock->GetValue(PB_DECAY,t,decay,FOREVER);	
	dobj->pblock->GetValue(PB_CENTERL,t,center,FOREVER);
	dobj->pblock->GetValue(PB_CAP,t,cap,FOREVER);
	dobj->pblock->GetValue(PB_LENGTH,t,s.y,FOREVER);
	dobj->pblock->GetValue(PB_WIDTH,t,s.x,FOREVER);
	dobj->pblock->GetValue(PB_HEIGHT,t,s.z,FOREVER);
	
	//invtm = nodeRef->GetNodeTM(t);
	invtm = nodeRef->GetObjectTM(t);
	invtm.PreScale(s);
	tm    = Inverse(invtm);

	if (dobj->thebm) {
		if (blur==0.0f) {
			dobj->thebm->SetFilter(BMM_FILTER_NONE);
		} else {
			dobj->thebm->SetFilter(BMM_FILTER_SUM);
			}
		}

	dobj->SetImageTime(t);

	deformer = DispDeformer (tm,invtm,dobj->thebm, dobj->tmap,type,
		strength,utile,vtile, uflip, vflip, blur,decay,centerLum,center,cap,NULL,NULL);
 	return deformer;
 	}

Point3 DisplaceField::Force(TimeValue t,const Point3 &pos, const Point3 &vel,int index)
	{
	int type, centerLum, uflip, vflip, cap;
	float strength, utile, vtile, blur, decay, center;

	if (!tmValid.InInterval(t)) {		
		tmValid = FOREVER;
		Point3 s;
		dobj->pblock->GetValue(PB_LENGTH,t,s.y,tmValid);
		dobj->pblock->GetValue(PB_WIDTH,t,s.x,tmValid);
		dobj->pblock->GetValue(PB_HEIGHT,t,s.z,tmValid);		
		invtm = node->GetObjectTM(t,&tmValid);
		invtm.PreScale(s);
		tm    =	Inverse(invtm);
		}
	
	dobj->pblock->GetValue(PB_MAPTYPE,t,type,FOREVER);
	dobj->pblock->GetValue(PB_CENTERLUM,t,centerLum,FOREVER);
	dobj->pblock->GetValue(PB_UTILE,t,utile,FOREVER);
	dobj->pblock->GetValue(PB_VTILE,t,vtile,FOREVER);
	dobj->pblock->GetValue(PB_UFLIP,t,uflip,FOREVER);
	dobj->pblock->GetValue(PB_VFLIP,t,vflip,FOREVER);
	dobj->pblock->GetValue(PB_STRENGTH,t,strength,FOREVER);
	dobj->pblock->GetValue(PB_BLUR,t,blur,FOREVER);
	dobj->pblock->GetValue(PB_DECAY,t,decay,FOREVER);	
	dobj->pblock->GetValue(PB_CENTERL,t,center,FOREVER);
	dobj->pblock->GetValue(PB_CAP,t,cap,FOREVER);

	dobj->SetImageTime(t);

	DispDeformer deformer(
		tm,invtm,thebm,dobj->tmap,type,
		strength,utile,vtile,
		uflip, vflip,
		blur,decay,centerLum,center,cap,NULL,NULL);
	
	return deformer.MapForce(pos);
	}

void DisplaceWSMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		DisplaceObject *dobj = (DisplaceObject*)GetWSMObject(t);
		force.dobj   = dobj;
		force.thebm  = dobj->thebm;
		force.node   = nodeRef;
		force.tmValid.SetEmpty();
		obj->ApplyForceField(&force);
	} else {
		SimpleWSMMod::ModifyObject(t,mc,os,node);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\clustmod.cpp ===
/**********************************************************************
 *<
	FILE: clustmod.cpp   

	DESCRIPTION:  Vertex cluster animating modifier

	CREATED BY: Rolf Berteig

	HISTORY: created 24 August, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "simpmod.h"
#include "buildver.h"

class ClustMod : public SimpleMod {	
	private:		
		int selLevel;

	public:												
		ClustMod();
				
		void DeleteThis() {delete this;}
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_XFORM_CLASS); } 
		Class_ID ClassID() { return Class_ID(CLUSTOSM_CLASS_ID,0);}
		RefTargetHandle Clone(RemapDir& remap);
		TCHAR *GetObjectName() { return GetString(IDS_RB_XFORM); }
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);	
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);		

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node);
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc);
		void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);
		void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
		void Move(TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
		void ActivateSubobjSel(int level, XFormModes& modes);
	};


class ClustDeformer: public Deformer {
	public:
		Matrix3 tm;
			
		ClustDeformer();
		ClustDeformer(Matrix3& modmat);		
		
		Point3 Map(int i, Point3 p); 
	};


class ClustClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new ClustMod;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_XFORM_CLASS); }
	SClass_ID		SuperClassID() {return OSM_CLASS_ID; }
	Class_ID		ClassID() {return Class_ID(CLUSTOSM_CLASS_ID,0); }
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	};
static ClustClassDesc clustDesc;
extern ClassDesc* GetClustModDesc() { return &clustDesc; }

/*--------------------------------------------------------------------*/



RefTargetHandle ClustMod::Clone(RemapDir& remap) 
	{
	ClustMod* newmod = new ClustMod();			
	newmod->SimpleModClone(this);
	return(newmod);
	}

ClustDeformer::ClustDeformer() 
	{ 	
	tm.IdentityMatrix();	
	}

Point3 ClustDeformer::Map(int i, Point3 p)
	{	
	p = p * tm;	
	return p;
	}

ClustDeformer::ClustDeformer(Matrix3& modmat) 
	{	
	tm = modmat;		
	} 

ClustMod::ClustMod()
	{
	// We'll use A_WORK4 to indicate that this mod was just created.
	// The first time we enter BeginEditParams() we'll go directly into
	// sub object selection 
	//SetAFlag(A_WORK4);
	selLevel = 1;
	}

Deformer& ClustMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{	
	static ClustDeformer deformer;
	assert(0);
	return deformer;
	}

void ClustMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
	{
	SimpleMod::BeginEditParams(ip,flags,prev);
	//if (TestAFlag(A_WORK4)) ip->SetSubObjectLevel(1);
	//ClearAFlag(A_WORK4);
	if (selLevel) ip->SetSubObjectLevel(1);
	}

void ClustMod::ActivateSubobjSel(int level, XFormModes& modes)
	{
	selLevel = level;
	SimpleMod::ActivateSubobjSel(level,modes);
	}

#define DEFORMER_TM	(ptm * ctm)
static Matrix3 CompTM(
		Matrix3 &ptm, Matrix3 &ctm, Matrix3 *mctm, int i)
	{
	if (mctm) {
		if (i) return  ptm * ctm * Inverse(*mctm);
		else return *mctm * ptm * ctm * Inverse(*mctm);
	} else {
		return ptm * ctm;
		}
	}

void ClustMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState * os, INode *node)
	{
	Interval valid = FOREVER;
	Matrix3 ptm(1), ctm(1);
	if (posControl) posControl->GetValue(t,&ptm,valid,CTRL_RELATIVE);
	if (tmControl) tmControl->GetValue(t,&ctm,valid,CTRL_RELATIVE);	
	//Matrix3 tm = DEFORMER_TM;
	Matrix3 tm = CompTM(ptm,ctm,mc.tm,0);

	ClustDeformer deformer(tm);
	
	os->obj->Deform(&deformer, TRUE);
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);
	}

// RB 3/31/99: Push mc->box through this to handle the case where an XForm
// mod is applied to an empty sub-object selection.
static Box3& MakeBoxNotEmpty(Box3 &box)
	{
	static Box3 smallBox(Point3(-5,-5,-5),Point3( 5, 5, 5));
	if (box.IsEmpty()) return smallBox;
	else return box;
	}

int ClustMod::HitTest(
		TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc)
	{	
	int savedLimits;
	Matrix3 obtm = inode->GetObjectTM(t);
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();	
	gw->setTransform(obtm);

	Matrix3 ptm(1), ctm(1);
	if (posControl) posControl->GetValue(t,&ptm,FOREVER,CTRL_RELATIVE);
	if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);	

	if (ip && ip->GetSubObjectLevel() == 1) {		
		//Matrix3 tm = DEFORMER_TM;
		Matrix3 tm = CompTM(ptm,ctm,mc->tm,1);

		ClustDeformer deformer(tm);
		if (mc->box->pmin==mc->box->pmax) {
			Point3 pt = mc->box->pmin * tm;
			gw->marker(&pt,ASTERISK_MRKR);
		} else {
			DoModifiedBox(MakeBoxNotEmpty(*mc->box),deformer,DrawLineProc(gw));
			}
		}

	if (ip && (ip->GetSubObjectLevel() == 1 ||
	           ip->GetSubObjectLevel() == 2)) {		
		//obtm = ctm * obtm;
		if (mc->tm) obtm = ctm * Inverse(*mc->tm) * obtm;
		else obtm = ctm * obtm;

		gw->setTransform(obtm);
		DrawCenterMark(DrawLineProc(gw),MakeBoxNotEmpty(*mc->box));
		}

	gw->setRndLimits(savedLimits);	
	if (gw->checkHitCode()) {
		vpt->LogHit(inode, mc, gw->getHitDistance(), 0, NULL); 
		return 1;
		}
	return 0;
	}

int ClustMod::Display(
		TimeValue t, INode* inode, ViewExp *vpt, 
		int flags, ModContext *mc)
	{
	// Transform the gizmo with the node.
	#ifdef DESIGN_VER
	TimeValue rt = GetCOREInterface()->GetTime();
	Matrix3 obtm = inode->GetObjectTM(rt);
	#else
	Matrix3 obtm = inode->GetObjectTM(t);
    #endif

	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(obtm);

	Matrix3 ptm(1), ctm(1);
	if (posControl) posControl->GetValue(t,&ptm,FOREVER,CTRL_RELATIVE);
	if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);	
	//Matrix3 tm = DEFORMER_TM;
	Matrix3 tm = CompTM(ptm,ctm,mc->tm,1);	

	ClustDeformer deformer(tm);	
	if (ip && ip->GetSubObjectLevel() == 1) {
		//gw->setColor( LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);		
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor( LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}
	if (mc->box->pmin==mc->box->pmax) {
		Point3 pt = mc->box->pmin * tm;
		gw->marker(&pt,ASTERISK_MRKR);		
	} else {
		DoModifiedBox(MakeBoxNotEmpty(*mc->box),deformer,DrawLineProc(gw));
		}

	//obtm = ctm * obtm;
	if (mc->tm) obtm = ctm * Inverse(*mc->tm) * obtm;
	else obtm = ctm * obtm;
	
	gw->setTransform(obtm);
	if ( ip && (ip->GetSubObjectLevel() == 1 ||
	            ip->GetSubObjectLevel() == 2) ) {		
		//gw->setColor( LINE_COLOR, (float)1.0, (float)1.0, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));
	} else {
		//gw->setColor( LINE_COLOR, (float).85, (float).5, (float)0.0);
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_GIZMOS));
		}	
	DrawCenterMark(DrawLineProc(gw),MakeBoxNotEmpty(*mc->box));	
	return 0;
	}

void ClustMod::GetWorldBoundBox(
		TimeValue t,INode* inode, ViewExp *vpt, 
		Box3& box, ModContext *mc)
	{

	// Need the correct bound box for proper damage rect calcs.
	#ifdef DESIGN_VER
	TimeValue rt = GetCOREInterface()->GetTime();
	Matrix3 obtm = inode->GetObjectTM(rt);
	#else
	Matrix3 obtm = inode->GetObjectTM(t);
    #endif
	GraphicsWindow *gw = vpt->getGW();
	
	Matrix3 ptm(1), ctm(1);
	if (posControl) posControl->GetValue(t,&ptm,FOREVER,CTRL_RELATIVE);
	if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);	
	//Matrix3 tm = DEFORMER_TM;
	Matrix3 tm = CompTM(ptm,ctm,mc->tm,1);
	ClustDeformer deformer(tm);	
	
	BoxLineProc bp1(&obtm);
	DoModifiedBox(MakeBoxNotEmpty(*mc->box), deformer, bp1);
	box = bp1.Box();

	//obtm = ctm * obtm;
	if (mc->tm) obtm = ctm * Inverse(*mc->tm) * obtm;
	else obtm = ctm * obtm;

	BoxLineProc bp2(&obtm);		
	DrawCenterMark(bp2,MakeBoxNotEmpty(*mc->box));
	box += bp2.Box();
	}

void ClustMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 obtm = node->GetObjectTM(t);
	Matrix3 ptm(1), ctm(1);
	if (posControl) posControl->GetValue(t,&ptm,FOREVER,CTRL_RELATIVE);	
	if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);

	if (cb->Type()==SO_CENTER_PIVOT) {
		//Matrix3 mat = ctm * obtm;
		Matrix3 mat;		
		if (mc->tm) mat = ctm * Inverse(*mc->tm) * obtm;
		else mat = ctm * obtm;
		cb->Center(mat.GetTrans(),0);
	} else {		
		//Matrix3 tm = DEFORMER_TM;
		Matrix3 tm = CompTM(ptm,ctm,mc->tm,1);
		ClustDeformer deformer(tm);
		BoxLineProc bp1(&obtm);
		DoModifiedBox(MakeBoxNotEmpty(*mc->box), deformer, bp1);
		cb->Center(bp1.Box().Center(),0);
		}
	}

void ClustMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Matrix3 obtm = node->GetObjectTM(t);
	Matrix3 ptm(1), ctm(1);
	if (posControl) posControl->GetValue(t,&ptm,FOREVER,CTRL_RELATIVE);
	if (tmControl) tmControl->GetValue(t,&ctm,FOREVER,CTRL_RELATIVE);	
	//Matrix3 tm = DEFORMER_TM * obtm;	
	Matrix3 tm = CompTM(ptm,ctm,mc->tm,1) * obtm;
	cb->TM(tm,0);
	}

void ClustMod::Move(
		TimeValue t, Matrix3& partm, Matrix3& tmAxis, 
		Point3& val, BOOL localOrigin) 
	{
#ifdef DESIGN_VER
	t=0;
#endif
	if (tmControl==NULL) {
		MakeRefByID(FOREVER,0,NewDefaultMatrix3Controller()); 
		NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
		}

	if (ip && ip->GetSubObjectLevel()==1) {				
		SetXFormPacket pckt(val,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);		
	} else {		
		if (posControl==NULL) {
			MakeRefByID(FOREVER,1,NewDefaultPositionController()); 
			NotifyDependents(FOREVER,0,REFMSG_CONTROLREF_CHANGE);
			}
		Matrix3 ptm = partm;
		Interval valid;
		if (tmControl)
			tmControl->GetValue(t,&ptm,valid,CTRL_RELATIVE);
		posControl->SetValue(t,-VectorTransform(tmAxis*Inverse(ptm),val),TRUE,CTRL_RELATIVE);
		
		SetXFormPacket pckt(val,partm,tmAxis);
		tmControl->SetValue(t,&pckt,TRUE,CTRL_RELATIVE);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\clstnode.cpp ===
/**********************************************************************
 *<
	FILE: clstnode.cpp   

	DESCRIPTION:  Vertex cluster animating modifier that uses nodes

	CREATED BY: Rolf Berteig

	HISTORY: created 27 October, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"

class ClustNodeMod : public Modifier {	
	public:
		INode *node;
		static IObjParam *ip;
		static HWND hParams;
		Matrix3 tm, invtm;

		ClustNodeMod();
		~ClustNodeMod();

		// From Animatable
		void DeleteThis() {delete this;}
		void GetClassName(TSTR& s) { s= GetString(IDS_RB_CLUSTNODEMOD); }  
		virtual Class_ID ClassID() { return Class_ID(CLUSTNODEOSM_CLASS_ID,0);}
		void BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams(IObjParam *ip,ULONG flags,Animatable *next);		
		TCHAR *GetObjectName() {return GetString(IDS_RB_NODEXFORM);}
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 

		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE;}
		ChannelMask ChannelsChanged() {return PART_GEOM;}
		Class_ID InputType() {return defObjectClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t);

		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return node;}
		void SetReference(int i, RefTargetHandle rtarg) {node=(INode*)rtarg;}
		
		IOResult Load(ILoad *iload);
		IOResult Save(ISave *isave);
				
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);
	};


//--- ClassDescriptor and class vars ---------------------------------

IObjParam* ClustNodeMod::ip = NULL;
HWND ClustNodeMod::hParams  = NULL;

class ClustNodeClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new ClustNodeMod;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_NODEXFORM_CLASS);}
	SClass_ID		SuperClassID() {return OSM_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(CLUSTNODEOSM_CLASS_ID,0); }
	const TCHAR* 	Category() {return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static ClustNodeClassDesc clustNodeDesc;
extern ClassDesc* GetClustNodeModDesc() {return &clustNodeDesc;}


//--- CustMod dlg proc ------------------------------

class PickControlNode : 
		public PickModeCallback,
		public PickNodeCallback {
	public:				
		ClustNodeMod *mod;
		PickControlNode() {mod=NULL;}
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);		
		BOOL Pick(IObjParam *ip,ViewExp *vpt);		
		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);		
		BOOL Filter(INode *node);
		PickNodeCallback *GetFilter() {return this;}
		BOOL RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}
	};
static PickControlNode thePickMode;

BOOL PickControlNode::Filter(INode *node)
	{
	node->BeginDependencyTest();
	mod->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) {		
		return FALSE;
	} else {
		return TRUE;
		}
	}

BOOL PickControlNode::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	if (ip->PickNode(hWnd,m,this)) {
		return TRUE;
	} else {
		return FALSE;
		}
	}

BOOL PickControlNode::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	if (node) {
		// RB 3/1/99: This should use the node tm not the object TM. See ModifyObject() imp.
		Matrix3 ourTM,ntm = node->GetNodeTM(ip->GetTime()); //node->GetObjectTM(ip->GetTime());	

		ModContextList mcList;
		INodeTab nodes;
		ip->GetModContexts(mcList,nodes);
		assert(nodes.Count());
		ourTM = nodes[0]->GetObjectTM(ip->GetTime());
		mod->tm    = ourTM * Inverse(ntm);
		mod->invtm = Inverse(ourTM);
		mod->ReplaceReference(0,node);
		mod->NotifyDependents(FOREVER,0,REFMSG_CHANGE);

		SetWindowText(GetDlgItem(mod->hParams,IDC_CLUST_NODENAME),
					mod->node->GetName());
		nodes.DisposeTemporary();
		}
	return TRUE;
	}

void PickControlNode::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(mod->hParams,IDC_CLUST_PICKNODE));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	}

void PickControlNode::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut = GetICustButton(GetDlgItem(mod->hParams,IDC_CLUST_PICKNODE));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
	}

static BOOL CALLBACK ClustParamDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	ClustNodeMod *mod = (ClustNodeMod*)GetWindowLong(hWnd,GWL_USERDATA);
	
	switch (msg) {
		case WM_INITDIALOG: {
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			mod = (ClustNodeMod*)lParam;
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_CLUST_PICKNODE));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(iBut);
			if (mod->node) {
				SetWindowText(GetDlgItem(hWnd,IDC_CLUST_NODENAME),
					mod->node->GetName());
			} else {
				SetWindowText(GetDlgItem(hWnd,IDC_CLUST_NODENAME),
					GetString(IDS_RB_NONE));
				}
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CLUST_PICKNODE:
					thePickMode.mod  = mod;					
					mod->ip->SetPickMode(&thePickMode);
					break;
				}
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

//--- ClustMod methods -------------------------------

ClustNodeMod::ClustNodeMod()
	{
	node  = NULL;
	tm    = Matrix3(1);
	invtm = Matrix3(1);
	}

ClustNodeMod::~ClustNodeMod()
	{
	DeleteAllRefsFromMe();
	}

#define CLUSTNODE_TM_CHUNK		0x0100
#define CLUSTNODE_INVTM_CHUNK	0x0110

IOResult ClustNodeMod::Load(ILoad *iload)
	{
	Modifier::Load(iload);
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case CLUSTNODE_TM_CHUNK:
				tm.Load(iload);
				break;

			case CLUSTNODE_INVTM_CHUNK:
				invtm.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}

IOResult ClustNodeMod::Save(ISave *isave)
	{
	Modifier::Save(isave);
	isave->BeginChunk(CLUSTNODE_TM_CHUNK);
	tm.Save(isave);
	isave->EndChunk();

	isave->BeginChunk(CLUSTNODE_INVTM_CHUNK);
	invtm.Save(isave);
	isave->EndChunk();
	
	return IO_OK;
	}

void ClustNodeMod::BeginEditParams(
		IObjParam *ip, ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	hParams  = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_CLUSTNODEPARAM),
		ClustParamDlgProc,
		GetString(IDS_RB_PARAMETERS),
		(LPARAM)this);
	}

void ClustNodeMod::EndEditParams(
		IObjParam *ip,ULONG flags,Animatable *next)
	{
	ip->ClearPickMode();
	this->ip = NULL;
	ip->DeleteRollupPage(hParams);
	}



class ClustNodeDeformer: public Deformer {
	public:
		Matrix3 tm,invtm;
		ClustNodeDeformer(Matrix3 m,Matrix3 mi) {tm=m;invtm=mi;}
		Point3 Map(int i, Point3 p) {return (p*tm)*invtm;}
	};

void ClustNodeMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	if (this->node) {
		Interval valid = FOREVER;
		Matrix3 ntm = this->node->GetNodeTM(t,&valid);
		ClustNodeDeformer deformer(tm*ntm,invtm);
		os->obj->Deform(&deformer, TRUE);
		os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	
		}
	}

Interval ClustNodeMod::LocalValidity(TimeValue t)
	{
	Interval valid = FOREVER;
	if (node) {
		node->GetNodeTM(t,&valid);
		}
	return valid;
	}

RefTargetHandle ClustNodeMod::Clone(RemapDir& remap)
	{
	ClustNodeMod *newmod = new ClustNodeMod;
	newmod->ReplaceReference(0,node);
	newmod->tm    = tm;
	newmod->invtm = invtm;
	return newmod;
	}

RefResult ClustNodeMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_TARGET_DELETED:
			if (hTarget==node) {
				node = NULL;
				}
			break;
		}
	return REF_SUCCEED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\delsmod.cpp ===
/**********************************************************************
 *<
	FILE: delmod.cpp

	DESCRIPTION:  A delete spline modifier

	CREATED BY: Audrey Peterson

	HISTORY: 1/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "iparamm.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"

#define SDELETE_CLASS_ID		0x120f2c0c

class SDeleteMod : public Modifier {	
	public:		
		SDeleteMod();

		// From Animatable
		void DeleteThis() { delete this; }
		void GetClassName(TSTR& s) {s = GetString(IDS_AP_SDELETEMOD);}  
		virtual Class_ID ClassID() { return Class_ID(SDELETE_CLASS_ID,0);}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_SDELETEMOD);}

		// From modifier
		ChannelMask ChannelsUsed()  {return PART_GEOM|PART_TOPO|PART_SELECT|PART_SUBSEL_TYPE;}
		ChannelMask ChannelsChanged() {return PART_GEOM|PART_TOPO|PART_SELECT;}
		Class_ID InputType() {return splineShapeClassID;}
		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval LocalValidity(TimeValue t) {return FOREVER;}

		// From BaseObject
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;} 
		
		int NumRefs() {return 0;}
		RefTargetHandle GetReference(int i) {return NULL;}
		void SetReference(int i, RefTargetHandle rtarg) {}

		int NumSubs() {return 0;}
		Animatable* SubAnim(int i) {return NULL;}
		TSTR SubAnimName(int i) {return _T("");}

		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message) {return REF_SUCCEED;}
	};


//--- ClassDescriptor and class vars ---------------------------------

class SDeleteClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new SDeleteMod; }
	const TCHAR *	ClassName() { return GetString(IDS_AP_SDELETEMOD); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(SDELETE_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFDEFORMATIONS);}
	};

static SDeleteClassDesc SdeleteDesc;
ClassDesc* GetSDeleteModDesc() {return &SdeleteDesc;}


//--- Delete mod methods -------------------------------

SDeleteMod::SDeleteMod()
	{

	}

RefTargetHandle SDeleteMod::Clone(RemapDir& remap)
	{
	return new SDeleteMod();
	}

void SDeleteMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{ if (os->obj->CanConvertToType(splineShapeClassID))
  {		SplineShape *sshape = (SplineShape *)os->obj->ConvertToType(t,splineShapeClassID);
		int ss;
		switch (ss=sshape->shape.selLevel)
		{ case SHAPE_OBJECT: 
			{ for(int poly = sshape->shape.vertSel.polys - 1; poly >= 0; --poly) 
			  	 sshape->shape.vertSel[poly].SetAll(); 
			  sshape->shape.DeleteSelectedVerts(); 
			}
			break;
		  case SHAPE_VERTEX: sshape->shape.DeleteSelectedVerts();
						  break;
		  case SHAPE_SEGMENT: sshape->shape.DeleteSelectedSegs();
						 break;
		  case SHAPE_SPLINE:  sshape->shape.DeleteSelectedPolys();
						break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editmesh.cpp ===
/**********************************************************************
 *<
	FILE: editmesh.cpp

	DESCRIPTION:  Edit Mesh OSM

	CREATED BY: Dan Silva & Rolf Berteig

	HISTORY: created 18 March, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "MeshDLib.h"
#include "editmesh.h"

HWND                EditMeshMod::hSel = NULL;
HWND                EditMeshMod::hGeom = NULL;
HWND                EditMeshMod::hSurf = NULL;
HWND				EditMeshMod::hAR = NULL;
IObjParam*          EditMeshMod::ip      = NULL;

MoveModBoxCMode*    EditMeshMod::moveMode        = NULL;
RotateModBoxCMode*  EditMeshMod::rotMode 	     = NULL;
UScaleModBoxCMode*  EditMeshMod::uscaleMode      = NULL;
NUScaleModBoxCMode* EditMeshMod::nuscaleMode     = NULL;
SquashModBoxCMode*  EditMeshMod::squashMode      = NULL;
SelectModBoxCMode*  EditMeshMod::selectMode      = NULL;
ExtrudeCMode*       EditMeshMod::extrudeMode     = NULL;
BevelCMode * EditMeshMod::bevelMode = NULL;
ChamferCMode *EditMeshMod::chamferMode = NULL;
CreateVertCMode*	EditMeshMod::createVertMode  = NULL;
WeldVertCMode* EditMeshMod::weldVertMode = NULL;
AttachPickMode* EditMeshMod::attachPickMode = NULL;
CreateFaceCMode* EditMeshMod::createFaceMode = NULL;
TurnEdgeCMode* EditMeshMod::turnEdgeMode = NULL;
DivideEdgeCMode* EditMeshMod::divideEdgeMode = NULL;
DivideFaceCMode* EditMeshMod::divideFaceMode = NULL;
CutEdgeCMode * EditMeshMod::cutEdgeMode = NULL;
FlipNormCMode * EditMeshMod::flipMode = NULL;

BOOL  EditMeshMod::inExtrude = FALSE;
BOOL EditMeshMod::inBevel = FALSE;
BOOL EditMeshMod::inChamfer = FALSE;
int EditMeshMod::extType = MESH_EXTRUDE_CLUSTER;
BOOL EditMeshMod::inBuildFace = FALSE;
BOOL EditMeshMod::inCutEdge = FALSE;
BOOL EditMeshMod::faceUIValid = FALSE;
float EditMeshMod::normScale = -1.0f;
BOOL EditMeshMod::ignoreBackfaces = FALSE;
BOOL EditMeshMod::ignoreVisEdge = FALSE;
BOOL EditMeshMod::selByVert = FALSE;
int EditMeshMod::weldBoxSize = DEF_PICKBOX_SIZE;
int EditMeshMod::pickBoxSize = DEF_PICKBOX_SIZE;
Quat EditMeshMod::sliceRot(0.0f,0.0f,0.0f,1.0f);
Point3 EditMeshMod::sliceCenter(0.0f,0.0f,0.0f);
bool EditMeshMod::sliceMode = FALSE;
float EditMeshMod::sliceSize = 100.0f;
bool EditMeshMod::sliceSplit = FALSE;
bool EditMeshMod::cutRefine = TRUE;
BOOL EditMeshMod::rsSel = TRUE;
BOOL EditMeshMod::rsAR = FALSE;
BOOL EditMeshMod::rsGeom = TRUE;
BOOL EditMeshMod::rsSurf = TRUE;
int EditMeshMod::condenseMat = FALSE;
int EditMeshMod::attachMat = ATTACHMAT_IDTOMAT;

static EditMeshClassDesc editMeshDesc;
extern ClassDesc* GetEditMeshModDesc() { return &editMeshDesc; }

void EditMeshClassDesc::ResetClassParams(BOOL fileReset) {
	EditMeshMod::normScale       = -1.0f;
	EditMeshMod::selByVert       = FALSE;
	EditMeshMod::extType = MESH_EXTRUDE_CLUSTER;
	EditMeshMod::sliceMode = FALSE;
	EditMeshMod::sliceSize = 100.0f;
	EditMeshMod::sliceSplit = FALSE;
	EditMeshMod::cutRefine = TRUE;
	EditMeshMod::rsSel = TRUE;
	EditMeshMod::rsAR = FALSE;
	EditMeshMod::rsGeom = TRUE;
	EditMeshMod::rsSurf = TRUE;
	EditMeshMod::condenseMat = FALSE;
	EditMeshMod::attachMat = ATTACHMAT_IDTOMAT;
	ResetEditMeshUI();
}

EditMeshDeleteEvent delEvent;


/*-------------------------------------------------------------------*/
//
// Per instance data
//

EditMeshData::EditMeshData() {
	flags = 0;
	mod = NULL;
	mesh = NULL;
	tmr = NULL;
	tempData = NULL;
	mValid.SetEmpty ();
	topoValid.SetEmpty ();
	geomValid.SetEmpty ();
	updateMD = FALSE;
	lockInvalidate = FALSE;
}

EditMeshData::EditMeshData(EditMeshData& emc) {
	mdelta   = emc.mdelta;
	for (int i=0; i<3; i++) selSet[i] = emc.selSet[i];
	flags    = emc.flags & EMD_HASDATA;
	mod = NULL;
	mesh = NULL;
	tmr = NULL;
	tempData = NULL;
	mValid.SetEmpty ();
	topoValid.SetEmpty ();
	geomValid.SetEmpty ();
	updateMD = FALSE;
	lockInvalidate = FALSE;
}

EditMeshData::~EditMeshData() {
	if (tempData) delete tempData;
	if (mesh) delete mesh;
	if (tmr) delete tmr;
}

void EditMeshData::Apply (TimeValue t, TriObject *triOb, EditMeshMod *mod) {
	Interval inGeomValid = triOb->ChannelValidity (t, GEOM_CHAN_NUM);
	Interval inTopoValid = triOb->ChannelValidity (t, TOPO_CHAN_NUM);
	Interval inVCValid = triOb->ChannelValidity (t, VERT_COLOR_CHAN_NUM);
	Interval inTexValid = triOb->ChannelValidity (t, TEXMAP_CHAN_NUM);

	if (!GetFlag(EMD_UPDATING_CACHE) && MeshCached(t)) {
		// Just copy the cached mesh.
		triOb->GetMesh().DeepCopy (GetMesh(t),
			PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|
			PART_DISPLAY|PART_TOPO|PART_TEXMAP|PART_VERTCOLOR);
		triOb->PointsWereChanged();
	}
	else if (GetFlag(EMD_HASDATA)) {
		// Use the mesh delta.
		triOb->GetMesh().freeVSelectionWeights ();
		lastInVNum = triOb->GetMesh().numVerts;
		lastInFNum = triOb->GetMesh().numFaces;
		if (mdelta.vnum < lastInVNum) mdelta.SetInVNum (lastInVNum);
		else if (mdelta.vnum > lastInVNum) updateMD = TRUE;
		if (mdelta.fnum < lastInFNum) mdelta.SetInFNum (lastInFNum);
		else if (mdelta.fnum > lastInFNum) updateMD = TRUE;
		lastInMVNum.SetCount (mdelta.mapSupport.GetSize());
		for (int i=0; i<mdelta.mapSupport.GetSize(); i++) {
			if (!mdelta.mapSupport[i]) continue;
			if (!triOb->GetMesh().mapSupport(i)) lastInMVNum[i] = lastInVNum;
			else lastInMVNum[i] = triOb->GetMesh().getNumMapVerts (i);
			if (mdelta.map[i].vnum < lastInMVNum[i]) mdelta.map[i].SetInVNum (lastInMVNum[i]);
			else if (mdelta.map[i].vnum > lastInMVNum[i]) updateMD = TRUE;
		}
		mdelta.Apply(triOb->GetMesh());
		selSet[NS_VERTEX].SetSize(triOb->GetMesh().getNumVerts());
		selSet[NS_FACE].SetSize(triOb->GetMesh().getNumFaces());
		selSet[NS_EDGE].SetSize(triOb->GetMesh().getNumFaces()*3);
		triOb->PointsWereChanged();
	}

	triOb->GetMesh().dispFlags = 0;
	bool dispVerts = FALSE;
	if (mod->inBuildFace) dispVerts = TRUE;

	switch (mod->selLevel) {
	case SL_VERTEX:
		dispVerts = TRUE;
		break;
	case SL_POLY:
	case SL_ELEMENT:
		triOb->GetMesh().SetDispFlag(DISP_SELPOLYS);
		if (mod->normScale>0.0f) triOb->GetMesh().displayNormals(TRUE,mod->normScale);
		break;
	case SL_FACE:
		triOb->GetMesh().SetDispFlag(DISP_SELFACES);
		if (mod->normScale>0.0f) triOb->GetMesh().displayNormals(TRUE,mod->normScale);
		break;
	case SL_EDGE:
		triOb->GetMesh().SetDispFlag(DISP_SELEDGES);
		break;
	}
	if (dispVerts && (!mod->ip || !mod->ip->GetShowEndResult()))
		triOb->GetMesh().SetDispFlag(DISP_VERTTICKS|DISP_SELVERTS);
	triOb->GetMesh().selLevel = meshLevel[mod->selLevel];
	
	// If we have got tvFaces then make sure the flag is
	// set for all faces.
	if (triOb->GetMesh().tvFace) {
		for (int i=0; i<triOb->GetMesh().getNumFaces(); i++) {
			triOb->GetMesh().faces[i].flags |= HAS_TVERTS;
		}
	}

	if (GetFlag(EMD_UPDATING_CACHE)) {
		//MaxAssert(tempData);
		UpdateCache(t, triOb);
		SetFlag(EMD_UPDATING_CACHE,FALSE);
	}

	// Output only changes over time in response to certain changes in input.
	triOb->UpdateValidity (GEOM_CHAN_NUM, inGeomValid & inTopoValid);
	triOb->UpdateValidity (TOPO_CHAN_NUM, inTopoValid);
	triOb->UpdateValidity (SELECT_CHAN_NUM, inTopoValid);
	triOb->UpdateValidity (SUBSEL_TYPE_CHAN_NUM, FOREVER);
	triOb->UpdateValidity (DISP_ATTRIB_CHAN_NUM, inTopoValid);
	int vc=0;
	if (mdelta.mapSupport[0]) {
		triOb->UpdateValidity (VERT_COLOR_CHAN_NUM, inTopoValid & inVCValid);
		vc = 1;
	}
	if (mdelta.mapSupport.NumberSet() > vc) {
		triOb->UpdateValidity (TEXMAP_CHAN_NUM, inTopoValid & inTexValid);
	}

	if (mod->affectRegion && mod->selLevel) {
		triOb->GetMesh().SupportVSelectionWeights ();
		float *vsw = triOb->GetMesh().getVSelectionWeights ();
		float *ourvw = TempData(t)->VSWeight (mod->useEdgeDist, mod->edgeIts, mod->arIgBack,
			mod->falloff, mod->pinch, mod->bubble)->Addr(0);
		memcpy (vsw, ourvw, triOb->GetMesh().getNumVerts()*sizeof(float));
	}
}

void EditMeshData::BeginEdit (TimeValue t) {
	MaxAssert(tempData);
	if (GetFlag(EMD_HASDATA)) return;
	GetMesh (t);
	mdelta.InitToMesh (*mesh);
	if (mdelta.vdSupport.GetSize() > VDATA_SELECT)
		mdelta.vdSupport.Clear (VDATA_SELECT);	// Clear out incoming soft selections.
	SetFlag(EMD_HASDATA,TRUE);
}

BitArray EditMeshData::GetSel (int nsl) {
	switch (nsl) {
	case NS_VERTEX: return mdelta.vsel;
	case NS_EDGE: return mdelta.esel;
	}
	return mdelta.fsel;
}

void EditMeshData::AddVertHide (BitArray hideMe, IMeshSelect *mod, TimeValue t) {
	BeginEdit (t);
	if (theHold.Holding()) theHold.Put (new VertexHideRestore (this, (EditMeshMod*)mod));
	hideMe.SetSize (mesh->numVerts);
	mesh->vertHide |= hideMe;
	BitArray nsel = mesh->vertSel & ~hideMe;
	hideMe.SetSize (mdelta.outVNum());
	mdelta.vhide |= hideMe;
	if (nsel.NumberSet() != mesh->vertSel.NumberSet()) SetVertSel (nsel, mod, t);
}

void EditMeshData::ClearVertHide (IMeshSelect *mod, TimeValue t) {
	BeginEdit (t);
	if (theHold.Holding()) theHold.Put (new VertexHideRestore (this, (EditMeshMod*)mod));
	mesh->vertHide.ClearAll ();
	mdelta.vhide.ClearAll ();
}

void EditMeshData::SetVertSel (BitArray &set, IMeshSelect *mod, TimeValue t) {
	EditMeshMod *em = (EditMeshMod *) mod;
	BeginEdit (t);
	if (theHold.Holding()) theHold.Put (new MeshSelectRestore (this, em, SL_VERTEX));
	mesh->vertSel = set;
	mesh->vertSel.SetSize (mesh->numVerts);
	mesh->vertSel &= ~mesh->vertHide;
	mdelta.vsel = mesh->vertSel;
	if (mdelta.vsel.GetSize () != mdelta.outVNum()) {
		mdelta.vsel.SetSize (mdelta.outVNum(), TRUE);
	}
	Invalidate (PART_SELECT);
}

void EditMeshData::SetFaceSel(BitArray &set, IMeshSelect *mod, TimeValue t) {
	EditMeshMod *em = (EditMeshMod *) mod;
	BeginEdit (t);
	if (theHold.Holding()) theHold.Put (new MeshSelectRestore(this, em, SL_FACE));
	mdelta.fsel = set;
	if (set.GetSize () != mdelta.outFNum()) {
		mdelta.fsel.SetSize (mdelta.outFNum(), TRUE);
	}
	GetMesh (t);
	mdelta.SelectFacesByFlags (*mesh, FALSE, FACE_HIDDEN, FACE_HIDDEN);
	mesh->faceSel = mdelta.fsel;
	mesh->faceSel.SetSize (mesh->numFaces);
	Invalidate(PART_SELECT);
}

void EditMeshData::SetEdgeSel(BitArray &set, IMeshSelect *mod, TimeValue t) {
	EditMeshMod *em = (EditMeshMod *) mod;
	BeginEdit (t);
	if (theHold.Holding()) theHold.Put (new MeshSelectRestore (this, em, SL_EDGE));
	mdelta.esel = set;
	if (set.GetSize () != mdelta.outFNum()*3) {
		mdelta.esel.SetSize (mdelta.outFNum()*3, TRUE);
	}
	if (MeshCached(t)) {
		mesh->edgeSel = mdelta.esel;
		mesh->edgeSel.SetSize (mesh->numFaces*3);
		Invalidate(PART_SELECT);
	}
}

void EditMeshData::SetSel (int nsl, BitArray & set, IMeshSelect *mod, TimeValue t) {
	switch (nsl) {
	case NS_VERTEX: SetVertSel (set, mod, t); break;
	case NS_EDGE: SetEdgeSel (set, mod, t); break;
	case NS_FACE: SetFaceSel (set, mod, t); break;
	}
}

class NamedSetSizeChange : public RestoreObj {
public:
	// STEVE: should this be a reference?
	EditMeshData *emd;
	int nsl;
	int oldsize, change;

	NamedSetSizeChange (EditMeshData *e, int n, int old, int inc) { emd=e; nsl=n; oldsize=old; change=inc; }
	void Restore (int isUndo) { emd->selSet[nsl].SetSize (oldsize); }
	void Redo () { emd->selSet[nsl].SetSize (oldsize+change); }
	int GetSize () { return 3*sizeof(int) + sizeof (void *); }
	TSTR Description () { return _T("Named Selection Set Size Change"); }
};

void EditMeshData::ChangeNamedSetSize (int nsl, int oldsize, int change) {
	if (change == 0) return;
	if (selSet[nsl].Count() == 0) return;
	if (theHold.Holding())
		theHold.Put (new NamedSetSizeChange (this, nsl, oldsize, change));
	selSet[nsl].SetSize (oldsize + change);
}

class NamedSetDelete : public RestoreObj {
public:
	// STEVE: should this be a reference?
	EditMeshData *emd;
	int nsl;
	Tab<BitArray *> oldSets;
	BitArray del;

	NamedSetDelete (EditMeshData *em, int n, BitArray &d);
	~NamedSetDelete ();
	void Restore (int isUndo);
	void Redo () { emd->selSet[nsl].DeleteSetElements (del, (nsl==NS_EDGE) ? 3 : 1); }
	int GetSize () { return 3*sizeof(int) + sizeof (void *); }
	TSTR Description () { return _T("Named Selection Set Subset Deletion"); }
};

NamedSetDelete::NamedSetDelete (EditMeshData *em, int n, BitArray &d) {
	emd = em;
	nsl = n;
	del = d;
	oldSets.SetCount (emd->selSet[nsl].Count());
	for (int i=0; i<emd->selSet[nsl].Count(); i++) {
		oldSets[i] = new BitArray;
		(*oldSets[i]) = (*(emd->selSet[nsl].sets[i]));
	}
}

NamedSetDelete::~NamedSetDelete () {
	for (int i=0; i<oldSets.Count(); i++) delete oldSets[i];
}

void NamedSetDelete::Restore (int isUndo) {
	int i, max = oldSets.Count();
	if (emd->selSet[nsl].Count() < max) max = emd->selSet[nsl].Count();
	for (i=0; i<max; i++) *(emd->selSet[nsl].sets[i]) = *(oldSets[i]);
}

void EditMeshData::DeleteNamedSetArray (int nsl, BitArray & del) {
	if (del.NumberSet() == 0) return;
	if (selSet[nsl].Count() == 0) return;
	if (theHold.Holding()) 
		theHold.Put (new NamedSetDelete (this, nsl, del));
	selSet[nsl].DeleteSetElements (del, (nsl==NS_EDGE) ? 3 : 1);
}

void EditMeshData::ApplyMeshDelta (MeshDelta & md, MeshDeltaUser *mdu, TimeValue t) {
	DWORD partsChanged = md.PartsChanged();
	if (updateMD) partsChanged |= (PART_TOPO|PART_GEOM|PART_SELECT|PART_TEXMAP|PART_VERTCOLOR);
	EditMeshMod *mod = (EditMeshMod *) mdu;
	BeginEdit (t);
	if (theHold.Holding()) {
		theHold.Put(new MeshEditRestore (this, mod, md));
	}
	if (updateMD) {
		mdelta.SetInVNum (lastInVNum);
		mdelta.SetInFNum (lastInFNum);
		for (int mp=0; mp<mdelta.mapSupport.GetSize(); mp++) {
			if (!mdelta.mapSupport[mp]) continue;
			mdelta.map[mp].SetInVNum (lastInMVNum[mp]);
		}
		updateMD = FALSE;
	}

	// If there are creates, modify the named selection sets to match:
	int nv;
	if (nv = md.vCreate.Count() + md.vClone.Count()) {
		ChangeNamedSetSize (NS_VERTEX, mdelta.outVNum(), nv);
	}
	if (md.fCreate.Count()) {
		ChangeNamedSetSize (NS_EDGE, mdelta.outFNum()*3, md.fCreate.Count()*3);
		ChangeNamedSetSize (NS_FACE, mdelta.outFNum(), md.fCreate.Count());
	}

	// If we clone any of mdelta's creates, we'll have to recompute the mesh.
	Tab<DWORD> cloneRemapTable;
	BOOL reorder = md.vCreate.Count() && mdelta.vClone.Count();
	mdelta.Compose (md, &cloneRemapTable);
	if (cloneRemapTable.Count() || reorder) {
		Invalidate (partsChanged, FALSE);
	} else {
		if (MeshCached (t)) md.Apply(*mesh);
		Invalidate (partsChanged, TRUE);
	}

	// If there were deletes, change the named selection sets to match:
	if (md.vDelete.NumberSet()) {
		DeleteNamedSetArray (NS_VERTEX, md.vDelete);
	}
	if (md.fDelete.NumberSet()) {
		DeleteNamedSetArray (NS_EDGE, md.fDelete);
		DeleteNamedSetArray (NS_FACE, md.fDelete);
	}

	mod->LocalDataChanged (partsChanged);
}

/*-------------------------------------------------------------------*/		
//
// Edit Mesh Modifier
//


EditMeshMod::EditMeshMod() {
	//if (GetSystemSetting(SYSSET_ENABLE_EDITMESHMOD)) selLevel = SL_VERTEX;
	selLevel = SL_OBJECT;
	affectRegion = FALSE;
	useEdgeDist = 0;
	edgeIts = 1;
	arIgBack = 0;
	falloff = 20.0f;
	pinch = bubble = 0.0f;
	emFlags = 0;
}

EditMeshMod::~EditMeshMod() {
	ClearSetNames();
}

class ScaleVertDeltas : public ModContextEnumProc {
public:
	float f;
	EditMeshMod *mod;
	ScaleVertDeltas(float ff,EditMeshMod *m) {f=ff;mod=m;}
	BOOL proc(ModContext *mc) {
		EditMeshData *emdata = (EditMeshData*)mc->localData;
		if (!emdata) return TRUE;
		if (theHold.Holding()) theHold.Put(new VertexEditRestore(emdata, mod));
		MeshDelta & md = emdata->mdelta;
		for (int i=0; i<md.vMove.Count(); i++) md.vMove[i].dv *= f;
		for (i=0; i<md.vCreate.Count(); i++) md.vCreate[i] *= f;
		for (i=0; i<md.vClone.Count(); i++) md.vClone[i].dv *= f;
		return TRUE;
	}
};

void EditMeshMod::RescaleWorldUnits(float f) {
	if (TestAFlag(A_WORK1)) return;
	SetAFlag(A_WORK1);
	ScaleVertDeltas svd(f,this);
	EnumModContexts(&svd);
}

Interval EditMeshMod::LocalValidity(TimeValue t) {
	// Force a cache if being edited.
	// TH 12/20/95 -- Uncommented this code to test fix of failure to cache Extrusions/Lathes
	 if (TestAFlag(A_MOD_BEING_EDITED))  // DONT WANT THIS since we have our own Cache.
	 	return NEVER;
	return FOREVER;
}

RefTargetHandle EditMeshMod::Clone(RemapDir& remap) {
	EditMeshMod* newmod = new EditMeshMod();
	newmod->selLevel = selLevel;
	newmod->affectRegion = affectRegion;
	newmod->falloff = falloff;
	newmod->pinch = pinch;
	newmod->bubble = bubble;
	newmod->useEdgeDist = useEdgeDist;
	newmod->edgeIts = edgeIts;
	newmod->arIgBack = arIgBack;
	return(newmod);
}

BOOL EditMeshMod::DependOnTopology(ModContext &mc) {
	EditMeshData *meshData = (EditMeshData*)mc.localData;
	if (meshData) {
		if (meshData->GetFlag(EMD_HASDATA)) {
			return TRUE;
		}
	}
	return FALSE;
}


void EditMeshMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) {
	MaxAssert(os->obj->IsSubClassOf(triObjectClassID));

	TriObject *triOb = (TriObject *)os->obj;
	EditMeshData *meshData;

	if ( !mc.localData ) {
		mc.localData = new EditMeshData();
		meshData = (EditMeshData*)mc.localData;
	} else {
		meshData = (EditMeshData*)mc.localData;
	}
	meshData->SetModifier (this);

	meshData->Apply(t,triOb,this);
}

void EditMeshMod::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc) {
	if ( mc->localData ) {
		EditMeshData *meshData = (EditMeshData*)mc->localData;
		if ( meshData ) meshData->Invalidate(partID,FALSE);
	}
}

void EditMeshMod::SelectSubComponent (HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert) {
	if (selLevel == SL_OBJECT) return;
	if (!ip) return;
	if (sliceMode) return;
	TimeValue t = ip->GetTime();
	ip->ClearCurNamedSelSet();
	EndExtrude(t);

	AdjFaceList *af=NULL;
	AdjEdgeList *ae=NULL;
	BitArray nsel;
	HitRecord *hr;
	EditMeshData *meshData;
	Mesh *mesh;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	int nd;

	int localSelByVert = selByVert;
	if (cutEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (turnEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (divideEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (divideFaceMode == ip->GetCommandMode()) localSelByVert = FALSE;

	for (nd=0; nd<mcList.Count(); nd++) {
		meshData = (EditMeshData*) mcList[nd]->localData;
		if (meshData==NULL) continue;
		if (!all && (hitRec->modContext->localData != meshData)) continue;
		for (hr=hitRec; hr!=NULL; hr=hr->Next()) if (hr->modContext->localData == meshData) break;
		if (hr==NULL) continue;

		mesh = meshData->GetMesh (t);
		if (selLevel>=SL_POLY) af = meshData->TempData(t)->AdjFList();
		if (localSelByVert) ae = meshData->TempData(t)->AdjEList();

		switch (selLevel) {
		case SL_VERTEX:
			nsel = mesh->vertSel;
			for (; hr != NULL; hr=hr->Next()) {
				if (hr->modContext->localData != meshData) continue;
				nsel.Set (hr->hitInfo, invert ? !nsel[hr->hitInfo] : selected);
				if (!all) break;
			}
			meshData->SetVertSel (nsel, this, t);
			break;

		case SL_EDGE:
			nsel = mesh->edgeSel;
			for (; hr != NULL; hr=hr->Next()) {
				if (hr->modContext->localData != meshData) continue;
				if (localSelByVert) {
					DWORDTab & list = ae->list[hr->hitInfo];
					for (int i=0; i<list.Count(); i++) {
						MEdge & me = ae->edges[list[i]];
						for (int j=0; j<2; j++) {
							if (me.f[j] == UNDEFINED) continue;
							DWORD ei = mesh->faces[me.f[j]].GetEdgeIndex (me.v[0], me.v[1]);
							if (ei>2) continue;
							ei += me.f[j]*3;
							nsel.Set (ei, invert ? !mesh->edgeSel[ei] : selected);
						}
					}
				} else {
					nsel.Set (hr->hitInfo, invert ? !nsel[hr->hitInfo] : selected);
				}
				if (!all) break;
			}
			meshData->SetEdgeSel (nsel, this, t);
			break;

		case SL_FACE:
			nsel = mesh->faceSel;
			for (; hr != NULL; hr=hr->Next()) {
				if (hr->modContext->localData != meshData) continue;
				if (localSelByVert) {
					DWORDTab & list = ae->list[hr->hitInfo];
					for (int i=0; i<list.Count(); i++) {
						MEdge & me = ae->edges[list[i]];
						for (int j=0; j<2; j++) {
							if (me.f[j] == UNDEFINED) continue;
							nsel.Set (me.f[j], invert ? !mesh->faceSel[me.f[j]] : selected);
						}
					}
				} else {
					nsel.Set (hr->hitInfo, invert ? !mesh->faceSel[hr->hitInfo] : selected);
				}
				if (!all) break;
			}
			meshData->SetFaceSel (nsel, this, t);
			break;

		case SL_POLY:
		case SL_ELEMENT:
			nsel.SetSize (mesh->getNumFaces());
			nsel.ClearAll ();
			for (; hr != NULL; hr=hr->Next()) {
				if (hr->modContext->localData != meshData) continue;
				if (!localSelByVert) {
					if (selLevel==SL_ELEMENT) mesh->ElementFromFace (hr->hitInfo, nsel, af);
					else mesh->PolyFromFace (hr->hitInfo, nsel, GetPolyFaceThresh(), ignoreVisEdge, af);
				} else {
					DWORDTab & list = ae->list[hr->hitInfo];
					for (int i=0; i<list.Count(); i++) {
						MEdge & me = ae->edges[list[i]];
						for (int j=0; j<2; j++) {
							if (me.f[j] == UNDEFINED) continue;
							if (selLevel==SL_ELEMENT) mesh->ElementFromFace (me.f[j], nsel, af);
							else mesh->PolyFromFace (me.f[j], nsel, GetPolyFaceThresh(), ignoreVisEdge, af);
						}
					}
				}
				if (!all) break;
			}
			if (invert) nsel ^= mesh->faceSel;
			else {
				if (selected) nsel |= mesh->faceSel;
				else nsel = mesh->faceSel & ~nsel;
			}
			meshData->SetFaceSel (nsel, this, t);
		}
	}
	LocalDataChanged ();
	nodes.DisposeTemporary ();
}

void EditMeshMod::ClearSelection(int selLevel) {
	if (selLevel==SL_OBJECT) return;
	if (!ip) return;	
	if (sliceMode) return;

	EndExtrude(ip->GetTime());

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ip->ClearCurNamedSelSet();
	BitArray nsel;

	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;		
		Mesh *mesh = meshData->GetMesh (ip->GetTime());
		switch (selLevel) {
		case SL_VERTEX:
			nsel.SetSize (mesh->getNumVerts());
			nsel.ClearAll ();
			meshData->SetVertSel (nsel, this, ip->GetTime());
			break;
		case SL_FACE:
		case SL_POLY:
		case SL_ELEMENT:
			nsel.SetSize (mesh->getNumFaces());
			nsel.ClearAll ();
			meshData->SetFaceSel (nsel, this, ip->GetTime());
			break;
		case SL_EDGE:
			nsel.SetSize (mesh->getNumFaces()*3);
			nsel.ClearAll ();
			meshData->SetEdgeSel (nsel, this, ip->GetTime());
			break;
		}
	}
	
	nodes.DisposeTemporary();
	LocalDataChanged ();
}

void EditMeshMod::SelectAll(int selLevel) {
	if (selLevel==SL_OBJECT) return;
	if (!ip) return;	
	if (sliceMode) return;

	EndExtrude(ip->GetTime());

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ip->ClearCurNamedSelSet();

	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		Mesh *mesh = meshData->GetMesh (ip->GetTime());
		BitArray sel;

		switch ( selLevel ) {
		case SL_VERTEX:	
			sel.SetSize (mesh->numVerts);
			sel.SetAll ();
			meshData->SetVertSel (sel, this, ip->GetTime());
			break;

		case SL_EDGE:
			sel.SetSize (mesh->numFaces*3);
			sel.SetAll ();
			meshData->SetEdgeSel (sel, this, ip->GetTime());
			break;

		default:
			sel.SetSize (mesh->numFaces);
			sel.SetAll ();
			meshData->SetFaceSel (sel, this, ip->GetTime());
			break;
		}
	}

	nodes.DisposeTemporary();
	LocalDataChanged ();
}

void EditMeshMod::InvertSelection(int selLevel) {
	if ( !ip ) return;
	if (selLevel == SL_OBJECT) return;
	if (sliceMode) return;
	EndExtrude(ip->GetTime());

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ip->ClearCurNamedSelSet();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;		
		Mesh *mesh = meshData->GetMesh (ip->GetTime());
		BitArray sel;

		switch ( selLevel ) {
		case SL_VERTEX:	
			sel = ~mesh->vertSel;
			meshData->SetVertSel (sel, this, ip->GetTime ());
			break;
	
		case SL_EDGE:
			sel = ~mesh->edgeSel;
			meshData->SetEdgeSel (sel, this, ip->GetTime());
			break;

		default:
			sel = ~mesh->faceSel;
			meshData->SetFaceSel (sel, this, ip->GetTime());
			break;
		}
	}
	
	nodes.DisposeTemporary();
	LocalDataChanged ();
}

void EditMeshMod::InvalidateDistances () {
	if ( !ip ) return;
	if (selLevel == SL_OBJECT) return;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		MeshTempData *emt = meshData->tempData;
		if (!emt) continue;
		emt->InvalidateDistances ();
	}
	nodes.DisposeTemporary();
}

void EditMeshMod::InvalidateAffectRegion () {
	if ( !ip ) return;
	if (selLevel == SL_OBJECT) return;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		MeshTempData *emt = meshData->tempData;
		if (!emt) continue;
		emt->InvalidateAffectRegion ();
	}
	nodes.DisposeTemporary();
}

DWORD EditMeshMod::GetSelLevel () {
	switch (selLevel) {
	case SL_OBJECT: return IMESHSEL_OBJECT;
	case SL_VERTEX: return IMESHSEL_VERTEX;
	case SL_EDGE: return IMESHSEL_EDGE;
	}
	return IMESHSEL_FACE;
}

void EditMeshMod::SetSelLevel (DWORD sl) {
	switch (sl) {
	case IMESHSEL_OBJECT:
		selLevel = SL_OBJECT;
		break;
	case IMESHSEL_VERTEX:
		selLevel = SL_VERTEX;
		break;
	case IMESHSEL_EDGE:
		selLevel = SL_EDGE;
		break;
	case IMESHSEL_FACE:
		if (selLevel < SL_FACE) selLevel = SL_POLY;	// don't change if we're already in a face mode.
		break;
	}
	if (ip) ip->SetSubObjectLevel(selLevel);
}

void EditMeshMod::LocalDataChanged () {
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	if ( !ip ) return;	
	ip->ClearCurNamedSelSet();
	InvalidateSurfaceUI ();
	InvalidateNumberSelected ();
	UpdateNamedSelDropDown ();
}

void EditMeshMod::LocalDataChanged (DWORD parts) {
	NotifyDependents(FOREVER, parts, REFMSG_CHANGE);
	if (!ip) return;
	ip->ClearCurNamedSelSet();
	InvalidateSurfaceUI ();
	if (parts & SELECT_CHANNEL) InvalidateNumberSelected ();
}


//------Named Selection Sets-----------------------------

// Strategy:
// We need to keep track of named selection sets simultaneously at the
// modifier and localmoddata levels.  Therefore we have the namedSel and ids
// tables in EditMeshMod, plus the GenericNamedSelSetLists in each EditMeshData,
// with its individual tables of names, sets, and ids.  The ids appear to be used 
// instead of names in the localmoddatas -- this saves space and comparison time.


// Relevant restore objects:
class EMAppendSetRestore : public RestoreObj {
public:
	BitArray set;		
	DWORD id;
	TSTR name;
	GenericNamedSelSetList *setList;		

	EMAppendSetRestore(GenericNamedSelSetList *sl, DWORD idd, TSTR & n) { setList = sl; id=idd; name = n; }
	void Restore(int isUndo) {
		set = *setList->GetSet (id);
		setList->RemoveSet(id);
	}
	void Redo() { setList->AppendSet(set,id,name); }
			
	TSTR Description() { return TSTR(_T("Append Set")); }
};

class EMAppendSetNameRestore : public RestoreObj {
public:		
	TSTR name;
	DWORD id;
	EditMeshMod *et;
	Tab<TSTR*> *sets;
	Tab<DWORD> *ids;

	EMAppendSetNameRestore(EditMeshMod *e,Tab<TSTR*> *s,Tab<DWORD> *i) 
		{et = e; sets = s; ids = i;}
	void Restore(int isUndo) {			
		name = *(*sets)[sets->Count()-1];
		id   = (*ids)[sets->Count()-1];
		delete (*sets)[sets->Count()-1];
		sets->Delete(sets->Count()-1,1);			
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
	void Redo() {
		TSTR *nm = new TSTR(name);
		sets->Append(1,&nm);
		ids->Append(1,&id);
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
			
	TSTR Description() {return TSTR(_T("Append Set Name"));}
};

class EMDeleteSetRestore : public RestoreObj {
public:
	BitArray set;
	DWORD id;
	TSTR name;
	GenericNamedSelSetList *setList;

	EMDeleteSetRestore(GenericNamedSelSetList *sl,DWORD i, TSTR & n) {
		setList = sl;
		id = i;
		name = n;
		BitArray *ptr = setList->GetSet(id);
		if (ptr) set = *ptr;
	}
	void Restore(int isUndo) { setList->AppendSet(set,id,name); }
	void Redo() { setList->RemoveSet(id); }
	TSTR Description() {return TSTR(_T("Delete Named Set"));}
};

class EMDeleteSetNameRestore : public RestoreObj {
public:
	TSTR name;
	DWORD id;
	EditMeshMod *et;
	Tab<TSTR*> *sets;
	Tab<DWORD> *ids;

	EMDeleteSetNameRestore(Tab<TSTR*> *s, EditMeshMod *e,Tab<DWORD> *i, DWORD id) {
		sets = s;
		et = e;		
		this->id = id;
		ids = i;
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
			}
		}
		if (index>=0) {
			name = *(*sets)[index];
		}
	}   		
	void Restore(int isUndo) {			
		TSTR *nm = new TSTR(name);			
		sets->Append(1,&nm);
		ids->Append(1,&id);
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
	void Redo() {
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
			}
		}
		if (index>=0) {
			sets->Delete(index,1);
			ids->Delete(index,1);
		}
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
			
	TSTR Description() {return TSTR(_T("Delete Set Name"));}
};

class EMSetNameRestore : public RestoreObj {
public:
	TSTR undo, redo;
	DWORD id;
	Tab<TSTR*> *sets;
	Tab<DWORD> *ids;
	EditMeshMod *et;
	EMSetNameRestore(Tab<TSTR*> *s, EditMeshMod *e,Tab<DWORD> *i,DWORD id) {
		this->id = id;
		ids = i;
		sets = s; et = e;
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
			}
		}
		if (index>=0) {
			undo = *(*sets)[index];
		}			
	}

	void Restore(int isUndo) {
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
			}
		}
		if (index>=0) {
			redo = *(*sets)[index];
			*(*sets)[index] = undo;
		}			
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
	void Redo() {
		int index = -1;
		for (int j=0; j<sets->Count(); j++) {
			if ((*ids)[j]==id) {
				index = j;
				break;
			}
		}
		if (index>=0) {
			*(*sets)[index] = redo;
		}
		if (et->ip) et->ip->NamedSelSetListChanged();
	}
			
	TSTR Description() {return TSTR(_T("Set Name"));}
};

void EditMeshMod::UpdateSetNames () {
	if ( !ip ) return;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		for (int nsl=0; nsl<3; nsl++) {
			// Make sure the namedSel array is in alpha order.
			// (Crude bubble sort since we expect that it will be.)
			int j, k, kmax = namedSel[nsl].Count();
			for (k=1; k<kmax; k++) {
				if (*(namedSel[nsl][k-1]) < *(namedSel[nsl][k])) continue;
				for (j=0; j<k-1; j++) {
					if (*(namedSel[nsl][j]) > *(namedSel[nsl][k])) break;
				}
				// j now represents the point at which k should be inserted.
				TSTR *hold = namedSel[nsl][k];
				DWORD dhold = ids[nsl][k];
				int j2;
				for (j2=k; j2>j; j2--) {
					namedSel[nsl][j2] = namedSel[nsl][j2-1];
					ids[nsl][j2] = ids[nsl][j2-1];
				}
				namedSel[nsl][j] = hold;
				ids[nsl][j] = dhold;
			}

			GenericNamedSelSetList & gnsl = meshData->selSet[nsl];
			// Check for old, unnamed sets with ids.
			for (k=0; k<gnsl.Count(); k++) {
				if (gnsl.names[k]) continue;
				for (j=0; j<ids[nsl].Count(); j++) if (ids[nsl][j] == gnsl.ids[k]) break;
				if (j == ids[nsl].Count()) continue;
				gnsl.names[j] = new TSTR(*(namedSel[nsl][j]));
			}
			gnsl.Alphabetize ();

			// Now check lists against each other, adding any missing elements.
			for (j=0; j<gnsl.Count(); j++) {
				if (j>= namedSel[nsl].Count()) {
					TSTR *nname = new TSTR(*gnsl.names[j]);
					DWORD nid = gnsl.ids[j];
					namedSel[nsl].Append (1, &nname);
					ids[nsl].Append (1, &nid);
					continue;
				}
				if (*(gnsl.names[j]) == *(namedSel[nsl][j])) continue;
				if (*(gnsl.names[j]) > *(namedSel[nsl][j])) {
					BitArray baTemp;
					gnsl.InsertSet (j, baTemp, ids[nsl][j], *(namedSel[nsl][j]));
					continue;
				}
				// Otherwise:
				TSTR *nname = new TSTR(*gnsl.names[j]);
				DWORD nid = gnsl.ids[j];
				namedSel[nsl].Insert (j, 1, &nname);
				ids[nsl].Insert (j, 1, &nid);
			}
			for (; j<namedSel[nsl].Count(); j++) {
				BitArray baTemp;
				gnsl.AppendSet (baTemp, ids[nsl][j], *(namedSel[nsl][j]));
			}
		}
	}

	nodes.DisposeTemporary();
}

void EditMeshMod::ClearSetNames() {
	for (int i=0; i<3; i++) {
		for (int j=0; j<namedSel[i].Count(); j++) {
			delete namedSel[i][j];
			namedSel[i][j] = NULL;
		}
	}
}

int EditMeshMod::FindSet(TSTR &setName, int nsl) {
	for (int i=0; i<namedSel[nsl].Count(); i++) if (setName == *namedSel[nsl][i]) return i;
	return -1;
}

DWORD EditMeshMod::AddSet(TSTR &setName, int nsl) {
	DWORD id = 0;
	TSTR *name = new TSTR(setName);
	namedSel[nsl].Append(1,&name);
	// Find an empty id to assign to this set.
	BOOL found = FALSE;
	while (!found) {
		found = TRUE;
		for (int i=0; i<ids[nsl].Count(); i++) {
			if (ids[nsl][i]!=id) continue;
			id++;
			found = FALSE;
		}
	}
	ids[nsl].Append(1,&id);
	return id;
}

void EditMeshMod::RemoveSet (TSTR &setName, int nsl) {
	//DebugPrint ("EMM: RemoveSet (%s, %d)\n", setName, nsl);
	int i;
	if ((i=FindSet(setName,nsl)) < 0) return;
	delete namedSel[nsl][i];
	namedSel[nsl].Delete(i,1);
	ids[nsl].Delete(i,1);
}

void EditMeshMod::ActivateSubSelSet(TSTR &setName) {
	//DebugPrint ("EMM: ActivateSubSelSet (%s)\n", setName);
	if (selLevel == SL_OBJECT) return;
	int nsl = namedSetLevel[selLevel];
	int index = FindSet (setName, nsl);
	if (index<0 || !ip) return;
	EndExtrude(ip->GetTime());	

	theHold.Begin ();
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;		
		meshData->BeginEdit (ip->GetTime());
		BitArray *set = meshData->selSet[nsl].GetSet (ids[nsl][index]);
		if (set) meshData->SetSel (nsl, *set, this, ip->GetTime());
	}
	theHold.Accept (GetString (IDS_DS_SELECT));
	nodes.DisposeTemporary();
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::NewSetFromCurSel(TSTR &setName) {
	//DebugPrint ("EMM: NewSetFromCurSel (%s)\n", setName);
	if (selLevel==SL_OBJECT) return;
	if (!ip) return;

	DWORD id = -1;
	int nsl = namedSetLevel[selLevel];
	int index = FindSet (setName, nsl);
	if (index<0) id = AddSet (setName, nsl);
	else id = ids[nsl][index];
	EndExtrude(ip->GetTime());

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		meshData->BeginEdit (ip->GetTime());
		BitArray *set;
		if (index>=0 && (set = meshData->selSet[nsl].GetSet(id))) *set = meshData->GetSel(nsl);
		else meshData->selSet[nsl].AppendSet (meshData->GetSel(nsl), id, setName);
	}
	nodes.DisposeTemporary();
}

void EditMeshMod::RemoveSubSelSet(TSTR &setName) {
	//DebugPrint ("EMM: RemoveSubSelSet (%s)\n", setName);
	int nsl = namedSetLevel[selLevel];
	int index = FindSet (setName, nsl);
	if (index<0 || !ip) return;
	EndExtrude(ip->GetTime());
	
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	DWORD id = ids[nsl][index];
	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (theHold.Holding ()) theHold.Put (new EMDeleteSetRestore (&(meshData->selSet[nsl]), id, setName));
		meshData->selSet[nsl].RemoveSet(id);
	}
	RemoveSet (setName, nsl);
	ip->ClearCurNamedSelSet();
	nodes.DisposeTemporary();
}

void EditMeshMod::SetupNamedSelDropDown () {
	//DebugPrint ("EMM: SetupNamedSelDropDown\n");
	if (selLevel == SL_OBJECT) return;
	ip->ClearSubObjectNamedSelSets();
	int nsl = namedSetLevel[selLevel];
	for (int i=0; i<namedSel[nsl].Count(); i++) ip->AppendSubObjectNamedSelSet(*namedSel[nsl][i]);
}

void EditMeshMod::UpdateNamedSelDropDown () {
	if (!ip) return;
	if (selLevel == SL_OBJECT) {
		ip->ClearCurNamedSelSet ();
		return;
	}
	// See if this selection matches a named set
	DWORD nsl = namedSetLevel[selLevel];
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts (mcList, nodes);
	BitArray nselmatch;
	nselmatch.SetSize (namedSel[nsl].Count());
	nselmatch.SetAll ();
	int nd, i, foundone=FALSE;
	for (nd=0; nd<mcList.Count(); nd++) {
		EditMeshData *d = (EditMeshData *) mcList[nd]->localData;
		if (!d) continue;
		foundone = TRUE;
		for (i=0; i<nselmatch.GetSize(); i++) {
			if (!nselmatch[i]) continue;
			if (!(*(d->selSet[nsl].sets[i]) == d->GetSel(nsl))) nselmatch.Clear(i);
		}
		if (nselmatch.NumberSet () == 0) break;
	}
	if (foundone && nselmatch.NumberSet ()) {
		for (i=0; i<nselmatch.GetSize(); i++) if (nselmatch[i]) break;
		ip->SetCurNamedSelSet (*(namedSel[nsl][i]));
	} else ip->ClearCurNamedSelSet ();
}

int EditMeshMod::NumNamedSelSets () {
	//DebugPrint ("EMM: NumNamedSelSets()=");
	int nsl = namedSetLevel[selLevel];
	int ret=namedSel[nsl].Count();
	//DebugPrint ("%d\n", ret);
	return ret;
}

TSTR EditMeshMod::GetNamedSelSetName (int i) {
	//DebugPrint ("EMM: GetNamedSelSetName(%d)=", i);
	int nsl = namedSetLevel[selLevel];
	//DebugPrint ("%s\n", *namedSel[nsl][i]);
	return *namedSel[nsl][i];
}

void EditMeshMod::SetNamedSelSetName (int i, TSTR & newName) {
	//DebugPrint ("EMM: SetNamedSelSetName (%d, %s)\n", i, newName);
	int nsl = namedSetLevel[selLevel];

	if (ip) {
		ModContextList mcList;
		INodeTab nodes;
		ip->GetModContexts(mcList,nodes);
		for (int i=0; i<mcList.Count(); i++) {
			EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
			if (!meshData) continue;
			meshData->selSet[nsl].RenameSet (*(namedSel[nsl][i]), newName);
		}
		nodes.DisposeTemporary ();
	}

	*namedSel[nsl][i] = newName;
}

void EditMeshMod::NewSetByOperator (TSTR &newName, Tab<int> &sets, int op) {
	//DebugPrint ("EMM: NewSetByOperator (%s, %d, %d)\n", newName, sets.Count(), op);
	int nsl = namedSetLevel[selLevel];
	DWORD id = AddSet(newName, nsl);
	BOOL delSet = TRUE;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData *)mcList[i]->localData;
		if (!meshData) continue;
		BitArray bits;
		GenericNamedSelSetList & setList = meshData->selSet[nsl];
		bits = setList[sets[0]];
		for (int i=1; i<sets.Count(); i++) {
			switch (op) {
			case NEWSET_MERGE:
				bits |= setList[sets[i]];
				break;
			case NEWSET_INTERSECTION:
				bits &= setList[sets[i]];
				break;
			case NEWSET_SUBTRACT:
				bits &= ~(setList[sets[i]]);
				break;
			}
		}
		if (bits.NumberSet()) delSet = FALSE;

		if (!delSet) setList.InsertSet (bits, id, newName);
	}
	if (delSet) RemoveSubSelSet(newName);
}

void EditMeshMod::NSCopy() {
	if (selLevel == SL_OBJECT) return;
	int index = SelectNamedSet();
	if (index<0) return;
	if (!ip) return;

	int nsl = namedSetLevel[selLevel];
	MeshNamedSelClip *clip = new MeshNamedSelClip(*namedSel[nsl][index]);

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;

		GenericNamedSelSetList & setList = meshData->selSet[nsl];
		BitArray *bits = new BitArray(*setList.sets[index]);
		clip->sets.Append(1,&bits);
	}
	SetMeshNamedSelClip(clip, namedClipLevel[selLevel]);

	// Enable the paste button
	if (hSel) {
		ICustButton *but;
		but = GetICustButton(GetDlgItem(hSel, IDC_EM_PASTENS));
		but->Enable();
		ReleaseICustButton(but);
	}
}

void EditMeshMod::NSPaste() {
	if (selLevel==SL_OBJECT) return;
	int nsl = namedSetLevel[selLevel];
	MeshNamedSelClip *clip = GetMeshNamedSelClip(namedClipLevel[selLevel]);
	if (!clip) return;
	TSTR name = clip->name;
	if (!GetUniqueSetName(name)) return;

	ModContextList mcList;
	INodeTab nodes;
	theHold.Begin();

	DWORD id = AddSet (name, nsl);
	if (theHold.Holding()) theHold.Put(new EMAppendSetNameRestore(this, &namedSel[nsl], &ids[nsl]));	

	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;

		GenericNamedSelSetList & setList = meshData->selSet[nsl];

		if (i>=clip->sets.Count()) {
			BitArray bits;
			setList.InsertSet(bits,id,name);
		} else setList.InsertSet(*clip->sets[i],id,name);
		if (theHold.Holding()) theHold.Put(new EMAppendSetRestore (&setList, id, name));		
	}	
	
	ActivateSubSelSet(name);
	ip->SetCurNamedSelSet(name);
	theHold.Accept(GetString (IDS_TH_PASTE_NAMED_SEL));
	SetupNamedSelDropDown();
}

static BOOL CALLBACK PickSetNameDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static TSTR *name;
	ICustEdit *edit;
	TCHAR buf[256];

	switch (msg) {
	case WM_INITDIALOG:
		name = (TSTR*)lParam;
		edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
		edit->SetText(*name);
		ReleaseICustEdit(edit);
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
			edit->GetText(buf,256);
			*name = TSTR(buf);
			ReleaseICustEdit(edit);
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

BOOL EditMeshMod::GetUniqueSetName(TSTR &name) {
	while (1) {				
		Tab<TSTR*> &setList = namedSel[namedSetLevel[selLevel]];

		BOOL unique = TRUE;
		for (int i=0; i<setList.Count(); i++) {
			if (name==*setList[i]) {
				unique = FALSE;
				break;
			}
		}
		if (unique) break;

		if (!ip) return FALSE;
		if (!DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_PASTE_NAMEDSET),
			ip->GetMAXHWnd(), PickSetNameDlgProc, (LPARAM)&name)) return FALSE;
		if (!ip) return FALSE;
	}
	return TRUE;
}

static BOOL CALLBACK PickSetDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
	case WM_INITDIALOG:	{
		Tab<TSTR*> *setList = (Tab<TSTR*>*)lParam;
		for (int i=0; i<setList->Count(); i++) {
			int pos  = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_ADDSTRING,0,
				(LPARAM)(TCHAR*)*(*setList)[i]);
			SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_SETITEMDATA,pos,i);
		}
		break;
	}

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_NS_LIST:
			if (HIWORD(wParam)!=LBN_DBLCLK) break;
			// fall through

		case IDOK:
			int sel;
			sel = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETCURSEL,0,0);
			if (sel!=LB_ERR) {
				int res =SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETITEMDATA,sel,0);
				EndDialog(hWnd,res);
				break;
			}
			// fall through

		case IDCANCEL:
			EndDialog(hWnd,-1);
			break;
		}
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

int EditMeshMod::SelectNamedSet() {
	Tab<TSTR*> &setList = namedSel[namedSetLevel[selLevel]];
	if (!ip) return FALSE;
	return DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_SEL_NAMEDSET),
		ip->GetMAXHWnd(), PickSetDlgProc, (LPARAM)&setList);
}

void EditMeshMod::ActivateSubobjSel(int level, XFormModes& modes ) {	
	ModContextList mcList;
	INodeTab nodes;
	int old = selLevel;

	if (!ip) return;
	ip->GetModContexts(mcList,nodes);

	// if we're in sub object selection then we want del key input.
	if (selLevel==0 && level!=0) {
		delEvent.SetEditMeshMod(this);
		ip->RegisterDeleteUser(&delEvent);
	}
	if (selLevel!=0 && level==0) {
		ip->UnRegisterDeleteUser(&delEvent);
	}
	if ((selLevel != level) && ((level<SL_FACE) || (selLevel<SL_FACE))) {
		ExitAllCommandModes (level == SL_OBJECT);
	}

	selLevel = level;
	
	if (level!=SL_OBJECT) {
		modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
	}

	if (selLevel != old) {
		// Modify the caches to reflect the new sel level.
		for ( int i = 0; i < mcList.Count(); i++ ) {
			EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
			if ( !meshData ) continue;		
		
			if ( meshData->MeshCached(ip->GetTime()) ) {
				Mesh *mesh = meshData->GetMesh (ip->GetTime());
				mesh->dispFlags = 0;
				mesh->SetDispFlag(levelDispFlags[selLevel]);
				mesh->selLevel = meshLevel[selLevel];
			}
			meshData->Invalidate(PART_SELECT);
		}

		NotifyDependents (FOREVER, PART_SELECT|PART_SUBSEL_TYPE|PART_DISPLAY, REFMSG_CHANGE);	
		ip->PipeSelLevelChanged();
	}
	
	// Setup named selection sets	
	SetupNamedSelDropDown();
	UpdateNamedSelDropDown();

	nodes.DisposeTemporary();
	if (hSel) RefreshSelType ();
	ip->RedrawViews (ip->GetTime());
}

int EditMeshMod::SubObjectIndex(HitRecord *hitRec) {
	EditMeshData *meshData = (EditMeshData*)hitRec->modContext->localData;

	if ( !meshData ) return 0;
	if ( !ip ) return 0;
	TimeValue t = ip->GetTime();
	FaceClusterList *fc;
	EdgeClusterList *ec;
	DWORD id;

	switch ( selLevel ) {
	case SL_VERTEX:
		// Changed SubObjectIndex to mean the actual index of the vertex,
		// not the nth selected.
		return hitRec->hitInfo;
	
	case SL_FACE:
	case SL_POLY:
	case SL_ELEMENT:
		fc = meshData->TempData(t)->FaceClusters();
		id = (*fc)[hitRec->hitInfo];
		if (id!=UNDEFINED) return id;
		else return 0;

	case SL_EDGE:
		ec = meshData->TempData(t)->EdgeClusters();
		id = (*ec)[hitRec->hitInfo];
		if (id!=UNDEFINED) return id;
		else return 0;

	default:
		return 0;
	}
}

void EditMeshMod::GetSubObjectCenters (SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc) {
	Matrix3 tm = node->GetObjectTM(t);	
	
	if (sliceMode) {
		cb->Center (sliceCenter*tm, 0);
		return;
	}

	MaxAssert(ip);

	if (!mc->localData) return;
	EditMeshData *meshData = (EditMeshData*)mc->localData;		
	Mesh *mesh = meshData->GetMesh (t);
	int i;
	Point3 cent = Point3(0,0,0);
	
	switch (selLevel) {
	case SL_VERTEX:
		int ct;
		for (i=0, ct=0; i<mesh->getNumVerts(); i++) {
			if (!mesh->vertSel[i]) continue;
			cent += mesh->verts[i];
			ct++;
		}
		if (ct) {
			cent /= float(ct);	
			cb->Center(cent*tm,0);
		}
		break;

	case SL_EDGE:
	case SL_FACE:
	case SL_POLY:
	case SL_ELEMENT:
		Tab<Point3> *centers;
		centers = meshData->TempData(t)->ClusterCenters(meshLevel[selLevel]);
		for (i=0; i<centers->Count(); i++) cb->Center((*centers)[i]*tm,i);
		break;

	default:
		cb->Center(tm.GetTrans(),0);
		break;
	}		
}


void EditMeshMod::GetSubObjectTMs (SubObjAxisCallback *cb,
								   TimeValue t,INode *node,ModContext *mc) {
	Matrix3 tm;	
	Matrix3 otm = node->GetObjectTM(t);

	if (sliceMode) {
		Matrix3 rotMatrix(1);
		sliceRot.MakeMatrix (rotMatrix);
		rotMatrix.SetTrans (sliceCenter);
		rotMatrix *= otm;
		cb->TM (rotMatrix, 0);
		return;
	}

	if (!mc->localData ) return;
	EditMeshData *meshData = (EditMeshData*)mc->localData;
	Mesh *mesh = meshData->GetMesh (t);
	int i,j;

	switch (selLevel) {
	case SL_VERTEX:
		if (mesh->vertSel.NumberSet()==0) return;
		if (ip->GetCommandMode()->ID()==CID_SUBOBJMOVE) {
			Tab<Point3> *vnorms;
			vnorms = meshData->TempData(t)->VertexNormals();

			for (i=0,j=0; i<vnorms->Count(); i++) {
				if (!mesh->vertSel[i]) continue;
				Point3 n = VectorTransform(otm, (*vnorms)[i]);
				n = Normalize(n);
				MatrixFromNormal(n,tm);
				tm.SetTrans(mesh->verts[i]*otm);
				cb->TM(tm, j++);
			}
		} else {
			Point3 norm;
			Point3 cent;
			int ct;
			cent = Point3(0,0,0);
			ct=0;

			// Comute average face normal
			norm = AverageSelVertNormal(*mesh);

			// Compute center of selection
			for (i=0; i<mesh->getNumVerts(); i++) {
				if (!mesh->vertSel[i]) continue;
				cent += mesh->verts[i];
				ct++;
			}
			if (ct) cent /= float(ct);
			cent = cent * otm;
			norm = Normalize(VectorTransform(otm,norm));
			Matrix3 mat;
			MatrixFromNormal(norm,mat);
			mat.SetTrans(cent);
			cb->TM(mat,0);
		}
		break;

	case SL_EDGE:
	case SL_FACE:
	case SL_POLY:
	case SL_ELEMENT:
		Tab<Point3> *norms;
		norms = meshData->TempData(t)->ClusterNormals(meshLevel[selLevel]);
		Tab<Point3> *centers;
		centers = meshData->tempData->ClusterCenters(meshLevel[selLevel]);
		for (int i=0; i<norms->Count(); i++) {
			Point3 n = VectorTransform(otm,(*norms)[i]);
			n = Normalize(n);
			MatrixFromNormal(n,tm);
			tm.SetTrans((*centers)[i]*otm);
			cb->TM(tm,i);
		}
		break;
	}
}


void EditMeshMod::DeleteMeshDataTempData()
	{
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;		
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;				
		if ( meshData->tempData ) {
			delete meshData->tempData;
			}
		meshData->tempData = NULL;
		}
	nodes.DisposeTemporary();
	}


void EditMeshMod::CreateMeshDataTempData()
	{
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;		
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		meshData->mod = this;
		if ( meshData->tempData ) continue;
		meshData->tempData = new MeshTempData ();
	}
	
	nodes.DisposeTemporary();
}

bool CheckNodeSelection (Interface *ip, INode *inode) {
	if (!ip) return FALSE;
	if (!inode) return FALSE;
	int i, nct = ip->GetSelNodeCount();
	for (i=0; i<nct; i++) if (ip->GetSelNode (i) == inode) return TRUE;
	return FALSE;
}

int EditMeshMod::HitTest(TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) {
	Interval valid;
	int savedLimits,res = 0;
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;

	// Setup GW
	MakeHitRegion(hr,type, crossing, pickBoxSize, p);
	gw->setHitRegion(&hr);
	Matrix3 mat = inode->GetObjectTM(t);
	gw->setTransform(mat);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	if (ignoreBackfaces) gw->setRndLimits(gw->getRndLimits() |  GW_BACKCULL);
	else gw->setRndLimits(gw->getRndLimits() & ~GW_BACKCULL);
	gw->clearHitCode();

	if (sliceMode && CheckNodeSelection (ip, inode)) {
		gw->setTransform (inode->GetObjectTM(t) * (mc->tm?Inverse(*mc->tm):Matrix3(1)));
		Point3 rp[5];
		Matrix3 rotMatrix;
		sliceRot.MakeMatrix (rotMatrix);
		rotMatrix.SetTrans (sliceCenter);
		rp[0] = Point3(-sliceSize,-sliceSize,0.0f)*rotMatrix;
		rp[1] = Point3(-sliceSize,sliceSize,0.0f)*rotMatrix;
		rp[2] = Point3(sliceSize,sliceSize,0.0f)*rotMatrix;
		rp[3] = Point3(sliceSize,-sliceSize,0.0f)*rotMatrix;
		gw->polyline (4, rp, NULL, NULL, TRUE, NULL);
		if (gw->checkHitCode()) {
			vpt->LogHit (inode, mc, gw->getHitDistance(), 0, NULL);
			res = 1;
		}
		gw->setRndLimits (savedLimits);
		return res;
	}

	int localSelByVert = selByVert;
	if (cutEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (turnEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (divideEdgeMode == ip->GetCommandMode()) localSelByVert = FALSE;
	if (divideFaceMode == ip->GetCommandMode()) localSelByVert = FALSE;

	if ( mc->localData ) {
		EditMeshData *meshData = (EditMeshData*)mc->localData;
		Mesh *mesh = meshData->GetMesh (ip->GetTime());
		SubObjHitList hitList;
		MeshSubHitRec *rec;
		
		DWORD hitLev = hitLevel[selLevel];
		if (inBuildFace || localSelByVert) hitLev = SUBHIT_VERTS;
		if (inCutEdge) hitLev = SUBHIT_EDGES;
		if (hitLev == SUBHIT_VERTS) {
			BitArray oldHide;
			if (ignoreBackfaces) {
				BOOL flip = mat.Parity();
				oldHide = mesh->vertHide;
				BitArray faceBack;
				faceBack.SetSize (mesh->getNumFaces());
				faceBack.ClearAll ();
				for (int i=0; i<mesh->getNumFaces(); i++) {
					DWORD *vv = mesh->faces[i].v;
					IPoint3 A[3];
					for (int j=0; j<3; j++) gw->wTransPoint (&(mesh->verts[vv[j]]), &(A[j]));
					IPoint3 d1 = A[1] - A[0];
					IPoint3 d2 = A[2] - A[0];
					if (flip) {
						if ((d1^d2).z > 0) continue;
					} else {
						if ((d1^d2).z < 0) continue;
					}
					for (j=0; j<3; j++) mesh->vertHide.Set (vv[j]);
					faceBack.Set (i);
				}
				for (i=0; i<mesh->getNumFaces(); i++) {
					if (faceBack[i]) continue;
					DWORD *vv = mesh->faces[i].v;
					for (int j=0; j<3; j++) mesh->vertHide.Clear (vv[j]);
				}
				mesh->vertHide |= oldHide;
			}
			DWORD thisFlags = flags | hitLev;
			if ((selLevel != SL_VERTEX) && localSelByVert) thisFlags |= SUBHIT_USEFACESEL;
			res = mesh->SubObjectHitTest(gw, gw->getMaterial(), &hr, thisFlags, hitList);
			if (ignoreBackfaces) mesh->vertHide = oldHide;
		} else {
			res = mesh->SubObjectHitTest(gw, gw->getMaterial(), &hr, flags|hitLev, hitList);
		}

		rec = hitList.First();
		while (rec) {
			vpt->LogHit(inode,mc,rec->dist,rec->index,NULL);
			rec = rec->Next();
		}
	}

	gw->setRndLimits(savedLimits);	
	return res;
}

int EditMeshMod::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc) {	
	if (!ip) return 0;
	if (!GetFlag (EM_EDITING)) return 0;
	// Set up GW
	GraphicsWindow *gw = vpt->getGW();
	int savedLimits= gw->getRndLimits();
	gw->setRndLimits((savedLimits & ~GW_ILLUM) | GW_ALL_EDGES);
	Matrix3 tm = inode->GetObjectTM(t) * (mc->tm?Inverse(*mc->tm):Matrix3(1));
	gw->setTransform(tm);

	if (sliceMode && CheckNodeSelection (ip, inode)) {
		// Draw rectangle representing slice plane.
		gw->setColor(LINE_COLOR,GetUIColor(COLOR_SEL_GIZMOS));

		Point3 rp[5];
		Matrix3 rotMatrix;
		sliceRot.MakeMatrix (rotMatrix);
		rotMatrix.SetTrans (sliceCenter);
		rp[0] = Point3(-sliceSize,-sliceSize,0.0f)*rotMatrix;
		rp[1] = Point3(-sliceSize,sliceSize,0.0f)*rotMatrix;
		rp[2] = Point3(sliceSize,sliceSize,0.0f)*rotMatrix;
		rp[3] = Point3(sliceSize,-sliceSize,0.0f)*rotMatrix;
		gw->polyline (4, rp, NULL, NULL, TRUE, NULL);
	}

	if (inBuildFace && CheckNodeSelection (ip, inode)
		&& (mc->localData == createFaceMode->proc.meshData) && mc->localData) {
		tm = inode->GetObjectTM(t);
		gw->setTransform(tm);
		gw->setColor (LINE_COLOR, GetSubSelColor());
		createFaceMode->proc.DrawEstablishedFace (gw);
	}

	if (ip->GetShowEndResult() && mc->localData && selLevel) {
		tm = inode->GetObjectTM(t);
		gw->setTransform(tm);
		// We need to draw a "gizmo" version of the mesh:
		Point3 colSel=GetSubSelColor();
		Point3 colTicks=GetUIColor (COLOR_VERT_TICKS);
		Point3 colGiz=GetUIColor(COLOR_GIZMOS);
		Point3 colGizSel=GetUIColor(COLOR_SEL_GIZMOS);
		gw->setColor (LINE_COLOR, colGiz);
		EditMeshData *meshData = (EditMeshData*)mc->localData;
		Mesh *mesh = meshData->GetMesh (ip->GetTime());
		AdjEdgeList *ae = meshData->TempData(ip->GetTime())->AdjEList();
		Point3 rp[3];
		int i, ect = ae->edges.Count();
		int es[3];
		for (i=0; i<ect; i++) {
			MEdge & me = ae->edges[i];
			if (me.Hidden (mesh->faces)) continue;
			if (me.Visible (mesh->faces)) {
				es[0] = GW_EDGE_VIS;
			} else {
				if (selLevel < SL_EDGE) continue;
				if (selLevel > SL_FACE) continue;
				es[0] = GW_EDGE_INVIS;
			}
			if (selLevel == SL_EDGE) {
				if (ae->edges[i].Selected (mesh->faces, meshData->GetEdgeSel())) gw->setColor (LINE_COLOR, colGizSel);
				else gw->setColor (LINE_COLOR, colGiz);
			}
			if (selLevel >= SL_FACE) {
				if (ae->edges[i].AFaceSelected (meshData->GetFaceSel())) gw->setColor (LINE_COLOR, colGizSel);
				else gw->setColor (LINE_COLOR, colGiz);
			}
			rp[0] = mesh->verts[me.v[0]];
			rp[1] = mesh->verts[me.v[1]];
			gw->polyline (2, rp, NULL, NULL, FALSE, es);
		}
		if (selLevel == SL_VERTEX) {
			float *ourvw = affectRegion ? meshData->TempData(ip->GetTime())->VSWeight
				(useEdgeDist, edgeIts, arIgBack, falloff, pinch, bubble)->Addr(0) : NULL;
			for (i=0; i<mesh->numVerts; i++) {
				if (meshData->mdelta.vhide[i]) continue;

				if (meshData->mdelta.vsel[i]) gw->setColor (LINE_COLOR, colSel);
				else {
					if (ourvw) gw->setColor (LINE_COLOR, SoftSelectionColor(ourvw[i]));
					else gw->setColor (LINE_COLOR, colTicks);
				}

				if(getUseVertexDots()) gw->marker (&(mesh->verts[i]), getVertexDotType() ? DOT_MRKR : SM_DOT_MRKR);
				else gw->marker (&(mesh->verts[i]), PLUS_SIGN_MRKR);
			}
		}
	}
	gw->setRndLimits(savedLimits);
	return 0;	
}

void EditMeshMod::GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) {
	if (!ip) return;
	box.Init();
	Matrix3 tm = inode->GetObjectTM(t) * (mc->tm?Inverse(*mc->tm):Matrix3(1));
	if (sliceMode && CheckNodeSelection (ip, inode)) {
		Matrix3 rotMatrix;
		sliceRot.MakeMatrix (rotMatrix);
		rotMatrix.SetTrans (sliceCenter);
		rotMatrix *= tm;
		box += Point3(-sliceSize,-sliceSize,0.0f)*rotMatrix;
		box += Point3(-sliceSize,sliceSize,0.0f)*rotMatrix;
		box += Point3(sliceSize,sliceSize,0.0f)*rotMatrix;
		box += Point3(sliceSize,-sliceSize,0.0f)*rotMatrix;
	}

	if (ip->GetShowEndResult() && mc->localData && selLevel) {
		// We need to draw a "gizmo" version of the mesh:
		Matrix3 tm = inode->GetObjectTM(t);
		EditMeshData *meshData = (EditMeshData*)mc->localData;
		if (meshData->MeshCached (ip->GetTime())) {
			Mesh *mesh = meshData->mesh;
			AdjEdgeList *ae = meshData->TempData(ip->GetTime())->AdjEList();
			int i, ect = ae->edges.Count();
			for (i=0; i<ect; i++) {
				box += tm*mesh->verts[ae->edges[i].v[0]];
				box += tm*mesh->verts[ae->edges[i].v[1]];
			}
		}
	}
}

//---------------------------------------------------------------------
// IO

#define SEL_LEVEL_CHUNK 			0x2800
#define NAMEDVSEL_NAMES_CHUNK		0x2805
#define NAMEDFSEL_NAMES_CHUNK		0x2806
#define NAMEDESEL_NAMES_CHUNK		0x2807
#define NAMEDSEL_STRING_CHUNK		0x2809
#define NAMEDSEL_ID_CHUNK			0x2810
#define AR_CHUNK 0x2820
#define FALLOFF_CHUNK 0x2822
#define PINCH_CHUNK 0x2824
#define BUBBLE_CHUNK 0x2826
#define EDIST_CHUNK 0x2828
#define EDGE_ITS_CHUNK 0x282a
#define IG_BACK_CHUNK 0x282c
#define EMOD_FLAGS_CHUNK 0x2830

static int namedSelID[] = {NAMEDVSEL_NAMES_CHUNK,NAMEDFSEL_NAMES_CHUNK,NAMEDESEL_NAMES_CHUNK};

IOResult EditMeshMod::Save(ISave *isave) {
	Modifier::Save(isave);
	Interval valid;
	ULONG nb;	
	short sl = selLevel;
	isave->BeginChunk(SEL_LEVEL_CHUNK);
	isave->Write(&sl,sizeof(short),&nb);
	isave->EndChunk();	
	
	for (int j=0; j<3; j++) {
		if (namedSel[j].Count()) {
			isave->BeginChunk(namedSelID[j]);			
			for (int i=0; i<namedSel[j].Count(); i++) {
				isave->BeginChunk(NAMEDSEL_STRING_CHUNK);
				isave->WriteWString(*namedSel[j][i]);
				isave->EndChunk();

				isave->BeginChunk(NAMEDSEL_ID_CHUNK);
				isave->Write(&ids[j][i],sizeof(DWORD),&nb);
				isave->EndChunk();
			}
			isave->EndChunk();
		}
	}

	isave->BeginChunk (AR_CHUNK);
	isave->Write (&affectRegion, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (FALLOFF_CHUNK);
	isave->Write (&falloff, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (PINCH_CHUNK);
	isave->Write (&pinch, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (BUBBLE_CHUNK);
	isave->Write (&bubble, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (EDIST_CHUNK);
	isave->Write (&useEdgeDist, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (EDGE_ITS_CHUNK);
	isave->Write (&edgeIts, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (IG_BACK_CHUNK);
	isave->Write (&arIgBack, sizeof(int), &nb);
	isave->EndChunk ();

	isave->BeginChunk (EMOD_FLAGS_CHUNK);
	DWORD keepFlags = emFlags & EM_KEEPFLAGS;
	isave->Write (&keepFlags, sizeof(DWORD), &nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult EditMeshMod::LoadNamedSelChunk(ILoad *iload,int level)
	{	
	IOResult res;
	DWORD ix=0;
	ULONG nb;
	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case NAMEDSEL_STRING_CHUNK: {
				TCHAR *name;
				res = iload->ReadWStringChunk(&name);
				//AddSet(TSTR(name),level+1);
				TSTR *newName = new TSTR(name);
				namedSel[level].Append(1,&newName);				
				ids[level].Append(1,&ix);
				ix++;
				break;
				}
			case NAMEDSEL_ID_CHUNK:
				iload->Read(&ids[level][ids[level].Count()-1],sizeof(DWORD), &nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult EditMeshMod::Load(ILoad *iload) {
	Modifier::Load(iload);
	IOResult res;
	ULONG nb;
	int level = -1;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case NAMEDVSEL_NAMES_CHUNK: {				
				res = LoadNamedSelChunk(iload,0);
				break;
				}

			case NAMEDFSEL_NAMES_CHUNK: {
				res = LoadNamedSelChunk(iload,1);
				break;
				}

			case NAMEDESEL_NAMES_CHUNK: {
				res = LoadNamedSelChunk(iload,2);
				break;
				}

			case SEL_LEVEL_CHUNK: {
				short sl;
				res = iload->Read(&sl,sizeof(short),&nb);
				selLevel = sl;
				}
				break;

			case AR_CHUNK:
				res = iload->Read (&affectRegion, sizeof(int), &nb);
				break;

			case FALLOFF_CHUNK:
				res = iload->Read (&falloff, sizeof(float), &nb);
				break;

			case PINCH_CHUNK:
				res = iload->Read (&pinch, sizeof(float), &nb);
				break;

			case BUBBLE_CHUNK:
				res = iload->Read (&bubble, sizeof(float), &nb);
				break;

			case EDIST_CHUNK:
				res = iload->Read (&useEdgeDist, sizeof(int), &nb);
				break;

			case EDGE_ITS_CHUNK:
				res = iload->Read (&edgeIts, sizeof(int), &nb);
				break;

			case IG_BACK_CHUNK:
				res = iload->Read (&arIgBack, sizeof(int), &nb);
				break;

			case EMOD_FLAGS_CHUNK:
				DWORD keepFlags;
				res = iload->Read (&keepFlags, sizeof(DWORD), &nb);
				emFlags = (emFlags & EM_TEMPFLAGS) | (keepFlags & EM_KEEPFLAGS);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

// Save/Load stuff
// Here we define the obselete TopoDelta and VertexDelta classes to make
// backward-compatibility conversion easier.
// STEVE: also switch selLevel for older versions: used to go obj, vert, face, edge.  Now goes
// obj, vert, edge, face, poly, element 

class VertexDelta {
public:
	Tab<Point3>	deltas;
	BitArray	hide;

	~VertexDelta() {}
	VertexDelta() {}
};

class FaceMap {
public:
	DWORD v[3];
	FaceMap(DWORD fv[3]) {v[0]=fv[0];v[1]=fv[1];v[2]=fv[2];}
	FaceMap(DWORD a,DWORD b,DWORD c) {v[0]=a;v[1]=b;v[2]=c;}
	FaceMap() {v[0]=v[1]=v[2]=UNDEFINED;}
};
typedef Tab<FaceMap> FaceMapTab;

class TopoDelta {
public:				
	DWORDTab cverts;			// Clone verts
	DWORDTab dverts;			// Delete verts		
	Tab<Point3> nverts;			// Add verts
	Tab<Point3> nTverts;			// Add texture verts
	DWORDTab dfaces;			// Delete faces
	Tab<Face> nfaces;			// New faces
	Tab<TVFace> nTVfaces;		// New texture vert faces
	FaceMapTab map;				// Remap faces
	FaceMapTab tmap;			// TVFace remap
	DWORDTab attribs;			// Changes attributes of a face.
	DWORDTab smgroups;			// Changes smooth groups for a face.
	DWORD inputFaces; 			// Number of faces on input mesh
	DWORD inputVerts;			// Number of vertices input mesh has

	TopoDelta () {}
	~TopoDelta() {}
};

class ConvertToMeshDeltaPLCB : public PostLoadCallback {
public:
	EditMeshMod *em;
	EditMeshData *emd;
	TopoDelta td;
	VertexDelta vd;
	BitArray vsel, esel, fsel;

	ConvertToMeshDeltaPLCB(EditMeshMod *m, EditMeshData *d) { em=m; emd=d; }
	void proc(ILoad *iload);
	void MyDebugPrint();
};

#define FLAGS_CHUNK 			0x2740
#define VSEL_CHUNK 				0x2750
#define FSEL_CHUNK	 			0x2755
#define ESEL_CHUNK				0x2756
#define VERT_DELTA_CHUNK 		0x2760
#define VERT_HIDE_CHUNK			0x2761
#define TOPO_DELTA_CHUNK 		0x2765
#define TOPO_NVERTS_CHUNK 		0x2771
#define TOPO_NTVERTS_CHUNK		0x2772
#define TOPO_CVERTS_CHUNK 		0x2770
#define TOPO_NFACES_CHUNK 		0x2775
#define TOPO_NTVFACES_CHUNK 	0x2776
#define TOPO_FACEMAP_CHUNK 		0x2780
#define TOPO_TVFACEMAP_CHUNK 	0x2781
#define TOPO_DVERTS_CHUNK 		0x2790
#define TOPO_DFACES_CHUNK 		0x2800
#define TOPO_INPUTFACES_CHUNK	0x2810
#define TOPO_INPUTVERTS_CHUNK	0x2820
#define TOPO_ATTRIBS_CHUNK		0x2830
#define TOPO_SMGROUPS_CHUNK		0x2840
#define VSELSET_CHUNK			0x2845
#define FSELSET_CHUNK			0x2846
#define ESELSET_CHUNK			0x2847
#define VERT_DELTAZERO_CHUNK   	0x3000
#define TOPO_FACEMAPUNDEF_CHUNK 0x3010
#define TOPO_TVFACEMAPUNDEF_CHUNK 0x3020
#define TOPO_ATTRIBSZERO_CHUNK 0x3030
#define TOPO_SMGROUPSSAME_CHUNK 0x3040
#define MDELTA_CHUNK 0x4000

IOResult EditMeshMod::SaveLocalData(ISave *isave, LocalModData *ld) {
	ULONG nb;
	EditMeshData *em = (EditMeshData *)ld;

	isave->BeginChunk(FLAGS_CHUNK);
	isave->Write(&em->flags,sizeof(DWORD), &nb);
	isave->EndChunk();

	if (em->selSet[NS_VERTEX].Count()) {
		isave->BeginChunk(VSELSET_CHUNK);
		em->selSet[NS_VERTEX].Save(isave);
		isave->EndChunk();
	}
	if (em->selSet[NS_EDGE].Count()) {
		isave->BeginChunk(ESELSET_CHUNK);
		em->selSet[NS_EDGE].Save(isave);
		isave->EndChunk();
	}
	if (em->selSet[NS_FACE].Count()) {
		isave->BeginChunk(FSELSET_CHUNK);
		em->selSet[NS_FACE].Save(isave);
		isave->EndChunk();
	}

	isave->BeginChunk (MDELTA_CHUNK);
	IOResult res = em->mdelta.Save (isave);
	isave->EndChunk ();

	return res;
}

IOResult EditMeshMod::LoadLocalData(ILoad *iload, LocalModData **pld) {
	ULONG nb;
	int n;
	IOResult res;
	EditMeshData *em;
	if (*pld==NULL) *pld =(LocalModData *) new EditMeshData();
	em = (EditMeshData *)*pld;
	em->SetModifier (this);

	ConvertToMeshDeltaPLCB *ctmd = NULL;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case FLAGS_CHUNK:
				res = iload->Read(&em->flags,sizeof(DWORD), &nb);
				break;
			case VSEL_CHUNK:
				if (!ctmd) ctmd = new ConvertToMeshDeltaPLCB (this, em);
			   	res = ctmd->vsel.Load(iload);
				break;
			case FSEL_CHUNK:
				if (!ctmd) ctmd = new ConvertToMeshDeltaPLCB (this, em);
			   	res = ctmd->fsel.Load(iload);
				break;
			case ESEL_CHUNK:
				if (!ctmd) ctmd = new ConvertToMeshDeltaPLCB (this, em);
			   	res = ctmd->esel.Load(iload);
				break;
			
			case VSELSET_CHUNK:
				res = em->selSet[NS_VERTEX].Load(iload);
				break;
			case FSELSET_CHUNK:
				res = em->selSet[NS_FACE].Load(iload);
				break;
			case ESELSET_CHUNK:
				res = em->selSet[NS_EDGE].Load(iload);
				break;

			case MDELTA_CHUNK:
				res = em->mdelta.Load (iload);
				break;

			case VERT_HIDE_CHUNK:
				if (!ctmd) ctmd = new ConvertToMeshDeltaPLCB (this, em);
				res = ctmd->vd.hide.Load(iload);
				break;
			case VERT_DELTA_CHUNK:
				if (!ctmd) ctmd = new ConvertToMeshDeltaPLCB (this, em);
				n = iload->CurChunkLength()/sizeof(Point3);
				ctmd->vd.deltas.SetCount(n);
				res = iload->Read(ctmd->vd.deltas.Addr(0),n*sizeof(Point3),&nb);
				break;
			case VERT_DELTAZERO_CHUNK: {
				if (!ctmd) ctmd = new ConvertToMeshDeltaPLCB (this, em);
				res = iload->Read(&n,sizeof(n),&nb);
				ctmd->vd.deltas.SetCount(n);
				Point3 *pt  = ctmd->vd.deltas.Addr(0);
				Point3 pzero(0,0,0);
				for (int i=0; i<n; i++) pt[i] = pzero;
				}
				break;
			case TOPO_DELTA_CHUNK:
				if (!ctmd) ctmd = new ConvertToMeshDeltaPLCB (this, em);
				while (IO_OK==(res=iload->OpenChunk())) {
					switch(iload->CurChunkID())  {
						case TOPO_NVERTS_CHUNK:
							n = iload->CurChunkLength()/sizeof(Point3);
							ctmd->td.nverts.SetCount(n);
							res = iload->Read(ctmd->td.nverts.Addr(0),n*sizeof(Point3),&nb);
							break;
						case TOPO_NTVERTS_CHUNK:
							n = iload->CurChunkLength()/sizeof(Point3);
							ctmd->td.nTverts.SetCount(n);
							res = iload->Read(ctmd->td.nTverts.Addr(0),n*sizeof(Point3),&nb);
							break;
						case TOPO_CVERTS_CHUNK:
							n = iload->CurChunkLength()/sizeof(DWORD);
							ctmd->td.cverts.SetCount(n);
							res = iload->Read(ctmd->td.cverts.Addr(0),n*sizeof(DWORD),&nb);
							break;
						case TOPO_NFACES_CHUNK:
							n = iload->CurChunkLength()/sizeof(Face);
							ctmd->td.nfaces.SetCount(n);
							res = iload->Read(ctmd->td.nfaces.Addr(0),n*sizeof(Face),&nb);
							break;
						case TOPO_NTVFACES_CHUNK:
							n = iload->CurChunkLength()/sizeof(TVFace);
							ctmd->td.nTVfaces.SetCount(n);
							res = iload->Read(ctmd->td.nTVfaces.Addr(0),n*sizeof(TVFace),&nb);
							break;
						case TOPO_FACEMAP_CHUNK:
							n = iload->CurChunkLength()/sizeof(FaceMap);
							ctmd->td.map.SetCount(n);
							res = iload->Read(ctmd->td.map.Addr(0),n*sizeof(FaceMap),&nb);
							break;
						case TOPO_FACEMAPUNDEF_CHUNK:  {
							res = iload->Read(&n,sizeof(n),&nb);
							ctmd->td.map.SetCount(n);
							FaceMap *fm  = ctmd->td.map.Addr(0);
							for (int i=0; i<n; i++) {
								fm[i].v[0] = fm[i].v[1] = fm[i].v[2] = UNDEFINED;
								}
							}
							break;

						case TOPO_TVFACEMAP_CHUNK:
							n = iload->CurChunkLength()/sizeof(FaceMap);
							ctmd->td.tmap.SetCount(n);
							res = iload->Read(ctmd->td.tmap.Addr(0),n*sizeof(FaceMap),&nb);
							break;

						case TOPO_TVFACEMAPUNDEF_CHUNK:  {
							res = iload->Read(&n,sizeof(n),&nb);
							ctmd->td.tmap.SetCount(n);
							FaceMap *fm  = ctmd->td.tmap.Addr(0);
							for (int i=0; i<n; i++) {
								fm[i].v[0] = fm[i].v[1] = fm[i].v[2] = UNDEFINED;
								}
							}
							break;

						case TOPO_DVERTS_CHUNK:
							n = iload->CurChunkLength()/sizeof(DWORD);
							ctmd->td.dverts.SetCount(n);
							res = iload->Read(ctmd->td.dverts.Addr(0),n*sizeof(DWORD),&nb);
							break;
						case TOPO_DFACES_CHUNK:
							n = iload->CurChunkLength()/sizeof(DWORD);
							ctmd->td.dfaces.SetCount(n);
							res = iload->Read(ctmd->td.dfaces.Addr(0),n*sizeof(DWORD),&nb);
							break;
						case TOPO_ATTRIBS_CHUNK:
							n = iload->CurChunkLength()/sizeof(DWORD);
							ctmd->td.attribs.SetCount(n);
							res = iload->Read(ctmd->td.attribs.Addr(0),n*sizeof(DWORD),&nb);
							break;
						case TOPO_ATTRIBSZERO_CHUNK:
							{
							res = iload->Read(&n,sizeof(n),&nb);
							ctmd->td.attribs.SetCount(n);
							DWORD *dw  = ctmd->td.attribs.Addr(0);
							for (int i=0; i<n; i++)  dw[i] = 0;
							}
							break;
						case TOPO_SMGROUPS_CHUNK:
							n = iload->CurChunkLength()/sizeof(DWORD);
							ctmd->td.smgroups.SetCount(n);
							res = iload->Read(ctmd->td.smgroups.Addr(0),n*sizeof(DWORD),&nb);
							break;
						case TOPO_SMGROUPSSAME_CHUNK:
							{
							DWORD sg;
							res = iload->Read(&n,sizeof(n),&nb);
							res = iload->Read(&sg,sizeof(sg),&nb);
							ctmd->td.smgroups.SetCount(n);
							DWORD *dw  = ctmd->td.smgroups.Addr(0);
							for (int i=0; i<n; i++)  dw[i] = sg;
							}
							break;
						case TOPO_INPUTVERTS_CHUNK:
							res = iload->Read(&ctmd->td.inputVerts,sizeof(DWORD), &nb);
							break;
						case TOPO_INPUTFACES_CHUNK:
							res = iload->Read(&ctmd->td.inputFaces,sizeof(DWORD), &nb);
							break;
						}
					iload->CloseChunk();
					if ( res!=IO_OK) 
					return res;
					}
				if (res==IO_ERROR) return res;
				res = IO_OK;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) return res;
	}

	if (ctmd) {
		iload->RegisterPostLoadCallback (ctmd);
		SetFlag (EM_SWITCH_SUBOBJ_VERSIONS);
	} else {
		BOOL ret = em->mdelta.CheckOrder ();
#ifdef _DEBUG
		if (!ret) DebugPrint ("Edit Mesh: Repairing MeshDelta internal order on load.\n");
#endif
		ret = em->mdelta.CheckMapFaces ();
#ifdef _DEBUG
		if (!ret) DebugPrint ("Edit Mesh: Repairing MeshDelta mapping faces on load.\n");
#endif
	}
	return IO_OK;
	}


// CCJ 6/19/98
// Return the sub object material assignment interface
// This is used by the node when assigning materials.
// If an open face selection mode is active, the material
// will be assigned to the selected faces only.
// A multi/sub-object material is created and the material
// is assigned to the matierial ID created for the selected
// faces.
void* EditMeshMod::GetInterface(ULONG id) {
	if (id==I_SUBMTLAPI) return (ISubMtlAPI*)this;
	else if (id==I_MESHDELTAUSER) return (MeshDeltaUser*)this;
	else return Modifier::GetInterface(id);
}

// Return a material ID that is currently not used by the object.
// If the current face selection share once single MtlDI that is not
// used by any other faces, you should use it.
MtlID EditMeshMod::GetNextAvailMtlID(ModContext* mc) {
	if (!mc) return 1;
	EditMeshData *d = (EditMeshData*)mc->localData;
	if (!d) return 1;
	Mesh* m = d->GetMesh (ip->GetTime());

	int mtlID = GetSelFaceUniqueMtlID(mc);

	if (mtlID == -1) {
		int i;
		BitArray b;
		mtlID = m->numFaces;
		b.SetSize(m->numFaces, FALSE);
		b.ClearAll();
		for (i=0; i<m->numFaces; i++) {
			int mid = m->faces[i].getMatID();
			if (mid < m->numFaces) {
				b.Set(mid);
				}
			}

		for (i=0; i<m->numFaces; i++) {
			if (!b[i]) {
				mtlID = i;
				break;
				}
			}
		}

	return (MtlID)mtlID;
	}

// Indicate if you are active in the modifier panel and have an 
// active face selection
BOOL EditMeshMod::HasFaceSelection(ModContext* mc) {
	// Are we the edited object?
	if (ip == NULL)  return FALSE;

	EditMeshData *d = (EditMeshData*)mc->localData;

	// Do we have local data?
	if (!d) return FALSE;

	// Does the local data have a mesh?
	if (!d->MeshCached (ip->GetTime())) return FALSE;

	// Is Face selection active?
	if (selLevel < SL_FACE) return FALSE;

	return (d->mesh->faceSel.NumberSet() > 0);
}

// Set the selected faces to the specified material ID.
// If bResetUnsel is TRUE, then you should set the remaining
// faces material ID's to 0
void EditMeshMod::SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel) {

	EditMeshData *d = (EditMeshData*)mc->localData;

	d->BeginEdit (ip->GetTime());
	Mesh *m = d->GetMesh (ip->GetTime());		

	// Can't use the EMD_FLAG here since we will be "Accepted" by the materials editor...
	if (theHold.Holding()) theHold.Put(new FaceChangeRestore(d,this));

	for (int j=0; j<m->getNumFaces(); j++) {			
		if (m->faceSel[j]) {
			m->setFaceMtlIndex(j,(MtlID)id);
			d->mdelta.SetMatID((DWORD)j,id);
			}
		else if (bResetUnsel) {
			m->setFaceMtlIndex(j,(MtlID)0);
			d->mdelta.SetMatID((DWORD)j,0);
		}
	}

	InvalidateSurfaceUI();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

// Return the material ID of the selected face(s).
// If multiple faces are selected they should all have the same MtlID -
// otherwise you should return -1.
// If faces other than the selected share the same material ID, then 
// you should return -1.
int EditMeshMod::GetSelFaceUniqueMtlID(ModContext* mc) {
	int	i;
	int	mtlID;

	mtlID = GetSelFaceAnyMtlID(mc);

	EditMeshData *d = (EditMeshData*)mc->localData;
	Mesh* m = d->GetMesh (ip->GetTime());

	if (mtlID == -1) return mtlID;
	for (i=0; i<m->numFaces; i++) {
		if (m->faceSel[i]) continue;
		if (m->faces[i].getMatID() != mtlID) continue;
		mtlID = -1;
		break;
	}

	return mtlID;
}

// Return the material ID of the selected face(s).
// If multiple faces are selected they should all have the same MtlID,
// otherwise you should return -1.
int EditMeshMod::GetSelFaceAnyMtlID(ModContext* mc) {
	int				mtlID = -1;
	BOOL			bGotFirst = FALSE;
	int				i;

	EditMeshData *d = (EditMeshData*)mc->localData;
	Mesh* m = d->GetMesh (ip->GetTime());

	for (i=0; i<m->numFaces; i++) {
		if (!m->faceSel[i]) continue;
		if (bGotFirst) {
			if (mtlID != m->faces[i].getMatID()) {
				mtlID = -1;
				break;
			}
		} else {
			mtlID = m->faces[i].getMatID();
			bGotFirst = TRUE;
		}
	}

	return mtlID;
}

// Return the highest MtlID used by the object.
int EditMeshMod::GetMaxMtlID(ModContext* mc) {
	MtlID mtlID = 0;

	EditMeshData *d  = (EditMeshData*)mc->localData;
	Mesh* m = d->GetMesh (ip->GetTime());

	for (int i=0; i<m->numFaces; i++) mtlID = max(mtlID, m->faces[i].getMatID());
	return mtlID;
}

// Old bits for attribs:
// First 3 bits are edge visibility
// 4th bit is face visibility
// 29,30 and 31 indicate which if any should be applied
#define OLD_ATTRIB_APPLY_EDGE		(1<<31)
#define OLD_ATTRIB_APPLY_FACE		(1<<30)
#define OLD_ATTRIB_APPLY_MATID		(1<<29)
#define OLD_ATTRIB_APPLY_SMGROUP	(1<<28)

// Mat ID takes bit 5-21
#define OLD_ATTRIB_MATID_SHIFT	5
#define OLD_ATTRIB_MATID_MASK	0xffff

void ConvertToMeshDeltaPLCB::MyDebugPrint () {
	DebugPrint ("\nConverting old TopoDelta, VertexDelta to MeshDelta.\n");
	DebugPrint ("Expecting pipeline mesh of %d verts, %d faces\n", td.inputVerts, td.inputFaces);
	int i, num;
	if (num=td.cverts.Count()) {
		DebugPrint ("%d Vertex Clones:\n  ", num);
		for (i=0; i<num; i++) {
			DebugPrint ("%2d ", td.cverts[i]);
			if ((i<num-1) && (i%10==9)) DebugPrint ("\n  ");
		}
		DebugPrint ("\n");
	}
	if (num=td.dverts.Count()) {
		DebugPrint ("%d Vertex Deletes:\n  ", num);
		for (i=0; i<num; i++) {
			DebugPrint ("%2d ", td.dverts[i]);
			if ((i<num-1) && (i%10==9)) DebugPrint ("\n  ");
		}
		DebugPrint ("\n");
	}
	if (num=td.nverts.Count()) {
		DebugPrint ("%d Vertex Creates:\n", num);
		for (i=0; i<num; i++) {
			DebugPrint ("  %7.3f, %7.3f, %7.3f\n", td.nverts[i].x, td.nverts[i].y, td.nverts[i].z);
		}
	}
	if (num=vd.deltas.Count()) {
		DebugPrint ("Vertex Moves:\n");
		for (i=0; i<num; i++) {
			if (vd.deltas[i] == Point3(0,0,0)) continue;
			DebugPrint ("  %d: %7.3f, %7.3f, %7.3f\n", i, vd.deltas[i].x, vd.deltas[i].y, vd.deltas[i].z);
		}
	}
	if (num=td.map.Count()) {
		DebugPrint ("Face Remaps:\n");
		for (i=0; i<num; i++) {
			DebugPrint ("  %d: %3d, %3d, %3d\n", i, td.map[i].v[0], td.map[i].v[1], td.map[i].v[2]);
		}
	}
	if (num=td.nfaces.Count()) {
		DebugPrint ("Face Creates:\n");
		for (i=0; i<num; i++) {
			DebugPrint ("  %3d, %3d, %3d\n", td.nfaces[i].v[0], td.nfaces[i].v[1], td.nfaces[i].v[2]);
		}
	}
}

void ConvertToMeshDeltaPLCB::proc (ILoad *iload) {
	int num, i,j;
	// MyDebugPrint ();
	// Perform operations in same order as old TopoDelta::Apply, etc.
	MeshDelta & md = emd->mdelta;
	md.ClearAllOps ();
	if (emd->flags & EMD_HASDATA) {
		md.SetInVNum (td.inputVerts);
		md.SetInFNum (td.inputFaces);
		md.SetMapNum (2);
		md.mapSupport.ClearAll();
		if (td.nfaces.Count() == td.nTVfaces.Count()) {
			md.mapSupport.Set (1);
			md.map[1].fnum = td.inputFaces;
			// We have no value for md.map[1].vnum -- it's filled in by the first "Apply".
		}
		for (i=0; i<td.cverts.Count(); i++) md.VClone (td.cverts[i]);
		if (num=td.dverts.Count()) {
			// Careful how we apply following -- old way of saying verts 2,3 get deleted is to say 2, 2 get deleted -
			// delete vert 2, then delete vert 2 from what's left.
			// Equally valid old deletion pattern would be 3,2.
			BitArray vd;
			DWORD vdsize = md.vnum + md.vClone.Count();
			vd.SetSize (vdsize);
			for (i=0; i<num; i++) {
				int del = td.dverts[i];
				for (j=0; j<=del; j++) {	// Increment by the number of verts already deleted "below" this one.
					if (vd[j]) del++;
					if (del >= vdsize) break;
				}
				if (j<del) continue;
				vd.Set (del);
			}
			md.VDelete (vd);
		}
		if (td.nverts.Count()) md.VCreate (td.nverts.Addr(0), td.nverts.Count());
		int lastOrigV = md.vnum - md.vDelete.NumberSet();
		int lastCloneV = lastOrigV + md.vClone.Count();
		int numCl = md.vClone.Count();
		int numCr = md.vCreate.Count();

		if (md.mapSupport[1] && td.nTverts.Count()) md.map[1].VCreate (td.nTverts.Addr(0), td.nTverts.Count());

		if (num=td.dfaces.Count()) {
			// Careful how we apply following -- old way of saying faces 2,3 get deleted is to say 2, 2 get deleted -
			// delete face 2, then delete face 2 from what's left.
			// Equally valid old deletion pattern would be 3,2.
			BitArray fd;
			fd.SetSize (md.fnum);
			for (i=0; i<num; i++) {
				int del = td.dfaces[i];
				for (j=0; j<=del; j++) {	// Increment by the number of faces already deleted "below" this one.
					if (fd[j]) del++;
					if (del >= md.fnum) break;
				}
				if (j<del) continue;
				fd.Set (del);
			}
			md.FDelete (fd);
		}

		if (td.nfaces.Count()) md.FCreate (td.nfaces.Addr(0), td.nfaces.Count());
		// The newly created faces are indexed properly by pre-deleted verts, but
		// they'll need to have their clones and creates switched.
		for (i=0; i<md.fCreate.Count(); i++) {
			DWORD *vv = md.fCreate[i].v;
			DWORD max = md.vnum + numCl + numCr;
			for (j=0; j<3; j++) {
				if (vv[j] >= max) vv[j] = 0;
				if (vv[j] < md.vnum) continue;	// Remember: pre-deleted verts, thus vnum
				if (vv[j] < md.vnum+numCl) vv[j] += numCr;
				else vv[j] -= numCl;
			}
		}
		// No re-indexing for tex maps, since they have no clones, only creates.
		if (md.mapSupport[1] && td.nTVfaces.Count()) md.map[1].FCreate (td.nTVfaces.Addr(0), td.nTVfaces.Count());

		FaceRemap temp;
		DWORD *ww = temp.v;
		if (td.map.Count()) {
			// Remaps in original form are indexed by post-deleted verts, and also have
			// their clones and creates switched.
			DWORD max = lastCloneV + td.nverts.Count();
			for (i=0; i<td.map.Count(); i++) {
				temp.flags = 0;
				for (j=0; j<3; j++) {
					if ((ww[j] = td.map[i].v[j]) != UNDEFINED) {
						temp.flags |= (1<<j);
						if (ww[j] >= max) ww[j] = 0;	// correct for out-of-range.
						if (ww[j] >= lastOrigV) {	// Remember: post-deleted indices.
							if (ww[j] < lastCloneV) ww[j] += numCr;
							else ww[j] -= numCl;
						}
						ww[j] = md.VLut (ww[j]);	// Here is the conversion to pre-deleted.
					}
				}
				if (!temp.flags) continue;
				temp.f = md.FLut(i);
				if (temp.f>=md.fnum) {
					MaxAssert (temp.f < md.fnum + (DWORD)md.fCreate.Count());
					temp.Apply (md.fCreate[temp.f-md.fnum]);
				} else md.fRemap.Append (1, &temp, td.map.Count());
			}
		}

		if (md.mapSupport[1] && td.tmap.Count()) {
			for (i=0; i<td.tmap.Count(); i++) {
				temp.flags = 0;
				for (j=0; j<3; j++) {
					if ((ww[j] = td.tmap[i].v[j]) != UNDEFINED) temp.flags |= (1<<j);
				}
				if (!temp.flags) continue;
				temp.f = i;
				if (temp.f>=md.fnum) {
					MaxAssert (temp.f < md.fnum + (DWORD)md.map[1].fCreate.Count());
					temp.Apply (md.fCreate[temp.f-md.fnum]);
				} else md.map[1].fRemap.Append (1, &temp, td.map.Count());
			}
		}

		if (td.attribs.Count()) {
			FaceChange fcTemp;
			FaceSmooth fsTemp;
			for (i=0; i<td.attribs.Count(); i++) {
				fcTemp.flags = 0;
				fcTemp.val = 0;
				if (td.attribs[i] & OLD_ATTRIB_APPLY_EDGE) {
					fcTemp.flags |= EDGE_ALL;
					fcTemp.val |= (td.attribs[i] & EDGE_ALL);
				}
				if (td.attribs[i] & OLD_ATTRIB_APPLY_FACE) {
					fcTemp.flags |= FACE_HIDDEN;
					fcTemp.val |= (td.attribs[i] & FACE_HIDDEN);
				}
				if (td.attribs[i] & OLD_ATTRIB_APPLY_MATID) {
					fcTemp.flags |= ATTRIB_MATID;
					MtlID mid = (MtlID)(td.attribs[i]>>OLD_ATTRIB_MATID_SHIFT)&OLD_ATTRIB_MATID_MASK;
					fcTemp.val |= mid<<ATTRIB_MATID_SHIFT;
				}
				if (fcTemp.flags) {
					fcTemp.f = md.FLut(i);
					if (fcTemp.f >= md.fnum) {
						MaxAssert (fcTemp.f < md.fnum + (DWORD)md.fCreate.Count());
						temp.Apply (md.fCreate[temp.f-md.fnum]);
					} else md.fChange.Append (1, &fcTemp, td.attribs.Count());
				}
				if (td.attribs[i] & OLD_ATTRIB_APPLY_SMGROUP) {
					fsTemp.f = md.FLut(i);
					fsTemp.mask = ~0x0;
					fsTemp.val = td.smgroups[i];
					if (fsTemp.f >= md.fnum) {
						MaxAssert (fcTemp.f < md.fnum + (DWORD)md.fCreate.Count());
						temp.Apply (md.fCreate[temp.f-md.fnum]);
					} else md.fSmooth.Append (1, &fsTemp, td.attribs.Count());
				}
			}
		}

		for (i=0; i<vd.deltas.Count(); i++) {
			if (i<lastOrigV) md.Move (i, vd.deltas[i]);
			else {
				if (i<lastCloneV) md.Move (i+numCr, vd.deltas[i]);
				else md.Move (i-numCl, vd.deltas[i]);
			}
		}
		md.vsel = vsel;
		md.vsel.SetSize (md.outVNum(), TRUE);
		md.vhide = vd.hide;
		md.vhide.SetSize (md.outVNum(), TRUE);
		md.esel = esel;
		md.esel.SetSize (md.outFNum()*3, TRUE);
		md.fsel = fsel;
		md.fsel.SetSize (md.outFNum(), TRUE);

		// Finally, if we're loading up a topodelta version, the subobject indices have changed:
		if (em->GetFlag (EM_SWITCH_SUBOBJ_VERSIONS)) {
			switch (em->selLevel) {
			case 2:
				em->selLevel = SL_POLY;
				break;
			case 3:
				em->selLevel = SL_EDGE;
				break;
			}
			em->ClearFlag (EM_SWITCH_SUBOBJ_VERSIONS);
		}
	}

	//emd->mdelta.MyDebugPrint (FALSE, TRUE);
	delete this;
}

void EditMeshMod::ShowEndResultChanged (BOOL showEndResult) {
	if (!ip) return;
	if (!GetFlag (EM_EDITING)) return;
	NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
}

// Not a real restore object:
TempMoveRestore::TempMoveRestore (Mesh *msh) {
	init.SetCount (msh->numVerts);
	if (msh->numVerts) memcpy (init.Addr(0), msh->verts, msh->numVerts*sizeof(Point3));
}

void TempMoveRestore::Restore (Mesh *msh) {
	if (!init.Count()) return;
	int min = (msh->numVerts < init.Count()) ? msh->numVerts : init.Count();
	memcpy (msh->verts, init.Addr(0), min*sizeof(Point3));
}

static TimeValue dragTime;
static bool dragRestored;
static bool inDragMove=FALSE;

void EditMeshMod::DragMoveInit (TimeValue t) {
	if (!ip) return;
	dragTime = t;
	inDragMove = TRUE;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for (int nd = 0; nd<mcList.Count(); nd++) {
		if (!mcList[nd]->localData) continue;
		EditMeshData *emd = (EditMeshData *) mcList[nd]->localData;
		Mesh *mesh = emd->GetMesh(t);
		emd->tempMove.InitToMesh (*mesh);
		if (emd->tmr) delete emd->tmr;
		emd->tmr = new TempMoveRestore (mesh);
	}
	dragRestored = TRUE;
}

void EditMeshMod::DragMoveRestore () {
	if (!ip) return;
	if (dragRestored) return;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for (int nd = 0; nd<mcList.Count(); nd++) {
		if (!mcList[nd]->localData) continue;
		EditMeshData *emd = (EditMeshData *) mcList[nd]->localData;
		emd->tempMove.vMove.ZeroCount();
		if (!emd->tmr) continue;
		emd->tmr->Restore (emd->GetMesh(dragTime));
	}
	LocalDataChanged (PART_GEOM);
	if (theHold.Holding ()) theHold.Put (new CueLocalRestore(this));
	dragRestored = TRUE;
}

void EditMeshMod::DragMove (MeshDelta & md, MeshDeltaUserData *mdu) {
	if (!ip) return;
	if (!inDragMove) {
		mdu->ApplyMeshDelta (md, this, ip->GetTime());
		return;
	}

	EditMeshData *emd = (EditMeshData *) mdu;
	Mesh *mesh = emd->GetMesh (dragTime);
	for (int i=0; i<md.vMove.Count(); i++) {
		DWORD j = md.vMove[i].vid;
		mesh->verts[j] += md.vMove[i].dv;
	}
	emd->tempMove = md;
	LocalDataChanged (PART_GEOM);
	dragRestored = FALSE;
}

void EditMeshMod::DragMoveAccept () {
	if (!ip) return;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for (int nd = 0; nd<mcList.Count(); nd++) {
		if (!mcList[nd]->localData) continue;
		EditMeshData *emd = (EditMeshData *) mcList[nd]->localData;
		if (!emd->tmr) continue;
		emd->Invalidate (PART_GEOM, FALSE);
		// (Invalidate clears out the mesh, so we don't update it incorrectly with a double-move.)
		emd->ApplyMeshDelta (emd->tempMove, this, dragTime);
		emd->tempMove.ClearAllOps ();
		delete emd->tmr;
		emd->tmr = NULL;
	}
	inDragMove = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editmops.cpp ===
/**********************************************************************
 *<
	FILE: editmops.cpp

	DESCRIPTION:  Edit Mesh OSM operations

	CREATED BY: Rolf Berteig

	HISTORY: created 30 March, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "mods.h"
#include "MeshDLib.h"
#include "editmesh.h"
#include "imtl.h"
#include "spline3d.h"
#include "splshape.h"
#include "shape.h"

void Matrix3DebugPrint (Matrix3 & tm) {
	if (tm.GetIdentFlags() & POS_IDENT) DebugPrint ("   No translation\n");
	if (tm.GetIdentFlags() & ROT_IDENT) DebugPrint ("   No rotation\n");
	if (tm.GetIdentFlags() & SCL_IDENT) DebugPrint ("   No scaling\n");
	for (int i=0; i<4; i++) {
		Point3 r = tm.GetRow(i);
		DebugPrint ("  %7.3f  %7.3f  %7.3f\n", r[0], r[1], r[2]);
	}
}

void EditMeshMod::ClearMeshDataFlag(ModContextList& mcList,DWORD f) {
	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		meshData->SetFlag(f,FALSE);
	}
}

void EditMeshMod::CloneSelSubComponents(TimeValue t) {
	if (selLevel == SL_OBJECT) return;
	if (!ip) return;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);
	
	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(t);

		MeshDelta tmd(*mesh);
		switch (selLevel) {
		case SL_VERTEX: tmd.CloneVerts (*mesh, mesh->vertSel); break;
		case SL_EDGE: tmd.ExtrudeEdges (*mesh, mesh->edgeSel); break;
		default: tmd.CloneFaces (*mesh, mesh->faceSel); break;
		}
		meshData->ApplyMeshDelta (tmd, this, t);

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept(GetString(IDS_RB_CLONE));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::AcceptCloneSelSubComponents(TimeValue t) {
	if (!ip) return;
	if ((selLevel==SL_OBJECT) || (selLevel==SL_EDGE)) return;
	TSTR name;
	if (!GetCloneObjectName (ip, name)) return;
	if (!ip) return;
	Detach (name, (selLevel != SL_VERTEX), TRUE, FALSE);
}

void EditMeshMod::Transform (TimeValue t, Matrix3& partm, Matrix3 tmAxis, 
		BOOL localOrigin, Matrix3 xfrm, int type) {
	if (!ip) return;

	if (sliceMode) {
		// Special case -- just transform slicing plane.
		theHold.Put (new TransformPlaneRestore(this));
		Matrix3 tm  = partm * Inverse(tmAxis);
		Matrix3 itm = Inverse(tm);
		Matrix3 myxfm = tm * xfrm * itm;
		Point3 myTrans, myScale;
		Quat myRot;
		DecomposeMatrix (myxfm, myTrans, myRot, myScale);
		float factor;
		switch (type) {
		case 0: sliceCenter += myTrans; break;
		case 1: sliceRot *= myRot; break;
		case 2:
			factor = (float) exp(log(myScale[0]*myScale[1]*myScale[2])/3.0);
			sliceSize *= factor;
			break;
		}
		NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime());
		return;
	}

	// Definitely transforming subobject geometry:
	DragMoveRestore ();

	// Get modcontexts
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	// Get axis type:
	int numAxis = ip->GetNumAxis();
	BOOL normMoveVerts = FALSE;

	// Special case for vertices: Only individual axis when moving in local space
	if ((selLevel==SL_VERTEX) && (numAxis==NUMAXIS_INDIVIDUAL)) {
		if (ip->GetRefCoordSys()!=COORDS_LOCAL || 
			ip->GetCommandMode()->ID()!=CID_SUBOBJMOVE) {
			numAxis = NUMAXIS_ALL;
		} else {
			normMoveVerts = TRUE;
		}
	}

	ClearMeshDataFlag(mcList,EMD_BEENDONE);
	for (int nd=0; nd<mcList.Count(); nd++) {
		EditMeshData *meshData = (EditMeshData*)mcList[nd]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		Mesh *mesh = meshData->GetMesh(t);
		MeshTempData *td = meshData->TempData(t);

		// partm is useless -- need this matrix which includes object-offset:
		Matrix3 objTM = nodes[nd]->GetObjectTM(t);

		// Selected vertices - either directly or indirectly through selected faces or edges.
		BitArray sel = mesh->VertexTempSel();
		if (!sel.NumberSet()) continue;
		MeshDelta tmd(*mesh);

		// Setup some of the affect region stuff
		Tab<Point3> *vertNorms=NULL;
		if (normMoveVerts) vertNorms = td->VertexNormals ();
		int i, nv=mesh->numVerts;

		// Compute the transforms
		if ((numAxis==NUMAXIS_INDIVIDUAL) && (selLevel != SL_VERTEX)) {
			// Do each cluster one at a time
			DWORD count = (selLevel == SL_EDGE) ? td->EdgeClusters()->count : td->FaceClusters()->count;
			Tab<DWORD> *vclust = td->VertexClusters(meshLevel[selLevel]);
			float *clustDist=NULL, *ws=NULL;
			Tab<float> weightSum;
			Matrix3 tm, itm;
			if (affectRegion) {
				weightSum.SetCount(nv);
				ws = weightSum.Addr(0);
				for (i=0; i<nv; i++) ws[i] = 0.0f;
			}
			for (DWORD j=0; j<count; j++) {
				tmAxis = ip->GetTransformAxis (nodes[nd], j);
				tm  = objTM * Inverse(tmAxis);
				itm = Inverse(tm);
				tm *= xfrm;
				if (affectRegion) clustDist = td->ClusterDist(meshLevel[selLevel], j, useEdgeDist, edgeIts)->Addr(0);
				for (i=0; i<nv; i++) {
					if (sel[i]) {
						if ((*vclust)[i]!=j) continue;
						Point3 & old = mesh->verts[i];
						tmd.Move (i, (tm*old)*itm - old);
					} else {
						if (!affectRegion) continue;
						if (clustDist[i] < 0) continue;
						if (clustDist[i] > falloff) continue;
						float af = AffectRegionFunction (clustDist[i], falloff, pinch, bubble);
						ws[i] += af;
						Point3 & old = mesh->verts[i];
						tmd.Move (i, ((tm*old)*itm - old)*af);
					}
				}
			}
			if (affectRegion) {
				for (i=0; i<nv; i++) {
					if (sel[i]) continue;
					if (ws[i] <= 1) continue;
					j = tmd.MoveID(i);
					if (j==(DWORD)tmd.vMove.Count()) continue;
					if (tmd.vMove[j].vid != (DWORD)i) continue;
					tmd.vMove[j].dv /= weightSum[i];
				}
			}
		} else {
			Matrix3 tm  = objTM * Inverse(tmAxis);
			Matrix3 itm = Inverse(tm);
			tm *= xfrm;
			Matrix3 ntm;
			if (numAxis == NUMAXIS_INDIVIDUAL) ntm = nodes[nd]->GetObjectTM(t);
			float *ws=NULL;
			if (affectRegion) ws = td->VSWeight(useEdgeDist, edgeIts, arIgBack, falloff, pinch, bubble)->Addr(0);
			for (i=0; i<nv; i++) {
				if (!sel[i] && (!ws || (ws[i]<=0))) continue;
				Point3 & old = mesh->verts[i];
				Point3 delta;
				if (numAxis == NUMAXIS_INDIVIDUAL) {
					MatrixFromNormal ((*vertNorms)[i], tm);
					tm  = objTM * Inverse(tm*ntm);
					itm = Inverse(tm);
					delta = itm*(xfrm*(tm*old)) - old;
				} else {
					delta = itm*(tm*old)-old;
				}
				if (sel[i]) tmd.Move (i, delta);
				else tmd.Move (i, delta * ws[i]);
			}
		}

		DragMove (tmd, meshData);
		meshData->SetFlag(EMD_BEENDONE,TRUE);		
	}

	nodes.DisposeTemporary();
	ClearMeshDataFlag(mcList,EMD_BEENDONE);
}

void EditMeshMod::Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin ) {
	Transform (t, partm, tmAxis, localOrigin, TransMatrix(val), 0);	
}

void EditMeshMod::Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin ) {
	Matrix3 mat;
	val.MakeMatrix(mat);
	Transform(t, partm, tmAxis, localOrigin, mat, 1);
}

void EditMeshMod::Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin ) {
	Transform (t, partm, tmAxis, localOrigin, ScaleMatrix(val), 2);	
}

void EditMeshMod::TransformStart (TimeValue t) {
	if (!ip) return;
	ip->LockAxisTripods(TRUE);
	if (sliceMode) return;
	DragMoveInit (t);
}

void EditMeshMod::TransformHoldingFinish (TimeValue t) {
	if (!ip) return;
	if (sliceMode) return;
	DragMoveAccept ();
}

void EditMeshMod::TransformFinish (TimeValue t) {
	if (!ip) return;
	ip->LockAxisTripods(FALSE);
}

void EditMeshMod::TransformCancel (TimeValue t) {
	if (!ip) return;
	ip->LockAxisTripods(FALSE);
	DragMoveRestore ();
}

// Selection dialog ops

void EditMeshMod::HideSelectedVerts() {
	if (!ip) return;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());

		// Start a restore object...
		meshData->AddVertHide (mesh->vertSel, this, ip->GetTime());
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}
 	theHold.Accept(GetString(IDS_RB_HIDEVERT));
	nodes.DisposeTemporary();

	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::UnhideAllVerts() {
	ModContextList mcList;
	INodeTab nodes;

	if (!ip) return;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		meshData->ClearVertHide (this, ip->GetTime());
		meshData->SetFlag(EMD_BEENDONE,TRUE);		
	}
	theHold.Accept(GetString(IDS_RB_UNHIDEALLFACES));	// just says unhide all.
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::HideSelectedFaces() {
	ModContextList mcList;
	INodeTab nodes;

	if (!ip) return;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		meshData->BeginEdit(ip->GetTime());
		Mesh *mesh = meshData->GetMesh(ip->GetTime());

		theHold.Put (new MeshEditRestore (meshData, this, MDELTA_FCHANGE | MDELTA_FCREATE));

		for (int j=0; j<mesh->getNumFaces(); j++) {
			if (mesh->faceSel[j]) {
				mesh->faces[j].Hide();
				meshData->mdelta.FChange ((DWORD)j, ATTRIB_HIDE_FACE, ATTRIB_HIDE_FACE);
			}
		}
		
		BitArray emptyFaceSel;
		emptyFaceSel.SetSize (mesh->numFaces);
		meshData->SetFaceSel (emptyFaceSel, this, ip->GetTime());

		// Reset vertex hide flags
		theHold.Put (new VertexHideRestore (meshData, this));
		HiddenFacesToVerts (*mesh,meshData->mdelta.vhide);
		meshData->mdelta.vhide = mesh->vertHide;
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}
		
	theHold.Accept(GetString(IDS_RB_HIDEFACE));
	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_TOPO|PART_DISPLAY, REFMSG_CHANGE);
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::UnhideAllFaces() {
	ModContextList mcList;
	INodeTab nodes;

	if (!ip) return;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		meshData->BeginEdit(ip->GetTime());
		Mesh *mesh = meshData->GetMesh(ip->GetTime());		

		theHold.Put(new FaceChangeRestore(meshData,this));

		for (int j=0; j<mesh->getNumFaces(); j++) {
			if (!mesh->faces[j].Hidden()) continue;
			mesh->faces[j].Show();
			meshData->mdelta.FChange ((DWORD)j, ATTRIB_HIDE_FACE, 0);
		}
		
		// Reset vertex hide flags
		HiddenFacesToVerts (*mesh, meshData->mdelta.vhide);
		meshData->SetFlag(EMD_BEENDONE,TRUE);		
	}
		
	theHold.Accept(GetString(IDS_RB_UNHIDEALLFACES));
	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

// Edit Geometry ops

DWORD EditMeshMod::CreateVertex(Point3 pt, EditMeshData *meshData, INode *nref) {
	if (!ip) return UNDEFINED;
	// Put the point in object space:
	INodeTab nodes;
	bool dispTemp=FALSE;
	if (meshData == NULL) {
		ModContextList mcList;
		ip->GetModContexts(mcList,nodes);	
		meshData = (EditMeshData*)mcList[0]->localData;
		if (!meshData) {
			nodes.DisposeTemporary();
			return UNDEFINED;
		}
		nref = nodes[0];
		dispTemp=TRUE;
	}
	meshData->BeginEdit(ip->GetTime());		
	pt = pt * Inverse(nref->GetObjectTM(ip->GetTime()));
	if (dispTemp) nodes.DisposeTemporary();

	Mesh *mesh = meshData->GetMesh(ip->GetTime());
	MeshDelta tmd(*mesh);
	DWORD ret = tmd.VCreate (&pt);
	tmd.vsel.Set (ret);

	theHold.Begin();
	meshData->ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_ADDVERTS));

	ip->RedrawViews(ip->GetTime());
	return ret;
}

bool EditMeshMod::CreateFace (EditMeshData *meshData, int *v, int deg) {
	Mesh *mesh = meshData->GetMesh(ip->GetTime());
	MeshDelta tmd(*mesh);
	if (tmd.CreatePolygon (*mesh, deg, v) == UNDEFINED) return FALSE;
	theHold.Begin ();
	meshData->ApplyMeshDelta (tmd, this, ip->GetTime());
	theHold.Accept (GetString (IDS_RB_BUILDFACE));
	ip->RedrawViews(ip->GetTime());
	return TRUE;
}

void EditMeshMod::DeleteSelected() {
	if (selLevel == SL_OBJECT) return;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	int i, j, delIso = -1;
	BitArray fset, iso;
	DWORD stringID, of;
	AdjFaceList *af;

	theHold.Begin();

	for (int nd=0; nd<mcList.Count(); nd++) {
		EditMeshData *meshData = (EditMeshData*)mcList[nd]->localData;
		if ( !meshData ) continue;
		if ( meshData->GetFlag(EMD_BEENDONE)) continue;

		Mesh *mesh=meshData->GetMesh (ip->GetTime());
		MeshDelta tmd(*mesh);

		switch (selLevel) {
		case SL_VERTEX:
			tmd.DeleteVertSet (*mesh, mesh->vertSel);
			stringID = IDS_RB_DELETEVERT;
			break;

		case SL_EDGE:
			af = meshData->TempData(ip->GetTime())->AdjFList();
			fset.SetSize(mesh->getNumFaces());

			for (i=0; i<mesh->getNumFaces(); i++) {
				for (j=0; j<3; j++) if (mesh->edgeSel[i*3+j]) break;
				if (j==3) continue;
				fset.Set(i);
				// Mark other sides of edges:
				for (; j<3; j++) {
					if (!mesh->edgeSel[i*3+j]) continue;
					if ((of=(*af)[i].f[j]) != UNDEFINED) fset.Set(of);
				}
			}

			mesh->FindVertsUsedOnlyByFaces (fset, iso);
			tmd.DeleteFaceSet (*mesh, fset);

			if (iso.NumberSet()) {
				if (delIso==-1) {
					TSTR str1 = GetString(IDS_RB_DELETEISOLATED);
					TSTR str2 = GetString(IDS_RB_DELETEFACE);
					delIso = (IDYES==MessageBox (ip->GetMAXHWnd(), str1, str2, MB_ICONQUESTION|MB_YESNO)) ? 1 : 0;
				}
				if (delIso) tmd.VDelete (iso);
			}

			stringID = IDS_RB_DELETEEDGE;
			break;

		default:
			mesh->FindVertsUsedOnlyByFaces (mesh->faceSel, iso);
			tmd.DeleteFaceSet (*mesh, meshData->mdelta.fsel);

			if (iso.NumberSet()) {
				if (delIso==-1) {
					TSTR str1 = GetString(IDS_RB_DELETEISOLATED);
					TSTR str2 = GetString(IDS_RB_DELETEFACE);
					delIso = (IDYES==MessageBox (ip->GetMAXHWnd(), str1, str2, MB_ICONQUESTION|MB_YESNO)) ? 1 : 0;
				}
				if (delIso) tmd.VDelete (iso);
			}
			stringID = IDS_RB_DELETEFACE;
			break;

		}
		if (!ip) break;
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	nodes.DisposeTemporary();
	if (!ip) return;

	theHold.Accept(GetString(stringID));
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::Attach (INode *node, bool & canUndo) {
	// Get the attach object
	BOOL del = FALSE;
	TriObject *obj = NULL;
	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
	if (os.obj->IsSubClassOf(triObjectClassID)) obj = (TriObject *) os.obj;
	else {
		if (!os.obj->CanConvertToType(triObjectClassID)) return;
		obj = (TriObject*)os.obj->ConvertToType(ip->GetTime(),triObjectClassID);
		if (obj!=os.obj) del = TRUE;
	}

	// Get our node: (We always attach to node 0.)
	ModContextList mcList;
	INodeTab nodes;	
	ip->GetModContexts(mcList,nodes);	

	// Get local data:
	EditMeshData *meshData = (EditMeshData*)mcList[0]->localData;
	if (!meshData) {
		nodes.DisposeTemporary();
		return;
	}
	Mesh *mesh = meshData->GetMesh(ip->GetTime());

	theHold.Begin();

	// Combine the materials of the two nodes.
	int mat2Offset=0;
	Mtl *m1 = nodes[0]->GetMtl();
	Mtl *m2 = node->GetMtl();
	bool condenseMe = FALSE;
	if (m1 && m2 && (m1 != m2)) {
		if (attachMat==ATTACHMAT_IDTOMAT) {
			int ct=1;
			if (m1->IsMultiMtl()) ct = m1->NumSubMtls();
			MeshDelta tmd(*mesh);
			tmd.RestrictMatIDs (*mesh, ct);
			meshData->ApplyMeshDelta (tmd, this, ip->GetTime());
			FitMeshIDsToMaterial (obj->GetMesh(), m2);
			if (condenseMat) condenseMe = TRUE;
		}

		// the theHold calls here were a vain attempt to make this all undoable.
		// This should be revisited in the future so we don't have to use the SYSSET_CLEAR_UNDO.
		theHold.Suspend ();
		if (attachMat==ATTACHMAT_MATTOID) {
			m1 = FitMaterialToMeshIDs (*mesh, m1);
			m2 = FitMaterialToMeshIDs (obj->GetMesh(), m2);
		}
		Mtl *multi = CombineMaterials (m1, m2, mat2Offset);
		if (attachMat == ATTACHMAT_NEITHER) mat2Offset = 0;
		theHold.Resume ();
		// We can't be in face subobject mode, else we screw up the materials:
		DWORD oldSL = selLevel;
		if (oldSL>SL_EDGE) selLevel = SL_OBJECT;
		nodes[0]->SetMtl(multi);
		if (oldSL>SL_EDGE) selLevel = oldSL;
		m1 = multi;
		canUndo = FALSE;
	}
	if (!m1 && m2) {
		// This material operation seems safe.
		// We can't be in face subobject mode, else we screw up the materials:
		DWORD oldSL = selLevel;
		if (oldSL>SL_EDGE) selLevel = SL_OBJECT;
		nodes[0]->SetMtl(m2);
		if (oldSL>SL_EDGE) selLevel = oldSL;
		m1 = m2;
	}

	// Construct a transformation that takes a vertex out of the space of
	// the source node and puts it into the space of the destination node.
	Matrix3 tm = node->GetObjectTM(ip->GetTime()) *
		Inverse(nodes[0]->GetObjectTM(ip->GetTime()));

	MeshDelta nmd;
	nmd.AttachMesh (*mesh, obj->GetMesh(), tm, mat2Offset);
	meshData->ApplyMeshDelta (nmd, this, ip->GetTime());
	ip->DeleteNode(node);
	theHold.Accept (GetString (IDS_RB_ATTACHOBJECT));

	if (m1 && condenseMe) {
		// Have to clear undo stack.
		if (!m1->IsMultiMtl()) GetSystemSetting(SYSSET_CLEAR_UNDO);
		mesh = meshData->GetMesh(ip->GetTime());
		m1 = CondenseMatAssignments (*mesh, m1);
	}

	nodes.DisposeTemporary();
	if (del) delete obj;
}

void EditMeshMod::MultiAttach (INodeTab &nodeTab) {
	bool canUndo = TRUE;
	if (nodeTab.Count() > 1) theHold.SuperBegin ();
	for (int i=0; i<nodeTab.Count(); i++) Attach (nodeTab[i], canUndo);
	if (nodeTab.Count() > 1) theHold.SuperAccept (GetString (IDS_EM_ATTACH_LIST));
	if (!canUndo) GetSystemSetting (SYSSET_CLEAR_UNDO);
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::Detach (TSTR &name,BOOL doFaces,BOOL del, BOOL elem) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();
	if (!elem) {	// Animation confuses things.
		SuspendAnimate();
		AnimateOff();
	}

	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());

		TriObject *newObj;
		if (!elem) newObj = CreateNewTriObject ();

		MeshDelta tmd;
		tmd.Detach (*mesh, elem ? NULL : &(newObj->GetMesh()),
			doFaces ? mesh->faceSel : mesh->vertSel, doFaces, del, elem);
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		if (!elem) {
			// Add the object to the scene. Give it the given name
			// and set its transform to ours.
			// Also, give it our material.
			INode *node = ip->CreateObjectNode(newObj);
			Matrix3 ntm = nodes[i]->GetNodeTM(ip->GetTime());
			INode *nodeByName = ip->GetINodeByName (name);
			if (nodeByName != node) {	// Can happen, eg for "Object01".
				TSTR uname = name;
				if (nodeByName) ip->MakeNameUnique(uname);
				node->SetName (uname);
			}
			node->SetNodeTM(ip->GetTime(),ntm);
			node->FlagForeground(ip->GetTime(),FALSE);
			node->SetMtl(nodes[i]->GetMtl());
			node->SetObjOffsetPos (nodes[i]->GetObjOffsetPos());
			node->SetObjOffsetRot (nodes[i]->GetObjOffsetRot());
			node->SetObjOffsetScale (nodes[i]->GetObjOffsetScale());
		}

		meshData->SetFlag (EMD_BEENDONE, TRUE);
	}

	if (!elem) ResumeAnimate ();
	theHold.Accept (GetString (doFaces ? IDS_EM_DETACHFACES : IDS_EM_DETACHVERTS));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::BreakVerts () {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts (mcList, nodes);
	ClearMeshDataFlag (mcList, EMD_BEENDONE);

	theHold.Begin ();
	for (int nd=0; nd<mcList.Count(); nd++) {
		EditMeshData *emd = (EditMeshData *) mcList[nd]->localData;
		if (emd->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = emd->GetMesh (ip->GetTime());
		if (!mesh->vertSel.NumberSet()) continue;

		MeshDelta tmd;
		tmd.BreakVerts (*mesh, mesh->vertSel);
		emd->ApplyMeshDelta (tmd, this, ip->GetTime());
		emd->SetFlag(EMD_BEENDONE,TRUE);
	}
	theHold.Accept (GetString (IDS_EM_VERT_BREAK));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::DoExtrusion() {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();

	Tab<Point3> edir;
	TimeValue t = ip->GetTime();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		if ( meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(t);
		MeshTempData *tempd = meshData->TempData(t);
		
		MeshDelta tmd(*mesh);
		if (selLevel == SL_EDGE) {
			tmd.ExtrudeEdges (*mesh, mesh->edgeSel, &edir);
			meshData->ApplyMeshDelta (tmd, this, t);
			meshData->TempData(t)->EdgeExtDir (&edir, extType);
		} else {
			AdjEdgeList *ae = tempd->AdjEList();
			tmd.ExtrudeFaces (*mesh, mesh->faceSel, ae);
			meshData->ApplyMeshDelta (tmd, this, t);
			meshData->TempData(t)->FaceExtDir (extType);
		}
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept(GetString(IDS_RB_EXTRUDE));
	nodes.DisposeTemporary();
}

void EditMeshMod::BeginExtrude (TimeValue t) {
	if (inExtrude) return;
	inExtrude = TRUE;
	theHold.SuperBegin();
	DoExtrusion();
	DragMoveInit (t);
}

void EditMeshMod::EndExtrude (TimeValue t, BOOL accept) {	
	if (!inExtrude) return;
	if (!ip) return;
	inExtrude = FALSE;

	theHold.Begin ();
	DragMoveAccept ();
	theHold.Accept(GetString(IDS_DS_MOVE));
	if (accept) theHold.SuperAccept(IDS_RB_EXTRUDE);
	else theHold.SuperCancel();

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		MeshTempData *tempd = meshData->TempData(t);
		tempd->freeBevelInfo();
	}
	nodes.DisposeTemporary();

	ISpinnerControl *spin = GetISpinner(GetDlgItem(hGeom,IDC_EM_EXTRUDESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
	}
}

void EditMeshMod::Extrude( TimeValue t, float amount ) {	
	if (!inExtrude) return;
	DragMoveRestore ();

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		Mesh *mesh = meshData->GetMesh(t);
		MeshTempData *tempd = meshData->TempData(t);

		BitArray sel = mesh->VertexTempSel();
		Tab<Point3> *extDir = tempd->CurrentExtDir();
		if ((extDir==NULL) || (amount==0)) continue;
		Tab<DWORD> *clust = tempd->VertexClusters(meshLevel[selLevel]);

		MeshDelta tmd(*mesh);
		tmd.Bevel (*mesh, sel, 0, NULL, amount, extDir);
		DragMove (tmd, meshData);
	}

	nodes.DisposeTemporary();
}

static int ExtDone=FALSE;

void EditMeshMod::BeginBevel (TimeValue t, BOOL doExtrude) {
	if (inBevel) return;
	inBevel = TRUE;
	theHold.SuperBegin();
	if (ExtDone=doExtrude) DoExtrusion();
	DragMoveInit (t);
}

void EditMeshMod::EndBevel (TimeValue t, BOOL accept) {	
	if (!inBevel) return;
	if (!ip) return;
	inBevel = FALSE;

	theHold.Begin ();
	DragMoveAccept ();
	theHold.Accept(GetString (IDS_DS_MOVE));
	if (accept)
		theHold.SuperAccept(GetString (ExtDone ? IDS_EM_BEVEL : IDS_EM_OUTLINE));
	else theHold.SuperCancel();

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		MeshTempData *tempd = meshData->TempData(t);
		tempd->freeBevelInfo();
	}

	ISpinnerControl *spin = GetISpinner(GetDlgItem(hGeom,IDC_EM_EXTRUDESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
	}
	spin = GetISpinner(GetDlgItem(hGeom,IDC_EM_OUTLINESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
	}
}

void EditMeshMod::Bevel (TimeValue t, float outline, float height) {	
	if (!inBevel) return;
	DragMoveRestore();

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		Mesh *mesh = meshData->GetMesh(t);
		MeshTempData *tempd = meshData->TempData(t);

		BitArray sel = mesh->VertexTempSel();
		MeshDelta tmd(*mesh);
		tmd.Bevel (*mesh, sel, outline, tempd->OutlineDir(extType), height, tempd->CurrentExtDir());
		DragMove (tmd, meshData);
	}

	nodes.DisposeTemporary();
}

void EditMeshMod::DoChamfer (TimeValue t) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		if ( meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(t);
		MeshTempData *tempd = meshData->TempData(t);
		AdjEdgeList *ae = tempd->AdjEList();
		MeshChamferData *mcd = tempd->ChamferData();
		
		MeshDelta tmd(*mesh);
		if (selLevel == SL_EDGE) tmd.ChamferEdges (*mesh, mesh->edgeSel, *mcd, ae);
		else tmd.ChamferVertices (*mesh, mesh->vertSel, *mcd, ae);
		meshData->ApplyMeshDelta (tmd, this, t);
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept (GetString (IDS_EM_CHAMFER));
	nodes.DisposeTemporary();
}

void EditMeshMod::BeginChamfer (TimeValue t) {
	if (inChamfer) return;
	inChamfer = TRUE;
	theHold.SuperBegin();
	DoChamfer (t);
	DragMoveInit (t);
}

void EditMeshMod::EndChamfer (TimeValue t, BOOL accept) {		
	if (!ip) return;
	if (!inChamfer) return;
	inChamfer = FALSE;

	// Eliminate all the chamfer data:
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		MeshTempData *tempd = meshData->TempData(t);
		tempd->freeChamferData();
	}
	nodes.DisposeTemporary();

	theHold.Begin ();
	DragMoveAccept ();
	theHold.Accept(GetString(IDS_DS_MOVE));
	if (accept) theHold.SuperAccept(GetString(IDS_EM_CHAMFER));
	else theHold.SuperCancel();

	ISpinnerControl *spin = GetISpinner(GetDlgItem(hGeom,IDC_EM_OUTLINESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
	}
}

void EditMeshMod::Chamfer (TimeValue t, float amount) {
	if (!inChamfer) return;
	DragMoveRestore();
	if (amount<=0) return;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if ( !meshData ) continue;
		Mesh *mesh = meshData->GetMesh(t);
		MeshTempData *tempd = meshData->TempData(t);
		MeshChamferData *mcd = tempd->ChamferData();
		AdjEdgeList *ae = tempd->AdjEList ();

		MeshDelta tmd(*mesh);
		tmd.ChamferMove (*mesh, *mcd, amount, ae);
		DragMove (tmd, meshData);
	}
	nodes.DisposeTemporary();
}

void EditMeshMod::AlignTo (int alignType) {
	// We'll need the viewport or construction plane transform:
	Matrix3 atm;
	ViewExp *vpt = ip->GetActiveViewport();
	if (alignType == ALIGN_CONST) {
		vpt->GetConstructionTM(atm);
	} else {
		vpt->GetAffineTM(atm);
		atm = Inverse(atm);
	}
	ip->ReleaseViewport (vpt);

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts (mcList, nodes);
	ClearMeshDataFlag (mcList, EMD_BEENDONE);

	theHold.Begin ();
	for (int nd=0; nd<mcList.Count(); nd++) {
		EditMeshData *emd = (EditMeshData *) mcList[nd]->localData;
		if (emd->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = emd->GetMesh (ip->GetTime());
		BitArray sel = mesh->VertexTempSel ();
		if (!sel.NumberSet()) continue;

		// Need to find plane equation of alignment plane in object space.
		// if in view align, the exact z-offset of the plane is determined by the points selected.
		Matrix3 otm, res;
		otm = nodes[nd]->GetObjectTM(ip->GetTime());
		res = atm*Inverse(otm);
		Point3 ZNorm(0,0,1), zero(0,0,0);
		zero = res * zero;
		ZNorm = Normalize (VectorTransform (res, ZNorm));
		float zoff;
		if (alignType == ALIGN_VIEW) {
			zoff = 0.0f;
			for (int i=0; i<mesh->numVerts; i++) {
				if (!sel[i]) continue;
				zoff += DotProd (ZNorm, mesh->verts[i]);
			}
			zoff /= (float) sel.NumberSet();
		} else {
			zoff = DotProd (ZNorm, res.GetTrans());
		}

		MeshDelta tmd(*mesh);
		tmd.MoveVertsToPlane (*mesh, sel, ZNorm, zoff);
		emd->ApplyMeshDelta (tmd, this, ip->GetTime());
		emd->SetFlag(EMD_BEENDONE,TRUE);
	}
	theHold.Accept (GetString (IDS_EM_ALIGN));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::MakePlanar() {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());

		MeshDelta tmd(*mesh);
		BitArray tempSel;
		int j, k;
		switch (selLevel) {
		case SL_VERTEX:
			tmd.MakeSelVertsPlanar (*mesh, mesh->vertSel);
			break;

		case SL_EDGE:
			tempSel.SetSize (mesh->numVerts);
			tempSel.ClearAll ();
			for (j=0; j<mesh->numFaces; j++) {
				for (k=0; k<3; k++) if (mesh->edgeSel[j*3+k]) break;
				if (k==3) continue;
				tempSel.Set (mesh->faces[j].v[k]);
				tempSel.Set (mesh->faces[j].v[(k+1)%3]);
				if ((k<2) && (mesh->edgeSel[j*3+(k+1)%3] || mesh->edgeSel[j*3+(k+2)%3]))
					tempSel.Set (mesh->faces[j].v[(k+2)%3]);
			}
			tmd.MakeSelVertsPlanar (*mesh, tempSel);
			break;

		default:
			tmd.MakeSelFacesPlanar (*mesh, mesh->faceSel);
			break;
		}
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept(GetString(IDS_RB_MAKEPLANAR));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::Collapse () {
	if (selLevel == SL_OBJECT) return;
	DWORD sid;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin ();
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());

		MeshDelta tmd(*mesh);
		switch (selLevel) {
		case SL_EDGE:
			sid = IDS_RB_COLLAPSEEDGE;
			tmd.CollapseEdges(*mesh, mesh->edgeSel, meshData->TempData(ip->GetTime())->AdjEList());
			break;
		case SL_VERTEX:
			sid = IDS_RB_COLLAPSE;
			tmd.WeldVertSet (*mesh, mesh->vertSel);
			break;
		default:
			sid = IDS_RB_FACECOLLAPSE;
			tmd.WeldVertSet (*mesh, mesh->VertexTempSel());
			break;
		}
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}
	theHold.Accept(GetString(sid));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::Tessellate (float tens,BOOL edge) {	
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);
	TimeValue t = ip->GetTime();

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(t);
		MeshTempData *tempd = meshData->TempData(t);
		AdjEdgeList *ae = tempd->AdjEList();
		AdjFaceList *af = tempd->AdjFList();

		MeshDelta tmd;
		if (edge) tmd.EdgeTessellate (*mesh, mesh->faceSel, tens, ae, af);
		else tmd.DivideFaces (*mesh, mesh->faceSel);
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());
	
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept (GetString(IDS_RB_TESSELLATE));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::Explode (float thresh,BOOL objs,TSTR &name) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	TimeValue t = ip->GetTime();
	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(t);
		AdjFaceList *af = meshData->TempData(t)->AdjFList ();

		MeshDelta tmd;
		if (!objs) tmd.ExplodeFaces (*mesh, thresh, (selLevel>=SL_FACE), af);
		else {
			theHold.Put (new MeshSelectRestore (meshData, this, SL_FACE));
			ExplodeToObjects (mesh, thresh, nodes[i], name, ip, &tmd, af, selLevel>=SL_FACE);
		}
		meshData->ApplyMeshDelta (tmd, this, t);
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept(GetString(IDS_RB_EXPLODE));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::Slice () {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts (mcList, nodes);
	ClearMeshDataFlag (mcList, EMD_BEENDONE);

	Matrix3 rotMatrix;
	sliceRot.MakeMatrix (rotMatrix);

	theHold.Begin ();
	for (int nd=0; nd<mcList.Count(); nd++) {
		EditMeshData *emd = (EditMeshData *) mcList[nd]->localData;
		if (emd->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = emd->GetMesh (ip->GetTime());

		Matrix3 mcInv = Inverse(*mcList[nd]->tm);
		Point3 N = Normalize (VectorTransform (mcInv, Point3(0.0f,0.0f,1.0f) * rotMatrix));
		float offset = DotProd (N, mcInv*sliceCenter);

		MeshDelta tmd;
		if (selLevel >= SL_FACE) tmd.Slice (*mesh, N, offset, sliceSplit, FALSE, &(mesh->faceSel));
		else tmd.Slice (*mesh, N, offset, sliceSplit);
		emd->ApplyMeshDelta (tmd, this, ip->GetTime());
		emd->SetFlag(EMD_BEENDONE,TRUE);
	}
	theHold.Accept (GetString (IDS_EM_SLICE));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}


BOOL EditMeshMod::WeldVerts (float thresh) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	BOOL found = FALSE;
	TimeValue t = ip->GetTime();
	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh (t);
		if (mesh->vertSel.NumberSet() < 1) continue;

		MeshDelta tmd(*mesh);
		if (tmd.WeldByThreshold (*mesh, mesh->vertSel, thresh)) found = TRUE;
		meshData->ApplyMeshDelta (tmd, this, t);

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept(GetString(IDS_RB_WELDVERTS));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
	return found;
}

void EditMeshMod::WeldVerts (Point3 weldPoint) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);
	TimeValue t = ip->GetTime();

	//theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh (t);
		if (mesh->vertSel.NumberSet() < 1) continue;

		MeshDelta tmd(*mesh);
		tmd.WeldVertSet (*mesh, mesh->vertSel, &weldPoint);
		meshData->ApplyMeshDelta (tmd, this, t);

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	//theHold.Accept(GetString(IDS_RB_WELDVERTS));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::RemoveIsoVerts () {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts (mcList, nodes);
	ClearMeshDataFlag (mcList,EMD_BEENDONE);

	theHold.Begin ();
	for (int nd=0; nd<mcList.Count(); nd++) {
		EditMeshData *emd = (EditMeshData *) mcList[nd]->localData;
		if (!emd) continue;
		if (emd->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = emd->GetMesh (ip->GetTime());

		MeshDelta tmd(*mesh);
		tmd.DeleteIsoVerts (*mesh);
		emd->ApplyMeshDelta (tmd, this, ip->GetTime());

		emd->SetFlag(EMD_BEENDONE,TRUE);
	}
	theHold.Accept (GetString (IDS_EM_DELETE_ISOVERTS));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::SelectOpenEdges () {
	ModContextList list;
	INodeTab nodes;	
	ip->GetModContexts(list,nodes);
	ClearMeshDataFlag (list,EMD_BEENDONE);

	theHold.Begin();
	BitArray nesel;
	for (int i=0; i<list.Count(); i++) {
		EditMeshData *d = (EditMeshData*)list[i]->localData;		
		if (!d) continue;
		if (d->GetFlag (EMD_BEENDONE)) continue;
		Mesh *mesh = d->GetMesh(ip->GetTime());
		mesh->FindOpenEdges (nesel);
		d->SetEdgeSel (nesel, this, ip->GetTime());
	}
	nodes.DisposeTemporary();
	LocalDataChanged ();
	theHold.Accept(GetString (IDS_EM_SELECT_OPEN));
	ip->RedrawViews(ip->GetTime());
}

// Vertex surface operations:

float EditMeshMod::GetWeight (TimeValue t, int *numSel) {
	if (selLevel != SL_VERTEX) return 1.0f;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	float weight = 1.0f;
	int i, j, num = 0;
	for (i=0; i<mcList.Count(); i++) {
		EditMeshData *emd = (EditMeshData*) mcList[i]->localData;
		if (!emd) continue;
		Mesh *mesh = emd->GetMesh (t);
		if (emd->mdelta.vsel.NumberSet () == 0) continue;
		float *vw = mesh->getVertexWeights ();
		if (!vw) {
			if (num && (weight != 1.0f)) weight = -1.0f;
			num += emd->mdelta.vsel.NumberSet();
			continue;
		}
		for (j=0; j<emd->mdelta.vsel.GetSize(); j++) {
			if (!emd->mdelta.vsel[j]) continue;
			if (!num) weight = vw[j];
			else if (weight != vw[j]) weight = -1.0f;
			num++;
		}
	}
	if (numSel) *numSel = num;
	nodes.DisposeTemporary ();
	return weight;
}

void EditMeshMod::UpdateWeightDisplay (TimeValue t, HWND hWnd) {
	if (selLevel != SL_VERTEX) return;
	ISpinnerControl *spin = GetISpinner (GetDlgItem (hWnd, IDC_EM_WEIGHTSPIN));
	if (!spin) return;

	int num;
	float weight = GetWeight (t, &num);

	if (num == 0) {	// Nothing selected
		// Simply disable weight stuff & return
		spin->Disable ();
		EnableWindow (GetDlgItem (hWnd,	IDC_EM_WEIGHT_LABEL), FALSE);
		ReleaseISpinner(spin);
		return;
	}

	spin->Enable ();
	EnableWindow (GetDlgItem (hWnd,	IDC_EM_WEIGHT_LABEL), TRUE);

	// Set the actual weight:
	if (weight<0) {	// Verts don't have the same weight.
		spin->SetIndeterminate (TRUE);
		ReleaseISpinner(spin);
	} else {
		spin->SetIndeterminate(FALSE);
		spin->SetValue (weight, FALSE);
		ReleaseISpinner(spin);
	}
}

void EditMeshMod::SetWeight (TimeValue t, float weight) {
	if (selLevel != SL_VERTEX) return;
	if (weight < MIN_WEIGHT) weight = MIN_WEIGHT;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *emd = (EditMeshData*) mcList[i]->localData;
		if (!emd) continue;
		if (emd->mdelta.vsel.NumberSet() == 0) continue;
		Mesh *mesh = emd->GetMesh (t);

		MeshDelta tmd (*mesh);
		tmd.SetVertWeights (*mesh, emd->mdelta.vsel, weight);
		emd->ApplyMeshDelta (tmd, this, t);
	}
	nodes.DisposeTemporary ();

	NotifyDependents (FOREVER, PART_GEOM, REFMSG_CHANGE);
	ip->RedrawViews (t);
}

void EditMeshMod::ResetWeights (TimeValue t) {
	if (selLevel != SL_VERTEX) return;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *emd = (EditMeshData*) mcList[i]->localData;
		if (!emd) continue;
		Mesh *mesh = emd->GetMesh (t);

		MeshDelta tmd (*mesh);
		tmd.ResetVertWeights (*mesh);
		emd->ApplyMeshDelta (tmd, this, t);
	}
	nodes.DisposeTemporary ();

	NotifyDependents (FOREVER, PART_GEOM, REFMSG_CHANGE);
	ip->RedrawViews (t);
}

Color EditMeshMod::GetVertColor () {
	static Color white(1,1,1), black(0,0,0);
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	Color col(white);
	BOOL init=FALSE;

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		if (!mesh->vertSel.NumberSet()) continue;

		TVFace *cf = mesh->mapFaces(0);
		UVVert *cv = mesh->mapVerts(0);
		if (!cf) {
			if (init) {
				if (col != white) return black;
			} else {
				col = white;
				init = TRUE;
			}
			meshData->SetFlag (EMD_BEENDONE, TRUE);
			continue;
		}

		for (int i=0; i<mesh->getNumFaces(); i++) {
			DWORD *tt = cf[i].t;
			DWORD *vv = mesh->faces[i].v;
			for (int j=0; j<3; j++) {
				if (!mesh->vertSel[vv[j]]) continue;
				if (!init) {
					col = cv[tt[j]];
					init = TRUE;
				} else {
					Color ac = cv[tt[j]];
					if (ac!=col) return black;
				}
			}
		}
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	nodes.DisposeTemporary();
	return col;
}

void EditMeshMod::SetVertColor (Color clr) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		if (!mesh->vertSel.NumberSet()) continue;

		MeshDelta tmd(*mesh);
		tmd.SetVertColors (*mesh, mesh->vertSel, clr);
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::SelectVertByColor (VertColor clr, int deltaR, int deltaG, int deltaB, BOOL add, BOOL sub) {
	float dr = float(deltaR)/255.0f;
	float dg = float(deltaG)/255.0f;
	float db = float(deltaB)/255.0f;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();
	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		TVFace *cf = mesh->mapFaces(0);
		UVVert *cv = mesh->mapVerts(0);
		if ((!cf) || (!cv)) continue;

		BitArray nvs;
		if (add || sub) {
			nvs = mesh->vertSel;
			nvs.SetSize (mesh->numVerts, TRUE);
		} else {
			nvs.SetSize (mesh->numVerts);
			nvs.ClearAll ();
		}

		for (int i=0; i<mesh->getNumFaces(); i++) {
			for (int j=0; j<3; j++) {
				Point3 col = cv[cf[i].t[j]];
				if ((float)fabs(col.x-clr.x) > dr) continue;
				if ((float)fabs(col.y-clr.y) > dg) continue;
				if ((float)fabs(col.z-clr.z) > db) continue;
				if (sub) nvs.Clear (mesh->faces[i].v[j]);
				else nvs.Set (mesh->faces[i].v[j]);
			}
		}
		meshData->SetVertSel (nvs, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}
	nodes.DisposeTemporary ();
	theHold.Accept(GetString(IDS_EM_SELBYCOLOR));
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

// Edge surface operations:

void EditMeshMod::SetEdgeVis(BOOL vis) {
	ModContextList mcList;	
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		AdjFaceList *af = meshData->TempData(ip->GetTime())->AdjFList();

		MeshDelta tmd(*mesh);
		int maxedge = mesh->getNumFaces()*3;
		for (int j=0; j<maxedge; j++) {
			if (mesh->edgeSel[j]) tmd.SetSingleEdgeVis (*mesh, j, vis, af);										
		}
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	if (vis) theHold.Accept (GetString(IDS_RB_EDGEVISIBLE));
	else theHold.Accept (GetString(IDS_RB_EDGEINVISIBLE));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::AutoEdge(float thresh, int type) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());

		AdjEdgeList *ae = meshData->TempData(ip->GetTime())->AdjEList();
		AdjFaceList *af = meshData->TempData(ip->GetTime())->AdjFList();
		Tab<MEdge> &edges = ae->edges;

		MeshDelta tmd(*mesh);
		for (int j=0; j<edges.Count(); j++) {						
			if (!edges[j].Selected(mesh->faces,meshData->mdelta.esel)) continue;
			BOOL vis = (thresh==0.0f) || (mesh->AngleBetweenFaces(edges[j].f[0],edges[j].f[1]) > thresh);
			if ((type == 1) && !vis) continue;
			if ((type == 2) && vis) continue;
			if (edges[j].f[0]!=UNDEFINED) {
				int e = mesh->faces[edges[j].f[0]].GetEdgeIndex (edges[j].v[0],edges[j].v[1]);
				tmd.SetSingleEdgeVis (*mesh, edges[j].f[0]*3+e, vis, af);
				continue;
			}
			MaxAssert (edges[j].f[1]!=UNDEFINED);
			int e = mesh->faces[edges[j].f[1]].GetEdgeIndex(edges[j].v[0],edges[j].v[1]);
			tmd.SetSingleEdgeVis (*mesh, edges[j].f[1]*3+e, vis, af);
		}
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}
	theHold.Accept(GetString(IDS_RB_AUTOEDGE));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

// Face surface operations:

void EditMeshMod::ShowNormals() {
	bool show = ((normScale>0) && (selLevel!=SL_OBJECT)) ? TRUE : FALSE;
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		mesh->displayNormals (show, normScale);
		mesh->buildBoundingBox ();
	}
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::FlipNormals() {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		meshData->BeginEdit(ip->GetTime());
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		if (mesh->faceSel.NumberSet() < 1) continue;

		MeshDelta tmd(*mesh);
		for (int j=0; j<mesh->getNumFaces(); j++) {
			if (!mesh->faceSel[j]) continue;
			tmd.FlipNormal (*mesh, j);
		}
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept(GetString(IDS_RB_FLIPNORMALS));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::UnifyNormals() {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);	

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		AdjFaceList *af = meshData->TempData(ip->GetTime())->AdjFList();

		MeshDelta tmd(*mesh);
		tmd.UnifyNormals (*mesh, mesh->faceSel, af);
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);		
	}
	
	theHold.Accept(GetString(IDS_RB_UNIFYNORMALS));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

DWORD EditMeshMod::GetMatIndex() {
	ModContextList mcList;	
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	DWORD mat=UNDEFINED;
	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		
		for (int j=0; j<mesh->getNumFaces(); j++) {
			if (!mesh->faceSel[j]) continue;
			if (mat==UNDEFINED) mat = mesh->getFaceMtlIndex(j);
			else if (mesh->getFaceMtlIndex(j) != mat) {
				nodes.DisposeTemporary ();
				return UNDEFINED;
			}
		}
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	nodes.DisposeTemporary();
	return mat;
}

// Note: good reasons for handling theHold.Begin/Accept at higher level.
void EditMeshMod::SetMatIndex(DWORD index) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);	

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());		

		MeshDelta tmd(*mesh);
		for (int j=0; j<mesh->getNumFaces(); j++) {			
			if (mesh->faceSel[j]) tmd.SetMatID (j, MtlID(index));
		}
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime ());

		meshData->SetFlag(EMD_BEENDONE,TRUE);		
	}
	
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::SelectByMat (DWORD index,BOOL clear) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);
	
	theHold.Begin();
	BitArray ns;

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());		

		if (clear) {
			ns.SetSize (mesh->numFaces);
			ns.ClearAll ();
		} else {
			ns = mesh->faceSel;
			if (ns.GetSize() != mesh->numFaces) ns.SetSize (mesh->numFaces, TRUE);
		}
		for (int j=0; j<mesh->getNumFaces(); j++) {			
			if (mesh->getFaceMtlIndex(j)==index) ns.Set(j);
		}
		meshData->SetFaceSel (ns, this, ip->GetTime());
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}
		
	theHold.Accept(GetString(IDS_RB_SELECTBYMATID));
	nodes.DisposeTemporary();
	LocalDataChanged ();
	ip->RedrawViews(ip->GetTime());
}

DWORD EditMeshMod::GetUsedSmoothBits () {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	DWORD bits = 0;

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		meshData->BeginEdit(ip->GetTime());
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		for (int j=0; j<mesh->getNumFaces(); j++)
			bits |= mesh->faces[j].smGroup;
	}
	nodes.DisposeTemporary();
	return bits;
}

// Those bits used by ANY selected faces are set in "some".
// Those bits used by ALL selected faces are set in the return value.
DWORD EditMeshMod::GetSelSmoothBits(DWORD &some) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	DWORD all = ~0;
	some = 0;
	bool someFaceSel=FALSE;

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		meshData->BeginEdit(ip->GetTime());
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		if (!mesh->faceSel.NumberSet()) continue;
		someFaceSel = TRUE;
		for (int j=0; j<mesh->getNumFaces(); j++) {
			if (!mesh->faceSel[j]) continue;
			some |= mesh->faces[j].smGroup;
			all &= mesh->faces[j].smGroup;
		}
	}
	nodes.DisposeTemporary();
	if (!someFaceSel) return 0;
	return all;
}

void EditMeshMod::SetSelSmoothBits(DWORD bits,DWORD mask) {
	ModContextList mcList;	
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	theHold.Begin();
	bits &= mask;

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		if (mesh->faceSel.NumberSet() < 1) continue;

		MeshDelta tmd (*mesh);
		for (int j=0; j<mesh->getNumFaces(); j++) {
			if (!mesh->faceSel[j]) continue;
			tmd.FSmooth (j, mask, bits);
		}
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept(GetString(IDS_RB_SETSMOOTHGROUP));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::SelectBySmoothGroup (DWORD bits,BOOL clear) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);
	
	theHold.Begin();
	BitArray nfs;

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		meshData->BeginEdit(ip->GetTime());
		Mesh *mesh = meshData->GetMesh(ip->GetTime());		
		
		if (clear) {
			nfs.SetSize (mesh->getNumFaces());
			nfs.ClearAll();
		} else {
			nfs = mesh->faceSel;
			nfs.SetSize (mesh->getNumFaces(), TRUE);
		}
		for (int j=0; j<mesh->getNumFaces(); j++) {			
			if (mesh->faces[j].smGroup & bits) nfs.Set(j);
		}

		meshData->SetFaceSel (nfs, this, ip->GetTime());
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}
		
	theHold.Accept(GetString(IDS_RB_SELECTBYSMOOTH));
	nodes.DisposeTemporary();
	LocalDataChanged();
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::AutoSmooth(float thresh) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);	

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		if (mesh->faceSel.NumberSet() < 1) continue;

		AdjFaceList *af = meshData->TempData(ip->GetTime())->AdjFList();
		AdjEdgeList *ae = meshData->TempData(ip->GetTime())->AdjEList();

		MeshDelta tmd(*mesh);
		tmd.AutoSmooth (*mesh, mesh->faceSel, thresh, af, ae);
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());

		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	theHold.Accept(GetString(IDS_RB_AUTOSMOOTH));
	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

Color EditMeshMod::GetFaceColor () {
	static Color white(1,1,1), black(0,0,0);
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	Color col = white;
	BOOL init=FALSE;

	for (int i = 0; i < mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh(ip->GetTime());
		if (!mesh->faceSel.NumberSet()) continue;

		TVFace *cf=mesh->mapFaces(0);
		UVVert *cv=mesh->mapVerts(0);
		if (!cf) {
			if (init) {
				if (col != white) break;
			} else {
				col = white;
				init = TRUE;
			}
			meshData->SetFlag (EMD_BEENDONE, TRUE);
			continue;
		}

		for (int i=0; i<mesh->getNumFaces(); i++) {
			if (!mesh->faceSel[i]) continue;
			DWORD *tt = cf[i].t;
			for (int j=0; j<3; j++) {
				if (!init) {
					col = cv[tt[j]];
					init = TRUE;
				} else {
					Color ac = cv[tt[j]];
					if (ac!=col) break;
				}
			}
			if (j<3) break;
		}
		if (i<mesh->numFaces) break;
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}
	nodes.DisposeTemporary();
	return (i<mcList.Count()) ? black : col;
}

void EditMeshMod::SetFaceColor(Color clr) {
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	ClearMeshDataFlag(mcList,EMD_BEENDONE);

	for (int i=0; i<mcList.Count(); i++) {
		EditMeshData *meshData = (EditMeshData*)mcList[i]->localData;
		if (!meshData) continue;
		if (meshData->GetFlag(EMD_BEENDONE)) continue;
		Mesh *mesh = meshData->GetMesh (ip->GetTime());
		if (!mesh->faceSel.NumberSet()) continue;

		MeshDelta tmd(*mesh);
		tmd.SetFaceColors (*mesh, mesh->faceSel, clr);
		meshData->ApplyMeshDelta (tmd, this, ip->GetTime());
		meshData->SetFlag(EMD_BEENDONE,TRUE);
	}

	nodes.DisposeTemporary();
	ip->RedrawViews(ip->GetTime());
}

//----Globals----------------------------------------------
// Move to class Interface or someplace someday?

void ExplodeToObjects (Mesh *mesh, float thresh, INode *node, TSTR &name,
					   IObjParam *ip, MeshDelta *tmd, AdjFaceList *af, BOOL selOnly) {
	FaceClusterList fc(mesh, *af, thresh, selOnly);
	if (!selOnly || (mesh->faceSel.NumberSet() == mesh->numFaces)) {
		if (fc.count==1) return;	// nothing to do -- all in one cluster.
		if (!selOnly) mesh->faceSel.SetAll();
		for (int i=0; i<mesh->numFaces; i++) if (fc[i] == fc.count-1) mesh->faceSel.Clear (i);
		fc.count--;
	}

	// For speed, make face-lists for each cluster:
	int j,k, mp;
	DWORD i;
	DWORDTab *flist = new DWORDTab[fc.count];
	for (i=0; i<(DWORD)mesh->numFaces; i++) {
		if (!mesh->faceSel[i]) continue;
		flist[fc[i]].Append (1, &i, 10);
	}

	// Make used, lookup arrays big enough to hold verts or any mapping vert set.
	int vsize = mesh->numVerts;
	for (mp=0; mp<mesh->getNumMaps(); mp++) {
		if (!mesh->mapSupport(mp)) continue;
		if (mesh->getNumMapVerts (mp) > vsize) vsize = mesh->getNumMapVerts(mp);
	}
	BitArray usedVerts;
	usedVerts.SetSize (vsize);
	DWORD *vlut = new DWORD[vsize];

	// Transfer all clusters to new meshes.
	for (i=0; i<fc.count; i++) {
		if (flist[i].Count() < 1) continue;	// shouldn't happen.

		usedVerts.ClearAll();
		for (j=0; j<flist[i].Count(); j++) {
			DWORD *vv = mesh->faces[flist[i][j]].v;
			usedVerts.Set (vv[0]);
			usedVerts.Set (vv[1]);
			usedVerts.Set (vv[2]);
		}

		TriObject *newObj = CreateNewTriObject();
		Mesh *newMesh = &newObj->GetMesh();
		newMesh->setNumVerts(usedVerts.NumberSet());
		newMesh->setNumFaces(flist[i].Count());
		for (j=0,k=0; j<mesh->numVerts; j++) {
			if (!usedVerts[j]) continue;
			newMesh->verts[k] = mesh->verts[j];
			vlut[j] = k++;
		}
		for (j=0; j<flist[i].Count(); j++) {
			Face & f = mesh->faces[flist[i][j]];
			newMesh->faces[j] = f;
			for (k=0; k<3; k++) newMesh->faces[j].v[k] = vlut[f.v[k]];
		}

		// Handle mapping.
		newMesh->setNumMaps (mesh->getNumMaps ());
		for (mp=0; mp<mesh->getNumMaps(); mp++) {
			if (!mesh->mapSupport(mp)) {
				newMesh->setMapSupport (mp, FALSE);
				continue;
			}
			newMesh->setMapSupport (mp, TRUE);

			TVFace *mapf = mesh->mapFaces(mp);
			UVVert *mapv = mesh->mapVerts(mp);
			TVFace *nmapf = newMesh->mapFaces(mp);
			usedVerts.ClearAll ();
			for (j=0; j<flist[i].Count(); j++) {
				DWORD *vv = mapf[flist[i][j]].t;
				usedVerts.Set (vv[0]);
				usedVerts.Set (vv[1]);
				usedVerts.Set (vv[2]);
			}

			newMesh->setNumMapVerts (mp, usedVerts.NumberSet());
			for (j=0,k=0; j<mesh->getNumMapVerts(mp); j++) {
				if (!usedVerts[j]) continue;
				newMesh->setMapVert (mp, k, mapv[j]);
				vlut[j] = k++;
			}
			for (j=0; j<flist[i].Count(); j++) {
				TVFace & f = mapf[flist[i][j]];
				nmapf[j] = f;
				for (k=0; k<3; k++) nmapf[j].t[k] = vlut[f.t[k]];
			}
		}

		INode *nd = ip->CreateObjectNode(newObj);
		Matrix3 ntm = node->GetNodeTM(ip->GetTime());
		TSTR uname = name;
		ip->MakeNameUnique(uname);
		nd->SetName(uname);
		nd->SetNodeTM (ip->GetTime(), ntm);
		nd->FlagForeground (ip->GetTime(), FALSE);
		nd->SetMtl (node->GetMtl());
		nd->SetObjOffsetPos (node->GetObjOffsetPos());
		nd->SetObjOffsetRot (node->GetObjOffsetRot());
		nd->SetObjOffsetScale (node->GetObjOffsetScale());
	}
	delete [] vlut;
	delete [] flist;

	// Finally, set up meshdelta to delete components from this mesh.
	tmd->ClearAllOps ();
	tmd->InitToMesh (*mesh);
	BitArray vdel;
	mesh->FindVertsUsedOnlyByFaces (mesh->faceSel, vdel);
	tmd->FDelete (mesh->faceSel);
	tmd->VDelete (vdel);
}

BOOL CreateCurveFromMeshEdges (Mesh & mesh, INode *onode, Interface *ip, AdjEdgeList *ae,
							   TSTR & name, BOOL curved, BOOL ignoreHiddenEdges) {
	if (!mesh.edgeSel.NumberSet()) return FALSE;

	SuspendAnimate();
	AnimateOff();	

	SplineShape *shape = (SplineShape*)GetSplineShapeDescriptor()->Create(0);	

	BitArray done;
	done.SetSize(ae->edges.Count());

	// Mark hidden edges as done to ignore them
	if (ignoreHiddenEdges) {
		for (int i=0; i<ae->edges.Count(); i++) {
			if (!ae->edges[i].Visible(mesh.faces)) done.Set(i);
		}
	}

	for (int i=0; i<ae->edges.Count(); i++) {
		if (done[i]) continue;
		if (!ae->edges[i].Selected (mesh.faces,mesh.edgeSel)) continue;
			
		// The array of points for the spline
		Tab<Point3> pts;
		
		// Add the first two points.
		pts.Append(1,&mesh.verts[ae->edges[i].v[0]],10);
		pts.Append(1,&mesh.verts[ae->edges[i].v[1]],10);
		int nextv = ae->edges[i].v[1], start = ae->edges[i].v[0];
		
		// Mark this edge as done
		done.Set(i);

		// Trace along selected edges
		while (1) {
			DWORDTab &ve = ae->list[nextv];
			for (int j=0; j<ve.Count(); j++) {
				if (done[ve[j]]) continue;
				if (ae->edges[ve[j]].Selected(mesh.faces,mesh.edgeSel)) break;
			}
			if (j==ve.Count()) break;
			if (ae->edges[ve[j]].v[0]==(DWORD)nextv) nextv = (int)ae->edges[ve[j]].v[1];
			else nextv = ae->edges[ve[j]].v[0];

			// Mark this edge as done
			done.Set(ve[j]);

			// Add this vertex to the list
			pts.Append(1,&mesh.verts[nextv],10);
		}
		int lastV = nextv;

		// Now trace backwards
		nextv = start;
		while (1) {
			DWORDTab &ve = ae->list[nextv];
			for (int j=0; j<ve.Count(); j++) {
				if (done[ve[j]]) continue;
				if (ae->edges[ve[j]].Selected(mesh.faces,mesh.edgeSel)) break;
			}
			if (j==ve.Count()) break;
			if (ae->edges[ve[j]].v[0]==(DWORD)nextv) nextv = (int)ae->edges[ve[j]].v[1];
			else nextv = ae->edges[ve[j]].v[0];

			// Mark this edge as done
			done.Set(ve[j]);

			// Add this vertex to the list
			pts.Insert(0,1,&mesh.verts[nextv]);
		}
		int firstV = nextv;

		// Now weve got all th points. Create the spline and add points
		Spline3D *spline = new Spline3D(KTYPE_AUTO,KTYPE_BEZIER);
		int max = pts.Count();
		if (firstV == lastV) {
			max--;
			spline->SetClosed ();
		}
		if (curved) {
			for (int j=0; j<max; j++) {
				int prvv = j ? j-1 : ((firstV==lastV) ? max-1 : 0);
				int nxtv = (max-1-j) ? j+1 : ((firstV==lastV) ? 0 : max-1);
				float prev_length = Length(pts[j] - pts[prvv])/3.0f;
				float next_length = Length(pts[j] - pts[nxtv])/3.0f;
				Point3 tangent = Normalize (pts[nxtv] - pts[prvv]);
				SplineKnot sn (KTYPE_BEZIER, LTYPE_CURVE, pts[j],
						pts[j] - prev_length*tangent, pts[j] + next_length*tangent);
				spline->AddKnot(sn);
			}
		} else {
			for (int j=0; j<max; j++) {
				SplineKnot sn(KTYPE_CORNER, LTYPE_LINE, pts[j],pts[j],pts[j]);
				spline->AddKnot(sn);
			}
			spline->ComputeBezPoints();
		}
		shape->shape.AddSpline(spline);
	}

	shape->shape.InvalidateGeomCache();
	shape->shape.UpdateSels();

	INode *node = ip->CreateObjectNode (shape);
	INode *nodeByName = ip->GetINodeByName (name);
	if (nodeByName != node) {
		if (nodeByName) ip->MakeNameUnique(name);
		node->SetName (name);
	}
	Matrix3 ntm = onode->GetNodeTM(ip->GetTime());
	node->SetNodeTM (ip->GetTime(),ntm);
	node->FlagForeground (ip->GetTime(),FALSE);
	node->SetMtl (onode->GetMtl());
	node->SetObjOffsetPos (onode->GetObjOffsetPos());
	node->SetObjOffsetRot (onode->GetObjOffsetRot());
	node->SetObjOffsetScale (onode->GetObjOffsetScale());	
	ResumeAnimate();
	ip->RedrawViews(ip->GetTime());
	return TRUE;
}

/*------------Command modes & Mouse procs----------------------*/

HitRecord *PickEdgeMouseProc::HitTestEdges (IPoint2 &m, ViewExp *vpt, float *prop, Point3 *snapPoint) {
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),HITTYPE_POINT,0, 0, &m, vpt);
	if (!vpt->NumSubObjHits()) return NULL;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *hr = hitLog.ClosestHit();
	if (!hr) return hr;
	if (!prop) return hr;

	// Find where along this edge we hit
	// Strategy:
	// Get Mouse click, plus viewport z-direction at mouse click, in object space.
	// Then find the direction of the edge in a plane orthogonal to z, and see how far
	// along that edge we are.

	EditMeshData *meshData = (EditMeshData*)hr->modContext->localData;
	DWORD ee = hr->hitInfo;

	Ray r;
	vpt->MapScreenToWorldRay ((float)m.x, (float)m.y, r);
	Point3 Zdir = Normalize (r.dir);
	if (!snapPoint) snapPoint = &(r.p);

	Mesh *mm = meshData->GetMesh (ip->GetTime());
	Matrix3 obj2world = hr->nodeRef->GetObjectTM (ip->GetTime ());
	Point3 A = obj2world * mm->verts[mm->faces[ee/3].v[ee%3]];
	Point3 B = obj2world * mm->verts[mm->faces[ee/3].v[(ee+1)%3]];
	Point3 Xdir = B-A;
	Xdir -= DotProd(Xdir, Zdir)*Zdir;
	*prop = DotProd (Xdir, *snapPoint-A) / LengthSquared (Xdir);
	if (*prop<.0001f) *prop=0;
	if (*prop>.9999f) *prop=1;
	return hr;
}

int PickEdgeMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {
	ViewExp *vpt;
	HitRecord *hr;
	float prop;
	Point3 snapPoint;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		ip->SetActiveViewport(hwnd);
		vpt = ip->GetViewport(hwnd);
		snapPoint = vpt->SnapPoint(m,m,NULL);
		snapPoint = vpt->MapCPToWorld (snapPoint);
		hr = HitTestEdges (m, vpt, &prop, &snapPoint);
		if (vpt) ip->ReleaseViewport(vpt);
		if (hr) {
			EditMeshData *meshData = (EditMeshData*)hr->modContext->localData;
			EdgePick (meshData, hr->hitInfo, prop);
		}
		break;
		
	case MOUSE_MOVE:
	case MOUSE_FREEMOVE:
		vpt = ip->GetViewport(hwnd);
		vpt->SnapPreview (m, m, NULL, SNAP_FORCE_3D_RESULT);//|SNAP_SEL_OBJS_ONLY);
		if (HitTestEdges(m,vpt,NULL,NULL)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(LoadCursor(NULL,IDC_ARROW));
		if (vpt) ip->ReleaseViewport(vpt);
		break;
	}

	return TRUE;	
}

// --------------------------------------------------------

HitRecord *PickFaceMouseProc::HitTestFaces (IPoint2 &m, ViewExp *vpt, float *bary, Point3 *snapPoint) {
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),HITTYPE_POINT,0, 0, &m, vpt);
	if (!vpt->NumSubObjHits()) return NULL;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *hr = hitLog.ClosestHit();
	if (!hr) return hr;
	if (!bary) return hr;

	// Find barycentric coordinates of hit in face.
	// Strategy:
	// Get Mouse click, plus viewport z-direction at mouse click, in object space.
	// Then find face coords in a plane orthogonal to z, and compare hit to points.

	EditMeshData *meshData = (EditMeshData*)hr->modContext->localData;
	DWORD ff = hr->hitInfo;
	Matrix3 obj2world = hr->nodeRef->GetObjectTM (ip->GetTime ());

	Ray r;
	vpt->MapScreenToWorldRay ((float)m.x, (float)m.y, r);
	Point3 Zdir = Normalize (r.dir);
	if (!snapPoint) snapPoint = &(r.p);

	Mesh *mm = meshData->GetMesh (ip->GetTime());
	Point3 A = obj2world * mm->verts[mm->faces[ff].v[0]];
	Point3 B = obj2world * mm->verts[mm->faces[ff].v[1]];
	Point3 C = obj2world * mm->verts[mm->faces[ff].v[2]];
	Point3 Xdir = B-A;
	Xdir = Normalize (Xdir - DotProd(Xdir, Zdir)*Zdir);
	Point3 Ydir = Zdir^Xdir;	// orthonormal basis
	bary[2] = DotProd (*snapPoint-A, Ydir) / DotProd (C-A, Ydir);
	if (bary[2] < .0001f) bary[2] = 0.f;
	if (bary[2] > .9999f) {
		bary[2] = 1.0f;
		bary[0] = bary[1] = 0.0f;
		return hr;
	}
	A += bary[2] * (C-A);
	B += bary[2] * (C-B);
	bary[1] = DotProd (Xdir, *snapPoint-A) / DotProd (Xdir, B-A);
	bary[1] *= (1.0f-bary[2]);
	if (bary[1] < .0001f) bary[1] = 0.f;
	if (bary[1] > .9999f) bary[1] = 1.f;
	if (bary[1] + bary[2] > .9999f) {
		float prop = 1.0f / (bary[1] + bary[2]);
		bary[1] *= prop;
		bary[2] *= prop;
		bary[0] = 0.0f;
		return hr;
	}
	bary[0] = 1.0f - bary[1] - bary[2];
	return hr;
}

int PickFaceMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m) {
	ViewExp *vpt = ip->GetViewport(hwnd);
	HitRecord *hr;
	float bary[3];
	Point3 snapPoint;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		ip->SetActiveViewport(hwnd);
		vpt = ip->GetViewport(hwnd);
		snapPoint = vpt->SnapPoint(m, m, NULL);
		snapPoint = vpt->MapCPToWorld (snapPoint);
		hr = HitTestFaces(m,vpt,bary, &snapPoint);
		if (vpt) ip->ReleaseViewport(vpt);
		if (hr) {
			EditMeshData *meshData = (EditMeshData *) hr->modContext->localData;
			FacePick (meshData, hr->hitInfo, bary);
		}
		break;
	
	case MOUSE_MOVE:
	case MOUSE_FREEMOVE:
		vpt = ip->GetViewport(hwnd);
		vpt->SnapPreview (m, m, NULL, SNAP_FORCE_3D_RESULT);//|SNAP_SEL_OBJS_ONLY);
		if (HitTestFaces(m,vpt,NULL,NULL)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(LoadCursor(NULL,IDC_ARROW));
		if (vpt) ip->ReleaseViewport(vpt);
		break;
	}

	return TRUE;
}

// -------------------------------------------------------

void CreateVertCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_CREATE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void CreateVertCMode::ExitMode() {
	if ( !em->hGeom ) return;
	em->EndExtrude(em->ip->GetTime(),TRUE);
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_CREATE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// following cursor used both here and in CreateFaceMouseProc
static HCURSOR hCurCreateVerts = NULL;
int CreateVertMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {
	if (!hCurCreateVerts) hCurCreateVerts = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_ADDVERTCUR));

	ViewExp *vpt;

	Matrix3 ctm;
	Point3 pt;
	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		ip->SetActiveViewport(hwnd);
		vpt = ip->GetViewport(hwnd);
		vpt->GetConstructionTM(ctm);
		pt = vpt->SnapPoint(m,m,&ctm);
		if (vpt) ip->ReleaseViewport(vpt);
		pt = pt * ctm;
		em->CreateVertex(pt);
		break;
	
	case MOUSE_FREEMOVE:
		SetCursor(hCurCreateVerts);
		vpt = ip->GetViewport(hwnd);
		vpt->SnapPreview(m,m,NULL, SNAP_FORCE_3D_RESULT);
		if (vpt) ip->ReleaseViewport(vpt);
		break;
	}

	return TRUE;
}

//----------------------------------------------------------

void CreateFaceCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_CREATE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
	em->inBuildFace = TRUE;
	em->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	em->ip->RedrawViews(em->ip->GetTime());
}

void CreateFaceCMode::ExitMode() {
	if (!em->hGeom ) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_CREATE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
	em->inBuildFace = FALSE;
	em->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	em->ip->RedrawViews(em->ip->GetTime());
}

CreateFaceMouseProc::CreateFaceMouseProc(EditMeshMod* mod, IObjParam *i) {
	em = mod;
	ip = i;
	meshData = NULL;
	pt = 0;
}

BOOL CreateFaceMouseProc::HitTestVerts(IPoint2 m, ViewExp *vpt, int &v) {
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),HITTYPE_POINT,0, 0, &m, vpt);
	if (!vpt->NumSubObjHits()) return FALSE;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *hr = hitLog.ClosestHit();
	MaxAssert(hr);
	if ((meshData != hr->modContext->localData) && (meshData != NULL)) return FALSE;
	if (em->selLevel != SL_POLY) {
		for (int i=0; i<pt; i++) if (vts[i]==(int)hr->hitInfo) return FALSE;
	}
	v = hr->hitInfo;
	return TRUE;
}
		
// We assume the transform, color, render style, etc, has been set up in advance.
void CreateFaceMouseProc::DrawEstablishedFace (GraphicsWindow *gw) {
	if (pt<2) return;
	if (!meshData) return;
	Mesh *mesh = meshData->GetMesh (ip->GetTime());
	Tab<Point3> rverts;
	rverts.SetCount (pt+1);
	for (int j=0; j<pt; j++) {
		rverts[j] = mesh->verts[vts[j]];
	}
	gw->polyline (pt, rverts.Addr(0), NULL, NULL, FALSE, NULL);
}

void CreateFaceMouseProc::DrawCreatingFace (HWND hWnd, const IPoint2 & m) {
	if (!pt) return;
	HDC hdc = GetDC(hWnd);
	SetROP2(hdc, R2_XORPEN);
	SetBkMode(hdc, TRANSPARENT);
	SelectObject(hdc,CreatePen(PS_DOT, 0, RGB(255,255,255)));

	MoveToEx (hdc, mfirst.x, mfirst.y, NULL);
	LineTo (hdc, m.x, m.y);
	if (pt>1) LineTo(hdc, mlast.x, mlast.y);

	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
	ReleaseDC(hWnd, hdc);
}

int CreateFaceMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {
	if (!hCurCreateVerts) hCurCreateVerts = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_ADDVERTCUR));

	ViewExp *vpt = ip->GetViewport(hwnd);
	ModContextList mcList;	
	INodeTab nodes;
	int dummyVert;
	int nv, lpt;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (point==1) break;
		ip->SetActiveViewport(hwnd);
		bool done;
		done=FALSE;

		if (HitTestVerts (m, vpt, nv)) {
			HitLog& hitLog = vpt->GetSubObjHitList();
			HitRecord *hr = hitLog.ClosestHit();
			MaxAssert(hr);
			for (int j=0; j<pt; j++) if (vts[j] == nv) break;
			if (!meshData) {
				// The first point
				meshData = (EditMeshData*)hr->modContext->localData;
				nref = hr->nodeRef;
			}
			if (j<pt) done = TRUE;
			else {
				vts.Append (1, &nv, 20);
				if (pt==0) mfirst = m;
				else mlast = m;
				pt++;
				em->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
				ip->RedrawViews (ip->GetTime());
				oldm = m;
				DrawCreatingFace(hwnd, m);
			}
		} else {
			if (!(flags & MOUSE_SHIFT)) {
				ip->ReleaseViewport(vpt);
				if (!pt) return FALSE;
				else return TRUE;
			}
			Matrix3 ctm;
			vpt->GetConstructionTM (ctm);
			Point3 newpt = vpt->SnapPoint (m, m, &ctm, SNAP_FORCE_3D_RESULT|SNAP_SEL_SUBOBJ_ONLY);
			newpt = newpt * ctm;
			if (!meshData) {
				// The first point
				ip->GetModContexts (mcList, nodes);
				meshData = (EditMeshData *) mcList[0]->localData;
				nref = nodes[0];
			}
			nv = meshData->GetMesh(ip->GetTime())->numVerts;
			vts.Append (1, &nv, 20);
			if (pt==0) mfirst = m;
			else mlast = m;
			pt++;
			em->CreateVertex (newpt, meshData, nref);
			oldm = m;
			DrawCreatingFace(hwnd, m);
		}

		if ((em->selLevel != SL_POLY) && (pt==3)) done = TRUE;

		if (done) {
			// We're done collecting verts - build a face
			lpt = pt;
			pt = 0;	// so the redraw gets that we're done.
			if ((lpt>2) && !em->CreateFace (meshData, vts.Addr(0), lpt)) {
				InvalidateRect(vpt->getGW()->getHWnd(),NULL,FALSE);
				TSTR buf1 = GetString(IDS_RB_DUPFACEWARNING);
				TSTR buf2 = GetString(IDS_RB_EDITMESHTITLE);
				MessageBox (ip->GetMAXHWnd(), buf1, buf2, MB_OK|MB_ICONINFORMATION);
				em->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
				ip->RedrawViews (ip->GetTime());
			}
			vts.SetCount(0);
			meshData = NULL;
			ip->ReleaseViewport (vpt);
			return FALSE;
		}
		break;

	case MOUSE_MOVE:
		if (pt) DrawCreatingFace (hwnd, oldm);	// Erase old outline
		if (HitTestVerts(m,vpt,dummyVert))
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else {
			if (flags & MOUSE_SHIFT) {
				SetCursor (hCurCreateVerts);
				vpt->SnapPreview (m, m, NULL, SNAP_FORCE_3D_RESULT);
				ip->RedrawViews (ip->GetTime());
			} else SetCursor(ip->GetSysCursor (SYSCUR_DEFARROW));
		}
		if (pt) {
			oldm = m;
			DrawCreatingFace (hwnd, oldm);
		}
		break;

	case MOUSE_FREEMOVE:
		if (HitTestVerts(m,vpt,dummyVert))
			SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else {
			if (flags & MOUSE_SHIFT) {
				SetCursor (hCurCreateVerts);
				vpt->SnapPreview (m, m, NULL, SNAP_FORCE_3D_RESULT);
			} else SetCursor(ip->GetSysCursor (SYSCUR_DEFARROW));
		}
		break;

	case MOUSE_ABORT:
		pt = 0;
		vts.SetCount(0);
		meshData = NULL;
		em->NotifyDependents (FOREVER, PART_DISPLAY, REFMSG_CHANGE);
		ip->RedrawViews (ip->GetTime());
		break;
	}

	ip->ReleaseViewport(vpt);
	return TRUE;
}

/*-----------------------------------------------------------------------*/

BOOL AttachPickMode::Filter(INode *node) {
	if (!node) return FALSE;

	// Make sure the node does not depend on us
	node->BeginDependencyTest();
	em->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) return FALSE;

	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
	if (os.obj->IsSubClassOf(triObjectClassID)) return TRUE;
	if (os.obj->CanConvertToType(triObjectClassID)) return TRUE;
	return FALSE;
}

BOOL AttachPickMode::HitTest (IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags) {
	return ip->PickNode(hWnd, m, this) ? TRUE : FALSE;
}

BOOL AttachPickMode::Pick(IObjParam *ip,ViewExp *vpt) {
	INode *node = vpt->GetClosestHit();
	if (!Filter(node)) return FALSE;

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);
	// (We always attach to node 0.)

	BOOL ret = TRUE;
	if (nodes[0]->GetMtl() && node->GetMtl() && (nodes[0]->GetMtl()!=node->GetMtl())) {
		ret = DoAttachMatOptionDialog (ip, em);
	}
	nodes.DisposeTemporary ();
	if (!ip) return FALSE;
	if (!ret) return FALSE;

	bool canUndo = TRUE;
	em->Attach (node, canUndo);
	if (!canUndo) GetSystemSetting (SYSSET_CLEAR_UNDO);
	ip->RedrawViews(ip->GetTime());
	return FALSE;
}

void AttachPickMode::EnterMode(IObjParam *ip) {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_OBJ_ATTACH));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void AttachPickMode::ExitMode(IObjParam *ip) {
	if ( !em->hGeom ) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_OBJ_ATTACH));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// -----------------------------

int MAttachHitByName::filter(INode *node) {
	if (!node) return FALSE;

	// Make sure the node does not depend on this modifier.
	node->BeginDependencyTest();
	em->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) return FALSE;

	ObjectState os = node->GetObjectRef()->Eval(em->ip->GetTime());
	if (os.obj->IsSubClassOf(triObjectClassID)) return TRUE;
	if (os.obj->CanConvertToType(triObjectClassID)) return TRUE;
	return FALSE;
}

void MAttachHitByName::proc(INodeTab &nodeTab) {
	if (inProc) return;
	inProc = TRUE;
	ModContextList mcList;
	INodeTab nodes;
	em->ip->GetModContexts (mcList, nodes);
	BOOL ret = TRUE;
	if (nodes[0]->GetMtl()) {
		for (int i=0; i<nodeTab.Count(); i++) {
			if (nodeTab[i]->GetMtl() && (nodes[0]->GetMtl()!=nodeTab[i]->GetMtl())) break;
		}
		if (i<nodeTab.Count()) ret = DoAttachMatOptionDialog (em->ip, em);
	}
	nodes.DisposeTemporary ();
	inProc = FALSE;
	if (!ret) return;
	if (!em->ip) return;
	em->MultiAttach (nodeTab);
}

//----------------------------------------------------------

void DivideEdgeProc::EdgePick(EditMeshData *meshData, DWORD edge, float prop) {
	Mesh *mesh = meshData->GetMesh(ip->GetTime());
	theHold.Begin ();
	MeshDelta tmd;
	tmd.DivideEdge (*mesh, edge, prop, meshData->TempData(ip->GetTime())->AdjEList());
	meshData->ApplyMeshDelta (tmd, em, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_EDGEDIVIDE));

	ip->RedrawViews(ip->GetTime());	
}

void DivideEdgeCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_DIVIDE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void DivideEdgeCMode::ExitMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_DIVIDE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

//----------------------------------------------------------

void DivideFaceProc::FacePick (EditMeshData *meshData, DWORD ff, float *bary) {
	Mesh *mesh = meshData->GetMesh(ip->GetTime());
	theHold.Begin ();
	MeshDelta tmd;
	tmd.DivideFace (*mesh, ff, bary);
	meshData->ApplyMeshDelta (tmd, em, ip->GetTime());
	theHold.Accept(GetString(IDS_EM_FACE_DIVIDE));
	ip->RedrawViews(ip->GetTime());	
}

void DivideFaceCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom, IDC_EM_DIVIDE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void DivideFaceCMode::ExitMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom, IDC_EM_DIVIDE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// ------------------------------------------------------------------

void TurnEdgeProc::EdgePick(EditMeshData *meshData,DWORD edge, float prop) {
	Mesh *mesh = meshData->GetMesh(ip->GetTime());

	theHold.Begin ();
	MeshDelta tmd(*mesh);
	tmd.TurnEdge (*mesh, edge);
	meshData->ApplyMeshDelta (tmd, em, ip->GetTime());
	theHold.Accept(GetString(IDS_RB_EDGETURN));

	ip->RedrawViews(ip->GetTime());
}

void TurnEdgeCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_TURN));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void TurnEdgeCMode::ExitMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_TURN));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// ------------------------------------------------------

int ExtrudeMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m) {	
	ViewExp *vpt = ip->GetViewport(hwnd);
	Point3 p0, p1;
	ISpinnerControl *spin;
	float amount;
	IPoint2 m2;

	switch ( msg ) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (!point) {
			em->BeginExtrude(ip->GetTime());
			om = m;
		} else {
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			em->EndExtrude(ip->GetTime(),TRUE);
		}
		break;

	case MOUSE_MOVE:
		p0 = vpt->MapScreenToView(om,float(-200));
		m2.x = om.x;
		m2.y = m.y;
		p1 = vpt->MapScreenToView (m2, float(-200));
		amount = Length (p1-p0);
		if (m.y > om.y) amount *= -1.0f;
		em->Extrude (ip->GetTime(), amount);

		spin = GetISpinner(GetDlgItem(em->hGeom,IDC_EM_EXTRUDESPINNER));
		if (spin) {
			spin->SetValue (amount, FALSE);
			ReleaseISpinner(spin);
		}

		ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
		break;

	case MOUSE_ABORT:
		em->EndExtrude(ip->GetTime(),FALSE);			
		ip->RedrawViews(ip->GetTime(),REDRAW_END);
		break;		
	}
	
	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

HCURSOR ExtrudeSelectionProcessor::GetTransformCursor() { 
	static HCURSOR hCur = NULL;
	if ( !hCur ) hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_EXTRUDECUR));
	return hCur;
}

void ExtrudeCMode::EnterMode() {
	if (!em->hGeom ) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_EXTRUDE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void ExtrudeCMode::ExitMode() {
	if (!em->hGeom ) return;
	em->EndExtrude(em->ip->GetTime(),TRUE);
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_EXTRUDE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// ------------------------------------------------------

int BevelMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {	
	ViewExp *vpt=ip->GetViewport (hwnd);
	Point3 p0, p1;
	ISpinnerControl *spin;
	float amount;
	IPoint2 m2;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		switch (point) {
		case 0:
			m0 = m;
			m0set = TRUE;
			em->BeginBevel (ip->GetTime(), TRUE);
			break;
		case 1:
			m1 = m;
			m1set = TRUE;
			p0 = vpt->MapScreenToView (m0, float(-200));
			m2.x = m0.x;
			m2.y = m.y;
			p1 = vpt->MapScreenToView (m2, float(-200));
			height = Length (p0-p1);
			if (m.y > m0.y) height *= -1.0f;
			em->Bevel (ip->GetTime(), 0, height);
			spin = GetISpinner(GetDlgItem(em->hGeom,IDC_EM_EXTRUDESPINNER));
			if (spin) {
				spin->SetValue (height, FALSE);
				ReleaseISpinner (spin);
			}
			break;
		case 2:
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			em->EndBevel(ip->GetTime(),TRUE);
			m1set = m0set = FALSE;
			if (vpt) ip->ReleaseViewport(vpt);
			return FALSE;
		}
		break;

	case MOUSE_MOVE:
		if (!m0set) break;
		m2.y = m.y;
		if (!m1set) {
			p0 = vpt->MapScreenToView (m0, float(-200));
			m2.x = m0.x;
			p1 = vpt->MapScreenToView (m2, float(-200));
			amount = Length (p1-p0);
			if (m.y > m0.y) amount *= -1.0f;
			em->Bevel (ip->GetTime(), 0, amount);
			spin = GetISpinner(GetDlgItem(em->hGeom,IDC_EM_EXTRUDESPINNER));
		} else {
			p0 = vpt->MapScreenToView (m1, float(-200));
			m2.x = m1.x;
			p1 = vpt->MapScreenToView (m2, float(-200));
			amount = Length (p1-p0);
			if (m.y > m1.y) amount *= -1.0f;
			em->Bevel (ip->GetTime(), amount, height);
			spin = GetISpinner(GetDlgItem(em->hGeom,IDC_EM_OUTLINESPINNER));
		}
		if (spin) {
			spin->SetValue (amount, FALSE);
			ReleaseISpinner(spin);
		}

		ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
		break;

	case MOUSE_ABORT:
		em->EndBevel(ip->GetTime(),FALSE);		
		ip->RedrawViews(ip->GetTime(),REDRAW_END);
		m1set = m0set = FALSE;
		break;
	}

	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

HCURSOR BevelSelectionProcessor::GetTransformCursor() { 
	static HCURSOR hCur = NULL;
	if ( !hCur ) hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_BEVEL));
	return hCur;
}

void BevelCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_BEVEL));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void BevelCMode::ExitMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_BEVEL));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// ------------------------------------------------------

int ChamferMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {	
	ViewExp *vpt=ip->GetViewport (hwnd);
	Point3 p0, p1;
	ISpinnerControl *spin;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (!point) {
			em->BeginChamfer (ip->GetTime());		
			om = m;
		} else {
			ip->RedrawViews (ip->GetTime(),REDRAW_END);
			em->EndChamfer (ip->GetTime(),TRUE);
		}
		break;

	case MOUSE_MOVE:
		p0 = vpt->MapScreenToView(om,float(-200));
		p1 = vpt->MapScreenToView(m,float(-200));
		em->Chamfer (ip->GetTime(), Length(p1-p0));

		spin = GetISpinner(GetDlgItem(em->hGeom,IDC_EM_OUTLINESPINNER));
		if (spin) {
			spin->SetValue(Length(p1-p0),FALSE);
			ReleaseISpinner(spin);
		}

		ip->RedrawViews (ip->GetTime(), REDRAW_INTERACTIVE);
		break;

	case MOUSE_ABORT:
		em->EndChamfer (ip->GetTime(),FALSE);			
		ip->RedrawViews (ip->GetTime(),REDRAW_END);
		break;
	}

	if (vpt) ip->ReleaseViewport(vpt);
	return TRUE;
}

HCURSOR ChamferSelectionProcessor::GetTransformCursor() { 
	static HCURSOR hECur = NULL;
	static HCURSOR hVCur = NULL;
	if (em->selLevel == SL_VERTEX) {
		if ( !hVCur ) hVCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_VCHAMFERCUR));
		return hVCur;
	}
	if ( !hECur ) hECur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_ECHAMFERCUR));
	return hECur;
}

void ChamferCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_BEVEL));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void ChamferCMode::ExitMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_BEVEL));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

// --- Slice: not really a command mode, just looks like it.--------- //

// Each time we enter the slice mode, we reset the slice plane.
// It should encompass all nodes.
void EditMeshMod::EnterSliceMode () {
	sliceMode = TRUE;
	if (hGeom) {
		ICustButton *but = GetICustButton (GetDlgItem(hGeom,IDC_EM_SLICE));
		but->Enable ();
		ReleaseICustButton (but);
		EnableWindow (GetDlgItem (hGeom, IDC_EM_REFINE), FALSE);
		but = GetICustButton (GetDlgItem (hGeom, IDC_EM_SLICEPLANE));
		but->SetCheck (TRUE);
		ReleaseICustButton (but);
	}

	ModContextList mcList;
	INodeTab inodes;
	ip->GetModContexts (mcList, inodes);
	Box3 *bbox = mcList[0]->box;
	sliceCenter = (bbox->pmin + bbox->pmax) * .5f;
	sliceRot.Identity();
	Point3 boxDiff = bbox->pmax - bbox->pmin;
	sliceSize = (boxDiff.x > boxDiff.y) ? boxDiff.x : boxDiff.y;
	sliceSize *= .52f;
	if (sliceSize<1.0f) sliceSize = 1.0f;

	if (ip->GetCommandMode()->ID() >= CID_USER) ip->SetStdCommandMode (CID_OBJMOVE);
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
}

void EditMeshMod::ExitSliceMode () {
	sliceMode = FALSE;
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	if (hGeom) {
		ICustButton *but = GetICustButton (GetDlgItem(hGeom,IDC_EM_SLICE));
		but->Disable ();
		ReleaseICustButton (but);
		if (selLevel >= SL_EDGE) EnableWindow (GetDlgItem (hGeom, IDC_EM_REFINE), TRUE);
		but = GetICustButton (GetDlgItem (hGeom, IDC_EM_SLICEPLANE));
		but->SetCheck (FALSE);
		ReleaseICustButton (but);
	}
	ip->RedrawViews(ip->GetTime());
}

// -- Cut Edge proc/mode -------------------------------------

class CutAbandon : public RestoreObj {
public:
	EditMeshMod *mod;

	CutAbandon (EditMeshMod *m) { mod = m; }
	void Restore(int isUndo) { if (mod->cutEdgeMode) mod->cutEdgeMode->AbandonCut(); }
	void Redo() { if (mod->cutEdgeMode) mod->cutEdgeMode->AbandonCut (); }
	int Size() { return sizeof(void *); }
	TSTR Description() { return TSTR(_T("Edit Mesh Cut Abandon")); }
};

HitRecord *CutEdgeProc::HitTestEdges (IPoint2 &m, ViewExp *vpt) {
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(), HITTYPE_POINT, 0, 0, &m, vpt);
	if (!vpt->NumSubObjHits()) return NULL;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *ret;

	if (!e1set) {
		ret = hitLog.ClosestHit();
		mc = ret->modContext;
		return ret;
	}

	for (ret=hitLog.First(); ret != NULL; ret=ret->Next())
		if (ret->modContext == mc) break;
	if (ret==NULL) return NULL;
	DWORD best = ret->distance;
	HitRecord *iter;
	for (iter=ret; iter!=NULL; iter=iter->Next()) {
		if (iter->modContext != mc) continue;
		if (iter->distance < best) {
			ret = iter;
			best = ret->distance;
		}
	}
	if (e1 == (int)ret->hitInfo) return NULL;
	return ret;
}

void CutEdgeProc::DrawCutter (HWND hWnd,IPoint2 &m) {
	HDC hdc = GetDC(hWnd);
	SetROP2(hdc, R2_XORPEN);
	SetBkMode(hdc, TRANSPARENT);	
	SelectObject(hdc,CreatePen(PS_DOT, 0, RGB(255,255,255)));
	MoveToEx(hdc,m1.x,m1.y,NULL);
	LineTo(hdc,m.x,m.y);
	DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));
	ReleaseDC(hWnd, hdc);
}

int CutEdgeProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m) {
	ViewExp *vpt;
	HitRecord *hr;
	AdjEdgeList *ae;
	MeshDelta tmd;
	IPoint2 betterM;
	Point3 A, B, snapPoint, Zdir, Xdir;
	Matrix3 obj2world, world2obj;
	float prop;
	Ray r;

	EditMeshData *meshData;
	Mesh *mesh;
	TimeValue t = ip->GetTime();

	switch (msg) {
	case MOUSE_ABORT:
		// Erase last cutter line:
		if (e1set) DrawCutter (hwnd, oldm2);
		e1set = FALSE;
		return FALSE;

	case MOUSE_PROPCLICK:
		// Erase last cutter line:
		if (e1set) DrawCutter (hwnd, oldm2);
		ip->SetStdCommandMode(CID_OBJMOVE);
		return FALSE;

	case MOUSE_DBLCLICK:
		if (!e1set) break;
		// Erase last cutter line:
		DrawCutter (hwnd, oldm2);

		theHold.Begin ();
		meshData = (EditMeshData *) mc->localData;
		mesh = meshData->GetMesh(t);
		ae = meshData->TempData(t)->AdjEList();
		tmd.DivideEdge (*mesh, e1, prop1, ae, FALSE, em->cutRefine,
			FALSE, em->sliceSplit);
		meshData->ApplyMeshDelta (tmd, em, t);
		theHold.Accept (GetString (IDS_EM_CUT));
		ip->RedrawViews(ip->GetTime());
		e1set = FALSE;
		return FALSE;

	case MOUSE_POINT:
		if (point==1) break;
		ip->SetActiveViewport(hwnd);
		vpt = ip->GetViewport (hwnd);
		hr = HitTestEdges(m,vpt);
		if (!hr) {
			ip->ReleaseViewport(vpt);
			break;
		}

		DWORD ee;
		ee = hr->hitInfo;

		// Find where along this edge we hit
		// Strategy:
		// Get Mouse click, plus viewport z-direction at mouse click, in object space.
		// Then find the direction of the edge in a plane orthogonal to z, and see how far
		// along that edge we are.
		snapPoint = vpt->SnapPoint(m,betterM,NULL);
		snapPoint = vpt->MapCPToWorld (snapPoint);
		obj2world = hr->nodeRef->GetObjectTM (t);

		t = ip->GetTime();
		meshData = (EditMeshData *) mc->localData;
		mesh = meshData->GetMesh(t);

		vpt->MapScreenToWorldRay ((float)betterM.x, (float)betterM.y, r);
		Zdir = Normalize (r.dir);
		A = obj2world * mesh->verts[mesh->faces[ee/3].v[ee%3]];
		B = obj2world * mesh->verts[mesh->faces[ee/3].v[(ee+1)%3]];
		Xdir = B-A;
		Xdir -= DotProd(Xdir, Zdir)*Zdir;
		prop = DotProd (Xdir, snapPoint-A) / LengthSquared (Xdir);
		if (prop<.0001f) prop=0;
		if (prop>.9999f) prop=1;

		ip->ReleaseViewport(vpt);

		if (!e1set) {
			e1 = hr->hitInfo;
			prop1 = prop;
			e1set = TRUE;
			m1 = betterM;
			DrawCutter (hwnd, m);
			oldm2=m;
			break;
		}

		// Erase last cutter line:
		DrawCutter (hwnd, oldm2);

		// Do the cut:
		theHold.Begin ();
		world2obj = Inverse (obj2world);
		Zdir = VectorTransform (world2obj, Zdir);
		e1 = tmd.Cut (*mesh, e1, prop1, ee, prop, -Zdir, em->cutRefine, em->sliceSplit);
		meshData->ApplyMeshDelta (tmd, em, t);
		theHold.Put (new CutAbandon(em));
		theHold.Accept (GetString (IDS_EM_CUT));
		ip->RedrawViews(ip->GetTime());

		if (e1==UNDEFINED) {
			e1set = FALSE;
			return FALSE;
		} else {
			prop1=0.0f;
			m1 = betterM;
			DrawCutter (hwnd, m);
			oldm2 = m;
		}
		break;

	case MOUSE_MOVE:
		vpt = ip->GetViewport (hwnd);
		vpt->SnapPoint(m,m,NULL);
		if (e1set) {
			DrawCutter (hwnd,oldm2);
			oldm2 = m;
		}
		if (HitTestEdges(m,vpt)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(LoadCursor(NULL,IDC_ARROW));
		ip->ReleaseViewport(vpt);
		ip->RedrawViews(ip->GetTime());
		if (e1set) DrawCutter (hwnd, oldm2);
		break;

	case MOUSE_FREEMOVE:
		vpt = ip->GetViewport (hwnd);
		vpt->SnapPreview(m,m,NULL);//, SNAP_SEL_OBJS_ONLY);
		if (HitTestEdges(m,vpt)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(LoadCursor(NULL,IDC_ARROW));
		ip->ReleaseViewport(vpt);
		break;
	}

	return TRUE;	
}

void CutEdgeCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_CUT));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
	proc.e1set = FALSE;
	em->inCutEdge = TRUE;
}

void CutEdgeCMode::ExitMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_CUT));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
	em->inCutEdge = FALSE;
}

void CutEdgeCMode::AbandonCut () {
	proc.e1set = FALSE;
}

/*-------------------------------------------------------------------*/

void WeldVertCMode::EnterMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_WELDTOVERT));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);
}

void WeldVertCMode::ExitMode() {
	if (!em->hGeom) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hGeom,IDC_EM_WELDTOVERT));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);
}

BOOL WeldVertMouseProc::HitTestVerts (IPoint2 &m, ViewExp *vpt, int &v) {
	vpt->ClearSubObjHitList();
	em->pickBoxSize = em->weldBoxSize;
	ip->SubObHitTest(ip->GetTime(),HITTYPE_POINT,0, HIT_UNSELONLY, &m, vpt);
	em->pickBoxSize = DEF_PICKBOX_SIZE;
	if (!vpt->NumSubObjHits()) return FALSE;
	HitLog& hitLog = vpt->GetSubObjHitList();
	HitRecord *hr = hitLog.ClosestHit();
	MaxAssert(hr);
	v = hr->hitInfo;
	return TRUE;
}

void WeldVertMouseProc::PostTransformHolding () {
	TransformModBox::PostTransformHolding();
	if (targetVert < 0) return;
	Mesh *mesh = emd->GetMesh(ip->GetTime());
	Point3 pt = mesh->verts[targetVert];

	// Select the point that was hit
	BitArray vsel = emd->GetVertSel ();
	vsel.Set (targetVert);
	emd->SetVertSel (vsel, em, ip->GetTime());

	// Do the weld
	em->WeldVerts (pt);
}

int WeldVertMouseProc::proc (HWND hwnd, int msg, int point, int flags, IPoint2 m ) {
	ViewExp *vpt = ip->GetViewport(hwnd);
	int res = TRUE;

	switch (msg) {
	case MOUSE_PROPCLICK:
		ip->SetStdCommandMode(CID_OBJMOVE);
		break;

	case MOUSE_POINT:
		if (point==1) {
			if (!HitTestVerts(m,vpt,targetVert)) {
				targetVert = -1;
				break;
			}
			// Get the hit record
			HitLog& hitLog = vpt->GetSubObjHitList();
			HitRecord *hr = hitLog.ClosestHit();
			MaxAssert(hr);
			// Find the point on the mesh that was hit
			emd = (EditMeshData*)hr->modContext->localData;
		}
		break;

	case MOUSE_MOVE:
		int vert;
		if (HitTestVerts(m,vpt,vert)) SetCursor(ip->GetSysCursor(SYSCUR_SELECT));
		else SetCursor(ip->GetSysCursor(SYSCUR_MOVE));
		break;
	}
	
	if (vpt) ip->ReleaseViewport(vpt);
	return MoveModBox::proc(hwnd,msg,point,flags,m);	
}

HCURSOR WeldVertSelectionProcessor::GetTransformCursor() { 	
	return ip->GetSysCursor(SYSCUR_MOVE); 
}

//----------------------------------------------------------

void FlipNormProc::FacePick (EditMeshData *meshData, DWORD face, float *bary) {
	Mesh *mesh = meshData->GetMesh(ip->GetTime());
	theHold.Begin ();
	MeshDelta tmd(*mesh);
	if (em->selLevel <= SL_FACE) {
		tmd.FlipNormal (*mesh, face);
	} else {
		BitArray flip;
		flip.SetSize (tmd.fnum);
		flip.ClearAll ();
		AdjFaceList *af = meshData->TempData(ip->GetTime())->AdjFList();
		if (em->selLevel == SL_POLY) {
			mesh->PolyFromFace (face, flip, em->GetPolyFaceThresh(), em->ignoreVisEdge, af);
		} else {
			mesh->ElementFromFace (face, flip, af);
		}
		for (DWORD i=0; i<tmd.fnum; i++) if (flip[i]) tmd.FlipNormal (*mesh, i);
	}
	meshData->ApplyMeshDelta (tmd, em, ip->GetTime());
	theHold.Accept(GetString(IDS_EM_FLIP_NORMAL));
	ip->RedrawViews(ip->GetTime());	
}

void FlipNormCMode::EnterMode() {
	if (!em->hSurf) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hSurf, IDC_EM_NORMAL_FLIPMODE));
	but->SetCheck(TRUE);
	ReleaseICustButton(but);	
}

void FlipNormCMode::ExitMode() {
	if (!em->hSurf) return;
	ICustButton *but = GetICustButton(GetDlgItem(em->hSurf, IDC_EM_NORMAL_FLIPMODE));
	but->SetCheck(FALSE);
	ReleaseICustButton(but);		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editsops.cpp ===
/**********************************************************************
 *<
	FILE: editsops.cpp

	DESCRIPTION:  Edit BezierShape OSM operations

	CREATED BY: Tom Hudson & Rolf Berteig

	HISTORY: created 25 April, 1995

 *>	Copyright (c) 1995, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "editspl.h"
#include "evrouter.h"

extern CoreExport Class_ID splineShapeClassID; 

// in mods.cpp
extern HINSTANCE hInstance;

/*-------------------------------------------------------------------*/

static void XORDottedLine( HWND hwnd, IPoint2 p0, IPoint2 p1 )
	{
	HDC hdc;
	hdc = GetDC( hwnd );
	SetROP2( hdc, R2_XORPEN );
	SetBkMode( hdc, TRANSPARENT );
	SelectObject( hdc, CreatePen( PS_DOT, 0, RGB(255,255,255) ) );
	MoveToEx( hdc, p0.x, p0.y, NULL );
	LineTo( hdc, p1.x, p1.y );		
	DeleteObject( SelectObject( hdc, GetStockObject( BLACK_PEN ) ) );
	ReleaseDC( hwnd, hdc );
	}

/*-------------------------------------------------------------------*/

ESTempData::~ESTempData()
	{
	if (shape) delete shape;
	}

ESTempData::ESTempData(EditSplineMod *m,EditSplineData *sd)
	{
	shape = NULL;
	shapeValid.SetEmpty();
	shapeData = sd;
	mod = m;
	}

void ESTempData::Invalidate(DWORD part,BOOL shapeValid)
	{
	if ( !shapeValid ) {
		delete shape;
		shape = NULL;
		}
	if ( part & PART_TOPO ) {
		}
	if ( part & PART_GEOM ) {
		}
	if ( part & PART_SELECT ) {
		}
	}

BezierShape *ESTempData::GetShape(TimeValue t)
	{
	if ( shapeValid.InInterval(t) && shape ) {
		return shape;
	} else {
		shapeData->SetFlag(ESD_UPDATING_CACHE,TRUE);
		mod->NotifyDependents(Interval(t,t), 
			PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|
			PART_DISPLAY|PART_TOPO,    REFMSG_MOD_EVAL);
		shapeData->SetFlag(ESD_UPDATING_CACHE,FALSE);
		return shape;
		}
	}

BOOL ESTempData::ShapeCached(TimeValue t)
	{
	return (shapeValid.InInterval(t) && shape);
	}

void ESTempData::UpdateCache(SplineShape *splShape)
	{
	if ( shape ) delete shape;
	shape = new BezierShape(splShape->shape);

	shapeValid = FOREVER;
	
	// These are the channels we care about.
	shapeValid &= splShape->ChannelValidity(0,GEOM_CHAN_NUM);
	shapeValid &= splShape->ChannelValidity(0,TOPO_CHAN_NUM);
	shapeValid &= splShape->ChannelValidity(0,SELECT_CHAN_NUM);
	shapeValid &= splShape->ChannelValidity(0,SUBSEL_TYPE_CHAN_NUM);
	shapeValid &= splShape->ChannelValidity(0,DISP_ATTRIB_CHAN_NUM);	
	}

HCURSOR OutlineSelectionProcessor::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_OUTLINECUR)); 
		}

	return hCur; 
	}

/*-------------------------------------------------------------------*/

HCURSOR FilletSelectionProcessor::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_FILLETCUR)); 
		}

	return hCur; 
	}

/*-------------------------------------------------------------------*/

HCURSOR ESChamferSelectionProcessor::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_CHAMFERCUR)); 
		}

	return hCur; 
	}

/*-------------------------------------------------------------------*/

HCURSOR SegBreakMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_SEGBREAKCUR)); 
		}

	return hCur; 
	}

BOOL SegBreakMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}

int SegBreakMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;

	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			if(HitTest(vpt,&m,HITTYPE_POINT,0) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				HitRecord *bestRec = rec;
				DWORD best = rec->distance;
				while(rec) {
					rec = rec->Next();
					if(rec) {
						if(rec->distance < best) {
							best = rec->distance;
							bestRec = rec;
							}
						}
					}
				ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
				es->DoSegBreak(vpt, hit->shape, hit->poly, hit->index, m);
				}
			res = FALSE;
			break;
		
		case MOUSE_FREEMOVE:
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
				SetCursor(GetTransformCursor());
				}
			else {
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				}
			break;
			
		}

	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

HCURSOR SegRefineMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_SEGREFINECUR)); 
		}

	return hCur; 
	}

BOOL SegRefineMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	SetSplineHitOverride(ES_SEGMENT);
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	ClearSplineHitOverride();
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}

int SegRefineMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;

	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			if(HitTest(vpt,&m,HITTYPE_POINT,0) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				HitRecord *bestRec = rec;
				DWORD best = rec->distance;
				while(rec) {
					rec = rec->Next();
					if(rec) {
						if(rec->distance < best) {
							best = rec->distance;
							bestRec = rec;
							}
						}
					}
				ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
				es->DoSegRefine(vpt, hit->shape, hit->poly, hit->index, m);
				}
			res = FALSE;
			break;
		
		case MOUSE_FREEMOVE:
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
				SetCursor(GetTransformCursor());
				}
			else {
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				}
			break;
			
		}

	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

HCURSOR CrossInsertMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_CROSSINSERTCUR)); 
		}

	return hCur; 
	}

BOOL CrossInsertMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	SetSplineHitOverride(SS_SPLINE);
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	ClearSplineHitOverride();
	// Make sure that there are exactly two hits and they are on different polygons of
	// the same shape
	if ( vpt->NumSubObjHits() == 2 ) {
		HitLog &hits = vpt->GetSubObjHitList();
		HitRecord *rec = hits.First();
		ShapeHitData *h1 = (ShapeHitData *)rec->hitData;
		rec = rec->Next();
		assert(rec);
		ShapeHitData *h2 = (ShapeHitData *)rec->hitData;
		if((h1->shape == h2->shape) && (h1->poly != h2->poly))
			return TRUE;
		}
	return FALSE;			
	}

int CrossInsertMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;

	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			if(HitTest(vpt,&m,HITTYPE_POINT,0) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				ShapeHitData *h1 = (ShapeHitData *)rec->hitData;
				rec = rec->Next();
				assert(rec);
				ShapeHitData *h2 = (ShapeHitData *)rec->hitData;
				assert(h1->shape == h2->shape);
				es->DoCrossInsert(vpt, h1->shape, h1->poly, h1->index, h2->poly, h2->index, m);
				}
			res = FALSE;
			break;
		
		case MOUSE_FREEMOVE:
			if ( HitTest(vpt,&m,HITTYPE_POINT,0) ) {
				SetCursor(GetTransformCursor());
				}
			else {
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				}
			break;
			
		}

	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

HCURSOR VertConnectMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_VERTCONNECTCUR)); 
		}

	return hCur; 
	}

BOOL VertConnectMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}

BOOL VertConnectMouseProc::HitAnEndpoint(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
	BezierShape **shapeOut, int *polyOut, int *vertOut) {
	int first = 1;
	
	if(HitTest(vpt, p, HITTYPE_POINT, 0) ) {
		HitLog &hits = vpt->GetSubObjHitList();
		HitRecord *rec = hits.First();
		DWORD best = 9999;
		HitRecord *bestRec;
		while(rec) {
			ShapeHitData *hit = ((ShapeHitData *)rec->hitData);
			// If there's an exclusion shape, this must be a part of it!
			if(!shape || shape == hit->shape) {
				// If there's an exclusion shape, the vert & poly can't be the same!
				if(!shape || (shape && !(poly == hit->poly && vert == hit->index))) {
					Spline3D *spline = hit->shape->splines[hit->poly];
					if(!spline->Closed()) {
						int hitKnot = hit->index / 3;
						if(hitKnot == 0 || hitKnot == (spline->KnotCount() - 1)) {
							if(first || rec->distance < best) {
								first = 0;
								best = rec->distance;
								bestRec = rec;
								}
							}
						}
					}
				}
			rec = rec->Next();
			}
		if(!first) {
			ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
			if(shapeOut)
				*shapeOut = hit->shape;
			if(polyOut)
				*polyOut = hit->poly;
			if(vertOut)
				*vertOut = hit->index;
			return TRUE;
			}
		}
	return FALSE;
	}

int VertConnectMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;
	static BezierShape *shape1 = NULL;
	static int poly1, vert1, poly2, vert2;
	static IPoint2 anchor, lastPoint;

	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			switch(point) {
				case 0:
					if(HitAnEndpoint(vpt, &m, NULL, -1, -1, &shape1, &poly1, &vert1))
						res = TRUE;
					else
						res = FALSE;
					anchor = lastPoint = m;
					XORDottedLine(hwnd, anchor, m);	// Draw it!
					break;
				case 1:
					XORDottedLine(hwnd, anchor, lastPoint);	// Erase it!
					if(HitAnEndpoint(vpt, &m, shape1, poly1, vert1, NULL, &poly2, &vert2))
						es->DoVertConnect(vpt, shape1, poly1, vert1, poly2, vert2); 
					res = FALSE;
					break;
				default:
					assert(0);
				}
			break;

		case MOUSE_MOVE:
			// Erase old dotted line
			XORDottedLine(hwnd, anchor, lastPoint);
			// Draw new dotted line
			XORDottedLine(hwnd, anchor, m);
			lastPoint = m;

			if(HitAnEndpoint(vpt, &m, shape1, poly1, vert1, NULL, NULL, NULL))
				SetCursor(GetTransformCursor());
			else
				SetCursor(LoadCursor(NULL,IDC_ARROW));

			break;
					
		case MOUSE_FREEMOVE:
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				ShapeHitData *hit = ((ShapeHitData *)rec->hitData);
				Spline3D *spline = hit->shape->splines[hit->poly];
				if(!spline->Closed()) {
					int hitKnot = hit->index / 3;
					if(hitKnot == 0 || hitKnot == (spline->KnotCount() - 1)) {
						SetCursor(LoadCursor(hInstance,MAKEINTRESOURCE(IDC_TH_SELCURSOR)));
						break;
						}
					}
				}
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			break;
		
		case MOUSE_ABORT:
			// Erase old dotted line
			XORDottedLine(hwnd, anchor, lastPoint);
			break;			
		}

	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

HCURSOR VertInsertMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_VERTINSERTCUR)); 
		}

	return hCur; 
	}

BOOL VertInsertMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags, int hitType )
	{
	vpt->ClearSubObjHitList();
	SetSplineHitOverride(hitType);
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	ClearSplineHitOverride();
	if ( vpt->NumSubObjHits() )
		return TRUE;
	return FALSE;
	}

// Determine where we'll be inserting.  If they clicked on an endpoint, fill in 'vertOut'.
// If they clicked on a segment, fill in 'segOut'.

BOOL VertInsertMouseProc::InsertWhere(ViewExp *vpt, IPoint2 *p, BezierShape **shapeOut, int *polyOut,
		int *segOut, int *vertOut) {
	int first = 1;

	// Reset these!
	*segOut = -1;
	*vertOut = -1;

	// Only valid insertion vertices are endpoints of the spline
	if(HitTest(vpt, p, HITTYPE_POINT, 0, ES_VERTEX) ) {
		HitLog &hits = vpt->GetSubObjHitList();
		HitRecord *rec = hits.First();
		DWORD best = 9999;
		HitRecord *bestRec;
		while(rec) {
			ShapeHitData *hit = ((ShapeHitData *)rec->hitData);
			int hitKnot = hit->index / 3;
			Spline3D *spline = hit->shape->splines[hit->poly];
			if(!spline->Closed() && (hitKnot == 0 || hitKnot == (spline->KnotCount() - 1))) {
				if(first || rec->distance < best) {
					first = 0;
					best = rec->distance;
					bestRec = rec;
					}
				}
			rec = rec->Next();
			}
		if(!first) {
			ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
			if(shapeOut)
				*shapeOut = hit->shape;
			if(polyOut)
				*polyOut = hit->poly;
			if(vertOut)
				*vertOut = hit->index;
			return TRUE;
			}
		}

	// No hits on endpoints, so let's try segments!
	if(HitTest(vpt, p, HITTYPE_POINT, 0, ES_SEGMENT) ) {
		HitLog &hits = vpt->GetSubObjHitList();
		HitRecord *rec = hits.First();
		DWORD best = 9999;
		HitRecord *bestRec;
		while(rec) {
			ShapeHitData *hit = ((ShapeHitData *)rec->hitData);
			if(first || rec->distance < best) {
				first = 0;
				best = rec->distance;
				bestRec = rec;
				}
			rec = rec->Next();
			}
		if(!first) {
			ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
			if(shapeOut)
				*shapeOut = hit->shape;
			if(polyOut)
				*polyOut = hit->poly;
			if(segOut)
				*segOut = hit->index;
			return TRUE;
			}
		}

	return FALSE;
	}

class ESIBackspaceUser : public EventUser {
	Spline3D *spline;
	EditSplineMod *mod;

	public:
		void Notify();
		void SetPtrs(EditSplineMod *m,Spline3D *s) { mod = m; spline = s; }
	};

void ESIBackspaceUser::Notify() {
	if(spline->KnotCount() > 2) {
		// Tell the spline we just backspaced to remove the last point
		spline->Create(NULL, -1, 0, 0, IPoint2(0,0), NULL);
		mod->insertShapeData->Invalidate(PART_GEOM);
		mod->NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
		mod->ip->RedrawViews(mod->ip->GetTime(), REDRAW_NORMAL);
		}
	}

static ESIBackspaceUser iBack;

int VertInsertMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;
	static int poly, seg, vert;
	static BezierShape *shape;
	static int inserting = FALSE;
	static Matrix3 mat;
	static EditSplineMod *mod;

	static int originalInsert;

	if(inserting) {
		// Ignore the messages the spline code doesn't care about... TH 3/12/99
		switch(msg) {
#ifdef DESIGN_VER
			case MOUSE_DBLCLICK:
#endif
			case MOUSE_POINT:
				{
				for (int i = 0; i < shape->bindList.Count();i++)
					{
					if (poly == shape->bindList[i].segSplineIndex)  
						{
						if ((seg!=-1)&&(originalInsert <= shape->bindList[i].seg))
							{
							if (originalInsert == shape->bindList[i].seg)
								{
									{
									shape->bindList[i].seg++;
									}
								}
							else
								{
								shape->bindList[i].seg++;

								}
							}
						}
					}
				}
			case MOUSE_MOVE:
			case MOUSE_ABORT:
				break;
			default:
				return TRUE;
			}
		int res = shape->splines[poly]->Create(vpt,msg,point,flags,m,&mat,ip);
		
		// Must update the shape's selection set for this spline
		BitArray& vsel = shape->vertSel[poly];
		BitArray& ssel = shape->segSel[poly];
		while(vsel.GetSize() < shape->splines[poly]->Verts()) {
			vsel.SetSize(vsel.GetSize() + 3,1);
			vsel.Shift(RIGHT_BITSHIFT,3,vert+3);
			vsel.Clear(vert+2);
			vsel.Clear(vert+3);
			vsel.Clear(vert+4);
			}
		while(ssel.GetSize() < shape->splines[poly]->Segments()) {
			ssel.SetSize(ssel.GetSize() + 1,1);
			ssel.Shift(RIGHT_BITSHIFT,1,vert/3+1);
			ssel.Clear(vert/3+1);
			}
			
		switch(res) {
			case CREATE_STOP: {
				// Must update the shape's selection set for this spline
				BitArray& vsel = shape->vertSel[poly];
				BitArray& ssel = shape->segSel[poly];
				while(vsel.GetSize() > shape->splines[poly]->Verts()) {
					vsel.Shift(LEFT_BITSHIFT,3,vert+1);
					vsel.SetSize(vsel.GetSize() - 3,1);
					}
				while(ssel.GetSize() > shape->splines[poly]->Segments()) {
					ssel.Shift(LEFT_BITSHIFT,1,(vert+1)/3);
					ssel.SetSize(ssel.GetSize() - 1,1);
					}
				es->EndVertInsert();
				inserting = FALSE;
				backspaceRouter.UnRegister(&iBack);
				for (int i = 0; i < shape->bindList.Count();i++)
					{
					if (poly == shape->bindList[i].segSplineIndex)  
						{
						if ((seg!=-1)&&(originalInsert <= shape->bindList[i].seg))
							{
							if (originalInsert == shape->bindList[i].seg)
								{
									{
									shape->bindList[i].seg--;
									}
								}
							else
								{
								shape->bindList[i].seg--;

								}
							}
						}
					}


				break;
				}
			case CREATE_ABORT:
				shape->DeleteSpline(poly);
				es->insertPoly = -1;
				es->EndVertInsert();
				inserting = FALSE;
				backspaceRouter.UnRegister(&iBack);
				break;
			}	
		mod->insertShapeData->Invalidate(PART_GEOM);
		mod->NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime(), REDRAW_NORMAL);
		}
	else {
		switch(msg)	{
			case MOUSE_PROPCLICK:
				ip->SetStdCommandMode(CID_OBJMOVE);
				break;

			case MOUSE_POINT:
				if(InsertWhere(vpt, &m, &shape, &poly, &seg, &vert)) {
					vert = es->StartVertInsert(vpt, shape, poly, seg, vert, &mod);
					if(vert < 0) {
						res = FALSE;
						break;
						}
					originalInsert = seg;
					mat = mod->insertTM;
					shape->splines[poly]->StartInsert(vpt, msg, point, flags, m, &mat, vert/3+1 );
					// Must update the shape's selection set for this spline
					BitArray& vsel = shape->vertSel[poly];
					BitArray& ssel = shape->segSel[poly];
					while(vsel.GetSize() < shape->splines[poly]->Verts()) {
						vsel.SetSize(vsel.GetSize() + 3,1);
						vsel.Shift(RIGHT_BITSHIFT,3,vert+3);
						vsel.Clear(vert+2);
						vsel.Clear(vert+3);
						vsel.Clear(vert+4);
						}
					while(ssel.GetSize() < shape->splines[poly]->Segments()) {
						ssel.SetSize(ssel.GetSize() + 1,1);
						ssel.Shift(RIGHT_BITSHIFT,1,vert/3+1);
						ssel.Clear(vert/3+1);
						}
					inserting = TRUE;
					iBack.SetPtrs(mod, shape->splines[poly]);
					backspaceRouter.Register(&iBack);
					}
				else
					res = FALSE;
				break;

			case MOUSE_MOVE:
			case MOUSE_ABORT:
				res = FALSE;
				break;

			case MOUSE_FREEMOVE:
				if ( HitTest(vpt, &m, HITTYPE_POINT, HIT_ABORTONHIT, ES_VERTEX) )
					SetCursor(GetTransformCursor());
				else
				if ( HitTest(vpt, &m, HITTYPE_POINT, HIT_ABORTONHIT, ES_SEGMENT) )
					SetCursor(GetTransformCursor());
				else
					SetCursor(LoadCursor(NULL,IDC_ARROW));
				break;
			
			}
		}
	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

class ESMBackspaceUser : public EventUser {
	Spline3D *spline;
	EditSplineMod *mod;
	public:
		void Notify();
		void SetPtrs(EditSplineMod *m,Spline3D *s) { mod = m; spline = s; }
	};

void ESMBackspaceUser::Notify() {
	if(spline->KnotCount() > 2) {
		// Tell the spline we just backspaced to remove the last point
		spline->Create(NULL, -1, 0, 0, IPoint2(0,0), NULL);
		mod->createShapeData->Invalidate(PART_GEOM);
		mod->NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
		mod->ip->RedrawViews(mod->ip->GetTime(), REDRAW_NORMAL);
		}
	}

static ESMBackspaceUser pBack;

int CreateLineMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;
	static int poly, seg, vert;
	static BezierShape *shape;
	static Spline3D *spline;
	static int inserting = FALSE;
	static Matrix3 mat;
	static EditSplineMod *mod;

	if(inserting) {
		// Ignore the messages the spline code doesn't care about... TH 3/12/99
		switch(msg) {
#ifdef DESIGN_VER
			case MOUSE_DBLCLICK:
#endif
			case MOUSE_POINT:
			case MOUSE_MOVE:
			case MOUSE_ABORT:
				break;
			default:
				return TRUE;
			}
		vpt->getGW()->setTransform(mat);	
		int res = shape->splines[poly]->Create(vpt,msg,point,flags,m,&mat,ip);
		// Must update the shape's selection set for this spline
		shape->UpdateSels();		
			
		switch(res) {
			case CREATE_STOP:
				es->EndCreateLine();
				inserting = FALSE;
				backspaceRouter.UnRegister(&pBack);
				break;
			case CREATE_ABORT:
				shape->DeleteSpline(poly);
				es->EndCreateLine();
				inserting = FALSE;
				backspaceRouter.UnRegister(&pBack);
				break;
			}	
		mod->createShapeData->Invalidate(PART_GEOM);
		mod->NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime(), REDRAW_NORMAL);
		}
	else {
		switch(msg)	{
			case MOUSE_PROPCLICK:
				ip->SetStdCommandMode(CID_OBJMOVE);
				break;

			case MOUSE_POINT:
				mod = es;
				if(!mod->StartCreateLine(&shape))
					return CREATE_ABORT;
				poly = shape->splineCount;
				spline = shape->NewSpline();
				shape->UpdateSels();
				mat = mod->createTM;
				vpt->getGW()->setTransform(mat);	
				if(spline->Create(vpt,msg,point,flags,m,&mat,ip) == CREATE_CONTINUE) {
					inserting = TRUE;
					shape->UpdateSels();
					pBack.SetPtrs(mod, spline);
					backspaceRouter.Register(&pBack);
					}
				else {
					shape->DeleteSpline(poly);
					res = FALSE;
					}
				SetCursor(LoadCursor(hInstance,MAKEINTRESOURCE(IDC_ES_CROSS_HAIR)));
				break;

			case MOUSE_MOVE:
			case MOUSE_ABORT:
				res = FALSE;
				break;

			case MOUSE_FREEMOVE:
				SetCursor(LoadCursor(hInstance,MAKEINTRESOURCE(IDC_ES_CROSS_HAIR)));
				vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
				break;
			
			}
		}
	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

HCURSOR BooleanMouseProc::GetTransformCursor() 
	{ 
	return LoadCursor(hInstance, MAKEINTRESOURCE(es->GetBoolCursorID()));
	}

BOOL BooleanMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	if ( vpt->NumSubObjHits() )
		return TRUE;
	return FALSE;
	}

int BooleanMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;
	static int poly2 = -1;

	switch(msg)	{
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			if(poly2 >= 0)
				if(ValidBooleanPolygon(es->ip, es->boolShape->splines[poly2]))
					es->DoBoolean(poly2);
			res = FALSE;
			break;

		case MOUSE_MOVE:
		case MOUSE_ABORT:
			res = FALSE;
			break;

		case MOUSE_FREEMOVE:
			poly2 = -1;
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				ShapeHitData *hit = ((ShapeHitData *)rec->hitData);
				Spline3D *spline = hit->shape->splines[hit->poly];
				if(spline->Closed() && hit->shape == es->boolShape && hit->poly != es->boolPoly1) {
					poly2 = hit->poly;
					SetCursor(GetTransformCursor());
					break;
					}
				}
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			break;
		
		}
	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

/*-------------------------------------------------------------------*/
//watje


HCURSOR BindMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_VERTCONNECTCUR)); 
		}

	return hCur; 
	}

BOOL BindMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}


BOOL BindMouseProc::HitTestSeg( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	SetSplineHitOverride(SS_SEGMENT);
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	ClearSplineHitOverride();
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}

BOOL BindMouseProc::HitAnEndpoint(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
	BezierShape **shapeOut, int *polyOut, int *vertOut) {
	int first = 1;
	
	if(HitTest(vpt, p, HITTYPE_POINT, 0) ) {
		HitLog &hits = vpt->GetSubObjHitList();
		HitRecord *rec = hits.First();
		DWORD best = 9999;
		HitRecord *bestRec;
		while(rec) {
			ShapeHitData *hit = ((ShapeHitData *)rec->hitData);
			// If there's an exclusion shape, this must be a part of it!
			if(!shape || shape == hit->shape) {
				// If there's an exclusion shape, the vert & poly can't be the same!
				if(!shape || (shape && !(poly == hit->poly && vert == hit->index))) {
					Spline3D *spline = hit->shape->splines[hit->poly];
					if(!spline->Closed()) {
						int hitKnot = hit->index / 3;
						if(hitKnot == 0 || hitKnot == (spline->KnotCount() - 1)) {
							if(first || rec->distance < best) {
								first = 0;
								best = rec->distance;
								bestRec = rec;
								}
							}
						}
					}
				}
			rec = rec->Next();
			}
		if(!first) {
			ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
			if(shapeOut)
				*shapeOut = hit->shape;
			if(polyOut)
				*polyOut = hit->poly;
			if(vertOut)
				*vertOut = hit->index;
			return TRUE;
			}
		}
	return FALSE;
	}


BOOL BindMouseProc::HitASegment(ViewExp *vpt, IPoint2 *p, BezierShape *shape, int poly, int vert,
	BezierShape **shapeOut, int *polyOut, int *vertOut) {

	int first = 1;
	
	SetSplineHitOverride(SS_SEGMENT);
	if(HitTest(vpt, p, HITTYPE_POINT, 0) ) {
		HitLog &hits = vpt->GetSubObjHitList();
		HitRecord *rec = hits.First();
		DWORD best = 9999;
		HitRecord *bestRec;
		while(rec) {
			ShapeHitData *hit = ((ShapeHitData *)rec->hitData);
			// If there's an exclusion shape, this must be a part of it!
			Spline3D *spline = hit->shape->splines[hit->poly];
			int scount = spline->KnotCount()-1;
			if ((poly == hit->poly) && ((vert-1) == 0) && (hit->index == 0))
				{
				}
			else if ((poly == hit->poly) && (vert == ((scount+1)*3-2)) && (hit->index == (scount-1)))
				{
				}
			else if(first || rec->distance < best) 
				{
				first = 0;
				best = rec->distance;
				bestRec = rec;
				}
			rec = rec->Next();
			}
		if(!first) {
			ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
			if(shapeOut)
				*shapeOut = hit->shape;
			if(polyOut)
				*polyOut = hit->poly;
			if(vertOut)
				*vertOut = hit->index;
			ClearSplineHitOverride();
			return TRUE;
			}
		}
	ClearSplineHitOverride();
	return FALSE;

	}


int BindMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;
	static BezierShape *shape1 = NULL;
	static int poly1, vert1, poly2, vert2;
	static IPoint2 anchor, lastPoint;

	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			switch(point) {
				case 0:
					if(HitAnEndpoint(vpt, &m, NULL, -1, -1, &shape1, &poly1, &vert1))
						res = TRUE;
					else
						res = FALSE;
					anchor = lastPoint = m;
					XORDottedLine(hwnd, anchor, m);	// Draw it!
					break;
				case 1:
					XORDottedLine(hwnd, anchor, lastPoint);	// Erase it!
					if(HitASegment(vpt, &m, shape1, poly1, vert1, NULL, &poly2, &vert2))
						ss->DoBind( poly1, vert1, poly2, vert2); 
					res = FALSE;
					break;
				default:
					assert(0);
				}
			break;

		case MOUSE_MOVE:
			// Erase old dotted line
			XORDottedLine(hwnd, anchor, lastPoint);
			// Draw new dotted line
			XORDottedLine(hwnd, anchor, m);
			lastPoint = m;

			if(HitASegment(vpt, &m, shape1, poly1, vert1, NULL, NULL, NULL))
				SetCursor(GetTransformCursor());
			else
				SetCursor(LoadCursor(NULL,IDC_ARROW));

			break;
					
		case MOUSE_FREEMOVE:
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				ShapeHitData *hit = ((ShapeHitData *)rec->hitData);
				Spline3D *spline = hit->shape->splines[hit->poly];
				if(!spline->Closed()) {
					int hitKnot = hit->index / 3;
					if(hitKnot == 0 || hitKnot == (spline->KnotCount() - 1)) {
						SetCursor(LoadCursor(hInstance,MAKEINTRESOURCE(IDC_TH_SELCURSOR)));
						break;
						}
					}
				}
			else SetCursor(LoadCursor(NULL,IDC_ARROW));
			break;
		
		case MOUSE_ABORT:
			// Erase old dotted line
			XORDottedLine(hwnd, anchor, lastPoint);
			break;			
		}

	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

HCURSOR RefineConnectMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_SEGREFINECUR)); 
		}

	return hCur; 
	}

BOOL RefineConnectMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	SetSplineHitOverride(SS_SEGMENT);
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	ClearSplineHitOverride();
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}

int RefineConnectMouseProc::proc(
			HWND hwnd, 
			int msg, 
			int point, 
			int flags, 
			IPoint2 m )
	{
	ViewExp *vpt = ip->GetViewport(hwnd);	
	int res = TRUE;

	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:
			if(HitTest(vpt,&m,HITTYPE_POINT,0) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				HitRecord *bestRec = rec;
				DWORD best = rec->distance;
				while(rec) {
					rec = rec->Next();
					if(rec) {
						if(rec->distance < best) {
							best = rec->distance;
							bestRec = rec;
							}
						}
					}
				ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
				ss->DoRefineConnect(vpt, hit->shape, hit->poly, hit->index, m);
				}
			res = FALSE;
			break;
		
		case MOUSE_FREEMOVE:
			vpt->SnapPreview(m,m,NULL, SNAP_IN_3D);
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
				SetCursor(GetTransformCursor());
				}
			else {
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				}
			break;
			
		}

	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

HCURSOR TrimMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur ) {
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_CUR_TRIM)); 
		}

	return hCur; 
	}

BOOL TrimMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}

int TrimMouseProc::proc( 
		HWND hwnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m )
	{	
	ViewExp *vpt = ip->GetViewport(hwnd);
	int res = TRUE;
//	IntersectPt fromPt, toPt;
	BOOL extend = FALSE;
	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:						
			if(HitTest(vpt,&m,HITTYPE_POINT,0) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				HitRecord *bestRec = rec;
				DWORD best = rec->distance;
				while(rec) {
					rec = rec->Next();
					if(rec) {
						if(rec->distance < best) {
							best = rec->distance;
							bestRec = rec;
							}
						}
					}
				ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
				es->HandleTrimExtend(vpt, hit, m, SHAPE_TRIM);
				}
			res = FALSE;
			break;

		case MOUSE_FREEMOVE:
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
				SetCursor(GetTransformCursor());
				}
			else {
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				}
			break;
		}
	
	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}

/*-------------------------------------------------------------------*/

HCURSOR ExtendMouseProc::GetTransformCursor() 
	{ 
	static HCURSOR hCur = NULL;

	if ( !hCur )
		hCur = LoadCursor(hInstance,MAKEINTRESOURCE(IDC_CUR_TRIM)); 

	return hCur; 
	}

BOOL ExtendMouseProc::HitTest( 
		ViewExp *vpt, IPoint2 *p, int type, int flags )
	{
	vpt->ClearSubObjHitList();
	ip->SubObHitTest(ip->GetTime(),type,ip->GetCrossing(),flags,p,vpt);
	if ( vpt->NumSubObjHits() ) {
		return TRUE;
	} else {
		return FALSE;
		}			
	}

int ExtendMouseProc::proc( 
		HWND hwnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m )
	{	
	ViewExp *vpt = ip->GetViewport(hwnd);
	int res = TRUE;
	BOOL extend = FALSE;
	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:						
			if(HitTest(vpt,&m,HITTYPE_POINT,0) ) {
				HitLog &hits = vpt->GetSubObjHitList();
				HitRecord *rec = hits.First();
				HitRecord *bestRec = rec;
				DWORD best = rec->distance;
				while(rec) {
					rec = rec->Next();
					if(rec) {
						if(rec->distance < best) {
							best = rec->distance;
							bestRec = rec;
							}
						}
					}
				ShapeHitData *hit = ((ShapeHitData *)bestRec->hitData);
				es->HandleTrimExtend(vpt, hit, m, SHAPE_EXTEND);
				}
			res = FALSE;
			break;

		case MOUSE_FREEMOVE:
			if ( HitTest(vpt,&m,HITTYPE_POINT,HIT_ABORTONHIT) ) {
				SetCursor(GetTransformCursor());
				}
			else {
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				}
			break;
		}
	
	if ( vpt ) ip->ReleaseViewport(vpt);
	return res;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editmesh.h ===
/**********************************************************************
 *<
	FILE: editmesh.h

	DESCRIPTION:  Edit Mesh OSM

	CREATED BY: Dan Silva & Rolf Berteig

	HISTORY: created 18 March, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __EDITMESH_H__
#define __EDITMESH_H__

#ifdef _DEBUG
//#define EM_DEBUG
#endif

#include "namesel.h"
#include "nsclip.h"
#include "sbmtlapi.h"
#include "istdplug.h"
#include "KbdShortcut.h"

// Available selection levels
#define SL_OBJECT EM_SL_OBJECT	//0
#define SL_VERTEX EM_SL_VERTEX	//1
#define SL_EDGE EM_SL_EDGE	//2
#define SL_FACE EM_SL_FACE	//3
#define SL_POLY EM_SL_POLYGON	//4
#define SL_ELEMENT EM_SL_ELEMENT	//5

#define DEF_PICKBOX_SIZE	4

// Alignment types:
#define ALIGN_CONST 0
#define ALIGN_VIEW 1

#define EDITMESH_CHANNELS (PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY|PART_TOPO|TEXMAP_CHANNEL|PART_VERTCOLOR)

class WeldVertCMode;
class CreateVertCMode;
class CreateFaceCMode;
class DivideEdgeCMode;
class TurnEdgeCMode;
class AttachPickMode;
class ExtrudeCMode;
class BevelCMode;
class ChamferCMode;
class FlipNormCMode;
class CutEdgeCMode;
class DivideFaceCMode;
class XFormProc;
class EditMeshData;

#define CID_EXTRUDE		CID_USER + 972
#define CID_CREATEVERT	CID_USER + 973
#define CID_OBJATTACH	CID_USER + 974
#define CID_BUILDFACE	CID_USER + 975
#define CID_DIVIDEEDGE	CID_USER + 976
#define CID_TURNEDGE	CID_USER + 977
#define CID_WELDVERT	CID_USER + 978
#define CID_DIVIDEFACE CID_USER + 979
#define CID_CUTEDGE CID_USER + 980
#define CID_FLIPNORM CID_USER + 981
#define CID_BEVEL    CID_USER + 982
#define CID_MCHAMFER CID_USER + 983	// "Mesh Chamfer" -- CID_CHAMFER was taken.

#define MAX_MATID	0xffff

// Edit Mesh Flags
// Temp flags:
#define EM_TEMPFLAGS 0xff
#define EM_SWITCH_SUBOBJ_VERSIONS 0x01
#define EM_EDITING 0x02
// "Keeper" flags:
#define EM_KEEPFLAGS (~0xff)
#define EM_DISP_RESULT 0x0100

class EditMeshMod : public Modifier, public IMeshSelect, public MeshDeltaUser,
							 public ISubMtlAPI, public AttachMatDlgUser {
public:
	// Window handles & an interface:
	static HWND hGeom, hSurf, hSel, hAR;
	static IObjParam *ip;		

	// Command modes
	static MoveModBoxCMode *moveMode;
	static RotateModBoxCMode *rotMode;
	static UScaleModBoxCMode *uscaleMode;
	static NUScaleModBoxCMode *nuscaleMode;
	static SquashModBoxCMode *squashMode;
	static SelectModBoxCMode *selectMode;
	static WeldVertCMode *weldVertMode;
	static CreateVertCMode *createVertMode;
	static CreateFaceCMode* createFaceMode;
	static TurnEdgeCMode* turnEdgeMode;
	static DivideEdgeCMode* divideEdgeMode;
	static DivideFaceCMode* divideFaceMode;
	static AttachPickMode* attachPickMode;
	static ExtrudeCMode *extrudeMode;
	static BevelCMode* bevelMode;
	static ChamferCMode *chamferMode;
	static FlipNormCMode *flipMode;
	static CutEdgeCMode *cutEdgeMode;

	static float normScale;
	static BOOL selByVert;
	static BOOL inBuildFace, inCutEdge;
	static BOOL faceUIValid;
	static BOOL inExtrude, inBevel, inChamfer;
	static int extType;
	static BOOL ignoreBackfaces, ignoreVisEdge;
	static BOOL rsSel, rsAR, rsGeom, rsSurf;	// Rollup States (FALSE=Rolled-up.)
	static int pickBoxSize;
	static int weldBoxSize;
	static int attachMat;
	static BOOL condenseMat;
	static bool sliceMode, sliceSplit, cutRefine;
	static Quat sliceRot;
	static Point3 sliceCenter;
	static float sliceSize;

	// Named selection set info:
	Tab<TSTR*> namedSel[3];
	Tab<DWORD> ids[3];
	int affectRegion, arIgBack, useEdgeDist, edgeIts;
	float falloff, pinch, bubble;
	int selLevel;

	DWORD emFlags;
	void SetFlag (DWORD fl, BOOL val=TRUE) { if (val) emFlags |= fl; else emFlags &= ~fl; }
	void ClearFlag (DWORD fl) { emFlags &= (~fl); }
	bool GetFlag (DWORD fl) { return (emFlags&fl) ? TRUE : FALSE; }

	EditMeshMod();
	~EditMeshMod();

	Interval LocalValidity(TimeValue t);
	ChannelMask ChannelsUsed()  { return EDITMESH_CHANNELS; }
	ChannelMask ChannelsChanged() { return EDITMESH_CHANNELS; }
	void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
	void NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc);
	Class_ID InputType() { return triObjectClassID; }
	
	int CompMatrix(TimeValue t, ModContext& mc, Matrix3& tm, Interval& valid);
	
	// From Animatable
	void DeleteThis() { delete this; }
	Class_ID ClassID() { return Class_ID(EDITMESH_CLASS_ID,0);}
	void GetClassName(TSTR& s) { s= GetString(IDS_RB_EDITMESHMOD); }
	void RescaleWorldUnits(float f);

	// From BaseObject
	int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc);
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flagst, ModContext *mc);
	void GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc);

	void GetSubObjectCenters(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
	void GetSubObjectTMs(SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc);
	int SubObjectIndex(HitRecord *hitRec);

	void ShowEndResultChanged (BOOL showEndResult);
	
	// Named selection set handling:
	// local methods:
	void UpdateSetNames ();	// Reconciles names with EditMeshData.
	void ClearSetNames();
	int FindSet(TSTR &setName,int level);
	DWORD AddSet(TSTR &setName,int level);
	void RemoveSet(TSTR &setName,int level);
	// from BaseObject:
	BOOL SupportsNamedSubSels () {return TRUE;}
	void ActivateSubSelSet (TSTR &setName);
	void NewSetFromCurSel (TSTR &setName);
	void RemoveSubSelSet (TSTR &setName);
	// also from BaseObject, for the named selection editing dialog:
	void SetupNamedSelDropDown ();
	int NumNamedSelSets ();
	TSTR GetNamedSelSetName (int i);
	void SetNamedSelSetName (int i, TSTR & newName);
	void NewSetByOperator(TSTR &newName,Tab<int> &sets,int op);
	// More local methods, relating to copying and pasting of named selections:
	void NSCopy();
	void NSPaste();
	BOOL GetUniqueSetName(TSTR &name);
	int SelectNamedSet();

	BOOL DependOnTopology(ModContext &mc);

	// Operations -- in editmops.cpp
	// Shift-cloning:
	void CloneSelSubComponents(TimeValue t);
	void AcceptCloneSelSubComponents(TimeValue t);
	// Transform stuff:
	void Transform (TimeValue t, Matrix3& partm, Matrix3 tmAxis, BOOL localOrigin, Matrix3 xfrm, int type);
	void Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
	void Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin=FALSE );
	void Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin=FALSE );
	void TransformStart(TimeValue t);
	void TransformHoldingFinish(TimeValue t);
	void TransformFinish(TimeValue t);
	void TransformCancel(TimeValue t);

	void DragMoveInit (TimeValue t);
	void DragMoveRestore ();
	void DragMove (MeshDelta & md, MeshDeltaUserData *mdu);
	void DragMoveAccept ();

	// Selection panel operations:
	void HideSelectedVerts();
	void UnhideAllVerts();
	void HideSelectedFaces();
	void UnhideAllFaces();	

	// Topological & Geometric ops from the Edit Geometry panel
	DWORD CreateVertex (Point3 pt, EditMeshData *meshData=NULL, INode *nref=NULL);
	bool CreateFace (EditMeshData *meshData, int *v, int deg);
	void DeleteSelected ();

	// from AttachMatDlgUser
	int GetAttachMat() { return attachMat; }
	void SetAttachMat(int value) { attachMat = value; }
	BOOL GetCondenseMat() { return condenseMat; }
	void SetCondenseMat(BOOL sw) { condenseMat = sw; }

	void Attach (INode *node, bool & canUndo);
	void MultiAttach (INodeTab &nodeTab);
	void Detach (TSTR &name,BOOL doFaces,BOOL del=TRUE, BOOL elem=FALSE);
	void BreakVerts ();	// happens when we click "Divide" on a vert.
	void DoExtrusion();
	void BeginExtrude(TimeValue t);
	void Extrude( TimeValue t, float amount );
	void EndExtrude(TimeValue t,BOOL accept=TRUE);
	void BeginBevel (TimeValue t, BOOL doExtrude=FALSE);
	void EndBevel (TimeValue t,BOOL accept=TRUE);
	void Bevel (TimeValue t, float outline, float height=0);
	void DoChamfer (TimeValue t);
	void BeginChamfer (TimeValue t);
	void EndChamfer (TimeValue t,BOOL accept);
	void Chamfer (TimeValue t, float amount);
	void AlignTo (int alignType);
	void MakePlanar ();
	void Collapse ();
	void Tessellate (float tens,BOOL edge);
	void Explode (float thresh,BOOL objs,TSTR &name);
	void Slice ();
	BOOL WeldVerts (float thresh);
	void WeldVerts (Point3 weldPoint);
	void RemoveIsoVerts ();
	void SelectOpenEdges ();

	// Vertex Surface operations:
	float GetWeight (TimeValue t, int *numSel=NULL);
	void UpdateWeightDisplay (TimeValue t, HWND hWnd);
	void SetWeight (TimeValue t, float w);
	void ResetWeights (TimeValue t);
	Color GetVertColor ();
	void SetVertColor (Color clr);
	void SelectVertByColor (VertColor clr, int deltaR, int deltaG, int deltaB, BOOL add, BOOL sub);

	// Edge Surface operations:
	void SetEdgeVis (BOOL vis);
	void AutoEdge (float thresh, int type);

	// Face Surface operations:
	void ShowNormals ();
	void FlipNormals ();
	void UnifyNormals ();
	DWORD GetMatIndex ();
	void SetMatIndex (DWORD index);
	void SelectByMat (DWORD index,BOOL clear);
	DWORD GetUsedSmoothBits ();
	DWORD GetSelSmoothBits (DWORD &invalid);
	void SetSelSmoothBits (DWORD bits,DWORD mask); // Only bits that are 1 in 'mask' are changed to the value given by 'bits'
	void SelectBySmoothGroup (DWORD bits,BOOL clear);		
	void AutoSmooth (float thresh);
	Color GetFaceColor ();
	void SetFaceColor (Color clr);

	// Psuedo-command-mode, mixed in with real ones in editmops.cpp:
	void EnterSliceMode ();
	void ExitSliceMode ();

	// UI code -- edmui.cpp
	void UpdateSurfType ();
	void RefreshSelType ();
	void SetSelDlgEnables (), SetGeomDlgEnables (), SetARDlgEnables ();
	void SetSurfDlgEnables ();
	void InvalidateSurfaceUI();
	void InvalidateNumberSelected ();
	void SetNumSelLabel ();
	void ExitAllCommandModes (bool exSlice=TRUE);
	float GetPolyFaceThresh ();

	void ClearMeshDataFlag(ModContextList& mcList,DWORD f);
	void DeleteMeshDataTempData();		
	void CreateMeshDataTempData();

	int NumRefs() { return 0; }
	RefTargetHandle GetReference(int i) { return NULL; }
	void SetReference(int i, RefTargetHandle rtarg) {}
	RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message ) { return REF_SUCCEED; }

	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);
	IOResult SaveLocalData(ISave *isave, LocalModData *ld);
	IOResult LoadLocalData(ILoad *iload, LocalModData **pld);
	IOResult LoadNamedSelChunk(ILoad *iload,int level);

	CreateMouseCallBack* GetCreateMouseCallBack() { return NULL; } 
	void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
	void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	RefTargetHandle Clone(RemapDir& remap = NoRemap());
	TCHAR *GetObjectName() { return GetString(IDS_RB_EDITMESH); }
	void ActivateSubobjSel(int level, XFormModes& modes );
	int NeedUseSubselButton() { return 0; }
	void SelectSubComponent(HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert);
	void ClearSelection(int selLevel);
	void SelectAll(int selLevel);
	void InvertSelection(int selLevel);
	void UpdateNamedSelDropDown ();

	void InvalidateDistances ();
	void InvalidateAffectRegion ();

	// IMeshSelect methods:
	DWORD GetSelLevel();
	void SetSelLevel(DWORD level);
	void LocalDataChanged();

	// MeshDeltaUser methods:
	void LocalDataChanged (DWORD parts);
	void GetUIParam (meshUIParam uiCode, float & ret);
	void SetUIParam (meshUIParam uiCode, float val);
	void GetUIParam (meshUIParam uiCode, int & ret);
	void SetUIParam (meshUIParam uiCode, int val);
	void ToggleCommandMode (meshCommandMode mode);
	void ButtonOp (meshButtonOp opcode);
	void ExitCommandModes () { ExitAllCommandModes (TRUE); }

	bool Editing () { return (ip && GetFlag (EM_EDITING)) ? TRUE : FALSE; }
	DWORD GetEMeshSelLevel () { return selLevel; }
	void SetEMeshSelLevel (DWORD sl) { if (ip) ip->SetSubObjectLevel (sl); else selLevel = sl; }

	// ISubMtlAPI methods:
	void*	GetInterface(ULONG id);
	MtlID	GetNextAvailMtlID(ModContext* mc);
	BOOL	HasFaceSelection(ModContext* mc);
	void	SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel = FALSE);
	int		GetSelFaceUniqueMtlID(ModContext* mc);
	int		GetSelFaceAnyMtlID(ModContext* mc);
	int		GetMaxMtlID(ModContext* mc);
};

// Accelerator table callback for Editable or Edit Mesh.
class EMeshShortcutCB : public ShortcutCallback {
public:
	MeshDeltaUser *em;
	EMeshShortcutCB (MeshDeltaUser *emm) { em=emm; }
	BOOL KeyboardShortcut(int id);
};

// Tables based on Edit Mesh's selLevel:
// Mesh selection level:
const int meshLevel[] = {MESH_OBJECT,MESH_VERTEX,MESH_EDGE,MESH_FACE,MESH_FACE,MESH_FACE};
// Display flags:
const DWORD levelDispFlags[] = {0,DISP_VERTTICKS|DISP_SELVERTS,DISP_SELEDGES,DISP_SELFACES,DISP_SELPOLYS,DISP_SELPOLYS};
// Hit testing...
const int hitLevel[] = { 0, SUBHIT_VERTS, SUBHIT_EDGES, SUBHIT_FACES, SUBHIT_FACES, SUBHIT_FACES };

// Named selection set levels:
#define NS_VERTEX 0
#define NS_EDGE 1
#define NS_FACE 2
// Conversion from selLevel to named selection level:
static int namedSetLevel[] = { NS_VERTEX, NS_VERTEX, NS_EDGE, NS_FACE, NS_FACE, NS_FACE };
static int namedClipLevel[] = { CLIP_VERT, CLIP_VERT, CLIP_EDGE, CLIP_FACE, CLIP_FACE, CLIP_FACE };

class EditMeshClassDesc:public ClassDesc {
public:
	int 			IsPublic() { return GetSystemSetting(SYSSET_ENABLE_EDITMESHMOD); }
	void *			Create(BOOL loading = FALSE ) { return new EditMeshMod; }
	const TCHAR *	ClassName() { return GetString(IDS_RB_EDITMESH_CLASS); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(EDITMESH_CLASS_ID,0); }
	const TCHAR* 	Category() { return GetString(IDS_RB_DEFEDIT);}
	void			ResetClassParams(BOOL fileReset);
};

void ResetEditMeshUI();

class XFormProc {
public:
	virtual Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat)=0;
	virtual void SetMat( Matrix3& mat ) {}
};

class MoveXForm : public XFormProc {
private:
	Point3 delta, tdelta;		
public:
	Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) { return p + tdelta; }
	void SetMat( Matrix3& mat ) { tdelta = VectorTransform(Inverse(mat),delta); }
	MoveXForm(Point3 d) { delta = d; }
};

class RotateXForm : public XFormProc {
private:
	Matrix3 rot, trot;
public:
	Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) { return (trot*p)*imat; }
	void SetMat( Matrix3& mat ) { trot = mat * rot; }
	RotateXForm(Quat q) { q.MakeMatrix(rot); }
};

class ScaleXForm : public XFormProc {
private:
	Matrix3 scale, tscale;
public:
	Point3 proc(Point3& p, Matrix3 &mat, Matrix3 &imat) { return (p*tscale)*imat; }
	void SetMat( Matrix3& mat ) { tscale = mat*scale; }
	ScaleXForm(Point3 s) { scale = ScaleMatrix(s); }
};

// EditmeshData flags
#define EMD_BEENDONE			(1<<0)
#define EMD_UPDATING_CACHE		(1<<1)
#define EMD_HASDATA				(1<<2)

// Types of welds
#define WELD_COLLAPSE	1
#define WELD_THRESHOLD	2
#define WELD_TOVERT		3

// Not really a restore object, just used in some drag moves.
class TempMoveRestore {
public:
	Tab<Point3> init;
	TempMoveRestore (Mesh *msh);
	void Restore (Mesh *msh);
};

// This is the data that each mod app will have.
class EditMeshData : public LocalModData, public IMeshSelectData, public MeshDeltaUserData {
public:
	DWORD flags;

	// This is the change record on the incoming object.
	MeshDelta  mdelta;

	// This represents temporary drag movements:
	MeshDelta tempMove;
	TempMoveRestore *tmr;

	// Lists of named selection sets
	GenericNamedSelSetList selSet[3];

	// While an object is being edited, these exist:
	EditMeshMod *mod;
	Mesh *mesh;
	bool updateMD;
	DWORD lastInVNum, lastInFNum;
	Tab<DWORD> lastInMVNum;
	MeshTempData *tempData;
	Interval mValid, topoValid, geomValid;
	BOOL lockInvalidate;

	EditMeshData();
	EditMeshData(EditMeshData& emc);
	~EditMeshData();

	// Applies modifications to a triOb
	void Apply(TimeValue t,TriObject *triOb, EditMeshMod *mod);

	// If this is the first edit, then the delta arrays will be allocated.  Returns cached mesh.
	void SetModifier (EditMeshMod *md) { mod = md; }
	void BeginEdit (TimeValue t);
	LocalModData *Clone() { return new EditMeshData(*this); }
	
	void SetFlag(DWORD f,BOOL on) { if ( on ) flags|=f; else flags&=~f; }
	DWORD GetFlag(DWORD f) { return flags&f; }

	// Temp data related methods in edmdata.cpp:
	Mesh *GetMesh (TimeValue t);
	MeshTempData *TempData (TimeValue t);
	void Invalidate (PartID part,BOOL meshValid=TRUE);
	BOOL MeshCached(TimeValue t);
	void UpdateCache(TimeValue t, TriObject *triOb);

	// LocalModData
	void* GetInterface(ULONG id) { if (id == I_MESHSELECTDATA) return(IMeshSelectData*)this; else return LocalModData::GetInterface(id); }

	// IMeshSelectData methods:
	BitArray GetVertSel() { return mdelta.vsel; }
	BitArray GetFaceSel() { return mdelta.fsel; }
	BitArray GetEdgeSel() { return mdelta.esel; }
	BitArray GetSel (int nsl);
	void AddVertHide(BitArray set, IMeshSelect *mod, TimeValue t);	// (Not an IMeshSelectData method)
	void ClearVertHide(IMeshSelect *mod, TimeValue t);	// (Not an IMeshSelectData method)
	void SetVertSel(BitArray &set, IMeshSelect *mod, TimeValue t);
	void SetFaceSel(BitArray &set, IMeshSelect *mod, TimeValue t);
	void SetEdgeSel(BitArray &set, IMeshSelect *mod, TimeValue t);
	void SetSel (int nsl, BitArray &set, IMeshSelect *mod, TimeValue t);
	GenericNamedSelSetList & GetNamedVertSelList () { return selSet[NS_VERTEX]; }
	GenericNamedSelSetList & GetNamedEdgeSelList () { return selSet[NS_EDGE]; }
	GenericNamedSelSetList & GetNamedFaceSelList () { return selSet[NS_FACE]; }

	// Other named selection set methods:
	void ChangeNamedSetSize (int nsl, int oldsize, int increase);
	void DeleteNamedSetArray (int nsl, BitArray & del);

	// From MeshDeltaUserData
	void ApplyMeshDelta (MeshDelta & md, MeshDeltaUser *mdu, TimeValue t);
	MeshDelta *GetCurrentMDState () { return &mdelta; }
	void MoveSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
	void RotateSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin);
	void ScaleSelection(int level, TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin);
	void ExtrudeSelection(int level, BitArray* sel, float amount, float bevel, BOOL groupNormal, Point3* direction);
};

// --- Command Modes & Mouse Procs -------------------------------

// Virtual mouse procs:
class PickEdgeMouseProc : public MouseCallBack {
public:
	EditMeshMod *em;
	IObjParam *ip;

	PickEdgeMouseProc(EditMeshMod* mod, IObjParam *i) { em=mod; ip=i; }
	HitRecord *HitTestEdges(IPoint2 &m, ViewExp *vpt, float *prop, Point3 *snapPoint);
	int proc (HWND hwnd, int msg, int point, int flags, IPoint2 m);
	virtual void EdgePick(EditMeshData *meshData,DWORD edge, float prop)=0;
};

class PickFaceMouseProc : public MouseCallBack {
public:
	EditMeshMod *em;
	IObjParam *ip;

	PickFaceMouseProc(EditMeshMod* e, IObjParam *i) {em=e;ip=i;}
	HitRecord *HitTestFaces(IPoint2 &m, ViewExp *vpt, float *bary, Point3 *snapPoint);
	int proc (HWND hwnd, int msg, int point, int flags, IPoint2 m );
	virtual void FacePick(EditMeshData *meshData, DWORD face, float *bary)=0;
};

// Actual procs & command modes:

class CreateVertMouseProc : public MouseCallBack {
private:		
	EditMeshMod *em;
	IObjParam *ip;
public:
	CreateVertMouseProc(EditMeshMod* mod, IObjParam *i) {em=mod;ip=i;}
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class CreateVertCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	CreateVertMouseProc proc;
	EditMeshMod* em;

public:
	CreateVertCMode(EditMeshMod* mod, IObjParam *i) : fgProc(mod), proc(mod,i) {em=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_CREATEVERT; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class CreateFaceMouseProc : public MouseCallBack {
public:
	EditMeshMod *em;
	IObjParam *ip;
	EditMeshData *meshData;
	INode *nref;
	Tab<int> vts;
	IPoint2 mlast, mfirst, oldm;
	int pt;

	CreateFaceMouseProc(EditMeshMod* mod, IObjParam *i);
	void DrawCreatingFace (HWND hWnd, const IPoint2 & m);
	void DrawEstablishedFace (GraphicsWindow *gw);
	BOOL HitTestVerts(IPoint2 m, ViewExp *vpt,int &v);
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class CreateFaceCMode : public CommandMode {
public:
	ChangeFGObject fgProc;		
	CreateFaceMouseProc proc;
	EditMeshMod* em;

	CreateFaceCMode(EditMeshMod* mod, IObjParam *i) : fgProc(mod), proc(mod,i) {em=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_BUILDFACE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=999999; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class AttachPickMode : public PickModeCallback, public PickNodeCallback {
public:
	EditMeshMod* em;
	IObjParam *ip;

	AttachPickMode(EditMeshMod* mod, IObjParam *i) { em=mod; ip=i; }
	BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);				
	BOOL Pick(IObjParam *ip,ViewExp *vpt);
	void EnterMode(IObjParam *ip);
	void ExitMode(IObjParam *ip);		
	
	BOOL Filter(INode *node);
	BOOL RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}
	PickNodeCallback *GetFilter() {return this;}
};

class MAttachHitByName : public HitByNameDlgCallback {
public:
	EditMeshMod *em;
	bool inProc;

	MAttachHitByName (EditMeshMod *e) {em=e; inProc=FALSE;}
	TCHAR *dialogTitle() { return GetString(IDS_EM_ATTACH_LIST); }
	TCHAR *buttonText() { return GetString(IDS_TH_ATTACH); }
	int filter(INode *node);	
	void proc(INodeTab &nodeTab);	
};

class DivideEdgeProc : public PickEdgeMouseProc {
public:
	DivideEdgeProc(EditMeshMod* mod, IObjParam *i) : PickEdgeMouseProc(mod,i) {}
	void EdgePick(EditMeshData *meshData,DWORD edge, float prop);
};

class DivideEdgeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	DivideEdgeProc proc;
	EditMeshMod* em;

public:
	DivideEdgeCMode(EditMeshMod* mod, IObjParam *i) : fgProc(mod), proc(mod,i) {em=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_DIVIDEEDGE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class DivideFaceProc : public PickFaceMouseProc {
public:
	DivideFaceProc(EditMeshMod* e, IObjParam *i) : PickFaceMouseProc(e,i) {}
	void FacePick(EditMeshData *meshData, DWORD edge, float *bary);
};

class DivideFaceCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	DivideFaceProc proc;
	EditMeshMod* em;

public:
	DivideFaceCMode(EditMeshMod* e, IObjParam *i) : fgProc(e), proc(e,i) {em=e;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_DIVIDEFACE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class TurnEdgeProc : public PickEdgeMouseProc {
public:
	TurnEdgeProc(EditMeshMod* mod, IObjParam *i) : PickEdgeMouseProc(mod,i) {}
	void EdgePick(EditMeshData *meshData,DWORD edge, float prop);
};

class TurnEdgeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	TurnEdgeProc proc;
	EditMeshMod* em;

public:
	TurnEdgeCMode(EditMeshMod* mod, IObjParam *i) : fgProc(mod), proc(mod,i) {em=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_TURNEDGE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class ExtrudeMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	EditMeshMod *em;
	IObjParam *ip;
	IPoint2 om;
public:
	ExtrudeMouseProc(EditMeshMod* mod, IObjParam *i) : moveTrans(i) {em=mod;ip=i;}
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class ExtrudeSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	ExtrudeSelectionProcessor(ExtrudeMouseProc *mc, Modifier *m, IObjParam *i) 
		: GenModSelectionProcessor(mc,m,i) {}
};

class ExtrudeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	ExtrudeSelectionProcessor mouseProc;
	ExtrudeMouseProc eproc;
	EditMeshMod* em;

public:
	ExtrudeCMode(EditMeshMod* mod, IObjParam *i) :
		fgProc(mod), mouseProc(&eproc,mod,i), eproc(mod,i) {em=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_EXTRUDE; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};

class BevelMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	EditMeshMod *em;
	Interface *ip;
	IPoint2 m0, m1;
	bool m0set, m1set;
	float height;
public:
	BevelMouseProc(EditMeshMod* m, IObjParam *i) : moveTrans(i) {em=m;ip=i; m0set=FALSE; m1set=FALSE; }
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class BevelSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	BevelSelectionProcessor(BevelMouseProc *mc, Modifier *m, IObjParam *i) 
		: GenModSelectionProcessor(mc,m,i) {}
};

class BevelCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	BevelSelectionProcessor mouseProc;
	BevelMouseProc eproc;
	EditMeshMod* em;
public:
	BevelCMode(EditMeshMod* m, IObjParam *i) :
		fgProc(m), mouseProc(&eproc,m,i), eproc(m,i) {em=m;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_BEVEL; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=999; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};

class ChamferMouseProc : public MouseCallBack {
private:
	MoveTransformer moveTrans;
	EditMeshMod* em;
	Interface *ip;
	IPoint2 om;
public:
	ChamferMouseProc (EditMeshMod* m, IObjParam *i) : moveTrans(i) {em=m;ip=i;}
	int proc (HWND hwnd, int msg, int point, int flags, IPoint2 m);
};

class ChamferSelectionProcessor : public GenModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
public:
	EditMeshMod* em;
	ChamferSelectionProcessor(ChamferMouseProc *mc, EditMeshMod *m, IObjParam *i) 
		: GenModSelectionProcessor(mc,m,i) {em=m;}
};

class ChamferCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	ChamferSelectionProcessor mouseProc;
	ChamferMouseProc eproc;
	EditMeshMod* em;

public:
	ChamferCMode (EditMeshMod* m, IObjParam *i) :
		fgProc(m), mouseProc(&eproc,m,i), eproc(m,i) {em=m;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_MCHAMFER; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};

class CutEdgeProc : public MouseCallBack {	// SCA -- derived from DivideEdgeProc.
public:
	EditMeshMod *em;
	IObjParam *ip;
	DWORD e1;
	bool e1set;
	float prop1;
	IPoint2 m1, oldm2;
	ModContext *mc;

	CutEdgeProc(EditMeshMod* e, IObjParam *i) { em=e; ip=i; e1set = FALSE; mc=NULL;}
	HitRecord *HitTestEdges(IPoint2 &m, ViewExp *vpt);
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m );
	void DrawCutter (HWND hWnd,IPoint2 &m);
};

class CutEdgeCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	CutEdgeProc proc;
	EditMeshMod* em;

public:
	CutEdgeCMode(EditMeshMod* mod, IObjParam *i) : fgProc(mod), proc(mod,i) {em=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_CUTEDGE; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=999; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
	void AbandonCut ();
};

class WeldVertMouseProc : public MoveModBox {
private:		
	EditMeshMod *em;
	IObjParam *ip;
	int targetVert;
	EditMeshData *emd;
public:
	WeldVertMouseProc(EditMeshMod* mod, IObjParam *i) : MoveModBox(mod,i) {em=mod;ip=i;}		
	BOOL HitTestVerts(IPoint2 &m, ViewExp *vpt,int &v);
	int proc(HWND hwnd, int msg, int point, int flags, IPoint2 m);
	void PostTransformHolding ();
	int UndoStringID() { return IDS_RB_WELDVERTS; }
};

class WeldVertSelectionProcessor : public SubModSelectionProcessor {
protected:
	HCURSOR GetTransformCursor();
	
public:
	WeldVertSelectionProcessor(WeldVertMouseProc *mc, Modifier *m, IObjParam *i) 
		: SubModSelectionProcessor(mc,m,i) { SetSupportTransformGizmo (TRUE); }
};

class WeldVertCMode : public CommandMode {
private:
	ChangeFGObject fgProc;
	WeldVertSelectionProcessor mouseProc;
	WeldVertMouseProc eproc;
	EditMeshMod* em;

public:
	WeldVertCMode(EditMeshMod* mod, IObjParam *i) :
		fgProc(mod), mouseProc(&eproc,mod,i), eproc(mod,i) {em=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_WELDVERT; }
	MouseCallBack *MouseProc(int *numPoints) { *numPoints=2; return &mouseProc; }
	ChangeForegroundCallback *ChangeFGProc() { return &fgProc; }
	BOOL ChangeFG( CommandMode *oldMode ) { return oldMode->ChangeFGProc() != &fgProc; }
	void EnterMode();
	void ExitMode();
};

/*
class WeldToCMode : public MoveModBoxCMode {
public:
	EditMeshMod* em;

	WeldToCMode (EditMeshMod *mod, IObjParam *i) : MoveModBoxCMode (mod,i) { em=mod; }
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_WELDVERT; }
	void PostTransformHolding ();
	void EnterMode();
	void ExitMode();
};
*/

class FlipNormProc : public PickFaceMouseProc {
public:
	FlipNormProc (EditMeshMod *mod, IObjParam *i) : PickFaceMouseProc (mod,i) {}
	void FacePick (EditMeshData *meshData, DWORD face, float *bary);
};

class FlipNormCMode : public CommandMode {
private:
	ChangeFGObject fgProc;		
	FlipNormProc proc;
	EditMeshMod* em;

public:
	FlipNormCMode(EditMeshMod* mod, IObjParam *i) : fgProc(mod), proc(mod,i) {em=mod;}
	int Class() { return MODIFY_COMMAND; }
	int ID() { return CID_FLIPNORM; }
	MouseCallBack *MouseProc(int *numPoints) {*numPoints=1; return &proc;}
	ChangeForegroundCallback *ChangeFGProc() {return &fgProc;}
	BOOL ChangeFG(CommandMode *oldMode) {return oldMode->ChangeFGProc()!= &fgProc;}
	void EnterMode();
	void ExitMode();
};

class EditMeshDeleteEvent : public EventUser {
public:
	EditMeshMod *em;

	void Notify() {if (em) em->DeleteSelected();}
	void SetEditMeshMod(EditMeshMod *e) {em=e;}
};
extern EditMeshDeleteEvent delEvent;

// --- Restore Objects -----------------------------------------

class CueLocalRestore : public RestoreObj {
public:
	EditMeshMod *emesh;

	CueLocalRestore (EditMeshMod *em) { emesh = em; }
	void Restore(int isUndo) { emesh->DragMoveRestore(); }
	void Redo() { }
	TSTR Description() {return TSTR(_T("Cue internal Restore"));}
	int Size() { return sizeof(int) + sizeof(void *); }
};

class MeshSelectRestore : public RestoreObj {
public:
	BitArray undo, redo;
	EditMeshData *meshData;
	EditMeshMod *mod;
	DWORD selLevel;
	TimeValue t;

	MeshSelectRestore (EditMeshData * md, EditMeshMod * mm);
	MeshSelectRestore (EditMeshData * md, EditMeshMod * mm, DWORD selLev);
	void Restore(int isUndo);
	void Redo();
	int Size() { return 2*sizeof(void *) + 2*sizeof(BitArray) + sizeof(DWORD) + sizeof(TimeValue); }
	TSTR Description() { return TSTR(_T("Edit Mesh Selection")); }
};

class VertexEditRestore : public RestoreObj {
public:
	Tab<VertMove> oMove, nMove;
	Tab<Point3> oCreate, nCreate;
	Tab<VertMove> oClone, nClone;
	EditMeshData *meshData;
	EditMeshMod	 *mod;

	~VertexEditRestore() { }
	VertexEditRestore(EditMeshData* md, EditMeshMod* mod);
	void Restore(int isUndo);
	void Redo();
	int Size() { return 2*sizeof(void *) + 6*sizeof(Tab<Point3>); }
			
	TSTR Description() { return TSTR(_T("Move Vertices")); }
};

// This one is memory-heavy, but can cope with anything.
class MeshEditRestore : public RestoreObj {
public:
	MeshDelta	omdelta, nmdelta;
	EditMeshData *meshData;
	EditMeshMod * mod;
	DWORD changeFlags;
	Tab<DWORD> mapChanges;
	bool updateMD;

	~MeshEditRestore() {};
	MeshEditRestore (EditMeshData* md, EditMeshMod *mod, MeshDelta & changer);
	MeshEditRestore (EditMeshData* md, EditMeshMod *mod, DWORD cF);
	MeshEditRestore (EditMeshData* md, EditMeshMod *mod);
	void Restore(int isUndo);
	void Redo();
	int Size () { return 2*sizeof(MeshDelta) + 2*sizeof (void *) + sizeof(DWORD); }
	TSTR Description() { return TSTR(_T("Mesh Topological Edit")); }
};

class VertexHideRestore : public RestoreObj {
public:
	BitArray hide;
	BitArray rhide;
	EditMeshData *meshData;
	EditMeshMod	 *mod;
	TimeValue t;

	~VertexHideRestore() {};
	VertexHideRestore(EditMeshData* md, EditMeshMod* mod);
	void Restore(int isUndo);
	void Redo();
	int Size() { return 1; }

	TSTR Description() { return TSTR(_T("Hide Vertices")); }
};

class FaceChangeRestore : public RestoreObj {
public:
	Tab<FaceChange> attribs;
	Tab<FaceChange> rattribs;

	EditMeshData *meshData;
	EditMeshMod	 *mod;		

	~FaceChangeRestore() {};
	FaceChangeRestore(EditMeshData* md, EditMeshMod* mod);
	void Restore(int isUndo);
	void Redo();
	int Size() { return 2*sizeof(Tab<FaceChange>); }

	TSTR Description() { return TSTR(_T("Face attributes")); }
};

class TransformPlaneRestore : public RestoreObj {
public:
	Point3 oldSliceCenter, newSliceCenter;
	Quat oldSliceRot, newSliceRot;
	float oldSliceSize, newSliceSize;
	EditMeshMod *em;
	TransformPlaneRestore (EditMeshMod *emm);
	void Restore (int isUndo);
	void Redo ();
	int Size () {
		return 2*(sizeof(Point3) + sizeof(Quat) + sizeof(float))
			+ sizeof (EditMeshMod *);
	}
	TSTR Description () { return TSTR (_T("Slice Plane move")); }
};

// In EdMUI.cpp:
BOOL GetCloneObjectName (Interface *ip, TSTR &name);

// In EditMops.cpp:
void ExplodeToObjects (Mesh *mesh, float thresh, INode *node, TSTR &name,
					   IObjParam *ip, MeshDelta *md, AdjFaceList *af, BOOL selFaces);
BOOL CreateCurveFromMeshEdges (Mesh & mesh, INode *onode, Interface *ip, AdjEdgeList *ae,
							   TSTR & name, BOOL curved, BOOL ignoreHiddenEdges);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editspl.cpp ===
/**********************************************************************
 *<
	FILE: editspl.cpp

	DESCRIPTION:  Edit BezierShape OSM

	CREATED BY: Tom Hudson, Dan Silva & Rolf Berteig

	HISTORY: created 25 April, 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "editspl.h"
#include "nsclip.h"

// Uncomment this for boolean debugging
// (Leaves poly fragments without deleting unused or welding them)
//#define DEBUGBOOL 1

// Uncomment this for vert mapper debugging
//#define VMAP_DEBUG 1

// Our temporary prompts last 2 seconds:
#define PROMPT_TIME 2000

// in mods.cpp
extern HINSTANCE hInstance;

// A handy zero point
static Point3 zeroPoint(0,0,0);

HWND				EditSplineMod::hSelectPanel    = NULL;
HWND				EditSplineMod::hOpsPanel       = NULL;
HWND				EditSplineMod::hSurfPanel      = NULL;
BOOL				EditSplineMod::rsSel           = TRUE;
BOOL				EditSplineMod::rsOps           = TRUE;
BOOL				EditSplineMod::rsSurf          = TRUE;
IObjParam*          EditSplineMod::ip              = NULL;
MoveModBoxCMode*    EditSplineMod::moveMode        = NULL;
RotateModBoxCMode*  EditSplineMod::rotMode 	       = NULL;
UScaleModBoxCMode*  EditSplineMod::uscaleMode      = NULL;
NUScaleModBoxCMode* EditSplineMod::nuscaleMode     = NULL;
SquashModBoxCMode *	EditSplineMod::squashMode      = NULL;
SelectModBoxCMode*  EditSplineMod::selectMode      = NULL;
OutlineCMode*		EditSplineMod::outlineMode     = NULL;
FilletCMode*		EditSplineMod::filletMode      = NULL;
ESChamferCMode*		EditSplineMod::chamferMode     = NULL;
SegBreakCMode*		EditSplineMod::segBreakMode    = NULL;
SegRefineCMode*		EditSplineMod::segRefineMode   = NULL;
CrossInsertCMode*	EditSplineMod::crossInsertMode = NULL;
VertConnectCMode*	EditSplineMod::vertConnectMode = NULL;
VertInsertCMode*	EditSplineMod::vertInsertMode  = NULL;
CreateLineCMode*	EditSplineMod::createLineMode  = NULL;
BooleanCMode*		EditSplineMod::booleanMode     = NULL;
TrimCMode*			EditSplineMod::trimMode        = NULL;
ExtendCMode*		EditSplineMod::extendMode      = NULL;
BOOL               	EditSplineMod::inOutline       = FALSE;
BOOL               	EditSplineMod::inFillet        = FALSE;
BOOL               	EditSplineMod::inChamfer       = FALSE;
BOOL               	EditSplineMod::inSegBreak      = FALSE;
ISpinnerControl*	EditSplineMod::outlineSpin     = NULL;
ISpinnerControl*	EditSplineMod::filletSpin      = NULL;
ISpinnerControl*	EditSplineMod::chamferSpin     = NULL;
ISpinnerControl*	EditSplineMod::weldSpin        = NULL;
ISpinnerControl*	EditSplineMod::divSpin         = NULL;
ISpinnerControl*	EditSplineMod::crossSpin       = NULL;
ISpinnerControl*	EditSplineMod::matSpin         = NULL;

//2-1-99 watje
ISpinnerControl*	EditSplineMod::selectAreaSpin  = NULL;

ICustButton *		EditSplineMod::iUnion          = NULL;
ICustButton *		EditSplineMod::iSubtraction    = NULL;
ICustButton *		EditSplineMod::iIntersection   = NULL;
ICustButton *		EditSplineMod::iMirrorHorizontal = NULL;
ICustButton *		EditSplineMod::iMirrorVertical   = NULL;
ICustButton *		EditSplineMod::iMirrorBoth     = NULL;
int                 EditSplineMod::boolType        = BOOL_UNION;
int                 EditSplineMod::mirrorType      = MIRROR_HORIZONTAL;
PickSplineAttach	EditSplineMod::pickCB;
BOOL				EditSplineMod::segUIValid		= TRUE;
int					EditSplineMod::condenseMat		= FALSE;
int					EditSplineMod::attachMat		= ATTACHMAT_IDTOMAT;

// Some trim/extend stuff
#define TRIM_PROJECT_VIEW 0
#define TRIM_PROJECT_GRID 1
#define TRIM_PROJECT_3D 2

// Constants.
//
#define eNO_PTS_FOUND			1
#define eNO_EXTEND_CLOSED_SPL	2
#define eCLOSED_SPL_REQ_2_PTS	4
#define mSPLINE_DELETED			8
//#define mSHAPE_DELETED			16

static int g_trimErrorCode = 0;	// See DisplayMessage() for bit meanings.

//watje
RefineConnectCMode*		EditSplineMod::refineConnectMode   = NULL;
BindCMode*		EditSplineMod::bindMode   = NULL;

// Select by material parameters
static int sbmParams[2]     = {1,1};

// Checkbox items for rollup pages
static BOOL polyMirrorCopy = 0;
static BOOL mirrorAboutPivot = 0;
static BOOL trimInfinite = 0;
static int detachSameShape = 0;
static int detachCopy = 0;
static int detachReorient = 0;
static int attachReorient = 0;
static int centeredOutline = 0;
static int explodeToObjects = 0;
static int lockedHandles = 0;
static int lockType = IDC_LOCKALIKE;
static BOOL showSelected = FALSE;
static int segDivisions = 1;

// The weld threshold
static float weldThreshold = 0.1f;

// The boolean operation
static int boolOperation = BOOL_UNION;

// The crossing threshold
static float crossThreshold = 0.1f;

// This is a special override value which allows us to hit-test on
// any sub-part of a shape

int splineHitOverride = 0;	// If zero, no override is done

void SetSplineHitOverride(int value) {
	splineHitOverride = value;
	}

void ClearSplineHitOverride() {
	splineHitOverride = 0;
	}

/*-------------------------------------------------------------------*/

static HIMAGELIST hSplineImages = NULL;

static void LoadESImages() {
	if (hSplineImages) return;

	HBITMAP hBitmap, hMask;
	hSplineImages = ImageList_Create(24, 23, ILC_COLOR|ILC_MASK, 6, 0);
	hBitmap     = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_SPLINESELTYPES));
	hMask       = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_SPLINESELMASK));
	ImageList_Add(hSplineImages,hBitmap,hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
}

/*-------------------------------------------------------------------*/

// Right-click menu support
class ESRightMenu : public RightClickMenu {
	private:
		EditSplineMod *es;
	public:
		void Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m);
		void Selected(UINT id);
		void SetMod(EditSplineMod *es) { this->es = es; }
	};

void ESRightMenu::Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m) {
	switch(es->GetSubobjectLevel()) {
		case ES_VERTEX:
			if(es->RememberVertThere(hWnd, m)) {
				int oldType = -1;
				int flags1, flags2, flags3, flags4;
				flags1 = flags2 = flags3 = flags4 = MF_STRING;
				switch(es->rememberedData) {
					case KTYPE_AUTO:
						flags1 |= MF_CHECKED;
						break;
					case KTYPE_CORNER:
						flags2 |= MF_CHECKED;
						break;
					case KTYPE_BEZIER:
						flags3 |= MF_CHECKED;
						break;
					case KTYPE_BEZIER_CORNER:
						flags4 |= MF_CHECKED;
						break;
					}
				manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
				manager->AddMenu(this, flags1, KTYPE_AUTO, GetString(IDS_TH_SMOOTH));
				manager->AddMenu(this, flags2, KTYPE_CORNER, GetString(IDS_TH_CORNER));
				manager->AddMenu(this, flags3, KTYPE_BEZIER, GetString(IDS_TH_BEZIER));
				manager->AddMenu(this, flags4, KTYPE_BEZIER_CORNER, GetString(IDS_TH_BEZIERCORNER));
				}
			break;
		case ES_SEGMENT:
			if(es->RememberSegThere(hWnd, m)) {
				int oldType = -1;
				int flags1, flags2;
				flags1 = flags2 = MF_STRING;
				switch(es->rememberedData) {
					case LTYPE_CURVE:
						flags1 |= MF_CHECKED;
						break;
					case LTYPE_LINE:
						flags2 |= MF_CHECKED;
						break;
					}
				manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
				manager->AddMenu(this, flags1, LTYPE_CURVE, GetString(IDS_TH_CURVE));
				manager->AddMenu(this, flags2, LTYPE_LINE, GetString(IDS_TH_LINE));
				}
			break;
		case ES_SPLINE:
			if(es->RememberPolyThere(hWnd, m)) {
				int oldType = -1;
				int flags1, flags2;
				flags1 = flags2 = MF_STRING;
				switch(es->rememberedData) {
					case LTYPE_CURVE:
						flags1 |= MF_CHECKED;
						break;
					case LTYPE_LINE:
						flags2 |= MF_CHECKED;
						break;
					}
				manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
				manager->AddMenu(this, flags1, LTYPE_CURVE, GetString(IDS_TH_CURVE));
				manager->AddMenu(this, flags2, LTYPE_LINE, GetString(IDS_TH_LINE));
				}
			break;
		}
	}

void ESRightMenu::Selected(UINT id) {
	switch(es->GetSubobjectLevel()) {
		case ES_VERTEX:
			es->SetRememberedVertType((int)id);
			break;
		case ES_SEGMENT:
			es->SetRememberedSegType((int)id);
			break;
		case ES_SPLINE:
			es->SetRememberedPolyType((int)id);
			break;
		}
	}

ESRightMenu esMenu;

// Delete interface support

class ESDeleteUser : public EventUser {
	private:
		EditSplineMod *es;
	public:
		void Notify();
		void SetMod(EditSplineMod *es) { this->es = es; }
	};

void ESDeleteUser::Notify() {
	switch(es->GetSubobjectLevel()) {
		case ES_VERTEX:
			es->DoVertDelete();
			break;
		case ES_SEGMENT:
			es->DoSegDelete();
			break;
		case ES_SPLINE:
			es->DoPolyDelete();
			break;
		}
	}

ESDeleteUser esDel;

/*-------------------------------------------------------------------*/

// This function checks the current command mode and resets it to CID_OBJMOVE if
// it's one of our command modes

static
void CancelEditSplineModes(IObjParam *ip) {
	switch(ip->GetCommandMode()->ID()) {
		case CID_OUTLINE:
		case CID_SEGBREAK:
		case CID_SEGREFINE:
		case CID_VERTCONNECT:
		case CID_VERTINSERT:
		case CID_BOOLEAN:
		case CID_CREATELINE:
		case CID_CROSSINSERT:
		case CID_FILLET:
		case CID_CHAMFER:
		case CID_TRIM:
		case CID_EXTEND:
//watje			
		case CID_REFINECONNECT:
		case CID_SPLINEBIND:

		case CID_STDPICK:
			ip->SetStdCommandMode( CID_OBJMOVE );
			break;
		}
	}

// If there isn't just 1 spline selected in the shape, and the boolean mode
// is active, turn it off!
static
void MaybeCancelBooleanMode(EditSplineMod *mod) {
	if(!mod->ip)
		return;
	if(mod->ip->GetCommandMode()->ID() == CID_BOOLEAN) {
		mod->ip->SetStdCommandMode( CID_OBJMOVE );
		}
	}

/*-------------------------------------------------------------------*/

// Vertex-to-knot selection mapper
static BitArray &KnotSelFromVertSel(BitArray &vsel) {
	int knots = vsel.GetSize() / 3;
	static BitArray ksel;
	ksel.SetSize(knots);
	for(int i = 0; i < knots; ++i)
		ksel.Set(i, vsel[i*3+1]);
	return ksel;
	}

/*-------------------------------------------------------------------*/

static
BOOL IsCompatible(BezierShape *shape, int poly, BitArray *VSel, BitArray *SSel) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(VSel) {
		if(shape->splines[poly]->Verts() != VSel->GetSize())
			return FALSE;
		}
	if(SSel) {
		if(shape->splines[poly]->Segments() != SSel->GetSize())
			return FALSE;
		}
	return TRUE;
	}

/*-------------------------------------------------------------------*/		

// Delete all selected segments
// Returns TRUE if the operation results in the polygon being deleted
static int DeleteSelSegs(BezierShape *shape, int poly) {
	Spline3D *spline = shape->splines[poly];
//	BitArray& vsel = shape->vertSel[poly];
//	BitArray& ssel = shape->segSel[poly];
	int segs = spline->Segments();
	int verts = spline->Verts();
	int altered = 0;
	for(int s = segs-1; s >= 0; --s) {
		BitArray& vsel = shape->vertSel[poly];
		BitArray& ssel = shape->segSel[poly];
		if(ssel[s]) {
			altered = 1;
			if(spline->Closed()) {
				if(s == (spline->KnotCount()-1)) {	// deletion at end segment -- Just open the spline!
					delete_at_last_segment:
					altered = 1;
					spline->SetOpen();
					ssel.SetSize(spline->Segments(),1);
					}
				else
				if(s == 0) {			// Delete at first segment
					SplineKnot dupKnot = spline->GetKnot(0);
					spline->AddKnot(dupKnot, -1);
					spline->DeleteKnot(0);
					spline->SetOpen();
					vsel.Rotate(LEFT_BITSHIFT, 3);
					ssel.Rotate(LEFT_BITSHIFT, 1);
					ssel.SetSize(spline->Segments(),1);
					}
				else {					// Deletion somewhere in the middle
					// First, rotate the spline so that the deletion point is the last one!
					int rotations = 0;
					int lastSeg = spline->KnotCount() - 1;
					while(s < (lastSeg)) {
						SplineKnot dupKnot = spline->GetKnot(lastSeg);
						spline->DeleteKnot(lastSeg);
						spline->AddKnot(dupKnot, 0);
						rotations++;
						s++;
						}
					vsel.Rotate(RIGHT_BITSHIFT, rotations*3);
					ssel.Rotate(RIGHT_BITSHIFT, rotations);
					s = lastSeg;
					goto delete_at_last_segment;
					}
				}
			else {
				// If it's the only segment, blow the polygon away!
				if(spline->Segments() == 1) {
					shape->DeleteSpline(poly);
//5-1-99 watje
					shape->UpdateBindList();
					return TRUE;				// It's TRUE -- We deleted the spline!
					}
				if(s==0) {
					spline->DeleteKnot(0);
					vsel.Shift(LEFT_BITSHIFT, 3);
					vsel.SetSize(spline->Verts(),1);
					ssel.Shift(LEFT_BITSHIFT, 1);
					ssel.SetSize(spline->Segments(),1);
					}
				else
				if(s == (spline->KnotCount()-2)) {
					spline->DeleteKnot(s+1);
					vsel.SetSize(spline->Verts(),1);
					ssel.SetSize(spline->Segments(),1);
					}
				else {
					int i;
					int newPolySize = spline->KnotCount() - s - 1;
					// OK, We're deleting at a point in the middle -- Copy end points off to a new spline, then
					// delete them from the original!
					Spline3D *newSpline = shape->NewSpline();
					int knots = spline->KnotCount();
					for(i = s + 1; i < knots; ++i) {
						SplineKnot dupKnot = spline->GetKnot(i);
						newSpline->AddKnot(dupKnot, -1);
						}
					for(i = knots-1; i > s; --i)
						spline->DeleteKnot(i);
					// Adjust selection data for this spline
					vsel.SetSize(spline->Verts(),1);
					ssel.SetSize(spline->Segments(),1);
					// Don't forget to create a new selection record for this new spline!
					shape->vertSel.Insert(shape->splineCount - 1, newPolySize * 3);
					shape->segSel.Insert(shape->splineCount - 1, newPolySize - 1);
					shape->polySel.Insert(shape->splineCount - 1);
					}
				}
			}
		}
	if(altered)	{
		spline->ComputeBezPoints();
//3-31-99 watje
		shape->UpdateBindList();
		shape->InvalidateGeomCache();
		}
	return FALSE;	// The poly's still there
	}

/*-------------------------------------------------------------------*/		

// Segment Detach Types:
#define SDT_COPY_MASK (1<<0)
#define SDT_SAME_MASK (1<<1)

#define SDT_DETACH		0	// Detach to other shape
#define SDT_COPY		(SDT_COPY_MASK) 	// Copy to other shape
#define SDT_DETACH_SAME	(SDT_SAME_MASK)		// Detach to same shape
#define SDT_COPY_SAME	(SDT_COPY_MASK | SDT_SAME_MASK)	// Copy to same shape

// Handle the basic mechanics of detaching segments
static int HandleSegDetach(BezierShape *shape, BezierShape *toShape, int type, int poly) {
	Spline3D *spline = shape->splines[poly];
	int segments = spline->Segments();
	int segsSelected = shape->segSel[poly].NumberSet();
	// If all segments selected, copy the whole polygon!
	if(segsSelected == segments) {
		toShape->InsertSpline(spline, toShape->SplineCount());
		}
	else {
		int end = segments;
		for(int seg = 0; seg < end; ++seg) {
			if(shape->segSel[poly][seg]) {
				Spline3D newSpline;
				if(seg == 0 && spline->Closed()) {
					backLoop:
					if(shape->segSel[poly][--end]) {
						SplineKnot addKnot = spline->GetKnot(end);
						newSpline.AddKnot(addKnot, 0);
						goto backLoop;
						}
					}
				SplineKnot addKnot = spline->GetKnot(seg);
				newSpline.AddKnot(addKnot, -1);

				loop:
				seg++;
				if(spline->Closed())
					seg %= segments;
				addKnot = spline->GetKnot(seg);
				newSpline.AddKnot(addKnot, -1);
				if(seg > 0 && seg < end && shape->segSel[poly][seg])
					goto loop;

				// Finish up the spline!
				newSpline.ComputeBezPoints();
				toShape->InsertSpline(&newSpline, toShape->SplineCount());
				// If copying to same shape, select the copied spline's segments (always the last)
				if(type == SDT_COPY_SAME)
					toShape->segSel[toShape->splineCount - 1].SetAll();
//3-31-99 watje
				shape->UpdateBindList();
				shape->InvalidateGeomCache();
				if(toShape != shape)
					toShape->InvalidateGeomCache();

				// Special termination test for wraparound
				if(seg == 0)
					seg = end;
				}
			}
		}
	// Call the segment delete function
	if(type != SDT_COPY && type != SDT_COPY_SAME)
		return DeleteSelSegs(shape, poly);	// Spline may be deleted
	else {
		// Clear the spline's segment selection set
		if(type == SDT_COPY_SAME)
			shape->segSel[poly].ClearAll();
		}

	return FALSE;	// Spline not deleted
	}

/*-------------------------------------------------------------------*/

static
TSTR detachName;

static
BOOL CALLBACK DetachDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	TCHAR tempName[256];
	switch(message) {
		case WM_INITDIALOG:
			SetDlgItemText(hDlg, IDC_DETACH_NAME, detachName);
			SendMessage(GetDlgItem(hDlg, IDC_DETACH_NAME), EM_SETSEL, 0, -1);
			SetFocus(GetDlgItem(hDlg, IDC_DETACH_NAME));
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK:
					GetDlgItemText(hDlg, IDC_DETACH_NAME, tempName, 255);
					detachName = TSTR(tempName);
					EndDialog(hDlg, 1);
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}

static
int GetDetachOptions(IObjParam *ip, TSTR& newName) {
	detachName = newName;
	ip->MakeNameUnique(detachName);	
	if(DialogBox(hInstance, MAKEINTRESOURCE(IDD_DETACH), ip->GetMAXHWnd(), (DLGPROC)DetachDialogProc)==1) {
		newName = detachName;
		return 1;
		}
	return 0;
	}

/*-------------------------------------------------------------------*/

static EditSplineClassDesc editSplineDesc;
extern ClassDesc* GetEditSplineModDesc() { return &editSplineDesc; }

void EditSplineClassDesc::ResetClassParams(BOOL fileReset)
	{
	sbmParams[0]   = 1;
	sbmParams[1]   = 1;
	polyMirrorCopy = 0;
	mirrorAboutPivot = 0;
	trimInfinite = 0;
	detachSameShape = 0;
	detachCopy = 0;
	detachReorient = 0;
	segDivisions = 1;
	attachReorient = 0;
	centeredOutline = 0;
	explodeToObjects = 0;
	lockedHandles = 0;
	showSelected = FALSE;
	lockType = IDC_LOCKALIKE;
	weldThreshold = 0.1f;
	crossThreshold = 0.1f;
	boolOperation = BOOL_UNION;
	EditSplineMod::condenseMat = FALSE;
	EditSplineMod::attachMat = ATTACHMAT_IDTOMAT;
	}

/*-------------------------------------------------------------------*/

ShapePointTab::ShapePointTab() {
	polys = 0;
	pUsed = NULL;
	ptab = NULL;
	ktab = NULL;
	ltab = NULL;
	}

ShapePointTab::~ShapePointTab() {
	if(pUsed)
		delete [] pUsed;
	if(ptab)
		delete [] ptab;
	if(ktab)
		delete [] ktab;
	if(ltab)
		delete [] ltab;
	}

void ShapePointTab::Empty() {
	if(pUsed)
		delete [] pUsed;
	pUsed = NULL;
	if(ptab)
		delete [] ptab;
	ptab = NULL;
	if(ktab)
		delete [] ktab;
	ktab = NULL;
	if(ltab)
		delete [] ltab;
	ltab = NULL;
	polys = 0;
	}

void ShapePointTab::Zero() {
	int i;
	for(int poly = 0; poly < polys; ++poly) {
		pUsed[poly] = 0;

		Point3Tab &pt = ptab[poly];
		IntTab &kt = ktab[poly];
		IntTab &st = ltab[poly];

		int points = pt.Count();
		int knots = kt.Count();
		int segments = st.Count();
		Point3 zero(0, 0, 0);

		for(i = 0; i < points; ++i)
			pt[i] = zero;
		for(i = 0; i < knots; ++i)
			kt[i] = 0;
		for(i = 0; i < segments; ++i)
			st[i] = 0;
		}
	}

void ShapePointTab::MakeCompatible(BezierShape& shape,int clear) {
	Point3 zero(0,0,0);
	int izero = 0;
	if(polys == shape.splineCount) {
		for(int i=0; i<polys; ++i) {
			int size = shape.splines[i]->Verts();
			int knots = shape.splines[i]->KnotCount();
			Point3Tab& tab = ptab[i];
			IntTab& kttab = ktab[i];
			IntTab& lttab = ltab[i];
			if(clear) {
				pUsed[i] = 0;
				tab.Delete(0,tab.Count());
				kttab.Delete(0,kttab.Count());
				lttab.Delete(0,lttab.Count());
				}
			if ( tab.Count() > size ) {
				int diff = tab.Count() - size;
				tab.Delete( tab.Count() - diff, diff );
				diff = kttab.Count() - knots;		
				kttab.Delete( kttab.Count() - diff, diff );		
				lttab.Delete( lttab.Count() - diff, diff );		
				}
			else
			if ( tab.Count() < size ) {
				int diff = size - tab.Count();
				tab.Resize( size );
				for ( int j = 0; j < diff; j++ )
					tab.Append(1,&zero);
				diff = knots - kttab.Count();
				kttab.Resize( knots );
				lttab.Resize( knots );
				for ( j = 0; j < diff; j++ ) {
					kttab.Append(1,&izero);
					lttab.Append(1,&izero);
					}
				}
			}
		}
	else {
		if(pUsed)
			delete [] pUsed;
		if(ptab)
			delete [] ptab;
		if(ktab)
			delete [] ktab;
		if(ltab)
			delete [] ltab;
		polys = shape.splineCount;
		pUsed = new int[polys];
		ptab = new Point3Tab[polys];
		ktab = new IntTab[polys];
		ltab = new IntTab[polys];
//		closures.SetSize(polys);
		for(int i=0; i<polys; ++i) {
			pUsed[i] = 0;
			Point3Tab& tab = ptab[i];
			IntTab& kttab = ktab[i];
			IntTab& lttab = ltab[i];
			int size = shape.splines[i]->Verts();
			for ( int j = 0; j < size; j++ )
				tab.Append(1,&zero);
			int knots = shape.splines[i]->KnotCount();
			tab.Resize( size );
			kttab.Resize( knots );
			lttab.Resize( knots );
			for ( j = 0; j < knots; j++ ) {
				kttab.Append(1,&izero);
				lttab.Append(1,&izero);
				}
			}
		}
	}

ShapePointTab& ShapePointTab::operator=(ShapePointTab& from) {
	if(pUsed)
		delete [] pUsed;
	if(ptab)
		delete [] ptab;
	if(ktab)
		delete [] ktab;
	if(ltab)
		delete [] ltab;
	polys = from.polys;
	pUsed = new int[polys];
	ptab = new Point3Tab[polys];
	ktab = new IntTab[polys];
	ltab = new IntTab[polys];
	for(int poly = 0; poly < polys; ++poly) {
		pUsed[poly] = from.pUsed[poly];
		ptab[poly] = from.ptab[poly];
		ktab[poly] = from.ktab[poly];
		ltab[poly] = from.ltab[poly];
		}
//	closures = from.closures;
	return *this;
	}

BOOL ShapePointTab::IsCompatible(BezierShape &shape) {
	if(polys != shape.splineCount)
		return FALSE;
	for(int poly = 0; poly < polys; ++poly) {
		if(ptab[poly].Count() != shape.splines[poly]->Verts())
			return FALSE;
		if(ktab[poly].Count() != shape.splines[poly]->KnotCount())
			return FALSE;
		}
	return TRUE;
	}

void ShapePointTab::RescaleWorldUnits(float f) {
	Matrix3 stm = ScaleMatrix(Point3(f, f, f));
	int i;
	for(int poly = 0; poly < polys; ++poly) {
		Point3Tab &pt = ptab[poly];
		int points = pt.Count();
		for(i = 0; i < points; ++i)
			pt[i] = pt[i] * stm;
		}
	}

#define SPT_POLYDATA_CHUNK	0x1000

IOResult ShapePointTab::Save(ISave *isave) {	
	int i, n;
	ULONG nb;
	isave->BeginChunk(SPT_POLYDATA_CHUNK);
	isave->Write(&polys,sizeof(int),&nb);
	for(int poly = 0; poly < polys; ++poly) {
		n = pUsed[poly];
		isave->Write(&n,sizeof(int),&nb);
		Point3Tab &pptab = ptab[poly];
		int count = pptab.Count();
		isave->Write(&count,sizeof(int),&nb);
		for(i = 0; i < count; ++i)
			isave->Write(&pptab[i],sizeof(Point3),&nb);
		IntTab &iktab = ktab[poly];
		count = iktab.Count();
		isave->Write(&count,sizeof(int),&nb);
		for(i = 0; i < count; ++i)
			isave->Write(&iktab[i],sizeof(int),&nb);
		IntTab &iltab = ltab[poly];
		count = iltab.Count();
		isave->Write(&count,sizeof(int),&nb);
		for(i = 0; i < count; ++i)
			isave->Write(&iltab[i],sizeof(int),&nb);
		}
	isave->EndChunk();
	return IO_OK;
	}

IOResult ShapePointTab::Load(ILoad *iload) {	
	int i, n;
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SPT_POLYDATA_CHUNK:
				res = iload->Read(&polys,sizeof(int),&nb);
				pUsed = new int[polys];
				ptab = new Point3Tab[polys];
				ktab = new IntTab[polys];
				ltab = new IntTab[polys];
				for(int poly = 0; poly < polys; ++poly) {
					iload->Read(&n,sizeof(int),&nb);
					pUsed[poly] = n;
					Point3Tab &pptab = ptab[poly];
					int count;
					iload->Read(&count,sizeof(int),&nb);
					Point3 workpt;
					for(i = 0; i < count; ++i) {
						iload->Read(&workpt,sizeof(Point3),&nb);
						pptab.Append(1,&workpt);
						}
					IntTab &iktab = ktab[poly];
					iload->Read(&count,sizeof(int),&nb);
					for(i = 0; i < count; ++i) {
						iload->Read(&n,sizeof(int),&nb);
						iktab.Append(1,&n);
						}
					IntTab &iltab = ltab[poly];
					iload->Read(&count,sizeof(int),&nb);
					for(i = 0; i < count; ++i) {
						iload->Read(&n,sizeof(int),&nb);
						iltab.Append(1,&n);
						}
					}
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/

void ShapeVertexDelta::SetSize(BezierShape& shape, BOOL load)
	{
	dtab.MakeCompatible(shape, FALSE);
	
	// Load it if necessary
	if(load) {
		for(int poly = 0; poly < shape.splineCount; ++poly) {
			Spline3D *spline = shape.splines[poly];
			int verts = spline->Verts();
			int knots = spline->KnotCount();
//			dtab.pUsed[poly] = 1;	// ???
			Point3Tab& delta = dtab.ptab[poly];
			IntTab& kdelta = dtab.ktab[poly];
			IntTab& ldelta = dtab.ltab[poly];
			for(int i = 0; i < verts; ++i)
				delta[i] = spline->GetVert(i);
			for(i = 0; i < knots; ++i) {
				kdelta[i] = spline->GetKnotType(i);
				ldelta[i] = spline->GetLineType(i);
				}
//			spline->ComputeBezPoints();
			}
//		shape.GetClosures(dtab.closures);
		}
	}

void ShapeVertexDelta::Apply(BezierShape &shape)
	{
	// This does nothing if the number of verts hasn't changed in the mesh.
	SetSize(shape, FALSE);

	// Apply the deltas
//	shape.SetClosures(dtab.closures);
	for(int poly = 0; poly < shape.splineCount; ++poly) {
//		if(dtab.pUsed[poly]) {
			Spline3D *spline = shape.splines[poly];
			int verts = spline->Verts();
			int knots = spline->KnotCount();
			Point3Tab& delta = dtab.ptab[poly];
			IntTab& kdelta = dtab.ktab[poly];
			IntTab& ldelta = dtab.ltab[poly];
			for(int i = 0; i < verts; ++i)
				spline->SetVert(i,spline->GetVert(i) + delta[i]);
			for(i = 0; i < knots; ++i) {
				spline->SetKnotType(i,spline->GetKnotType(i) ^ kdelta[i]);
				spline->SetLineType(i,spline->GetLineType(i) ^ ldelta[i]);
				}
			spline->ComputeBezPoints();
//			DebugPrint(_T("Poly %d used"),poly);
//			}
//		else
//			DebugPrint(_T("Poly %d not used"),poly);
		}
//watje
	shape.UpdateBindList();

	shape.InvalidateGeomCache();
	}

void ShapeVertexDelta::UnApply(BezierShape &shape)
	{
	// This does nothing if the number of verts hasn't changed in the mesh.
	SetSize(shape, FALSE);

	// Apply the deltas
//	shape.SetClosures(dtab.closures);
	for(int poly = 0; poly < shape.splineCount; ++poly) {
//		if(dtab.pUsed[poly]) {
			Spline3D *spline = shape.splines[poly];
			int verts = spline->Verts();
			int knots = spline->KnotCount();
			Point3Tab& delta = dtab.ptab[poly];
			IntTab& kdelta = dtab.ktab[poly];
			IntTab& ldelta = dtab.ltab[poly];
			for(int i = 0; i < verts; ++i)
				spline->SetVert(i,spline->GetVert(i) - delta[i]);
			for(i = 0; i < knots; ++i) {
				spline->SetKnotType(i,spline->GetKnotType(i) ^ kdelta[i]);
				spline->SetLineType(i,spline->GetLineType(i) ^ ldelta[i]);
				}
			spline->ComputeBezPoints();
//			DebugPrint(_T("Poly %d used"),poly);
//			}
//		else
//			DebugPrint(_T("Poly %d not used"),poly);
		}
//watje
	shape.UpdateBindList();

	shape.InvalidateGeomCache();
	}

// This function applies the current changes to slave handles and their knots, and zeroes everything else
void ShapeVertexDelta::ApplyHandlesAndZero(BezierShape &shape, int handlePoly, int handleVert) {
	// This does nothing if the number of verts hasn't changed in the mesh.
	SetSize(shape, FALSE);

	Point3 zeroPt(0.0f, 0.0f, 0.0f);

	// Apply the deltas	to just the slave handles
	for(int poly = 0; poly < shape.splineCount; ++poly) {
		if(dtab.pUsed[poly]) {
			Spline3D *spline = shape.splines[poly];
			int verts = spline->Verts();
			int knots = spline->KnotCount();
			Point3Tab& delta = dtab.ptab[poly];
			IntTab& kdelta = dtab.ktab[poly];
			IntTab& ldelta = dtab.ltab[poly];
			for(int i = 0; i < verts; ++i) {
				if(delta[i] != zeroPt) {
					if(!((poly == handlePoly) && (i == handleVert)))
						spline->SetVert(i,spline->GetVert(i) + delta[i]);
					else
						delta[i] = zeroPt;
					}
				}

			for(i = 0; i < knots; ++i) {
				if(kdelta[i])
					spline->SetKnotType(i,spline->GetKnotType(i) ^ kdelta[i]);
				if(ldelta[i])
					spline->SetLineType(i,spline->GetLineType(i) ^ ldelta[i]);
				}
//			spline->ComputeBezPoints();
//			DebugPrint(_T("Poly %d used"),poly);
			}
//		else
//			DebugPrint(_T("Poly %d not used"),poly);
		}
	shape.InvalidateGeomCache();
	}


#define SVD_POINTTAB_CHUNK		0x1000

IOResult ShapeVertexDelta::Save(ISave *isave) {
	isave->BeginChunk(SVD_POINTTAB_CHUNK);
	dtab.Save(isave);
	isave->	EndChunk();
	return IO_OK;
	}

IOResult ShapeVertexDelta::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SVD_POINTTAB_CHUNK:
				res = dtab.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/

EditSplineData::EditSplineData()
	{
	flags = 0;
	tempData = NULL;
	}

EditSplineData::EditSplineData(EditSplineData& esc)
	{
	flags = esc.flags;
	tempData = NULL;
	vertMap = esc.vertMap;
	finalShape = esc.finalShape;
	}


void EditSplineData::Apply(TimeValue t,SplineShape *splShape,int selLevel,BOOL showVertNumbers,BOOL SVNSelectedOnly)
	{
	// Either just copy it from the existing cache or rebuild from previous level!
	if ( !GetFlag(ESD_UPDATING_CACHE) && tempData && tempData->ShapeCached(t) ) {
		splShape->shape.DeepCopy( 
			tempData->GetShape(t),
			PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_DISPLAY|PART_TOPO );		
		splShape->PointsWereChanged();
		}	
	else
	if ( GetFlag(ESD_HASDATA) ) {
		// For old files, which contain exhaustive data to reconstruct the editing process
		// of shapes, we'll have data in the 'changes' table.  If it's there, go ahead and
		// replay the edits, then store the alterations in our new delta format and discard
		// the change table!
		int count = changes.Count();
		if(count) {
//DebugPrint("*** Applying old style (%d) ***\n", count);
			// Store the topology for future reference
			vertMap.Build(splShape->shape);
			finalShape = splShape->shape;
			for(int i = 0; i < count; ++i) {
				ModRecord *rec = changes[i];
				// Record the topo flags
				RecordTopologyTags(&splShape->shape);
				BOOL result = rec->Redo(&splShape->shape,0);
				UpdateChanges(&splShape->shape);
				// If we hit one that didn't play back OK, we need to flush the remainder
				if(!result) {
					for(int j = i; j < count; ++j)
						delete changes[j];
					changes.Delete(i, count - i);
					break;
					}
				}
			splShape->PointsWereChanged();
			// Nuke the changes table
			count = changes.Count();
			for(int k = 0; k < count; ++k)
				delete changes[k];
			changes.Delete(0, count);
			changes.Shrink();
			count = 0;
			}
		else {
			// Adjust the deltas if necessary
			vertMap.UpdateAndApplyDeltas(splShape->shape, finalShape);
			splShape->shape = finalShape;
			}
		// Kind of a waste when there's no animation...		
		splShape->UpdateValidity(GEOM_CHAN_NUM,FOREVER);
		splShape->UpdateValidity(TOPO_CHAN_NUM,FOREVER);
		splShape->UpdateValidity(SELECT_CHAN_NUM,FOREVER);
		splShape->UpdateValidity(SUBSEL_TYPE_CHAN_NUM,FOREVER);
		splShape->UpdateValidity(DISP_ATTRIB_CHAN_NUM,FOREVER);		
		}
	else {	// No data yet -- Store initial required data
//DebugPrint("<<<Storing Initial Data>>>\n");
		vertMap.Build(splShape->shape);
		finalShape = splShape->shape;
		}
	
	splShape->shape.dispFlags = 0;
	switch ( selLevel ) {
		case ES_SPLINE:
			splShape->shape.SetDispFlag(DISP_VERTTICKS|DISP_SELPOLYS);
			break;
		case ES_VERTEX:
			if (showSelected) 
				{
				splShape->shape.SetDispFlag(DISP_VERTTICKS|DISP_SELVERTS|DISP_SELSEGMENTS);
//				shape->dispFlags |= DISP_SELSEGMENTS;
				}
			else
				{
				splShape->shape.SetDispFlag(DISP_VERTTICKS|DISP_SELVERTS);
//				shape->dispFlags &= ~DISP_SELSEGMENTS;
				}

			break;
		case ES_SEGMENT:
			splShape->shape.SetDispFlag(DISP_VERTTICKS|DISP_SELSEGMENTS);			
			break;
		}

	splShape->showVertNumbers = showVertNumbers;
	splShape->SVNSelectedOnly = SVNSelectedOnly;
	
	splShape->shape.selLevel = shapeLevel[selLevel];
	
	if ( GetFlag(ESD_UPDATING_CACHE) ) {
		assert(tempData);
//DebugPrint("*** Updating edit spline cache ***\n");
		tempData->UpdateCache(splShape);
		SetFlag(ESD_UPDATING_CACHE,FALSE);
		}		
	}

void EditSplineData::Invalidate(PartID part,BOOL shapeValid)
	{
	if ( tempData ) {
		tempData->Invalidate(part,shapeValid);
		}
	}

void EditSplineData::BeginEdit(TimeValue t)
	{
	assert(tempData);
	if ( !GetFlag(ESD_HASDATA) )
		SetFlag(ESD_HASDATA,TRUE);
	}

ESTempData *EditSplineData::TempData(EditSplineMod *mod)
	{
	if ( !tempData ) {
		assert(mod->ip);
		tempData = new ESTempData(mod,this);
		}
	return tempData;
	}

void EditSplineData::RescaleWorldUnits(float f) {
	// Scale the deltas inside the vertex map
	vertMap.RescaleWorldUnits(f);
	// Now rescale stuff inside our data structures
	Matrix3 stm = ScaleMatrix(Point3(f, f, f));
	finalShape.Transform(stm);
	}

// Store vertex/poly information in the vertices of the shape so we can tell
// when the topology changes.
void EditSplineData::RecordTopologyTags(BezierShape *shape) {
	// First, stuff all -1's into aux fields
	int polys = shape->SplineCount();
	for(int poly = 0; poly < polys; ++poly) {
		Spline3D *spline = shape->GetSpline(poly);
		int verts = spline->Verts();
		for(int vert = 0; vert < verts; ++vert)
			spline->SetVertAux(vert, 0, 0xffffffff);
		}
	// Now put in our tags
	vertMap.RecordTopologyTags(*shape);
	// And the standard topology tags
	shape->RecordTopologyTags();
	}

/*-------------------------------------------------------------------*/		

class ESChangeVertSetRestore : public RestoreObj {
	public:
		ShapeVSel oldset,newset;
		int index;
		NamedVertSelSetList *setList;

		ESChangeVertSetRestore(NamedVertSelSetList *sl,int ix,ShapeVSel *o) {
			setList = sl; index = ix; oldset = *o;
			}   		
		void Restore(int isUndo) {
			newset = *(setList->sets[index]);
			*(setList->sets[index]) = oldset;
			}
		void Redo() {
			*(setList->sets[index]) = newset;
			}
				
		TSTR Description() {return TSTR(_T("Change Vert Set"));}
	};

class ESChangeSegSetRestore : public RestoreObj {
	public:
		ShapeSSel oldset, newset;
		int index;
		NamedSegSelSetList *setList;

		ESChangeSegSetRestore(NamedSegSelSetList *sl,int ix,ShapeSSel *o) {
			setList = sl; index = ix; oldset = *o;
			}   		
		void Restore(int isUndo) {
			newset = *(setList->sets[index]);
			*(setList->sets[index]) = oldset;
			}
		void Redo() {
			*(setList->sets[index]) = newset;
			}
				
		TSTR Description() {return TSTR(_T("Change Seg Set"));}
	};

class ESChangePolySetRestore : public RestoreObj {
	public:
		ShapePSel oldset, newset;
		int index;
		NamedPolySelSetList *setList;

		ESChangePolySetRestore(NamedPolySelSetList *sl,int ix,ShapePSel *o) {
			setList = sl; index = ix; oldset = *o;
			}   		
		void Restore(int isUndo) {
			newset = *(setList->sets[index]);
			*(setList->sets[index]) = oldset;
			}
		void Redo() {
			*(setList->sets[index]) = newset;
			}
				
		TSTR Description() {return TSTR(_T("Change Poly Set"));}
	};


class ESAppendVertSetRestore : public RestoreObj {
	public:
		ShapeVSel set;
		TSTR name;
		NamedVertSelSetList *setList;
		EditSplineMod *mod;

		ESAppendVertSetRestore(NamedVertSelSetList *sl,EditSplineMod *m) {
			setList = sl; mod = m;
			}   		
		void Restore(int isUndo) {
			set  = *setList->sets[setList->Count()-1];
			name = *setList->names[setList->Count()-1];
			setList->DeleteSet(setList->Count()-1);
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			setList->AppendSet(set,name);
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Append Vert Set"));}
	};

class ESAppendSegSetRestore : public RestoreObj {
	public:
		ShapeSSel set;
		TSTR name;
		NamedSegSelSetList *setList;
		EditSplineMod *mod;

		ESAppendSegSetRestore(NamedSegSelSetList *sl,EditSplineMod *m) {
			setList = sl; mod = m;
			}   		
		void Restore(int isUndo) {
			set  = *setList->sets[setList->Count()-1];
			name = *setList->names[setList->Count()-1];
			setList->DeleteSet(setList->Count()-1);
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			setList->AppendSet(set,name);
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Append Seg Set"));}
	};

class ESAppendPolySetRestore : public RestoreObj {
	public:
		ShapePSel set;
		TSTR name;
		NamedPolySelSetList *setList;
		EditSplineMod *mod;

		ESAppendPolySetRestore(NamedPolySelSetList *sl,EditSplineMod *m) {
			setList = sl; mod = m;
			}   		
		void Restore(int isUndo) {
			set  = *setList->sets[setList->Count()-1];
			name = *setList->names[setList->Count()-1];
			setList->DeleteSet(setList->Count()-1);
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			setList->AppendSet(set,name);
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Append Poly Set"));}
	};

class ESDeleteVertSetRestore : public RestoreObj {
	public:
		ShapeVSel set;
		TSTR name;
		int index;
		NamedVertSelSetList *setList;
		EditSplineMod *mod;

		ESDeleteVertSetRestore(int i,NamedVertSelSetList *sl,EditSplineMod *m) {
			setList = sl; mod = m; index = i;
			set  = *setList->sets[index];
			name = *setList->names[index];
			}   		
		void Restore(int isUndo) {
			ShapeVSel *n = new ShapeVSel(set);
			TSTR *nm = new TSTR(name);
			setList->sets.Insert(index,1,&n);
			setList->names.Insert(index,1,&nm);
			if (mod->FindSet(name, ES_VERTEX) < 0) mod->AddSet(name, ES_VERTEX); // mjm - 4.12.99
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			setList->DeleteSet(index);
			mod->RemoveSet(name, ES_VERTEX); // mjm - 4.12.99
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Delete Vert Set"));}
	};

class ESDeleteSegSetRestore : public RestoreObj {
	public:
		ShapeSSel set;
		TSTR name;
		int index;
		NamedSegSelSetList *setList;
		EditSplineMod *mod;

		ESDeleteSegSetRestore(int i,NamedSegSelSetList *sl,EditSplineMod *m) {
			setList = sl; mod = m; index = i;
			set  = *setList->sets[index];
			name = *setList->names[index];
			}   		
		void Restore(int isUndo) {
			ShapeSSel *n = new ShapeSSel(set);
			TSTR *nm = new TSTR(name);
			setList->sets.Insert(index,1,&n);
			setList->names.Insert(index,1,&nm);
			if (mod->FindSet(name, ES_SEGMENT) < 0) mod->AddSet(name, ES_SEGMENT); // mjm - 4.12.99
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			setList->DeleteSet(index);
			mod->RemoveSet(name, ES_SEGMENT); // mjm - 4.12.99
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Delete Seg Set"));}
	};

class ESDeletePolySetRestore : public RestoreObj {
	public:
		ShapePSel set;
		TSTR name;
		int index;
		NamedPolySelSetList *setList;
		EditSplineMod *mod;

		ESDeletePolySetRestore(int i,NamedPolySelSetList *sl,EditSplineMod *m) {
			setList = sl; mod = m; index = i;
			set  = *setList->sets[index];
			name = *setList->names[index];
			}   		
		void Restore(int isUndo) {
			ShapePSel *n = new ShapePSel(set);
			TSTR *nm = new TSTR(name);
			setList->sets.Insert(index,1,&n);
			setList->names.Insert(index,1,&nm);
			if (mod->FindSet(name, ES_SPLINE) < 0) mod->AddSet(name, ES_SPLINE); // mjm - 4.12.99
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			setList->DeleteSet(index);
			mod->RemoveSet(name, ES_SPLINE); // mjm - 4.12.99
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Delete Poly Set"));}
	};

class ESVertSetNameRestore : public RestoreObj {
	public:
		TSTR undo, redo;
		int index;
		NamedVertSelSetList *setList;
		EditSplineMod *mod;
		ESVertSetNameRestore(int i,NamedVertSelSetList *sl,EditSplineMod *m) {
			index = i; setList = sl; mod = m;
			undo = *setList->names[index];
			}

		void Restore(int isUndo) {			
			redo = *setList->names[index];
			*setList->names[index] = undo;
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			*setList->names[index] = redo;
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Set Vert Set Name"));}
	};

class ESSegSetNameRestore : public RestoreObj {
	public:
		TSTR undo, redo;
		int index;
		NamedSegSelSetList *setList;
		EditSplineMod *mod;
		ESSegSetNameRestore(int i,NamedSegSelSetList *sl,EditSplineMod *m) {
			index = i; setList = sl; mod = m;
			undo = *setList->names[index];
			}

		void Restore(int isUndo) {			
			redo = *setList->names[index];
			*setList->names[index] = undo;
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			*setList->names[index] = redo;
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Set Seg Set Name"));}
	};

class ESPolySetNameRestore : public RestoreObj {
	public:
		TSTR undo, redo;
		int index;
		NamedPolySelSetList *setList;
		EditSplineMod *mod;
		ESPolySetNameRestore(int i,NamedPolySelSetList *sl,EditSplineMod *m) {
			index = i; setList = sl; mod = m;
			undo = *setList->names[index];
			}

		void Restore(int isUndo) {			
			redo = *setList->names[index];
			*setList->names[index] = undo;
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			*setList->names[index] = redo;
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Set Poly Set Name"));}
	};

class ESAddSetRestore : public RestoreObj {
	public:
		EditSplineMod *mod;
		TSTR name;
		int selLevel;
		ESAddSetRestore(TSTR &n, int level, EditSplineMod *m) {
			name = n;
			selLevel = level;
			mod = m;
			}
		void Restore(int isUndo) {			
			mod->namedSel[selLevel-1].Delete(mod->namedSel[selLevel-1].Count()-1, 1);
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			mod->AddSet(name, selLevel);
			if (mod->ip) mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Add Set Name"));}
	};

// --------------------------------------------------------------------------------------

class ESVertMapRestore : public RestoreObj {
public:
	BOOL gotRedo;
	ESVertMapper undo;
	ESVertMapper redo;
	EditSplineData *esd;
	
	ESVertMapRestore(EditSplineData *d) {
		undo = d->vertMap;
		esd = d;
		gotRedo = FALSE;
		}

	void Restore(int isUndo) {
		if(!gotRedo) {
			gotRedo = TRUE;
			redo = esd->vertMap;
			}
		esd->vertMap = undo;
		}

	void Redo() {
		esd->vertMap = redo;
		}

	int Size() { return 1; }
	void EndHold() { }
	TSTR Description() { return TSTR(_T("ESVertMapRestore")); }
};

// --------------------------------------------------------------------------------------

class FinalShapeRestore : public RestoreObj {
public:
	BOOL gotRedo;
	BezierShape undo;
	BezierShape redo;
	BezierShape *shape;
	
	FinalShapeRestore(BezierShape *s) {
		undo = *s;
		shape = s;
		gotRedo = FALSE;
		}

	void Restore(int isUndo) {
		if(!gotRedo) {
			gotRedo = TRUE;
			redo = *shape;
			}
		*shape = undo;
		}

	void Redo() {
		*shape = redo;
		}

	int Size() { return 1; }
	void EndHold() { }
	TSTR Description() { return TSTR(_T("FinalShapeRestore")); }
};

// --------------------------------------------------------------------------------------

// Alter the stored transformation data to match the current edited shape
void EditSplineData::UpdateChanges(BezierShape *shape, BOOL checkTopology) {
	if(theHold.Holding()) {
		theHold.Put(new ESVertMapRestore(this));
		theHold.Put(new FinalShapeRestore(&finalShape));
		}
	if(checkTopology) {
		// Update the mapper's indices
		vertMap.UpdateMapping(*shape);

		// Update the named selection sets
		// First, the vertex selections
		for(int set = 0; set < vselSet.Count(); ++set) {
			ShapeVSel *oldVS = &vselSet[set];
			ShapeVSel newVS;
			newVS.SetSize(*shape, FALSE);
			for(int poly = 0; poly < shape->SplineCount(); ++poly) {
				Spline3D *spline = shape->GetSpline(poly);
				for(int k = 0; k < spline->KnotCount(); ++k) {
					// Get the knot's previous location, then copy that selection into the new set
					int tag = spline->GetAux2(k);
					int oldPoly = tag >> 16;
					int oldKnot = tag & 0xffff;
					if(oldPoly >= 0 && oldKnot >= 0) {
						int oldVert = oldKnot * 3 + 1;
						newVS[poly].Set(k*3+1, (*oldVS)[oldPoly][oldVert]);
						}
					else
						newVS[poly].Set(k*3+1, 0);
					}
				}
			if(theHold.Holding())
				theHold.Put(new ESChangeVertSetRestore(&vselSet, set, oldVS));
			vselSet[set] = newVS;
			}
		// Now the segment selections
		for(set = 0; set < sselSet.Count(); ++set) {
			ShapeSSel *oldSS = &sselSet[set];
			ShapeSSel newSS;
			newSS.SetSize(*shape, FALSE);
			for(int poly = 0; poly < shape->SplineCount(); ++poly) {
				Spline3D *spline = shape->GetSpline(poly);
				for(int k = 0; k < spline->Segments(); ++k) {
					// Get the segment's previous location, then copy that selection into the new set
					int tag = spline->GetAux2(k);
					int oldPoly = tag >> 16;
					int oldSeg = tag & 0xffff;
					if(oldPoly >= 0 && oldSeg >= 0)
						newSS[poly].Set(k, (*oldSS)[oldPoly][oldSeg]);
					else
						newSS[poly].Set(k, 0);
					}
				}
			if(theHold.Holding())
				theHold.Put(new ESChangeSegSetRestore(&sselSet, set, oldSS));
			sselSet[set] = newSS;
			}
		// Now the spline selections
		for(set = 0; set < pselSet.Count(); ++set) {
			ShapePSel *oldPS = &pselSet[set];
			ShapePSel newPS;
			newPS.SetSize(*shape, FALSE);
			for(int poly = 0; poly < shape->SplineCount(); ++poly) {
				Spline3D *spline = shape->GetSpline(poly);
				// Get the first knot's previous location, then copy that selection into the new set
				int tag = spline->GetAux2(0);
				int oldPoly = tag >> 16;
				if(oldPoly >= 0)
					newPS.Set(poly, (*oldPS)[oldPoly]);
				else
					newPS.Set(poly, 0);
				}
			if(theHold.Holding())
				theHold.Put(new ESChangePolySetRestore(&pselSet, set, oldPS));
			pselSet[set] = newPS;
			}
		}
	// Update mapper's XYZ deltas
	vertMap.RecomputeDeltas(*shape);
	// Store the final shape
	finalShape = *shape;
	}

#define ESD_GENERAL_CHUNK		0x1000	// Obsolete as of 10/28/98 (r3)
#define CHANGE_CHUNK			0x1010	// Obsolete as of 10/28/98 (r3)
#define ESD_R3_GENERAL_CHUNK	0x1020
#define VERTMAP_CHUNK			0x1030
#define FINALSHAPE_CHUNK		0x1040

// Named sel set chunks
#define VSELSET_CHUNK		0x1060
#define SSELSET_CHUNK		0x1070
#define PSELSET_CHUNK		0x1080

IOResult EditSplineData::Save(ISave *isave) {	
	ULONG nb;
	isave->BeginChunk(ESD_R3_GENERAL_CHUNK);
	isave->Write(&flags,sizeof(DWORD),&nb);
	isave->EndChunk();
	// Save named sel sets
	if (vselSet.Count()) {
		isave->BeginChunk(VSELSET_CHUNK);
		vselSet.Save(isave);
		isave->EndChunk();
		}
	if (sselSet.Count()) {
		isave->BeginChunk(SSELSET_CHUNK);
		sselSet.Save(isave);
		isave->EndChunk();
		}
	if (pselSet.Count()) {
		isave->BeginChunk(PSELSET_CHUNK);
		pselSet.Save(isave);
		isave->EndChunk();
		}

	isave->BeginChunk(VERTMAP_CHUNK);
	vertMap.Save(isave);
	isave->EndChunk();
	isave->BeginChunk(FINALSHAPE_CHUNK);
	finalShape.Save(isave);
	isave->EndChunk();
	return IO_OK;
	}

IOResult EditSplineData::Load(ILoad *iload) {	
	static int chCount;
	IOResult res;
	ULONG nb;
	ModRecord *theChange;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			// The following code is here to load pre-release 3 files.
			case ESD_GENERAL_CHUNK:
				iload->SetObsolete();
				res = iload->Read(&flags,sizeof(DWORD),&nb);
				res = iload->Read(&chCount,sizeof(int),&nb);
				break;
			case CLEARVERTSELRECORD_CHUNK:
				theChange = new ClearVertSelRecord;
				goto load_change;
			case SETVERTSELRECORD_CHUNK:
				theChange = new SetVertSelRecord;
				goto load_change;
			case INVERTVERTSELRECORD_CHUNK:
				theChange = new InvertVertSelRecord;
				goto load_change;
			case CLEARSEGSELRECORD_CHUNK:
				theChange = new ClearSegSelRecord;
				goto load_change;
			case SETSEGSELRECORD_CHUNK:
				theChange = new SetSegSelRecord;
				goto load_change;
			case INVERTSEGSELRECORD_CHUNK:
				theChange = new InvertSegSelRecord;
				goto load_change;
			case CLEARPOLYSELRECORD_CHUNK:
				theChange = new ClearPolySelRecord;
				goto load_change;
			case SETPOLYSELRECORD_CHUNK:
				theChange = new SetPolySelRecord;
				goto load_change;
			case INVERTPOLYSELRECORD_CHUNK:
				theChange = new InvertPolySelRecord;
				goto load_change;
			case VERTSELRECORD_CHUNK:
				theChange = new VertSelRecord;
				goto load_change;
			case SEGSELRECORD_CHUNK:
				theChange = new SegSelRecord;
				goto load_change;
			case POLYSELRECORD_CHUNK:
				theChange = new PolySelRecord;
				goto load_change;
			case POLYCLOSERECORD_CHUNK:
				theChange = new PolyCloseRecord;
				goto load_change;
			case POLYREVERSERECORD_CHUNK:
				theChange = new PolyReverseRecord;
				goto load_change;
			case POLYMIRRORRECORD_CHUNK:
				theChange = new PolyMirrorRecord;
				goto load_change;
			case POLYENDATTACHRECORD_CHUNK:
				theChange = new PolyEndAttachRecord;
				goto load_change;
			case OUTLINERECORD_CHUNK:
				theChange = new OutlineRecord;
				goto load_change;
			case POLYDETACHRECORD_CHUNK:
				theChange = new PolyDetachRecord;
				goto load_change;
			case POLYDELETERECORD_CHUNK:
				theChange = new PolyDeleteRecord;
				goto load_change;
			case VERTMOVERECORD_CHUNK:
				theChange = new VertMoveRecord;
				goto load_change;
			case SEGDELETERECORD_CHUNK:
				theChange = new SegDeleteRecord;
				goto load_change;
			case SEGDETACHRECORD_CHUNK:
				theChange = new SegDetachRecord;
				goto load_change;
			case POLYFIRSTRECORD_CHUNK:
				theChange = new PolyFirstRecord;
				goto load_change;
			case SEGBREAKRECORD_CHUNK:
				theChange = new SegBreakRecord;
				goto load_change;
			case SEGREFINERECORD_CHUNK:
				theChange = new SegRefineRecord;
				goto load_change;
			case VERTBREAKRECORD_CHUNK:
				theChange = new VertBreakRecord;
				goto load_change;
			case VERTCONNECTRECORD_CHUNK:
				theChange = new VertConnectRecord;
				goto load_change;
			case VERTINSERTRECORD_CHUNK:
				theChange = new VertInsertRecord;
				goto load_change;
			case VERTWELDRECORD_CHUNK:
				theChange = new VertWeldRecord;
				goto load_change;
			case BOOLEANRECORD_CHUNK:
				theChange = new BooleanRecord;
				goto load_change;
			case ATTACHRECORD_CHUNK:
				theChange = new AttachRecord;
				goto load_change;
			case VERTCHANGERECORD_CHUNK:
				theChange = new VertChangeRecord;
				goto load_change;
			case SEGCHANGERECORD_CHUNK:
				theChange = new SegChangeRecord;
				goto load_change;
			case POLYCHANGERECORD_CHUNK:
				theChange = new PolyChangeRecord;
				goto load_change;
			case CREATELINERECORD_CHUNK:
				theChange = new CreateLineRecord;
				goto load_change;
			case POLYCOPYRECORD_CHUNK:
				theChange = new PolyCopyRecord;
				goto load_change;
			case SEGCOPYRECORD_CHUNK:
				theChange = new SegCopyRecord;
				goto load_change;
			case VERTDELETERECORD_CHUNK:
				theChange = new VertDeleteRecord;
				// Intentional fall-thru!
				load_change:
				changes.Append(1,&theChange);
				changes[changes.Count()-1]->Load(iload);
				break;
			//
			// The following code is used for post-release 3 files
			//
			case ESD_R3_GENERAL_CHUNK:
				res = iload->Read(&flags,sizeof(DWORD),&nb);
				break;
			// Load named selection sets
			case VSELSET_CHUNK:
				res = vselSet.Load(iload);
				break;
			case PSELSET_CHUNK:
				res = pselSet.Load(iload);
				break;
			case SSELSET_CHUNK:
				res = sselSet.Load(iload);
				break;
			case VERTMAP_CHUNK:
				res = vertMap.Load(iload);
				break;
			case FINALSHAPE_CHUNK:
				res = finalShape.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL ClearVertSelRecord::Redo(BezierShape *shape,int reRecord) {
	if(reRecord)
		sel = shape->vertSel;
	shape->vertSel.ClearAll();
	return TRUE;
	}

#define CVSR_SEL_CHUNK 0x1000

IOResult ClearVertSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case CVSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL SetVertSelRecord::Redo(BezierShape *shape,int reRecord) {
	if(reRecord)
		sel = shape->vertSel;
	shape->vertSel.SetAll();
	return TRUE;
	}

#define SVSR_SEL_CHUNK 0x1000

IOResult SetVertSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SVSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL InvertVertSelRecord::Redo(BezierShape *shape,int reRecord) {
	shape->vertSel.Toggle();
	return TRUE;
	}

IOResult InvertVertSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL ClearSegSelRecord::Redo(BezierShape *shape,int reRecord) {
	if(reRecord)
		sel = shape->segSel;
	shape->segSel.ClearAll();
	return TRUE;
	}

#define CSSR_SEL_CHUNK 0x1000

IOResult ClearSegSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case CSSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL SetSegSelRecord::Redo(BezierShape *shape,int reRecord) {
	if(reRecord)
		sel = shape->segSel;
	shape->segSel.SetAll();
	return TRUE;
	}

#define SSSR_SEL_CHUNK 0x1000

IOResult SetSegSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SSSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL InvertSegSelRecord::Redo(BezierShape *shape,int reRecord) {
	shape->segSel.Toggle();
	return TRUE;
	}

IOResult InvertSegSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL ClearPolySelRecord::Redo(BezierShape *shape,int reRecord) {
	if(reRecord)
		sel = shape->polySel;
	shape->polySel.ClearAll();
	return TRUE;
	}

#define CPSR_SEL_CHUNK 0x1000

IOResult ClearPolySelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case CPSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL SetPolySelRecord::Redo(BezierShape *shape,int reRecord) {
	if(reRecord)
		sel = shape->polySel;
	shape->polySel.SetAll();
	return TRUE;
	}

#define SPSR_SEL_CHUNK 0x1000

IOResult SetPolySelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SPSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL InvertPolySelRecord::Redo(BezierShape *shape,int reRecord) {
	shape->polySel.Toggle();
	return TRUE;
	}

IOResult InvertPolySelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL VertSelRecord::Redo(BezierShape *shape,int reRecord) {
	if(!newSel.IsCompatible(*shape))
		return FALSE;
	shape->vertSel = newSel;
	return TRUE;
	}

#define VSR_OLDSEL_CHUNK 0x1000
#define VSR_NEWSEL_CHUNK 0x1010

IOResult VertSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VSR_OLDSEL_CHUNK:
				res = oldSel.Load(iload);
				break;
			case VSR_NEWSEL_CHUNK:
				res = newSel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL SegSelRecord::Redo(BezierShape *shape,int reRecord) {
	if(!newSel.IsCompatible(*shape))
		return FALSE;
	shape->segSel = newSel;
	return TRUE;
	}

#define SSR_OLDSEL_CHUNK 0x1000
#define SSR_NEWSEL_CHUNK 0x1010

IOResult SegSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SSR_OLDSEL_CHUNK:
				res = oldSel.Load(iload);
				break;
			case SSR_NEWSEL_CHUNK:
				res = newSel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PolySelRecord::Redo(BezierShape *shape,int reRecord) {
	if(!newSel.IsCompatible(*shape))
		return FALSE;
	shape->polySel = newSel;
	return TRUE;
	}

#define PSR_OLDSEL_CHUNK 0x1000
#define PSR_NEWSEL_CHUNK 0x1010

IOResult PolySelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PSR_OLDSEL_CHUNK:
				res = oldSel.Load(iload);
				break;
			case PSR_NEWSEL_CHUNK:
				res = newSel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PolyCloseRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	Spline3D *spline = shape->splines[poly];
	spline->SetClosed();
	spline->ComputeBezPoints();
	shape->InvalidateGeomCache();
	shape->vertSel[poly].SetSize(spline->Verts(),1);
	shape->segSel[poly].SetSize(spline->Segments(),1);
	shape->segSel[poly].Clear(spline->Segments()-1);
	shape->polySel.Clear(poly);
	return TRUE;
	}

#define PCR_POLY_CHUNK 0x1000

IOResult PolyCloseRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PCR_POLY_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PolyReverseRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	shape->Reverse(poly);
	shape->splines[poly]->ComputeBezPoints();
	shape->InvalidateGeomCache();
	return TRUE;
	}

#define PRR_POLY_CHUNK 0x1000

IOResult PolyReverseRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PRR_POLY_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void MirrorPoly(BezierShape *shape, int poly, int type, BOOL copy, Point3 *pivot = NULL) {
	if(copy) {
		Spline3D *newSpline = shape->NewSpline();
		*newSpline = *shape->splines[poly];
		shape->polySel.Clear(poly);		// Unselect the old one
		poly = shape->SplineCount() - 1;
		// Don't forget to create a new selection record for this new spline!
		shape->vertSel.Insert(poly, newSpline->KnotCount() * 3);
		shape->segSel.Insert(poly, newSpline->Segments());
		shape->polySel.Insert(poly);
		shape->polySel.Set(poly);	// Select the new one!
		}
	// Now mirror it!
	Spline3D *spline = shape->splines[poly];
	// Find its center
	Box3 bbox;
	bbox.Init();
	for(int k = 0; k < spline->KnotCount(); ++k)
		bbox += spline->GetKnotPoint(k);

	Point3 center;
	if(pivot)
		center = -(*pivot);
	else
		center = bbox.Center();
	for(k = 0; k < spline->KnotCount(); ++k) {
		Point3 knot = spline->GetKnotPoint(k);
		Point3 in = spline->GetInVec(k);
		Point3 out = spline->GetOutVec(k);
		if(type == MIRROR_BOTH || type == MIRROR_HORIZONTAL) {
			knot.x = center.x - (knot.x - center.x);
			in.x = center.x - (in.x - center.x);
			out.x = center.x - (out.x - center.x);
			}
		if(type == MIRROR_BOTH || type == MIRROR_VERTICAL) {
			knot.y = center.y - (knot.y - center.y);
			in.y = center.y - (in.y - center.y);
			out.y = center.y - (out.y - center.y);
			}
		spline->SetKnotPoint(k, knot);
		spline->SetInVec(k, in);
		spline->SetOutVec(k, out);
		}
	spline->ComputeBezPoints();
	shape->InvalidateGeomCache();
	}

BOOL PolyMirrorRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	MirrorPoly(shape, poly, type, copy);
	return TRUE;
	}

#define PMR_POLY_CHUNK 0x1000
#define PMR_TYPE_CHUNK 0x1010
#define PMR_COPY_CHUNK 0x1020

IOResult PolyMirrorRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PMR_POLY_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				break;
			case PMR_TYPE_CHUNK:
				res = iload->Read(&type,sizeof(int),&nb);
				break;
			case PMR_COPY_CHUNK:
				res = iload->Read(&copy,sizeof(BOOL),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void DoPolyEndAttach(BezierShape *shape, int poly1, int vert1, int poly2, int vert2, BOOL r3Way=TRUE) {
	Spline3D *spline = shape->splines[poly1];
	int knots = spline->KnotCount();
	int verts = spline->Verts();
	int segs = spline->Segments();

	// If connecting endpoints of the same polygon, close it and get rid of vertex 1
	if(poly1 == poly2) {
		spline->SetClosed();
		BitArray& vsel = shape->vertSel[poly1];
		BitArray& ssel = shape->segSel[poly1];
		BOOL bothAuto = (spline->GetKnotType(vert1) == KTYPE_AUTO && spline->GetKnotType(vert2) == KTYPE_AUTO) ? TRUE : FALSE;
		int lastVert = knots - 1;
		Point3 p1 = spline->GetKnotPoint(0);
		Point3 p2 = spline->GetKnotPoint(lastVert);
		Point3 midpoint = (p1 + p2) / 2.0f;
		Point3 p1Delta = midpoint - p1;
		Point3 p2Delta = midpoint - p2;
		// Repoint the knot
		spline->SetKnotPoint(0, midpoint);
		if(!bothAuto) {
			spline->SetKnotType(0, KTYPE_BEZIER_CORNER);
			spline->SetInVec(0, spline->GetInVec(lastVert) + p2Delta);
			spline->SetOutVec(0, spline->GetOutVec(0) + p1Delta);
			}
		spline->DeleteKnot(lastVert);
		// Make the selection sets the right size
		vsel.SetSize(spline->Verts(), 1);
		ssel.SetSize(spline->Segments(), 1);
//3-31-99 watje
		shape->UpdateBindList();
		spline->ComputeBezPoints();
		shape->InvalidateGeomCache();
		}
	else { 		// Connecting two different splines -- Splice 'em together!
		Spline3D *spline2 = shape->splines[poly2];
		BOOL bothAuto = (spline->GetKnotType(vert1) == KTYPE_AUTO && spline2->GetKnotType(vert2) == KTYPE_AUTO) ? TRUE : FALSE;
		int knots2 = spline2->KnotCount();
		int verts2 = spline2->Verts();
		int segs2 = spline2->Segments();
		// Enlarge the selection sets for the first spline
 		BitArray& vsel = shape->vertSel[poly1];
		BitArray& ssel = shape->segSel[poly1];
 		BitArray& vsel2 = shape->vertSel[poly2];
		BitArray& ssel2 = shape->segSel[poly2];
		
		// Reorder the splines if necessary -- We set them up so that poly 1 is first,
		// ordered so that its connection point is the last knot.  Then we order poly
		// 2 so that its connection point is the first knot.  We then copy the invec
		// of poly 1's last knot to the invec of poly 2's first knot, delete poly 1's
		// last knot and append poly 2 to poly 1.  We then delete poly 2.

		if(vert1 == 0) {
			spline->Reverse();
			vsel.Reverse();
			ssel.Reverse();
			}
		if(vert2 != 0) {
			spline2->Reverse();
			vsel2.Reverse();
			ssel2.Reverse();
			}
		
		int lastVert = knots - 1;
		Point3 p1 = spline->GetKnotPoint(lastVert);
		Point3 p2 = spline2->GetKnotPoint(0);
		Point3 midpoint = (p1 + p2) / 2.0f;
		Point3 p1Delta = midpoint - p1;
		Point3 p2Delta = midpoint - p2;
		if(r3Way)	// TH 4/13/99 -- Make sure it's backward compatible
			spline2->SetKnotPoint(0, midpoint);
		else
			spline->SetKnotPoint(lastVert, midpoint);
		if(!bothAuto) {
			spline2->SetKnotType(0, KTYPE_BEZIER_CORNER);
			spline2->SetInVec(0, spline->GetInVec(lastVert) + p1Delta);
			spline2->SetOutVec(0, spline2->GetOutVec(0) + p2Delta);
			}
		spline->DeleteKnot(lastVert);
		BOOL welded = spline->Append(spline2);

		// Fix up the selection sets
#ifndef DESIGN_VER
		int base = verts - 3;
		vsel.SetSize(spline->Verts(), 1);
		vsel.Set(base+1);
		for(int i = welded ? 6 : 3; i < verts2; ++i)
			vsel.Set(base+i, vsel2[i]);
		base = segs;
		ssel.SetSize(spline->Segments(), 1);
		for(i = welded ? 1 : 0; i < segs2; ++i)
			ssel.Set(base+i, ssel2[i]);
#else
		int new_verts = spline->Verts();
		vsel.SetSize(new_verts, 1);
		vsel.Set(verts - 2);
		for(int i = verts; i < new_verts; ++i)
			vsel.Set(i, vsel2[i-verts+3]);

		int new_segs = spline->Segments();
		ssel.SetSize(new_segs, 1);
		for(i = segs; i < new_segs; ++i)
			ssel.Set(i, ssel2[i-segs]);
#endif

		// Compute bezier handles and get rid of the attachee
		spline->ComputeBezPoints();
		shape->DeleteSpline(poly2);
//3-31-99 watje
		shape->UpdateBindList();
		}
	}

BOOL PolyEndAttachRecord::Redo(BezierShape *shape,int reRecord) {
	if(!IsCompatible(shape, poly1, &oldVSel1, &oldSSel1))
		return FALSE;
	if(reRecord) {
		oldSpline1 = *(shape->splines[poly1]);
		oldVSel1 = shape->vertSel[poly1];
		oldSSel1 = shape->segSel[poly1];
		if(poly1 != poly2) {
			oldSpline2 = *(shape->splines[poly2]);
			oldVSel2 = shape->vertSel[poly2];
			oldSSel2 = shape->segSel[poly2];
			selected2 = shape->polySel[poly2];
			}
		}
	DoPolyEndAttach(shape, poly1, vert1, poly2, vert2, FALSE);
	return TRUE;
	}

#define PEAR_GENERAL_CHUNK		0x1000
#define PEAR_OLDVSEL1_CHUNK	0x1040
#define PEAR_OLDSSEL1_CHUNK	0x1050
#define PEAR_SPLINE1_CHUNK		0x1060
#define PEAR_OLDVSEL2_CHUNK	0x1070
#define PEAR_OLDSSEL2_CHUNK	0x1080
#define PEAR_SPLINE2_CHUNK		0x1090

IOResult PolyEndAttachRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PEAR_GENERAL_CHUNK:
				res = iload->Read(&poly1,sizeof(int),&nb);
				res = iload->Read(&vert1,sizeof(int),&nb);
				res = iload->Read(&poly2,sizeof(int),&nb);
				res = iload->Read(&vert2,sizeof(int),&nb);
				res = iload->Read(&selected2,sizeof(int),&nb);
				break;
			case PEAR_OLDVSEL1_CHUNK:
				res = oldVSel1.Load(iload);
				break;
			case PEAR_OLDSSEL1_CHUNK:
				res = oldSSel1.Load(iload);
				break;
			case PEAR_SPLINE1_CHUNK:
				res = oldSpline1.Load(iload);
				break;
			case PEAR_OLDVSEL2_CHUNK:
				res = oldVSel2.Load(iload);
				break;
			case PEAR_OLDSSEL2_CHUNK:
				res = oldSSel2.Load(iload);
				break;
			case PEAR_SPLINE2_CHUNK:
				res = oldSpline2.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

#define CURVELENGTHSTEPS 5
static float CurveLength(Spline3D *spline, int knot, float v1, float v2, float size = 0.0f) {
	float len = 0.0f;
	if(size == 0.0f) {	// Simple curve length
		Point3 p1,p2;
		p1 = spline->InterpBezier3D(knot, v1);
		float step = (v2 - v1) / CURVELENGTHSTEPS;
		float pos;
		int i;
		for(i = 1, pos = step; i < CURVELENGTHSTEPS; ++i, pos += step) {
			p2 = spline->InterpBezier3D(knot, v1+pos);
			len += Length(p2 - p1);
			p1 = p2;
			}
		len += Length(spline->InterpBezier3D(knot, v2) - p1);
		}
	else {	// Need to figure based on displaced location
		int knots = spline->KnotCount();
		int prev = (knot + knots - 1) % knots;
		int next = (knot + 1) % knots;
		float pv = v1 - 0.01f;
		int pk = knot;
		if(pv < 0.0f) {
			if(spline->Closed()) {
				pv += 1.0f;
				pk = prev;
				}
			else
				pv = 0.0f;
			}
		float nv = v1 + 0.01f;
		Point3 direction = Normalize(spline->InterpBezier3D(knot, nv) - spline->InterpBezier3D(pk, pv));
		direction.z = 0.0f;	// Keep it in the XY plane
		Point3 perp = Point3(direction.y * size, -direction.x * size, 0.0f);

		Point3 p1,p2;
		p1 = spline->InterpBezier3D(knot, v1) + perp;	// Got 1st displaced point

		float step = (v2 - v1) / CURVELENGTHSTEPS;
		float pos;
		int i;
		for(i = 1, pos = step; i < CURVELENGTHSTEPS; ++i, pos += step) {
			pv = v1 + pos - 0.01f;
			nv = v1 + pos + 0.01f;
			direction = Normalize(spline->InterpBezier3D(knot, nv) - spline->InterpBezier3D(knot, pv));
			direction.z = 0.0f;	// Keep it in the XY plane
			perp = Point3(direction.y * size, -direction.x * size, 0.0f);

			p2 = spline->InterpBezier3D(knot, v1+pos) + perp;
			len += Length(p2 - p1);
			p1 = p2;
			}
		pv = v2 - 0.01f;
		int nk = knot;
		nv = v2 + 0.01f;
		if(nv > 1.0f) {
			if(spline->Closed()) {
				nv -= 1.0f;
				nk = next;
				}
			else
				nv = 1.0f;
			}
		direction = Normalize(spline->InterpBezier3D(nk, nv) - spline->InterpBezier3D(knot, pv));
		direction.z = 0.0f;	// Keep it in the XY plane
		perp = Point3(direction.y * size, -direction.x * size, 0.0f);

		len += Length((spline->InterpBezier3D(knot, v2) + perp) - p1);
		}
	return len;
	}

static
void OutlineSpline(BezierShape *shape, int poly, float size, int centered, BOOL newType) {
	// IMPORTANT: The 'else' case to 'if(newType)' must be left as is!  This is code
	// which operates only on modification records brought in from release 1.x of MAX.
	// The 'newType' code operates on MAX 2.0 and later.
	if(newType) {
		Spline3D *inSpline = shape->splines[poly];
		Spline3D outSpline;
		// Do some basic calculations that we'll need regardless
		float size1 = (centered) ? size / 2.0f : 0.0f;	// First phase offset
		float size2 = (centered) ? -size / 2.0f : -size;	// Second phase offset
		int knots = inSpline->KnotCount();
		Point3 knot, in, out;
		int i;
		Matrix3 theMatrix;

		// If the input spline is closed, we wind up with two polygons
		if(inSpline->Closed()) {
			Spline3D *outSpline2 = shape->NewSpline();
			// Generate the outline polygons...
			for(i = 0; i < knots; ++i) {
				int prevKnot = (i + knots - 1) % knots;
				float oldInLength = CurveLength(inSpline, prevKnot, 0.5f, 1.0f);
				float oldOutLength = CurveLength(inSpline, i, 0.0f, 0.5f);
				int knotType = inSpline->GetKnotType(i);
				// Determine the angle of the curve at this knot
				// Get vector from interp before knot to interp after knot
				Point3 ko = inSpline->GetKnotPoint(i);
				Point3 bVec = Normalize(inSpline->InterpBezier3D(prevKnot, 0.99f) - ko);
				Point3 fVec = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
				Point3 direction = Normalize(fVec - bVec);
				direction.z = 0.0f;	// Keep it in the XY plane
				// Figure the size multiplier for the crotch angle
				float dot = DotProd(bVec, fVec);
				float angle, wsize1, wsize2;
				if(dot >= -0.9999939f)
					angle = (float)-acos(dot) / 2.0f;
				else
					angle = HALFPI;
				float base1 = size1 / (float)tan(angle);
				float sign1 = (size1 < 0.0f) ? -1.0f : 1.0f;
				wsize1 = (float)sqrt(base1 * base1 + size1 * size1) * sign1;
				float base2 = size2 / (float)tan(angle);
				float sign2 = (size2 < 0.0f) ? -1.0f : 1.0f;
				wsize2 = (float)sqrt(base2 * base2 + size2 * size2) * sign2;

				Point3 perp(direction.y * wsize1, -direction.x * wsize1, 0.0f);
				float newInLength = CurveLength(inSpline, prevKnot, 0.5f, 1.0f, size1);
				float newOutLength = CurveLength(inSpline, i, 0.0f, 0.5f, size1);
				Point3 kn = ko + perp;
				float inMult = newInLength / oldInLength;
				float outMult = newOutLength / oldOutLength;
				SplineKnot k(knotType, LTYPE_CURVE,
					kn, kn + (inSpline->GetInVec(i) - ko) * inMult, kn + (inSpline->GetOutVec(i) - ko) * outMult);
				outSpline.AddKnot(k);
				perp = Point3(direction.y * wsize2, -direction.x * wsize2, 0.0f);
				newInLength = CurveLength(inSpline, prevKnot, 0.5f, 1.0f, size2);
				newOutLength = CurveLength(inSpline, i, 0.0f, 0.5f, size2);
				kn = ko + perp;
				inMult = newInLength / oldInLength;
				outMult = newOutLength / oldOutLength;
				k = SplineKnot(knotType, LTYPE_CURVE,
					kn, kn + (inSpline->GetInVec(i) - ko) * inMult, kn + (inSpline->GetOutVec(i) - ko) * outMult);
				outSpline2->AddKnot(k);
				}
			outSpline.SetClosed();
			outSpline.ComputeBezPoints();
			*inSpline = outSpline;
			outSpline2->SetClosed();
			outSpline2->ComputeBezPoints();
			shape->vertSel.Insert(shape->SplineCount() - 1, knots * 3);
			shape->segSel.Insert(shape->SplineCount() - 1, knots);
			shape->polySel.Insert(shape->SplineCount() - 1);
			}
		else {	// Otherwise, we get one closed polygon
			// Generate the outline polygon...
			for(i = 0; i < knots; ++i) {
				// Determine the angle of the curve at this knot
				// Get vector from interp before knot to interp after knot
				Point3 direction;
				Point3 ko = inSpline->GetKnotPoint(i);
				float oldInLength = (i == 0) ? 1.0f : CurveLength(inSpline, i - 1, 0.5f, 1.0f);
				float oldOutLength = (i == (knots - 1)) ? 1.0f : CurveLength(inSpline, i, 0.0f, 0.5f);
				float wsize1;
				if(i == 0) {
					direction = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
					wsize1 = size1;
					}
				else
				if(i == (knots - 1)) {
					direction = Normalize(ko - inSpline->InterpBezier3D(i-1, 0.99f));
					wsize1=size1;
					}
				else {
					Point3 bVec = Normalize(inSpline->InterpBezier3D(i-1, 0.99f) - ko);
					Point3 fVec = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
					direction = Normalize(fVec - bVec);
					// Figure the size multiplier for the crotch angle
					float dot = DotProd(bVec, fVec);
					if(dot >= -0.9999939f) {
						float angle = (float)-acos(dot) / 2.0f;
						float base1 = size1 / (float)tan(angle);
						float sign1 = (size1 < 0.0f) ? -1.0f : 1.0f;
						wsize1 = (float)sqrt(base1 * base1 + size1 * size1) * sign1;
						}
					}
				direction.z = 0.0f;	// Keep it in the XY plane
				Point3 perp(direction.y * wsize1, -direction.x * wsize1, 0.0f);
				float newInLength = (i == 0) ? 1.0f : CurveLength(inSpline, i - 1, 0.5f, 1.0f, size1);
				float newOutLength = (i == (knots - 1)) ? 1.0f : CurveLength(inSpline, i, 0.0f, 0.5f, size1);
				float inMult = newInLength / oldInLength;
				float outMult = newOutLength / oldOutLength;
				int knotType = inSpline->GetKnotType(i);
				Point3 kn = ko + perp;
				SplineKnot k((i==0 || i==(knots-1)) ? KTYPE_BEZIER_CORNER : knotType, LTYPE_CURVE,
					kn, kn + (inSpline->GetInVec(i) - ko) * inMult, kn + (inSpline->GetOutVec(i) - ko) * outMult);
				outSpline.AddKnot(k);

				}
			for(i = knots - 1; i >= 0; --i) {
				// Determine the angle of the curve at this knot
				// Get vector from interp before knot to interp after knot
				Point3 direction;
				Point3 ko = inSpline->GetKnotPoint(i);
				float oldInLength = (i == 0) ? 1.0f : CurveLength(inSpline, i - 1, 0.5f, 1.0f);
				float oldOutLength = (i == (knots - 1)) ? 1.0f : CurveLength(inSpline, i, 0.0f, 0.5f);
				float wsize2;
				if(i == 0) {
					direction = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
					wsize2 = size2;
					}
				else
				if(i == (knots - 1)) {
					direction = Normalize(ko - inSpline->InterpBezier3D(i-1, 0.99f));
					wsize2 = size2;
					}
				else {
					Point3 bVec = Normalize(inSpline->InterpBezier3D(i-1, 0.99f) - ko);
					Point3 fVec = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
					direction = Normalize(fVec - bVec);
					// Figure the size multiplier for the crotch angle
					float dot = DotProd(bVec, fVec);
					if(dot >= -0.9999939f) {
						float angle = (float)-acos(dot) / 2.0f;
						float base2 = size2 / (float)tan(angle);
						float sign2 = (size2 < 0.0f) ? -1.0f : 1.0f;
						wsize2 = (float)sqrt(base2 * base2 + size2 * size2) * sign2;
						}
					}
				direction.z = 0.0f;	// Keep it in the XY plane
				Point3 perp(direction.y * wsize2, -direction.x * wsize2, 0.0f);
				float newInLength = (i == 0) ? 1.0f : CurveLength(inSpline, i - 1, 0.5f, 1.0f, size2);
				float newOutLength = (i == (knots - 1)) ? 1.0f : CurveLength(inSpline, i, 0.0f, 0.5f, size2);
				float inMult = newInLength / oldInLength;
				float outMult = newOutLength / oldOutLength;
				int knotType = inSpline->GetKnotType(i);
				Point3 kn = ko + perp;
				SplineKnot k((i==0 || i==(knots-1)) ? KTYPE_BEZIER_CORNER : knotType, LTYPE_CURVE,
					kn, kn + (inSpline->GetOutVec(i) - ko) * outMult, kn + (inSpline->GetInVec(i) - ko) * inMult);
				outSpline.AddKnot(k);
				}
			int lastPt = outSpline.KnotCount() - 1;
			outSpline.SetInVec(0, outSpline.GetKnotPoint(0));
			outSpline.SetOutVec(lastPt, outSpline.GetKnotPoint(lastPt));
			outSpline.SetInVec(knots, outSpline.GetKnotPoint(knots));
			outSpline.SetOutVec(knots - 1, outSpline.GetKnotPoint(knots - 1));
			outSpline.SetClosed();
			outSpline.ComputeBezPoints();
			*inSpline = outSpline;
			// Adjust selection data for this spline
			shape->vertSel[poly].SetSize(outSpline.Verts(),1);
			shape->segSel[poly].SetSize(outSpline.Segments(),1);
			}
		}
	else {
		Spline3D *inSpline = shape->splines[poly];
		Spline3D outSpline;
		// Do some basic calculations that we'll need regardless
		float size1 = (centered) ? size / 2.0f : 0.0f;	// First phase offset
		float size2 = (centered) ? -size / 2.0f : -size;	// Second phase offset
		int knots = inSpline->KnotCount();
		Point3 knot, in, out;
		int i;
		Matrix3 theMatrix;

		// If the input spline is closed, we wind up with two polygons
		if(inSpline->Closed()) {
			Spline3D *outSpline2 = shape->NewSpline();
			// Generate the outline polygons...
			for(i = 0; i < knots; ++i) {
				int prevKnot = (i + knots - 1) % knots;
				float oldInLength = CurveLength(inSpline, prevKnot, 0.5f, 1.0f);
				float oldOutLength = CurveLength(inSpline, i, 0.0f, 0.5f);
				int knotType = inSpline->GetKnotType(i);
				// Determine the angle of the curve at this knot
				// Get vector from interp before knot to interp after knot
				Point3 ko = inSpline->GetKnotPoint(i);
				Point3 bVec = Normalize(inSpline->InterpBezier3D(prevKnot, 0.99f) - ko);
				Point3 fVec = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
				Point3 direction = Normalize(fVec - bVec);
				direction.z = 0.0f;	// Keep it in the XY plane
			// Calculate the offset size differently if this knot is a corner.
			// Applies to both Corner and BezCorner.
				Point3 perp;
				perp = Point3(direction.y * size1, -direction.x * size1, 0.0f);
				float newInLength = CurveLength(inSpline, prevKnot, 0.5f, 1.0f, size1);
				float newOutLength = CurveLength(inSpline, i, 0.0f, 0.5f, size1);
				Point3 kn = ko + perp;
				float inMult = newInLength / oldInLength;
				float outMult = newOutLength / oldOutLength;
				SplineKnot k(knotType, LTYPE_CURVE,
					kn, kn + (inSpline->GetInVec(i) - ko) * inMult, kn + (inSpline->GetOutVec(i) - ko) * outMult);
				outSpline.AddKnot(k);
				perp = Point3(direction.y * size2, -direction.x * size2, 0.0f);
				newInLength = CurveLength(inSpline, prevKnot, 0.5f, 1.0f, size2);
				newOutLength = CurveLength(inSpline, i, 0.0f, 0.5f, size2);
				kn = ko + perp;
				inMult = newInLength / oldInLength;
				outMult = newOutLength / oldOutLength;
				k = SplineKnot(knotType, LTYPE_CURVE,
					kn, kn + (inSpline->GetInVec(i) - ko) * inMult, kn + (inSpline->GetOutVec(i) - ko) * outMult);
				outSpline2->AddKnot(k);
				}
			outSpline.SetClosed();
			outSpline.ComputeBezPoints();
			*inSpline = outSpline;
			outSpline2->SetClosed();
			outSpline2->ComputeBezPoints();
			shape->vertSel.Insert(shape->splineCount - 1, knots * 3);
			shape->segSel.Insert(shape->splineCount - 1, knots);
			shape->polySel.Insert(shape->splineCount - 1);
			}
		else {	// Otherwise, we get one closed polygon
			// Now get the spline selection sets
			BitArray& vsel = shape->vertSel[poly];
			BitArray& ssel = shape->segSel[poly];
			
			// Generate the outline polygon...
			for(i = 0; i < knots; ++i) {
				// Determine the angle of the curve at this knot
				// Get vector from interp before knot to interp after knot
				Point3 direction;
				Point3 ko = inSpline->GetKnotPoint(i);
				float oldInLength = (i == 0) ? 1.0f : CurveLength(inSpline, i - 1, 0.5f, 1.0f);
				float oldOutLength = (i == (knots - 1)) ? 1.0f : CurveLength(inSpline, i, 0.0f, 0.5f);
				if(i == 0)
					direction = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
				else
				if(i == (knots - 1))
					direction = Normalize(ko - inSpline->InterpBezier3D(i-1, 0.99f));
				else {
					Point3 bVec = Normalize(inSpline->InterpBezier3D(i-1, 0.99f) - ko);
					Point3 fVec = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
					direction = Normalize(fVec - bVec);
					}
				direction.z = 0.0f;	// Keep it in the XY plane
				Point3 perp(direction.y * size1, -direction.x * size1, 0.0f);
				float newInLength = (i == 0) ? 1.0f : CurveLength(inSpline, i - 1, 0.5f, 1.0f, size1);
				float newOutLength = (i == (knots - 1)) ? 1.0f : CurveLength(inSpline, i, 0.0f, 0.5f, size1);
				float inMult = newInLength / oldInLength;
				float outMult = newOutLength / oldOutLength;
				int knotType = inSpline->GetKnotType(i);
				Point3 kn = ko + perp;
				SplineKnot k((i==0 || i==(knots-1)) ? KTYPE_BEZIER_CORNER : knotType, LTYPE_CURVE,
					kn, kn + (inSpline->GetInVec(i) - ko) * inMult, kn + (inSpline->GetOutVec(i) - ko) * outMult);
				outSpline.AddKnot(k);
				}
			for(i = knots - 1; i >= 0; --i) {
				// Determine the angle of the curve at this knot
				// Get vector from interp before knot to interp after knot
				Point3 direction;
				Point3 ko = inSpline->GetKnotPoint(i);
				float oldInLength = (i == 0) ? 1.0f : CurveLength(inSpline, i - 1, 0.5f, 1.0f);
				float oldOutLength = (i == (knots - 1)) ? 1.0f : CurveLength(inSpline, i, 0.0f, 0.5f);
				if(i == 0)
					direction = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
				else
				if(i == (knots - 1))
					direction = Normalize(ko - inSpline->InterpBezier3D(i-1, 0.99f));
				else {
					Point3 bVec = Normalize(inSpline->InterpBezier3D(i-1, 0.99f) - ko);
					Point3 fVec = Normalize(inSpline->InterpBezier3D(i, 0.01f) - ko);
					direction = Normalize(fVec - bVec);
					}
				direction.z = 0.0f;	// Keep it in the XY plane
				Point3 perp(direction.y * size2, -direction.x * size2, 0.0f);
				float newInLength = (i == 0) ? 1.0f : CurveLength(inSpline, i - 1, 0.5f, 1.0f, size2);
				float newOutLength = (i == (knots - 1)) ? 1.0f : CurveLength(inSpline, i, 0.0f, 0.5f, size2);
				float inMult = newInLength / oldInLength;
				float outMult = newOutLength / oldOutLength;
				int knotType = inSpline->GetKnotType(i);
				Point3 kn = ko + perp;
				SplineKnot k((i==0 || i==(knots-1)) ? KTYPE_BEZIER_CORNER : knotType, LTYPE_CURVE,
					kn, kn + (inSpline->GetOutVec(i) - ko) * outMult, kn + (inSpline->GetInVec(i) - ko) * inMult);
				outSpline.AddKnot(k);
				}
			int lastPt = outSpline.KnotCount() - 1;
			outSpline.SetInVec(0, outSpline.GetKnotPoint(0));
			outSpline.SetOutVec(lastPt, outSpline.GetKnotPoint(lastPt));
			outSpline.SetInVec(knots, outSpline.GetKnotPoint(knots));
			outSpline.SetOutVec(knots - 1, outSpline.GetKnotPoint(knots - 1));
			outSpline.SetClosed();
			outSpline.ComputeBezPoints();
			*inSpline = outSpline;
			// Adjust selection data for this spline
			vsel.SetSize(inSpline->Verts(),1);
			ssel.SetSize(inSpline->Segments(),1);
			}
		}
//3-31-99 watje
	shape->UpdateBindList();
	shape->InvalidateGeomCache();
	}

/* Find the vector length for a circle segment	*/
/* Returns a unit value (radius=1.0)		*/
/* Angle expressed in radians			*/

static float
veccalc(float angstep) {
	static float lastin = -9999.0f,lastout;
	if(lastin == angstep)
		return lastout;

	float lo,hi,totdist;
	float sinfac=(float)sin(angstep),cosfac=(float)cos(angstep),test;
	int ix,count;
	Spline3D work;
	Point3 k1((float)cos(0.0f),(float)sin(0.0f),0.0f);
	Point3 k2(cosfac,sinfac,0.0f);

	hi=1.5f;
	lo=0.0f;
	count=200;

	/* Loop thru test vectors */

	loop:
	work.NewSpline();
	test=(hi+lo)/2.0f;
	Point3 out = k1 + Point3(0.0f, test, 0.0f);
	Point3 in = k2 + Point3(sinfac * test, -cosfac * test, 0.0f);

 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k1,k1,out));
 	work.AddKnot(SplineKnot(KTYPE_BEZIER,LTYPE_CURVE,k2,in,k2));

	totdist=0.0f;
	for(ix=0; ix<10; ++ix) {
		Point3 terp = work.InterpBezier3D(0,(float)ix/10.0f);
		totdist += (float)sqrt(terp.x * terp.x + terp.y * terp.y);
		}
	
	totdist /= 10.0f;
	count--;
	if(totdist==1.0f || count<=0)
		goto done;
	if(totdist>1.0f) {
		hi=test;
		goto loop;
		}
	lo=test;
	goto loop;

	done:
	lastin = angstep;
	lastout = test;
	return test;
	}

#define ES_FILLET 0
#define ES_CHAMFER 1

static void
FilletOrChamferSpline(BezierShape *shape, int poly, float size, int which) {
	if(size <= 0.0f)
		return;
	Spline3D *inSpline = shape->splines[poly];
	Spline3D outSpline = *inSpline;
	BitArray map = KnotSelFromVertSel(shape->vertSel[poly]);
	// Don't fillet or chamfer ends of open spline!
	if(!outSpline.Closed()) {
		map.Clear(0);
		map.Clear(outSpline.KnotCount() - 1);
		}
	// If nothing to do, exit
	if(!map.NumberSet())
		return;
	for(int i = outSpline.KnotCount()-1; i >= 0; --i) {
		if(map[i]) {
			int prev = (i + outSpline.KnotCount() - 1) % outSpline.KnotCount();
			float ilen = outSpline.SegmentLength(i);
			float prevlen = outSpline.SegmentLength(prev);
			outSpline.RefineSegment(i, size/ilen, SPLINE_INTERP_NORMALIZED);
			outSpline.RefineSegment((i < prev) ? prev+1 : prev, (prevlen - size)/prevlen, SPLINE_INTERP_NORMALIZED);
			outSpline.DeleteKnot((i > 0) ? i+1 : i);
			int k2 = (i > prev) ? i+1 : i;
			int k1 = prev + 1;
			if(which == ES_CHAMFER) {
				outSpline.SetKnotType(k1, KTYPE_BEZIER_CORNER);
				outSpline.SetKnotType(k2, KTYPE_BEZIER_CORNER);
				}
			Point3 k1p = outSpline.GetKnotPoint(k1);
			Point3 k2p = outSpline.GetKnotPoint(k2);
			outSpline.SetRelOutVec(k1, (k2p - k1p) / 3.0f);
			outSpline.SetRelInVec(k2, (k1p - k2p) / 3.0f);
			if(which == ES_FILLET) {
				Point3 ain = Normalize(outSpline.GetRelInVec(k1));
				Point3 aout = Normalize(outSpline.GetRelOutVec(k1));
				float a1 = (float)fabs(-acos(DotProd(ain, aout))) - HALFPI;
				Point3 bin = Normalize(outSpline.GetRelInVec(k2));
				Point3 bout = Normalize(outSpline.GetRelOutVec(k2));
				float a2 = (float)fabs(-acos(DotProd(bin, bout))) - HALFPI;
				// If both angles are < 179 degrees, continue!
				if(a1 < 3.124f && a2 < 3.124f) {
					float a3 = PI - a1 - a2;
					float ab = Length(k1p - k2p);
					float ax = (ab * (float)sin(a2)) / (float)sin(a3);
					float bx = (ax * (float)sin(a1)) / (float)sin(a2);
					float vector = veccalc(a3);
					outSpline.SetRelOutVec(k1, -ain * (vector * bx));
					outSpline.SetRelInVec(k2, -bout * (vector * ax));
					}
				}
			}
		}
	*inSpline = outSpline;
	// Adjust selection data for this spline
	shape->vertSel[poly].SetSize(outSpline.Verts(),1);
	shape->segSel[poly].SetSize(outSpline.Segments(),1);
//3-31-99 watje
	shape->UpdateBindList();
	shape->InvalidateGeomCache();
	}

BOOL OutlineRecord::Redo(BezierShape *shape, int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		oldSplineCount = shape->splineCount;
		}
	OutlineSpline(shape, poly, size, centered, newType);
	return TRUE;
	}

#define POR_GENERAL_CHUNK		0x1000
#define POR_OLDVSEL_CHUNK		0x1040
#define POR_OLDSSEL_CHUNK		0x1050
#define POR_SPLINE_CHUNK		0x1060
#define POR_NEWTYPE_CHUNK		0x1070

IOResult OutlineRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	newType = FALSE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case POR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&centered,sizeof(int),&nb);
				res = iload->Read(&size,sizeof(float),&nb);
				res = iload->Read(&oldSplineCount,sizeof(int),&nb);
				break;
			case POR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case POR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case POR_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			// If the following chunk is present, it's a MAX 2.0 file and the outlining 
			// is done using a fixed algorithm.  Otherwise, it uses the R1.x code, preserving
			// the shape as it was.
			case POR_NEWTYPE_CHUNK:
				newType = TRUE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PolyDetachRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord && !copy) {
		spline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		}
	if(!copy)
		shape->DeleteSpline(poly);
	return TRUE;
	}

#define PDETR_GENERAL_CHUNK		0x1000
#define PDETR_OLDVSEL_CHUNK		0x1040
#define PDETR_OLDSSEL_CHUNK		0x1050
#define PDETR_SPLINE_CHUNK		0x1060

IOResult PolyDetachRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PDETR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&copy,sizeof(int),&nb);
				break;
			case PDETR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case PDETR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case PDETR_SPLINE_CHUNK:
				res = spline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PolyDeleteRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		spline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		}
	shape->DeleteSpline(poly);
	return TRUE;
	}

#define PDELR_GENERAL_CHUNK		0x1000
#define PDELR_OLDVSEL_CHUNK		0x1040
#define PDELR_OLDSSEL_CHUNK		0x1050
#define PDELR_SPLINE_CHUNK		0x1060

IOResult PolyDeleteRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PDELR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				break;
			case PDELR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case PDELR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case PDELR_SPLINE_CHUNK:
				res = spline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL VertMoveRecord::Redo(BezierShape *shape,int reRecord) {
	if(!delta.IsCompatible(*shape))
		return FALSE;
	delta.Apply(*shape);
	return TRUE;
	}

#define VMR_DELTA_CHUNK		0x1000

IOResult VertMoveRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VMR_DELTA_CHUNK:
				res = delta.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}


BOOL SegDeleteRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		selected = shape->polySel[poly];
		}
	DeleteSelSegs(shape, poly);
	return TRUE;
	}

#define SDELR_GENERAL_CHUNK		0x1000
#define SDELR_OLDVSEL_CHUNK		0x1040
#define SDELR_OLDSSEL_CHUNK		0x1050
#define SDELR_SPLINE_CHUNK		0x1060

IOResult SegDeleteRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SDELR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&selected,sizeof(int),&nb);
				res = iload->Read(&deleted,sizeof(int),&nb);
				res = iload->Read(&oldSplineCount,sizeof(int),&nb);
				break;
			case SDELR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case SDELR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case SDELR_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		


BOOL SegDetachRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord && !copy) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		selected = shape->polySel[poly];
		}
	if(!copy)
		DeleteSelSegs(shape, poly);
	return TRUE;
	}

#define SDETR_GENERAL_CHUNK		0x1000
#define SDETR_OLDVSEL_CHUNK		0x1040
#define SDETR_OLDSSEL_CHUNK		0x1050
#define SDETR_SPLINE_CHUNK		0x1060

IOResult SegDetachRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SDETR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&copy,sizeof(int),&nb);
				res = iload->Read(&selected,sizeof(int),&nb);
				res = iload->Read(&deleted,sizeof(int),&nb);
				res = iload->Read(&oldSplineCount,sizeof(int),&nb);
				break;
			case SDETR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case SDETR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case SDETR_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		


static void BreakSegment(BezierShape *shape, int poly, int segment, float param) {
	Spline3D *spline = shape->splines[poly];
	int knots = spline->KnotCount();
	int verts = spline->Verts();
	int segs = spline->Segments();
	int nextSeg = (segment + 1) % knots;

	Point3 point = spline->InterpBezier3D(segment, param);
	
	Point3 v00 = spline->GetKnotPoint(segment);
	Point3 v30 = spline->GetKnotPoint(nextSeg);
	Point3 v10 = spline->GetOutVec(segment);
	Point3 v20 = spline->GetInVec(nextSeg);
	Point3 v01 = v00 + (v10 - v00) * param;
	Point3 v21 = v20 + (v30 - v20) * param;
	Point3 v11 = v10 + (v20 - v10) * param;
	Point3 v02 = v01 + (v11 - v01) * param;
	Point3 v12 = v11 + (v21 - v11) * param;
	Point3 v03 = v02 + (v12 - v02) * param;

	spline->SetOutVec(segment, v01);
	spline->SetInVec(nextSeg, v21);

	SplineKnot newKnot(KTYPE_BEZIER, LTYPE_CURVE, v03, v02, v12);
	spline->AddKnot(newKnot, nextSeg);
	spline->ComputeBezPoints();

	// Now adjust the spline selection sets
	BitArray& vsel = shape->vertSel[poly];
	BitArray& ssel = shape->segSel[poly];
	vsel.SetSize(verts + 3, 1);
	int where = (segment + 1) * 3;
	vsel.Shift(RIGHT_BITSHIFT, 3, where);
	vsel.Clear(where);
	vsel.Clear(where+1);
	vsel.Clear(where+2);
	ssel.SetSize(segs + 1, 1);
	ssel.Shift(RIGHT_BITSHIFT, 1, segment + 1);
	ssel.Set(segment+1,ssel[segment]);

	// Now break the spline at that vertex!

	knots = spline->KnotCount();
	verts = spline->Verts();

	int k = nextSeg;
	int altered = 0;

	if(1) {
		BitArray& vsel = shape->vertSel[poly];
		BitArray& ssel = shape->segSel[poly];
		int vert = k*3+1;
		if(spline->Closed()) {
			if(k == (knots-1)) {	// Break at end knot
				break_at_last_knot:
				altered = 1;
				SplineKnot dupKnot(spline->GetKnotType(k),spline->GetLineType(k),
					spline->GetKnotPoint(k),spline->GetInVec(k),spline->GetOutVec(k));
				spline->AddKnot(dupKnot, 0);
				knots++;
				verts += 3;
				spline->SetOpen();
				vsel.SetSize(spline->Verts(),1);
				vsel.Shift(RIGHT_BITSHIFT,3);
				vsel.Clear(0);	// New point not selected
				vsel.Clear(1);
				vsel.Clear(2);
				ssel.SetSize(spline->Segments(),1);
				ssel.Shift(RIGHT_BITSHIFT,1);
				ssel.Clear(0);
				}
			else
			if(k == 0) {			// Break at first knot
				altered = 1;
				SplineKnot dupKnot(spline->GetKnotType(0),spline->GetLineType(0),
					spline->GetKnotPoint(0),spline->GetInVec(0),spline->GetOutVec(0));
				spline->AddKnot(dupKnot, -1);
				knots++;
				verts += 3;
				spline->SetOpen();
				vsel.SetSize(spline->Verts(),1);
				vsel.Clear(verts-3);		// New point not selected
				vsel.Clear(verts-2);
				vsel.Clear(verts-1);
				ssel.SetSize(spline->Segments(),1);
				ssel.Clear(knots-1);
				}
			else {					// Break somewhere in the middle
				// First, rotate the spline so that the break point is the last one!
				int rotations = 0;
				int lastKnot = knots - 1;
				while(k < (lastKnot)) {
					SplineKnot dupKnot(spline->GetKnotType(lastKnot),spline->GetLineType(lastKnot),
						spline->GetKnotPoint(lastKnot),spline->GetInVec(lastKnot),spline->GetOutVec(lastKnot));
					spline->DeleteKnot(lastKnot);
					spline->AddKnot(dupKnot, 0);
					rotations++;
					k++;
					}
				vsel.Rotate(RIGHT_BITSHIFT, rotations*3);
				ssel.Rotate(RIGHT_BITSHIFT, rotations);
				k = lastKnot;
				vert = k*3+1;
				goto break_at_last_knot;
				}
			}
		else {
			// Don't do anything if the spline's open and we're breaking at an end vertex!
			if (k == 0 || k == (knots-1)) {
				vsel.Clear(vert);	// Just turn off the selection bit
				goto done;
				}
			int i;
			int newPolySize = knots - k;
			// OK, We're breaking at a point in the middle -- Copy end points off to a new spline, then
			// delete them from the original!
			Spline3D *newSpline = shape->NewSpline();
			for(i = k; i < knots; ++i) {
				SplineKnot dupKnot(spline->GetKnotType(i),spline->GetLineType(i),
					spline->GetKnotPoint(i),spline->GetInVec(i),spline->GetOutVec(i));
				newSpline->AddKnot(dupKnot, -1);
				}
			for(i = knots-1; i > k; --i)
				spline->DeleteKnot(i);
			// Adjust selection data for this spline
			vsel.SetSize(spline->Verts(),1);
			ssel.SetSize(spline->Segments(),1);
			// Don't forget to create a new selection record for this new spline!
			shape->vertSel.Insert(shape->splineCount - 1, newPolySize * 3);
			shape->segSel.Insert(shape->splineCount - 1, newPolySize - 1);
			shape->polySel.Insert(shape->splineCount - 1);
			}
		}
	done:
	if(altered) {
//3-31-99 watje
		shape->UpdateBindList();
		spline->ComputeBezPoints();
		shape->InvalidateGeomCache();
		}
	}

BOOL SegBreakRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		selected = shape->polySel[poly];
		oldSplineCount = shape->splineCount;
		}
	BreakSegment(shape, poly, segment, param);
	return TRUE;
	}

#define SBRKR_GENERAL_CHUNK		0x1000
#define SBRKR_OLDVSEL_CHUNK		0x1040
#define SBRKR_OLDSSEL_CHUNK		0x1050
#define SBRKR_SPLINE_CHUNK		0x1060

IOResult SegBreakRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SBRKR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&segment,sizeof(int),&nb);
				res = iload->Read(&param,sizeof(float),&nb);
				res = iload->Read(&selected,sizeof(int),&nb);
				res = iload->Read(&oldSplineCount,sizeof(int),&nb);
				break;
			case SBRKR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case SBRKR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case SBRKR_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void RefineSegment(BezierShape *shape, int poly, int segment, float param, BOOL r3Style=FALSE) {
	Spline3D *spline = shape->splines[poly];
	int knots = spline->KnotCount();
	int verts = spline->Verts();
	int segs = spline->Segments();
	int nextSeg = (segment + 1) % knots;
	int insertSeg = (nextSeg == 0) ? -1 : nextSeg;

	// Get the knot points
	Point3 v00 = spline->GetKnotPoint(segment);
	Point3 v30 = spline->GetKnotPoint(nextSeg);

	// Get the knot types
	int type1 = spline->GetKnotType(segment);
	int type2 = spline->GetKnotType(nextSeg);

	// Get the material
	MtlID mtl = spline->GetMatID(segment);

	// Special: If they're refining a line-type segment, force it to be a bezier curve again
	if(spline->GetLineType(segment) == LTYPE_LINE) {
		spline->SetKnotType(segment, KTYPE_BEZIER_CORNER);
		spline->SetKnotType(nextSeg, KTYPE_BEZIER_CORNER);
		spline->SetLineType(segment, LTYPE_CURVE);
		spline->SetOutVec(segment, v00 + (v30 - v00) / 3.0f);
		spline->SetInVec(nextSeg, v30 - (v30 - v00) / 3.0f);
		}

	Point3 point = spline->InterpBezier3D(segment, param);
	
	Point3 v10 = spline->GetOutVec(segment);
	Point3 v20 = spline->GetInVec(nextSeg);
	Point3 v01 = v00 + (v10 - v00) * param;
	Point3 v21 = v20 + (v30 - v20) * param;
	Point3 v11 = v10 + (v20 - v10) * param;
	Point3 v02 = v01 + (v11 - v01) * param;
	Point3 v12 = v11 + (v21 - v11) * param;
	Point3 v03 = v02 + (v12 - v02) * param;

	spline->SetOutVec(segment, v01);
	spline->SetInVec(nextSeg, v21);

	// New for r3: Make the knot type dependent on the bordering knot types
	int newType = KTYPE_BEZIER;
	if(r3Style) {
		if(type1 == KTYPE_CORNER && type2 == KTYPE_CORNER)
			newType = KTYPE_CORNER;
		else
		if((type1 & KTYPE_CORNER) || (type2 & KTYPE_CORNER))
			newType = KTYPE_BEZIER_CORNER;
		else
		if(type1 == KTYPE_AUTO && type2 == KTYPE_AUTO)
			newType = KTYPE_AUTO;
		}
	SplineKnot newKnot(newType, LTYPE_CURVE, v03, v02, v12);
	newKnot.SetMatID(mtl);

	spline->AddKnot(newKnot, insertSeg);
//3-31-99 watje
//watje 5-25-99
	BOOL hitBound = FALSE;
	for (int i = 0; i < shape->bindList.Count();i++)
		{
		if (poly == shape->bindList[i].segSplineIndex)  
			{
			if (segment <= shape->bindList[i].seg)
				{
				if (segment == shape->bindList[i].seg)
					{
					if (param <= 0.5f) 
						{
						shape->bindList[i].seg++;
						hitBound = TRUE;
						}
					}
				else
					{
					shape->bindList[i].seg++;
					hitBound = TRUE;

					}
				}
			}
		}

//	shape->UpdateBindList();
	spline->ComputeBezPoints();
	shape->InvalidateGeomCache();

	// Now adjust the spline selection sets
	BitArray& vsel = shape->vertSel[poly];
	BitArray& ssel = shape->segSel[poly];
	vsel.SetSize(spline->Verts(), 1);
	int where = (segment + 1) * 3;
	vsel.Shift(RIGHT_BITSHIFT, 3, where);
	vsel.Clear(where);
	vsel.Clear(where+1);
	vsel.Clear(where+2);
	ssel.SetSize(spline->Segments(), 1);
	ssel.Shift(RIGHT_BITSHIFT, 1, segment + 1);
	ssel.Set(segment+1,ssel[segment]);
	}

BOOL SegRefineRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		}
	if(segment >= shape->splines[poly]->Segments())
		return FALSE;
	RefineSegment(shape, poly, segment, param);
	return TRUE;
	}

#define SREFR_GENERAL_CHUNK		0x1000
#define SREFR_OLDVSEL_CHUNK		0x1040
#define SREFR_OLDSSEL_CHUNK		0x1050
#define SREFR_SPLINE_CHUNK		0x1060

IOResult SegRefineRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SREFR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&segment,sizeof(int),&nb);
				res = iload->Read(&param,sizeof(float),&nb);
				break;
			case SREFR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case SREFR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case SREFR_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

#define BEGINNING 0
#define END 1
#define FORWARD 1
#define REVERSE -1

static void ConnectVerts(BezierShape *shape, int poly1, int vert1, int poly2, int vert2, BOOL makeVectors) {
	Spline3D *spline = shape->splines[poly1];
	int knots = spline->KnotCount();
	int verts = spline->Verts();
	int segs = spline->Segments();

	// If connecting endpoints of the same polygon, close it and make the connecting line linear
	if(poly1 == poly2) {
		spline->SetClosed();
		// Make first and last knots beziers
		spline->SetKnotType(0, KTYPE_BEZIER_CORNER);
		int lastKnot = spline->KnotCount() - 1;
		spline->SetKnotType(lastKnot, KTYPE_BEZIER_CORNER);
		spline->SetLineType(lastKnot, LTYPE_CURVE);
		if(makeVectors) {
			Point3 v0 = spline->GetKnotPoint(0);
			Point3 v1 = spline->GetKnotPoint(lastKnot);
			Point3 vec = (v1 - v0) / 3.0f;
			spline->SetInVec(0, v0 + vec);
			spline->SetOutVec(lastKnot, v1 - vec);
			}
		else {
			spline->SetInVec(0, spline->GetKnotPoint(0));
			spline->SetOutVec(lastKnot, spline->GetKnotPoint(lastKnot));
			}
		BitArray& ssel = shape->segSel[poly1];
		ssel.SetSize(spline->Segments(), 1);
		ssel.Set(spline->Segments() - 1, 0);
		}
	else { 		// Connecting two different splines -- Splice 'em together!
		Spline3D *spline2 = shape->splines[poly2];
		int knots2 = spline2->KnotCount();
		int verts2 = spline2->Verts();
		int segs2 = spline2->Segments();
		// Enlarge the selection sets for the first spline
 		BitArray& vsel = shape->vertSel[poly1];
		BitArray& ssel = shape->segSel[poly1];
 		BitArray& vsel2 = shape->vertSel[poly2];
		BitArray& ssel2 = shape->segSel[poly2];

		// Ready the endpoints
		if(makeVectors) {
			Point3 v1, v2, vec;
			if(vert2 == 1)
				v2 = spline2->GetKnotPoint(0);
			else 
				v2 = spline2->GetKnotPoint(knots2 - 1);
			if(vert1 == 1)
				v1 = spline->GetKnotPoint(0);
			else 
				v1 = spline->GetKnotPoint(knots - 1);
			if(vert2 == 1) {
				spline2->SetKnotType(0, KTYPE_BEZIER_CORNER);
				spline2->SetInVec(0, v2 + (v1 - v2) / 3.0f);
				}
			else {
				spline2->SetKnotType(knots2 - 1, KTYPE_BEZIER_CORNER);
				spline2->SetOutVec(knots2 - 1, v2 + (v1 - v2) / 3.0f);
				}
			if(vert1 == 1) {
				spline->SetKnotType(0, KTYPE_BEZIER_CORNER);
				spline->SetInVec(0, v1 + (v2 - v1) / 3.0f);
				}
			else {
				spline->SetKnotType(spline->KnotCount() - 1, KTYPE_BEZIER_CORNER);
				spline->SetOutVec(knots - 1, v1 + (v2 - v1) / 3.0f);
				}
			}
		else {
			if(vert2 == 1) {
				spline2->SetKnotType(0, KTYPE_BEZIER_CORNER);
				spline2->SetInVec(0, spline2->GetKnotPoint(0));
				}
			else {
				spline2->SetKnotType(knots2 - 1, KTYPE_BEZIER_CORNER);
				spline2->SetOutVec(knots2 - 1, spline2->GetKnotPoint(knots2 - 1));
				}
			if(vert1 == 1) {
				spline->SetKnotType(0, KTYPE_BEZIER_CORNER);
				spline->SetInVec(0, spline->GetKnotPoint(0));
				}
			else {
				spline->SetKnotType(spline->KnotCount() - 1, KTYPE_BEZIER_CORNER);
				spline->SetOutVec(knots - 1, spline->GetKnotPoint(knots - 1));
				}
			}
		// Now copy the knots over!
		if(vert2 == 1) {
			if(vert1 == 1) {
				// Forward copy, reversing vectors
				for(int i = 0, first = 1; i < spline2->KnotCount(); ++i, first = 0) {
					SplineKnot k(spline2->GetKnotType(i), (first) ? LTYPE_CURVE : spline2->GetLineType(i - 1),
						spline2->GetKnotPoint(i),spline2->GetOutVec(i), spline2->GetInVec(i));
					spline->AddKnot(k, 0);
					vsel.SetSize(spline->Verts(), 1);
					ssel.SetSize(spline->Segments(), 1);
					vsel.Shift(RIGHT_BITSHIFT, 3);
					ssel.Shift(RIGHT_BITSHIFT, 1);
					vsel.Set(1, vsel2[i*3+1]);
					ssel.Set(0, (first) ? 0 : ssel2[i - 1]);
					}
				}
			else {
				// Simple forward copy
				for(int i = 0, first = 1; i < spline2->KnotCount(); ++i, first = 0) {
					SplineKnot k(spline2->GetKnotType(i), spline2->GetLineType(i),
						spline2->GetKnotPoint(i),spline2->GetInVec(i), spline2->GetOutVec(i));
					spline->AddKnot(k);
					vsel.SetSize(spline->Verts(), 1);
					ssel.SetSize(spline->Segments(), 1);
					vsel.Set((spline->KnotCount() - 1) * 3 + 1, vsel2[i*3+1]);
					ssel.Set(spline->Segments() - 1, (first) ? 0 : ssel2[i - 1]);
					}
				}
			}
		else {
			if(vert1 == 1) {
				// Backward copy
				for(int i = spline2->KnotCount() - 1, first = 1; i >= 0; --i, first = 0) {
					SplineKnot k(spline2->GetKnotType(i), (first) ? LTYPE_CURVE : spline2->GetLineType(i),
						spline2->GetKnotPoint(i),spline2->GetInVec(i), spline2->GetOutVec(i));
					spline->AddKnot(k, 0);
					vsel.SetSize(spline->Verts(), 1);
					ssel.SetSize(spline->Segments(), 1);
					vsel.Shift(RIGHT_BITSHIFT, 3);
					ssel.Shift(RIGHT_BITSHIFT, 1);
					vsel.Set(1, vsel2[i*3+1]);
					ssel.Set(0, (first) ? 0 : ssel2[i]);
					}
				}
			else {
				// Backward copy, reversing vectors
				for(int i = spline2->KnotCount() - 1, first = 1; i >= 0; --i,first = 0) {
					SplineKnot k(spline2->GetKnotType(i), (i == 0) ? LTYPE_CURVE : spline2->GetLineType(i - 1),
						spline2->GetKnotPoint(i),spline2->GetOutVec(i), spline2->GetInVec(i));
					spline->AddKnot(k, -1);
					vsel.SetSize(spline->Verts(), 1);
					ssel.SetSize(spline->Segments(), 1);
					vsel.Set((spline->KnotCount() - 1) * 3 + 1, vsel2[i*3+1]);
					ssel.Set(spline->Segments() - 1, (first) ? 0 : ssel2[i]);
					}
				}
			}
		spline->ComputeBezPoints();
		shape->DeleteSpline(poly2);

		}
	shape->UpdateBindList();
	}

BOOL VertConnectRecord::Redo(BezierShape *shape,int reRecord) {
	if(!IsCompatible(shape, poly1, &oldVSel1, &oldSSel1))
		return FALSE;
	if(poly1 != poly2 && !IsCompatible(shape, poly2, &oldVSel2, &oldSSel2))
		return FALSE;
	if(reRecord) {
		oldSpline1 = *(shape->splines[poly1]);
		oldVSel1 = shape->vertSel[poly1];
		oldSSel1 = shape->segSel[poly1];
		if(poly1 != poly2) {
			oldSpline2 = *(shape->splines[poly2]);
			oldVSel2 = shape->vertSel[poly2];
			oldSSel2 = shape->segSel[poly2];
			selected2 = shape->polySel[poly2];
			}
		}
	ConnectVerts(shape, poly1, vert1, poly2, vert2, FALSE);
	return TRUE;
	}

#define VCONR_GENERAL_CHUNK		0x1000
#define VCONR_OLDVSEL1_CHUNK	0x1040
#define VCONR_OLDSSEL1_CHUNK	0x1050
#define VCONR_SPLINE1_CHUNK		0x1060
#define VCONR_OLDVSEL2_CHUNK	0x1070
#define VCONR_OLDSSEL2_CHUNK	0x1080
#define VCONR_SPLINE2_CHUNK		0x1090

IOResult VertConnectRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VCONR_GENERAL_CHUNK:
				res = iload->Read(&poly1,sizeof(int),&nb);
				res = iload->Read(&vert1,sizeof(int),&nb);
				res = iload->Read(&poly2,sizeof(int),&nb);
				res = iload->Read(&vert2,sizeof(int),&nb);
				res = iload->Read(&selected2,sizeof(int),&nb);
				break;
			case VCONR_OLDVSEL1_CHUNK:
				res = oldVSel1.Load(iload);
				break;
			case VCONR_OLDSSEL1_CHUNK:
				res = oldSSel1.Load(iload);
				break;
			case VCONR_SPLINE1_CHUNK:
				res = oldSpline1.Load(iload);
				break;
			case VCONR_OLDVSEL2_CHUNK:
				res = oldVSel2.Load(iload);
				break;
			case VCONR_OLDSSEL2_CHUNK:
				res = oldSSel2.Load(iload);
				break;
			case VCONR_SPLINE2_CHUNK:
				res = oldSpline2.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL VertInsertRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		}
	shape->DeleteSpline(poly);
	shape->InsertSpline(&newSpline, poly);
	shape->vertSel[poly] = newVSel;
	shape->segSel[poly] = newSSel;
	return TRUE;
	}

#define VINSR_GENERAL_CHUNK		0x1000
#define VINSR_OLDVSEL_CHUNK		0x1010
#define VINSR_OLDSSEL_CHUNK		0x1050
#define VINSR_OLDSPLINE_CHUNK	0x1060
#define VINSR_NEWVSEL_CHUNK		0x1070
#define VINSR_NEWSSEL_CHUNK		0x1080
#define VINSR_NEWSPLINE_CHUNK	0x1090

IOResult VertInsertRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VINSR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				break;
			case VINSR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case VINSR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case VINSR_OLDSPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			case VINSR_NEWVSEL_CHUNK:
				res = newVSel.Load(iload);
				break;
			case VINSR_NEWSSEL_CHUNK:
				res = newSSel.Load(iload);
				break;
			case VINSR_NEWSPLINE_CHUNK:
				res = newSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PolyFirstRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount || !IsCompatible(shape, poly, &oldVSel, &oldSSel))
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		}
	shape->MakeFirst(poly, vertex);
	return TRUE;
	}

#define PFR_GENERAL_CHUNK		0x1000
#define PFR_OLDVSEL_CHUNK		0x1010
#define PFR_OLDSSEL_CHUNK		0x1050
#define PFR_OLDSPLINE_CHUNK		0x1060

IOResult PolyFirstRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PFR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&vertex,sizeof(int),&nb);
				break;
			case PFR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case PFR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case PFR_OLDSPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

// Break a polygon at all selected vertices
void BreakSplineAtSelVerts(BezierShape *shape, int poly) {
	Spline3D *spline = shape->splines[poly];
	int altered = 0;
	for(int k = spline->KnotCount()-1; k >= 0; --k) {
		BitArray& vsel = shape->vertSel[poly];
		BitArray& ssel = shape->segSel[poly];
		int vert = k*3+1;
		if(vsel[vert]) {
			if(spline->Closed()) {
				if(k == (spline->KnotCount()-1)) {	// Break at end knot
					break_at_last_knot:
					altered = 1;
					SplineKnot dupKnot(spline->GetKnotType(k),spline->GetLineType(k),
						spline->GetKnotPoint(k),spline->GetInVec(k),spline->GetOutVec(k));
					spline->AddKnot(dupKnot, 0);
					spline->SetOpen();
					vsel.Clear(vert);
					vsel.SetSize(spline->Verts(),1);
					vsel.Shift(RIGHT_BITSHIFT,3);
					vsel.Clear(0);	// New point not selected
					vsel.Clear(1);
					vsel.Clear(2);
					ssel.SetSize(spline->Segments(),1);
					ssel.Shift(RIGHT_BITSHIFT,1);
					ssel.Clear(0);
					k++;	// Increment pointer so we don't miss a knot!
					}
				else
				if(k == 0) {			// Break at first knot
					altered = 1;
					SplineKnot dupKnot(spline->GetKnotType(0),spline->GetLineType(0),
						spline->GetKnotPoint(0),spline->GetInVec(0),spline->GetOutVec(0));
					spline->AddKnot(dupKnot, -1);
					spline->SetOpen();
					vsel.Clear(vert);
					vsel.SetSize(spline->Verts(),1);
					vsel.Clear(spline->Verts()-3);		// New point not selected
					vsel.Clear(spline->Verts()-2);
					vsel.Clear(spline->Verts()-1);
					ssel.SetSize(spline->Segments(),1);
					ssel.Clear(spline->KnotCount()-1);
					}
				else {					// Break somewhere in the middle
					// First, rotate the spline so that the break point is the last one!
					int rotations = 0;
					int lastKnot = spline->KnotCount() - 1;
					while(k < (lastKnot)) {
						SplineKnot dupKnot(spline->GetKnotType(lastKnot),spline->GetLineType(lastKnot),
							spline->GetKnotPoint(lastKnot),spline->GetInVec(lastKnot),spline->GetOutVec(lastKnot));
						spline->DeleteKnot(lastKnot);
						spline->AddKnot(dupKnot, 0);
						rotations++;
						k++;
						}
					vsel.Rotate(RIGHT_BITSHIFT, rotations*3);
					ssel.Rotate(RIGHT_BITSHIFT, rotations);
					k = lastKnot;
					vert = k*3+1;
					goto break_at_last_knot;
					}
				}
			else {
				// Don't do anything if the spline's open and we're breaking at an end vertex!
				if (k == 0 || k == (spline->KnotCount()-1)) {
					vsel.Clear(vert);	// Just turn off the selection bit
					continue;
					}
				int i;
				int newPolySize = spline->KnotCount() - k;
				// OK, We're breaking at a point in the middle -- Copy end points off to a new spline, then
				// delete them from the original!
				Spline3D *newSpline = shape->NewSpline();
				for(i = k; i < spline->KnotCount(); ++i) {
					SplineKnot dupKnot(spline->GetKnotType(i),spline->GetLineType(i),
						spline->GetKnotPoint(i),spline->GetInVec(i),spline->GetOutVec(i));
					newSpline->AddKnot(dupKnot, -1);
					}
				for(i = spline->KnotCount()-1; i > k; --i)
					spline->DeleteKnot(i);
				vsel.Clear(vert);	// Deselect the knot
				// Adjust selection data for this spline
				vsel.SetSize(spline->Verts(),1);
				ssel.SetSize(spline->Segments(),1);
				// Don't forget to create a new selection record for this new spline!
				shape->vertSel.Insert(shape->splineCount - 1, newPolySize * 3);
				shape->segSel.Insert(shape->splineCount - 1, newPolySize - 1);
				shape->polySel.Insert(shape->splineCount - 1);
				}
			}
		}
	if(altered) {
//3-31-99 watje
		shape->UpdateBindList();
		spline->ComputeBezPoints();
		shape->InvalidateGeomCache();
		}
	}

BOOL VertBreakRecord::Redo(BezierShape *shape,int reRecord) {
	if(!IsCompatible(shape, poly, &oldVSel, &oldSSel))
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		selected = shape->polySel[poly];
		}
	BreakSplineAtSelVerts(shape, poly);
	return TRUE;
	}

#define VBRKR_GENERAL_CHUNK		0x1000
#define VBRKR_OLDVSEL_CHUNK		0x1040
#define VBRKR_OLDSSEL_CHUNK		0x1050
#define VBRKR_SPLINE_CHUNK		0x1060

IOResult VertBreakRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VBRKR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&selected,sizeof(int),&nb);
				res = iload->Read(&oldSplineCount,sizeof(int),&nb);
				break;
			case VBRKR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case VBRKR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case VBRKR_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

// Weld a polygon at all selected vertices
// Returns TRUE if weld results in entire spline deletion (degenerate, single vertex poly)

BOOL WeldSplineAtSelVerts(BezierShape *shape, int poly, float thresh) {
	int i;
	Spline3D *spline = shape->splines[poly];
	BitArray& vsel = shape->vertSel[poly];
	BitArray& ssel = shape->segSel[poly];
	int knots = spline->KnotCount();
	BitArray toPrev(knots);
	BitArray toNext(knots);
	toNext.ClearAll();

	// Create weld attachment flag arrays
	for(i = 0; i < knots; ++i) {
		if(vsel[i*3+1]) {
			int next = (i + 1) % knots;
			if(vsel[next*3+1] && Length(spline->GetKnotPoint(i) - spline->GetKnotPoint(next)) <= thresh)
				toNext.Set(i);
			}
		}

	// Now process 'em!
	for(i = knots - 1; i >= 0; --i) {
		if(toNext[i]) {
			int next = (i + 1) % spline->KnotCount();
			if(i == (spline->KnotCount() - 1))
				spline->SetClosed();
			Point3 midpoint = (spline->GetKnotPoint(i) + spline->GetKnotPoint(next)) / 2.0f;
			Point3 nextDelta = midpoint - spline->GetKnotPoint(next);
			Point3 thisDelta = midpoint - spline->GetKnotPoint(i);
			spline->SetKnotPoint(next, spline->GetKnotPoint(next) + nextDelta);
			spline->SetOutVec(next, spline->GetOutVec(next) + nextDelta);
			spline->SetInVec(next, spline->GetInVec(i) + thisDelta);
			if(spline->IsBezierPt(i) || spline->IsBezierPt(next))
				spline->SetKnotType(next, KTYPE_BEZIER_CORNER);
			else
			if(spline->IsCorner(i) || spline->IsCorner(next))
				spline->SetKnotType(next, KTYPE_CORNER);
			spline->DeleteKnot(i);
			}
		}

	// If the polygon is degenerate, blow it away!
	if(spline->KnotCount() < 2) {
		spline->NewSpline();
		shape->DeleteSpline(poly);
		return TRUE;
		}

	// Update the auto points
	shape->UpdateBindList();
	spline->ComputeBezPoints();
	shape->InvalidateGeomCache();

	// Clear out the selection sets for verts and segments
	vsel.SetSize(spline->Verts(),0);
	vsel.ClearAll();
	ssel.SetSize(spline->Segments(),0);
	ssel.ClearAll();
	return FALSE;
	}

BOOL VertWeldRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		selected = shape->polySel[poly];
		}
	deleted = WeldSplineAtSelVerts(shape, poly, thresh);
	return TRUE;
	}

#define VWELDR_GENERAL_CHUNK		0x1000
#define VWELDR_OLDVSEL_CHUNK		0x1040
#define VWELDR_OLDSSEL_CHUNK		0x1050
#define VWELDR_SPLINE_CHUNK			0x1060

IOResult VertWeldRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VWELDR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&thresh,sizeof(float),&nb);
				res = iload->Read(&selected,sizeof(int),&nb);
				res = iload->Read(&deleted,sizeof(BOOL),&nb);
				break;
			case VWELDR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case VWELDR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case VWELDR_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

// A handy 2D floating-point box class

class ESMBox2D {
	public:
		BOOL empty;
		Point2 min, max;
		ESMBox2D() { empty = TRUE; }
		void SetEmpty() { empty = TRUE; }
		ESMBox2D& operator+=(const Point2& p);	// expand this box to include p
	};

ESMBox2D& ESMBox2D::operator+=(const Point2& p) {
	if(empty) {
		min = max = p;
		empty = FALSE;
		}
	else {
		if(p.x < min.x) min.x = p.x;
		if(p.x > max.x) max.x = p.x;
		if(p.y < min.y) min.y = p.y;
		if(p.y > max.y) max.y = p.y;
		}
	return *this;
	}

#define FSGN(x) (x < 0.0f ? -1 : 1)

// Determine if the line segments p1-p2 and p3-p4 intersect
// Returns: 0 (no hit) 1 (hit) 2 (parallel)

static int IntSeg(Point2& p1, Point2& p2, Point2& p3, Point2& p4, Point2& icpt) {
	float C1,C2,DENOM;
	float test1,test2;
	int sgnx1,sgny1,sgnx2,sgny2,hitend;

	/* First, simple minmax test */

	ESMBox2D line1, line2;
	line1.SetEmpty();
	line1 += p1;
	line1 += p2;
	line2.SetEmpty();
	line2 += p3;
	line2 += p4;

	if(line1.max.x < line2.min.x || line1.min.x > line2.max.x || line1.max.y < line2.min.y || line1.min.y > line2.max.y)
		return 0;

	/* A1=-dy1 B1=dx1 A2=-dy2 B2=dx2 */

	Point2 d1 = p2 - p1;
	C1= -(p1.y * d1.x - p1.x * d1.y);

	Point2 d2 = p4 - p3;
	C2= -(p3.y * d2.x - p3.x * d2.y);

	DENOM= -d1.y * d2.x + d2.y * d1.x;

	if(DENOM==0.0)		/* Lines parallel!!! */
	 {
	 test1= -p1.x * d2.y + p1.y * d2.x + C2;
	 test2= -p3.x * d1.y + p3.y * d1.x + C1;
	 if(test1==test2)	/* Lines collinear! */
	  {
	  if(p1 == p3)
	   {
	   icpt = p1;
	   hitend=1;
	   sgnx1=FSGN(p2.x - p1.x);
	   sgny1=FSGN(p2.y - p1.y);
	   sgnx2=FSGN(p3.x - p4.x);
	   sgny2=FSGN(p3.y - p4.y);
	   }
	  else
	  if(p1 == p4)
	   {
	   icpt = p1;
	   hitend=1;
	   sgnx1=FSGN(p2.x - p1.x);
	   sgny1=FSGN(p2.y - p1.y);
	   sgnx2=FSGN(p4.x - p3.x);
	   sgny2=FSGN(p4.y - p3.y);
	   }
	  else
	  if(p2 == p3)
	   {
	   icpt = p2;
	   hitend=1;
	   sgnx1=FSGN(p1.x - p2.x);
	   sgny1=FSGN(p1.y - p2.y);
	   sgnx2=FSGN(p3.x - p4.x);
	   sgny2=FSGN(p3.y - p4.y);
	   }
	  else
	  if(p2 == p4)
	   {
	   icpt = p2;
	   hitend=1;
	   sgnx1=FSGN(p1.x - p2.x);
	   sgny1=FSGN(p1.y - p2.y);
	   sgnx2=FSGN(p4.x - p3.x);
	   sgny2=FSGN(p4.y - p3.y);
	   }
	  else
	   hitend=0;

	  if(hitend)
	   {
	   if(sgnx1==sgnx2 && sgny1==sgny2)	/* Hit at endpoint */
	    return(1);
	   }
	  return(2);
	  }
	 return(0);
	 }

	if(p1.x == p2.x)
	 icpt.x = p1.x;
	else
	if(p3.x == p4.x)
	 icpt.x = p3.x;
	else
	icpt.x = (d1.x * C2 - d2.x * C1) / DENOM;

	if(p1.y == p2.y)
	 icpt.y = p1.y;
	else
	if(p3.y == p4.y)
	 icpt.y = p3.y;
	else
	icpt.y = (-C1 * d2.y + C2 * d1.y) / DENOM;

	/* See if it hit line 1 */

	if(p1.x < p2.x)
	 {
	 if(icpt.x < p1.x || icpt.x > p2.x)
	  return(0);
	 }
	else
	 {
	 if(icpt.x < p2.x || icpt.x > p1.x)
	  return(0);
	 }
	if(p1.y < p2.y)
	 {
	 if(icpt.y < p1.y || icpt.y > p2.y)
	  return(0);
	 }
	else
	 {
	 if(icpt.y < p2.y || icpt.y > p1.y)
	  return(0);
	 }

	/* See if it hit line 2 */

	if(p3.x < p4.x)
	 {
	 if(icpt.x < p3.x || icpt.x > p4.x)
	  return(0);
	 }
	else
	 {
	 if(icpt.x < p4.x || icpt.x > p3.x)
	  return(0);
	 }
	if(p3.y < p4.y)
	 {
	 if(icpt.y < p3.y || icpt.y > p4.y)
	  return(0);
	 }
	else
	 {
	 if(icpt.y < p4.y || icpt.y > p3.y)
	  return(0);
	 }

	/* It hits both! */

	return(1);
	}

// Determine where the line segments p1-p2 and p3-p4 intersect
static int FindIntercept(Point2& p1, Point2& p2, Point2& p3, Point2& p4, Point2& icpt) {
	float C1,C2,DENOM;
	Point2 d1,d2;
	float test1,test2;

	d1 = p2 - p1;
	C1= -(p1.y * d1.x - p1.x * d1.y);

	d2 = p4 - p3;
	C2= -(p3.y * d2.x - p3.x * d2.y);

	DENOM= -d1.y * d2.x + d2.y * d1.x;

	if(DENOM==0.0)		/* Lines parallel!!! */
	 {
	 test1 = p1.x * -d2.y + p1.y * d2.x + C2;
	 test2 = p3.x * -d1.y + p3.y * d1.x + C1;
	 if(test1==test2)	/* Lines collinear! */
	  return(2);
	 return(0);
	 }

	if(p1.x == p2.x)
	 icpt.x = p1.x;
	else
	if(p3.x == p4.x)
	 icpt.x = p3.x;
	else
	icpt.x = (d1.x * C2 - d2.x * C1) / DENOM;

	if(p1.y == p2.y)
	 icpt.y = p1.y;
	else
	if(p3.y == p4.y)
	 icpt.y = p3.y;
	else
	icpt.y = (C1 * (-d2.y) - C2 * (-d1.y)) / DENOM;

	return(1);
	}



class ESMTemplate {
	public:
		int points;
		Point2 *pts;
		ESMTemplate(Spline3D *spline);
		~ESMTemplate();
		int Points() { return points; }
		int OriginalSegment(int seg) { return seg / 10; }
//		BOOL Orient();
		void FlagInside(Spline3D *spline, IntTab& flags);
		BOOL SurroundsPoint(Point2& point);
	};

ESMTemplate::ESMTemplate(Spline3D *spline) {
	int segments = spline->Segments();
	points = segments * 10 + 1;
	pts = new Point2[points];
	int point;
	Point3 p3;
	int i,j;
	float pct;
	for(i = 0, point = 0; i < segments; ++i) {
		for(j = 0, pct = 0.0f; j < 10; ++j, pct += 0.1f, ++point) {
			p3 = spline->InterpBezier3D(i, pct);
			pts[point] = Point2(p3.x, p3.y);
			}
		}
	if(spline->Closed())
		pts[point] = pts[0];
	else {
		p3 = spline->InterpBezier3D(segments, 0.0f);
		pts[point] = Point2(p3.x, p3.y);
		}
	}

ESMTemplate::~ESMTemplate() {
	delete [] pts;
	}

static int myrand(int mask) {
	return rand() & mask;
	}

BOOL ESMTemplate::SurroundsPoint(Point2& point) {
	int ix,ix2,outs,xout,yout;
	int hits,cept,trials,odds,evens;
	Point2 point2, point3, point4, where;
		
	evens=odds=0;
	
	/* Do three trials -- use the one with most */

	for(trials=0; trials<3; ++trials)
		{

		surr_try:
		point2.x = point.x + (float)(myrand(63) + 1);		/* Random second point */
		point2.y = point.y + (float)(myrand(63) - 32);
//DebugPrint("Point:%.2f %.2f Point2:%.2f %.2f\n",point.x,point.y,point2.x,point2.y);
		hits=0;
		for(ix=0; ix<(points - 1); ++ix)
			{
			ix2=ix+1;
	
			point3 = pts[ix];
			point4 = pts[ix2];

			/* Check for intercept */

			cept=FindIntercept(point, point2, point3, point4, where);

			switch(cept)
				{
				case 1:
					/* If lines intersect, check to see if it's in segment */
					if(where.x > point.x) {
						outs = 0;
						/* Abort test if ray goes thru endpoint */
						if(where == point3 || where == point4)
							goto surr_try;
	
						/* Figure out major axis of test line */
	
						xout=(fabs(point4.x - point3.x) > fabs(point4.y - point3.y)) ? 2:1;
						yout=(xout==2) ? 1:2;
	
						/* If ray intercepts line, record hit */
	
						if(point3.x < point4.x)
							{
							if(where.x < point3.x || where.x > point4.x)
								outs+=xout;
							}
						else
						if(point3.x > point4.x)
							{
							if(where.x < point4.x || where.x > point3.x)
								outs+=xout;
							}
						else
							outs++;
	
						if(point3.y < point4.y)
							{
							if(where.y < point3.y || where.y > point4.y)
								outs+=yout;
							}
						else
						if(point3.y > point4.y)
							{
							if(where.y < point4.y || where.y > point3.y)
								outs+=yout;
							}
						else
							outs++;
	
						/* If not outside both coords, it hits! */
	
						if(outs<2)
							hits++;
						}
					break;
				case 2:
					goto surr_try;
				case 0:
					break;
				}
			}
	
	/* odd # hits = surrounded! */
	
		if(hits & 1)
			odds++;
		else
			evens++;
		}
	
	/* even # hits = outside! */
	
	if(odds>evens)
		return(TRUE);
	return(FALSE);
	}

void ESMTemplate::FlagInside(Spline3D *spline, IntTab& flags) {
//DebugPrint("Starting FlagInside\n");
	int segs = spline->Segments();
	for(int i = 0; i < segs; ++i) {
		Point3 p = spline->InterpBezier3D(i, 0.5f);	// Use midpoint to determine whether we're inside or out
		flags[i] = flags[i] | SurroundsPoint(Point2(p.x, p.y)) ? POLYINSIDE : POLYOUTSIDE;
//DebugPrint("Seg %d inside:%s outside:%s\n",i, (flags[i] & POLYINSIDE) ? "YES":"NO", (flags[i] & POLYOUTSIDE) ? "YES":"NO");
		}
	}

class BoolHitData {
	public:
		int id;
		int poly;
		int seg;
		float pct;
		Point2 where;
		Point3 force;
		BOOL gotForce;
		BoolHitData() { gotForce = FALSE; }
		BoolHitData(int id, int poly, int seg, float pct, Point2& where)
			{ gotForce = FALSE; this->id = id; this->poly = poly; this->seg = seg; this->pct = pct; this->where = where; }
		int operator==( const BoolHitData& b ) const { 	return (poly==b.poly && seg==b.seg && pct==b.pct && where==b.where); }
	};

class BoolHit {
	public:
		int count;
		BoolHitData *data;
		BoolHit() { data = NULL; }
		~BoolHit() { if(data) delete [] data; }
		void SetSize(int count);
		void Set(Spline3D *spline, int location, int id, int poly, int seg, Point2& where);
		void Sort();
		BOOL GotForcePoint(BoolHitData& h, Point3* force);
		void SetForcePoint(BoolHitData& h, Point3& force);
	};

void BoolHit::SetSize(int count) {
	data = new BoolHitData[count];
	this->count = count;
	for(int i=0; i<count; ++i)
		data[i].gotForce = FALSE;
	}

BOOL BoolHit::GotForcePoint(BoolHitData& h, Point3* force) {
	for(int i = 0; i < count; ++i) {
		if(data[i].id == h.id && data[i].gotForce) {
			*force = data[i].force;
			return TRUE;
			}
		}
	return FALSE;
	}

void BoolHit::SetForcePoint(BoolHitData& h, Point3& force) {
	h.gotForce = TRUE;
	h.force = force;
//DebugPrint("Set force for id# %d to %.4f %.4f\n",h.id,force.x, force.y);
	}

#define CURVELOOPS 15

float Calc2DCurvePct(Spline3D *spline, int seg, Point2& where) {
	int count = CURVELOOPS;
	float low = 0.0f;
	float high = 1.0f;
	float bestL,bestPos;
	while(count--) {
		float range = high - low;
		float step = range / 10.0f;
		float pos;
		int i;

		for(i = 0, pos = low; i <= 10; ++i, pos += step) {
			Point3 p = spline->InterpBezier3D(seg, pos);
			Point2 p1 = Point2(p.x, p.y);
			float l = Length(p1 - where);
			if(i == 0 || l < bestL) {
				bestL = l;
				bestPos = pos;
				}
			}
		low = bestPos - step;
		if(low < 0.0f)
			low = 0.0f;
		high = bestPos + step;
		if(high > 1.0f)
			high = 1.0f;
		}
	return bestPos;
	}

void BoolHit::Set(Spline3D *spline, int location, int id, int poly, int seg, Point2& where) {
	// Find where on the curve the hit occurred, percentage-wise
	float pct = Calc2DCurvePct(spline, seg, where);
//DebugPrint("Hit %d on poly %d, seg:%d at %.4f %.4f was %.4f percent\n",location,poly,seg,where.x,where.y,pct);
//Point3 check = spline->InterpBezier3D(seg,pct);
//DebugPrint("Cross-check: %.4f %.4f\n",check.x,check.y);
	data[location] = BoolHitData(id, poly, seg, pct, where);
	}

void BoolHit::Sort() {
	BoolHitData temp;
	unsigned int srtcnt;
	register unsigned int srt1,srt2,srt3,srt4;

	srtcnt=count+1;

	nxtsc:
	srtcnt/=2;
	if(srtcnt==0) {
		int ix,jx;
		/* Eliminate duplicates */
		ix=0;
		jx=1;
		dup_loop:
	 	if(data[ix] == data[jx])
			jx++;
		else {
			ix++;
			if(ix!=jx)
				data[ix] = data[jx];
			jx++;
			}
		if(jx<count)
			goto dup_loop;
		count=ix+1;
		return;
		}
	srt1=1;
	srt2=count-srtcnt;

	srtsw1:
	srt3=srt1;

	srtsw2:
	srt4=srt3+srtcnt;

	if(data[srt3-1].poly < data[srt4-1].poly)
		goto swap;
	if(data[srt3-1].poly > data[srt4-1].poly)
		goto next;
	if(data[srt3-1].seg < data[srt4-1].seg)
		goto swap;
	if(data[srt3-1].seg > data[srt4-1].seg)
		goto next;
	if(data[srt3-1].pct >= data[srt4-1].pct)
		goto next;

	swap:
	temp = data[srt3-1];
	data[srt3-1] = data[srt4-1];
	data[srt4-1] = temp;
	if(srtcnt<srt3) {
		srt3-=srtcnt;
		goto srtsw2;
		}

	next:
	srt1++;
	if(srt1<=srt2)
		goto srtsw1;
	goto nxtsc;
	}

static void BoundSpline2D(Spline3D *spline, ESMBox2D& box) {
	Point2 p2;
	Point3 p3;
	box.SetEmpty();
	int knots = spline->KnotCount();
	int closed = spline->Closed();
	int lastKnot = knots - 1;
	for(int i = 0; i < knots; ++i) {
		p3 = spline->GetKnotPoint(i);
		p2.x = p3.x;
		p2.y = p3.y;
		box += p2;
		if (i > 0 || closed) {
			p3 = spline->GetInVec(i);
			p2.x = p3.x;
			p2.y = p3.y;
			box += p2;
			}
		if(i < lastKnot || closed) {
			p3 = spline->GetOutVec(i);
			p2.x = p3.x;
			p2.y = p3.y;
			box += p2;
			}
		}
	}

static void BoolCopy(BezierShape *shape, int poly, IntTab& flags, int mask) {
	BitArray &ssel = shape->segSel[poly];
	ssel.ClearAll();
	Spline3D *spline = shape->splines[poly];
	int segs = spline->Segments();
	int i;
	// Mark the segments that don't contain the mask flag for deletion
	for(i = 0; i < segs; ++i) {
		if(!(flags[i] & mask))
			ssel.Set(i);
		}

	// Now delete all those segments that we just flagged!
#ifndef DEBUGBOOL
	DeleteSelSegs(shape, poly);
#endif
	}																

// Weld all polygons in the shape at common endpoints

static BOOL WeldShape(BezierShape *shape) {
	int i,j;
	int lastKnot1,lastKnot2,knots1,knots2;
	Point3 p;
	BOOL attached;
	do {
		attached = FALSE;

		for(i = 0; i < shape->splineCount; ++i) {
			Spline3D *spline1 = shape->splines[i];
			knots1 = spline1->KnotCount();
			lastKnot1 = knots1 - 1;
			p = spline1->GetKnotPoint(0);
			Point2 s1first = Point2(p.x, p.y);
			p = spline1->GetKnotPoint(lastKnot1);
			Point2 s1last = Point2(p.x, p.y);

			for(j = shape->splineCount - 1; j > i; --j) {
				Spline3D *spline2 = shape->splines[j];
				knots2 = spline2->KnotCount();
				lastKnot2 = knots2 - 1;
				p = spline2->GetKnotPoint(0);
				Point2 s2first = Point2(p.x, p.y);
				p = spline2->GetKnotPoint(lastKnot2);
				Point2 s2last = Point2(p.x, p.y);
//DebugPrint("Checking %d/%d: %.4f %.4f - %.4f %.4f / %.4f %.4f - %.4f %.4f\n",i,j,s1first.x,s1first.y,s1last.x,s1last.y,
//	s2first.x,s2first.y,s2last.x,s2last.y);
				if(s1first == s2first) {
					spline2->Reverse();
					spline1->Prepend(spline2);
					shape->DeleteSpline(j);
//DebugPrint("Welded 1!\n");
					attached = TRUE;
					}
				else
				if(s1first == s2last) {
					spline1->Prepend(spline2);
					shape->DeleteSpline(j);
//DebugPrint("Welded 2!\n");
					attached = TRUE;
					}
				else
				if(s1last == s2first) {
					spline1->Append(spline2);
					shape->DeleteSpline(j);
//DebugPrint("Welded 3!\n");
					attached = TRUE;
					}
				else
				if(s1last == s2last) {
					spline2->Reverse();
					spline1->Append(spline2);
					shape->DeleteSpline(j);
//DebugPrint("Welded 4!\n");
					attached = TRUE;
					}
				}
			}
		} while(attached);

	// Now we go thru and make sure the resulting polygons are valid -- That is,
	// each must have coincident first and last points.  These polygons are stitched
	// together at the endpoints and closed.  If others are left, something
	// went hideously wrong.

	int polys = shape->splineCount;
//DebugPrint("Boolean resulted in %d polys\n",polys);
	for(i = 0; i < polys; ++i) {
		Spline3D *spline = shape->splines[i];
		// Make sure the first point is the same as the last, then close it
		int lastKnot = spline->KnotCount() - 1;
		p = spline->GetKnotPoint(0);
		Point2 first = Point2(p.x, p.y);
		p = spline->GetKnotPoint(lastKnot);
		Point2 last = Point2(p.x, p.y);
		if(!(first == last)) {
//DebugPrint("First:%.8f %.8f Last:%.8f %.8f\n",first.x, first.y, last.x, last.y);
			return FALSE;
			}
		spline->SetKnotType(0, KTYPE_BEZIER_CORNER);
		spline->SetInVec(0, spline->GetInVec(lastKnot));
		spline->DeleteKnot(lastKnot);
		shape->splines[i]->SetClosed();
		}

	return TRUE;
	}

// PerformBoolean return codes
#define BOOL_OK 1
#define BOOL_COINCIDENT_VERTEX	-1
#define BOOL_MUST_OVERLAP		-2
#define BOOL_WELD_FAILURE		-3

static int PerformBoolean(BezierShape *shape, int poly1, int poly2, int op, int *newPolyNum) {
	Spline3D *spline1 = shape->splines[poly1];
	int knots1 = spline1->KnotCount();
	Spline3D *spline2 = shape->splines[poly2];
	int knots2 = spline2->KnotCount();
	int i,j;

	// Can't have coincident vertices (why?)
	for(i = 0; i < knots1; ++i) {
		for(j = 0; j < knots2; ++j) {
			if(spline1->GetKnotPoint(i) == spline2->GetKnotPoint(j))
				return BOOL_COINCIDENT_VERTEX;
			}
		}
	
	// Make sure the polygons overlap in 2D
	ESMBox2D bound1, bound2;
	BoundSpline2D(spline1, bound1);
	BoundSpline2D(spline2, bound2);
	if(bound2.min.x > bound1.max.x || bound2.max.x < bound1.min.x ||
	   bound2.max.y < bound1.min.y || bound2.min.y > bound1.max.y) {
		no_overlap:
		return BOOL_MUST_OVERLAP;
		}

	// Load the splines into special 2D objects which contain the entire interpolated spline
	ESMTemplate t1(spline1);
	int points1 = t1.Points();
	int last1 = points1 - 1;
	ESMTemplate t2(spline2);
	int points2 = t2.Points();
	int last2 = points2 - 1;

	// Find the intersections between the two splines
	// This is a two-pass procedure -- Pass 0 counts the number of collisions,
	// and pass 1 records them.

	BoolHit hit;
	for(int pass = 0; pass < 2; ++pass) {
		int overlap = 0;
		int hitID = 0;
		for(i = 0; i < last1; ++i) {
			Point2 i1 = t1.pts[i];
			Point2 i2 = t1.pts[i+1];
			int iseg = t1.OriginalSegment(i);
			for(j = 0; j < last2; ++j) {
				Point2 j1 = t2.pts[j];
				Point2 j2 = t2.pts[j+1];
				int jseg = t2.OriginalSegment(j);

				/* Now compare line endpoints for collision */
	
				if(i1 == j1 || i1 == j2) {
					if(pass == 1) {
						hit.Set(spline1, overlap++, hitID, 0, iseg, i1);
						hit.Set(spline2, overlap++, hitID++, 1, jseg, i1);
						}
					else
						overlap += 2;
					}
				else
				if(i2 == j1 || i2 == j2) {
					if(pass == 1) {
						hit.Set(spline1, overlap++, hitID, 0, iseg, i2);
						hit.Set(spline2, overlap++, hitID++, 1, jseg, i2);
						}
					else
						overlap += 2;
					}
	
				/* Now test line segments themselves for collisions */
		
				Point2 dummy;
				if(IntSeg(i1, i2, j1, j2, dummy)==1)
					{
					Point2 where;
					FindIntercept(i1, i2, j1, j2, where);
					if(pass==1)
						{
						hit.Set(spline1, overlap++, hitID, 0, iseg, where);
						hit.Set(spline2, overlap++, hitID++, 1, jseg, where);
						}
					else
						overlap+=2;
					}
				}
			}
		if(pass==0)
			{
			if(overlap==0)
				goto no_overlap;
			hit.SetSize(overlap);
			}
		}

	// Sort the hits in ascending order and eliminate dupes
	hit.Sort();

	/* Go thru hitlist and adjust percentages for proper splits						*/
	/* This is necessary because the percentages of each cut are in relation		*/
	/* to the original segment, and as each cut is made, the lower percentages		*/
	/* must be adjusted.  Example: Original cuts at 25%, 50% and 75%.  After the	*/
	/* cut at 75% is made, the 50% cut becomes 66.6%.  After the 50% cut is made,	*/
	/* the 25% cut becomes 50%.														*/

	for(i = hit.count - 1; i > 0; --i)
		{
		j = i - 1;
		if(hit.data[j].poly == hit.data[i].poly && hit.data[j].seg == hit.data[i].seg)
		hit.data[i].pct = hit.data[i].pct / hit.data[j].pct;
		}

	// Copy the splines to a work shape
	BezierShape workShape;
	Spline3D *work0, *work1, *work[2];
	work0 = work[0] = workShape.NewSpline();
	*work[0] = *spline1;
	work1 = work[1] = workShape.NewSpline();
	*work[1] = *spline2;
	workShape.UpdateSels();

	/* Go thru hitlist and split up the original polygons */

	for(i = 0; i < hit.count; ++i)
		{
		BoolHitData &h = hit.data[i];
		Point3 force;
		int seg1 = h.seg;
		int seg2 = (h.seg + 1) % work[h.poly]->KnotCount();

		// Split 'em up and make sure the splits in the two polys are at the EXACT same point
		if(h.pct < 0.001) {
			if(hit.GotForcePoint(h, &force))
				workShape.splines[h.poly]->SetKnotPoint(seg1, force);
			else
				hit.SetForcePoint(h, workShape.splines[h.poly]->GetKnotPoint(seg1));
			}
		else
		if(h.pct > 0.999) {
			if(hit.GotForcePoint(h, &force))
				workShape.splines[h.poly]->SetKnotPoint(seg2, force);
			else
				hit.SetForcePoint(h, workShape.splines[h.poly]->GetKnotPoint(seg2));
			}
		else {
			RefineSegment(&workShape, h.poly, seg1, h.pct);
			if(hit.GotForcePoint(h, &force))
				workShape.splines[h.poly]->SetKnotPoint(seg1+1, force);
			else
				hit.SetForcePoint(h, workShape.splines[h.poly]->GetKnotPoint(seg1+1));
			}
		}

	// Set up some flags arrays
	IntTab flags0, flags1;
	IntTab *flags[2];
	flags[0] = &flags0;
	flags[1] = &flags1;
	int segs = work0->Segments();
	flags0.SetCount(segs);
	for(i = 0; i < segs; ++i)
		flags0[i] = 0;
	segs = work1->Segments();
	flags1.SetCount(segs);
	for(i = 0; i < segs; ++i)
		flags1[i] = 0;

	/* Polygons are diced up, now mark each piece	*/
	/* as being inside or outside the other polygon	*/

	t1.FlagInside(work1, flags1);
	t2.FlagInside(work0, flags0);

	/* Now delete spans according to boolean operator	*/
	/* UNION: Delete inside spans on both				*/
	/* SUBTRACTION: Delete pri/inside, sec/outside		*/
	/* INTERSECTION: Delete outside spans on both		*/

	switch(op)
		{
		case BOOL_UNION:
			BoolCopy(&workShape,1,flags1,POLYOUTSIDE);
			BoolCopy(&workShape,0,flags0,POLYOUTSIDE);
			break;
		case BOOL_SUBTRACTION:
			BoolCopy(&workShape,1,flags1,POLYINSIDE);
			BoolCopy(&workShape,0,flags0,POLYOUTSIDE);
			break;
		case BOOL_INTERSECTION:
			BoolCopy(&workShape,1,flags1,POLYINSIDE);
			BoolCopy(&workShape,0,flags0,POLYINSIDE);
			break;
		}

	/* Weld boolean pieces together, if necessary */
	
#ifndef DEBUGBOOL
	if(TRUE /*weldBooleans*/) {
		if(!WeldShape(&workShape))
			return BOOL_WELD_FAILURE;
		}

	// Get rid of the originals
	if(poly1 < poly2) {
		shape->DeleteSpline(poly2);
		shape->DeleteSpline(poly1);
		}
	else {
		shape->DeleteSpline(poly1);
		shape->DeleteSpline(poly2);
		}

	// Add all our new ones
	int oldPolys = shape->splineCount;
	int newPolys = workShape.splineCount;
	for(i = 0; i < newPolys; ++i) {
		Spline3D *poly = shape->NewSpline();
		*poly = *workShape.splines[i];
		}
	shape->UpdateSels();
	if(newPolys == 1) {
		shape->polySel.Set(oldPolys);
		if(newPolyNum)
			*newPolyNum = oldPolys;
		}
	else {
		if(newPolyNum)
			*newPolyNum = -1;
		}
#else
	*shape = workShape;
#endif // DEBUGBOOL
	return BOOL_OK;
	}

BOOL BooleanRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly1 >= shape->splineCount || poly2 >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline1 = *(shape->splines[poly1]);
		oldSpline2 = *(shape->splines[poly2]);
		oldVSel1 = shape->vertSel[poly1];
		oldSSel1 = shape->segSel[poly1];
		oldVSel2 = shape->vertSel[poly2];
		oldSSel2 = shape->segSel[poly2];
		}
	PerformBoolean(shape, poly1, poly2, operation, NULL);
	return TRUE;
	}

#define BOOLR_GENERAL_CHUNK		0x1001
#define BOOLR_OLDSPLINE1_CHUNK	0x1010
#define BOOLR_OLDVSEL1_CHUNK	0x1020
#define BOOLR_OLDSSEL1_CHUNK	0x1030
#define BOOLR_OLDSPLINE2_CHUNK	0x1040
#define BOOLR_OLDVSEL2_CHUNK	0x1050
#define BOOLR_OLDSSEL2_CHUNK	0x1060

IOResult BooleanRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case BOOLR_GENERAL_CHUNK:
				res = iload->Read(&poly1,sizeof(int),&nb);
				res = iload->Read(&poly2,sizeof(int),&nb);
				res = iload->Read(&operation,sizeof(int),&nb);
				res = iload->Read(&oldSplineCount,sizeof(int),&nb);
				break;
			case BOOLR_OLDSPLINE1_CHUNK:
				res = oldSpline1.Load(iload);
				break;
			case BOOLR_OLDVSEL1_CHUNK:
				res = oldVSel1.Load(iload);
				break;
			case BOOLR_OLDSSEL1_CHUNK:
				res = oldSSel1.Load(iload);
				break;
			case BOOLR_OLDSPLINE2_CHUNK:
				res = oldSpline2.Load(iload);
				break;
			case BOOLR_OLDVSEL2_CHUNK:
				res = oldVSel2.Load(iload);
				break;
			case BOOLR_OLDSSEL2_CHUNK:
				res = oldSSel2.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}


/*-------------------------------------------------------------------*/		

static void DoAttach(BezierShape *shape, BezierShape *attShape, int mtlOffset) {
	int boff = shape->splineCount;
	for(int i = 0; i < attShape->splineCount; ++i) {
		int index = shape->splineCount;
		Spline3D *spline = shape->NewSpline();
		*spline = *(attShape->splines[i]);
		for(int seg = 0; seg < spline->Segments(); ++seg)
			spline->SetMatID(seg, spline->GetMatID(seg) + mtlOffset);
		shape->vertSel.Insert(shape->splineCount-1,spline->Verts());
		shape->segSel.Insert(shape->splineCount-1,spline->Segments());
		shape->polySel.Insert(shape->splineCount-1);
		shape->vertSel[index] = attShape->vertSel[i];
		shape->segSel[index] = attShape->segSel[i];
		shape->polySel.Set(index, attShape->polySel[i]);
		// Flush all aux data in attached spline (prevents ResolveTopoChanges problems)
		for(int j = 0; j < spline->KnotCount(); ++j)
			spline->SetAux2(j, -1);
		}
//copy over binds + offset
	for (i = 0; i < attShape->bindList.Count();i++)
		{
		attShape->bindList[i].pointSplineIndex += boff;
		attShape->bindList[i].segSplineIndex += boff;
		

		shape->bindList.Append(1,&attShape->bindList[i],1);
		}
	for (i = 0; i < shape->bindList.Count();i++)
		{
		int index = 0;
		int spindex = shape->bindList[i].pointSplineIndex;
		if (shape->bindList[i].isEnd)
				index = shape->splines[spindex]->KnotCount()-1;
		shape->bindList[i].bindPoint = shape->splines[spindex]->GetKnotPoint(index);
		shape->bindList[i].segPoint = shape->splines[spindex]->GetKnotPoint(index);

		}

	}

BOOL AttachRecord::Redo(BezierShape *shape,int reRecord) {
	if(reRecord)
		oldSplineCount = shape->splineCount;
	DoAttach(shape, &attShape, 0);
	return TRUE;
	}

#define ATTR_GENERAL_CHUNK		0x1001
#define ATTR_ATTSHAPE_CHUNK		0x1010

IOResult AttachRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case ATTR_GENERAL_CHUNK:
				res = iload->Read(&oldSplineCount,sizeof(int),&nb);
				break;
			case ATTR_ATTSHAPE_CHUNK:
				res = attShape.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void ChangeVertexType(BezierShape *shape, int poly, int vertex, int type) {
	Spline3D *spline = shape->splines[poly];
	
	// If positive vertex number, do it to just one vertex
	if(vertex >= 0) {
		spline->SetKnotType(vertex, type);
		spline->ComputeBezPoints();
		shape->InvalidateGeomCache();
		return;
		}

	// Otherwise, do it to all selected vertices!
	int knots = spline->KnotCount();
	BitArray &vsel = shape->vertSel[poly];
	for(int i = 0; i < knots; ++i) {
		if(vsel[i*3+1])
			spline->SetKnotType(i, type);
		}
	spline->ComputeBezPoints();
	shape->InvalidateGeomCache();
	}

BOOL VertChangeRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount || (vertex > 0 && vertex >= shape->splines[poly]->KnotCount()))
		return FALSE;
	if(reRecord) {
		oldSpline = *shape->splines[poly];
		}
	ChangeVertexType(shape, poly, vertex, type);
	return TRUE;
	}

#define VCHG_GENERAL_CHUNK		0x1001
#define VCHG_SPLINE_CHUNK		0x1010

IOResult VertChangeRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VCHG_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&vertex,sizeof(int),&nb);
				res = iload->Read(&type,sizeof(int),&nb);
				break;
			case VCHG_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void ChangeSegmentType(BezierShape *shape, int poly, int segment, int type) {
	Spline3D *spline = shape->splines[poly];
	
	// If positive segment number, do it to just one segment
	if(segment >= 0) {
		spline->SetLineType(segment, type);
		spline->ComputeBezPoints();
		shape->InvalidateGeomCache();
		return;
		}

	// Otherwise, do it to all selected vertices!
	int segments = spline->Segments();
	BitArray &ssel = shape->segSel[poly];
	for(int i = 0; i < segments; ++i) {
		if(ssel[i])
			spline->SetLineType(i, type);
		}
	spline->ComputeBezPoints();
	shape->InvalidateGeomCache();
	}

BOOL SegChangeRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount || (segment > 0 && segment >= shape->splines[poly]->Segments()))
		return FALSE;
	if(reRecord) {
		oldSpline = *shape->splines[poly];
		}
	ChangeSegmentType(shape, poly, segment, type);
	return TRUE;
	}

#define SCHG_GENERAL_CHUNK		0x1001
#define SCHG_SPLINE_CHUNK		0x1010

IOResult SegChangeRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SCHG_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&segment,sizeof(int),&nb);
				res = iload->Read(&type,sizeof(int),&nb);
				break;
			case SCHG_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void ChangePolyType(BezierShape *shape, int poly, int type) {
	Spline3D *spline = shape->splines[poly];
	int i;
	int knots = spline->KnotCount();
	int segments = spline->Segments();
	switch(type) {
		case LTYPE_CURVE:
			for(i = 0; i < knots; ++i)
				spline->SetKnotType(i, KTYPE_AUTO);
			spline->ComputeBezPoints();
			for(i = 0; i < knots; ++i)
				spline->SetKnotType(i, KTYPE_BEZIER);
			break;
		case LTYPE_LINE:
			for(int i = 0; i < knots; ++i)
				spline->SetKnotType(i, KTYPE_CORNER);
			break;
		}
	for(i = 0; i < segments; ++i)
		spline->SetLineType(i, type);
	spline->ComputeBezPoints();
	shape->InvalidateGeomCache();
	}

BOOL PolyChangeRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline = *shape->splines[poly];
		}
	ChangePolyType(shape, poly, type);
	return TRUE;
	}

#define PCHG_GENERAL_CHUNK		0x1001
#define PCHG_SPLINE_CHUNK		0x1010

IOResult PolyChangeRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PCHG_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&type,sizeof(int),&nb);
				break;
			case PCHG_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

// Delete all selected vertices
// Returns TRUE if the operation results in the polygon being deleted
int DeleteSelVerts(BezierShape *shape, int poly) {
	Spline3D *spline = shape->splines[poly];
	int segs = spline->Segments();
	int knots = spline->KnotCount();

	// If less than two vertices would remain, blow it away!
	if((knots - shape->vertSel[poly].NumberSet()) < 2) {
		shape->DeleteSpline(poly);
//5-27-99 watje
		shape->UpdateBindList();

		return TRUE;				// It's TRUE -- We deleted the spline!
		}

	int altered = 0;
	BitArray& vsel = shape->vertSel[poly];
	BitArray& ssel = shape->segSel[poly];

	for(int k = knots-1; k >= 0; --k) {
		if(vsel[k*3+1]) {
			altered = 1;
			spline->DeleteKnot(k);
			}
		}

	if(altered) {
		vsel.SetSize(spline->Verts(),1);
		vsel.ClearAll();
		ssel.SetSize(spline->Segments(),1);
		ssel.ClearAll();
//3-31-99 watje
		shape->UpdateBindList();
		spline->ComputeBezPoints();
		shape->InvalidateGeomCache();
		}
	return FALSE;	// The poly's still there
	}

BOOL VertDeleteRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	if(reRecord) {
		oldSpline = *(shape->splines[poly]);
		oldVSel = shape->vertSel[poly];
		oldSSel = shape->segSel[poly];
		selected = shape->polySel[poly];
		}
	deleted = DeleteSelVerts(shape, poly);
	return TRUE;
	}

#define VDELR_GENERAL_CHUNK		0x1000
#define VDELR_OLDVSEL_CHUNK		0x1040
#define VDELR_OLDSSEL_CHUNK		0x1050
#define VDELR_SPLINE_CHUNK		0x1060

IOResult VertDeleteRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VDELR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&selected,sizeof(int),&nb);
				res = iload->Read(&deleted,sizeof(int),&nb);
				res = iload->Read(&oldSplineCount,sizeof(int),&nb);
				break;
			case VDELR_OLDVSEL_CHUNK:
				res = oldVSel.Load(iload);
				break;
			case VDELR_OLDSSEL_CHUNK:
				res = oldSSel.Load(iload);
				break;
			case VDELR_SPLINE_CHUNK:
				res = oldSpline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL CreateLineRecord::Redo(BezierShape *shape,int reRecord) {
	shape->InsertSpline(&spline,shape->splineCount);
	shape->UpdateSels();
	return TRUE;
	}

#define CRELR_SPLINE_CHUNK		0x1000

IOResult CreateLineRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case CRELR_SPLINE_CHUNK:
				res = spline.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void CopySpline(BezierShape *shape, int poly, BOOL selOriginal, BOOL selCopy) {
	Spline3D *spline = shape->NewSpline();
	*spline = *(shape->splines[poly]);
	shape->UpdateSels();	// Make sure it readies the selection set info
	shape->InvalidateGeomCache();
	shape->polySel.Set(poly, selOriginal);
	shape->polySel.SetSize(*shape);		// Expand the selection array
	shape->polySel.Set(shape->splineCount - 1, selCopy);
	}

BOOL PolyCopyRecord::Redo(BezierShape *shape,int reRecord) {
	if(poly >= shape->splineCount)
		return FALSE;
	CopySpline(shape, poly, selOrig, selCopy);
	return TRUE;
	}

#define PCOPYR_GENERAL_CHUNK		0x1000

IOResult PolyCopyRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PCOPYR_GENERAL_CHUNK:
				res = iload->Read(&poly,sizeof(int),&nb);
				res = iload->Read(&selOrig,sizeof(BOOL),&nb);
				res = iload->Read(&selCopy,sizeof(BOOL),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void CopySegments(BezierShape *shape, BOOL selCopy) {
	int oldSplineCount = shape->SplineCount();
	for(int poly = 0; poly < oldSplineCount; ++poly) {
		if(shape->segSel[poly].NumberSet()) {
			Spline3D *spline = shape->splines[poly];
			int segments = spline->Segments();
			int knots = spline->KnotCount();
			// If all segments selected, copy the whole polygon!
			if(shape->segSel[poly].NumberSet() == segments) {
				Spline3D *newSpline = shape->NewSpline();
				*newSpline = *spline;
				}
			else {
				int end = segments;
				for(int seg = 0; seg < end; ++seg) {
					if(shape->segSel[poly][seg]) {
						Spline3D *newSpline = shape->NewSpline();
						if(seg == 0 && spline->Closed()) {
							backLoop:
							if(shape->segSel[poly][--end]) {
								SplineKnot addKnot(spline->GetKnotType(end),spline->GetLineType(end),
									spline->GetKnotPoint(end),spline->GetInVec(end),spline->GetOutVec(end));
								newSpline->AddKnot(addKnot, 0);
								goto backLoop;
								}

							}
						SplineKnot addKnot(spline->GetKnotType(seg),spline->GetLineType(seg),
							spline->GetKnotPoint(seg),spline->GetInVec(seg),spline->GetOutVec(seg));
						newSpline->AddKnot(addKnot, -1);

						loop:
						int knot = (seg + 1) % knots;
						addKnot = SplineKnot(spline->GetKnotType(knot),spline->GetLineType(knot),
							spline->GetKnotPoint(knot),spline->GetInVec(knot),spline->GetOutVec(knot));
						newSpline->AddKnot(addKnot, -1);
						seg = (seg + 1) % segments;
						if(seg > 0 && seg < end && shape->segSel[poly][seg])
							goto loop;

						// Finish up the spline!
						newSpline->ComputeBezPoints();

						// Special termination test for wraparound
						if(seg == 0)
							seg = end;
						}
					}
				}
			}
		}
	shape->segSel.ClearAll();	// Deselect the originals
	shape->UpdateSels();	// Make sure it readies the selection set info
	shape->InvalidateGeomCache();
	for(int i = oldSplineCount; i < shape->SplineCount(); ++i) {
		if(selCopy)
			shape->segSel[i].SetAll();
		else
			shape->segSel[i].ClearAll();
		}
	}

BOOL SegCopyRecord::Redo(BezierShape *shape,int reRecord) {
	if(reRecord) {
		oldSplineCount = shape->splineCount;
		oldSSel = shape->segSel;
		}
	CopySegments(shape, selCopy);
	return TRUE;
	}

#define SCOPYR_GENERAL_CHUNK		0x1000

IOResult SegCopyRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SCOPYR_GENERAL_CHUNK:
				res = iload->Read(&selCopy,sizeof(BOOL),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/

ShapeRestore::ShapeRestore(EditSplineData* sd, EditSplineMod* mod, BezierShape *shape)
	{
	gotRedo = FALSE;
	esd = sd;
	this->mod = mod;
	oldShape = *shape;
	t = mod->ip->GetTime();
	undoPointList = mod->pointList;
	}

void ShapeRestore::Restore(int isUndo)
	{
	if ( esd->tempData && esd->TempData(mod)->ShapeCached(t) ) {
		BezierShape *shape = esd->TempData(mod)->GetShape(t);
		if(shape) {
			if(isUndo && !gotRedo) {
				newShape = *shape;
				redoPointList = mod->pointList;
				gotRedo = TRUE;
				}
			DWORD selLevel = shape->selLevel;	// Grab this...
			DWORD dispFlags = shape->dispFlags;	// Grab this...
			*shape = oldShape;
			shape->selLevel = selLevel;	// ...and put it back in
			shape->dispFlags = dispFlags;	// ...and put it back in
			mod->pointList = undoPointList;
			mod->InvalidateSurfaceUI();
			shape->InvalidateGeomCache();
			}
		esd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT);
		}
	else
	if ( esd->tempData ) {
		esd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT, FALSE);
		}
	if(isUndo)
		MaybeCancelBooleanMode(mod);
	mod->SelectionChanged();
	mod->NotifyDependents(FOREVER, PART_GEOM | PART_TOPO | PART_SELECT, REFMSG_CHANGE);
	}

void ShapeRestore::Redo()
	{
	if ( esd->tempData && esd->TempData(mod)->ShapeCached(t) ) {
		BezierShape *shape = esd->TempData(mod)->GetShape(t);
		if(shape) {
			DWORD selLevel = shape->selLevel;	// Grab this...
			DWORD dispFlags = shape->dispFlags;	// Grab this...
			*shape = newShape;
			shape->selLevel = selLevel;	// ...and put it back in
			shape->dispFlags = dispFlags;	// ...and put it back in
			shape->InvalidateGeomCache();
			mod->InvalidateSurfaceUI();
			}
		esd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT);
		}
	else
	if ( esd->tempData ) {
		esd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT, FALSE);
		}
	MaybeCancelBooleanMode(mod);
	mod->pointList = redoPointList;

	mod->SelectionChanged();
	mod->NotifyDependents(FOREVER, PART_GEOM | PART_TOPO | PART_SELECT, REFMSG_CHANGE);
	}

//--- Named Selection Set Methods ------------------------------------

int EditSplineMod::FindSet(TSTR &setName,int level)
	{	
	assert(level>0 && level<4);
	for (int i=0; i<namedSel[level-1].Count(); i++) {
		if (setName == *namedSel[level-1][i]) {
			return i;			
			}
		}
	return -1;
	}

void EditSplineMod::AddSet(TSTR &setName,int level)
	{
	assert(level>0 && level<4);
	TSTR *name = new TSTR(setName);
	namedSel[level-1].Append(1,&name);
	}

void EditSplineMod::RemoveSet(TSTR &setName,int level)
	{
	assert(level>0 && level<4);
	int i = FindSet(setName,level);
	if (i>=0) {
		delete namedSel[level-1][i];
		namedSel[level-1].Delete(i,1);
		}
	}

void EditSplineMod::RemoveAllSets()
	{
	ModContextList mcList;
	INodeTab nodes;
	
	if (!ip) return;	
	
	ip->GetModContexts(mcList,nodes);

	for (int i=0; i < mcList.Count(); i++) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if (!shapeData) continue;		
		
		int j;
		for (j=shapeData->vselSet.Count()-1; j>=0; j--) {
			shapeData->vselSet.DeleteSet(j);
			}
		for (j=shapeData->sselSet.Count()-1; j>=0; j--) {
			shapeData->sselSet.DeleteSet(j);
			}
		for (j=shapeData->pselSet.Count()-1; j>=0; j--) {
			shapeData->pselSet.DeleteSet(j);
			}		
		}	
	
	for (int j=0; j<3; j++) {
		for (int i=0; i<namedSel[j].Count(); i++) {
			delete namedSel[j][i];		
			}
		namedSel[j].Resize(0);
		}

	ip->ClearCurNamedSelSet();
	ip->ClearSubObjectNamedSelSets();
	nodes.DisposeTemporary();
	}

// Used by EditPatchMod destructor to free pointers
void EditSplineMod::ClearSetNames()
	{
	for (int i=0; i<3; i++) {
		for (int j=0; j<namedSel[i].Count(); j++) {
			delete namedSel[i][j];
			namedSel[i][j] = NULL;
			}
		}
	}

/*-------------------------------------------------------------------*/

void EditSplineMod::ActivateSubSelSet(TSTR &setName)
	{
	ModContextList mcList;
	INodeTab nodes;
	int index = FindSet(setName,selLevel);
	if (index<0 || !ip) return;	
	TimeValue t = ip->GetTime();

	ip->GetModContexts(mcList,nodes);

	theHold.Begin();
	for (int i = 0; i < mcList.Count(); i++) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->BeginEdit(ip->GetTime());
		switch (GetSubobjectLevel()) {
			case ES_VERTEX: {
				int i = shapeData->vselSet.FindSet(setName);
				if (i>=0) {
					if (!shapeData->vselSet[i].IsCompatible(*shape))
						shapeData->vselSet[i].SetSize(*shape, TRUE);
					if(theHold.Holding())
						theHold.Put(new ShapeRestore(shapeData,this,shape));
					shape->vertSel = shapeData->vselSet[i];
					SelectionChanged();
					}
				break;
				}

			case ES_SEGMENT: {
				int i = shapeData->sselSet.FindSet(setName);
				if (i>=0) {
					if (!shapeData->sselSet[i].IsCompatible(*shape))
						shapeData->sselSet[i].SetSize(*shape, TRUE);
					if(theHold.Holding())
						theHold.Put(new ShapeRestore(shapeData,this,shape));
					shape->segSel = shapeData->sselSet[i];
					SelectionChanged();
					}
				break;
				}

			case ES_SPLINE: {
				int i = shapeData->pselSet.FindSet(setName);
				if (i>=0) {
					if (!shapeData->pselSet[i].IsCompatible(*shape))
						shapeData->pselSet[i].SetSize(*shape, TRUE);
					if(theHold.Holding())
						theHold.Put(new ShapeRestore(shapeData,this,shape));
					shape->polySel = shapeData->pselSet[i];
					SelectionChanged();
					}
				break;
				}
			}
		shapeData->UpdateChanges(shape, FALSE);
		if (shapeData->tempData)
			shapeData->TempData(this)->Invalidate(PART_SELECT);
		}
	
	theHold.Accept(GetString(IDS_DS_SELECT));
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

void EditSplineMod::NewSetFromCurSel(TSTR &setName)
	{	
	ModContextList mcList;
	INodeTab nodes;
	if(!ip)
		return;
	TimeValue t = ip->GetTime();
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->BeginEdit(ip->GetTime());
		switch (GetSubobjectLevel()) {
			case SS_VERTEX: {
				int j = shapeData->vselSet.FindSet(setName);
				if (j>=0) {
					shapeData->vselSet[j] = shape->vertSel;
				} else {
					shapeData->vselSet.AppendSet(shape->vertSel,setName);
					}
				break;
				}

			case SS_SEGMENT: {
				int j = shapeData->sselSet.FindSet(setName);
				if (j>=0) {
					shapeData->sselSet[j] = shape->segSel;
				} else {
					shapeData->sselSet.AppendSet(shape->segSel,setName);
					}
				break;
				}

			case SS_SPLINE: {
				int j = shapeData->pselSet.FindSet(setName);
				if (j>=0) {
					shapeData->pselSet[j] = shape->polySel;
				} else {
					shapeData->pselSet.AppendSet(shape->polySel,setName);
					}
				break;
				}
			}
		}
	int index = FindSet(setName,selLevel);
	if (index<0)
		AddSet(setName,selLevel);		
	nodes.DisposeTemporary();
	}

void EditSplineMod::RemoveSubSelSet(TSTR &setName)
	{
	ModContextList mcList;
	INodeTab nodes;
	if(!ip)
		return;
	TimeValue t = ip->GetTime();
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->BeginEdit(ip->GetTime());
		switch(GetSubobjectLevel()) {
			case SS_VERTEX:
				if (theHold.Holding())
					theHold.Put(new ESDeleteVertSetRestore(i,&shapeData->vselSet,this));
				shapeData->vselSet.DeleteSet(setName);
				break;
			case SS_SEGMENT:
				if (theHold.Holding())
					theHold.Put(new ESDeleteSegSetRestore(i,&shapeData->sselSet,this));
				shapeData->sselSet.DeleteSet(setName);
				break;
			case SS_SPLINE:
				if (theHold.Holding())
					theHold.Put(new ESDeletePolySetRestore(i,&shapeData->pselSet,this));
				shapeData->pselSet.DeleteSet(setName);
				break;
			}
		}
	// Remove the modifier's entry
	RemoveSet(setName,selLevel);
	ip->ClearCurNamedSelSet();
	SetupNamedSelDropDown();
	nodes.DisposeTemporary();
	}

void EditSplineMod::SetupNamedSelDropDown()
	{
	// Setup named selection sets	
	if (selLevel == ES_OBJECT)
		return;
	ip->ClearSubObjectNamedSelSets();
	for (int i=0; i<namedSel[selLevel-1].Count(); i++)
		ip->AppendSubObjectNamedSelSet(*namedSel[selLevel-1][i]);
	}

int EditSplineMod::NumNamedSelSets()
	{
	if(GetSubobjectLevel() == ES_OBJECT)
		return 0;
	return namedSel[selLevel-1].Count();
	}

TSTR EditSplineMod::GetNamedSelSetName(int i)
	{
	return *namedSel[selLevel-1][i];
	}

class ESSelSetNameRestore : public RestoreObj {
	public:
		TSTR undo, redo;
		TSTR *target;
		EditSplineMod *mod;
		ESSelSetNameRestore(EditSplineMod *m, TSTR *t, TSTR &newName) {
			mod = m;
			undo = *t;
			target = t;
			}
		void Restore(int isUndo) {			
			if(isUndo)
				redo = *target;
			*target = undo;
			if (mod->ip)
				mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			*target = redo;
			if (mod->ip)
				mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Sel Set Name"));}
	};

void EditSplineMod::SetNamedSelSetName(int index,TSTR &newName)
	{
	if(!ip) return;

	// First do the master name list
	if (theHold.Holding())
		theHold.Put(new ESSelSetNameRestore(this, namedSel[selLevel-1][index], newName));

	// Save the old name so we can change those in the EditSplineData
	TSTR oldName = *namedSel[selLevel-1][index];
	*namedSel[selLevel-1][index] = newName;

	ModContextList mcList;
	INodeTab nodes;
	
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( shapeData ) {
			switch(GetSubobjectLevel()) {
				case SS_VERTEX:
					if (theHold.Holding())
						theHold.Put(new ESVertSetNameRestore(i,&shapeData->vselSet,this));
					shapeData->vselSet.RenameSet(oldName, newName);
					break;
				case SS_SEGMENT:
					if (theHold.Holding())
						theHold.Put(new ESSegSetNameRestore(i,&shapeData->sselSet,this));
					shapeData->sselSet.RenameSet(oldName, newName);
					break;
				case SS_SPLINE:
					if (theHold.Holding())
						theHold.Put(new ESPolySetNameRestore(i,&shapeData->pselSet,this));
					shapeData->pselSet.RenameSet(oldName, newName);
					break;
				}
			}
		}
	nodes.DisposeTemporary();
	}

void EditSplineMod::NewSetByOperator(TSTR &newName,Tab<int> &sets,int op)
	{
	// First do it in the master name list
	AddSet(newName,selLevel);		

	ModContextList mcList;
	INodeTab nodes;
	if(!ip)
		return;
	TimeValue t = ip->GetTime();
	ip->GetModContexts(mcList,nodes);

	theHold.Begin();
	for (int i = 0; i < mcList.Count(); i++) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->BeginEdit(ip->GetTime());
		int poly, j;
		
		switch(GetSubobjectLevel()) {
			case SS_VERTEX: {
				ShapeVSel bits = *(shapeData->vselSet.sets[sets[0]]);
				for(poly = 0; poly < bits.polys; ++poly) {
					for (j=1; j<sets.Count(); j++) {
						ShapeVSel &bit2 = *(shapeData->vselSet.sets[sets[j]]);
						switch (op) {
							case NEWSET_MERGE:
								bits[poly] |= bit2[poly];
								break;

							case NEWSET_INTERSECTION:
								bits[poly] &= bit2[poly];
								break;

							case NEWSET_SUBTRACT:
								bits[poly] &= ~(bit2[poly]);
								break;
							}
						}
					}
				shapeData->vselSet.AppendSet(bits,newName);
				if (theHold.Holding())
					theHold.Put(new ESAppendVertSetRestore(&shapeData->vselSet,this));
				}
				break;
			case SS_SEGMENT: {
				ShapeSSel bits = *(shapeData->sselSet.sets[sets[0]]);
				for(poly = 0; poly < bits.polys; ++poly) {
					for (j=1; j<sets.Count(); j++) {
						ShapeSSel &bit2 = *(shapeData->sselSet.sets[sets[j]]);
						switch (op) {
							case NEWSET_MERGE:
								bits[poly] |= bit2[poly];
								break;

							case NEWSET_INTERSECTION:
								bits[poly] &= bit2[poly];
								break;

							case NEWSET_SUBTRACT:
								bits[poly] &= ~(bit2[poly]);
								break;
							}
						}
					}
				shapeData->sselSet.AppendSet(bits,newName);
				if (theHold.Holding())
					theHold.Put(new ESAppendSegSetRestore(&shapeData->sselSet,this));
				}
				break;
			case SS_SPLINE: {
				ShapePSel bits = *(shapeData->pselSet.sets[sets[0]]);
				for (j=1; j<sets.Count(); j++) {
					ShapePSel &bit2 = *(shapeData->pselSet.sets[sets[j]]);
					switch (op) {
						case NEWSET_MERGE:
							bits.sel |= bit2.sel;
							break;

						case NEWSET_INTERSECTION:
							bits.sel &= bit2.sel;
							break;

						case NEWSET_SUBTRACT:
							bits.sel &= ~(bit2.sel);
							break;
						}
					}
				shapeData->pselSet.AppendSet(bits,newName);
				if (theHold.Holding())
					theHold.Put(new ESAppendPolySetRestore(&shapeData->pselSet,this));
				}
				break;
			}
		}
	}

// Named selection set copy/paste methods follow...

static BOOL CALLBACK PickSetNameDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static TSTR *name;

	switch (msg) {
		case WM_INITDIALOG: {
			name = (TSTR*)lParam;
			ICustEdit *edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
			edit->SetText(*name);
			ReleaseICustEdit(edit);
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ICustEdit *edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
					TCHAR buf[256];
					edit->GetText(buf,256);
					*name = TSTR(buf);
					ReleaseICustEdit(edit);
					EndDialog(hWnd,1);
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		};
	return TRUE;
	}

BOOL EditSplineMod::GetUniqueSetName(TSTR &name)
	{
	while (1) {		
		if(FindSet(name, selLevel) < 0)
			break;

		if (!DialogBoxParam(
			hInstance, 
			MAKEINTRESOURCE(IDD_PASTE_NAMEDSET),
			ip->GetMAXHWnd(), 
			PickSetNameDlgProc,
			(LPARAM)&name)) return FALSE;		
		}
	return TRUE;
	}

static BOOL CALLBACK PickSetDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{	
	switch (msg) {
		case WM_INITDIALOG:	{
			Tab<TSTR*> &names = *((Tab<TSTR*>*)lParam);
			for (int i=0; i<names.Count(); i++) {
				int pos  = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_ADDSTRING,0,
					(LPARAM)(TCHAR*)*names[i]);
				SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_SETITEMDATA,pos,i);
				}
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_NS_LIST:
					if (HIWORD(wParam)!=LBN_DBLCLK) break;
					// fall through
				case IDOK: {
					int sel = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETCURSEL,0,0);
					if (sel!=LB_ERR) {
						int res =SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETITEMDATA,sel,0);
						EndDialog(hWnd,res);
						break;
						}
					// fall through
					}

				case IDCANCEL:
					EndDialog(hWnd,-1);
					break;
				}
			break;

		default:
			return FALSE;
		};
	return TRUE;
	}

int EditSplineMod::SelectNamedSet()
	{
	Tab<TSTR*> names = namedSel[selLevel-1];
	return DialogBoxParam(
		hInstance, 
		MAKEINTRESOURCE(IDD_SEL_NAMEDSET),
		ip->GetMAXHWnd(), 
		PickSetDlgProc,
		(LPARAM)&names);
	}

void EditSplineMod::NSCopy()
	{
	if (selLevel == ES_OBJECT) return;
	int index = SelectNamedSet();
	if(index < 0) return;
	if(!ip) return;

	// Get the name for that index
	int nsl = namedSetLevel[selLevel];
	TSTR setName = *namedSel[nsl][index];

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		
		switch (GetSubobjectLevel()) {
			case SS_VERTEX: {
				ShapeNamedVertSelClip *clip = new ShapeNamedVertSelClip(*(shapeData->vselSet.names[index]));
				ShapeVSel *sel = new ShapeVSel(*(shapeData->vselSet.sets[index]));
				clip->sets.Append(1,&sel);
				SetShapeNamedVertSelClip(clip);
				}
				break;
			case SS_SEGMENT: {
				ShapeNamedSegSelClip *clip = new ShapeNamedSegSelClip(*(shapeData->sselSet.names[index]));
				ShapeSSel *sel = new ShapeSSel(*(shapeData->sselSet.sets[index]));
				clip->sets.Append(1,&sel);
				SetShapeNamedSegSelClip(clip);
				}
				break;
			case SS_SPLINE: {
				ShapeNamedPolySelClip *clip = new ShapeNamedPolySelClip(*(shapeData->pselSet.names[index]));
				ShapePSel *sel = new ShapePSel(*(shapeData->pselSet.sets[index]));
				clip->sets.Append(1,&sel);
				SetShapeNamedPolySelClip(clip);
				}
				break;
			}		
		}
	// Enable the paste button
	ICustButton *but = GetICustButton(GetDlgItem(hSelectPanel,IDC_NS_PASTE));
	but->Enable();
	ReleaseICustButton(but);
	}

void EditSplineMod::NSPaste()
	{	
	if (selLevel == ES_OBJECT) return;
	int nsl = namedSetLevel[selLevel];
	if(!ip) return;

	ShapeNamedVertSelClip *vclip;
	ShapeNamedSegSelClip *sclip;
	ShapeNamedPolySelClip *pclip;

	TSTR name;

	switch(GetSubobjectLevel()) {
		case SS_VERTEX:
			vclip = GetShapeNamedVertSelClip();
			if (!vclip) return;
			name = vclip->name;
			break;
		case SS_SEGMENT:
			sclip = GetShapeNamedSegSelClip();
			if (!sclip) return;
			name = sclip->name;
			break;
		case SS_SPLINE:
			pclip = GetShapeNamedPolySelClip();
			if (!pclip) return;
			name = pclip->name;
			break;
		}

	if (!GetUniqueSetName(name)) return;
	
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	theHold.Begin();

	if(theHold.Holding())
		theHold.Put(new ESAddSetRestore(name, selLevel, this));
	AddSet(name, selLevel);

	for (int i = 0; i < mcList.Count(); i++) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		switch(GetSubobjectLevel()) {
			case SS_VERTEX:
				shapeData->vselSet.AppendSet(*vclip->sets[0],name);	
				if ( theHold.Holding() )
					theHold.Put(new ESAppendVertSetRestore(&shapeData->vselSet,this));
				break;
			case SS_SEGMENT:
				shapeData->sselSet.AppendSet(*sclip->sets[0],name);	
				if ( theHold.Holding() )
					theHold.Put(new ESAppendSegSetRestore(&shapeData->sselSet,this));
				break;
			case SS_SPLINE:
				shapeData->pselSet.AppendSet(*pclip->sets[0],name);	
				if ( theHold.Holding() )
					theHold.Put(new ESAppendPolySetRestore(&shapeData->pselSet,this));
				break;
			}
		}

	ActivateSubSelSet(name);
	ip->SetCurNamedSelSet(name);
	theHold.Accept(GetString (IDS_TH_PASTE_NAMED_SEL));
	SetupNamedSelDropDown();
	}

/*-------------------------------------------------------------------*/

void EditSplineMod::EndMoveModes(TimeValue t, BOOL accept) {
	EndOutlineMove(t, accept);
	EndFilletMove(t, accept);
	EndChamferMove(t, accept);
	}

void OutlineCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_OUTLINE));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void OutlineCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		es->EndOutlineMove(es->ip->GetTime(),TRUE);
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_OUTLINE));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartOutlineMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == outlineMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(outlineMode);
	}

int OutlineMouseProc::proc( 
		HWND hwnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m )
	{	
	ViewExp *vpt = ip->GetViewport(hwnd);
	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:						
			if ( point == 0 ) {							
				es->BeginOutlineMove(ip->GetTime());				
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				sp0 = m;
			} else {
				float outSize = es->outlineSpin->GetFVal();
				es->EndOutlineMove(ip->GetTime(), (outSize == 0.0f) ? FALSE : TRUE);
				ip->RedrawViews(ip->GetTime(),REDRAW_END);
				}
			break;

		case MOUSE_MOVE: {
			float size = vpt->SnapLength(vpt->GetCPDisp(p0,Point3(0,0,1),sp0,m));
			es->OutlineMove( ip->GetTime(), size);
			es->outlineSpin->SetValue(size, FALSE);
			
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
			break;
			}

		case MOUSE_ABORT:
			es->EndOutlineMove(ip->GetTime(),FALSE);			
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			break;		
		}
	
	if ( vpt ) ip->ReleaseViewport(vpt);
	return TRUE;
	}

void EditSplineMod::BeginOutlineMove(TimeValue t)
	{
	EndOutlineMove(t);
	theHold.Begin();
	inOutline = TRUE;
	}

void EditSplineMod::EndOutlineMove(TimeValue t,BOOL accept)
	{	
	if ( !inOutline ) return;
	if ( !ip ) return;	
	
	if (accept) {
		// Record the changes that happened
		ModContextList mcList;		
		INodeTab nodes;
		ip->GetModContexts(mcList,nodes);
		ClearShapeDataFlag(mcList,ESD_BEENDONE);
		for ( int i = 0; i < mcList.Count(); i++ ) {
			EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
			if ( !shapeData ) continue;
			if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
			BezierShape *shape = shapeData->TempData(this)->GetShape(t);
			if(!shape) continue;
			shapeData->UpdateChanges(shape);					
			shapeData->TempData(this)->Invalidate(PART_GEOM);
			shapeData->SetFlag(ESD_BEENDONE,TRUE);
			}

		nodes.DisposeTemporary();
		ClearShapeDataFlag(mcList,ESD_BEENDONE);
		theHold.Accept(GetString(IDS_TH_OUTLINE));
	} else {
		theHold.Cancel();
		}
		
	inOutline = FALSE;
	if ( outlineSpin ) {
		outlineSpin->SetValue(0,FALSE);
		}
	}

// mjm - begin - 4.3.99
// removes segments less than tol distance long 
static
bool CleanSpline(Spline3D *spline, double tol)
{
	bool changed(false);
	int segs = spline->Segments();
	if (segs > 0)
	{
		bool *deleteFlags = new bool[segs];

		for (int seg=0; seg<segs; ++seg)
			deleteFlags[seg] = (spline->SegmentLength(seg) < tol) ? true : false;

		for (int knot = segs-1; knot>=0; --knot)
		{
			if (deleteFlags[knot])
			{
				spline->DeleteKnot(knot);
				changed = true;
			}
		}

		// re-cache the spline
		spline->SplineLength();

		if (deleteFlags)
			delete[] deleteFlags;
	}
	return changed;
}

// checks for splines with degenerate segments 
#define CLEAN_TOLERANCE .00001
static
bool CleanShape(BezierShape *shape)
{
	bool changed(false);
	int polys = shape->splineCount;
	for (int poly=0; poly<polys; ++poly)
	{
		Spline3D *spline = shape->splines[poly];
		if ( spline && CleanSpline(spline, CLEAN_TOLERANCE * spline->SplineLength()) )
			changed = true;
	}
	if (changed)
		shape->InvalidateGeomCache();

	return changed;
}
// mjm - end

void EditSplineMod::OutlineMove( TimeValue t, float amount ) 
	{	
	ModContextList mcList;		
	INodeTab nodes;

	if ( !ip ) return;
	theHold.Restore();
	ip->GetModContexts(mcList,nodes);

	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
				
		shapeData->BeginEdit(t);

		// mjm - begin - 4.3.99
		if ( CleanShape(shape) )
		{
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
		}
		// mjm - end

		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {				
			Spline3D *spline = shape->splines[poly];

			if(shape->polySel[poly]) {
				if ( theHold.Holding() && !TestAFlag(A_HELD) ) {
					shapeData->RecordTopologyTags(shape);
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}

				// Outline the polygon
				OutlineSpline(shape, poly, amount, centeredOutline, TRUE);
				}
			}
		shapeData->TempData(this)->Invalidate(PART_GEOM);
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}

	// Mark all objects in selection set
	SetAFlag(A_HELD);
	
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

/*-------------------------------------------------------------------*/

void FilletCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_FILLET));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void FilletCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		es->EndFilletMove(es->ip->GetTime(),TRUE);
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_FILLET));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartFilletMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == filletMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(filletMode);
	}

int FilletMouseProc::proc( 
		HWND hwnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m )
	{	
	ViewExp *vpt = ip->GetViewport(hwnd);
	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:						
			if ( point == 0 ) {							
				es->SetFCLimit();
				es->BeginFilletMove(ip->GetTime());				
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				sp0 = m;
			} else {
				float size = es->filletSpin->GetFVal();
				es->EndFilletMove(ip->GetTime(), (size == 0.0f) ? FALSE : TRUE);
				ip->RedrawViews(ip->GetTime(),REDRAW_END);
				}
			break;

		case MOUSE_MOVE: {
			float size = vpt->SnapLength(vpt->GetCPDisp(p0,Point3(0,0,1),sp0,m));
			es->FilletMove( ip->GetTime(), size);
			es->filletSpin->SetValue(size, FALSE);
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
			break;
			}

		case MOUSE_ABORT:
			es->EndFilletMove(ip->GetTime(),FALSE);			
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			break;		
		}
	
	if ( vpt ) ip->ReleaseViewport(vpt);
	return TRUE;
	}

void EditSplineMod::BeginFilletMove(TimeValue t)
	{
	EndMoveModes(t);
	theHold.Begin();
	inFillet = TRUE;
	}

void EditSplineMod::EndFilletMove(TimeValue t,BOOL accept)
	{	
	if ( !inFillet ) return;
	if ( !ip ) return;	
	
	if (accept) {
		theHold.Accept(GetString(IDS_TH_FILLET));
	} else {
		theHold.Cancel();
		}
		
	inFillet = FALSE;
	if ( filletSpin ) {
		filletSpin->SetValue(0,FALSE);
		}
	}

void EditSplineMod::FilletMove( TimeValue t, float amount ) 
	{	
	LimitValue(amount, 0.0f, FCLimit);

	ModContextList mcList;		
	INodeTab nodes;

	if ( !ip ) return;
	theHold.Restore();
	ip->GetModContexts(mcList,nodes);

	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
				
		shapeData->BeginEdit(t);
		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {				
			Spline3D *spline = shape->splines[poly];

			if(shape->vertSel[poly].NumberSet()) {
				if ( theHold.Holding() && !TestAFlag(A_HELD) ) {
					shapeData->RecordTopologyTags(shape);
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}

				FilletOrChamferSpline(shape, poly, amount, ES_FILLET);
				}
			}
		shapeData->TempData(this)->Invalidate(PART_GEOM);
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}

	// Mark all objects in selection set
	SetAFlag(A_HELD);
	
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

/*-------------------------------------------------------------------*/

void ESChamferCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_CHAMFER));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void ESChamferCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		es->EndChamferMove(es->ip->GetTime(),TRUE);
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_CHAMFER));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartChamferMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == chamferMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(chamferMode);
	}

int ESChamferMouseProc::proc( 
		HWND hwnd, 
		int msg, 
		int point, 
		int flags, 
		IPoint2 m )
	{	
	ViewExp *vpt = ip->GetViewport(hwnd);
	switch ( msg ) {
		case MOUSE_PROPCLICK:
			ip->SetStdCommandMode(CID_OBJMOVE);
			break;

		case MOUSE_POINT:						
			if ( point == 0 ) {							
				es->SetFCLimit();
				es->BeginChamferMove(ip->GetTime());				
				p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_3D);
				sp0 = m;
			} else {
				float size = es->chamferSpin->GetFVal();
				es->EndChamferMove(ip->GetTime(), (size == 0.0f) ? FALSE : TRUE);
				ip->RedrawViews(ip->GetTime(),REDRAW_END);
				}
			break;

		case MOUSE_MOVE: {
			float size = vpt->SnapLength(vpt->GetCPDisp(p0,Point3(0,0,1),sp0,m));
			es->ChamferMove( ip->GetTime(), size);
			es->chamferSpin->SetValue(size, FALSE);
			ip->RedrawViews(ip->GetTime(),REDRAW_INTERACTIVE);
			break;
			}

		case MOUSE_ABORT:
			es->EndChamferMove(ip->GetTime(),FALSE);			
			ip->RedrawViews(ip->GetTime(),REDRAW_END);
			break;		
		}
	
	if ( vpt ) ip->ReleaseViewport(vpt);
	return TRUE;
	}

void EditSplineMod::BeginChamferMove(TimeValue t)
	{
	EndMoveModes(t);
	theHold.Begin();
	inChamfer = TRUE;
	}

void EditSplineMod::EndChamferMove(TimeValue t,BOOL accept)
	{	
	if ( !inChamfer ) return;
	if ( !ip ) return;	
	
	if (accept) {
		theHold.Accept(GetString(IDS_TH_CHAMFER));
	} else {
		theHold.Cancel();
		}
		
	inChamfer = FALSE;
	if ( chamferSpin ) {
		chamferSpin->SetValue(0,FALSE);
		}
	}

void EditSplineMod::ChamferMove( TimeValue t, float amount ) 
	{	
	LimitValue(amount, 0.0f, FCLimit);
	
	ModContextList mcList;		
	INodeTab nodes;

	if ( !ip ) return;
	theHold.Restore();
	ip->GetModContexts(mcList,nodes);

	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
				
		shapeData->BeginEdit(t);
		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {				
			Spline3D *spline = shape->splines[poly];

			if(shape->vertSel[poly].NumberSet()) {
				if ( theHold.Holding() && !TestAFlag(A_HELD) ) {
					shapeData->RecordTopologyTags(shape);
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}

				FilletOrChamferSpline(shape, poly, amount, ES_CHAMFER);
				}
			}
		shapeData->TempData(this)->Invalidate(PART_GEOM);
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}

	// Mark all objects in selection set
	SetAFlag(A_HELD);
	
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

/*-------------------------------------------------------------------*/

void SegBreakCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_BREAK));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void SegBreakCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_BREAK));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartSegBreakMode()
	{
	if ( !ip ) return;

	ip->SetCommandMode(segBreakMode);
	}

/*-------------------------------------------------------------------*/

void CreateLineCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_CREATELINE));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void CreateLineCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_CREATELINE));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartCreateLineMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == createLineMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(createLineMode);
	}

BOOL EditSplineMod::StartCreateLine(BezierShape **shape) {
	ModContextList mcList;		
	INodeTab nodes;
	if ( !ip ) return FALSE;

	ip->GetModContexts(mcList,nodes);
	if(mcList.Count() != 1) {
		nodes.DisposeTemporary();
		return FALSE;
		}
	createShapeData = (EditSplineData*)mcList[0]->localData;
	if ( !createShapeData ) {
		nodes.DisposeTemporary();
		return FALSE;
		}
	// If the mesh isn't yet cache, this will cause it to get cached.
	createShape = createShapeData->TempData(this)->GetShape(ip->GetTime());
	if ( !createShape ) {
		nodes.DisposeTemporary();
		return FALSE;
		}

	theHold.Begin();
	if ( theHold.Holding() ) {
		theHold.Put(new ShapeRestore(createShapeData,this,createShape));
		}

	createNode = nodes[0]->GetActualINode();	
	createTM = nodes[0]->GetObjectTM(ip->GetTime());
	*shape = createShape;
	nodes.DisposeTemporary();
	createShapeData->RecordTopologyTags(createShape);
	return TRUE;
	}

void EditSplineMod::EndCreateLine() {
	ModContextList mcList;		
	INodeTab nodes;
	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);

	createShapeData->BeginEdit(ip->GetTime());
	
	createShapeData->UpdateChanges(createShape);
	theHold.Accept(GetString(IDS_TH_CREATELINE));
	nodes.DisposeTemporary();
	}

/*-------------------------------------------------------------------*/

void SegRefineCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel, IDC_ES_REFINE));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);

//2-1-99 watje
		EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCONNECT),FALSE);
		EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCLINEAR), FALSE);
		EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCCLOSED), FALSE);
		EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_BINDFIRST), FALSE);
		EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_BINDLAST), FALSE);

		}
	}

void SegRefineCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel, IDC_ES_REFINE));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);

//2-1-99 watje
		BOOL vType = (es->GetSubobjectLevel() == SS_VERTEX) ? TRUE : FALSE;
		BOOL sType = (es->GetSubobjectLevel() == SS_SEGMENT) ? TRUE : FALSE;

		if ( vType||sType)
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCONNECT),TRUE);
		else EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCONNECT),FALSE); 

		if ( (es->rConnect) && (vType||sType))
			{
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCLINEAR), TRUE);
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCCLOSED), TRUE);
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_BINDFIRST), TRUE);
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_BINDLAST), TRUE);
			}
		else
			{
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCLINEAR), FALSE);
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_RCCLOSED), FALSE);
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_BINDFIRST), FALSE);
			EnableWindow (GetDlgItem (es->hOpsPanel, IDC_ES_BINDLAST), FALSE);
			}


		}
	}

void EditSplineMod::StartSegRefineMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == segRefineMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}

	segRefineMode->SetType(GetSubobjectLevel()==ES_VERTEX ? REFINE_VERT : REFINE_SEG);
	ip->SetCommandMode(segRefineMode);
	}

/*-------------------------------------------------------------------*/

void CrossInsertCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel, IDC_ES_CROSS_INSERT));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void CrossInsertCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel, IDC_ES_CROSS_INSERT));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartCrossInsertMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == crossInsertMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(crossInsertMode);
	}

/*-------------------------------------------------------------------*/

void VertConnectCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_CONNECT));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void VertConnectCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
//		es->EndOutlineMove(es->ip->GetTime(),TRUE);
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_CONNECT));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartVertConnectMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == vertConnectMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(vertConnectMode);
	}

/*-------------------------------------------------------------------*/

void VertInsertCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		if(control >= 0) {
			ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,control));
			but->SetCheck(TRUE);
			ReleaseICustButton(but);
			}
		}
	}

void VertInsertCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		if(control >= 0) {
			ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,control));
			but->SetCheck(FALSE);
			ReleaseICustButton(but);
			}
		}
	}

void EditSplineMod::StartVertInsertMode(int controlID)
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == vertInsertMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	vertInsertMode->SetControl(controlID);
	ip->SetCommandMode(vertInsertMode);
	}

/*-------------------------------------------------------------------*/

void BooleanCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_BOOLEAN));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void BooleanCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
//		es->EndOutlineMove(es->ip->GetTime(),TRUE);
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_BOOLEAN));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartBooleanMode()
	{
	if ( !ip ) return;

	ip->SetCommandMode(booleanMode);
	}

// See if a spline self-intersects
static BOOL SplineSelfIntersects(Spline3D *spline) {
	// Create a 2D template of the spline
	ESMTemplate t(spline);
	int points = t.Points();
	int last = points - 1;
	int last2 = points - 2;
	Point2 where;
	for(int i = 0; i < last2; ++i) {
		Point2 i1 = t.pts[i];
		Point2 i2 = t.pts[i+1];
		for(int j = i + 2; j < last; ++j) {
			if(i==0 && j == last2) continue;	// No comparison with last seg & first!
			if(IntSeg(i1,i2,t.pts[j],t.pts[j+1],where) == 1) {
//DebugPrint("Self-int %d/%d: %.4f %.4f - %.4f %.4f / %.4f %.4f - %.4f %.4f @ %.4f %.4f\n",i,j,i1.x,i1.y,i2.x,i2.y,
//	t.pts[j].x,t.pts[j].y,t.pts[j+1].x,t.pts[j+1].y,where.x,where.y);
				return TRUE;
				}
			}
		}
	return FALSE;
	}

BOOL ValidBooleanPolygon(IObjParam *ip, Spline3D *spline) {
	if(!spline->Closed()) {
		ip->DisplayTempPrompt(GetString(IDS_TH_SELECTCLOSEDSPLINE),PROMPT_TIME);
		return FALSE;
		}
	if(SplineSelfIntersects(spline)) {
		ip->DisplayTempPrompt(GetString(IDS_TH_SPLINESELFINTERSECTS),PROMPT_TIME);
		return FALSE;
		}
	return TRUE;	// It's OK!
	}

// This function checks to see if there is only one polygon selected, and if so, starts up
// the second phase of the boolean operation

BOOL EditSplineMod::BooleanStartUp() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	if ( !ip ) return FALSE;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	int selected = 0;
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
			
		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			if(shape->polySel[poly]) {
				if(selected) {
					ip->DisplayTempPrompt(GetString(IDS_TH_MORETHANONESPLINESEL),PROMPT_TIME);
					return FALSE;
					}
				selected = 1;
				boolShape = shape;
				boolPoly1 = poly;
				}
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}

	nodes.DisposeTemporary();

	// If no polys selected -- No can do!
	if(!selected) {
		ip->DisplayTempPrompt(GetString(IDS_TH_SELECTONESPLINE),PROMPT_TIME);
		return FALSE;
		}

	// Got one poly selected, make sure it's valid!
	if(!ValidBooleanPolygon(ip, boolShape->splines[boolPoly1]))
		return FALSE;

	// It's kosher, start up the boolean mode!
	StartBooleanMode();

	return TRUE;
	}

/*-------------------------------------------------------------------*/

BOOL PickSplineAttach::Filter(INode *node)
	{
	ModContextList mcList;		
	INodeTab nodes;
	if (node) {
		// Make sure the node does not depend on us
		node->BeginDependencyTest();
		es->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if (node->EndDependencyTest()) return FALSE;

		ObjectState os = node->GetObjectRef()->Eval(es->ip->GetTime());
		GeomObject *object = (GeomObject *)os.obj;
		// Make sure it isn't one of the nodes we're editing, for heaven's sake!
		es->ip->GetModContexts(mcList,nodes);
		int numNodes = nodes.Count();
		for(int i = 0; i < numNodes; ++i) {
			if(nodes[i] == node) {
				nodes.DisposeTemporary();
				return FALSE;
				}
			}
		nodes.DisposeTemporary();
		if(object->CanConvertToType(splineShapeClassID))
			return TRUE;
		}

	return FALSE;
	}

BOOL PickSplineAttach::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	ModContextList mcList;		
	INodeTab nodes;
	
	if (node) {
		ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		GeomObject *object = (GeomObject *)os.obj;
		// Make sure it isn't one of the nodes we're editing, for heaven's sake!
		es->ip->GetModContexts(mcList,nodes);
		int numNodes = nodes.Count();
		for(int i = 0; i < numNodes; ++i) {
			if(nodes[i] == node) {
				nodes.DisposeTemporary();
				return FALSE;
				}
			}
		nodes.DisposeTemporary();
		if(object->CanConvertToType(splineShapeClassID))
			return TRUE;
		}

	return FALSE;
	}

BOOL PickSplineAttach::Pick(IObjParam *ip,ViewExp *vpt)
	{
	if(!ip)
		return FALSE;
	INode *node = vpt->GetClosestHit();
	assert(node);
	GeomObject *object = (GeomObject *)node->GetObjectRef()->Eval(ip->GetTime()).obj;
	if(object->CanConvertToType(splineShapeClassID)) {
		ModContextList mcList;
		INodeTab nodes;
		ip->GetModContexts(mcList,nodes);
		BOOL res = TRUE;
		if (nodes[0]->GetMtl() && node->GetMtl() && (nodes[0]->GetMtl()!=node->GetMtl()))
			res = DoAttachMatOptionDialog(ip, es);
		if(res)	{
			bool canUndo = TRUE;
			es->DoAttach(node, canUndo);
			if (!canUndo)
				GetSystemSetting (SYSSET_CLEAR_UNDO);
			}
		nodes.DisposeTemporary();
		}
	return FALSE;
	}


void PickSplineAttach::EnterMode(IObjParam *ip)
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_ATTACH));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void PickSplineAttach::ExitMode(IObjParam *ip)
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_ATTACH));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

HCURSOR PickSplineAttach::GetHitCursor(IObjParam *ip) {
	return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_ATTACHCUR));
	}

static BOOL doingMultiAttach = FALSE;

int EditSplineMod::DoAttach(INode *node, bool & canUndo) {
	if ( !ip ) return 0;

	// Get the shape that's being attached
	BezierShape attShape;
	GeomObject *object = (GeomObject *)node->GetObjectRef()->Eval(ip->GetTime()).obj;
	if(!object->CanConvertToType(splineShapeClassID))
		return 0;
	SplineShape *attSplShape = (SplineShape *)object->ConvertToType(ip->GetTime(),splineShapeClassID);
	if(!attSplShape)
		return 0;
	attShape = attSplShape->shape;
	// Discard the copy it made, if it isn't the same as the object itself
	if(attSplShape != (SplineShape *)object)
		delete attSplShape;
	
	ModContextList mcList;	
	INodeTab nodes;

	ip->GetModContexts(mcList,nodes);

	if(mcList.Count() != 1) {
		nodes.DisposeTemporary();
		return 0;
		}

	EditSplineData *shapeData = (EditSplineData*)mcList[0]->localData;
	if ( !shapeData ) {
		nodes.DisposeTemporary();
		return 0;
		}
	shapeData->BeginEdit(ip->GetTime());

	// If the mesh isn't yet cached, this will cause it to get cached.
	BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
	if(!shape) {
		nodes.DisposeTemporary();
		return 0;
		}

	ShapeRestore *theRestore = new ShapeRestore(shapeData,this,shape);

	// Transform the shape for attachment:
	// If reorienting, just translate to align pivots
	// Otherwise, transform to match our transform
	Matrix3 attMat(1);
	if(attachReorient) {
		Matrix3 thisTM = nodes[0]->GetNodeTM(ip->GetTime());
		Matrix3 thisOTMBWSM = nodes[0]->GetObjTMBeforeWSM(ip->GetTime());
		Matrix3 thisPivTM = thisTM * Inverse(thisOTMBWSM);
		Matrix3 otherTM = node->GetNodeTM(ip->GetTime());
		Matrix3 otherOTMBWSM = node->GetObjTMBeforeWSM(ip->GetTime());
		Matrix3 otherPivTM = otherTM * Inverse(otherOTMBWSM);
		Point3 otherObjOffset = node->GetObjOffsetPos();
		attMat = Inverse(otherPivTM) * thisPivTM;
		}
	else {
		attMat = node->GetObjectTM(ip->GetTime()) *
			Inverse(nodes[0]->GetObjectTM(ip->GetTime()));
		}
	attShape.Transform(attMat);

	theHold.Begin();

	// Combine the materials of the two nodes.
	int mat2Offset=0;
	Mtl *m1 = nodes[0]->GetMtl();
	Mtl *m2 = node->GetMtl();
	bool condenseMe = FALSE;
	if (m1 && m2 && (m1 != m2)) {
		if (attachMat==ATTACHMAT_IDTOMAT) {
			int ct=1;
			if (m1->IsMultiMtl())
				ct = m1->NumSubMtls();
			for(int poly = 0; poly < shape->SplineCount(); ++poly) {
				Spline3D *spline = shape->splines[poly];
				for(int i = 0; i < spline->Segments(); ++i) {
					int mtid = spline->GetMatID(i);
					if(mtid >= ct)
						spline->SetMatID(i, mtid % ct);
					}
				}
			FitShapeIDsToMaterial (attShape, m2);
			if (condenseMat) condenseMe = TRUE;
			}
		// the theHold calls here were a vain attempt to make this all undoable.
		// This should be revisited in the future so we don't have to use the SYSSET_CLEAR_UNDO.
		theHold.Suspend ();
		if (attachMat==ATTACHMAT_MATTOID) {
			m1 = FitMaterialToShapeIDs (*shape, m1);
			m2 = FitMaterialToShapeIDs (attShape, m2);
			}

		Mtl *multi = CombineMaterials (m1, m2, mat2Offset);
		if (attachMat == ATTACHMAT_NEITHER) mat2Offset = 0;
		theHold.Resume ();
		// We can't be in face subobject mode, else we screw up the materials:
		DWORD oldSL = shape->selLevel;
		shape->selLevel = SHAPE_OBJECT;
		nodes[0]->SetMtl(multi);
		shape->selLevel = oldSL;
		m1 = multi;
		canUndo = FALSE;	// Absolutely cannot undo material combinations.
		}
	if (!m1 && m2) {
		// We can't be in face subobject mode, else we screw up the materials:
		DWORD oldSL = shape->selLevel;
		shape->selLevel = SHAPE_OBJECT;
		nodes[0]->SetMtl(m2);
		shape->selLevel = oldSL;
		m1 = m2;
		}

	shapeData->RecordTopologyTags(shape);

	// Start a restore object...
	if ( theHold.Holding() )
		theHold.Put(theRestore);

	// Do the attach
	::DoAttach(shape, &attShape, mat2Offset);
	shapeData->UpdateChanges(shape);
	shapeData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);

	// Get rid of the original node
	ip->DeleteNode(node);

	theHold.Accept(GetString(IDS_TH_ATTACH));

	if (m1 && condenseMe) {
		// Following clears undo stack.
		shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		m1 = CondenseMatAssignments (*shape, m1);
		}
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	if(!doingMultiAttach) {
		SelectionChanged();
		NotifyDependents(FOREVER, PART_TOPO|PART_GEOM, REFMSG_CHANGE);
		ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
		}
	return 1;
	}

void EditSplineMod::MultiAttachObject(INodeTab &nodeTab)
	{
	bool canUndo = TRUE;
	if (nodeTab.Count() > 1)
		theHold.SuperBegin ();
	doingMultiAttach = TRUE;
	for (int i=0; i<nodeTab.Count(); i++)
		DoAttach (nodeTab[i], canUndo);
	doingMultiAttach = FALSE;
	if (nodeTab.Count() > 1)
		theHold.SuperAccept (GetString (IDS_EM_ATTACH_LIST));
	if (!canUndo)
		GetSystemSetting (SYSSET_CLEAR_UNDO);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO|PART_GEOM, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

/*-------------------------------------------------------------------*/

EditSplineMod::EditSplineMod()
	{
	showVertNumbers = FALSE;
	SVNSelectedOnly = FALSE;
	selLevel = ES_OBJECT;
	insertShape = NULL;	
 	segUIValid = FALSE;
//2-1-99 watje
	useAreaSelect = FALSE;
	areaSelect = 0.1f;
	}

EditSplineMod::~EditSplineMod()
	{
	}

Interval EditSplineMod::LocalValidity(TimeValue t)
	{
	// Force a cache if being edited.
	if (TestAFlag(A_MOD_BEING_EDITED))
		return NEVER;  			   
	return FOREVER;
	}

RefTargetHandle EditSplineMod::Clone(RemapDir& remap) {
	EditSplineMod* newmod = new EditSplineMod();	
	newmod->showVertNumbers = showVertNumbers;
	newmod->SVNSelectedOnly = SVNSelectedOnly;
	newmod->selLevel = selLevel;
	return(newmod);
	}

void EditSplineMod::ClearShapeDataFlag(ModContextList& mcList,DWORD f)
	{
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *meshData = (EditSplineData*)mcList[i]->localData;
		if ( !meshData ) continue;
		meshData->SetFlag(f,FALSE);
		}
	}

void EditSplineMod::XFormHandles( 
		XFormProc *xproc, 
		TimeValue t, 
		Matrix3& partm, 
		Matrix3& tmAxis,
		int masterObject)
	{	
	ModContextList mcList;		
	INodeTab nodes;
	Matrix3 mat,imat,theMatrix;
	Interval valid;
	int numAxis;
	int masterKnot;
	Point3 oldpt,newpt,oldin,oldout,rel;
	BOOL shiftPressed = FALSE;
	static BOOL wasBroken;
	Point3 theKnot;
	Point3 oldVector;
	Point3 newVector;
	BOOL isInVec;
	float oldLen;
	float newLen;
	float lengthRatio;

	if(lockType != IDC_LOCKALL)
		shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	numAxis = ip->GetNumAxis();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	// Loop thru the objects, doing the master object first
	// If handles aren't locked, we only need to do the master object!
	int objects = lockedHandles ? mcList.Count() : 1;
	for ( int i = 0, object = masterObject; i < objects; i++, object = (object + 1) % objects ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[object]->localData;
		if ( !shapeData ) {
			nodes.DisposeTemporary();
			return;
			}
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		
		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		// Create a change record for this object and store a pointer to its delta info in this EditSplineData
		if(!TestAFlag(A_HELD)) {
			shapeData->vdelta.SetSize(*shape,FALSE);
			if ( theHold.Holding() ) {
				theHold.Put(new ShapeRestore(shapeData,this,shape));
				}
			shapeData->vdelta.Zero();		// Reset all deltas
			shapeData->ClearHandleFlag();
			wasBroken = FALSE;
			shapeData->RecordTopologyTags(shape);
			}
		else {
			if(wasBroken && !shiftPressed)
				wasBroken = FALSE;
			if(shapeData->DoingHandles())
				shapeData->ApplyHandlesAndZero(*shape);		// Reapply the slave handle deltas
			else
				shapeData->vdelta.Zero();
			}

		// If the master shape, move the handle!
		if(object == masterObject) {
			masterKnot = shape->bezVecVert / 3;
			int poly = shape->bezVecPoly;
			int vert = shape->bezVecVert;
			shapeData->SetHandleFlag(poly, vert);
			Spline3D *spline = shape->splines[poly];
			int primaryKnot = vert / 3;
			isInVec = ((vert % 3) == 0) ? TRUE : FALSE;
			int otherVert = isInVec ? vert + 2 : vert - 2;
			theKnot = spline->GetKnotPoint(primaryKnot);
			Point3Tab &pDeltas = shapeData->vdelta.dtab.ptab[poly];

			int vbase = shape->GetVertIndex(poly, primaryKnot * 3 + 1);
			tmAxis = ip->GetTransformAxis(nodes[object],vbase);
			mat    = nodes[object]->GetObjectTM(t,&valid) * Inverse(tmAxis);
			imat   = Inverse(mat);
			xproc->SetMat(mat);
					
			// XForm the cache vertices
			oldpt = spline->GetVert(vert);
			newpt = xproc->proc(oldpt,mat,imat);
			spline->SetVert(vert,newpt);

			// Move the delta's vertices.
			shapeData->vdelta.SetPoint(poly,vert,newpt - oldpt);

			// If locked handles, turn the movement into a transformation matrix
			if(lockedHandles) {
				if(!wasBroken && shiftPressed)
					wasBroken = TRUE;
				oldVector = oldpt - theKnot;
				newVector = newpt - theKnot;
				oldLen = Length(oldVector);
				newLen = Length(newVector);
				int allNew = (oldLen == 0.0f) ? 1 : 0;		// All new vector?
				lengthRatio = 1.0f;
				if(!allNew)
					lengthRatio = newLen / oldLen;
				Point3 oldNorm = Normalize(oldVector);
				Point3 newNorm = Normalize(newVector);
				theMatrix.IdentityMatrix();
				if(oldNorm != newNorm) {
					// Get a matrix that will transform the old point to the new one
					// Cross product gives us the normal of the rotational axis
					Point3 axis = Normalize(CrossProd(oldNorm, newNorm));
					// Dot product gives us the angle
					float dot = DotProd(oldNorm, newNorm);
					if(dot >= -1.0f && dot < 1.0f) {
						float angle = (float)-acos(dot);

						// Now let's build a matrix that'll do this for us!
						Quat quat = QFromAngAxis(angle, axis);
						quat.MakeMatrix(theMatrix);

						// If need to break the vector, 
						if(shiftPressed && spline->GetKnotType(primaryKnot) == KTYPE_BEZIER) {
							spline->SetKnotType(primaryKnot,KTYPE_BEZIER_CORNER);
							shapeData->vdelta.SetKType(poly,primaryKnot,KTYPE_BEZIER ^ KTYPE_BEZIER_CORNER);
							}
						}
					}
				}
			else {
				// If unlocked and the bezier is non-corner, do its partner on the other side of the knot!
				if(spline->GetKnotType(primaryKnot) == KTYPE_BEZIER) {
					if(shiftPressed) {
						wasBroken = TRUE;
						spline->SetKnotType(primaryKnot,KTYPE_BEZIER_CORNER);
						// Need to record this for undo!
						shapeData->vdelta.SetKType(poly,primaryKnot,KTYPE_BEZIER ^ KTYPE_BEZIER_CORNER);
						}
					// If a bezier smooth knot, do the opposite side!
					if(spline->GetKnotType(primaryKnot) == KTYPE_BEZIER) {
						Point3 oldpt2 = spline->GetVert(otherVert) - pDeltas[otherVert];
						float oldLen2 = Length(theKnot - oldpt2);
						float oldLen1 = Length(theKnot - oldpt);
						if(oldLen1!=0.0f && oldLen2!=0.0f) {
							float ratio = oldLen2 / oldLen1;
							Point3 newpt2 = theKnot - (newpt - theKnot) * ratio;
							// Alter the cache
							spline->SetVert(otherVert,newpt2);
							// Move the delta's vertices.
							shapeData->vdelta.SetPoint(poly,otherVert,newpt2-oldpt2);
							}
						}
					}
				}

			// Really only need to do this if neighbor knots are non-bezier
			spline->ComputeBezPoints();
			shape->InvalidateGeomCache();
			}

		// If doing locked handles, process all of the handles of selected verts!
		if(lockedHandles) {
			int count = 0;
			if(object!=masterObject)
				shapeData->SetHandleFlag(-1, -1);
			for(int poly = 0; poly < shape->splineCount; ++poly) {
				shapeData->vdelta.ClearUsed(poly);
				// Selected vertices - either directly or indirectly through selected faces or edges.
				BitArray sel = shape->VertexTempSel(poly);
				Spline3D *spline = shape->splines[poly];
				int knots = spline->KnotCount();
				Point3Tab &pDeltas = shapeData->vdelta.dtab.ptab[poly];
				for ( int k = 0; k < knots; k++ ) {
					int kvert = k*3+1;
					if(object == masterObject && poly == shape->bezVecPoly && kvert == shape->bezVecVert) {
						shapeData->vdelta.SetUsed(poly);
						continue;
						}
					if ( spline->IsBezierPt(k) && sel[kvert]) {
						shapeData->vdelta.SetUsed(poly);
						theKnot = spline->GetKnotPoint(k);
						int knotType = spline->GetKnotType(k);
						
						if(shiftPressed && knotType == KTYPE_BEZIER) {
							spline->SetKnotType(k,KTYPE_BEZIER_CORNER);
							shapeData->vdelta.SetKType(poly,k,KTYPE_BEZIER ^ KTYPE_BEZIER_CORNER);
							}

						if(isInVec || lockType == IDC_LOCKALL || (!shiftPressed && knotType == KTYPE_BEZIER)) {
							// In vector
							int vert = kvert - 1;
							// XForm the cache vertices
							oldpt = spline->GetVert(vert) - pDeltas[vert];
							oldVector = oldpt - theKnot;
							oldLen = Length(oldVector);
							// If the old vector existed, transform it!
							if(oldLen != 0.0f) {
								Point3 newpt = theKnot + ((oldVector * lengthRatio) * theMatrix);
								// Alter the cache
								spline->SetVert(vert,newpt);
								// Move the delta's vertices.
								shapeData->vdelta.SetPoint(poly,vert,newpt-oldpt);
								}
							}

						if(!isInVec || lockType == IDC_LOCKALL || (!shiftPressed && knotType == KTYPE_BEZIER)) {
							// Out vector
							int vert = kvert + 1;
							// XForm the cache vertices
							oldpt = spline->GetVert(vert) - pDeltas[vert];
							oldVector = oldpt - theKnot;
							oldLen = Length(oldVector);
							// If the old vector existed, transform it!
							if(oldLen != 0.0f) {
								Point3 newpt = theKnot + ((oldVector * lengthRatio) * theMatrix);
								// Alter the cache
								spline->SetVert(vert,newpt);
								// Move the delta's vertices.
								shapeData->vdelta.SetPoint(poly,vert,newpt-oldpt);
								}
							}
						}
					}
				}
			}

		shapeData->UpdateChanges(shape);
		shapeData->TempData(this)->Invalidate(PART_GEOM);
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	// Mark all objects in selection set
	SetAFlag(A_HELD);
	
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

// --------------------------------------------------------------------------------------

class XFormVertsRestore : public RestoreObj {
public:
	TimeValue t;
	BOOL gotRedo;
	BezierShape undo;
	BezierShape redo;
	EditSplineData *esd;
	EditSplineMod *mod;
	
	XFormVertsRestore(EditSplineData *d, EditSplineMod *m, BezierShape *ss) {
		undo.CopyShapeDataFrom(*ss);
		gotRedo = FALSE;
		esd = d;
		mod = m;
		t = mod->ip->GetTime();
		}

	void Restore(int isUndo) {
		if ( esd->tempData && esd->TempData(mod)->ShapeCached(t) ) {
			BezierShape *shape = esd->TempData(mod)->GetShape(t);
			if(shape) {
				if (isUndo) {
					if(!gotRedo) {
						gotRedo = TRUE;
						redo.CopyShapeDataFrom(*shape);
						}
					}
				shape->CopyShapeDataFrom(undo);
				shape->InvalidateGeomCache();
				}
			esd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT);
			}
		else
		if ( esd->tempData ) {
			esd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT, FALSE);
			}
		mod->NotifyDependents(FOREVER, PART_GEOM | PART_TOPO | PART_SELECT, REFMSG_CHANGE);
		}

	void Redo() {
		if ( esd->tempData && esd->TempData(mod)->ShapeCached(t) ) {
			BezierShape *shape = esd->TempData(mod)->GetShape(t);
			if(shape) {
				shape->CopyShapeDataFrom(redo);
				shape->InvalidateGeomCache();
				esd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT);
				}
			}
		else
		if ( esd->tempData ) {
			esd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT, FALSE);
			}
		mod->NotifyDependents(FOREVER, PART_GEOM | PART_TOPO | PART_SELECT, REFMSG_CHANGE);
		}

	int Size() { return 1; }
	void EndHold() { mod->ClearAFlag(A_HELD); }
	TSTR Description() { return TSTR(_T("Generic shape restore")); }
};

// --------------------------------------------------------------------------------------

void EditSplineMod::XFormVerts( 
		XFormProc *xproc, 
		TimeValue t, 
		Matrix3& partm, 
		Matrix3& tmAxis  ) 
	{	
	ModContextList mcList;		
	INodeTab nodes;
	Matrix3 mat,imat;	
	Interval valid;
	int numAxis;
	Point3 oldpt,newpt,oldin,oldout,rel,delta;
	int shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) ? 1 : 0;
	static BOOL wasBroken;
	static BOOL handleEdit = FALSE;
	static int handleObject;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	numAxis = ip->GetNumAxis();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	if(!TestAFlag(A_HELD)) {
		handleEdit = FALSE;

		// Check all shapes to see if they are altering a bezier vector handle...
		if(selLevel == ES_VERTEX) {
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
				if ( !shapeData ) continue;
				if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		
				// If the mesh isn't yet cache, this will cause it to get cached.
				BezierShape *shape = shapeData->TempData(this)->GetShape(t);
				if(!shape) continue;
				if(!ip->SelectionFrozen() && shape->bezVecPoly >= 0) {
					// Editing a bezier handle -- Go do it!
					handleEdit = TRUE;
					handleObject = i;
					goto edit_handles;
					}
	 			shapeData->SetFlag(ESD_BEENDONE,TRUE);
				}
			}
		}
	
	// If editing the handles, cut to the chase!
	if(handleEdit) {
		edit_handles:
		XFormHandles(xproc, t, partm, tmAxis, handleObject);
		nodes.DisposeTemporary();
		return;
		}

	// Not doing handles, just plain ol' verts
	ClearShapeDataFlag(mcList,ESD_BEENDONE);	// Clear these out again
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		
		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		// Create a change record for this object and store a pointer to its delta info in this EditSplineData
		if(!TestAFlag(A_HELD)) {
			shapeData->vdelta.SetSize(*shape,FALSE);
			shapeData->vdelta.Zero();		// Reset all deltas
			shapeData->RecordTopologyTags(shape);
			if ( theHold.Holding() ) {
				theHold.Put(new XFormVertsRestore(shapeData, this, shape));
				}
			shapeData->ClearHandleFlag();
			wasBroken = FALSE;
			}
		else {
			if(wasBroken)
				shiftPressed = TRUE;
			if(shapeData->DoingHandles())
				shapeData->ApplyHandlesAndZero(*shape);		// Reapply the slave handle deltas
			else
				shapeData->vdelta.Zero();
			}

		// Compute the transforms
		if (numAxis==NUMAXIS_INDIVIDUAL) {
			switch(selLevel) {
				case ES_VERTEX:
				case ES_SEGMENT: {
					int vbase = 1;
					for(int poly = 0; poly < shape->splineCount; ++poly) {
						shapeData->vdelta.ClearUsed(poly);
						// Selected vertices - either directly or indirectly through selected faces or edges.
						BitArray sel = shape->VertexTempSel(poly);
						Spline3D *spline = shape->splines[poly];
						int knots = spline->KnotCount();
						for ( int k = 0; k < knots; k++,vbase+=3 ) {
							int vert = k*3+1;
//watje 5-20-99
							BOOL bound = FALSE;
							if ((k==0) && (!spline->Closed()))
								{
								for (int bct = 0; bct < shape->bindList.Count(); bct++)
									{
									if ((shape->bindList[bct].pointSplineIndex == poly) && (!shape->bindList[bct].isEnd))
										bound = TRUE;
									}
								}
							else if ((k==(knots-1)) && (!spline->Closed()))
								{
								for (int bct = 0; bct < shape->bindList.Count(); bct++)
									{
									if ((shape->bindList[bct].pointSplineIndex == poly) && (shape->bindList[bct].isEnd))
										bound = TRUE;
									}
								}

							if (( sel[vert] ) && (!bound)) {
//							if ( sel[vert] ) {
								shapeData->vdelta.SetUsed(poly);
								tmAxis = ip->GetTransformAxis(nodes[i],vbase);
								mat    = nodes[i]->GetObjectTM(t,&valid) * Inverse(tmAxis);
								imat   = Inverse(mat);
								xproc->SetMat(mat);
					
								// XForm the cache vertices
								oldpt = spline->GetVert(vert);
								newpt = xproc->proc(oldpt,mat,imat);
								spline->SetVert(vert,newpt);
								delta = newpt - oldpt;

								// Move the delta's vertices.
								shapeData->vdelta.Move(poly,vert,delta);

								// If it's a bezier knot, also affect its vectors
								if(spline->IsBezierPt(k)) {
									int in = vert - 1;
									int out = vert + 1;

									// XForm the cache vertices
									oldin = spline->GetVert(in);
									spline->SetVert(in,xproc->proc(oldin,mat,imat));
									delta = spline->GetVert(in) - oldin;

									// Move the delta's vertices.
									shapeData->vdelta.Move(poly,in,delta);

									// XForm the cache vertices
									oldout = spline->GetVert(out);
									spline->SetVert(out,xproc->proc(oldout,mat,imat));

									// Move the delta's vertices.
									shapeData->vdelta.Move(poly,out,spline->GetVert(out) - oldout);
									}
								}
							}
						if(shapeData->vdelta.IsUsed(poly)) {
							spline->ComputeBezPoints();
							shape->InvalidateGeomCache();
							}
						}
					}
					break;
				case ES_SPLINE: {
					for(int poly = 0; poly < shape->splineCount; ++poly) {
						shapeData->vdelta.ClearUsed(poly);
						// Selected vertices - either directly or indirectly through selected faces or edges.
						BitArray sel = shape->VertexTempSel(poly);
						Spline3D *spline = shape->splines[poly];
						int knots = spline->KnotCount();
						for ( int k = 0; k < knots; k++ ) {
							int vert = k*3+1;
							if ( sel[vert] ) {
								shapeData->vdelta.SetUsed(poly);
								tmAxis = ip->GetTransformAxis(nodes[i],poly);
								mat    = nodes[i]->GetObjectTM(t,&valid) * Inverse(tmAxis);
								imat   = Inverse(mat);
								xproc->SetMat(mat);
						
								// XForm the cache vertices
								oldpt = spline->GetVert(vert);
								newpt = xproc->proc(oldpt,mat,imat);
								spline->SetVert(vert,newpt);
								delta = newpt - oldpt;

								// Move the delta's vertices.
								shapeData->vdelta.Move(poly,vert,delta);

								// If it's a bezier knot, also affect its vectors
								if(spline->IsBezierPt(k)) {
									int in = vert - 1;
									int out = vert + 1;

									// XForm the cache vertices
									oldin = spline->GetVert(in);
									spline->SetVert(in,xproc->proc(oldin,mat,imat));
									delta = spline->GetVert(in) - oldin;

									// Move the delta's vertices.
									shapeData->vdelta.Move(poly,in,delta);

									// XForm the cache vertices
									oldout = spline->GetVert(out);
									spline->SetVert(out,xproc->proc(oldout,mat,imat));

									// Move the delta's vertices.
									shapeData->vdelta.Move(poly,out,spline->GetVert(out) - oldout);
									}
								}
							}
						if(shapeData->vdelta.IsUsed(poly)) {
							spline->ComputeBezPoints();
							shape->InvalidateGeomCache();
							}
						}
					}
					break;
				}			
			}
		else {
			mat = nodes[i]->GetObjectTM(t,&valid) * Inverse(tmAxis);
			imat = Inverse(mat);
			xproc->SetMat(mat);

			for(int poly = 0; poly < shape->splineCount; ++poly) {
				shapeData->vdelta.ClearUsed(poly);
				// Selected vertices - either directly or indirectly through selected faces or edges.
				BitArray sel = shape->VertexTempSel(poly);
				Spline3D *spline = shape->splines[poly];
				int knots = spline->KnotCount();
				for ( int k = 0; k < knots; k++ ) {
					int vert = k*3+1;
//watje 5-20-99
					BOOL bound = FALSE;
					if ((k==0) && (!spline->Closed()))
						{
						for (int bct = 0; bct < shape->bindList.Count(); bct++)
							{
							if ((shape->bindList[bct].pointSplineIndex == poly) && (!shape->bindList[bct].isEnd))
								bound = TRUE;
							}
						}
					else if ((k==(knots-1)) && (!spline->Closed()))
						{
						for (int bct = 0; bct < shape->bindList.Count(); bct++)
							{
							if ((shape->bindList[bct].pointSplineIndex == poly) && (shape->bindList[bct].isEnd))
								bound = TRUE;
							}
						}

					if (( sel[vert] ) && (!bound)) {
//					if ( sel[vert] ) {
						shapeData->vdelta.SetUsed(poly);

						// XForm the cache vertices
						oldpt = spline->GetVert(vert);
						newpt = xproc->proc(oldpt,mat,imat);
						spline->SetVert(vert,newpt);
						delta = newpt - oldpt;

						// Move the delta's vertices.
						shapeData->vdelta.Move(poly,vert,delta);

						// If it's a bezier knot, also affect its vectors
						if(spline->IsBezierPt(k)) {
							int in = vert - 1;
							int out = vert + 1;

							// XForm the cache vertices
							oldin = spline->GetVert(in);
							spline->SetVert(in,xproc->proc(oldin,mat,imat));

							// Move the delta's vertices.
							shapeData->vdelta.Move(poly,in,spline->GetVert(in) - oldin);

							// XForm the cache vertices
							oldout = spline->GetVert(out);
							spline->SetVert(out,xproc->proc(oldout,mat,imat));

							// Move the delta's vertices.
							shapeData->vdelta.Move(poly,out,spline->GetVert(out) - oldout);
							}
						}
					}
				if(shapeData->vdelta.IsUsed(poly)) {
					spline->ComputeBezPoints();
					shape->InvalidateGeomCache();
					}
				}
			}
		shapeData->UpdateChanges(shape);					
		shapeData->TempData(this)->Invalidate(PART_GEOM);
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	// Mark all objects in selection set
	SetAFlag(A_HELD);
	
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

void EditSplineMod::Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin )
	{
	MoveXForm proc(val);
	XFormVerts(&proc,t,partm,tmAxis); 	
	}

void EditSplineMod::Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin )
	{
	RotateXForm proc(val);
	XFormVerts(&proc,t,partm,tmAxis); 	
	}

void EditSplineMod::Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin )
	{
	ScaleXForm proc(val);
	XFormVerts(&proc,t,partm,tmAxis); 	
	}

static IPoint2
ProjectPointI(GraphicsWindow *gw, Point3 fp) {
	IPoint3 out;
	gw->wTransPoint(&fp,&out);
	IPoint2 work;
	work.x = out.x + 1;
	work.y = out.y + 1;
	return work;
	}

static Point2
ProjectPointF(GraphicsWindow *gw, Point3 fp) {
	IPoint3 out;
	gw->wTransPoint(&fp,&out);
	Point2 work;
	work.x = (float)out.x;
	work.y = (float)out.y;
	return work;
	}

class AutoConnectPrompt {
	public:
		BOOL prompted;
		BOOL doIt;
		AutoConnectPrompt() { prompted = FALSE; }
		BOOL DoIt(ViewExp *vpt, Matrix3 &tm, Point3 p1, Point3 p2);
	};

#define HITSIZE 6

BOOL AutoConnectPrompt::DoIt(ViewExp *vpt, Matrix3 &tm, Point3 p1, Point3 p2) {
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(tm);

	IPoint2 sp1 = ProjectPointI(gw, p1);
	IPoint2 sp2 = ProjectPointI(gw, p2);

	if(abs(sp1.x - sp2.x) >= HITSIZE || abs(sp1.y - sp2.y) >= HITSIZE)
		return FALSE;
	if(prompted)
		return doIt;
	if(weldThreshold == 0.0f)
		return FALSE;
	TSTR s1 = GetString(IDS_TH_CONNECT_COINCIDENT);
	TSTR s2 = GetString(IDS_TH_EDITSPLINE);
	int result = MessageBox(GetActiveWindow(), s1, s2, MB_YESNO);
	doIt = (result == IDYES) ? TRUE : FALSE;
	prompted = TRUE;
	if(!doIt)
		theHold.End();
	return doIt;
	}

// The following is called before the first Move(), Rotate() or Scale() call
void EditSplineMod::TransformStart(TimeValue t) {
	if(!ip)
		return;
	ip->LockAxisTripods(TRUE);
	NotifyDependents(FOREVER, 0, REFMSG_SHAPE_START_CHANGE);
	BOOL shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;
	if(shiftPressed) {
		if(selLevel == ES_SEGMENT) {
			ModContextList mcList;		
			INodeTab nodes;
			Interval valid;

			theHold.Begin();
			BOOL needUndo = FALSE;

			ip->GetModContexts(mcList,nodes);
			ClearShapeDataFlag(mcList,ESD_BEENDONE);
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
				if ( !shapeData ) continue;
				if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
				
				// If the mesh isn't yet cache, this will cause it to get cached.
				BezierShape *shape = shapeData->TempData(this)->GetShape(t);
				if(!shape) continue;
				shapeData->RecordTopologyTags(shape);

				// Go thru all polygons -- If any segs selected, copy 'em
				int polys = shape->SplineCount();
				BOOL altered = FALSE;
				for(int poly = 0; poly < polys; ++poly) {
					if(shape->segSel[poly].NumberSet()) {
						Spline3D *spline = shape->splines[poly];
						// Start a restore object...
						if ( theHold.Holding() ) {
							theHold.Put(new ShapeRestore(shapeData,this,shape));
							}
						CopySegments(shape, TRUE);	// Actually copy it
						altered = needUndo = TRUE;
						}
					}
				if(altered) {
					shapeData->UpdateChanges(shape);
					shapeData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);
					}

				shapeData->TempData(this)->Invalidate(PART_GEOM);
				shapeData->SetFlag(ESD_BEENDONE,TRUE);
				}
			nodes.DisposeTemporary();
			if(needUndo)
				theHold.Accept(GetString(IDS_TH_COPY_SEGMENT));
			else
				theHold.End(); 		// Forget it!

			}
		else
		if(selLevel == ES_SPLINE) {
			ModContextList mcList;		
			INodeTab nodes;
			Interval valid;

			if ( !ip ) return;

			theHold.Begin();
			BOOL needUndo = FALSE;

			ip->GetModContexts(mcList,nodes);
			ClearShapeDataFlag(mcList,ESD_BEENDONE);
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
				if ( !shapeData ) continue;
				if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
				
				// If the mesh isn't yet cache, this will cause it to get cached.
				BezierShape *shape = shapeData->TempData(this)->GetShape(t);
				if(!shape) continue;
				shapeData->RecordTopologyTags(shape);
				
				// Go thru all polygons -- If it's selected, copy it
				int polys = shape->SplineCount();
				BOOL altered = FALSE;
				for(int poly = 0; poly < polys; ++poly) {
					if(shape->polySel[poly]) {
						Spline3D *spline = shape->splines[poly];
						// Start a restore object...
						if ( theHold.Holding() ) {
							theHold.Put(new ShapeRestore(shapeData,this,shape));
							}
						CopySpline(shape, poly, FALSE, TRUE);	// Actually copy it
						altered = needUndo = TRUE;
						}
					}
				if(altered) {
					shapeData->UpdateChanges(shape);
					shapeData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);
					}

				shapeData->TempData(this)->Invalidate(PART_GEOM);
				shapeData->SetFlag(ESD_BEENDONE,TRUE);
				}
			nodes.DisposeTemporary();
			if(needUndo)
				theHold.Accept(GetString(IDS_TH_COPY_SPLINE));
			else
				theHold.End(); 		// Forget it!
			}	
		}
	}

// The following is called after the user has completed the Move, Rotate or Scale operation and
// the undo object has been accepted.
void EditSplineMod::TransformFinish(TimeValue t) {
	ModContextList mcList;		
	INodeTab nodes;
	Matrix3 mat,imat;	
	Interval valid;
	int numAxis;
	Point3 oldpt,newpt,oldin,oldout,rel,delta;
	AutoConnectPrompt thePrompt;
	if ( !ip ) return;

	ViewExp *vpt = ip->GetViewport(NULL);

	ip->LockAxisTripods(FALSE);

	theHold.Begin();
	BOOL needUndo = FALSE;

	ip->GetModContexts(mcList,nodes);
	numAxis = ip->GetNumAxis();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		
		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		Matrix3 nodeTM = nodes[i]->GetObjectTM(t);

		changed:
		// Go thru all polygons -- If it's an open poly and it has a selected end vertex, see if
		// its end verts overlap -- if they do, prompt for closure.
		int polys = shape->SplineCount();
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			if(!spline->Closed()) {
				int knots = spline->KnotCount();
				BitArray pSel = shape->VertexTempSel(poly);
				if(knots > 2 && (pSel[1] || pSel[(knots-1)*3+1])) {
					Point3 p1 = spline->GetKnotPoint(0);
					Point3 p2 = spline->GetKnotPoint(knots-1);
					if(thePrompt.DoIt(vpt, nodeTM, p1, p2)) {
						// Start a restore object...
						if ( theHold.Holding() )
							theHold.Put(new ShapeRestore(shapeData,this,shape));
						// Do the close
						if(pSel[1]) {
							DoPolyEndAttach(shape, poly, 0, poly, knots-1);
							}
						else {
							DoPolyEndAttach(shape, poly, knots-1, poly, 0);
							}
						shapeData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);
						needUndo = TRUE;
						}
					}

				}
			}
		// Go thru all polygons -- If an open poly, and it has a selected end vertex, see if its
		// end vertices overlap the end vertex of another open poly.  If so, prompt for connection
		for(int poly1 = 0; poly1 < polys; ++poly1) {
			Spline3D *spline1 = shape->splines[poly1];
			if(!spline1->Closed()) {
				int knots1 = spline1->KnotCount();
				int lastKnot1 = knots1-1;
				int lastSel1 = lastKnot1 * 3 + 1;
				BitArray pSel = shape->VertexTempSel(poly1);
				if(pSel[1] || pSel[lastSel1]) {
					Point3 p1 = spline1->GetKnotPoint(0);
					Point3 p2 = spline1->GetKnotPoint(knots1-1);
					for(int poly2 = 0; poly2 < polys; ++poly2) {
						Spline3D *spline2 = shape->splines[poly2];
						if(poly1 != poly2 && !spline2->Closed()) {
							int knots2 = spline2->KnotCount();
							Point3 p3 = spline2->GetKnotPoint(0);
							Point3 p4 = spline2->GetKnotPoint(knots2-1);
							int vert1, vert2;
							if(pSel[1]) {
								if(thePrompt.DoIt(vpt, nodeTM, p3, p1)) {
									vert1 = 0;
									vert2 = 0;

									attach_it:
									// Start a restore object...
									if ( theHold.Holding() )
										theHold.Put(new ShapeRestore(shapeData,this,shape));
									// Do the attach
									DoPolyEndAttach(shape, poly1, vert1, poly2, vert2);
									shapeData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);
									needUndo = TRUE;
									goto changed;
									}
								else
								if(thePrompt.DoIt(vpt, nodeTM, p4, p1)) {
									vert1 = 0;
									vert2 = knots2-1;
									goto attach_it;
									}
								}
							if(pSel[lastSel1]) {
								if(thePrompt.DoIt(vpt, nodeTM, p3, p2)) {
									vert1 = knots1-1;
									vert2 = 0;
									goto attach_it;
									}
								else
								if(thePrompt.DoIt(vpt, nodeTM, p4, p2)) {
									vert1 = knots1-1;
									vert2 = knots2-1;
									goto attach_it;
									}
								}
							}
						}
					}
				}
			}
		shapeData->UpdateChanges(shape);
		shapeData->TempData(this)->Invalidate(PART_GEOM);
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	if(needUndo)
		theHold.Accept(GetString(IDS_TH_POLYCONNECT));
	else
		theHold.End(); 		// Forget it!
	
	nodes.DisposeTemporary();
	SelectionChanged();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, 0, REFMSG_SHAPE_END_CHANGE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	if ( vpt ) ip->ReleaseViewport(vpt);
	}

// The following is called when the transform operation is cancelled by a right-click and the undo
// has been cancelled.
void EditSplineMod::TransformCancel(TimeValue t) {
//DebugPrint("Transform cancel\n");
	if (ip) ip->LockAxisTripods(FALSE);
	NotifyDependents(FOREVER, PART_ALL, REFMSG_SHAPE_END_CHANGE);
	}

void EditSplineMod::DoBoolean(int poly2)
	{
	ModContextList mcList;	
	INodeTab nodes;
	DWORD *clones = NULL;	
	BOOL altered = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);

	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;

		// If the mesh isn't yet cached, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		if(!shape) continue;

		if(shape == boolShape) {
			shapeData->RecordTopologyTags(shape);
			int newPolyNum;

			// Start a restore object...
			if ( theHold.Holding() ) {
				theHold.Put(new ShapeRestore(shapeData,this,shape));
				}
			int boolStat = PerformBoolean(boolShape, boolPoly1, poly2, boolType, &newPolyNum);
			switch(boolStat) {
				case BOOL_OK:
					altered = TRUE;
					shapeData->UpdateChanges(shape);
					shapeData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);
					if(newPolyNum >= 0)
						boolPoly1 = newPolyNum;
					else
						CancelEditSplineModes(ip);	// Cancel mode if more than one poly resulted
					break;
				default: {
					TSTR reason;
					switch(boolStat) {
						case BOOL_WELD_FAILURE:
							reason = GetString(IDS_TH_BOOLWELDFAILED);
							break;
						case BOOL_COINCIDENT_VERTEX:
							reason = GetString(IDS_TH_COINCIDENTVERTEX);
							break;
						case BOOL_MUST_OVERLAP:
							reason = GetString(IDS_TH_SPLINESMUSTOVERLAP);
							break;
						}
					ip->DisplayTempPrompt(reason,PROMPT_TIME);
					}
					break;
				}	
			goto done;
			}
		}
			
	// Accept all the outlines so they go on the undo stack
	done:
	if(altered)
		theHold.Accept(GetString(IDS_TH_BOOLEAN));
	else
		theHold.Cancel();

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO|PART_GEOM, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}					

void EditSplineMod::DoSegRefine(ViewExp *vpt, BezierShape *rshape, int poly, int seg, IPoint2 p) {
	ModContextList mcList;		
	INodeTab nodes;
	int holdNeeded = 0;
	int altered = 0;
	TimeValue t = ip->GetTime();
	
	Point3 sPoint = vpt->SnapPoint(p,p,NULL,SNAP_IN_3D);

	Point2 fp = Point2((float)p.x, (float)p.y);

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);

	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		if(shape == rshape) {
			shapeData->RecordTopologyTags(shape);
			
			// Find the location on the segment where the user clicked
			INode *inode = nodes[i];
			GraphicsWindow *gw = vpt->getGW();
			Matrix3 mat = inode->GetObjectTM(t);
			gw->setTransform(mat);	

			Spline3D *spline = shape->splines[poly];

			// Go thru the segment and narrow down where they hit
			float rez = 0.01f;
			float lorez = 0.0f;
			float hirez = 1.0f;
			// Start with a rough estimate
			HitRegion hr;
			MakeHitRegion(hr, HITTYPE_POINT, 1, 4, &p);
			gw->setHitRegion(&hr);
			float bestParam = shape->FindSegmentPoint(poly, seg, gw, gw->getMaterial(), &hr);
			Point3 pt = spline->InterpBezier3D(seg, bestParam);
			Point2 sp = ProjectPointF(gw, pt);
			float bestDist = 1000.0f;
			int iBestDist = 1000;
			if(bestParam > 0.0f) {
				bestDist = Length(sp - fp);
				iBestDist = (int)bestDist;
				}
			BOOL bestChanged = TRUE;
			while((rez > 0.00005f) || bestChanged) {
				bestChanged = FALSE;
				for(float sample = lorez; sample <= hirez; sample += rez) {
					pt = spline->InterpBezier3D(seg, sample);
					sp = ProjectPointF(gw, pt);
					float dist = Length(sp - fp);
					if(dist < bestDist) {
						int ibd = (int)dist;
						if(ibd < iBestDist) {
							bestChanged = TRUE;
							iBestDist = ibd;
							}
						bestDist = dist;
						bestParam = sample;
						if(bestDist <= 0.5)
							goto got_it;
						}
					}
				lorez = bestParam - rez;
				if(lorez < 0.0f)
					lorez = 0.0f;
				hirez = bestParam + rez;
				if(hirez > 1.0f)
					hirez = 1.0f;
				rez /= 10.0f;
				}

			got_it:
			if(iBestDist < 1000) {			
				altered = holdNeeded = 1;
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				RefineSegment(shape, poly, seg, bestParam, TRUE);
				shapeData->UpdateChanges(shape);
				shapeData->TempData(this)->Invalidate(PART_TOPO);
				theHold.Accept(GetString(IDS_TH_REFINE));
				}
			else
				theHold.Cancel();
			goto finished;
			}
		}
	finished:
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t, REDRAW_NORMAL);
	}

static void DivideSegment(BezierShape *shape, int poly, int divisions) {
	Spline3D *spline = shape->splines[poly];
	int segments = spline->Segments();
	// First tag auto points for later fixup 
	for(int k = 0; k < spline->KnotCount(); ++k) {
		int nextKnot = (k + 1) % spline->KnotCount();
		if(spline->GetKnotType(k) == KTYPE_AUTO) {
			if(spline->GetKnotType(nextKnot) == KTYPE_AUTO)
				spline->SetAux3(k, 1111);	// Span to be all auto
			else
				spline->SetAux3(k, 111);		// Span left alone
			}
		else
			spline->SetAux3(k, 222);	// Leave these alone
		}
	// Now convert all auto points to bezier corner
	for(k = 0; k < spline->KnotCount(); ++k) {
		if(spline->GetKnotType(k) == KTYPE_AUTO)
			spline->SetKnotType(k, KTYPE_BEZIER_CORNER);
		}
	// Now refine the curve
	for(int seg = segments - 1; seg >= 0; --seg) {
		if(shape->segSel[poly][seg]) {
			// Perform a recursive division of the segment from the end
			for(int div = divisions; div > 0; --div) {
				float pos = (float)div / (float)(div + 1);
				RefineSegment(shape, poly, seg, pos);
				}
			}
		}
	// Now convert all saved auto points back! 
	int inAuto = FALSE;
	for(k = 0; k < spline->KnotCount(); ++k) {
		switch(spline->GetAux3(k)) {
			case 111:
				inAuto = FALSE;
				spline->SetKnotType(k, KTYPE_AUTO);
				break;
			case 1111:
				inAuto = TRUE;
				spline->SetKnotType(k, KTYPE_AUTO);
				break;
			case 222:
				break;
			default:	// New point
				if(inAuto)
					spline->SetKnotType(k, KTYPE_AUTO);
				break;
			}
		}
	spline->ComputeBezPoints();
	}

void EditSplineMod::DoSegDivide(int divisions) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->segSel[poly].NumberSet()) {
				altered = holdNeeded = 1;
				if ( theHold.Holding() )
					theHold.Put(new ShapeRestore(shapeData,this,shape));
				// Call the segment divide function
				DivideSegment(shape, poly, divisions);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_DIVIDE_SEGMENT));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSEGSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

// Reverse all selected polygons
void EditSplineMod::DoPolyReverse() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	MaybeSelectSingleSpline();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys-1; poly >= 0; --poly) {
			if(shape->polySel[poly]) {
				Spline3D *spline = shape->splines[poly];
				altered = holdNeeded = 1;
				// Save the unmodified verts.
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->Reverse(poly, TRUE);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_REVERSE_SPLINE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

static TSTR explodeName;

static BOOL CALLBACK ExplodeDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	TCHAR tempName[256];
	switch (msg) {
	case WM_INITDIALOG:
		SetDlgItemText(hWnd, IDC_ES_EXPLODE_NAME, explodeName);
		CenterWindow(hWnd, GetParent(hWnd));
		SendMessage(GetDlgItem(hWnd,IDC_ES_EXPLODE_NAME), EM_SETSEL,0,-1);
		SetFocus(GetDlgItem(hWnd,IDC_ES_EXPLODE_NAME));
		return FALSE;

	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDOK:
			GetDlgItemText(hWnd, IDC_ES_EXPLODE_NAME, tempName, 255);
			explodeName = TSTR(tempName);
			EndDialog(hWnd,1);
			break;

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;

	default:
		return 0;
	}
	return 1;
}

static BOOL GetExplodeObjectName (IObjParam *ip, TSTR &name) {
	explodeName = name;
	ip->MakeNameUnique(explodeName);	
	if (DialogBox(hInstance, MAKEINTRESOURCE(IDD_ES_EXPLODE), ip->GetMAXHWnd(), ExplodeDlgProc)) {
		name = explodeName;
		return TRUE;
		}
	return FALSE;
}

// Explode all selected polygons
void EditSplineMod::DoPolyExplode() {
	ModContextList mcList;		
	INodeTab nodes;

	if ( !ip ) return;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	MaybeSelectSingleSpline();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;

		if(shape->polySel.sel.NumberSet()) {
			int altered = 0;
			shapeData->RecordTopologyTags(shape);
			// Save the unmodified verts.
			if ( theHold.Holding() ) {
				theHold.Put(new ShapeRestore(shapeData,this,shape));
				}
		
			// If this is the first edit, then the delta arrays will be allocated
			shapeData->BeginEdit(t);

			int polys = shape->splineCount;
			for(int poly = polys-1; poly >= 0; --poly) {
				if(shape->polySel[poly]) {
					Spline3D *spline = shape->splines[poly];
					altered = holdNeeded = 1;
					// Select all the vertices
					shape->vertSel[poly].ClearAll();
					for(int i = 1; i < shape->splines[poly]->Verts(); i+=3)
						shape->vertSel[poly].Set(i);
					// Call the vertex break function!
					BreakSplineAtSelVerts(shape, poly);
					}
				}

			if(altered) {
				shapeData->UpdateChanges(shape);
				shapeData->TempData(this)->Invalidate(PART_TOPO);
				}
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_EXPLODE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditSplineMod::DoExplodeToObjects() {
	ModContextList mcList;		
	INodeTab nodes;

	if ( !ip ) return;

	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	int dialoged = 0;
	TSTR newName(GetString(IDS_TH_SHAPE));

	theHold.Begin();
	MaybeSelectSingleSpline();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;

		if(shape->polySel.sel.NumberSet()) {

			shapeData->RecordTopologyTags(shape);
			
			// Save the unmodified verts.
			if ( theHold.Holding() ) {
				theHold.Put(new ShapeRestore(shapeData,this,shape));
				}
			// If this is the first edit, then the delta arrays will be allocated
			shapeData->BeginEdit(t);
			SplineShape *splShape;

			BOOL altered = FALSE;
			int polys = shape->splineCount;
			for(int poly = polys - 1; poly >= 0; --poly) {
				if(shape->polySel[poly]) {
					Spline3D *spline = shape->splines[poly];
					shape->segSel[poly].ClearAll();
					int segs = spline->Segments();
					while(segs > 0) {
						segs--;
						shape->segSel[poly].Set(0);
						if(!dialoged) {
							dialoged = 1;
							if(!GetExplodeObjectName(ip, newName))
								goto bail_out;
							}
						else
							ip->MakeNameUnique(newName);

						altered = holdNeeded = 1;					
						splShape = new SplineShape;
						HandleSegDetach(shape, &splShape->shape, SDT_DETACH, poly);
						splShape->shape.UpdateSels();	// Make sure it readies the selection set info
						splShape->shape.InvalidateGeomCache();
						INode *newNode = ip->CreateObjectNode(splShape);
						newNode->SetName(newName.data());
						Matrix3 tm = nodes[0]->GetObjectTM(t);
						newNode->SetNodeTM(t, tm);	// Use this object's TM.
						newNode->FlagForeground(t);		// WORKAROUND!
						}
					}
				}
			if(altered) {
				shape->UpdateSels();
				shapeData->UpdateChanges(shape);
				}
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}

	bail_out:
	if(holdNeeded) {
		theHold.Accept(GetString(IDS_TH_EXPLODE));
		}
	else {
		if(!dialoged)
			ip->DisplayTempPrompt(GetString(IDS_TH_NOSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t, REDRAW_NORMAL);
	}

// Helper class to locate closest points on segments

#define CSP_STEPS 50

class ClosestSegPoint {
	public:
		Spline3D *spline;
		int segment;
		float min;
		float max;
		float step;
		float bestParam;
		int bestIndex;
		float bestDist;
		BOOL gotBestIndex;
		Point3 interps[CSP_STEPS + 1];
		ClosestSegPoint(Spline3D *s, int seg) {
			spline = s;
			segment = seg;
			min = 0.0f;
			max = 1.0f;
			gotBestIndex = FALSE;
			}
		void Interpolate();
		void NextLevel(ClosestSegPoint &other);
		void SetBestIndex(int value) { bestIndex = value; gotBestIndex = TRUE; }
	};

void ClosestSegPoint::Interpolate() {
	int i;
	float param;
	step = (max - min) / (float)CSP_STEPS;
	for(i = 0, param = min; i < (CSP_STEPS + 1); ++i, param += step)
		interps[i] = spline->InterpBezier3D(segment, param);
	gotBestIndex = FALSE;
	}

void ClosestSegPoint::NextLevel(ClosestSegPoint &other) {
	if(!gotBestIndex) {
		bestIndex = -1;
		bestDist = 0.0f;
		for(int i = 0; i < (CSP_STEPS + 1); ++i) {
			for(int j = 0; j < (CSP_STEPS + 1); ++j) {
				float dist = Length(interps[i] - other.interps[j]);
				if(bestIndex < 0 || dist < bestDist) {
					SetBestIndex(i);
					other.SetBestIndex(j);
					bestDist = other.bestDist = dist;
					}
				}
			}
		}
	if(bestIndex == 0) {
		max = min + step;
		}
	else
	if(bestIndex == CSP_STEPS) {
		min = max - step;
		}
	else {
		max = min + (float)(bestIndex + 1) * step;
		min = min + (float)(bestIndex - 1) * step;
		}
	bestParam = (min + max) / 2.0f;
	}

#define CROSS_INSERT_LOOPS 20

void EditSplineMod::DoCrossInsert(ViewExp *vpt, BezierShape *rshape, int poly1, int seg1, int poly2, int seg2, IPoint2 p) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	Point2 fp = Point2((float)p.x, (float)p.y);

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);

	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		if(shape == rshape) {
			shapeData->RecordTopologyTags(shape);
			if ( theHold.Holding() )
				theHold.Put(new ShapeRestore(shapeData,this,shape));

			// Find the location where the segments are closest
			ClosestSegPoint csp1(rshape->GetSpline(poly1),seg1);
			ClosestSegPoint csp2(rshape->GetSpline(poly2),seg2);
			for(int loops = 0; loops < CROSS_INSERT_LOOPS; ++loops) {
				csp1.Interpolate();
				csp2.Interpolate();
				csp1.NextLevel(csp2);
				csp2.NextLevel(csp1);
				}

			// When we get here, we have a pretty good idea of where the best point is
			// Make sure it's within the user's threshold!
			if(csp1.bestDist <= crossThreshold) {
				RefineSegment(shape, poly1, seg1, csp1.bestParam);
				RefineSegment(shape, poly2, seg2, csp2.bestParam);
				shapeData->UpdateChanges(shape);
				shapeData->TempData(this)->Invalidate(PART_TOPO);
				theHold.Accept(GetString(IDS_TH_CROSS_INSERT));
				NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
				ip->RedrawViews(t, REDRAW_NORMAL);
				}
			else {
				ip->DisplayTempPrompt(GetString(IDS_TH_CROSS_NOT_IN_THRESHOLD),PROMPT_TIME);
				theHold.End();
				}
			goto finished;
			}
		}

finished:
	nodes.DisposeTemporary();
	}

void EditSplineMod::DoSegBreak(ViewExp *vpt, BezierShape *rshape, int poly, int seg, IPoint2 p) {
	ModContextList mcList;		
	INodeTab nodes;
	int holdNeeded = 0;
	int altered = 0;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);

	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		if(shape == rshape) {
			shapeData->RecordTopologyTags(shape);

			// Find the location on the segment where the user clicked
			INode *inode = nodes[i];
			GraphicsWindow *gw = vpt->getGW();
			HitRegion hr;
			MakeHitRegion(hr, HITTYPE_POINT, 1, 4, &p);
			gw->setHitRegion(&hr);
			Matrix3 mat = inode->GetObjectTM(t);
			gw->setTransform(mat);	
	
			float param = shape->FindSegmentPoint(poly, seg, gw, gw->getMaterial(), &hr);
			
			altered = holdNeeded = 1;
			if ( theHold.Holding() ) {
				theHold.Put(new ShapeRestore(shapeData,this,shape));
				}
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			theHold.Accept(GetString(IDS_TH_SEGBREAK));
			BreakSegment(shape, poly, seg, param);
			goto finished;
			}
		}
	finished:
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t, REDRAW_NORMAL);
	}

void EditSplineMod::DoVertConnect(ViewExp *vpt, BezierShape *rshape, int poly1, int vert1, int poly2, int vert2) {
	ModContextList mcList;		
	INodeTab nodes;
	int holdNeeded = 0;
	int altered = 0;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);

	theHold.Begin();

	// Verts may be vectors -- Make sure they indicate knots
	vert1 = (vert1 / 3) * 3 + 1;
	vert2 = (vert2 / 3) * 3 + 1;

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		if(shape == rshape) {
			shapeData->RecordTopologyTags(shape);
			altered = holdNeeded = 1;
			if ( theHold.Holding() ) {
				theHold.Put(new ShapeRestore(shapeData,this,shape));
				}
			ConnectVerts(shape, poly1, vert1, poly2, vert2, TRUE);
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			theHold.Accept(GetString(IDS_TH_VERTCONNECT));
			goto finished;
			}
		}
	finished:
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t, REDRAW_NORMAL);
	}

// Start inserting vertices -- Prep the spline object and start a record of the change.
// Return the index of the vertex where insertion will begin
int EditSplineMod::StartVertInsert(ViewExp *vpt, BezierShape *rshape, int poly, int seg, int vert, EditSplineMod **mod) {
	ModContextList mcList;		
	INodeTab nodes;
	int holdNeeded = 0;
	int altered = 0;
	TimeValue t = ip->GetTime();

	if ( !ip ) return -1;

	ip->GetModContexts(mcList,nodes);

	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		if(shape == rshape) {
			shapeData->RecordTopologyTags(shape);
			altered = holdNeeded = 1;
			if ( theHold.Holding() ) {
				theHold.Put(new ShapeRestore(shapeData,this,shape));
				}
			insertShape = shape;
			// Insert the points into the spline
			Spline3D *spline = shape->splines[poly];			
			insertSpline = spline;
			insertPoly = poly;
			// If inserting at first vertex, reverse the spline and relocate the insertion point!
			if(vert == 1) {
				spline->Reverse();
				shape->vertSel[poly].Reverse();
				shape->segSel[poly].Reverse();
				vert = (spline->KnotCount() - 1) * 3 + 1;
				for (int j = 0; j < shape->bindList.Count();j++)
					{
					if (poly == shape->bindList[j].pointSplineIndex)  
						shape->bindList[j].isEnd = !shape->bindList[j].isEnd;
					if (poly == shape->bindList[j].segSplineIndex)  
						{
						shape->bindList[j].seg = spline->KnotCount() - shape->bindList[j].seg-2;
						}
					}

				}
			else	// If segment, find the insertion vertex
			if(seg >= 0)
				{
				vert = seg * 3 + 1;
				for (int j = 0; j < shape->bindList.Count();j++)
					{
					if (poly == shape->bindList[j].segSplineIndex)  
						{
						if (seg <= shape->bindList[j].seg)
							{
							if (seg == shape->bindList[j].seg)
								{
								shape->bindList[j].seg++;
								}
							else
								{
								shape->bindList[j].seg++;

								}
							}
						}
					}
				}

			insertNode = nodes[i]->GetActualINode();
			insertTM = nodes[i]->GetObjectTM(ip->GetTime());
			insertVert = vert;
			insertShapeData = shapeData;
			*mod = this;
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			nodes.DisposeTemporary();
			return vert;
			}
		}
	nodes.DisposeTemporary();
	return -1;
	}

void EditSplineMod::EndVertInsert() {
	if(!insertShape)
		return;
	// Save the resulting spline to the restore record
	insertShapeData->UpdateChanges(insertShape);
	theHold.Accept(GetString(IDS_TH_VERTINSERT));
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(), REDRAW_NORMAL);
	insertShape->InvalidateGeomCache();
	insertShape = NULL;
	}

void EditSplineMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{		
//Alert(_T("in ModifyObject"));
	assert( os->obj->ClassID() == Class_ID(SPLINESHAPE_CLASS_ID,0) );
//Alert(_T("ModifyObject class ID is OK"));
	
	SplineShape *splShape = (SplineShape *)os->obj;

	if ( !mc.localData )
		mc.localData = new EditSplineData();	// Create it 1st time

	EditSplineData *shapeData = (EditSplineData*)mc.localData;
	shapeData->Apply(t,splShape,selLevel,showVertNumbers,SVNSelectedOnly);
	splShape->shape.InvalidateGeomCache();
	}

void EditSplineMod::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc)
	{
	if ( mc->localData ) {
		EditSplineData *shapeData = (EditSplineData*)mc->localData;
		if ( shapeData ) {
			// The FALSE parameter indicates the the mesh cache itself is
			// invalid in addition to any other caches that depend on the
			// mesh cache.
			shapeData->Invalidate(partID,FALSE);
			}
		}
	}

// Select a subcomponent within our object(s).  WARNING! Because the HitRecord list can
// indicate any of the objects contained within the group of shapes being edited, we need
// to watch for control breaks in the shapeData pointer within the HitRecord!

void EditSplineMod::SelectSubComponent( HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert )
	{
	if ( !ip ) return; 
	ip->ClearCurNamedSelSet();
	TimeValue t = ip->GetTime();
	EndOutlineMove(t);
//watje 
	int i;

	// Keep processing hit records as long as we have them!
	while(hitRec) {	
		EditSplineData *shapeData = (EditSplineData*)hitRec->modContext->localData;
	
		if ( !shapeData )
			return;

		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) return;

		shapeData->BeginEdit(t);

		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}

		switch ( selLevel ) {
			case ES_VERTEX: {
				if ( all ) {
					if ( invert ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto vert_done;
							int poly = ((ShapeHitData *)(hitRec->hitData))->poly;
							int vert = ((ShapeHitData *)(hitRec->hitData))->index;
							if(shape->vertSel[poly][vert])
								shape->vertSel[poly].Clear(vert);
							else
								shape->vertSel[poly].Set(vert);
							hitRec = hitRec->Next();
							}
						}
					else
					if ( selected ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto vert_done;
							shape->vertSel[((ShapeHitData *)(hitRec->hitData))->poly].Set(((ShapeHitData *)(hitRec->hitData))->index);
							hitRec = hitRec->Next();
							}
						}
					else {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto vert_done;
							shape->vertSel[((ShapeHitData *)(hitRec->hitData))->poly].Clear(((ShapeHitData *)(hitRec->hitData))->index);
							hitRec = hitRec->Next();
							}
						}
					}
				else {
					int poly = ((ShapeHitData *)(hitRec->hitData))->poly;
					int vert = ((ShapeHitData *)(hitRec->hitData))->index;
					if ( invert ) {
						if(shape->vertSel[poly][vert])
							shape->vertSel[poly].Clear(vert);
						else
							shape->vertSel[poly].Set(vert);
						}
					else
					if ( selected ) {
						shape->vertSel[poly].Set(vert);
						}
					else {
						shape->vertSel[poly].Clear(vert);
						}
					hitRec = NULL;	// Reset it so we can exit	
					}

//watje
				if (useAreaSelect)
					{
					float dist = areaSelect * areaSelect;

					for (i = 0; i < shape->splineCount; i++)  //wow managed for nested loops that sucks
						{
						for (int j = 0; j < shape->splines[i]->KnotCount(); j++)
							{
							if (shape->vertSel[i][j*3+1])
								{
								Point3 p = shape->splines[i]->GetKnotPoint(j);
								for (int k = 0; k < shape->splineCount; k++)
									{
									for (int m = 0; m < shape->splines[k]->KnotCount(); m++)
										{
										if ((!shape->vertSel[k][m*3+1]) && (LengthSquared(p - shape->splines[k]->GetKnotPoint(m)) < dist))
											shape->vertSel[k].Set(m*3+1);
										}
									}
	
								}

							}

						}


					}

				vert_done:
				break;
				}

			case ES_SEGMENT: {
				if ( all ) {				
					if ( invert ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto seg_done;
							int poly = ((ShapeHitData *)(hitRec->hitData))->poly;
							int seg = ((ShapeHitData *)(hitRec->hitData))->index;
							if(shape->segSel[poly][seg])
								shape->segSel[poly].Clear(seg);
							else
								shape->segSel[poly].Set(seg);
							hitRec = hitRec->Next();
							}
						}
					else
					if ( selected ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto seg_done;
							shape->segSel[((ShapeHitData *)(hitRec->hitData))->poly].Set(((ShapeHitData *)(hitRec->hitData))->index);
							hitRec = hitRec->Next();
							}
						}
					else {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto seg_done;
							shape->segSel[((ShapeHitData *)(hitRec->hitData))->poly].Clear(((ShapeHitData *)(hitRec->hitData))->index);
							hitRec = hitRec->Next();
							}
						}
					}
				else {
					int poly = ((ShapeHitData *)(hitRec->hitData))->poly;
					int seg = ((ShapeHitData *)(hitRec->hitData))->index;
					if ( invert ) {
						if(shape->segSel[poly][seg])
							shape->segSel[poly].Clear(seg);
						else
							shape->segSel[poly].Set(seg);
						}
					else
					if ( selected ) {
						shape->segSel[poly].Set(seg);
						}
					else {
						shape->segSel[poly].Clear(seg);
						}	
					hitRec = NULL;	// Reset it so we can exit	
					}
				seg_done:
				break;
				}

			case ES_SPLINE: {
				if ( all ) {				
					if ( invert ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto poly_done;
							int poly = ((ShapeHitData *)(hitRec->hitData))->poly;
							if(shape->polySel[poly])
								shape->polySel.Clear(poly);
							else
								shape->polySel.Set(poly);
							hitRec = hitRec->Next();
							}
						}
					else
					if ( selected ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto poly_done;
							shape->polySel.Set(((ShapeHitData *)(hitRec->hitData))->poly);
							hitRec = hitRec->Next();
							}
						}
					else {
						while( hitRec ) {
							// If the object changes, we're done!
							if(shapeData != (EditSplineData*)hitRec->modContext->localData)
								goto poly_done;
							shape->polySel.Clear(((ShapeHitData *)(hitRec->hitData))->poly);
							hitRec = hitRec->Next();
							}
						}
					}
				else {
					int poly = ((ShapeHitData *)(hitRec->hitData))->poly;
					if ( invert ) {
						if(shape->polySel[poly])
							shape->polySel.Clear(poly);
						else
							shape->polySel.Set(poly);
						}
					else
					if ( selected ) {
						shape->polySel.Set(poly);
						}
					else {
						shape->polySel.Clear(poly);
						}	
					hitRec = NULL;	// Reset it so we can exit	
					}
				poly_done:
				break;
				}
			case ES_OBJECT:
			default:
				return;
			}
		shapeData->UpdateChanges(shape, FALSE);
		if ( shapeData->tempData ) {
			shapeData->tempData->Invalidate(PART_SELECT);
			}
		}

	SelectionChanged();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void EditSplineMod::ClearSelection(int selLevel) 
	{
	if(selLevel == ES_OBJECT)
		return;

	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	ip->ClearCurNamedSelSet();
	EndOutlineMove(ip->GetTime());
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;		
		BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		if(!shape) continue;

		shapeData->BeginEdit(ip->GetTime());

		switch ( selLevel ) {
			case ES_VERTEX: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->vertSel.ClearAll();
				break;
				}

			case ES_SEGMENT: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->segSel.ClearAll();
				break;
				}

			case ES_SPLINE: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->polySel.ClearAll();
				break;
				}
			}
		shapeData->UpdateChanges(shape, FALSE);
		if ( shapeData->tempData ) {
			shapeData->TempData(this)->Invalidate(PART_SELECT);
			}
		}
	nodes.DisposeTemporary();
	SelectionChanged();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void EditSplineMod::SelectAll(int selLevel) 
	{
	if(selLevel == ES_OBJECT)
		return;

	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	ip->ClearCurNamedSelSet();
	EndOutlineMove(ip->GetTime());
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;		
		BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		if(!shape) continue;
		shapeData->BeginEdit(ip->GetTime());

		switch ( selLevel ) {
			case ES_VERTEX: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->vertSel.SetAll();
				shape->UnselectHiddenVerts();

				break;
				}

			case ES_SEGMENT: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->segSel.SetAll();
				shape->UnselectHiddenSegs();
				break;
				}

			case ES_SPLINE: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->polySel.SetAll();
				shape->UnselectHiddenSplines();
				break;
				}
			}
		shapeData->UpdateChanges(shape, FALSE);
		if ( shapeData->tempData ) {
			shapeData->TempData(this)->Invalidate(PART_SELECT);
			}
		}
	nodes.DisposeTemporary();
	SelectionChanged();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void EditSplineMod::InvertSelection(int selLevel) 
	{
	if(selLevel == ES_OBJECT)
		return;

	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	ip->ClearCurNamedSelSet();
	EndOutlineMove(ip->GetTime());
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;		
		BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		if(!shape) continue;
		shapeData->BeginEdit(ip->GetTime());

		switch ( selLevel ) {
			case ES_VERTEX: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->vertSel.Toggle();
				shape->UnselectHiddenVerts();
				break;
				}

			case ES_SEGMENT: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->segSel.Toggle();
				shape->UnselectHiddenSegs();
				break;
				}

			case ES_SPLINE: {
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->polySel.Toggle();
				shape->UnselectHiddenSplines();
				break;
				}
			}
		shapeData->UpdateChanges(shape, FALSE);
		if ( shapeData->tempData ) {
			shapeData->TempData(this)->Invalidate(PART_SELECT);
			}
		}
	nodes.DisposeTemporary();
	SelectionChanged();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void EditSplineMod::MaybeSelectSingleSpline(BOOL makeUndo) {
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	EndOutlineMove(ip->GetTime());
	
	ip->GetModContexts(mcList,nodes);
	int splines = 0;
	BezierShape *theShape = NULL;
	EditSplineData *theESD = NULL;
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;		
		BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		if(!shape) continue;
		splines += shape->SplineCount();
		if(splines > 1) {
			nodes.DisposeTemporary();
			return;
			}
		if(shape->polySel[0])
			return;
		if(splines) {
			theShape = shape;
			theESD = shapeData;
			}
		}
	if(theShape) {
		theESD->BeginEdit(ip->GetTime());
		if(makeUndo)
			theHold.Begin();
		if ( theHold.Holding() )
			theHold.Put(new ShapeRestore(theESD,this,theShape));
		if(makeUndo)
			theHold.Accept(GetString(IDS_DS_SELECT));
		theShape->polySel.Set(0);
		theESD->UpdateChanges(theShape, FALSE);
		if ( theESD->tempData ) {
			theESD->TempData(this)->Invalidate(PART_SELECT);
			}
		}
	nodes.DisposeTemporary();
	}

BOOL EditSplineMod::AnyPolysSelected() {
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return FALSE;	
	EndOutlineMove(ip->GetTime());
	
	ip->GetModContexts(mcList,nodes);
	int splines = 0;
	BezierShape *theShape = NULL;
	EditSplineData *theESD = NULL;
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;		
		BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		if(!shape) continue;
		if(shape->polySel.sel.NumberSet()) {
			nodes.DisposeTemporary();
			return TRUE;
			}
		}
	nodes.DisposeTemporary();
	return FALSE;
	}

class MinSegLength {
	public:
		BOOL first;
		float length;
		MinSegLength() { first = TRUE; length = 0.0f; }
		void Include(float l);
	};

void MinSegLength::Include(float l) {
	if(first) {
		length = l;
		first = FALSE;
		return;
		}
	if(l < length)
		length = l;
	}

void EditSplineMod::SetFCLimit() {
	MinSegLength min;
	ModContextList mcList;		
	INodeTab nodes;

	if ( !ip ) return;
	TimeValue t = ip->GetTime();
	ip->GetModContexts(mcList,nodes);

	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
				
		shapeData->BeginEdit(t);
		int polys = shape->splineCount;
		for(int poly = 0; poly < shape->splineCount; ++poly) {
			BitArray map = KnotSelFromVertSel(shape->vertSel[poly]);
			if(map.NumberSet()) {
				Spline3D *spline = shape->splines[poly];
				int segs = spline->Segments();
				// Don't fillet or chamfer ends of open spline!
				if(!spline->Closed()) {
					map.Clear(0);
					map.Clear(segs);
					}
				// If any still on, proceed!
				if(map.NumberSet()) {
					for(int i = 0; i < segs; ++i) {
						if(map[i]) {
							int prev = (i + segs - 1) % segs;
							int next = i + 1;
							float lp = spline->SegmentLength(prev);
							float ln = spline->SegmentLength(i);
							min.Include(map[prev] ? lp * 0.495f : lp * 0.99f);
							min.Include(map[next] ? ln * 0.495f : ln * 0.99f);
							}
						}
					}
				}
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	FCLimit = min.length;
//	DebugPrint("Fillet/Chamfer limit:%f\n",min.length);
	}

int EditSplineMod::GetSubobjectLevel()
	{
	return selLevel;
	}

void EditSplineMod::SetSubobjectLevel(int level)
	{
	selLevel = level;
	if(hSelectPanel)
		RefreshSelType();
	// Set up or remove the surface properties rollup if needed
	if (selLevel == ES_SEGMENT || selLevel == ES_SPLINE) {
		if(!hSurfPanel) {
			hSurfPanel = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_EDSPLINE_SURF),
				SplineSurfDlgProc, GetString(IDS_TH_SURFACEPROPERTIES), (LPARAM)this, rsSurf ? 0 : APPENDROLL_CLOSED);
			}
		}
	else {
		if(hSurfPanel) {
			rsSurf = IsRollupPanelOpen (hSurfPanel);
			ip->DeleteRollupPage(hSurfPanel);
			hSurfPanel = NULL;
			}
		}

	if(hSurfPanel)
		InvalidateSurfaceUI();
	// Setup named selection sets	
	SetupNamedSelDropDown();
	}

void EditSplineMod::ActivateSubobjSel(int level, XFormModes& modes )
	{	
	ModContextList mcList;
	INodeTab nodes;
	int old = selLevel;

	if ( !ip ) return;
	ip->GetModContexts(mcList,nodes);

	switch ( level ) {
		case ES_OBJECT:
			// Not imp.
			break;

		case ES_SPLINE:
		case ES_SEGMENT:
		case ES_VERTEX:
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
			break;
		}

	if ( level != old ) {
		SetSubobjectLevel(level);
		// Modify the caches to reflect the new sel level.
		for ( int i = 0; i < mcList.Count(); i++ ) {
			EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
			if ( !shapeData ) continue;		
		
			if ( shapeData->tempData && shapeData->TempData(this)->ShapeCached(ip->GetTime()) ) {
				BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
				if(!shape) continue;
				shape->dispFlags = 0;
				shape->SetDispFlag(shapeLevelDispFlags[selLevel]);
				shape->selLevel = shapeLevel[selLevel];
				}
			}		

		NotifyDependents( FOREVER, 	PART_SUBSEL_TYPE|PART_DISPLAY, 	REFMSG_CHANGE);
		ip->PipeSelLevelChanged();
		// Update selection UI display, named sel
		SelectionChanged();
		}
	nodes.DisposeTemporary();
	}

int EditSplineMod::SubObjectIndex(HitRecord *hitRec)
	{	
	EditSplineData *shapeData = (EditSplineData*)hitRec->modContext->localData;
	if ( !shapeData ) return 0;
	if ( !ip ) return 0;
	TimeValue t = ip->GetTime();
	switch ( selLevel ) {
		case ES_VERTEX:
		case ES_SEGMENT:
			return ((ShapeHitData *)(hitRec->hitData))->index;
		case ES_SPLINE:
			return ((ShapeHitData *)(hitRec->hitData))->poly;

		default:
			return 0;
		}
	}

BOOL EditSplineMod::DependOnTopology(ModContext &mc)
	{
	EditSplineData *shapeData = (EditSplineData*)mc.localData;
	if (shapeData) {
		if (shapeData->GetFlag(ESD_HASDATA)) {
			return TRUE;
			}
		}
	return FALSE;
	}

void EditSplineMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Interval valid;
	if ( mc->localData ) {
		EditSplineData *shapeData = (EditSplineData*)mc->localData;
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) return;

		switch ( selLevel ) {
			case ES_VERTEX: {
				int poly;
				Spline3D *spline;
 				Matrix3 otm = node->GetObjectTM(t,&valid);
				Matrix3 tm = node->GetNodeTM(t,&valid);
				int vbase = 1;
				for(poly = 0; poly < shape->splineCount; ++poly) {
					spline = shape->splines[poly];
					BitArray sel = shape->VertexTempSel(poly);
					for(int i = 1; i < spline->Verts(); i+=3, vbase+=3) {
						// Only display knots' axes
						if(sel[i]) {
							tm.SetTrans(otm * spline->GetVert(i));
							cb->TM(tm, vbase);
							}
						}
					}
				break;
				}
			case ES_SEGMENT: {
				int polys = shape->splineCount;
 				Matrix3 otm = node->GetObjectTM(t,&valid);
				Matrix3 tm = node->GetNodeTM(t,&valid);
				Box3 box;
				for(int poly = 0; poly < polys; ++poly) {
					BitArray sel = shape->VertexTempSel(poly);
					Spline3D *spline = shape->splines[poly];
					for ( int i = 0; i < spline->Verts(); i+=3 ) {
						if ( sel[i] )
							box += spline->GetVert(i);
						}
					}
				tm.SetTrans(otm * box.Center());
				cb->TM(tm, 0);
				break;
				}
			case ES_SPLINE: {
				int polys = shape->splineCount;
 				Matrix3 otm = node->GetObjectTM(t,&valid);
				Matrix3 tm = node->GetNodeTM(t,&valid);
				for(int poly = 0; poly < polys; ++poly) {
					if(shape->polySel[poly]) {
						Box3 box;
						Spline3D *spline = shape->splines[poly];
						for ( int i = 1; i < spline->Verts(); i+=3)
							box += spline->GetVert(i);
						tm.SetTrans(otm * box.Center());
						cb->TM(tm, poly);
						}
					}
				break;
				}
			}
		}
	}

void EditSplineMod::GetSubObjectCenters(
	SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Interval valid;
	Matrix3 tm = node->GetObjectTM(t,&valid);	
	
	assert(ip);
	if ( mc->localData ) {	
		EditSplineData *shapeData = (EditSplineData*)mc->localData;		
		BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		if(!shape) return;

		switch ( selLevel ) {
			case ES_VERTEX: {
				int polys = shape->splineCount;
				Spline3D *spline;
				Box3 box;
				int vbase = 1;
				for(int poly = 0; poly < polys; ++poly) {
					BitArray sel = shape->VertexTempSel(poly);
					spline = shape->splines[poly];
					for ( int i = 1; i < spline->Verts(); i+=3, vbase+=3 ) {
						if ( sel[i] )
							cb->Center(spline->GetVert(i) * tm, vbase);
						}
					}
				break;
				}
			case ES_SEGMENT: { 
				int polys = shape->splineCount;
				Box3 box;
				BOOL bHasSel = FALSE;
				for(int poly = 0; poly < polys; ++poly) {
					BitArray sel = shape->VertexTempSel(poly);
					Spline3D *spline = shape->splines[poly];
					for ( int i = 0; i < spline->Verts(); i++ ) {
						if ( sel[i] && ((i-1)%3) == 0 ) {
							box += spline->GetVert(i) * tm;
							bHasSel = TRUE;
							}

						}
					}
				if (bHasSel)
					cb->Center(box.Center(),0);

				break;
				}
			case ES_SPLINE: {
				int polys = shape->splineCount;
				for(int poly = 0; poly < polys; ++poly) {
					if(shape->polySel[poly]) {
						Box3 box;
						Spline3D *spline = shape->splines[poly];
						for ( int i = 1; i < spline->Verts(); i+=3)
							box += spline->GetVert(i) * tm;
						cb->Center(box.Center(), poly);
						}
					}
				break;
				}
			
			default:
				cb->Center(tm.GetTrans(),0);
				break;
			}		
		}
	}

void EditSplineMod::DeleteShapeDataTempData()
	{
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;		
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;				
		if ( shapeData->tempData ) {
			delete shapeData->tempData;
			}
		shapeData->tempData = NULL;
		}
	nodes.DisposeTemporary();
	}


void EditSplineMod::CreateShapeDataTempData()
	{
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;		
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;				
		if ( !shapeData->tempData ) {
			shapeData->tempData = new ESTempData(this,shapeData);
			}		
		}
	nodes.DisposeTemporary();
	}

//--------------------------------------------------------------
int EditSplineMod::HitTest(TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) 
	{
	Interval valid;
	int savedLimits,res = 0;
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 mat = inode->GetObjectTM(t);
	gw->setTransform(mat);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	
	if ( mc->localData ) {		
		EditSplineData *shapeData = (EditSplineData*)mc->localData;
		BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
		if(!shape) return 0;
		SubShapeHitList hitList;
		ShapeSubHitRec *rec;
		res = shape->SubObjectHitTest( gw, gw->getMaterial(), &hr,
			flags|((splineHitOverride) ? shapeHitLevel[splineHitOverride] : shapeHitLevel[selLevel]), hitList );
	
		rec = hitList.First();
		while( rec ) {
			vpt->LogHit(inode,mc,rec->dist,123456,new ShapeHitData(rec->shape, rec->poly, rec->index));
			rec = rec->Next();
			}
		}

	gw->setRndLimits(savedLimits);	
	return res;
	}

int EditSplineMod::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc) {	
	return 0;	
	}

void EditSplineMod::GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) {
	box.Init();
	}

//---------------------------------------------------------------------
// UI stuff

class ESModContextEnumProc : public ModContextEnumProc {
	float f;
	public:
		ESModContextEnumProc(float f) { this->f = f; }
		BOOL proc(ModContext *mc);  // Return FALSE to stop, TRUE to continue.
	};

BOOL ESModContextEnumProc::proc(ModContext *mc) {
	EditSplineData *shapeData = (EditSplineData*)mc->localData;
	if ( shapeData )		
		shapeData->RescaleWorldUnits(f);
	return TRUE;
	}

// World scaling
void EditSplineMod::RescaleWorldUnits(float f) {
	if (TestAFlag(A_WORK1))
		return;
	SetAFlag(A_WORK1);
	
	// rescale all our references
	for (int i=0; i<NumRefs(); i++) {
		ReferenceMaker *srm = GetReference(i);
		if (srm) 
			srm->RescaleWorldUnits(f);
		}
	
	// Now rescale stuff inside our data structures
	ESModContextEnumProc proc(f);
	EnumModContexts(&proc);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

void EditSplineMod::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
	{
	this->ip = ip;
	CreateShapeDataTempData();

	segUIValid = FALSE;
	EndOutlineMove(ip->GetTime());
	hSelectPanel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDSPLINE_SELECT),
		SplineSelectDlgProc, GetString(IDS_TH_SELECTION), (LPARAM)this, rsSel ? 0 : APPENDROLL_CLOSED);
	hOpsPanel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDSPLINE_OPS),
		SplineOpsDlgProc, GetString (IDS_TH_GEOMETRY), (LPARAM) this, rsOps ? 0 : APPENDROLL_CLOSED);
	if (selLevel == ES_SEGMENT || selLevel == ES_SPLINE) {
		hSurfPanel = ip->AddRollupPage(hInstance, MAKEINTRESOURCE(IDD_EDSPLINE_SURF),
			SplineSurfDlgProc, GetString(IDS_TH_SURFACEPROPERTIES), (LPARAM)this, rsSurf ? 0 : APPENDROLL_CLOSED);
		}
	else 
		hSurfPanel = NULL;
	
	// Create sub object editing modes.
	moveMode        = new MoveModBoxCMode(this,ip);
	rotMode         = new RotateModBoxCMode(this,ip);
	uscaleMode      = new UScaleModBoxCMode(this,ip);
	nuscaleMode     = new NUScaleModBoxCMode(this,ip);
	squashMode      = new SquashModBoxCMode(this,ip);
	selectMode      = new SelectModBoxCMode(this,ip);
	outlineMode     = new OutlineCMode(this,ip);
	filletMode      = new FilletCMode(this,ip);
	chamferMode     = new ESChamferCMode(this,ip);
	segBreakMode    = new SegBreakCMode(this,ip);
	segRefineMode   = new SegRefineCMode(this,ip);
	crossInsertMode = new CrossInsertCMode(this,ip);
	vertConnectMode = new VertConnectCMode(this,ip);
	vertInsertMode  = new VertInsertCMode(this,ip);
	booleanMode     = new BooleanCMode(this,ip);
	trimMode        = new TrimCMode(this,ip);
	extendMode      = new ExtendCMode(this,ip);
	createLineMode  = new CreateLineCMode(this,ip);

//watje
	refineConnectMode   = new RefineConnectCMode(this,ip);
	bindMode   = new BindCMode(this,ip);

	
	// Add our sub object type
	TSTR type1( GetString(IDS_TH_VERTEX) );
	TSTR type2( GetString(IDS_TH_SEGMENT) );
	TSTR type3( GetString(IDS_TH_SPLINE) );
	const TCHAR *ptype[] = { type1, type2, type3 };
	ip->RegisterSubObjectTypes( ptype, 3 );

	// Restore the selection level.
	ip->SetSubObjectLevel(selLevel);
	
	// Disable show end result.
	ip->EnableShowEndResult(FALSE);

	// Setup named selection sets	
	SetupNamedSelDropDown();

	// Update selection UI display
	SelectionChanged();

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);	
	}
		
void EditSplineMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
	{
	EndOutlineMove(ip->GetTime());

	if (hSelectPanel) {
		rsSel = IsRollupPanelOpen (hSelectPanel);
		ip->DeleteRollupPage(hSelectPanel);
		hSelectPanel = NULL;
		}
	if (hOpsPanel) {
		rsOps = IsRollupPanelOpen (hOpsPanel);
		ip->DeleteRollupPage(hOpsPanel);
		hOpsPanel = NULL;
		}
	if (hSurfPanel) {
		rsSurf = IsRollupPanelOpen (hSurfPanel);
		ip->DeleteRollupPage(hSurfPanel);
		hSurfPanel = NULL;
		}

	// Enable show end result
	ip->EnableShowEndResult(TRUE);

	CancelEditSplineModes(ip);

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	ClearAFlag(A_MOD_BEING_EDITED);
	
	DeleteShapeDataTempData();
	this->ip = NULL;
	
	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);
	ip->DeleteMode(selectMode);
	ip->DeleteMode(outlineMode);
	ip->DeleteMode(filletMode);
	ip->DeleteMode(chamferMode);
	ip->DeleteMode(segBreakMode);
	ip->DeleteMode(segRefineMode);
	ip->DeleteMode(crossInsertMode);
	ip->DeleteMode(vertConnectMode);
	ip->DeleteMode(vertInsertMode);
	ip->DeleteMode(booleanMode);
	ip->DeleteMode(trimMode);
	ip->DeleteMode(extendMode);
	ip->DeleteMode(createLineMode);

//	watje
	ip->DeleteMode(refineConnectMode);
	ip->DeleteMode(bindMode);


	if ( moveMode ) delete moveMode;
	moveMode = NULL;
	if ( rotMode ) delete rotMode;
	rotMode = NULL;
	if ( uscaleMode ) delete uscaleMode;
	uscaleMode = NULL;
	if ( nuscaleMode ) delete nuscaleMode;
	nuscaleMode = NULL;
	if ( squashMode ) delete squashMode;
	squashMode = NULL;
	if ( selectMode ) delete selectMode;
	selectMode = NULL;
	if ( outlineMode ) delete outlineMode;
	outlineMode = NULL;
	if ( filletMode ) delete filletMode;
	filletMode = NULL;
	if ( chamferMode ) delete chamferMode;
	chamferMode = NULL;
	if ( segBreakMode ) delete segBreakMode;
	segBreakMode = NULL;
	if ( segRefineMode ) delete segRefineMode;
	segRefineMode = NULL;
	if ( crossInsertMode ) delete crossInsertMode;
	crossInsertMode = NULL;
	if ( vertConnectMode ) delete vertConnectMode;
	vertConnectMode = NULL;
	if ( vertInsertMode ) delete vertInsertMode;
	vertInsertMode = NULL;
	if ( booleanMode ) delete booleanMode;
	booleanMode = NULL;
	if ( trimMode ) delete trimMode;
	trimMode = NULL;
	if ( extendMode ) delete extendMode;
	extendMode = NULL;
	if ( createLineMode ) delete createLineMode;
	createLineMode = NULL;

	//watje
	if ( refineConnectMode ) delete refineConnectMode;
	refineConnectMode = NULL;
	if ( bindMode ) delete bindMode;
	bindMode = NULL;

	}

// Vertex Break modifier method
void EditSplineMod::DoVertBreak() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->vertSel[poly].NumberSet()) {
				altered = holdNeeded = 1;
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				// Call the spline break function
				BreakSplineAtSelVerts(shape, poly);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_VERTBREAK));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

static BOOL NeedsWeld(Spline3D *spline, BitArray sel, float thresh) {
	int knots = spline->KnotCount();
	for(int i = 0; i < knots; ++i) {
		if(sel[i*3+1]) {
			int next = (i + 1) % knots;
			if(sel[next*3+1] && Length(spline->GetKnotPoint(i) - spline->GetKnotPoint(next)) <= thresh)
				return TRUE;
			}
		}
	return FALSE;
	}


//watje
class WeldList
{
public:
	int splineID, knotID;
	Point3 p;
	int used;
};


// Vertex Weld modifier method
void EditSplineMod::DoVertWeld() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	int oldVerts = 0;
	int newVerts = 0;

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// Add the original number of knots to the oldVerts field
		for(int poly = 0; poly < shape->splineCount; ++poly)
			oldVerts += shape->splines[poly]->KnotCount();

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

//watje now move any verts thta are within the weld tolerance onto each other
//build list 
/*
		Tab<WeldList> weldList;
		for(poly = 0; poly < shape->splineCount; ++poly)
			{
			BitArray pSel = shape->VertexTempSel(poly);
			for (int i = 0; i < pSel.GetSize()/3; i++)
				{
				if(pSel[(i*3)+1]) 
					{
					WeldList w;
					w.used = -1;
					w.splineID =poly;
					w.knotID = i;
					w.p = shape->splines[poly]->GetKnotPoint(i);
					weldList.Append(1,&w,1);
					}
				}
			}
		int ct = 0;
		float threshSquared = weldThreshold * weldThreshold;
		for (int wc = 0; wc < weldList.Count(); wc++)
			{
			Point3 p = weldList[wc].p;
			BOOL found = FALSE;
			for (int wc2 = (wc+1); wc2 < weldList.Count(); wc2++)
				{
				Point3 t;
				t = weldList[wc2].p;
				if ((weldList[wc2].used == -1) && (LengthSquared(p-t) <= threshSquared))
					{
					found = TRUE;
					weldList[wc].used = ct;
					weldList[wc2].used = ct;
					}
				}
			if (found) ct++;
			}
		if (ct >0)
			{
			altered = holdNeeded = TRUE;
			for (int i = 0; i < ct; i++)
				{
				Point3 avgPoint(0.0f,0.0f,0.0f);
				int pointCount = 0;
				for (int j = 0; j < weldList.Count(); j++)
					{
					if (i == weldList[j].used)
						{
						avgPoint += weldList[j].p;
						pointCount++;
						}
					}
				avgPoint = avgPoint/(float)pointCount;
				for (j = 0; j < weldList.Count(); j++)
					{
					if (i == weldList[j].used)
						{
						weldList[j].p = avgPoint;
						}
					}

				}
//now put them back in the knot list
			for (i = 0; i < weldList.Count(); i++)
				{
				int polyID = weldList[i].splineID;
				int knotID = weldList[i].knotID;

				shape->splines[polyID]->SetKnotPoint(knotID,weldList[i].p);
				shape->splines[polyID]->ComputeBezPoints();

				}
			shape->InvalidateGeomCache();

			}
*/
		// Poly-to-poly weld loops back here because a weld between polys creates one
		// polygon which may need its two new endpoints welded
		changed:
		int polys = shape->splineCount;
		for(poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->vertSel[poly].NumberSet()) {
				hadSelected = TRUE;
				if(NeedsWeld(spline, shape->vertSel[poly], weldThreshold)) {
					altered = holdNeeded = TRUE;
					if ( theHold.Holding() ) {
						theHold.Put(new ShapeRestore(shapeData,this,shape));
						}
					// Call the weld function
					WeldSplineAtSelVerts(shape, poly, weldThreshold);
					}
				}
			}

		// Now check for welds with other polys (endpoints only)
		polys = shape->SplineCount();
		for(int poly1 = 0; poly1 < polys; ++poly1) {
			Spline3D *spline1 = shape->splines[poly1];
			if(!spline1->Closed()) {
				int knots1 = spline1->KnotCount();
				int lastKnot1 = knots1-1;
				int lastSel1 = lastKnot1 * 3 + 1;
				BitArray pSel = shape->VertexTempSel(poly1);
				if(pSel[1] || pSel[lastSel1]) {
					Point3 p1 = spline1->GetKnotPoint(0);
					Point3 p2 = spline1->GetKnotPoint(lastKnot1);
					for(int poly2 = 0; poly2 < polys; ++poly2) {
						Spline3D *spline2 = shape->splines[poly2];
						if(poly1 != poly2 && !spline2->Closed()) {
							int knots2 = spline2->KnotCount();
							int lastKnot2 = knots2-1;
							int lastSel2 = lastKnot2 * 3 + 1;
							Point3 p3 = spline2->GetKnotPoint(0);
							Point3 p4 = spline2->GetKnotPoint(lastKnot2);
							BitArray pSel2 = shape->VertexTempSel(poly2);
							int vert1, vert2;
							if(pSel[1]) {
								if(pSel2[1] && Length(p3 - p1) <= weldThreshold) {
									vert1 = 0;
									vert2 = 0;

									attach_it:
									// Start a restore object...
									if ( theHold.Holding() )
										theHold.Put(new ShapeRestore(shapeData,this,shape));
									// Do the attach
									DoPolyEndAttach(shape, poly1, vert1, poly2, vert2);
									shapeData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);
									altered = holdNeeded = TRUE;
									goto changed;
									}
								else
								if(pSel2[lastSel2] && Length(p4 - p1) <= weldThreshold) {
									vert1 = 0;
									vert2 = knots2-1;
									goto attach_it;
									}
								}
							if(pSel[lastSel1]) {
								if(pSel2[1] && Length(p3 - p2) <= weldThreshold) {
									vert1 = knots1-1;
									vert2 = 0;
									goto attach_it;
									}
								else
								if(pSel2[lastSel2] && Length(p4 - p2) <= weldThreshold) {
									vert1 = knots1-1;
									vert2 = knots2-1;
									goto attach_it;
									}
								}
							}
						}
					}
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}

		// Add the original number of knots to the oldVerts field
		for(poly = 0; poly < shape->splineCount; ++poly)
			newVerts += shape->splines[poly]->KnotCount();

		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		theHold.Accept(GetString(IDS_TH_VERTWELD));
		TSTR s1;
		int welded = oldVerts - newVerts;
		s1.printf(GetString(IDS_TH_VERTWELDRESULT), welded, oldVerts);
		ip->DisplayTempPrompt(s1,PROMPT_TIME);
		}
	else {
		TSTR s1;
		if(!hadSelected)
			s1 = TSTR( GetString(IDS_TH_NOVALIDVERTSSEL) );
		else
			s1 = TSTR( GetString(IDS_TH_NOWELDPERFORMED) );
		ip->DisplayTempPrompt(s1,PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

// Make First modifier method
void EditSplineMod::DoMakeFirst() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			int knots = spline->KnotCount();
			// If one bits is set in the selection set, let's DO IT!!
			BitArray &vsel = shape->vertSel[poly];
			if(vsel.NumberSet() == 1) {
				if(spline->Closed()) {
					for(int i = 0; i < knots; ++i) {
						if(vsel[i*3+1])
							break;
						}
					if ( theHold.Holding() ) {
						theHold.Put(new ShapeRestore(shapeData,this,shape));
						}
					shape->MakeFirst(poly, i);
					altered = holdNeeded = TRUE;
					}
				else
				if(vsel[(knots-1)*3+1]) {	// Last vertex?
					if ( theHold.Holding() ) {
						theHold.Put(new ShapeRestore(shapeData,this,shape));
						}
					shape->Reverse(poly);
					altered = holdNeeded = TRUE;
					}
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_MAKEFIRST));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

// Vertex Delete modifier method
void EditSplineMod::DoVertDelete() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->vertSel[poly].NumberSet()) {
				altered = holdNeeded = 1;
				if ( theHold.Holding() )
					theHold.Put(new ShapeRestore(shapeData,this,shape));
				// Call the vertex delete function
				DeleteSelVerts(shape, poly);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_VERTDELETE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}


// Segment Delete modifier method
void EditSplineMod::DoSegDelete() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->segSel[poly].NumberSet()) {
				altered = holdNeeded = 1;
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				// Call the segment delete function
				DeleteSelSegs(shape, poly);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_SEGDELETE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSEGSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

// Segment Detach modifier method
void EditSplineMod::DoSegDetach(int sameShape, int copy, int reorient) {
	int holdNeeded = 0;
	int dialoged = 0;
	TSTR newName(GetString(IDS_TH_SHAPE));
	int retain = 1;
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	if(nodes.Count() > 1 && sameShape) {
		ip->DisplayTempPrompt(GetString(IDS_TH_MULTIPLE_NODES),PROMPT_TIME);
		nodes.DisposeTemporary();
		return;
		}
	
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();

	// Create a spline shape object
	SplineShape *splShape = NULL;
	BezierShape *outShape = NULL;
	
	if(!sameShape) {
		splShape = new SplineShape;
		outShape = &splShape->shape;
		}	

	int multipleObjects = (mcList.Count() > 1) ? 1 : 0;
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		if(!outShape)
			outShape = shape;
		
		int detachType;
		if(sameShape) {
			if(copy)
				detachType = SDT_COPY_SAME;
			else
				detachType = SDT_DETACH_SAME;
			}
		else {
			if(copy)
				detachType = SDT_COPY;
			else
				detachType = SDT_DETACH;
			}

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
//watje 5-26-99
		outShape->bindList = shape->bindList;

		for(int poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			int segsSelected = shape->segSel[poly].NumberSet();
			if(segsSelected) {
				if(!dialoged && !sameShape) {
					dialoged = 1;
					if(!GetDetachOptions(ip, newName))
						goto bail_out;
					}
				altered = holdNeeded = 1;
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				HandleSegDetach(shape, outShape, detachType, poly);
				}
			}

//watje 5-26-99
		shape->UpdateBindList();

		bail_out:
		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		if(!sameShape) {
			ObjectState os =
				nodes[0]->GetObjectRef()->Eval(t);
			GeomObject *object = (GeomObject *)os.obj;
			if(object->IsShapeObject()) {
				// Set base parameters in new shape
				splShape->CopyBaseData(*((ShapeObject *)object));
				// And optimize/adaptive
				if(object->IsSubClassOf(splineShapeClassID)) {
					SplineShape *ss = (SplineShape *)object;
					splShape->shape.optimize = ss->shape.optimize;
					splShape->steps = ss->steps;
					splShape->shape.steps = ss->shape.steps;
					}
				}
//watje 5-26-99
			splShape->shape.UpdateBindList();

			INode *newNode = ip->CreateObjectNode(splShape);
			newNode->SetName(newName.data());
			if(!multipleObjects) {	// Single input object?
				if(!reorient) {
					Matrix3 tm = nodes[0]->GetObjectTM(t);
					newNode->SetNodeTM(t, tm);	// Use this object's TM.
					}
				}
			else {
				if(!reorient) {
					Matrix3 matrix;
					matrix.IdentityMatrix();
					newNode->SetNodeTM(t, matrix);	// Use identity TM
					}
				}
			newNode->FlagForeground(t);		// WORKAROUND!
			}
//		outShape->UpdateSels();	// Make sure it readies the selection set info
//watje 5-26-99
		outShape->UpdateBindList();
		outShape->InvalidateGeomCache();
		theHold.Accept(GetString(IDS_TH_SEGDETACH));
		}
	else {
		if(splShape)
			delete splShape;	// Didn't need it after all!
		if(!dialoged)
			ip->DisplayTempPrompt(GetString(IDS_TH_NOSEGSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t, REDRAW_NORMAL);
	}

// Close all selected polygons (that aren't already closed)
void EditSplineMod::DoPolyClose() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	MaybeSelectSingleSpline();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			if(shape->polySel[poly]) {
				Spline3D *spline = shape->splines[poly];
				if(!spline->Closed() && spline->KnotCount()>2) {
					altered = holdNeeded = 1;
					// Save the unmodified verts.
					if ( theHold.Holding() ) {
						theHold.Put(new ShapeRestore(shapeData,this,shape));
						}
					spline->SetClosed();
					shape->vertSel[poly].SetSize(spline->Verts(),1);
					shape->segSel[poly].SetSize(spline->Segments(),1);
					shape->segSel[poly].Clear(spline->Segments()-1);
					spline->ComputeBezPoints();
					shape->UpdateBindList();
					shape->InvalidateGeomCache();
					}
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_CLOSESPLINE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

// Detach all selected polygons
void EditSplineMod::DoPolyDetach(int copy, int reorient) {
	int dialoged = 0;
	TSTR newName(GetString(IDS_TH_SHAPE));
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	MaybeSelectSingleSpline();

	// Create a spline shape object
	SplineShape *splShape = new SplineShape;

	BOOL setSegs = FALSE;
	 
	int multipleObjects = (mcList.Count() > 1) ? 1 : 0;
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys-1; poly >= 0; --poly) {
			if(shape->polySel[poly]) {
				Spline3D *spline = shape->splines[poly];
				if(!dialoged) {
					dialoged = 1;
					if(!GetDetachOptions(ip, newName))
						goto bail_out;
					}
				altered = holdNeeded = 1;
				// Save the unmodified verts.
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				// If haven't set destination segments, do it now
				if(!setSegs) {
					setSegs = TRUE;
					splShape->shape.steps = shape->steps;
					splShape->shape.optimize = shape->optimize;
					}
				// Copy selected polys to a new output object
				Spline3D *newSpline = splShape->shape.NewSpline();
				*newSpline = *spline;
				if(multipleObjects && !reorient)
					newSpline->Transform(&nodes[i]->GetObjectTM(t));
				if(!copy)
					shape->DeleteSpline(poly);
				}
			}

		bail_out:
//watje 5-26-99
		splShape->shape.bindList = shape->bindList;
		shape->UpdateBindList();

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ObjectState os =
			nodes[0]->GetObjectRef()->Eval(t);
		GeomObject *object = (GeomObject *)os.obj;
		if(object->IsShapeObject()) {
			// Set base parameters in new shape
			splShape->CopyBaseData(*((ShapeObject *)object));
			// And optimize/adaptive
			if(object->IsSubClassOf(splineShapeClassID)) {
				SplineShape *ss = (SplineShape *)object;
				splShape->shape.optimize = ss->shape.optimize;
				splShape->steps = ss->steps;
				splShape->shape.steps = ss->shape.steps;
				}
			}
		INode *newNode = ip->CreateObjectNode(splShape);
		newNode->SetName(newName.data());
//watje 5-26-99
		splShape->shape.UpdateBindList();

		splShape->shape.UpdateSels();	// Make sure it readies the selection set info
		splShape->shape.InvalidateGeomCache();
		if(!multipleObjects) {	// Single input object?
			if(!reorient) {
				Matrix3 tm = nodes[0]->GetObjectTM(t);
				newNode->SetNodeTM(t, tm);	// Use this object's TM.
				}
			}
		else {
			if(!reorient) {
				Matrix3 matrix;
				matrix.IdentityMatrix();
				newNode->SetNodeTM(t, matrix);	// Use identity TM
				}
			}
		newNode->FlagForeground(t);		// WORKAROUND!
		theHold.Accept(GetString(IDS_TH_DETACHSPLINE));
		}
	else {
		delete splShape;	// Didn't need it after all!
		if(!dialoged)
			ip->DisplayTempPrompt(GetString(IDS_TH_NOSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t,REDRAW_NORMAL);
	}

// Mirror all selected polygons
void EditSplineMod::DoPolyMirror(int type, int copy, BOOL aboutPivot) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	MaybeSelectSingleSpline();

	for (int i = 0; i < mcList.Count(); i++ ) {
		Point3 pivot = nodes[i]->GetObjOffsetPos();
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);
//to handle copying bound vert list watje 4-27-99
		Tab<int> oldSplines;
		Tab<int> newSplines;

		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			if(shape->polySel[poly]) {
//to handle copying bound vert list watje 4-27-99
				if (copy)
					{
					oldSplines.Append(1,&poly,1);
					int nsp = shape->SplineCount();
					newSplines.Append(1,&nsp,1);
					}
				Spline3D *spline = shape->splines[poly];
				altered = holdNeeded = 1;
				// Save the unmodified verts.
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				MirrorPoly(shape, poly, type, copy, mirrorAboutPivot ? &pivot : NULL);
				}
			}

		if(altered) {
//to handle copying bound vert list 4-27-99
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			if (copy)
				{
				for (int m = 0; m < shape->bindList.Count(); m++)
					{
					BOOL foundSeg=FALSE, foundSpline=FALSE;
					for (int j = 0; j < oldSplines.Count(); j++)
						{
						if (oldSplines[j] == shape->bindList[m].pointSplineIndex)
							{
							for (int k = 0; k < oldSplines.Count(); k++)
								{
								if (oldSplines[k] == shape->bindList[m].segSplineIndex)
//match found add to bindlist
									{
									bindShape temp;
									temp = shape->bindList[m];
									temp.segSplineIndex = newSplines[k];
									temp.pointSplineIndex = newSplines[j];
									shape->bindList.Append(1,&temp,1);
									}
								}
							}
						}
					}
				}
			for (int m = 0; m < shape->bindList.Count(); m++)
				{
				int index = 0;
				int spindex = shape->bindList[m].pointSplineIndex;
				Point3 p;
				if (shape->bindList[m].isEnd)
					index = shape->splines[spindex]->KnotCount()-1;
				shape->bindList[m].bindPoint = shape->splines[spindex]->GetKnot(index).Knot();
				shape->bindList[m].segPoint = shape->splines[spindex]->GetKnot(index).Knot();
				}
//			shape->UpdateBindList();


			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		theHold.Accept(GetString(IDS_TH_MIRROR));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t,REDRAW_NORMAL);
	}

// Delete all selected polygons
void EditSplineMod::DoPolyDelete() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();

	MaybeSelectSingleSpline();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys-1; poly >= 0; --poly) {
			if(shape->polySel[poly]) {
				Spline3D *spline = shape->splines[poly];
				altered = holdNeeded = 1;
				// Save the unmodified verts.
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				shape->DeleteSpline(poly);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_DELETESPLINE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

int EditSplineMod::GetBoolCursorID() {
	switch(boolType) {
		case BOOL_UNION:
			return IDC_BOOLUNION;
		case BOOL_SUBTRACTION:
			return IDC_BOOLSUBTRACTION;
		case BOOL_INTERSECTION:
			return IDC_BOOLINTERSECTION;
		}
	assert(0);
	return IDC_BOOLUNION;
	}

int EditSplineMod::GetBoolMirrString(int type) {
	switch(type) {
		case BOOL_UNION:
			return IDS_TH_UNION;
		case BOOL_SUBTRACTION:
			return IDS_TH_SUBTRACTION;
		case BOOL_INTERSECTION:
			return IDS_TH_INTERSECTION;
		case MIRROR_HORIZONTAL:
			return IDS_TH_MIRROR_H;
		case MIRROR_VERTICAL:
			return IDS_TH_MIRROR_V;
		case MIRROR_BOTH:
			return IDS_TH_MIRROR_BOTH;
		}
	assert(0);
	return IDC_BOOLUNION;
	}

#define IndexIsHandle(ix) (((ix) % 3) == 1 ? FALSE : TRUE)

int EditSplineMod::RememberVertThere(HWND hWnd, IPoint2 m) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	// Initialize so there isn't any remembered shape
	rememberedShape = NULL;

	if ( !ip ) return 0;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	// See if we're over a vertex
	ViewExp *vpt = ip->GetViewport(hWnd);
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr, HITTYPE_POINT, 1, 4, &m);
	gw->setHitRegion(&hr);
	SubShapeHitList hitList;

	int result = 0;

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		INode *inode = nodes[i];
		Matrix3 mat = inode->GetObjectTM(t);
		gw->setTransform(mat);	
		shape->SubObjectHitTest(gw, gw->getMaterial(), &hr, SUBHIT_SHAPE_VERTS/* | HIT_ABORTONHIT*/, hitList );
		ShapeSubHitRec *hit = hitList.First();
		if(hit) {
			result = 1;
			// Go thru the list and see if we have one that's selected
			// If more than one selected and they're different types, set unknown type
			hit = hitList.First();
			while(hit) {
				if(shape->vertSel[hit->poly][hit->index]) {
					if(shape->SelVertsSameType()) {
						rememberedShape = NULL;
						rememberedData = shape->splines[hit->poly]->GetKnotType(hit->index / 3);
						goto finish;
						}
					// Selected verts not all the same type!
					rememberedShape = NULL;
					rememberedData = -1;	// Not all the same!
					goto finish;
					}
				hit = hit->Next();
				}
			hit = hitList.First();
			if(IndexIsHandle(hit->index)) {
				result = 0;
				goto finish;
				}
			if(ip->SelectionFrozen())
				goto finish;
			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new ShapeRestore(shapeData,this,shape));
			theHold.Accept(GetString(IDS_DS_SELECT));
			// Select just this vertex
			shape->vertSel.ClearAll();
			shape->vertSel[hit->poly].Set(hit->index);
			shapeData->UpdateChanges(shape, FALSE);
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

			rememberedShape = shape;
			rememberedPoly = hit->poly;
			rememberedIndex = hit->index / 3;	// Convert from bezier index to knot
			rememberedData = shape->splines[hit->poly]->GetKnotType(rememberedIndex);
			SelectionChanged();
			goto finish;
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
finish:
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	if ( vpt ) ip->ReleaseViewport(vpt);
	nodes.DisposeTemporary();

	return result;
	}

void EditSplineMod::ChangeSelVerts(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->vertSel[poly].NumberSet()) {
				altered = holdNeeded = TRUE;
				if ( theHold.Holding() )
					theHold.Put(new ShapeRestore(shapeData,this,shape));
				// Call the vertex type change function
				ChangeVertexType(shape, poly, -1, type);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape, FALSE);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_VERTCHANGE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditSplineMod::ChangeRememberedVert(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		if(shape == rememberedShape) {
			// If this is the first edit, then the delta arrays will be allocated
			shapeData->BeginEdit(t);

			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new ShapeRestore(shapeData,this,shape));
			// Call the vertex type change function
			ChangeVertexType(shape, rememberedPoly, rememberedIndex, type);
			shapeData->UpdateChanges(shape, FALSE);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			theHold.Accept(GetString(IDS_TH_VERTCHANGE));
			ClearShapeDataFlag(mcList,ESD_BEENDONE);
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
			return;
 			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	}

void EditSplineMod::SetRememberedVertType(int type) {
	if(rememberedShape)
		ChangeRememberedVert(type);
	else
		ChangeSelVerts(type);
	}


int EditSplineMod::RememberSegThere(HWND hWnd, IPoint2 m) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	// Initialize so there isn't any remembered shape
	rememberedShape = NULL;

	if ( !ip ) return 0;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	// Okay, nothing is selected -- See if we're over a segment
	ViewExp *vpt = ip->GetViewport(hWnd);
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr, HITTYPE_POINT, 1, 4, &m);
	gw->setHitRegion(&hr);
	SubShapeHitList hitList;

	int result = 0;

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		INode *inode = nodes[i];
		Matrix3 mat = inode->GetObjectTM(t);
		gw->setTransform(mat);	
		shape->SubObjectHitTest(gw, gw->getMaterial(), &hr, SUBHIT_SHAPE_SEGMENTS /*| HIT_ABORTONHIT*/, hitList );
		ShapeSubHitRec *hit = hitList.First();
		if(hit) {
			result = 1;
			// Go thru the list and see if we have one that's selected
			// If more than one selected and they're different types, set unknown type
			hit = hitList.First();
			while(hit) {
				if(shape->segSel[hit->poly][hit->index]) {
					if(shape->SelSegsSameType()) {
						rememberedShape = NULL;
						rememberedData = shape->splines[hit->poly]->GetLineType(hit->index);
						goto finish;
						}
					// Selected segs not all the same type!
					rememberedShape = NULL;
					rememberedData = -1;	// Not all the same!
					goto finish;
					}
				hit = hit->Next();
				}
			if(ip->SelectionFrozen())
				goto finish;
			hit = hitList.First();
			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new ShapeRestore(shapeData,this,shape));
			theHold.Accept(GetString(IDS_DS_SELECT));
			// Select just this segment
			shape->segSel.ClearAll();
			shape->segSel[hit->poly].Set(hit->index);
			shapeData->UpdateChanges(shape, FALSE);
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

			rememberedShape = shape;
			rememberedPoly = hit->poly;
			rememberedIndex = hit->index;
			rememberedData = shape->splines[rememberedPoly]->GetLineType(rememberedIndex);
			SelectionChanged();
			goto finish;
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}

finish:
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	if ( vpt ) ip->ReleaseViewport(vpt);
	nodes.DisposeTemporary();
	return result;
	}

void EditSplineMod::ChangeSelSegs(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->segSel[poly].NumberSet()) {
				altered = holdNeeded = TRUE;
				if ( theHold.Holding() )
					theHold.Put(new ShapeRestore(shapeData,this,shape));
				// Call the segment type change function
				ChangeSegmentType(shape, poly, -1, type);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape, FALSE);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_SEGCHANGE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSEGSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditSplineMod::ChangeRememberedSeg(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		if(shape == rememberedShape) {
			// If this is the first edit, then the delta arrays will be allocated
			shapeData->BeginEdit(t);

			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new ShapeRestore(shapeData,this,shape));
			// Call the segment type change function
			ChangeSegmentType(shape, rememberedPoly, rememberedIndex, type);
			shapeData->UpdateChanges(shape, FALSE);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			theHold.Accept(GetString(IDS_TH_SEGCHANGE));
			ClearShapeDataFlag(mcList,ESD_BEENDONE);
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
			nodes.DisposeTemporary();
			return;
 			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	nodes.DisposeTemporary();
	}

void EditSplineMod::SetRememberedSegType(int type) {
	if(rememberedShape)
		ChangeRememberedSeg(type);
	else
		ChangeSelSegs(type);
	}

int EditSplineMod::RememberPolyThere(HWND hWnd, IPoint2 m) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	// Initialize so there isn't any remembered shape
	rememberedShape = NULL;

	if ( !ip ) return 0;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	// Okay, nothing is selected -- See if we're over a polygon
	ViewExp *vpt = ip->GetViewport(hWnd);
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr, HITTYPE_POINT, 1, 4, &m);
	gw->setHitRegion(&hr);
	SubShapeHitList hitList;

	int result = 0;

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		INode *inode = nodes[i];
		Matrix3 mat = inode->GetObjectTM(t);
		gw->setTransform(mat);	
		shape->SubObjectHitTest(gw, gw->getMaterial(), &hr, SUBHIT_SHAPE_POLYS /*| HIT_ABORTONHIT*/, hitList );
		ShapeSubHitRec *hit = hitList.First();
		if(hit) {
			result = 1;
			while(hit) {
				if(shape->polySel[hit->poly]) {
					if(shape->SelSplinesSameType()) {
						rememberedShape = NULL;
						rememberedData = shape->splines[hit->poly]->GetLineType(0);
						rememberedPoly = hit->poly;
						goto finish;
						}
					// Selected segs not all the same type!
					rememberedShape = NULL;
					rememberedData = -1;	// Not all the same!
					rememberedPoly = hit->poly;
					goto finish;
					}
				hit = hit->Next();
				}
			if(ip->SelectionFrozen())
				goto finish;
			hit = hitList.First();
			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new ShapeRestore(shapeData,this,shape));
			// Select just this poly
			shape->polySel.ClearAll();
			shape->polySel.Set(hit->poly);
			theHold.Accept(GetString(IDS_DS_SELECT));
			shapeData->UpdateChanges(shape, FALSE);
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

			rememberedShape = shape;
			if(shape->SelSplinesSameType())
				rememberedData = shape->splines[hit->poly]->GetLineType(0);
			else
				rememberedData = -1;
			rememberedPoly = hit->poly;
			SelectionChanged();
			goto finish;
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}

finish:
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	if ( vpt ) ip->ReleaseViewport(vpt);
	nodes.DisposeTemporary();
	return result;
	}

void EditSplineMod::ChangeSelPolys(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = polys - 1; poly >= 0; --poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->polySel[poly]) {
				altered = holdNeeded = TRUE;
				if ( theHold.Holding() )
					theHold.Put(new ShapeRestore(shapeData,this,shape));
				// Call the polygon type change function
				ChangePolyType(shape, poly, type);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape, FALSE);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_SPLINECHANGE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditSplineMod::ChangeRememberedPoly(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		if(shape == rememberedShape) {
			// If this is the first edit, then the delta arrays will be allocated
			shapeData->BeginEdit(t);

			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new ShapeRestore(shapeData,this,shape));
			// Call the segment type change function
			ChangePolyType(shape, rememberedPoly, type);
			shapeData->UpdateChanges(shape, FALSE);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			theHold.Accept(GetString(IDS_TH_SPLINECHANGE));
			ClearShapeDataFlag(mcList,ESD_BEENDONE);
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
			nodes.DisposeTemporary();
			return;
 			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	}

void EditSplineMod::SetRememberedPolyType(int type) {
	if(rememberedShape)
		ChangeRememberedPoly(type);
	else
		ChangeSelPolys(type);
	}

static int butIDs[] = { 0, ES_VERTEX, ES_SEGMENT, ES_SPLINE };

void EditSplineMod::RefreshSelType () {
	ICustToolbar *iToolbar = GetICustToolbar(GetDlgItem(hSelectPanel,IDC_SELTYPE));
	ICustButton *but;
	for (int i=1; i<4; i++) {
		but = iToolbar->GetICustButton (butIDs[i]);
		but->SetCheck (GetSubobjectLevel()==i);
		ReleaseICustButton (but);
	}
	ReleaseICustToolbar(iToolbar);
	SetSelDlgEnables();
	SetOpsDlgEnables();
	SetSurfDlgEnables();
	SelectionChanged();
}

void EditSplineMod::UpdateSelectDisplay() {	
	TSTR buf;
	int num, j;

	if (!hSelectPanel) return;

	ModContextList mcList;
	INodeTab nodes;
	if ( !ip )
		return;
	ip->GetModContexts(mcList,nodes);

	switch (GetSubobjectLevel()) {
		case ES_OBJECT:
			buf.printf (GetString (IDS_TH_OBJECT_SEL));
			break;

		case ES_VERTEX: {
			num = 0;
			int thePoly = 0;
			BezierShape *theShape = NULL;
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
				if ( !shapeData ) continue;		
			
				if ( shapeData->tempData && shapeData->TempData(this)->ShapeCached(ip->GetTime()) ) {
					BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
					if(!shape) continue;
					int polys = shape->splineCount;
//watje
					if (showSelected) 
						{
						shape->dispFlags |= DISP_SELSEGMENTS;
						}
					else
						{
						shape->dispFlags &= ~DISP_SELSEGMENTS;
						}

					for(int poly = 0; poly < polys; ++poly) {
						if(shape->splines[poly]->KnotCount() > 0) {
							int thisNum = 0;
							for (j=1; j<shape->vertSel.sel[poly].GetSize(); j+=3) {
								if (shape->vertSel.sel[poly][j])
									thisNum++;
								}
							if(thisNum) {
								num += thisNum;
								thePoly = poly;
								theShape = shape;
								}
							}
						}
					}
				}
			if (num==1) {
				for (j=1; j<theShape->vertSel.sel[thePoly].GetSize(); j+=3)
					if (theShape->vertSel.sel[thePoly][j]) break;
				buf.printf (GetString(IDS_TH_SPLVERTSEL), thePoly+1, (j-1)/3+1);
				}
			else
				buf.printf (GetString(IDS_TH_NUMVERTSELP), num);
			}
			break;

		case ES_SEGMENT: {
			num = 0;
			int thePoly = 0;
			BezierShape *theShape = NULL;
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
				if ( !shapeData ) continue;		
			
				if ( shapeData->tempData && shapeData->TempData(this)->ShapeCached(ip->GetTime()) ) {
					BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
					if(!shape) continue;
					int polys = shape->splineCount;
					for(int poly = 0; poly < polys; ++poly) {
						if(shape->splines[poly]->KnotCount() > 0) {
							int thisNum = shape->segSel.sel[poly].NumberSet();
							if(thisNum) {
								num += thisNum;
								thePoly = poly;
								theShape = shape;
								}
							}
						}
					}
				}
			if (num==1) {
				for (j=0; j<theShape->segSel.sel[thePoly].GetSize(); j++)
					if (theShape->segSel.sel[thePoly][j]) break;
				buf.printf (GetString(IDS_TH_SPLSEGSEL), thePoly+1, j+1);
				}
			else
				buf.printf (GetString(IDS_TH_NUMSEGSELP), num);
			}
			break;

		case ES_SPLINE: {
			int num = 0;
			int thePoly = 0;
			BezierShape *theShape = NULL;
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
				if ( !shapeData ) continue;		
			
				if ( shapeData->tempData && shapeData->TempData(this)->ShapeCached(ip->GetTime()) ) {
					BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
					if(!shape) continue;
					int polys = shape->splineCount;
					if(polys) {
						int thisNum = shape->polySel.sel.NumberSet();
						if(thisNum) {
							num += thisNum;
							theShape = shape;
							}
						}
					}
				}
			if (num==1) {
				for (j=0; j<theShape->splineCount; j++)
					if (theShape->polySel[j]) break;
				TSTR oc = theShape->splines[j]->Closed() ? GetString(IDS_TH_CLOSED) : GetString(IDS_TH_OPEN);
				buf.printf (GetString(IDS_TH_NUMSPLINESEL), j+1, oc);
				}	
			else
				buf.printf(GetString(IDS_TH_NUMSPLINESELP),num);
			}
			break;
		}

	SetDlgItemText(hSelectPanel, IDC_NUMSEL_LABEL, buf);

	TSTR string;
	if(GetSubobjectLevel() == ES_SPLINE) {
		int vertCount = 0;
		for ( int i = 0; i < mcList.Count(); i++ ) {
			EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
			if ( !shapeData ) continue;		
		
			if ( shapeData->tempData && shapeData->TempData(this)->ShapeCached(ip->GetTime()) ) {
				BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
				if(!shape) continue;
				int polys = shape->splineCount;
				for(int poly = 0; poly < polys; ++poly) {
					if(shape->polySel[poly])
						vertCount += shape->splines[poly]->KnotCount();
					}
				}
			}		
		string.printf(GetString(IDS_TH_SPLINE_VERT_COUNT),vertCount);
		}
	else
		string = _T("");

	nodes.DisposeTemporary();
	SetDlgItemText(hSelectPanel, IDC_SPLINE_VERT_COUNT, string);
	}

void EditSplineMod::SetSelDlgEnables() {
	if(!hSelectPanel)
		return;
	
	BOOL splType = (GetSubobjectLevel() == ES_SPLINE) ? TRUE : FALSE;
	EnableWindow (GetDlgItem (hSelectPanel, IDC_SVN_SELECTED), showVertNumbers);

	ICustButton *but = GetICustButton(GetDlgItem(hSelectPanel,IDC_NS_PASTE));
	but->Disable();
	switch(GetSubobjectLevel()) {
		case ES_VERTEX:
			if (GetShapeNamedVertSelClip())
				but->Enable();
			break;
		case ES_SEGMENT:
			if (GetShapeNamedSegSelClip())
				but->Enable();
			break;
		case ES_SPLINE:
			if (GetShapeNamedPolySelClip())
				but->Enable();
			break;
		}
	ReleaseICustButton(but);
//2-1-99
	ISpinnerControl *spin;
	BOOL vType = (GetSubobjectLevel() == ES_VERTEX) ? TRUE : FALSE;
	spin = GetISpinner(GetDlgItem(hSelectPanel,IDC_SELECTAREA_SPIN));
	spin->Enable(vType);
	ReleaseISpinner(spin);
	EnableWindow (GetDlgItem (hSelectPanel, IDC_AREA_SELECTION), vType);

	}

void EditSplineMod::SetOpsDlgEnables() {
	if(!hOpsPanel)
		return;
	
	assert(ip);

	// Disconnect right-click and delete mechanisms
	ip->GetRightClickMenuManager()->Unregister(&esMenu);
	ip->UnRegisterDeleteUser(&esDel);

	BOOL oType = (GetSubobjectLevel() == ES_OBJECT) ? TRUE : FALSE;
	BOOL vType = (GetSubobjectLevel() == ES_VERTEX) ? TRUE : FALSE;
	BOOL sType = (GetSubobjectLevel() == ES_SEGMENT) ? TRUE : FALSE;
	BOOL splType = (GetSubobjectLevel() == ES_SPLINE) ? TRUE : FALSE;
	BOOL ssType = (sType || splType) ? TRUE : FALSE;
	BOOL vsType = (vType || sType) ? TRUE : FALSE;
	
	// Shut off command modes that don't work in the new subobject level

	switch(ip->GetCommandMode()->ID()) {
		case CID_OUTLINE:
		case CID_TRIM:
		case CID_EXTEND:
		case CID_BOOLEAN:
			if(!splType)
				ip->SetStdCommandMode( CID_OBJMOVE );
			break;
		case CID_SEGBREAK:
			if(!sType)
				ip->SetStdCommandMode( CID_OBJMOVE );
			break;
		case CID_SEGREFINE:
//		watje
		case CID_REFINECONNECT:

			if(!vsType)
				ip->SetStdCommandMode( CID_OBJMOVE );
			break;
		case CID_VERTCONNECT:
		case CID_CROSSINSERT:
		case CID_FILLET:
		case CID_CHAMFER:
//		watje
		case CID_SPLINEBIND:
			if(!vType)
				ip->SetStdCommandMode( CID_OBJMOVE );
			break;
		case CID_VERTINSERT:
		case CID_CREATELINE:
			// Any level OK!
			break;
		}

	ICustButton *but;
	ISpinnerControl *spin;
	ICustToolbar *iToolbar;

//2-1-99 watje
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_RCONNECT), sType || vType);
	if (rConnect)
		{
		EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_RCLINEAR), sType || vType);
		EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_RCCLOSED), sType || vType);
		EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_BINDFIRST), sType || vType);
		EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_BINDLAST), sType || vType);
		}
	else
		{
		EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_RCLINEAR), FALSE);
		EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_RCCLOSED), FALSE);
		EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_BINDFIRST), FALSE);
		EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_BINDLAST), FALSE);
		}

//6-16-99 watje
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_SHOW_SELECTED), sType || vType);

//watje
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_BIND));
	but->Enable (vType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_UNBIND));
	but->Enable (vType);
	ReleaseICustButton (but);

	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_FUSE));
	but->Enable (vType);
	ReleaseICustButton (but);

/*2-1-99 watje
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_REFINECONNECT));
	but->Enable (sType ||vType);
	ReleaseICustButton (but);
	*/
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_CYCLE));
	but->Enable (vType);
	ReleaseICustButton (but);

	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_HIDE));
	but->Enable (!oType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_UNHIDE));
	but->Enable (!oType);
	ReleaseICustButton (but);


	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_CONNECT));
	but->Enable (vType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_REFINE));
	but->Enable (sType || vType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_BREAK));
	if(sType) {
		but->SetHighlightColor(GREEN_WASH);
		but->SetType(CBT_CHECK);
		}
	else {
		but->SetType(CBT_PUSH);
		}
	but->Enable (vType || sType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_EXPLODE));
	but->Enable (splType);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_TO_SPLINES), splType);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_TO_OBJECTS), splType);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_CROSS_INSERT));
	but->Enable (vType);
	ReleaseICustButton (but);
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_ES_CROSSTHRESHSPINNER));
	spin->Enable(vType);
	ReleaseISpinner(spin);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_MAKEFIRST));
	but->Enable (vType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_WELD));
	but->Enable (vType);
	ReleaseICustButton (but);
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_ES_THRESHSPINNER));
	spin->Enable(vType);
	ReleaseISpinner(spin);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_REVERSE));
	but->Enable (splType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_CLOSE));
	but->Enable (splType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_SEGDIVIDE));
	but->Enable (sType);
	ReleaseICustButton (but);
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_ES_DIVSSPINNER));
	spin->Enable(sType);
	ReleaseISpinner(spin);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_DETACH));
	but->Enable (ssType);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_SAMESHAPE), sType);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_DETACHREORIENT), ssType);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_DETACHCOPY), ssType);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_OUTLINE));
	but->Enable (splType);
	ReleaseICustButton (but);
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_ES_OUTLINESPINNER));
	spin->Enable(splType);
	ReleaseISpinner(spin);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_OUTCENTER), splType);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_FILLET));
	but->Enable (vType);
	ReleaseICustButton (but);
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_ES_FILLETSPINNER));
	spin->Enable(vType);
	ReleaseISpinner(spin);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_CHAMFER));
	but->Enable (vType);
	ReleaseICustButton (but);
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_ES_CHAMFERSPINNER));
	spin->Enable(vType);
	ReleaseISpinner(spin);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_BOOLEAN));
	but->Enable (splType);
	ReleaseICustButton (but);
	iToolbar = GetICustToolbar(GetDlgItem(hOpsPanel,IDC_ES_BOOL_TYPE));
	but = iToolbar->GetICustButton(BOOL_UNION);
	but->Enable (splType);
	ReleaseICustButton (but);
	but = iToolbar->GetICustButton(BOOL_SUBTRACTION);
	but->Enable (splType);
	ReleaseICustButton (but);
	but = iToolbar->GetICustButton(BOOL_INTERSECTION);
	but->Enable (splType);
	ReleaseICustButton (but);
	ReleaseICustToolbar(iToolbar);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_MIRROR));
	but->Enable (splType);
	ReleaseICustButton (but);
	iToolbar = GetICustToolbar(GetDlgItem(hOpsPanel,IDC_ES_MIRROR_TYPE));
	but = iToolbar->GetICustButton(MIRROR_HORIZONTAL);
	but->Enable (splType);
	ReleaseICustButton (but);
	but = iToolbar->GetICustButton(MIRROR_VERTICAL);
	but->Enable (splType);
	ReleaseICustButton (but);
	but = iToolbar->GetICustButton(MIRROR_BOTH);
	but->Enable (splType);
	ReleaseICustButton (but);
	ReleaseICustToolbar(iToolbar);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_COPY_MIRROR), splType);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_ABOUT_PIVOT), splType);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_TRIM));
	but->Enable (splType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_EXTEND));
	but->Enable (splType);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_ES_TRIM_INFINITE), splType);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ES_DELETE));
	but->Enable (!oType);
	ReleaseICustButton (but);
	// Enable/disable right-click and delete mechanisms
	if(!oType) {			
		esMenu.SetMod(this);
		ip->GetRightClickMenuManager()->Register(&esMenu);
		esDel.SetMod(this);
		ip->RegisterDeleteUser(&esDel);
		}
	}

void EditSplineMod::SetSurfDlgEnables() {
	if(!hSurfPanel)
		return;
	
	assert(ip);

	BOOL sType = (GetSubobjectLevel() == ES_SEGMENT) ? TRUE : FALSE;
	BOOL splType = (GetSubobjectLevel() == ES_SPLINE) ? TRUE : FALSE;
	BOOL ssType = (sType || splType) ? TRUE : FALSE;
	
	ICustButton *but;
	ISpinnerControl *spin;

	spin = GetISpinner(GetDlgItem(hSurfPanel,IDC_MAT_IDSPIN));
	spin->Enable(ssType);
	ReleaseISpinner(spin);
	but = GetICustButton (GetDlgItem (hSurfPanel, IDC_SELECT_BYID));
	but->Enable (ssType);
	ReleaseICustButton (but);
	}

void EditSplineMod::SelectionChanged() {
	if (hSelectPanel) {
		UpdateSelectDisplay();
		InvalidateRect(hSelectPanel,NULL,FALSE);
		}
	if (selLevel == ES_SEGMENT || GetSubobjectLevel() == ES_SPLINE)
		InvalidateSurfaceUI();
	// Now see if the selection set matches one of the named selections!
	if(ip && (selLevel != ES_OBJECT)) {
		ModContextList mcList;		
		INodeTab nodes;
		TimeValue t = ip->GetTime();
		ip->GetModContexts(mcList,nodes);
		int sublevel = selLevel - 1;
		int dataSet;
		for(int set = 0; set < namedSel[sublevel].Count(); ++set) {
			ClearShapeDataFlag(mcList,ESD_BEENDONE);
			BOOL gotMatch = FALSE;
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
				if ( !shapeData ) continue;
				if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;
				BezierShape *shape = shapeData->TempData(this)->GetShape(t);
				if(!shape) continue;
				// See if this shape has the named selection set
				switch(selLevel) {
					case ES_VERTEX: 
						for(dataSet = 0; dataSet < shapeData->vselSet.Count(); ++dataSet) {
							if(*(shapeData->vselSet.names[dataSet]) == *namedSel[sublevel][set]) {
								if(!(*shapeData->vselSet.sets[set] == shape->vertSel))
									goto next_set;
								gotMatch = TRUE;
								break;
								}
							}
						break;
					case ES_SEGMENT:
						for(dataSet = 0; dataSet < shapeData->sselSet.Count(); ++dataSet) {
							if(*(shapeData->sselSet.names[dataSet]) == *namedSel[sublevel][set]) {
								if(!(*shapeData->sselSet.sets[set] == shape->segSel))
									goto next_set;
								gotMatch = TRUE;
								break;
								}
							}
						break;
					case ES_SPLINE:
						for(dataSet = 0; dataSet < shapeData->pselSet.Count(); ++dataSet) {
							if(*(shapeData->pselSet.names[dataSet]) == *namedSel[sublevel][set]) {
								if(!(*shapeData->pselSet.sets[set] == shape->polySel))
									goto next_set;
								gotMatch = TRUE;
								break;
								}
							}
						break;
					}
				shapeData->SetFlag(ESD_BEENDONE,TRUE);
				}
			// If we reach here, we might have a set that matches
			if(gotMatch) {
				ip->SetCurNamedSelSet(*namedSel[sublevel][set]);
				goto namedSelUpdated;
				}
next_set:;
			}
		// No set matches, clear the named selection
		ip->ClearCurNamedSelSet();
				

namedSelUpdated:
		nodes.DisposeTemporary();
		ClearShapeDataFlag(mcList,ESD_BEENDONE);
		}
	}

void EditSplineMod::InvalidateSurfaceUI() {
	if(hSurfPanel) {
		InvalidateRect (hSurfPanel, NULL, FALSE);
		segUIValid = FALSE;
		}
	}

// Material editing operations

int EditSplineMod::GetSelMatIndex()
	{
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	if ( !ip ) return 0;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	BOOL first = 1;
	int mat=-1;

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;

		for(int poly = 0; poly < shape->splineCount; ++poly) {
			Spline3D *spline = shape->splines[poly];
			BitArray &sel = shape->segSel[poly];
			BOOL polySelected = (GetSubobjectLevel() == ES_SPLINE) ? shape->polySel[poly] : FALSE;
			for (int seg=0; seg < spline->Segments(); ++seg) {
				BOOL segSelected = (GetSubobjectLevel() == ES_SEGMENT) ? sel[seg] : FALSE;
				if (polySelected || segSelected) {
					if (first) {
						first = FALSE;
						mat   = (int)spline->GetMatID(seg);
					} else {
						if ((int)spline->GetMatID(seg) != mat) {
							return -1;
							}
						}
					}
				}
			}
		
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	return mat;
	}

void EditSplineMod::SetSelMatIndex(int index)
	{
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}

		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			BOOL polySelected = (GetSubobjectLevel() == ES_SPLINE) ? shape->polySel[poly] : FALSE;
			BitArray &sel = shape->segSel[poly];
			for(int seg = 0; seg < spline->Segments(); ++seg) {
				BOOL segSelected = (GetSubobjectLevel() == ES_SEGMENT) ? sel[seg] : FALSE;
				if(polySelected || segSelected) {
					altered = holdNeeded = TRUE;
					spline->SetMatID(seg,(MtlID)index);
					}
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape, FALSE);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_SEGMTLCHANGE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSEGSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditSplineMod::SelectByMat(int index,BOOL clear)
	{
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}

		int polys = shape->splineCount;
		if(GetSubobjectLevel() == ES_SPLINE) {
			BitArray &sel = shape->polySel.sel;
			if(clear)
				sel.ClearAll();
			for(int poly = 0; poly < polys; ++poly) {
				Spline3D *spline = shape->splines[poly];
				for(int seg = 0; seg < spline->Segments(); ++seg) {
					if(spline->GetMatID(seg) != index)
						goto next_spline;
					}
				sel.Set(poly);
next_spline:;
				}
			}
		else {
			for(int poly = 0; poly < polys; ++poly) {
				Spline3D *spline = shape->splines[poly];
				BitArray &sel = shape->segSel[poly];
				if(clear)
					sel.ClearAll();
				for(int seg = 0; seg < spline->Segments(); ++seg) {
					if(spline->GetMatID(seg) == index)
						sel.Set(seg);
					}
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape, FALSE);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	theHold.Accept(GetString(IDS_RB_SELECTBYMATID));

	nodes.DisposeTemporary();
	SelectionChanged();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

// Return TRUE if this modifier is just working on one object
BOOL EditSplineMod::SingleObjectMod() {
	ModContextList mcList;		
	INodeTab nodes;
	if ( !ip ) return FALSE;
	ip->GetModContexts(mcList,nodes);
	nodes.DisposeTemporary();
	return (mcList.Count() == 1) ? TRUE : FALSE;
	}

BezierShape *EditSplineMod::SingleObjectShape(INode **node) {
	ModContextList mcList;		
	INodeTab nodes;
	if ( !ip ) return NULL;
	ip->GetModContexts(mcList,nodes);
	if(mcList.Count() != 1) {
		nodes.DisposeTemporary();
		return NULL;
		}
	EditSplineData *shapeData = (EditSplineData*)mcList[0]->localData;
	if ( !shapeData ) {
		nodes.DisposeTemporary();
		return NULL;
		}
	if(node)
		*node = nodes[0];
	nodes.DisposeTemporary();
	return shapeData->TempData(this)->GetShape(ip->GetTime());
	}

//---------------------------------------------------------------------
// UI stuff

static HIMAGELIST hBoolImages = NULL;

static void LoadBoolImages()
	{
	if ( !hBoolImages ) {
		HBITMAP hBitmap, hMask;
		hBoolImages = ImageList_Create(16, 15, TRUE, 6, 0);
		hBitmap     = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_BOOLEANTYPES));
		hMask       = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_MASK_BOOLEANTYPES));
		ImageList_Add(hBoolImages,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);
		}
	}	

void EditSplineMod::SetBooleanButton() {
	iUnion->SetCheck((boolType == BOOL_UNION) ? TRUE : FALSE);
	iSubtraction->SetCheck((boolType == BOOL_SUBTRACTION) ? TRUE : FALSE);
	iIntersection->SetCheck((boolType == BOOL_INTERSECTION) ? TRUE : FALSE);
	}

static HIMAGELIST hMirrorImages = NULL;

static void LoadMirrorImages()
	{
	if ( !hMirrorImages ) {
		HBITMAP hBitmap, hMask;
		hMirrorImages = ImageList_Create(16, 15, TRUE, 6, 0);
		hBitmap     = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_MIRRORTYPES));
		hMask       = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_MASK_MIRRORTYPES));
		ImageList_Add(hMirrorImages,hBitmap,hMask);
		DeleteObject(hBitmap);
		DeleteObject(hMask);
		}
	}	

class ESImageListDestroyer {
	~ESImageListDestroyer() {
		if(hSplineImages)
			ImageList_Destroy(hSplineImages);
		if(hBoolImages)
			ImageList_Destroy(hBoolImages);
		if(hMirrorImages)
			ImageList_Destroy(hMirrorImages);
		}
	};
void EditSplineMod::SetMirrorButton() {
	iMirrorHorizontal->SetCheck((mirrorType == MIRROR_HORIZONTAL) ? TRUE : FALSE);
	iMirrorVertical->SetCheck((mirrorType == MIRROR_VERTICAL) ? TRUE : FALSE);
	iMirrorBoth->SetCheck((mirrorType == MIRROR_BOTH) ? TRUE : FALSE);
	}

// Dialog proc for "Select" rollup

BOOL CALLBACK SplineSelectDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	EditSplineMod *es = (EditSplineMod *)GetWindowLong( hDlg, GWL_USERDATA );
	ICustToolbar *iToolbar;
	if ( !es && message != WM_INITDIALOG ) return FALSE;
	
	switch ( message ) {
		case WM_INITDIALOG: {
		 	es = (EditSplineMod *)lParam;
		 	SetWindowLong( hDlg, GWL_USERDATA, (LONG)es );		 	
		 	es->hSelectPanel = hDlg;
			// Set up the editing level selector
			LoadESImages();
			iToolbar = GetICustToolbar(GetDlgItem(hDlg,IDC_SELTYPE));
			iToolbar->SetImage(hSplineImages);
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,0,3,0,3,24,23,24,23,ES_VERTEX));
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,1,4,1,4,24,23,24,23,ES_SEGMENT));
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,2,5,2,5,24,23,24,23,ES_SPLINE));
			ReleaseICustToolbar(iToolbar);
			es->RefreshSelType();
			CheckDlgButton( hDlg, IDC_LOCK_HANDLES, lockedHandles);
			CheckRadioButton( hDlg, IDC_LOCKALIKE, IDC_LOCKALL, lockType);
			CheckDlgButton( hDlg, IDC_SHOW_VERTEX_NUMBERS, es->showVertNumbers);
			CheckDlgButton( hDlg, IDC_SVN_SELECTED, es->SVNSelectedOnly);
			es->SetSelDlgEnables();

//2-1-99 watje
		 	es->selectAreaSpin = GetISpinner(GetDlgItem(hDlg,IDC_SELECTAREA_SPIN));
			es->selectAreaSpin->SetLimits( 0.0f, 999999.0f, FALSE );
			es->selectAreaSpin->LinkToEdit( GetDlgItem(hDlg,IDC_SELECTAREA), EDITTYPE_UNIVERSE );
			es->selectAreaSpin->SetValue(es->areaSelect,FALSE);
			CheckDlgButton( hDlg, IDC_AREA_SELECTION, es->useAreaSelect);

		 	return TRUE;
			}

		case WM_DESTROY:
//2-1-99 watje
			if ( es->selectAreaSpin ) {
				ReleaseISpinner(es->selectAreaSpin);
				es->selectAreaSpin = NULL;
				}

			// Don't leave in one of our modes!
			es->ip->ClearPickMode();
			CancelEditSplineModes(es->ip);
			return FALSE;
		
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			es->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;		
//2-1-99 watje
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_SELECTAREA_SPIN:
					es->areaSelect = es->selectAreaSpin->GetFVal();
					break;
				}


		
		case WM_COMMAND: {
			BOOL needRedraw = FALSE;
			switch ( LOWORD(wParam) ) {				
				case ES_VERTEX:
					if (es->GetSubobjectLevel() == ES_VERTEX)
						es->ip->SetSubObjectLevel (ES_OBJECT);
					else es->ip->SetSubObjectLevel (ES_VERTEX);
 
// Bug #202091 watje 8-31-99 no need to do a double notify 
//					needRedraw = TRUE;
					break;
				case ES_SEGMENT:
					if (es->GetSubobjectLevel() == ES_SEGMENT)
						es->ip->SetSubObjectLevel (ES_OBJECT);
					else es->ip->SetSubObjectLevel (ES_SEGMENT);
// Bug #202091 watje 8-31-99 no need to do a double notify 
//					needRedraw = TRUE;
					break;
				case ES_SPLINE:
					if (es->GetSubobjectLevel() == ES_SPLINE)
						es->ip->SetSubObjectLevel (ES_OBJECT);
					else es->ip->SetSubObjectLevel (ES_SPLINE);
// Bug #202091 watje 8-31-99 no need to do a double notify 
//					needRedraw = TRUE;
					break;
				case IDC_LOCK_HANDLES:
					lockedHandles = IsDlgButtonChecked( hDlg, IDC_LOCK_HANDLES);
					break;
				case IDC_SHOW_VERTEX_NUMBERS:
					es->showVertNumbers = IsDlgButtonChecked( hDlg, IDC_SHOW_VERTEX_NUMBERS);
					EnableWindow (GetDlgItem (hDlg, IDC_SVN_SELECTED), es->showVertNumbers);
					needRedraw = TRUE;
					break;
				case IDC_SVN_SELECTED:
					es->SVNSelectedOnly = IsDlgButtonChecked( hDlg, IDC_SVN_SELECTED);
					needRedraw = TRUE;
					break;
				case IDC_LOCKALIKE:
				case IDC_LOCKALL:
					lockType = LOWORD(wParam);
					break;
				case IDC_NS_COPY:
					es->NSCopy();
					break;
				case IDC_NS_PASTE:
					es->NSPaste();
					break;
//2-1-99 watje
				case IDC_AREA_SELECTION:
					es->useAreaSelect = IsDlgButtonChecked( hDlg, IDC_AREA_SELECTION);
					break;

				}
			if(needRedraw) {
				es->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
				es->ip->RedrawViews(es->ip->GetTime(),REDRAW_NORMAL);
				}
			}
			break;
		case WM_NOTIFY:
			if(((LPNMHDR)lParam)->code == TTN_NEEDTEXT) {
				LPTOOLTIPTEXT lpttt;
				lpttt = (LPTOOLTIPTEXT)lParam;				
				switch (lpttt->hdr.idFrom) {
				case ES_VERTEX:
					lpttt->lpszText = GetString (IDS_TH_VERTEX);
					break;
				case ES_SEGMENT:
					lpttt->lpszText = GetString (IDS_TH_SEGMENT);
					break;
				case ES_SPLINE:
					lpttt->lpszText = GetString(IDS_TH_SPLINE);
					break;
				}
			}
			break;

		}
	
	return FALSE;
	}

// Multiple Attachment handler

class AttachHitByName : public HitByNameDlgCallback {
public:
	EditSplineMod *es;

	AttachHitByName(EditSplineMod *s) {es=s;}
	TCHAR *dialogTitle()	{return GetString(IDS_TH_MULTIATTACH);}
	TCHAR *buttonText() 	{return GetString(IDS_TH_ATTACH);}
	int filter(INode *node);	
	void proc(INodeTab &nodeTab);	
};

int AttachHitByName::filter(INode *node)
	{
	ModContextList mcList;		
	INodeTab nodes;
	if (node) {
		// Make sure the node does not depend on this modifier.
		node->BeginDependencyTest();
		es->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if (node->EndDependencyTest()) return FALSE;

		ObjectState os =
			node->GetObjectRef()->Eval(es->ip->GetTime());
		GeomObject *object = (GeomObject *)os.obj;
		// Make sure it isn't one of the nodes we're editing, for heaven's sake!
		es->ip->GetModContexts(mcList,nodes);
		int numNodes = nodes.Count();
		if(numNodes != 1) {
			assert(0);
			return FALSE;
			}
		if(nodes[0] == node) {
			nodes.DisposeTemporary();
			return FALSE;
			}
		nodes.DisposeTemporary();
		if(object->CanConvertToType(splineShapeClassID))
			return TRUE;
		}
	return FALSE;
	}


void AttachHitByName::proc(INodeTab &nodeTab)
	{
	if (!es->ip) return;
	ModContextList mcList;
	INodeTab nodes;
	es->ip->GetModContexts(mcList, nodes);
	BOOL ret = TRUE;
	Mtl *firstMtl = nodes[0]->GetMtl();
	for (int i=0; i<nodeTab.Count(); i++) {
		if(firstMtl) {
			if (nodeTab[i]->GetMtl() && (firstMtl != nodeTab[i]->GetMtl()))
				break;
			}
		else
			firstMtl = nodeTab[i]->GetMtl();
		}
	if (i<nodeTab.Count())
		ret = DoAttachMatOptionDialog(es->ip, es);
	nodes.DisposeTemporary();
	if (!ret)
		return;
	es->MultiAttachObject(nodeTab);
	}

// Select by Material dialog

static BOOL CALLBACK SelectByMatDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static int *param;
	switch (msg) {
		case WM_INITDIALOG:
			param = (int*)lParam;
			SetupIntSpinner(hWnd,IDC_MAT_IDSPIN,IDC_MAT_ID,1,MAX_MATID,param[0]);			
			CheckDlgButton(hWnd,IDC_CLEARSELECTION,param[1]);
			CenterWindow(hWnd,GetParent(hWnd));
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_MAT_IDSPIN));
					param[0] = spin->GetIVal();
					param[1] = IsDlgButtonChecked(hWnd,IDC_CLEARSELECTION);
					ReleaseISpinner(spin);
					EndDialog(hWnd,1);					
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

// Dialog proc for "Operations" rollup

BOOL CALLBACK SplineOpsDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	ICustButton *but;
	EditSplineMod *es = (EditSplineMod *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !es && message != WM_INITDIALOG ) return FALSE;
	
	switch ( message ) {
		case WM_INITDIALOG: {
		 	es = (EditSplineMod *)lParam;
		 	SetWindowLong( hDlg, GWL_USERDATA, (LONG)es );		 	
			es->hOpsPanel = hDlg;
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_ATTACH));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			CheckDlgButton( hDlg, IDC_ES_ATTACHREORIENT, attachReorient);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_CREATELINE));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
		 	LoadBoolImages();
		 	LoadMirrorImages();
		 	es->outlineSpin = GetISpinner(GetDlgItem(hDlg,IDC_ES_OUTLINESPINNER));
			es->outlineSpin->SetLimits( -999999, 999999, FALSE );
			es->outlineSpin->LinkToEdit( GetDlgItem(hDlg,IDC_ES_OUTLINEWIDTH), EDITTYPE_UNIVERSE );
		 	es->filletSpin = GetISpinner(GetDlgItem(hDlg,IDC_ES_FILLETSPINNER));
			es->filletSpin->SetLimits( -999999, 999999, FALSE );
			es->filletSpin->LinkToEdit( GetDlgItem(hDlg,IDC_ES_FILLETWIDTH), EDITTYPE_UNIVERSE );
		 	es->chamferSpin = GetISpinner(GetDlgItem(hDlg,IDC_ES_CHAMFERSPINNER));
			es->chamferSpin->SetLimits( -999999, 999999, FALSE );
			es->chamferSpin->LinkToEdit( GetDlgItem(hDlg,IDC_ES_CHAMFERWIDTH), EDITTYPE_UNIVERSE );
			CheckDlgButton( hDlg, IDC_ES_OUTCENTER, centeredOutline);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_OUTLINE));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_FILLET));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_CHAMFER));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_BOOLEAN));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_TRIM));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_EXTEND));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_INSERT));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
		 	ICustToolbar *iToolbar = GetICustToolbar(GetDlgItem(hDlg,IDC_ES_BOOL_TYPE));
			iToolbar->SetImage(hBoolImages);
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,0,0,3,3,16,15,24,23,BOOL_UNION));
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,1,1,4,4,16,15,24,23,BOOL_SUBTRACTION));
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,2,2,5,5,16,15,24,23,BOOL_INTERSECTION));
			es->iUnion        = iToolbar->GetICustButton(BOOL_UNION);
			es->iSubtraction  = iToolbar->GetICustButton(BOOL_SUBTRACTION);
			es->iIntersection = iToolbar->GetICustButton(BOOL_INTERSECTION);
			ReleaseICustToolbar(iToolbar);
			es->SetBooleanButton();
		 	iToolbar = GetICustToolbar(GetDlgItem(hDlg,IDC_ES_MIRROR_TYPE));
			iToolbar->SetImage(hMirrorImages);
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,0,0,3,3,16,15,24,23,MIRROR_HORIZONTAL));
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,1,1,4,4,16,15,24,23,MIRROR_VERTICAL));
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,2,2,5,5,16,15,24,23,MIRROR_BOTH));
			es->iMirrorHorizontal = iToolbar->GetICustButton(MIRROR_HORIZONTAL);
			es->iMirrorVertical   = iToolbar->GetICustButton(MIRROR_VERTICAL);
			es->iMirrorBoth       = iToolbar->GetICustButton(MIRROR_BOTH);
			ReleaseICustToolbar(iToolbar);
			es->SetMirrorButton();
			CheckDlgButton( hDlg, IDC_TO_SPLINES, explodeToObjects ? FALSE : TRUE);
			CheckDlgButton( hDlg, IDC_TO_OBJECTS, explodeToObjects ? TRUE : FALSE);
			CheckDlgButton( hDlg, IDC_ES_COPY_MIRROR, polyMirrorCopy);
			CheckDlgButton( hDlg, IDC_ES_ABOUT_PIVOT, mirrorAboutPivot);
			CheckDlgButton( hDlg, IDC_ES_TRIM_INFINITE, trimInfinite);
			CheckDlgButton( hDlg, IDC_ES_SAMESHAPE, detachSameShape);
			CheckDlgButton( hDlg, IDC_ES_DETACHCOPY, detachCopy);
			CheckDlgButton( hDlg, IDC_ES_DETACHREORIENT, detachReorient);
			EnableWindow(GetDlgItem(hDlg,IDC_ES_DETACHREORIENT),!detachSameShape);
		 	es->divSpin = GetISpinner(GetDlgItem(hDlg,IDC_ES_DIVSSPINNER));
			es->divSpin->SetLimits( 1, 100, FALSE );
			es->divSpin->LinkToEdit( GetDlgItem(hDlg,IDC_ES_DIVISIONS), EDITTYPE_POS_INT );
			es->divSpin->SetValue(segDivisions, FALSE);
			es->divSpin->SetAutoScale();
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_REFINE));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_CROSS_INSERT));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_INSERT));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_CONNECT));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
		 	es->weldSpin = GetISpinner(GetDlgItem(hDlg,IDC_ES_THRESHSPINNER));
			es->weldSpin->SetLimits( 0, 999999, FALSE );
			es->weldSpin->LinkToEdit( GetDlgItem(hDlg,IDC_ES_WELDTHRESH), EDITTYPE_UNIVERSE );
			es->weldSpin->SetValue(weldThreshold,FALSE);
		 	es->crossSpin = GetISpinner(GetDlgItem(hDlg,IDC_ES_CROSSTHRESHSPINNER));
			es->crossSpin->SetLimits( 0, 999999, FALSE );
			es->crossSpin->LinkToEdit( GetDlgItem(hDlg,IDC_ES_CROSSTHRESH), EDITTYPE_UNIVERSE );
			es->crossSpin->SetValue(crossThreshold,FALSE);

//watje
			es->rConnect = IsDlgButtonChecked( hDlg, IDC_ES_RCONNECT);
			es->smoothRefineConnect = !IsDlgButtonChecked( hDlg, IDC_ES_RCLINEAR);
			es->closedRefineConnect = IsDlgButtonChecked( hDlg, IDC_ES_RCCLOSED);
			es->bindFirst = IsDlgButtonChecked( hDlg, IDC_ES_BINDFIRST);
			es->bindLast = IsDlgButtonChecked( hDlg, IDC_ES_BINDLAST);
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_BIND));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
/*2-1-99 watje
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_REFINECONNECT));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
*/
			but = GetICustButton(GetDlgItem(hDlg,IDC_ES_CYCLE));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_PUSH);
			ReleaseICustButton(but);

//6-16-99 watje
			CheckDlgButton( hDlg, IDC_ES_SHOW_SELECTED, showSelected);

		 	es->SetOpsDlgEnables();
			return TRUE;
			}

		case WM_DESTROY:
			if ( es->weldSpin ) {
				ReleaseISpinner(es->weldSpin);
				es->weldSpin = NULL;
				}
			if ( es->crossSpin ) {
				ReleaseISpinner(es->crossSpin);
				es->crossSpin = NULL;
				}
			if ( es->divSpin ) {
				ReleaseISpinner(es->divSpin);
				es->divSpin = NULL;
				}
			if ( es->outlineSpin ) {
				ReleaseISpinner(es->outlineSpin);
				es->outlineSpin = NULL;
				}
			if ( es->filletSpin ) {
				ReleaseISpinner(es->filletSpin);
				es->filletSpin = NULL;
				}
			if ( es->chamferSpin ) {
				ReleaseISpinner(es->chamferSpin);
				es->chamferSpin = NULL;
				}
 			if ( es->iUnion ) {
				ReleaseICustButton(es->iUnion);
				es->iUnion = NULL;
				}
 			if ( es->iSubtraction ) {
				ReleaseICustButton(es->iSubtraction);
				es->iSubtraction = NULL;
				}
 			if ( es->iIntersection ) {
				ReleaseICustButton(es->iIntersection);
				es->iIntersection = NULL;
				}
 			if ( es->iMirrorHorizontal ) {
				ReleaseICustButton(es->iMirrorHorizontal);
				es->iMirrorHorizontal = NULL;
				}
 			if ( es->iMirrorVertical ) {
				ReleaseICustButton(es->iMirrorVertical);
				es->iMirrorVertical = NULL;
				}
 			if ( es->iMirrorBoth ) {
				ReleaseICustButton(es->iMirrorBoth);
				es->iMirrorBoth = NULL;
				}
			// Don't leave in one of our modes!
			es->ip->DeleteMode(es->vertConnectMode);
			es->ip->DeleteMode(es->vertInsertMode);
			es->ip->DeleteMode(es->segRefineMode);
			es->ip->DeleteMode(es->crossInsertMode);
			es->ip->DeleteMode(es->segBreakMode);
			es->ip->DeleteMode(es->outlineMode);
			es->ip->DeleteMode(es->filletMode);
			es->ip->DeleteMode(es->chamferMode);
			es->ip->DeleteMode(es->booleanMode);
			es->ip->DeleteMode(es->createLineMode);

//watje
			es->ip->DeleteMode(es->refineConnectMode);
			es->ip->DeleteMode(es->bindMode);

			es->ip->ClearPickMode();
			CancelEditSplineModes(es->ip);
			// Detach our right-menu and delete stuff!
			es->ip->GetRightClickMenuManager()->Unregister(&esMenu);
			es->ip->UnRegisterDeleteUser(&esDel);
			return FALSE;
		
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_ES_OUTLINESPINNER: {
					float outSize = es->outlineSpin->GetFVal();
					if ( !es->inOutline ) {
						es->MaybeSelectSingleSpline(TRUE);
						if(es->AnyPolysSelected())
							es->BeginOutlineMove(es->ip->GetTime());
						}
					if(es->inOutline) {
						es->OutlineMove( es->ip->GetTime(), outSize );
						// If not being dragged, finish it now!
						if(!HIWORD(wParam))
							es->EndOutlineMove(es->ip->GetTime(), (outSize == 0.0f) ? FALSE : TRUE);
						es->ip->RedrawViews(es->ip->GetTime(),REDRAW_INTERACTIVE);					
						}
					}
					break;
				case IDC_ES_FILLETSPINNER: {
					float size = es->filletSpin->GetFVal();
					if ( !es->inFillet ) {
						es->SetFCLimit();
						es->filletSpin->SetLimits( 0.0f, es->FCLimit, FALSE );
						es->BeginFilletMove(es->ip->GetTime());
						}
					es->FilletMove( es->ip->GetTime(), size );
					// If not being dragged, finish it now!
					if(!HIWORD(wParam))
						es->EndFilletMove(es->ip->GetTime(), (size == 0.0f) ? FALSE : TRUE);
					es->ip->RedrawViews(es->ip->GetTime(),REDRAW_INTERACTIVE);					
					}
					break;
				case IDC_ES_CHAMFERSPINNER: {
					float size = es->chamferSpin->GetFVal();
					if ( !es->inChamfer ) {
						es->SetFCLimit();
						es->chamferSpin->SetLimits( 0.0f, es->FCLimit, FALSE );
						es->BeginChamferMove(es->ip->GetTime());
						}
					es->ChamferMove( es->ip->GetTime(), size );
					// If not being dragged, finish it now!
					if(!HIWORD(wParam))
						es->EndChamferMove(es->ip->GetTime(), (size == 0.0f) ? FALSE : TRUE);
					es->ip->RedrawViews(es->ip->GetTime(),REDRAW_INTERACTIVE);					
					}
					break;
				case IDC_ES_DIVSSPINNER:
					segDivisions = es->divSpin->GetIVal();
					break;
				case IDC_ES_THRESHSPINNER:
					weldThreshold = es->weldSpin->GetFVal();
					break;
				case IDC_ES_CROSSTHRESHSPINNER:
					crossThreshold = es->crossSpin->GetFVal();
					break;
				}
			break;

		case CC_SPINNER_BUTTONUP:
			switch( LOWORD(wParam) ) {
				case IDC_ES_OUTLINESPINNER:
					if(es->inOutline) {
						float outSize = es->outlineSpin->GetFVal();
						es->EndOutlineMove(es->ip->GetTime(), (outSize == 0.0f) ? FALSE : TRUE);
						}
					break;
				case IDC_ES_FILLETSPINNER:
					if(es->inFillet) {
						float size = es->filletSpin->GetFVal();
						es->EndFilletMove(es->ip->GetTime(), (size == 0.0f) ? FALSE : TRUE);
						}
					break;
				case IDC_ES_CHAMFERSPINNER:
					if(es->inChamfer) {
						float size = es->chamferSpin->GetFVal();
						es->EndChamferMove(es->ip->GetTime(), (size == 0.0f) ? FALSE : TRUE);
						}
					break;
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			es->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;		
		
		case WM_COMMAND:			
			switch ( LOWORD(wParam) ) {				

//watje
				case IDC_ES_UNBIND:
					es->DoUnBind();
					break;
				case IDC_ES_BIND:
					es->StartBindMode();
					break;
/*2-1-99 watje
				case IDC_ES_REFINECONNECT:
					es->StartRefineConnectMode();
					break;
*/
				case IDC_ES_RCLINEAR:
					{
					es->smoothRefineConnect = !IsDlgButtonChecked( hDlg, IDC_ES_RCLINEAR);
					break;
					}
				case IDC_ES_RCCLOSED:
					{
					es->closedRefineConnect = IsDlgButtonChecked( hDlg, IDC_ES_RCCLOSED);
					break;
					}
				case IDC_ES_BINDFIRST:
					{
					es->bindFirst = IsDlgButtonChecked( hDlg, IDC_ES_BINDFIRST);
					break;
					}
				case IDC_ES_BINDLAST:
					{
					es->bindLast = IsDlgButtonChecked( hDlg, IDC_ES_BINDLAST);
					break;
					}

//2-1-99 watje
				case IDC_ES_RCONNECT:
					{
					es->rConnect = IsDlgButtonChecked( hDlg, IDC_ES_RCONNECT);
					if (es->rConnect)
						{
						EnableWindow (GetDlgItem (hDlg, IDC_ES_RCLINEAR), TRUE);
						EnableWindow (GetDlgItem (hDlg, IDC_ES_RCCLOSED), TRUE);
						EnableWindow (GetDlgItem (hDlg, IDC_ES_BINDFIRST), TRUE);
						EnableWindow (GetDlgItem (hDlg, IDC_ES_BINDLAST), TRUE);
						}
					else
						{
						EnableWindow (GetDlgItem (hDlg, IDC_ES_RCLINEAR), FALSE);
						EnableWindow (GetDlgItem (hDlg, IDC_ES_RCCLOSED), FALSE);
						EnableWindow (GetDlgItem (hDlg, IDC_ES_BINDFIRST), FALSE);
						EnableWindow (GetDlgItem (hDlg, IDC_ES_BINDLAST), FALSE);
						}
					break;
					}


				case IDC_ES_HIDE:
					es->DoHide();
					break;
				case IDC_ES_UNHIDE:
					es->DoUnhide();
					break;
				case IDC_ES_CYCLE:
					es->DoCycleVerts();
					break;
				case IDC_ES_SHOW_SELECTED:
					showSelected = IsDlgButtonChecked( hDlg, IDC_ES_SHOW_SELECTED);
					es->SelectionChanged();
					es->NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
					es->ip->RedrawViews(es->ip->GetTime(),REDRAW_INTERACTIVE);					
					break;


				case IDC_ES_INSERT:
					es->StartVertInsertMode(IDC_ES_INSERT);
					break;
				case IDC_ES_BREAK:
					if(es->GetSubobjectLevel() == ES_VERTEX)
						es->DoVertBreak();
					else
						es->StartSegBreakMode();
					break;
				case IDC_ES_CLOSE:
					es->DoPolyClose();
					break;
				case IDC_ES_DETACH:
					switch(es->GetSubobjectLevel()) {
						case ES_SEGMENT:
							es->DoSegDetach(detachSameShape, detachCopy, detachReorient);
							break;
						case ES_SPLINE:
							es->DoPolyDetach(detachCopy, detachReorient);
							break;
						}
					break;
				case IDC_ES_SAMESHAPE:
					detachSameShape = IsDlgButtonChecked( hDlg, IDC_ES_SAMESHAPE);
					EnableWindow(GetDlgItem(hDlg,IDC_ES_DETACHREORIENT),!detachSameShape);
					break;
				case IDC_ES_DETACHCOPY:
					detachCopy = IsDlgButtonChecked( hDlg, IDC_ES_DETACHCOPY);
					break;
				case IDC_ES_DETACHREORIENT:
					detachReorient = IsDlgButtonChecked( hDlg, IDC_ES_DETACHREORIENT);
					break;
				case IDC_ES_SEGDIVIDE:
					es->DoSegDivide(segDivisions);
					break;
				case IDC_ES_OUTCENTER:
					centeredOutline = IsDlgButtonChecked( hDlg, IDC_ES_OUTCENTER);
					if ( es->inOutline ) {
						es->OutlineMove( es->ip->GetTime(),es->outlineSpin->GetFVal() );
						es->ip->RedrawViews(es->ip->GetTime(),REDRAW_INTERACTIVE);					
						}
					break;
				case IDC_ES_OUTLINE:
					es->StartOutlineMode();
					break;
				case IDC_ES_FILLET:
					es->StartFilletMode();
					break;
				case IDC_ES_CHAMFER:
					es->StartChamferMode();
					break;
				case IDC_ES_BOOLEAN: {
					if(!es->BooleanStartUp()) {
						ICustButton *but = GetICustButton(GetDlgItem(hDlg,IDC_ES_BOOLEAN));
						but->SetCheck(FALSE);
						ReleaseICustButton(but);
						CancelEditSplineModes(es->ip);
						}
					break;
					}
				case BOOL_UNION:
				case BOOL_SUBTRACTION:
				case BOOL_INTERSECTION:
					es->SetBoolOperation(LOWORD(wParam));
					es->SetBooleanButton();
					break;
				case IDC_TO_SPLINES:
					explodeToObjects = FALSE;
					CheckDlgButton( hDlg, IDC_TO_SPLINES, TRUE);
					CheckDlgButton( hDlg, IDC_TO_OBJECTS, FALSE);
					break;
				case IDC_TO_OBJECTS:
					explodeToObjects = TRUE;
					CheckDlgButton( hDlg, IDC_TO_SPLINES, FALSE);
					CheckDlgButton( hDlg, IDC_TO_OBJECTS, TRUE);
					break;
				case IDC_ES_MIRROR:
					es->DoPolyMirror(es->mirrorType,polyMirrorCopy, mirrorAboutPivot);
					break;
				case IDC_ES_COPY_MIRROR:
					polyMirrorCopy = IsDlgButtonChecked( hDlg, IDC_ES_COPY_MIRROR);
					break;
				case IDC_ES_ABOUT_PIVOT:
					mirrorAboutPivot = IsDlgButtonChecked( hDlg, IDC_ES_ABOUT_PIVOT);
					break;
				case IDC_ES_TRIM:
					es->StartTrimMode();
					break;
				case IDC_ES_EXTEND:
					es->StartExtendMode();
					break;
				case IDC_ES_TRIM_INFINITE:
					trimInfinite = IsDlgButtonChecked( hDlg, IDC_ES_TRIM_INFINITE);
					break;
				case IDC_ES_REVERSE:
					es->DoPolyReverse();
					break;
				case IDC_ES_EXPLODE:
					if(explodeToObjects)
						es->DoExplodeToObjects();
					else
						es->DoPolyExplode();
					break;
				case MIRROR_HORIZONTAL:
				case MIRROR_VERTICAL:
				case MIRROR_BOTH:
					es->SetMirrorOperation(LOWORD(wParam));
					es->SetMirrorButton();
					break;
				case IDC_ES_ATTACH: {
					// If the mode is on, turn it off and bail
					if (es->ip->GetCommandMode()->ID() == CID_STDPICK) {
						es->ip->SetStdCommandMode(CID_OBJMOVE);
						return FALSE;
						}
					es->pickCB.es = es;
					es->ip->SetPickMode(&es->pickCB);
					break;
					}
				case IDC_ES_ATTACH_MULTIPLE: {
					AttachHitByName proc(es);
					es->ip->DoHitByNameDialog(&proc);
					break;
					}
				case IDC_ES_ATTACHREORIENT:
					attachReorient = IsDlgButtonChecked( hDlg, IDC_ES_ATTACHREORIENT);
					break;
				case IDC_ES_CREATELINE:
					es->StartCreateLineMode();
					break;
//2-1-99 watje
				case IDC_ES_FUSE:
					es->DoVertFuse();
					break;
				case IDC_ES_REFINE:
					if (es->rConnect)
						es->StartRefineConnectMode();
					else es->StartSegRefineMode();
					break;

				case IDC_ES_CROSS_INSERT:
					es->StartCrossInsertMode();
					break;
				case IDC_ES_DELETE:
					switch(es->GetSubobjectLevel()) {
						case ES_VERTEX:
							es->DoVertDelete();
							break;
						case ES_SEGMENT:
							es->DoSegDelete();
							break;
						case ES_SPLINE:
							es->DoPolyDelete();
							break;
						}
					break;
				case IDC_ES_CONNECT:
					es->StartVertConnectMode();
					break;
				case IDC_ES_WELD:
					es->DoVertWeld();
					break;
				case IDC_ES_MAKEFIRST:
					es->DoMakeFirst();
					break;
				}
			break;

		case WM_NOTIFY:
			if(((LPNMHDR)lParam)->code == TTN_NEEDTEXT) {
				LPTOOLTIPTEXT lpttt;
				lpttt = (LPTOOLTIPTEXT)lParam;
				lpttt->lpszText = GetString(es->GetBoolMirrString(lpttt->hdr.idFrom));
				}
			break;
		}
	
	return FALSE;
	}

// Dialog proc for "Surface Properties" rollup

BOOL CALLBACK SplineSurfDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	EditSplineMod *es = (EditSplineMod *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !es && message != WM_INITDIALOG ) return FALSE;
	
	switch ( message ) {
		case WM_INITDIALOG: {
		 	es = (EditSplineMod *)lParam;
		 	SetWindowLong( hDlg, GWL_USERDATA, (LONG)es );		 	
			es->hSurfPanel = hDlg;
			es->matSpin = SetupIntSpinner(hDlg,IDC_MAT_IDSPIN,IDC_MAT_ID,1,MAX_MATID,0);
		 	es->SetSurfDlgEnables();
			return TRUE;
			}

		case WM_DESTROY:
			if( es->matSpin ) {
				ReleaseISpinner(es->matSpin);
				es->matSpin = NULL;
				}
			return FALSE;
		
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_MAT_IDSPIN: 
					if(HIWORD(wParam))
						break;		// No interactive action
					es->SetSelMatIndex(es->matSpin->GetIVal()-1);
					break;
				}
			break;

		case CC_SPINNER_BUTTONUP:
			switch( LOWORD(wParam) ) {
				case IDC_MAT_IDSPIN:
					es->SetSelMatIndex(es->matSpin->GetIVal()-1);
					es->ip->RedrawViews(es->ip->GetTime(),REDRAW_END);
					break;
				}
			break;

		case WM_PAINT:
			if (!es->segUIValid) {
				// Material index
				int mat = es->GetSelMatIndex();
				if (mat == -1) {
					es->matSpin->SetIndeterminate(TRUE);
				} else {
					es->matSpin->SetIndeterminate(FALSE);
					es->matSpin->SetValue(mat+1,FALSE);
					}

				es->segUIValid = TRUE;
				}
			return FALSE;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			es->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;		
		
		case WM_COMMAND:			
			switch ( LOWORD(wParam) ) {				
				// Material
				case IDC_SELECT_BYID: {										
					if (DialogBoxParam(
						hInstance, 
						MAKEINTRESOURCE(IDD_SELECTBYMAT),
						es->ip->GetMAXHWnd(), 
						SelectByMatDlgProc,
						(LPARAM)sbmParams)) {
					
						es->SelectByMat(sbmParams[0]-1/*index*/,sbmParams[1]/*clear*/);
						}
					break;
					}
				}
			break;
		}
	
	return FALSE;
	}

#define OLD_SEL_LEVEL_CHUNK 0x1000	// Old backwards ordering
#define SEL_LEVEL_CHUNK 0x1001
#define VERT_NUM_CHUNK 0x1010
// Names of named selection sets
#define NAMEDVSEL_NAMES_CHUNK	0x1050
#define NAMEDSSEL_NAMES_CHUNK	0x1060
#define NAMEDPSEL_NAMES_CHUNK	0x1070
#define NAMEDSEL_STRING_CHUNK	0x1080

#define USEAREA_CHUNK 0x1090
#define AREA_CHUNK 0x1100

static int namedSelID[] = {
	NAMEDVSEL_NAMES_CHUNK,
	NAMEDSSEL_NAMES_CHUNK,
	NAMEDPSEL_NAMES_CHUNK};

IOResult EditSplineMod::Save(ISave *isave) {
	Modifier::Save(isave);
	Interval valid;
	ULONG nb;
	short sl = selLevel;
	isave->BeginChunk(SEL_LEVEL_CHUNK);
	isave->Write(&sl,sizeof(short),&nb);
	isave->	EndChunk();
	isave->BeginChunk(VERT_NUM_CHUNK);
	isave->Write(&showVertNumbers,sizeof(BOOL), &nb);
	isave->Write(&SVNSelectedOnly,sizeof(BOOL), &nb);
	isave->EndChunk();
	// Save names of named selection sets
	for (int j=0; j<3; j++) {
		if (namedSel[j].Count()) {
			isave->BeginChunk(namedSelID[j]);			
			for (int i=0; i<namedSel[j].Count(); i++) {
				isave->BeginChunk(NAMEDSEL_STRING_CHUNK);
				isave->WriteWString(*namedSel[j][i]);
				isave->EndChunk();
				}
			isave->EndChunk();
			}
		}

//2-1-99 watje
	if (useAreaSelect)
		{
		isave->BeginChunk(USEAREA_CHUNK);
		isave->EndChunk();
		}
	isave->BeginChunk(AREA_CHUNK);
	isave->Write(&areaSelect,sizeof(float),&nb);
	isave->EndChunk();

	return IO_OK;
	}

IOResult EditSplineMod::LoadNamedSelChunk(ILoad *iload,int level)
	{	
	IOResult res;
	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case NAMEDSEL_STRING_CHUNK: {
				TCHAR *name;
				res = iload->ReadWStringChunk(&name);
				// Set the name in the modifier
				AddSet(TSTR(name),level+1);
				break;
				}
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

IOResult EditSplineMod::Load(ILoad *iload) {
	Modifier::Load(iload);
	IOResult res;
	ULONG nb;

	useAreaSelect = FALSE;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case OLD_SEL_LEVEL_CHUNK:
				{
				short sl;
				res = iload->Read(&sl,sizeof(short),&nb);
				selLevel = sl;
				switch(selLevel) {
					case 1:
						selLevel = ES_SPLINE;
						break;
					case 3:
						selLevel = ES_VERTEX;
						break;
					}
				}
				break;
			case SEL_LEVEL_CHUNK:
				res = iload->Read(&selLevel,sizeof(int),&nb);
				break;
			case VERT_NUM_CHUNK:
				res = iload->Read(&showVertNumbers,sizeof(BOOL), &nb);
				res = iload->Read(&SVNSelectedOnly,sizeof(BOOL), &nb);
				break;
			case NAMEDVSEL_NAMES_CHUNK: {				
				res = LoadNamedSelChunk(iload,0);
				break;
				}
			case NAMEDSSEL_NAMES_CHUNK: {
				res = LoadNamedSelChunk(iload,1);
				break;
				}
			case NAMEDPSEL_NAMES_CHUNK: {
				res = LoadNamedSelChunk(iload,2);
				break;
				}
//2-1-99 watje
			case USEAREA_CHUNK:
				useAreaSelect = TRUE;
				break;
			case AREA_CHUNK:
				res = iload->Read(&areaSelect,sizeof(float), &nb);
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}


#define EDITSPLINEDATA_CHUNK 0x1000

IOResult EditSplineMod::SaveLocalData(ISave *isave, LocalModData *ld) {
	EditSplineData *es = (EditSplineData *)ld;

	isave->BeginChunk(EDITSPLINEDATA_CHUNK);
	es->Save(isave);
	isave->EndChunk();

	return IO_OK;
	}

IOResult EditSplineMod::LoadLocalData(ILoad *iload, LocalModData **pld) {
	IOResult res;
	EditSplineData *es;
	if (*pld==NULL) {
		*pld =(LocalModData *) new EditSplineData();
		}
	es = (EditSplineData *)*pld;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case EDITSPLINEDATA_CHUNK:
				res = es->Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

ModRecord::~ModRecord() {
	}

// Edit Spline Vert Mapper methods follow...

ESPolysPV::~ESPolysPV() {
	if(map) {
		delete [] map;
		map = NULL;
		}
	}

void ESPolysPV::Build(Spline3D &spline, int poly) {
	if(map)
		delete [] map;
	count = spline.Verts();
	map = new ESPolyVert[count];
	for(int i = 0; i < count; ++i)
		map[i] = ESPolyVert(poly, i, spline.GetVert(i), Point3(0,0,0));
	}

void ESPolysPV::Reset() {
	for(int i = 0; i < count; ++i)
		map[i].poly = map[i].vert = -1;
	}

static Point3 noDelta(0,0,0);

void ESPolysPV::UpdateDeltas(Spline3D &spline, int poly) {
//	assert(count == spline.Verts());
	int sVerts = spline.Verts();
	for(int i = 0; i < count; ++i) {
		// If this table has more in it than we need, forget the rest
		// This can happen if the input object changes to fewer verts
		if(i >= sVerts)
			break;
		// If it's still mapped, update it!
		if(map[i].poly >= 0 && map[i].vert >= 0) {
			map[i].original = spline.GetVert(i);
			map[i].originalStored = TRUE;
			}
		}
	}

// This places an index to this poly and vert index into the spline.  The poly
// number is supplied by the ESVertMapper class.  By placing these indices into
// the spline, it allows an easy reverse mapping to us.
void ESPolysPV::RecordTopologyTags(BezierShape &shape, int poly) {
	for(int i = 0; i < count; ++i) {
		int mappoly = map[i].poly;
		int mapvert = map[i].vert;
		if(mappoly >= 0 && mapvert >= 0) {
			if(mappoly < shape.SplineCount()) {
				if(mapvert < shape.splines[mappoly]->Verts())
					shape.splines[mappoly]->SetVertAux(mapvert, 0, poly<<16 | i);
				}
			}
		}		
	}

ESPolysPV& ESPolysPV::operator=(ESPolysPV &from) {
	if(map)
		delete [] map;
	count = from.count;
	map = new ESPolyVert [count];
	for(int i = 0; i < count; ++i)
		map[i] = from.map[i];
	return *this;
	}

void ESPolysPV::RescaleWorldUnits(float f) {
	for(int i = 0; i < count; ++i) {
		map[i].delta *= f;
		if(map[i].originalStored)
			map[i].original *= f;
		}
	}

#define PPV_DATA_CHUNK 0x1000

IOResult ESPolysPV::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(PPV_DATA_CHUNK);
	isave->Write(&count,sizeof(int),&nb);
	for(int i = 0; i < count; ++i) {
		isave->Write(&map[i].poly,sizeof(int),&nb);
		isave->Write(&map[i].vert,sizeof(int),&nb);
		isave->Write(&map[i].delta,sizeof(Point3),&nb);
		}
	isave->EndChunk();
	return IO_OK;
	}

IOResult ESPolysPV::Load(ILoad *iload) {
	int i;
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PPV_DATA_CHUNK:
				res = iload->Read(&count,sizeof(int),&nb);
				if(map)
					delete [] map;
				map = new ESPolyVert[count];
				for(i = 0; i < count; ++i) {
					iload->Read(&map[i].poly,sizeof(int),&nb);
					iload->Read(&map[i].vert,sizeof(int),&nb);
					res = iload->Read(&map[i].delta,sizeof(Point3),&nb);
					}
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

ESVertMapper::~ESVertMapper() {
	if(polyMap) {
		delete [] polyMap;
		polyMap = NULL;
		}
	}

void ESVertMapper::Build(BezierShape &shape) {
	polys = shape.splineCount;
	if(polyMap)
		delete [] polyMap;
	polyMap = new ESPolysPV[polys];
	for(int i = 0; i < polys; ++i)
		polyMap[i].Build(*shape.splines[i], i);
	}

void ESVertMapper::UpdateAndApplyDeltas(BezierShape &inShape, BezierShape &outShape) {
#ifdef VMAP_DEBUG
	DebugPrint("Updating/Applying Deltas...\n");
#endif
	// Copy the shape's steps value -- Need to preserve them as they change! TH 5/6/99
	outShape.steps = inShape.steps;
	outShape.optimize = inShape.optimize;

	for(int i = 0; i < polys; ++i) {
		// Only update the deltas if the spline is still in the input shape
		if(i < inShape.splineCount)
			polyMap[i].UpdateDeltas(*inShape.splines[i], i);
		// Now apply the deltas to the output shape, also accounting for the updated
		// deltas from the previous step
		for(int j = 0; j < polyMap[i].count; ++j) {
			ESPolyVert &pv = polyMap[i].map[j];
			if(pv.poly >= 0 && pv.vert >= 0 && pv.originalStored) {
				// Watch out -- Edited spline may have had parts deleted -- TH 5/12/99
				if(pv.poly < outShape.SplineCount()) {
					if(pv.vert < outShape.splines[pv.poly]->Verts()) {
						if(i >= inShape.splineCount || (j >= (*inShape.splines[i]).Verts())) 
							outShape.splines[pv.poly]->SetVert(pv.vert, zeroPoint);
						else	
							outShape.splines[pv.poly]->SetVert(pv.vert, pv.original + pv.delta);
						}
					}
				}
			}
		}
#ifdef VMAP_DEBUG
	DebugPrint("Applying Deltas Complete!\n");
#endif
	}

void ESVertMapper::RecordTopologyTags(BezierShape &shape) {
	for(int i = 0; i < polys; ++i)
		polyMap[i].RecordTopologyTags(shape, i);
	}

void ESVertMapper::UpdateMapping(BezierShape &shape) {
//	DebugPrint("Updating mapping...\n");
	// Flush existing mapping
	for(int i = 0; i < polys; ++i)
		polyMap[i].Reset();
	// Build the new mapping
	int spolys = shape.SplineCount();
	for(int poly = 0; poly < spolys; ++poly) {
		Spline3D *spline = shape.splines[poly];
		int verts = spline->Verts();
		for(int vert = 0; vert < verts; ++vert) {
			int aux = spline->GetVertAux(vert, 0);
			if(aux != 0xffffffff) {
				int thePoly = aux >> 16;
				int theVert = aux & 0xffff;
				if(thePoly < polys) {
					ESPolyVert &epv = polyMap[thePoly].map[theVert];
					epv.poly = poly;
					epv.vert = vert;
#ifdef VMAP_DEBUG
					DebugPrint("map[%d/%d] maps to [%d/%d]\n",thePoly,theVert,poly,vert);
#endif
					}
				}
			}
		}
//	DebugPrint("Update Mapping Complete!\n");
	}

void ESVertMapper::RecomputeDeltas(BezierShape &shape) {
#ifdef VMAP_DEBUG
	DebugPrint("Recomputing Deltas...\n");
#endif
	for(int i = 0; i < polys; ++i) {
		ESPolysPV &ppv = polyMap[i];
		for(int j = 0; j < ppv.count; ++j) {
			ESPolyVert &ppvMap = ppv.map[j];
			if(ppvMap.poly >= 0 && ppvMap.vert >= 0 && ppvMap.originalStored) {
				if(ppvMap.poly < shape.SplineCount()) {
					Spline3D *spline = shape.splines[ppvMap.poly];
					if(ppvMap.vert < spline->Verts()) {
						Point3 pnew = spline->GetVert(ppvMap.vert);
						ppvMap.delta = pnew - ppvMap.original;
#ifdef VMAP_DEBUG
						DebugPrint("Point %d delta recomputed to %.2f %.2f %.2f\n",ppvMap.vert,ppvMap.delta.x,ppvMap.delta.y,ppvMap.delta.z);
#endif
						}
					}
				}
			}
		}
#ifdef VMAP_DEBUG
	DebugPrint("Recomputing Deltas Complete!\n");
#endif
	}

ESVertMapper& ESVertMapper::operator=(ESVertMapper &from) {
	if(polyMap)
		delete [] polyMap;
	polys = from.polys;
	polyMap = new ESPolysPV[polys];
	for(int i = 0; i < polys; ++i)
		polyMap[i] = from.polyMap[i];
	return *this;
	}

void ESVertMapper::RescaleWorldUnits(float f) {
	for(int i = 0; i < polys; ++i)
		polyMap[i].RescaleWorldUnits(f);
	}

#define ESVM_DATA_CHUNK 0x1000
#define ESVM_POLYMAP_CHUNK 0x1010

IOResult ESVertMapper::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(ESVM_DATA_CHUNK);
	isave->Write(&polys,sizeof(int),&nb);
	isave->EndChunk();
	for(int i = 0; i < polys; ++i) {
		isave->BeginChunk(ESVM_POLYMAP_CHUNK);
		polyMap[i].Save(isave);
		isave->	EndChunk();
		}
	return IO_OK;
	}

IOResult ESVertMapper::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	int index = 0;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case ESVM_DATA_CHUNK:
				res = iload->Read(&polys,sizeof(int),&nb);
				if(polyMap)
					delete [] polyMap;
				polyMap = new ESPolysPV[polys];
				break;
			case ESVM_POLYMAP_CHUNK:
				assert(index < polys);
				res = polyMap[index++].Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}



//watje

void EditSplineMod::DoBind(int poly1, int vert1, int poly2, int vert2) {

	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

/*		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->vertSel[poly].NumberSet()) {
*/
		altered = holdNeeded = 1;
		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}
				// Call the spline break function
		if (vert1 == 1)
			shape->BindKnot(FALSE, vert2, poly2, poly1);
		else shape->BindKnot(TRUE, vert2, poly2, poly1);

		//		shape->splines[poly1]->plineCacheValid = FALSE;
		shape->InvalidateGeomCache();

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_PW_BIND));
	else {
//		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
/*
	if ( !ip ) return;

	theHold.Begin();
	if ( theHold.Holding() )
		theHold.Put(new SSRestore(this));
	RecordTopologyTags();

	if (vert1 == 1)
		shape->BindKnot(FALSE, vert2, poly2, poly1);
	else shape->BindKnot(TRUE, vert2, poly2, poly1);
	shape->splines[poly1]->plineCacheValid = FALSE;
	ResolveTopoChanges();

	theHold.Accept(GetResString(IDS_TH_VERTCONNECT));
	SelectionChanged();
	shape.InvalidateGeomCache();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(), REDRAW_NORMAL);
*/
	}


void EditSplineMod::DoUnBind() {


	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

/*		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->vertSel[poly].NumberSet()) {
*/
		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}
				// Call the spline break function
//loop through splines check selecetd knots
		BOOL taltered = FALSE;
		for (int i = 0;  i < shape->vertSel.polys; i++)
			{
			if (shape->vertSel.sel[i][1])
				{
				taltered = shape->UnbindKnot(i,FALSE);
				if (taltered)
					altered = holdNeeded = 1;
				}
			int end = shape->vertSel.sel[i].GetSize() -2;

			if (shape->vertSel.sel[i][end])
				{
				taltered = shape->UnbindKnot(i,TRUE);
				if (taltered)
					altered = holdNeeded = 1;

				}

			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			holdNeeded = TRUE;
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_PW_UNBIND));
	else {
//		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
/*
	if ( !ip ) return;

	theHold.Begin();
	if ( theHold.Holding() )
		theHold.Put(new SSRestore(this));
	RecordTopologyTags();

//loop through splines check selecetd knots
	for (int i = 0;  i < shape.vertSel.polys; i++)
		{
		if (shape->vertSel.sel[i][1])
			{
			shape->UnbindKnot(i,FALSE);
			}
		int end = shape->vertSel.sel[i].GetSize() -2;

		if (shape->vertSel.sel[i][end])
			{
			shape->UnbindKnot(i,TRUE);
			}

		}
	ResolveTopoChanges();

	theHold.Accept(GetResString(IDS_TH_VERTCONNECT));
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(), REDRAW_NORMAL);

*/	}

/*-------------------------------------------------------------------*/

void BindCMode::EnterMode()
	{

	if ( ss->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(ss->hOpsPanel,IDC_ES_BIND));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}

	}

void BindCMode::ExitMode()
	{

	if ( ss->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(ss->hOpsPanel,IDC_ES_BIND));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}

	}

void EditSplineMod::StartBindMode()
	{

	if ( !ip ) return;

	if (ip->GetCommandMode() == bindMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(bindMode);

	}



/*-------------------------------------------------------------------*/
/*
void EditSplineMod::DoVertBreak() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->vertSel[poly].NumberSet()) {
				altered = holdNeeded = 1;
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				// Call the spline break function
				BreakSplineAtSelVerts(shape, poly);
				}
			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_VERTBREAK));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

*/

void EditSplineMod::DoHide() {

	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

//		altered = holdNeeded = 1;
		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}

		switch(GetSubobjectLevel()) {
			case SS_VERTEX:
				altered = shape->HideSelectedVerts();
//clear selection set
				shape->vertSel.ClearAll();
				break;
			case SS_SEGMENT:
				altered = shape->HideSelectedSegs();
				shape->segSel.ClearAll();
				break;
			case SS_SPLINE:
				altered = shape->HideSelectedSplines();
				shape->polySel.ClearAll();

				break;
			}



/*
		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			// If any bits are set in the selection set, let's DO IT!!
			if(shape->vertSel[poly].NumberSet()) {
				altered = holdNeeded = 1;
				if ( theHold.Holding() ) {
					theHold.Put(new ShapeRestore(shapeData,this,shape));
					}
				// Call the spline break function
				BreakSplineAtSelVerts(shape, poly);
				}
			}
*/

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			holdNeeded = TRUE;
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_PW_HIDE));
	else {
//		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);



/*
	if ( !ip ) return;

	theHold.Begin();
	if ( theHold.Holding() )
		theHold.Put(new SSRestore(this));
	RecordTopologyTags();

	switch(GetSubobjectLevel()) {
		case SS_VERTEX:
			shape->HideSelectedVerts();
//clear selection set
			shape->vertSel.ClearAll();
			break;
		case SS_SEGMENT:
			shape->HideSelectedSegs();
			shape->segSel.ClearAll();
			break;
		case SS_SPLINE:
			shape->HideSelectedSplines();
			shape->polySel.ClearAll();

			break;
		}

	ResolveTopoChanges();

	theHold.Accept(GetResString(IDS_TH_VERTCONNECT));
	SelectionChanged();
	shape.InvalidateGeomCache();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(), REDRAW_NORMAL);
*/
	}


void EditSplineMod::DoUnhide() {

	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		altered = 1;
		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}
		altered = shape->UnhideSegs();

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			holdNeeded = TRUE;
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
//FIX THIS NAME
		theHold.Accept(GetString(IDS_RB_UNHIDEALLFACES));
	else {
//		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);


/*	if ( !ip ) return;

	theHold.Begin();
	if ( theHold.Holding() )
		theHold.Put(new SSRestore(this));
	RecordTopologyTags();
	shape->UnhideSegs();

	ResolveTopoChanges();

	theHold.Accept(GetResString(IDS_TH_VERTCONNECT));
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(), REDRAW_NORMAL);
*/
	}


void EditSplineMod::DoCycleVerts() {


	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}
	
		int polys = shape->splineCount;
//check if only one selected cycle to next
//if a group is selected go to first
		int totalSelected = 0;
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			BitArray &sel = shape->vertSel[poly];
			totalSelected += sel.NumberSet();
			}

		if (totalSelected == 1)
			{
//find that one
			altered = 1;

			int s,k;
			Point3 p; 
			float adist = areaSelect * areaSelect;
			for(int poly = 0; poly < polys; ++poly) 
				{
				Spline3D *spline = shape->splines[poly];
				BitArray &sel = shape->vertSel[poly];
				for (int i = 0; i < sel.GetSize(); i++)
					{
					if (sel[i])
						{
						s = poly;
						k = i/3;
						p = spline->GetKnotPoint(k);
						i = sel.GetSize();
						poly = polys;
						}

					}
				}

	//now find next matching
			BOOL done = FALSE;
			int startPoly = s;
			int startKnot = k;

			int knot = ++k;
			poly = s;

			BOOL found = FALSE;
			Spline3D *spline = shape->splines[poly];
			BitArray &sel = shape->vertSel[poly];
			sel.ClearAll();
			BOOL first = TRUE;
			while (!done)
				{
				if ( (knot == startKnot) && (poly == startPoly))
					{
					done = TRUE;
					found = TRUE;
					}
				else if (knot >= spline->KnotCount())
					{
					knot = 0;
					poly++;
					if (poly >= shape->splineCount)
						poly = 0;
					spline = shape->splines[poly];

					}
				if (!done)
					{
					Point3 t = spline->GetKnotPoint(knot);
//2-1-99
					if (!useAreaSelect)
						{
						done = TRUE;
						found = TRUE;
						}
					else if (LengthSquared(p-t) <= adist) 
						{
						done = TRUE;
						found = TRUE;
						}
					else
						{
						knot++;
						}
					}

				}
			if (found)
				{
				BitArray &sel = shape->vertSel[poly];
				sel.Set(knot*3+1);

				}




	

			}
		else if (totalSelected > 0)
			{
//get first selected
			altered = 1;
			BOOL done = FALSE;
			int s,k;
			for(poly = 0; poly < polys; ++poly) {
				Spline3D *spline = shape->splines[poly];
				BitArray &sel = shape->vertSel[poly];
				if ((sel.NumberSet() >0) && (!done))
					{
					for (int i = 0; i < sel.GetSize(); i++)
						{
						if (sel[i])
							{
//2-1/99
							s = poly;
							k = i;
							done = TRUE;
							i = sel.GetSize();
							}
						}
					}
				sel.ClearAll();
				}

			shape->vertSel[s].Set(k);

			}


		if(altered) {
			shapeData->UpdateChanges(shape, FALSE);
			if ( shapeData->tempData ) {
				shapeData->tempData->Invalidate(PART_SELECT);
				}
			holdNeeded = TRUE;
//			shapeData->UpdateChanges(shape);
//			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_PW_CYCLE));
	else {
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);


}



/*-------------------------------------------------------------------*/


static Point3 ESRefineConnectSegment(BezierShape *shape, int poly, int segment, float param, BOOL apply) {

	Spline3D *spline = shape->splines[poly];
	int knots = spline->KnotCount();
	int verts = spline->Verts();
	int segs = spline->Segments();
	int nextSeg = (segment + 1) % knots;
	int insertSeg = (nextSeg == 0) ? -1 : nextSeg;

	// Get the knot points
	Point3 v00 = spline->GetKnotPoint(segment);
	Point3 v30 = spline->GetKnotPoint(nextSeg);

	// Get the knot types
	int type1 = spline->GetKnotType(segment);
	int type2 = spline->GetKnotType(nextSeg);

	// Get the material
	MtlID mtl = spline->GetMatID(segment);

	// Special: If they're refining a line-type segment, force it to be a bezier curve again


	if(spline->GetLineType(segment) == LTYPE_LINE) {
		spline->SetKnotType(segment, KTYPE_BEZIER_CORNER);
		spline->SetKnotType(nextSeg, KTYPE_BEZIER_CORNER);
		spline->SetLineType(segment, LTYPE_CURVE);
		spline->SetOutVec(segment, v00 + (v30 - v00) / 3.0f);
		spline->SetInVec(nextSeg, v30 - (v30 - v00) / 3.0f);
		}

	if (!apply) param= 0.5f;

	Point3 point = spline->InterpBezier3D(segment, param);
	
	Point3 v10 = spline->GetOutVec(segment);
	Point3 v20 = spline->GetInVec(nextSeg);
	Point3 v01 = v00 + (v10 - v00) * param;
	Point3 v21 = v20 + (v30 - v20) * param;
	Point3 v11 = v10 + (v20 - v10) * param;
	Point3 v02 = v01 + (v11 - v01) * param;
	Point3 v12 = v11 + (v21 - v11) * param;
	Point3 v03 = v02 + (v12 - v02) * param;


	if (apply)
		{

		spline->SetOutVec(segment, v01);
		spline->SetInVec(nextSeg, v21);

	// New for r3: Make the knot type dependent on the bordering knot types
		int newType = KTYPE_BEZIER;
//		if (r3Style) {
		if (TRUE) {
			if(type1 == KTYPE_CORNER && type2 == KTYPE_CORNER)
				newType = KTYPE_CORNER;
			else
			if((type1 & KTYPE_CORNER) || (type2 & KTYPE_CORNER))
				newType = KTYPE_BEZIER_CORNER;
			else
			if(type1 == KTYPE_AUTO && type2 == KTYPE_AUTO)
				newType = KTYPE_AUTO;
			}
		SplineKnot newKnot(newType, LTYPE_CURVE, v03, v02, v12);
		newKnot.SetMatID(mtl);

		spline->AddKnot(newKnot, insertSeg);


//watje 5-25-99
		BOOL hitBound = FALSE;
		for (int i = 0; i < shape->bindList.Count();i++)
			{
			if (poly == shape->bindList[i].segSplineIndex)  
				{
				if (segment <= shape->bindList[i].seg)
					{
					if (segment == shape->bindList[i].seg)
						{
						if (param <= 0.5f) 
							{
							shape->bindList[i].seg++;
							hitBound = TRUE;
							}
						}
					else
						{
						shape->bindList[i].seg++;
						hitBound = TRUE;

						}
					}
				}
			}


		spline->ComputeBezPoints();
		shape->InvalidateGeomCache();

	// Now adjust the spline selection sets
		BitArray& vsel = shape->vertSel[poly];
		BitArray& ssel = shape->segSel[poly];
		vsel.SetSize(spline->Verts(), 1);
		int where = (segment + 1) * 3;
		vsel.Shift(RIGHT_BITSHIFT, 3, where);
		vsel.Clear(where);
		vsel.Clear(where+1);
		vsel.Clear(where+2);
		ssel.SetSize(spline->Segments(), 1);
		ssel.Shift(RIGHT_BITSHIFT, 1, segment + 1);
		ssel.Set(segment+1,ssel[segment]);
		}
	return v03;
/*
	Spline3D *spline = shape->splines[poly];
	int knots = spline->KnotCount();
	int verts = spline->Verts();
	int segs = spline->Segments();
	int nextSeg = (segment + 1) % knots;
	int insertSeg = (nextSeg == 0) ? -1 : nextSeg;

	// Get the knot points
	Point3 v00 = spline->GetKnotPoint(segment);
	Point3 v30 = spline->GetKnotPoint(nextSeg);
	
	// Get the knot types
	int type1 = spline->GetKnotType(segment);
	int type2 = spline->GetKnotType(nextSeg);

	// Get the material
	MtlID mtl = spline->GetMatID(segment);

	// Special: If they're refining a line-type segment, force it to be a bezier curve again
	if(spline->GetLineType(segment) == LTYPE_LINE) {
		spline->SetKnotType(segment, KTYPE_BEZIER_CORNER);
		spline->SetKnotType(nextSeg, KTYPE_BEZIER_CORNER);
		spline->SetLineType(segment, LTYPE_CURVE);
		spline->SetOutVec(segment, v00 + (v30 - v00) / 3.0f);
		spline->SetInVec(nextSeg, v30 - (v30 - v00) / 3.0f);
		}

	if (!apply) param= 0.5f;

	Point3 point = spline->InterpBezier3D(segment, param);
	
	Point3 v10 = spline->GetOutVec(segment);
	Point3 v20 = spline->GetInVec(nextSeg);
	Point3 v01 = v00 + (v10 - v00) * param;
	Point3 v21 = v20 + (v30 - v20) * param;
	Point3 v11 = v10 + (v20 - v10) * param;
	Point3 v02 = v01 + (v11 - v01) * param;
	Point3 v12 = v11 + (v21 - v11) * param;
	Point3 v03 = v02 + (v12 - v02) * param;

	if (apply)
		{
		spline->SetOutVec(segment, v01);
		spline->SetInVec(nextSeg, v21);

	// New for r3: Make the knot type dependent on the bordering knot types
		int newType = KTYPE_BEZIER;
		if(type1 == KTYPE_CORNER && type2 == KTYPE_CORNER)
			newType = KTYPE_CORNER;
		else
		if((type1 & KTYPE_CORNER) || (type2 & KTYPE_CORNER))
			newType = KTYPE_BEZIER_CORNER;
		else
		if(type1 == KTYPE_AUTO && type2 == KTYPE_AUTO)
			newType = KTYPE_AUTO;

		SplineKnot newKnot(newType, LTYPE_CURVE, v03, v02, v12);
		newKnot.SetMatID(mtl);

	// If animating, expand the controller array to accomodate this new vertex
		if(ss && ss->cont.Count()) {
			int base = shape->GetVertIndex(poly, 0);
			if(insertSeg < 0)	// Special flag for last vert
				insertSeg = spline->KnotCount();
			ss->InsertPointConts(base + insertSeg * 3, 3);
			}
		spline->AddKnot(newKnot, insertSeg);
		spline->ComputeBezPoints();
		shape->InvalidateGeomCache();
		

	// Now adjust the spline selection sets
		BitArray& vsel = shape->vertSel[poly];
		BitArray& ssel = shape->segSel[poly];
		vsel.SetSize(spline->Verts(), 1);
		int where = (segment + 1) * 3;
		vsel.Shift(RIGHT_BITSHIFT, 3, where);
		vsel.Clear(where);
		vsel.Clear(where+1);
		vsel.Clear(where+2);
		ssel.SetSize(spline->Segments(), 1);
		ssel.Shift(RIGHT_BITSHIFT, 1, segment + 1);
		ssel.Set(segment+1,ssel[segment]);
		}

	return v03;
*/
	}


void EditSplineMod::DoRefineConnect(ViewExp *vpt, BezierShape *rshape, int poly, int seg, IPoint2 p) {

	ModContextList mcList;		
	INodeTab nodes;
	int holdNeeded = 0;
	int altered = 0;
	TimeValue t = ip->GetTime();

	Point3 sPoint = vpt->SnapPoint(p,p,NULL,SNAP_IN_3D);

	Point2 fp = Point2((float)p.x, (float)p.y);

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);

	if(nodes.Count() != 1) {
		nodes.DisposeTemporary();
//		assert(0);
		return;
		}

//	if (pointList.Count() != 0)
//		theHold.Accept(GetString(IDS_TH_REFINE));

	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}

		shapeData->BeginEdit(t);
		shapeData->RecordTopologyTags(shape);

	// Find the location on the segment where the user clicked
		INode *inode = nodes[0];
		GraphicsWindow *gw = vpt->getGW();
		HitRegion hr;
		MakeHitRegion(hr, HITTYPE_POINT, 1, 4, &p);
		gw->setHitRegion(&hr);
		Matrix3 mat = inode->GetObjectTM(t);
		gw->setTransform(mat);	

		float param = shape->FindSegmentPoint(poly, seg, gw, gw->getMaterial(), &hr);

		Point3 pt;// = RefineConnectSegment(this, &shape, poly, seg, param,TRUE);

		if ((bindFirst) && (pointList.Count() ==0) && (!closedRefineConnect))
			{
			pt = ESRefineConnectSegment( shape, poly, seg, param,FALSE);
			startSegRC = seg;
			startSplineRC = poly;
			}
		else if (bindLast) 
			{
			endSegRC = seg;
			endSplineRC = poly;

//			prevSpline = poly;
//			insertPoint = seg;
			int knots = shape->splines[poly]->KnotCount();
			knotPoint1 = shape->splines[poly]->GetKnot(seg);
			knotPoint2 = shape->splines[poly]->GetKnot((seg + 1) % knots);

			pt = ESRefineConnectSegment( shape, poly, seg, param,TRUE);

			}
		else pt = ESRefineConnectSegment(shape, poly, seg, param,TRUE);

		if (bindFirst)
			{
			if ((poly == startSplineRC) && (seg < startSegRC)) startSegRC++;
			}


		pointList.Append(1,&pt,1);

		shapeData->UpdateChanges(shape);
		shapeData->TempData(this)->Invalidate(PART_TOPO);
//		shape->UpdateBindList();

		theHold.Accept(GetString(IDS_TH_REFINE));
		}
	nodes.DisposeTemporary();
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t, REDRAW_NORMAL);
	}


void RefineConnectCMode::EnterMode()
	{

	if ( ss->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(ss->hOpsPanel, IDC_ES_REFINE));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
//2-1-99 watje
		EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCONNECT),FALSE);
		EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCLINEAR), FALSE);
		EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCCLOSED), FALSE);
		EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_BINDFIRST), FALSE);
		EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_BINDLAST), FALSE);

		}

	}

void RefineConnectCMode::ExitMode()
	{
//add line now

	if ( ss->hOpsPanel ) {

		if (ss->pointList.Count() > 0) ss->EndRefineConnectMode();

		ICustButton *but = GetICustButton(GetDlgItem(ss->hOpsPanel, IDC_ES_REFINE));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
//2-1-99 watje
		BOOL vType = (ss->GetSubobjectLevel() == SS_VERTEX) ? TRUE : FALSE;
		BOOL sType = (ss->GetSubobjectLevel() == SS_SEGMENT) ? TRUE : FALSE;

		if ( vType||sType)
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCONNECT),TRUE);
		else EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCONNECT),FALSE); 

		if ( (ss->rConnect) && (vType||sType))
			{
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCLINEAR), TRUE);
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCCLOSED), TRUE);
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_BINDFIRST), TRUE);
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_BINDLAST), TRUE);
			}
		else
			{
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCLINEAR), FALSE);
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_RCCLOSED), FALSE);
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_BINDFIRST), FALSE);
			EnableWindow (GetDlgItem (ss->hOpsPanel, IDC_ES_BINDLAST), FALSE);
			}


		}

	}

void EditSplineMod::StartRefineConnectMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == refineConnectMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	pointList.ZeroCount();

	refineConnectMode->SetType(GetSubobjectLevel()==SS_VERTEX ? REFINE_VERT : REFINE_SEG);
	ip->SetCommandMode(refineConnectMode);

	}


void EditSplineMod::EndRefineConnectMode()
	{

//	if ((bindLast) && (!closedRefineConnect))
//		theHold.Cancel();
//	else theHold.Accept(GetString(IDS_TH_REFINE));


	if (pointList.Count() == 1) return;


	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++ ) {
		Point3 pivot = nodes[i]->GetObjOffsetPos();
		int altered = 0;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);

		altered = holdNeeded = 1;
		// Save the unmodified verts.
		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}

//get rid of last refine if needed
		if (pointList.Count() > 1)
			{
			if ((startSplineRC == endSplineRC) && (bindFirst) && (bindLast))
				{
				if ((startSegRC >= endSegRC) && (startSegRC>0))
					startSegRC--;
				}

			if (bindLast)
				{
				shape->splines[endSplineRC]->DeleteKnot(endSegRC+1);
				shape->segSel.sel[endSplineRC].Shift(LEFT_BITSHIFT, 1, endSegRC+1);
				shape->segSel.sel[endSplineRC].SetSize(shape->segSel.sel[endSplineRC].GetSize()-1,TRUE);

				shape->vertSel.sel[endSplineRC].Shift(LEFT_BITSHIFT, 3, endSegRC+2);
				shape->vertSel.sel[endSplineRC].SetSize(shape->vertSel.sel[endSplineRC].GetSize()-3,TRUE);

				int knots = shape->splines[endSplineRC]->KnotCount();
				shape->splines[endSplineRC]->SetKnot(endSegRC,knotPoint1);
				shape->splines[endSplineRC]->SetKnot((endSegRC + 1) % knots,knotPoint2);

				}
			int ct = shape->splineCount;
			Spline3D *newSpline = shape->NewSpline();

			shape->vertSel.Insert(shape->SplineCount() - 1, pointList.Count() * 3);
			if (!closedRefineConnect)
				shape->segSel.Insert(shape->SplineCount() - 1, (pointList.Count()-1));
			else shape->segSel.Insert(shape->SplineCount() - 1, (pointList.Count()));
			shape->polySel.Insert(shape->SplineCount() - 1);

			for	(int j=0; j<pointList.Count();j++)
				{	
				
				if (smoothRefineConnect)  
					{
					SplineKnot k = SplineKnot(KTYPE_AUTO, LTYPE_CURVE,pointList[j],pointList[j],pointList[j]);
					newSpline->AddKnot(k);
					}
					else 
					{
					SplineKnot k = SplineKnot(KTYPE_CORNER, LTYPE_CURVE,pointList[j],pointList[j],pointList[j]);
					newSpline->AddKnot(k);
					}
				}
			if (closedRefineConnect)
				newSpline->SetClosed();
			else newSpline->SetOpen();
			newSpline->ComputeBezPoints();
			shape->UpdateBindList();

			if ((bindFirst) && (!closedRefineConnect))
				{
				shape->BindKnot(FALSE , startSegRC,startSplineRC, ct);
				}
			if ((bindLast) && (!closedRefineConnect))
				{
				shape->BindKnot(TRUE , endSegRC,endSplineRC, ct);

				}


//			newSpline->ComputeBezPoints();

		

			shape->InvalidateGeomCache();




			if(altered) {
				shapeData->UpdateChanges(shape);
				shapeData->TempData(this)->Invalidate(PART_TOPO);
				}
			shapeData->SetFlag(ESD_BEENDONE,TRUE);
			}
		}
	
	if(holdNeeded) {
		theHold.Accept(GetString(IDS_TH_CREATELINE));
		}
/*	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOSPLINESSEL),PROMPT_TIME);
		theHold.End();
		}
*/
	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t,REDRAW_NORMAL);



/*
	ModContextList mcList;		
	INodeTab nodes;
	int holdNeeded = 0;
	int altered = 0;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);

	if(nodes.Count() != 1) {
		nodes.DisposeTemporary();
		assert(0);
		return;
		}

	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		// If this is the first edit, then the delta arrays will be allocated
		shapeData->RecordTopologyTags(shape);
		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}
		shapeData->BeginEdit(t);

		int ct = shape->splineCount;
		Spline3D *newSpline = shape->NewSpline();
		for	(int j=0; j<pointList.Count();j++)
			{	
				
			if (smoothRefineConnect)  
				{
				SplineKnot k = SplineKnot(KTYPE_AUTO, LTYPE_CURVE,pointList[j],pointList[j],pointList[j]);
				newSpline->AddKnot(k);
				}
				else 
				{
				SplineKnot k = SplineKnot(KTYPE_CORNER, LTYPE_CURVE,pointList[j],pointList[j],pointList[j]);
				newSpline->AddKnot(k);
				}
			}
		if (closedRefineConnect)
			newSpline->SetClosed();
		else newSpline->SetOpen();
			newSpline->ComputeBezPoints();

		if ((bindFirst) && (!closedRefineConnect))
			{
			shape->BindKnot(FALSE , startSegRC,startSplineRC, ct);
			}
		if ((bindLast) && (!closedRefineConnect))
			{
			shape->BindKnot(TRUE , endSegRC,endSplineRC, ct);

			}

		newSpline->ComputeBezPoints();

		shape->vertSel.Insert(shape->SplineCount() - 1, pointList.Count() * 3);
		shape->segSel.Insert(shape->SplineCount() - 1, pointList.Count());
		shape->polySel.Insert(shape->SplineCount() - 1);
		

		shape->InvalidateGeomCache();


		shape->UpdateBindList();


		shapeData->UpdateChanges(shape,TRUE);
		shapeData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);
		shapeData->SetFlag(ESD_BEENDONE,TRUE);

		}
	theHold.Accept(GetString(IDS_TH_CREATELINE));

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	SelectionChanged();

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t, REDRAW_NORMAL);


*/

	}

/*-------------------------------------------------------------------*/

// Trim/Extend follows

/*-------------------------------------------------------------------*/

void TrimCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_TRIM));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void TrimCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		es->EndOutlineMove(es->ip->GetTime(),TRUE);
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_TRIM));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartTrimMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == trimMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(trimMode);
	}

/*-------------------------------------------------------------------*/

void ExtendCMode::EnterMode()
	{
	if ( es->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_EXTEND));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void ExtendCMode::ExitMode()
	{
	if ( es->hOpsPanel ) {
		es->EndOutlineMove(es->ip->GetTime(),TRUE);
		ICustButton *but = GetICustButton(GetDlgItem(es->hOpsPanel,IDC_ES_EXTEND));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

void EditSplineMod::StartExtendMode()
	{
	if ( !ip ) return;

	if (ip->GetCommandMode() == extendMode) {
		ip->SetStdCommandMode(CID_OBJMOVE);
		return;
		}
	ip->SetCommandMode(extendMode);
	}

class EditSplineShapeContextCallback : public ShapeContextCallback {
	public:
		EditSplineMod *mod;
		EditSplineShapeContextCallback(EditSplineMod *m) { mod=m; }
		BezierShape *GetShapeContext(ModContext *context);
	};

BezierShape *EditSplineShapeContextCallback::GetShapeContext(ModContext *context) {
	EditSplineData *shapeData = (EditSplineData*)context->localData;
	if ( !mod->ip )
		return NULL;
	if ( !shapeData )
		return NULL;
	return shapeData->TempData(mod)->GetShape(mod->ip->GetTime());
	}

void EditSplineMod::HandleTrimExtend(ViewExp *vpt, ShapeHitData *hit, IPoint2 &m, int trimType) {
	EditSplineShapeContextCallback cb(this);

	ModContextList mcList;		
	INodeTab nodes;
	if ( !ip ) return;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		
		if(shape == hit->shape) {
			// If this is the first edit, then the delta arrays will be allocated
			shapeData->BeginEdit(t);

			if ( theHold.Holding() )
				theHold.Put(new ShapeRestore(shapeData,this,shape));
			if(shape->PerformTrimOrExtend(ip, vpt, hit, m, cb, trimType, trimInfinite)) {
				holdNeeded = TRUE;
				shapeData->UpdateChanges(shape, FALSE);
				shapeData->TempData(this)->Invalidate(PART_TOPO);
				}
			}
		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(trimType == SHAPE_TRIM ? GetString(IDS_TH_TRIM) : GetString(IDS_TH_EXTEND));
	else
		theHold.End();

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

/*-------------------------------------------------------------------*/
// --------------------------------------------------------------------
// ISplineSelect and ISplineOps interfaces   (JBW 2/1/99)

void* EditSplineMod::GetInterface(ULONG id) 
{
	switch (id)
	{
		case I_SPLINESELECT: return (ISplineSelect*)this;
		case I_SPLINESELECTDATA: return (ISplineSelectData*)this;
		case I_SPLINEOPS: return (ISplineOps*)this;
		case I_SUBMTLAPI: return (ISubMtlAPI*)this;
	}
	return Modifier::GetInterface(id);
}

void EditSplineMod::StartCommandMode(splineCommandMode mode)
{
	switch (mode)
	{
		case ScmCreateLine:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_CREATELINE, 0);
			break;
		case ScmAttach:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_ATTACH, 0);
			break;
		case ScmInsert:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_INSERT, 0);
			break;
		case ScmConnect:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_CONNECT, 0);
			break;
		case ScmRefine:
			if (hOpsPanel != NULL && (GetSubobjectLevel() == SS_VERTEX || GetSubobjectLevel() == SS_SEGMENT))
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_REFINE, 0);
			break;
		case ScmFillet:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_FILLET, 0);
			break;
		case ScmChamfer:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_CHAMFER, 0);
			break;
		case ScmBind:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_BIND, 0);
			break;
		case ScmRefineConnect:
			if (hOpsPanel != NULL && (GetSubobjectLevel() == SS_VERTEX || GetSubobjectLevel() == SS_SEGMENT))
//watje			PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_REFINECONNECT, 0);
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_REFINE, 0);
			break;
		case ScmOutline:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_OUTLINE, 0);
			break;
		case ScmTrim:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_TRIM, 0);
			break;
		case ScmExtend:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_EXTEND, 0);
			break;
		case ScmCrossInsert:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_CROSS_INSERT, 0);
			break;
		case ScmBreak:
			if (hOpsPanel != NULL && (GetSubobjectLevel() == SS_SEGMENT || GetSubobjectLevel() == SS_VERTEX))
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_BREAK, 0);
			break;
		case ScmUnion:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
			{
				PostMessage(hOpsPanel, WM_COMMAND, BOOL_UNION, 0);
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_BOOLEAN, 0);
			}
			break;
		case ScmSubtract:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
			{
				PostMessage(hOpsPanel, WM_COMMAND, BOOL_SUBTRACTION, 0);
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_BOOLEAN, 0);
			}
			break;
	}
}

void EditSplineMod::ButtonOp(splineButtonOp opcode)
{
	switch (opcode)
	{
		case SopHide:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_HIDE, 0);
			break;
		case SopUnhideAll:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_UNHIDE, 0);
			break;
		case SopDelete:
			if (hOpsPanel != NULL && GetSubobjectLevel() >= SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_DELETE, 0);
			break;
		case SopDetach:
			if (hOpsPanel != NULL && (GetSubobjectLevel() == SS_SEGMENT || GetSubobjectLevel() == SS_SPLINE))
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_DETACH, 0);
			break;
		case SopDivide:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SEGMENT)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_SEGDIVIDE, 0);
			break;
		case SopCycle:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_CYCLE, 0);
			break;
		case SopUnbind:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_UNBIND, 0);
			break;
		case SopWeld:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_WELD, 0);
			break;
		case SopMakeFirst:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_VERTEX)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_MAKEFIRST, 0);
			break;
		case SopAttachMultiple:
			if (hOpsPanel != NULL)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_ATTACH_MULTIPLE, 0);
			break;
		case SopExplode:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_EXPLODE, 0);
			break;
		case SopReverse:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_REVERSE, 0);
			break;
		case SopClose:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_CLOSE, 0);
			break;
		case SopIntersect:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
			{
				PostMessage(hOpsPanel, WM_COMMAND, BOOL_INTERSECTION, 0);
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_BOOLEAN, 0);
			}
			break;
		case SopMirrorHoriz:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
			{
				PostMessage(hOpsPanel, WM_COMMAND, MIRROR_HORIZONTAL, 0);
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_MIRROR, 0);
			}
			break;
		case SopMirrorVert:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
			{
				PostMessage(hOpsPanel, WM_COMMAND, MIRROR_VERTICAL, 0);
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_MIRROR, 0);
			}
			break;
		case SopMirrorBoth:
			if (hOpsPanel != NULL && GetSubobjectLevel() == SS_SPLINE)
			{
				PostMessage(hOpsPanel, WM_COMMAND, MIRROR_BOTH, 0);
				PostMessage(hOpsPanel, WM_COMMAND, IDC_ES_MIRROR, 0);
			}
			break;
		case SopSelectByID:
			if (hOpsPanel != NULL && (GetSubobjectLevel() == SS_SEGMENT || GetSubobjectLevel() == SS_SPLINE))
				PostMessage(hOpsPanel, WM_COMMAND, IDC_SELECT_BYID, 0);
			break;
	}
}

DWORD EditSplineMod::GetSelLevel()
{
	return GetSubobjectLevel();
}

void EditSplineMod::SetSelLevel(DWORD level)
{
}

void EditSplineMod::LocalDataChanged()
{
}

MtlID EditSplineMod::GetNextAvailMtlID(ModContext* mc) {
	if(!mc)
		return 1;
	EditSplineData *shapeData = (EditSplineData*)mc->localData;
	if ( !shapeData ) return 1;

	// If the mesh isn't yet cache, this will cause it to get cached.
	BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
	if(!shape) return 1;
	
	int mtlID = GetSelFaceUniqueMtlID(mc);

	if (mtlID == -1) {
		int i;
 		
		MtlID min, max;
		BOOL first = TRUE;

		int polys = shape->splineCount;
		for(int poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			for(int seg = 0; seg < spline->Segments(); ++seg) {
				MtlID thisID = spline->GetMatID(seg);
				if(first) {
					min = max = thisID;
					first = FALSE;
					}
				else
				if(thisID < min)
					min = thisID;
				else
				if(thisID > max)
					max = thisID;
				}
			}
		// If room below, return it
		if(min > 0)
			return min - 1;
		// Build a bit array to find any gaps		
		BitArray b;
		int bits = max - min + 1;
		b.SetSize(bits);
		b.ClearAll();
		for(poly = 0; poly < polys; ++poly) {
			Spline3D *spline = shape->splines[poly];
			for(int seg = 0; seg < spline->Segments(); ++seg)
				b.Set(spline->GetMatID(seg) - min);
			}
		for(i = 0; i < bits; ++i) {
			if(!b[i])
				return (MtlID)(i + min);
			}
		// No gaps!  If room above, return it
		if(max < 65535)
			return max + 1;
		}
	return (MtlID)mtlID;
	}

BOOL EditSplineMod::HasFaceSelection(ModContext* mc) {
	// Are we the edited object?
	if (ip == NULL)  return FALSE;

	EditSplineData *shapeData = (EditSplineData*)mc->localData;
	if ( !shapeData ) return FALSE;

	// If the mesh isn't yet cache, this will cause it to get cached.
	BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
	if(!shape) return FALSE;

	// Is Segment selection active?
	if (selLevel == ES_SEGMENT) {
		for(int poly = 0; poly < shape->splineCount; ++poly)
			if(shape->segSel[poly].NumberSet()) return TRUE;
		}
	
	// Is Spline selection active?
	if (selLevel == ES_SPLINE && shape->polySel.sel.NumberSet()) return TRUE;
	
	return FALSE;
	}

void EditSplineMod::SetSelFaceMtlID(ModContext* mc, MtlID id, BOOL bResetUnsel) {
	int altered = 0;
	EditSplineData *shapeData = (EditSplineData*)mc->localData;
	if ( !shapeData ) return;

	// If the mesh isn't yet cache, this will cause it to get cached.
	BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
	if(!shape) return;
	
	// If this is the first edit, then the delta arrays will be allocated
	shapeData->BeginEdit(ip->GetTime());

	if ( theHold.Holding() )
		theHold.Put(new ShapeRestore(shapeData,this,shape));

	int polys = shape->splineCount;
	for(int poly = 0; poly < polys; ++poly) {
		Spline3D *spline = shape->splines[poly];
		BOOL polySelected = (GetSubobjectLevel() == ES_SPLINE) ? shape->polySel[poly] : FALSE;
		BitArray &sel = shape->segSel[poly];
		for(int seg = 0; seg < spline->Segments(); ++seg) {
			BOOL segSelected = (GetSubobjectLevel() == ES_SEGMENT) ? sel[seg] : FALSE;
			if(polySelected || segSelected) {
				altered = TRUE;
				spline->SetMatID(seg, id);
				}
			}
		}

	if(altered)	{
		shapeData->UpdateChanges(shape, FALSE);
		InvalidateSurfaceUI();
		}

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

int	EditSplineMod::GetSelFaceUniqueMtlID(ModContext* mc) {
	int	mtlID;

	mtlID = GetSelFaceAnyMtlID(mc);
	if (mtlID == -1) return mtlID;

	EditSplineData *shapeData = (EditSplineData*)mc->localData;
	if ( !shapeData ) return 1;

	// If the mesh isn't yet cache, this will cause it to get cached.
	BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
	if(!shape) return 1;

	int polys = shape->splineCount;
	for(int poly = 0; poly < polys; ++poly) {
		Spline3D *spline = shape->splines[poly];
		BOOL polySelected = (GetSubobjectLevel() == ES_SPLINE) ? shape->polySel[poly] : FALSE;
		BitArray &sel = shape->segSel[poly];
		for(int seg = 0; seg < spline->Segments(); ++seg) {
			BOOL segSelected = (GetSubobjectLevel() == ES_SEGMENT) ? sel[seg] : FALSE;
			if(polySelected || segSelected)
				continue;
			if(spline->GetMatID(seg) != mtlID)
				continue;
			mtlID = -1;
			}
		}
	return mtlID;
	}

int	EditSplineMod::GetSelFaceAnyMtlID(ModContext* mc) {
	int				mtlID = -1;
	BOOL			bGotFirst = FALSE;

	EditSplineData *shapeData = (EditSplineData*)mc->localData;
	if ( !shapeData ) return 1;

	// If the mesh isn't yet cache, this will cause it to get cached.
	BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
	if(!shape) return 1;

	int polys = shape->splineCount;
	for(int poly = 0; poly < polys; ++poly) {
		Spline3D *spline = shape->splines[poly];
		BOOL polySelected = (GetSubobjectLevel() == ES_SPLINE) ? shape->polySel[poly] : FALSE;
		BitArray &sel = shape->segSel[poly];
		for(int seg = 0; seg < spline->Segments(); ++seg) {
			BOOL segSelected = (GetSubobjectLevel() == ES_SEGMENT) ? sel[seg] : FALSE;
			if(!polySelected && !segSelected)
				continue;
			if (bGotFirst) {
				if (mtlID != spline->GetMatID(seg)) {
					mtlID = -1;
					break;
					}
				}
			else {
				mtlID = spline->GetMatID(seg);
				bGotFirst = TRUE;
				}
			}
		}

	return mtlID;
	}

int	EditSplineMod::GetMaxMtlID(ModContext* mc) {
	MtlID mtlID = 0;

	EditSplineData *shapeData = (EditSplineData*)mc->localData;
	if ( !shapeData ) return 1;

	// If the mesh isn't yet cache, this will cause it to get cached.
	BezierShape *shape = shapeData->TempData(this)->GetShape(ip->GetTime());
	if(!shape) return 1;

	int polys = shape->splineCount;
	for(int poly = 0; poly < polys; ++poly) {
		Spline3D *spline = shape->splines[poly];
		for(int seg = 0; seg < spline->Segments(); ++seg)
			mtlID = max(mtlID, spline->GetMatID(seg));
		}

	return mtlID;
	}

//2-1-99 watje

void EditSplineMod::DoVertFuse() {


	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearShapeDataFlag(mcList,ESD_BEENDONE);

	int oldVerts = 0;
	int newVerts = 0;

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditSplineData *shapeData = (EditSplineData*)mcList[i]->localData;
		if ( !shapeData ) continue;
		if ( shapeData->GetFlag(ESD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		BezierShape *shape = shapeData->TempData(this)->GetShape(t);
		if(!shape) continue;
		shapeData->RecordTopologyTags(shape);



		// Add the original number of knots to the oldVerts field
		for(int poly = 0; poly < shape->splineCount; ++poly)
			oldVerts += shape->splines[poly]->KnotCount();

		// If this is the first edit, then the delta arrays will be allocated
		shapeData->BeginEdit(t);


		if ( theHold.Holding() ) {
			theHold.Put(new ShapeRestore(shapeData,this,shape));
			}

//watje now move any verts thta are within the weld tolerance onto each other
//build list 
		Tab<WeldList> weldList;
		for(poly = 0; poly < shape->splineCount; ++poly)
			{
			BitArray pSel = shape->VertexTempSel(poly);
			for (int i = 0; i < pSel.GetSize()/3; i++)
				{
				if(pSel[(i*3)+1]) 
					{
					WeldList w;
					w.used = -1;
					w.splineID =poly;
					w.knotID = i;
					w.p = shape->splines[poly]->GetKnotPoint(i);
					weldList.Append(1,&w,1);
					}
				}
			}
		int ct = weldList.Count();
		if (ct >0)
			{
			altered = holdNeeded = TRUE;
			Point3 avgPoint(0.0f,0.0f,0.0f);
			int pointCount = 0;
			for (int j = 0; j < weldList.Count(); j++)
				{
				avgPoint += weldList[j].p;
				pointCount++;
				}
			avgPoint = avgPoint/(float)pointCount;
			for (j = 0; j < weldList.Count(); j++)
				{
				weldList[j].p = avgPoint;
				}
//now put them back in the knot list
			for (int i = 0; i < weldList.Count(); i++)
				{
				int polyID = weldList[i].splineID;
				int knotID = weldList[i].knotID;
//10-4-99 211610 
//get vec from point to average
				Point3 vec;
				vec = weldList[i].p-shape->splines[polyID]->GetKnotPoint(knotID);
				Point3 ivec,ovec;
				ivec = shape->splines[polyID]->GetInVec(knotID)+vec;
				ovec = shape->splines[polyID]->GetOutVec(knotID)+vec;
				shape->splines[polyID]->SetInVec(knotID,ivec);
				shape->splines[polyID]->SetOutVec(knotID,ovec);



				shape->splines[polyID]->SetKnotPoint(knotID,weldList[i].p);
				shape->splines[polyID]->ComputeBezPoints();

				}
			shape->InvalidateGeomCache();

			}

		if(altered) {
			shapeData->UpdateChanges(shape);
			shapeData->TempData(this)->Invalidate(PART_TOPO);
			}

		// Add the original number of knots to the oldVerts field
		for(poly = 0; poly < shape->splineCount; ++poly)
			newVerts += shape->splines[poly]->KnotCount();

		shapeData->SetFlag(ESD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		theHold.Accept(GetString(IDS_PW_FUSE));
		TSTR s1;
		int welded = oldVerts - newVerts;
		s1.printf(GetString(IDS_PW_FUSE), welded, oldVerts);
		ip->DisplayTempPrompt(s1,PROMPT_TIME);
		}
	else {
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearShapeDataFlag(mcList,ESD_BEENDONE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

/*
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	int oldVerts = 0;
	int newVerts = 0;
	BOOL altered = FALSE;

	theHold.Begin();
	if ( theHold.Holding() )
		theHold.Put(new SSRestore(this));
	RecordTopologyTags();
//watje now move any verts thta are within the weld tolerance onto each other
//build list 
	Tab<WeldList> weldList;
	for(int poly = 0; poly < shape.splineCount; ++poly)
		{
		BitArray pSel = shape.VertexTempSel(poly);
		for (int i = 0; i < pSel.GetSize()/3; i++)
			{
			if(pSel[(i*3)+1]) 
				{
				WeldList w;
				w.used = -1;
				w.splineID =poly;
				w.knotID = i;
				w.p = shape.splines[poly]->GetKnotPoint(i);
				weldList.Append(1,&w,1);
				}
			}
		}
	int ct = weldList.Count();
	if (ct >0)
		{
		altered = holdNeeded = TRUE;
		Point3 avgPoint(0.0f,0.0f,0.0f);
		int pointCount = 0;
		for (int j = 0; j < weldList.Count(); j++)
			{
			avgPoint += weldList[j].p;
			pointCount++;
			}
		avgPoint = avgPoint/(float)pointCount;
		for (j = 0; j < weldList.Count(); j++)
			{
			weldList[j].p = avgPoint;
			}
//now put them back in the knot list
		for (int i = 0; i < weldList.Count(); i++)
			{
			int polyID = weldList[i].splineID;
			int knotID = weldList[i].knotID;

			shape.splines[polyID]->SetKnotPoint(knotID,weldList[i].p);
			shape.splines[polyID]->ComputeBezPoints();

			}
		shape.InvalidateGeomCache();

		}


	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetResString(IDS_PW_VERTFUSED));
		}
	else {
		theHold.End();
		}

	SelectionChanged();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
*/
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Modifier\editpat.cpp ===
/**********************************************************************
 *<
	FILE: editpat.cpp

	DESCRIPTION:  Edit Patch OSM

	CREATED BY: Tom Hudson, Dan Silva & Rolf Berteig

	HISTORY: created 23 June, 1995

	IMPORTANT USAGE NOTE:

		When you do an operation in edit patch which will change the topology, the form
		of the code should look like this code, taken from the vertex deletion:

		-----

			ip->GetModContexts(mcList,nodes);
			ClearPatchDataFlag(mcList,EPD_BEENDONE);

			theHold.Begin();
		-->	RecordTopologyTags();
			for ( int i = 0; i < mcList.Count(); i++ ) {
				int altered = 0;
				EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
				if ( !patchData ) continue;
				if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

				// If the mesh isn't yet cache, this will cause it to get cached.
				PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
				if(!patch)
					continue;
		-->		patchData->RecordTopologyTags(patch);

				// If this is the first edit, then the delta arrays will be allocated
				patchData->BeginEdit(t);

				// If any bits are set in the selection set, let's DO IT!!
				if(patch->vertSel.NumberSet()) {
					altered = holdNeeded = 1;
					if ( theHold.Holding() )
						theHold.Put(new PatchRestore(patchData,this,patch,"DoVertDelete"));
					// Call the vertex delete function
					DeleteSelVerts(patch);
		-->			patchData->UpdateChanges(patch);
					patchData->TempData(this)->Invalidate(PART_TOPO);
					}
				patchData->SetFlag(EPD_BEENDONE,TRUE);
				}
			
			if(holdNeeded) {
		-->		ResolveTopoChanges();
				theHold.Accept(GetString(IDS_TH_VERTDELETE));
				}
			else {
				ip->DisplayTempPrompt(GetString(IDS_TH_NOVERTSSEL),PROMPT_TIME);
				theHold.End();
				}
			
			nodes.DisposeTemporary();
			ClearPatchDataFlag(mcList,EPD_BEENDONE);

		-----

		The key elements in the "changed topology" case are the calls noted by arrows.
		These record special tags inside the object so that after the topology is changed
		by the modifier code, the UpdateChanges code can make a new mapping from the old
		object topology to the new.

		If the operation doesn't change the topology, then the three topology tag calls
		aren't needed and the UpdateChanges call becomes:

			patchData->UpdateChanges(patch, FALSE);

		This tells UpdateChanges not to bother remapping the topology.

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "mods.h"
#include "editpat.h"
#include "decomp.h"

#define DBGWELD_DUMPx
#define DBGWELD_ACTIONx

#define DBG_NAMEDSELSx

// Uncomment this for vert mapper debugging
//#define VMAP_DEBUG 1

// Forward references
BOOL CALLBACK PatchSelectDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
BOOL CALLBACK PatchOpsDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
BOOL CALLBACK PatchObjSurfDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
BOOL CALLBACK PatchSurfDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

// A handy zero point
static Point3 zeroPoint(0,0,0);

// Our temporary prompts last 2 seconds:
#define PROMPT_TIME 2000

// in mods.cpp
extern HINSTANCE hInstance;

// Select by material parameters
static int sbmParams[2]     = {1,1};

// Select by smooth parameters
static DWORD sbsParams[3]   = {1,1,0};

HWND				EditPatchMod::hSelectPanel    = NULL;
HWND				EditPatchMod::hOpsPanel       = NULL;
HWND				EditPatchMod::hSurfPanel      = NULL;
BOOL				EditPatchMod::rsSel           = TRUE;
BOOL				EditPatchMod::rsOps           = TRUE;
BOOL				EditPatchMod::rsSurf          = TRUE;
IObjParam*          EditPatchMod::ip              = NULL;
MoveModBoxCMode*    EditPatchMod::moveMode        = NULL;
RotateModBoxCMode*  EditPatchMod::rotMode 	      = NULL;
UScaleModBoxCMode*  EditPatchMod::uscaleMode      = NULL;
NUScaleModBoxCMode* EditPatchMod::nuscaleMode     = NULL;
SquashModBoxCMode *	EditPatchMod::squashMode      = NULL;
SelectModBoxCMode*  EditPatchMod::selectMode      = NULL;
ISpinnerControl*	EditPatchMod::weldSpin        = NULL;
ISpinnerControl*	EditPatchMod::stepsSpin       = NULL;
//3-18-99 to suport render steps and removal of the mental tesselator
ISpinnerControl*	EditPatchMod::stepsRenderSpin       = NULL;

BOOL				EditPatchMod::settingViewportTess = FALSE;
BOOL				EditPatchMod::settingDisp     = FALSE;
ISpinnerControl*	EditPatchMod::uSpin           = NULL;
ISpinnerControl*	EditPatchMod::vSpin           = NULL;
ISpinnerControl*	EditPatchMod::edgeSpin        = NULL;
ISpinnerControl*	EditPatchMod::distSpin        = NULL;
ISpinnerControl*	EditPatchMod::angSpin         = NULL;
ISpinnerControl*	EditPatchMod::mergeSpin       = NULL;
ISpinnerControl*	EditPatchMod::matSpin         = NULL;
BOOL				EditPatchMod::patchUIValid    = TRUE;
PickPatchAttach		EditPatchMod::pickCB;
int					EditPatchMod::condenseMat     = FALSE;
int					EditPatchMod::attachMat       = ATTACHMAT_IDTOMAT;

static float weldThreshold = 0.1f;

// Checkbox items for rollup pages
static int lockedHandles = 0;
static int patchDetachCopy = 0;
static int patchDetachReorient = 0;
static int attachReorient = 0;
static BOOL filterVerts = TRUE;
static BOOL filterVecs = TRUE;


EPM_BindCMode*			EditPatchMod::bindMode   = NULL;
EPM_ExtrudeCMode*		EditPatchMod::extrudeMode   = NULL;
EPM_BevelCMode*			EditPatchMod::bevelMode   = NULL;


static void SetVertFilter() {
	patchHitLevel[EP_VERTEX] = (filterVerts ? SUBHIT_PATCH_VERTS : 0) | (filterVecs ? SUBHIT_PATCH_VECS : 0);
	}

// This is a special override value which allows us to hit-test on
// any sub-part of a patch

int patchHitOverride = 0;	// If zero, no override is done

void SetPatchHitOverride(int value) {
	patchHitOverride = value;
	}

void ClearPatchHitOverride() {
	patchHitOverride = 0;
	}

/*-------------------------------------------------------------------*/

static HIMAGELIST hFaceImages = NULL;
static void LoadImages() {
	if (hFaceImages) return;

	HBITMAP hBitmap, hMask;
	hFaceImages = ImageList_Create(24, 23, ILC_COLOR|ILC_MASK, 6, 0);
	hBitmap     = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_PATCHSELTYPES));
	hMask       = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_PATCHSELMASK));
	ImageList_Add(hFaceImages,hBitmap,hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
}

class EPImageListDestroyer {
	~EPImageListDestroyer() {
		if(hFaceImages)
			ImageList_Destroy(hFaceImages);
		}
	};

/*-------------------------------------------------------------------*/

class PatchDeleteUser : public EventUser {
	private:
		EditPatchMod *ep;
	public:
		void Notify() { ep->DoDeleteSelected(); }
		void SetMod(EditPatchMod *ep) { this->ep = ep; }
	};

static PatchDeleteUser pDel;

class PatchRightMenu : public RightClickMenu {
	private:
		EditPatchMod *ep;
	public:
		void Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m);
		void Selected(UINT id);
		void SetMod(EditPatchMod *ep) { this->ep = ep; }
	};

void PatchRightMenu::Init(RightClickMenuManager* manager, HWND hWnd, IPoint2 m) {
	switch(ep->GetSubobjectLevel()) {
		case EP_VERTEX:
			if(ep->RememberVertThere(hWnd, m)) {
				int oldType = -1;
				int flags1, flags2;
				flags1 = flags2 = MF_STRING;
				switch(ep->rememberedData) {
					case PVERT_COPLANAR:
						flags1 |= MF_CHECKED;
						break;
					case 0:
						flags2 |= MF_CHECKED;
						break;
					}
				manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
				manager->AddMenu(this, flags1, PVERT_COPLANAR, GetString(IDS_TH_COPLANAR));
				manager->AddMenu(this, flags2, 0, GetString(IDS_TH_CORNER));
				}
			break;
		case EP_PATCH:
			if(ep->RememberPatchThere(hWnd, m)) {
				int oldType = -1;
				int flags1, flags2;
				flags1 = flags2 = MF_STRING;
				switch(ep->rememberedData) {
					case PATCH_AUTO:
						flags1 |= MF_CHECKED;
						break;
					case 0:
						flags2 |= MF_CHECKED;
						break;
					}
				manager->AddMenu(this, MF_SEPARATOR, 0, NULL);
				manager->AddMenu(this, flags1, PATCH_AUTO, GetString(IDS_TH_AUTOINTERIOR));
				manager->AddMenu(this, flags2, 0, GetString(IDS_TH_MANUALINTERIOR));
				}
			break;
		}
	}

void PatchRightMenu::Selected(UINT id) {
	switch(ep->GetSubobjectLevel()) {
		case EP_VERTEX:
			ep->SetRememberedVertType((int)id);
			break;
		case EP_PATCH:
			ep->SetRememberedPatchType((int)id);
			break;
		}
	}

PatchRightMenu pMenu;

/*-------------------------------------------------------------------*/

static
BOOL IsCompatible(BitArray &a, BitArray &b) {
	return (a.GetSize() == b.GetSize()) ? TRUE : FALSE;
	}


//--- Named Selection Set Methods ------------------------------------

// Used by EditPatchMod destructor to free pointers
void EditPatchMod::ClearSetNames()
	{
	for (int i=0; i<3; i++) {
		for (int j=0; j<namedSel[i].Count(); j++) {
			delete namedSel[i][j];
			namedSel[i][j] = NULL;
			}
		}
	}

int EditPatchMod::FindSet(TSTR &setName,int level)
	{	
	assert(level>0 && level<4);
	for (int i=0; i<namedSel[level-1].Count(); i++) {
		if (setName == *namedSel[level-1][i]) {
			return i;			
			}
		}
	return -1;
	}

void EditPatchMod::AddSet(TSTR &setName,int level)
	{
	assert(level>0 && level<4);
	TSTR *name = new TSTR(setName);
	namedSel[level-1].Append(1,&name);
	}

void EditPatchMod::RemoveSet(TSTR &setName,int level)
	{
	MaybeFixupNamedSels();
	assert(level>0 && level<4);
	int i = FindSet(setName,level);
	if (i>=0) {
		delete namedSel[level-1][i];
		namedSel[level-1].Delete(i,1);
		}
	}

static void AssignSetMatchSize(BitArray &dst, BitArray &src)
	{
	int size = dst.GetSize();
	dst = src;
	if (dst.GetSize() != size) {
		dst.SetSize(size,TRUE);
		}
	}

void EditPatchMod::ActivateSubSelSet(TSTR &setName)
	{
	MaybeFixupNamedSels();
	ModContextList mcList;
	INodeTab nodes;
	int index = FindSet(setName,selLevel);
	if (index<0 || !ip) return;	

	ip->GetModContexts(mcList,nodes);

	theHold.Begin();
	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;
		patchData->BeginEdit(ip->GetTime());
		// If that set exists in this context, deal with it
		GenericNamedSelSetList &sel = patchData->GetSelSet(this);
		BitArray *set = sel.GetSet(setName);
		if(set) {
			if (theHold.Holding())
				theHold.Put(new PatchSelRestore(patchData,this,patch));
			BitArray *psel = GetLevelSelectionSet(patch);	// Get the appropriate selection set
			AssignSetMatchSize(*psel, *set);				
			PatchSelChanged();
			}

		patchData->UpdateChanges(patch, FALSE);
		if (patchData->tempData)
			patchData->TempData(this)->Invalidate(PART_SELECT);
		}
	
	theHold.Accept(GetString(IDS_DS_SELECT));
	nodes.DisposeTemporary();	
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

void EditPatchMod::NewSetFromCurSel(TSTR &setName)
	{
	MaybeFixupNamedSels();

	ModContextList mcList;
	INodeTab nodes;	
	if (!ip) return;
	
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;
		GenericNamedSelSetList &sel = patchData->GetSelSet(this);
		BitArray *exist = sel.GetSet(setName);	
		switch (selLevel) {
			case EP_VERTEX:	
				if (exist) {
					*exist = patch->vertSel;
				} else {
					patchData->vselSet.AppendSet(patch->vertSel, 0, setName);
					}
				break;

			case EP_PATCH:
				if (exist) {
					*exist = patch->patchSel;
				} else {
					patchData->pselSet.AppendSet(patch->patchSel, 0, setName);
					}
				break;

			case EP_EDGE:
				if (exist) {
					*exist = patch->edgeSel;
				} else {
					patchData->eselSet.AppendSet(patch->edgeSel, 0, setName);
					}
				break;
			}
		}	
	
	int index = FindSet(setName,selLevel);
	if (index<0)
		AddSet(setName,selLevel);		
	nodes.DisposeTemporary();
	}

void EditPatchMod::RemoveSubSelSet(TSTR &setName)
	{
	MaybeFixupNamedSels();

	ModContextList mcList;
	INodeTab nodes;

	if (!ip) return;	
	
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;		
		patchData->BeginEdit(ip->GetTime());
		GenericNamedSelSetList &sel = patchData->GetSelSet(this);
		sel.RemoveSet(setName);
		}
	// Remove the modifier's entry
	RemoveSet(setName,selLevel);
	ip->ClearCurNamedSelSet();
	SetupNamedSelDropDown();
	nodes.DisposeTemporary();
	}

void EditPatchMod::SetupNamedSelDropDown()
	{
	// Setup named selection sets	
	if (selLevel == EP_OBJECT)
		return;
	ip->ClearSubObjectNamedSelSets();
	for (int i=0; i<namedSel[selLevel-1].Count(); i++)
		ip->AppendSubObjectNamedSelSet(*namedSel[selLevel-1][i]);
	}

int EditPatchMod::NumNamedSelSets() {
	if(GetSubobjectLevel() == PO_OBJECT)
		return 0;
	return namedSel[selLevel-1].Count();
	}

TSTR EditPatchMod::GetNamedSelSetName(int i) {
	return *namedSel[selLevel-1][i];
	}

class EPSelSetNameRestore : public RestoreObj {
	public:
		TSTR undo, redo;
		TSTR *target;
		EditPatchMod *mod;
		EPSelSetNameRestore(EditPatchMod *m, TSTR *t, TSTR &newName) {
			mod = m;
			undo = *t;
			target = t;
			}
		void Restore(int isUndo) {			
			if(isUndo)
				redo = *target;
			*target = undo;
			if (mod->ip)
				mod->ip->NamedSelSetListChanged();
			}
		void Redo() {
			*target = redo;
			if (mod->ip)
				mod->ip->NamedSelSetListChanged();
			}
				
		TSTR Description() {return TSTR(_T("Sel Set Name"));}
	};

void EditPatchMod::SetNamedSelSetName(int index, TSTR &newName) {
	if(!ip) return;
	MaybeFixupNamedSels();

	// First do the master name list
	if (theHold.Holding())
		theHold.Put(new EPSelSetNameRestore(this, namedSel[selLevel-1][index], newName));

	// Save the old name so we can change those in the EditPatchData
	TSTR oldName = *namedSel[selLevel-1][index];
	*namedSel[selLevel-1][index] = newName;

	ModContextList mcList;
	INodeTab nodes;
	
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (patchData)
			patchData->GetSelSet(this).RenameSet(oldName, newName);
		}
	nodes.DisposeTemporary();
	}

void EditPatchMod::NewSetByOperator(TSTR &newName,Tab<int> &sets,int op) {
	MaybeFixupNamedSels();

	// First do it in the master name list
	AddSet(newName,selLevel);		
// TO DO: Undo?
	ModContextList mcList;
	INodeTab nodes;	

	if (!ip) return;
	
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData ) continue;		
		GenericNamedSelSetList &set = patchData->GetSelSet(this);
		BitArray bits = *set.GetSetByIndex(sets[0]);
		for (i=1; i<sets.Count(); i++) {
			BitArray *bit2 = set.GetSetByIndex(sets[i]);
			switch (op) {
				case NEWSET_MERGE:
					bits |= *bit2;
					break;

				case NEWSET_INTERSECTION:
					bits &= *bit2;
					break;

				case NEWSET_SUBTRACT:
					bits &= ~(*bit2);
					break;
				}
			}
		set.AppendSet(bits,0,newName);
		}	
	
	nodes.DisposeTemporary();
	}

// Named selection set copy/paste methods follow...

static BOOL CALLBACK PickSetNameDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static TSTR *name;

	switch (msg) {
		case WM_INITDIALOG: {
			name = (TSTR*)lParam;
			ICustEdit *edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
			edit->SetText(*name);
			ReleaseICustEdit(edit);
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ICustEdit *edit =GetICustEdit(GetDlgItem(hWnd,IDC_SET_NAME));
					TCHAR buf[256];
					edit->GetText(buf,256);
					*name = TSTR(buf);
					ReleaseICustEdit(edit);
					EndDialog(hWnd,1);
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		};
	return TRUE;
	}

BOOL EditPatchMod::GetUniqueSetName(TSTR &name) {
	while (1) {		
		if(FindSet(name, selLevel) < 0)
			break;

		if (!DialogBoxParam(
			hInstance, 
			MAKEINTRESOURCE(IDD_PASTE_NAMEDSET),
			ip->GetMAXHWnd(), 
			PickSetNameDlgProc,
			(LPARAM)&name)) return FALSE;		
		}
	return TRUE;
	}

static BOOL CALLBACK PickSetDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{	
	switch (msg) {
		case WM_INITDIALOG:	{
			Tab<TSTR*> &names = *((Tab<TSTR*>*)lParam);
			for (int i=0; i<names.Count(); i++) {
				int pos  = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_ADDSTRING,0,
					(LPARAM)(TCHAR*)*names[i]);
				SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_SETITEMDATA,pos,i);
				}
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_NS_LIST:
					if (HIWORD(wParam)!=LBN_DBLCLK) break;
					// fall through
				case IDOK: {
					int sel = SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETCURSEL,0,0);
					if (sel!=LB_ERR) {
						int res =SendDlgItemMessage(hWnd,IDC_NS_LIST,LB_GETITEMDATA,sel,0);
						EndDialog(hWnd,res);
						break;
						}
					// fall through
					}

				case IDCANCEL:
					EndDialog(hWnd,-1);
					break;
				}
			break;

		default:
			return FALSE;
		};
	return TRUE;
	}

int EditPatchMod::SelectNamedSet() {
	Tab<TSTR*> names = namedSel[selLevel-1];
	return DialogBoxParam(
		hInstance, 
		MAKEINTRESOURCE(IDD_SEL_NAMEDSET),
		ip->GetMAXHWnd(), 
		PickSetDlgProc,
		(LPARAM)&names);
	}

void EditPatchMod::NSCopy() {
	MaybeFixupNamedSels();
	if (selLevel == EP_OBJECT) return;
	int index = SelectNamedSet();
	if(index < 0) return;
	if(!ip) return;
	// Get the name for that index
	int nsl = namedSetLevel[selLevel];
	TSTR setName = *namedSel[nsl][index];
	PatchNamedSelClip *clip = new PatchNamedSelClip(setName);

	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;

		GenericNamedSelSetList &setList = patchData->GetSelSet(this);
		BitArray *set = setList.GetSet(setName);
		if(set) {
			BitArray *bits = new BitArray(*set);
			clip->sets.Append(1,&bits);
			}
		}
	SetPatchNamedSelClip(clip, namedClipLevel[selLevel]);

	// Enable the paste button
	ICustButton *but = GetICustButton(GetDlgItem(hSelectPanel,IDC_NS_PASTE));
	but->Enable();
	ReleaseICustButton(but);
	}

void EditPatchMod::NSPaste() {
	MaybeFixupNamedSels();
	if (selLevel == EP_OBJECT) return;
	int nsl = namedSetLevel[selLevel];
	PatchNamedSelClip *clip = GetPatchNamedSelClip(namedClipLevel[selLevel]);
	if (!clip) return;
	TSTR name = clip->name;
	if (!GetUniqueSetName(name)) return;
	if(!ip) return;

	ModContextList mcList;
	INodeTab nodes;

	AddSet(name, selLevel);

	ip->GetModContexts(mcList,nodes);
	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;

		GenericNamedSelSetList & setList = patchData->GetSelSet(this);

		if (i>=clip->sets.Count()) {
			BitArray bits;
			setList.AppendSet(bits, 0, name);
			}
		else
			setList.AppendSet(*clip->sets[i], 0, name);
		}	
	
	ActivateSubSelSet(name);
	ip->SetCurNamedSelSet(name);
	SetupNamedSelDropDown();
	}

// Old MAX files (pre-r3) have EditPatchData named selections without names assigned.  This
// assigns them their proper names for r3 and later code.  If no fixup is required, this does nothing.
void EditPatchMod::MaybeFixupNamedSels() {
	int i;
	if(!ip) return;

	// Go thru the modifier contexts, and stuff the named selection names into the EditPatchData
	ModContextList mcList;
	INodeTab nodes;
	
	ip->GetModContexts(mcList,nodes);

#ifdef DBG_NAMEDSELS
	DebugPrint("Context/named sels:\n");
	for (i=0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;		

		// Go thru each subobject level
		for(int j = 0; j < 3; ++j) {
			GenericNamedSelSetList &pdSel = patchData->GetSelSet(j);
			for(int k = 0; k < pdSel.Count(); ++k)
				DebugPrint("Context %d, level %d, set %d: [%s]\n", i, j, k, *pdSel.names[k]);
			}
		}	
#endif //DBG_NAMEDSELS

	if(!namedSelNeedsFixup) {
#ifdef DBG_NAMEDSELS
		DebugPrint("!!! NO FIXUP REQUIRED !!!\n");
#endif //DBG_NAMEDSELS
		return;
		}

#ifdef DBG_NAMEDSELS
	DebugPrint("*** Fixing up named sels ***\n");
#endif //DBG_NAMEDSELS

	for (i=0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;		

		// Go thru each subobject level
		for(int j = 0; j < 3; ++j) {
			Tab<TSTR*> &mSel = namedSel[j];
			GenericNamedSelSetList &pdSel = patchData->GetSelSet(j);
			// Some old files may have improper counts in the EditPatchData.  Limit the counter
			int mc = mSel.Count();
			int pdc = pdSel.Count();
			int limit = (mc < pdc) ? mc : pdc;
#ifdef DBG_NAMEDSELS
			if(mc != pdc)
				DebugPrint("****** mSel.Count=%d, pdSel.Count=%d ******\n", mc, pdc);
#endif //DBG_NAMEDSELS
			for(int k = 0; k < limit; ++k)
				*pdSel.names[k] = *mSel[k];
			}
		}	
	
	nodes.DisposeTemporary();
	namedSelNeedsFixup = FALSE;
	}

void EditPatchMod::RemoveAllSets()
	{
	ModContextList mcList;
	INodeTab nodes;
	
	if (!ip) return;	
	
	ip->GetModContexts(mcList,nodes);

	for (int i=0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;		
		
		int j;
		for (j=patchData->vselSet.Count()-1; j>=0; j--) {
			patchData->vselSet.DeleteSet(j);
			}
		for (j=patchData->pselSet.Count()-1; j>=0; j--) {
			patchData->pselSet.DeleteSet(j);
			}
		for (j=patchData->eselSet.Count()-1; j>=0; j--) {
			patchData->eselSet.DeleteSet(j);
			}		
		}	
	
	for (int j=0; j<3; j++) {
		for (int i=0; i<namedSel[j].Count(); i++) {
			delete namedSel[j][i];		
			}
		namedSel[j].Resize(0);
		}

	ip->ClearCurNamedSelSet();
	ip->ClearSubObjectNamedSelSets();
	nodes.DisposeTemporary();
	}


/*-------------------------------------------------------------------*/

// Deletes any vertices tagged, also any patches tagged.  Automatically deletes the vectors that
// are deleted as a result of the patch deletion and sweeps any vertices floating in space.

static void DeletePatchParts(PatchMesh *patch, BitArray &delVerts, BitArray &delPatches) {
	int patches = patch->getNumPatches();
	int verts = patch->getNumVerts();
	int vecs = patch->getNumVecs();
	int dest;

	// We treat vectors specially in order to clean up after welds.  First, we tag 'em all,
	// then untag only those on unselected patches so that any dangling vectors will be deleted.
	BitArray delVectors(vecs);
	delVectors.SetAll();

	// Untag vectors that are on nondeleted patches
	for(int i = 0; i < patches; ++i) {
		if(!delPatches[i]) {
			Patch& p = patch->patches[i];
			for(int j = 0; j < (p.type * 2); ++j) {
				delVectors.Clear(p.vec[j]);
				}
			for(j = 0; j < p.type; ++j)
				delVectors.Clear(p.interior[j]);
			}
		}

	// Make a table of vertices that are still in use -- Used to
	// delete those vertices which are floating, unused, in space.
	BitArray usedVerts(verts);
	usedVerts.ClearAll();
	for(i = 0; i < patches; ++i) {
		if(!delPatches[i]) {
			Patch& p = patch->patches[i];
			for(int j = 0; j < p.type; ++j) {
				usedVerts.Set(p.v[j]);
				}
			}
		}
	for(i = 0; i < verts; ++i) {
		if(!usedVerts[i])
			delVerts.Set(i);
		}

	// If we have texture vertices, handle them, too
	for(int chan = 0; chan < patch->getNumMaps(); ++chan) {
		int tverts = patch->numTVerts[chan];
		if(tverts && patch->tvPatches[chan]) {
			BitArray delTVerts(tverts);
			delTVerts.SetAll();
			for(i = 0; i < patches; ++i) {
				if(!delPatches[i]) {
					Patch& p = patch->patches[i];
					TVPatch& tp = patch->tvPatches[chan][i];
					for(int j = 0; j < p.type; ++j)
						delTVerts.Clear(tp.tv[j]);
					}
				}
			// Got the list of tverts to delete -- now delete 'em
			// Build a table of redirected texture vertex indices
			int newTVerts = tverts - delTVerts.NumberSet();
			IntTab tVertIndex;
			tVertIndex.SetCount(tverts);
			UVVert *newTVertArray = new UVVert[newTVerts];
			dest = 0;
			for(i = 0; i < tverts; ++i) {
				if(!delTVerts[i]) {
					newTVertArray[dest] = patch->tVerts[chan][i];
					tVertIndex[i] = dest++;
					}
				}
			delete[] patch->tVerts[chan];
			patch->tVerts[chan] = newTVertArray;
			patch->numTVerts[chan] = newTVerts;
			// Now, copy the untagged texture patches to a new array
			// While you're at it, redirect the vertex indices
			int newTVPatches = patches - delPatches.NumberSet();
			TVPatch *newArray = new TVPatch[newTVPatches];
			dest = 0;
			for(i = 0; i < patches; ++i) {
				if(!delPatches[i]) {
					Patch& p = patch->patches[i];
					TVPatch& tp = newArray[dest++];
					tp = patch->tvPatches[chan][i];
					for(int j = 0; j < p.type; ++j)
						tp.tv[j] = tVertIndex[tp.tv[j]];
					}
				}
			delete[] patch->tvPatches[chan];
			patch->tvPatches[chan] = newArray;;
			}
		}

	// Build a table of redirected vector indices
	IntTab vecIndex;
	vecIndex.SetCount(vecs);
	int newVectors = vecs - delVectors.NumberSet();
	PatchVec *newVecArray = new PatchVec[newVectors];
	dest = 0;
	for(i = 0; i < vecs; ++i) {
		if(!delVectors[i]) {
			newVecArray[dest] = patch->vecs[i];
			vecIndex[i] = dest++;
			}
		else
			vecIndex[i] = -1;
		}
	delete[] patch->vecs;
	patch->vecs = newVecArray;
	patch->numVecs = newVectors;

	// Build a table of redirected vertex indices
	int newVerts = verts - delVerts.NumberSet();
	IntTab vertIndex;
	vertIndex.SetCount(verts);
	PatchVert *newVertArray = new PatchVert[newVerts];
	BitArray newVertSel(newVerts);
	newVertSel.ClearAll();
	dest = 0;
	for(i = 0; i < verts; ++i) {
		if(!delVerts[i]) {
			newVertArray[dest] = patch->verts[i];
			newVertSel.Set(dest, patch->vertSel[i]);
			// redirect & adjust attached vector list
			PatchVert& v = newVertArray[dest];
			for(int j = 0; j < v.vectors.Count(); ++j) {
				v.vectors[j] = vecIndex[v.vectors[j]];
				if(v.vectors[j] < 0) {
					v.vectors.Delete(j, 1);
					j--;	// realign index
					}
				}
			vertIndex[i] = dest++;
			}
		}
	delete[] patch->verts;
	patch->verts = newVertArray;
	patch->numVerts = newVerts;
	patch->vertSel = newVertSel;

	// Now, copy the untagged patches to a new array
	// While you're at it, redirect the vertex and vector indices
	int newPatches = patches - delPatches.NumberSet();
	Patch *newArray = new Patch[newPatches];
	BitArray newPatchSel(newPatches);
	newPatchSel.ClearAll();
	dest = 0;
	for(i = 0; i < patches; ++i) {
		if(!delPatches[i]) {
			newArray[dest] = patch->patches[i];
			Patch& p = newArray[dest];
			for(int j = 0; j < p.type; ++j)
				p.v[j] = vertIndex[p.v[j]];
			for(j = 0; j < (p.type * 2); ++j)
				p.vec[j] = vecIndex[p.vec[j]];
			for(j = 0; j < p.type; ++j)
				p.interior[j] = vecIndex[p.interior[j]];
			newPatchSel.Set(dest++, patch->patchSel[i]);
			}
		}
	delete[] patch->patches;
	patch->patches = newArray;;
	patch->numPatches = newPatches;
	patch->patchSel.SetSize(newPatches,TRUE);
	patch->patchSel = newPatchSel;
	patch->buildLinkages();
	}

/*-------------------------------------------------------------------*/

// This function checks the current command mode and resets it to CID_OBJMOVE if
// it's one of our command modes

static
void CancelEditPatchModes(IObjParam *ip) {
	switch(ip->GetCommandMode()->ID()) {
		case CID_STDPICK:
			ip->SetStdCommandMode( CID_OBJMOVE );
			break;
		}
	}

// This gets rid of two-step modes, like booleans.  This is necessary because
// the first step, which activates the mode button, validates the selection set.
// If the selection set changes, the mode must be turned off because the new
// selection set may not be valid for the mode.
static
void Cancel2StepPatchModes(IObjParam *ip) {
//	switch(ip->GetCommandMode()->ID()) {
//		case CID_BOOLEAN:
//			ip->SetStdCommandMode( CID_OBJMOVE );
//			break;
//		}
	}

/*-------------------------------------------------------------------*/

static
TSTR detachName;

static
BOOL CALLBACK DetachDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
	TCHAR tempName[256];
	switch(message) {
		case WM_INITDIALOG:
			SetDlgItemText(hDlg, IDC_DETACH_NAME, detachName);
			SetFocus(GetDlgItem(hDlg, IDC_DETACH_NAME));
			return FALSE;
		case WM_COMMAND:
			switch(LOWORD(wParam)) {
				case IDOK:
					GetDlgItemText(hDlg, IDC_DETACH_NAME, tempName, 255);
					detachName = TSTR(tempName);
					EndDialog(hDlg, 1);
					return TRUE;
				case IDCANCEL:
					EndDialog(hDlg, 0);
					return TRUE;
			}
		}
	return FALSE;
	}

static
int GetDetachOptions(IObjParam *ip, TSTR& newName) {
	detachName = newName;
	ip->MakeNameUnique(detachName);	
	if(DialogBox(hInstance, MAKEINTRESOURCE(IDD_DETACH), ip->GetMAXHWnd(), (DLGPROC)DetachDialogProc)==1) {
		newName = detachName;
		return 1;
		}
	return 0;
	}

/*-------------------------------------------------------------------*/

static EditPatchClassDesc editPatchDesc;
extern ClassDesc* GetEditPatchModDesc() { return &editPatchDesc; }

void EditPatchClassDesc::ResetClassParams(BOOL fileReset)
	{
	sbmParams[0]   = 1;
	sbmParams[1]   = 1;
	EditPatchMod::condenseMat = FALSE;
	EditPatchMod::attachMat = ATTACHMAT_IDTOMAT;
	}

/*-------------------------------------------------------------------*/

PatchPointTab::PatchPointTab() {
	}

PatchPointTab::~PatchPointTab() {
	}

void PatchPointTab::Empty() {
	ptab.Delete(0, ptab.Count());
	vtab.Delete(0, vtab.Count());
	pttab.Delete(0, pttab.Count());
	}

void PatchPointTab::Zero() {
//DebugPrint("Zeroing\n");
	int points = ptab.Count();
	int vectors = vtab.Count();
	Point3 zero(0, 0, 0);

	for(int i = 0; i < points; ++i) {
		ptab[i] = zero;
		pttab[i] = 0;
		}
	for(i = 0; i < vectors; ++i)
		vtab[i] = zero;
	}

void PatchPointTab::MakeCompatible(PatchMesh& patch,int clear) {
	int izero = 0;
	if(clear) {
		ptab.Delete(0, ptab.Count());
		pttab.Delete(0, pttab.Count());
		vtab.Delete(0, vtab.Count());
		}
	// First, the verts
	int size = patch.numVerts;
	if(ptab.Count() > size) {
		int diff = ptab.Count() - size;
		ptab.Delete( ptab.Count() - diff, diff );
		pttab.Delete( pttab.Count() - diff, diff );
		}
	if(ptab.Count() < size) {
		int diff = size - ptab.Count();
		ptab.Resize( size );
		pttab.Resize( size );
		for( int j = 0; j < diff; j++ ) {
			ptab.Append(1,&zeroPoint);
			pttab.Append(1,&izero);
			}
		}
	// Now, the vectors
	size = patch.numVecs;
	if(vtab.Count() > size) {
		int diff = vtab.Count() - size;
		vtab.Delete( vtab.Count() - diff, diff );
		}
	if(vtab.Count() < size) {
		int diff = size - vtab.Count();
		vtab.Resize( size );
		for( int j = 0; j < diff; j++ )
			vtab.Append(1,&zeroPoint);
		}
	}

PatchPointTab& PatchPointTab::operator=(PatchPointTab& from) {
	ptab = from.ptab;
	vtab = from.vtab;
	pttab = from.pttab;
	return *this;
	}

BOOL PatchPointTab::IsCompatible(PatchMesh &patch) {
	if(ptab.Count() != patch.numVerts)
		return FALSE;
	if(pttab.Count() != patch.numVerts)
		return FALSE;
	if(vtab.Count() != patch.numVecs)
		return FALSE;
	return TRUE;
	}

void PatchPointTab::RescaleWorldUnits(float f) {
	Matrix3 stm = ScaleMatrix(Point3(f, f, f));
	int points = ptab.Count();
	int vectors = vtab.Count();

	for(int i = 0; i < points; ++i)
		ptab[i] = ptab[i] * stm;
	for(i = 0; i < vectors; ++i)
		vtab[i] = vtab[i] * stm;
	}

#define PPT_VERT_CHUNK		0x1000
#define PPT_VEC_CHUNK		0x1010
#define PPT_VERTTYPE_CHUNK	0x1020

IOResult PatchPointTab::Save(ISave *isave) {	
	int i;
	ULONG nb;
	isave->BeginChunk(PPT_VERT_CHUNK);
	int count = ptab.Count();
	isave->Write(&count,sizeof(int),&nb);
	for(i = 0; i < count; ++i)
		isave->Write(&ptab[i],sizeof(Point3),&nb);
	isave->EndChunk();
	isave->BeginChunk(PPT_VERTTYPE_CHUNK);
	count = pttab.Count();
	isave->Write(&count,sizeof(int),&nb);
	for(i = 0; i < count; ++i)
		isave->Write(&pttab[i],sizeof(int),&nb);
	isave->EndChunk();
	isave->BeginChunk(PPT_VEC_CHUNK);
	count = vtab.Count();
	isave->Write(&count,sizeof(int),&nb);
	for(i = 0; i < count; ++i)
		isave->Write(&vtab[i],sizeof(Point3),&nb);
	isave->EndChunk();
	return IO_OK;
	}

IOResult PatchPointTab::Load(ILoad *iload) {	
	int i, count;
	Point3 workpt;
	int workint;
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PPT_VERT_CHUNK:
				ptab.Delete(0,ptab.Count());
				iload->Read(&count,sizeof(int),&nb);
				for(i = 0; i < count; ++i) {
					iload->Read(&workpt,sizeof(Point3),&nb);
					ptab.Append(1,&workpt);
					}
				break;
			case PPT_VERTTYPE_CHUNK:
				pttab.Delete(0,pttab.Count());
				iload->Read(&count,sizeof(int),&nb);
				for(i = 0; i < count; ++i) {
					iload->Read(&workint,sizeof(int),&nb);
					pttab.Append(1,&workint);
					}
				break;
			case PPT_VEC_CHUNK:
				vtab.Delete(0,vtab.Count());
				iload->Read(&count,sizeof(int),&nb);
				for(i = 0; i < count; ++i) {
					iload->Read(&workpt,sizeof(Point3),&nb);
					vtab.Append(1,&workpt);
					}
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/

void PatchVertexDelta::SetSize(PatchMesh& patch, BOOL load)
	{
	dtab.MakeCompatible(patch, FALSE);
	
	// Load it if necessary
	if(load) {
		int verts = patch.numVerts;
		int vecs = patch.numVecs;
		for(int i = 0; i < verts; ++i) {
			dtab.ptab[i] = patch.verts[i].p;
			dtab.pttab[i] = patch.verts[i].flags & PVERT_COPLANAR;
			}
		for(i = 0; i < vecs; ++i)
			dtab.vtab[i] = patch.vecs[i].p;
		}
	}

void PatchVertexDelta::Apply(PatchMesh &patch)
	{
//DebugPrint(_T("PVD:Applying\n"));
	// This does nothing if the number of verts hasn't changed in the mesh.
	SetSize(patch, FALSE);

	// Apply the deltas
	int verts = patch.numVerts;
	int vecs = patch.numVecs;
	for(int i = 0; i < verts; ++i) {
		patch.verts[i].p += dtab.ptab[i];
		patch.verts[i].flags ^= dtab.pttab[i];
		}
	for(i = 0; i < vecs; ++i) {
		patch.vecs[i].p += dtab.vtab[i];
		}
	patch.computeInteriors();
	}

void PatchVertexDelta::UnApply(PatchMesh &patch)
	{
//DebugPrint(_T("PVD:UnApplying\n"));
	// This does nothing if the number of verts hasn't changed in the mesh.
	SetSize(patch, FALSE);

	// Apply the deltas
	int verts = patch.numVerts;
	int vecs = patch.numVecs;
	for(int i = 0; i < verts; ++i) {
		patch.verts[i].p -= dtab.ptab[i];
		patch.verts[i].flags ^= dtab.pttab[i];
		}
	for(i = 0; i < vecs; ++i) {
		patch.vecs[i].p -= dtab.vtab[i];
		}
	patch.computeInteriors();
	}

// This function applies the current changes to slave handles and their knots, and zeroes everything else
void PatchVertexDelta::ApplyHandlesAndZero(PatchMesh &patch, int handleVert) {
//DebugPrint(_T("PVD:ApplyAndZero\n"));
	// This does nothing if the number of verts hasn't changed in the mesh.
	SetSize(patch, FALSE);

	Point3 zeroPt(0.0f, 0.0f, 0.0f);

	// Apply the deltas	to just the slave handles
	int verts = patch.numVerts;
	int vecs = patch.numVecs;
	Point3Tab& delta = dtab.vtab;
	IntTab& kdelta = dtab.pttab;
	for(int i = 0; i < vecs; ++i) {
		if(!(delta[i] == zeroPt)) {
			if(i != handleVert)
				patch.vecs[i].p += delta[i];
			else
				delta[i] = zeroPt;
			}
		}

	for(i = 0; i < verts; ++i) {
		if(kdelta[i])
			patch.verts[i].flags ^= kdelta[i];
		}
	}


#define PVD_POINTTAB_CHUNK		0x1000

IOResult PatchVertexDelta::Save(ISave *isave) {
	isave->BeginChunk(PVD_POINTTAB_CHUNK);
	dtab.Save(isave);
	isave->	EndChunk();
	return IO_OK;
	}

IOResult PatchVertexDelta::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PVD_POINTTAB_CHUNK:
				res = dtab.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/

EPVertMapper::~EPVertMapper() {
	if(vertMap) {
		delete [] vertMap;
		vertMap = NULL;
		}
	if(vecMap) {
		delete [] vecMap;
		vecMap = NULL;
		}
	}

void EPVertMapper::Build(PatchMesh &patch) {
	verts = patch.numVerts;
	if(vertMap)
		delete [] vertMap;
	vertMap = new EPMapVert[verts];
	vecs = patch.numVecs;
	if(vecMap)
		delete [] vecMap;
	vecMap = new EPMapVert[vecs];
	for(int i = 0; i < verts; ++i)
		vertMap[i] = EPMapVert(i, patch.verts[i].p, zeroPoint);
	for(i = 0; i < vecs; ++i)
		vecMap[i] = EPMapVert(i, patch.vecs[i].p, zeroPoint);
	}

void EPVertMapper::RecordTopologyTags(PatchMesh &patch) {
	for(int i = 0; i < verts; ++i) {
		// If it's still mapped, record it!
		if(vertMap[i].vert >= 0)
			patch.verts[vertMap[i].vert].aux1 = i;
		}
	for(i = 0; i < vecs; ++i) {
		// If it's still mapped, record it!
		if(vecMap[i].vert >= 0)
			patch.vecs[vecMap[i].vert].aux1 = i;
		}
	}

void EPVertMapper::UpdateMapping(PatchMesh &patch) {
	// Flush existing mapping
	for(int i = 0; i < verts; ++i)
		vertMap[i].vert = -1;
	for(i = 0; i < vecs; ++i)
		vecMap[i].vert = -1;
	// Build the new mapping
	int wverts = patch.numVerts;
	for(int wvert = 0; wvert < wverts; ++wvert) {
		int aux = patch.verts[wvert].aux1;
		if(aux != 0xffffffff) {
			if(aux >=0 && aux < verts)
				vertMap[aux].vert = wvert;
			}
		}
	int wvecs = patch.numVecs;
	for(int wvec = 0; wvec < wvecs; ++wvec) {
		int aux = patch.vecs[wvec].aux1;
		if(aux != 0xffffffff) {
			if(aux >= 0 && aux < vecs)
				vecMap[aux].vert = wvec;
			}
		}
	}

void EPVertMapper::RecomputeDeltas(PatchMesh &patch) {
	for(int i = 0; i < verts; ++i) {
		EPMapVert &map = vertMap[i];
		if(map.vert >= 0 && map.originalStored) {
			Point3 pnew = patch.verts[map.vert].p;
#ifdef VMAP_DEBUG
			Point3 oldDelta = map.delta;
#endif
			map.delta = pnew - map.original;
#ifdef VMAP_DEBUG
			if(map.delta != oldDelta)
				DebugPrint("Vert %d delta changed from %.2f %.2f %.2f to %.2 %.2f %.2f\n",i,oldDelta.x,oldDelta.y,oldDelta.z,map.delta.x,map.delta.y,map.delta.z);
#endif
			}
		}
	for(i = 0; i < vecs; ++i) {
		EPMapVert &map = vecMap[i];
		if(map.vert >= 0 && map.originalStored) {
			Point3 pnew = patch.vecs[map.vert].p;
#ifdef VMAP_DEBUG
			Point3 oldDelta = map.delta;
#endif
			map.delta = pnew - map.original;
#ifdef VMAP_DEBUG
			if(map.delta != oldDelta)
				DebugPrint("Vec %d delta changed from %.2f %.2f %.2f to %.2 %.2f %.2f\n",i,oldDelta.x,oldDelta.y,oldDelta.z,map.delta.x,map.delta.y,map.delta.z);
#endif
			}
		}
	}

void EPVertMapper::UpdateAndApplyDeltas(PatchMesh &inPatch, PatchMesh &outPatch) {

	//watje 4-27-99 here to handle 0 patch situations
	if (inPatch.numPatches == 0)
		{
//		outPatch.setNumVerts(0,TRUE); 
		return;
		}
	

	// Update the original point locations
	for(int i = 0; i < verts; ++i) {
		// If this table has more in it than we need, forget the rest
		// This can happen if the input object changes to fewer verts
		if(i >= inPatch.numVerts)
			break;
		// If it's still mapped, update it!
		if(vertMap[i].vert >= 0) {
			vertMap[i].original = inPatch.verts[i].p;
			vertMap[i].originalStored = TRUE;
			}
		}
	for(i = 0; i < vecs; ++i) {
		// If this table has more in it than we need, forget the rest
		// This can happen if the input object changes to fewer vecs
		if(i >= inPatch.numVecs)
			break;
		// If it's still mapped, update it!
		if(vecMap[i].vert >= 0) {
			vecMap[i].original = inPatch.vecs[i].p;
			vecMap[i].originalStored = TRUE;
			}
		}
	// Now apply to output
	for(i = 0; i < verts; ++i) {
		EPMapVert &pv = vertMap[i];
		if(pv.vert >= 0 && pv.originalStored) {
//assert(pv.vert >= 0 && pv.vert < outPatch.numVerts);
//watje 4-27-99 instead just throwing an assert it pops a message box up and troes to recover
if (!(pv.vert >= 0 && pv.vert < outPatch.numVerts))
	{
	outPatch.setNumVerts(pv.vert+1,TRUE); 
	TSTR title = GetString(IDS_TH_EDITPATCH_CLASS),
	warning = GetString(IDS_PW_SURFACEERROR);

	MessageBox(GetCOREInterface()->GetMAXHWnd(),
		warning, title, MB_OK|MB_APPLMODAL );
	}

			if(i >= inPatch.numVerts) 
				outPatch.verts[pv.vert].p = zeroPoint;
			else
				outPatch.verts[pv.vert].p = pv.original + pv.delta;
#ifdef VMAP_DEBUG
			if(pv.delta != zeroPoint)
				DebugPrint("Vert %d applied delta of %.2f %.2f %.2f\n",i,pv.delta.x,pv.delta.y,pv.delta.z);
#endif
			}
		}
	for(i = 0; i < vecs; ++i) {
		EPMapVert &pv = vecMap[i];
		if(pv.vert >= 0 && pv.originalStored) {
//assert(pv.vert >= 0 && pv.vert < outPatch.numVecs);
//watje 4-27-99 instead just throwing an assert it pops a message box up and troes to recover
if (!(pv.vert >= 0 && pv.vert < outPatch.numVecs))
	{
	outPatch.setNumVecs(pv.vert+1,TRUE); 

	TSTR title = GetString(IDS_TH_EDITPATCH_CLASS),
	warning = GetString(IDS_PW_SURFACEERROR);

	MessageBox(GetCOREInterface()->GetMAXHWnd(),
		warning, title, MB_OK|MB_APPLMODAL );
	}

			if(i >= inPatch.numVecs) 
				outPatch.vecs[pv.vert].p = zeroPoint;
			else
				outPatch.vecs[pv.vert].p = pv.original + pv.delta;
#ifdef VMAP_DEBUG
			if(pv.delta != zeroPoint)
				DebugPrint("Vec %d applied delta of %.2f %.2f %.2f\n",i,pv.delta.x,pv.delta.y,pv.delta.z);
#endif
			}
		}
	}

EPVertMapper& EPVertMapper::operator=(EPVertMapper &from) {
	if(vertMap)
		delete [] vertMap;
	verts = from.verts;
	vertMap = new EPMapVert[verts];
	for(int i = 0; i < verts; ++i)
		vertMap[i] = from.vertMap[i];
	if(vecMap)
		delete [] vecMap;
	vecs = from.vecs;
	vecMap = new EPMapVert[vecs];
	for(i = 0; i < vecs; ++i)
		vecMap[i] = from.vecMap[i];
	return *this;
	}

void EPVertMapper::RescaleWorldUnits(float f) {
	for(int i = 0; i < verts; ++i) {
		vertMap[i].delta *= f;
		if(vertMap[i].originalStored)
			vertMap[i].original *= f;
		}
	for(i = 0; i < vecs; ++i) {
		vecMap[i].delta *= f;
		if(vecMap[i].originalStored)
			vecMap[i].original *= f;
		}
	}

#define EPVM_DATA_CHUNK 0x1000

IOResult EPVertMapper::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(EPVM_DATA_CHUNK);
	isave->Write(&verts,sizeof(int),&nb);
	isave->Write(vertMap,sizeof(EPMapVert) * verts, &nb);
	isave->Write(&vecs,sizeof(int),&nb);
	isave->Write(vecMap,sizeof(EPMapVert) * vecs, &nb);
	isave->EndChunk();
	return IO_OK;
	}

IOResult EPVertMapper::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	int index = 0;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case EPVM_DATA_CHUNK:
				res = iload->Read(&verts,sizeof(int),&nb);
				if(vertMap)
					delete [] vertMap;
				vertMap = new EPMapVert[verts];
				res = iload->Read(vertMap,sizeof(EPMapVert) * verts,&nb);
				res = iload->Read(&vecs,sizeof(int),&nb);
				if(vecMap)
					delete [] vecMap;
				vecMap = new EPMapVert[vecs];
				res = iload->Read(vecMap,sizeof(EPMapVert) * vecs,&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/

EditPatchData::EditPatchData(EditPatchMod *mod)
	{
	meshSteps = mod->meshSteps;
//3-18-99 to suport render steps and removal of the mental tesselator
	meshStepsRender = mod->meshStepsRender;
	showInterior = mod->showInterior;
	

//	meshAdaptive = mod->meshAdaptive;	// Future use (Not used now)
	viewTess = mod->viewTess;
	prodTess = mod->prodTess;
	dispTess = mod->dispTess;
	mViewTessNormals = mod->mViewTessNormals;
	mProdTessNormals = mod->mProdTessNormals;
	mViewTessWeld = mod->mViewTessWeld;
	mProdTessWeld = mod->mProdTessWeld;
	displayLattice = mod->displayLattice;
	displaySurface = mod->displaySurface;
	flags = 0;
	tempData = NULL;
	}

EditPatchData::EditPatchData(EditPatchData& emc)
	{
	meshSteps = emc.meshSteps;
//3-18-99 to suport render steps and removal of the mental tesselator
	meshStepsRender = emc.meshStepsRender;
	showInterior = emc.showInterior;

//	meshAdaptive = emc.meshAdaptive;	// Future use (Not used now)
	viewTess = emc.viewTess;
	prodTess = emc.prodTess;
	dispTess = emc.dispTess;
	mViewTessNormals = emc.mViewTessNormals;
	mProdTessNormals = emc.mProdTessNormals;
	mViewTessWeld = emc.mViewTessWeld;
	mProdTessWeld = emc.mProdTessWeld;
	displayLattice = emc.displayLattice;
	displaySurface = emc.displaySurface;
	flags = emc.flags;
	tempData = NULL;
	vertMap = emc.vertMap;
	finalPatch = emc.finalPatch;
	}

void EditPatchData::Apply(TimeValue t,PatchObject *patchOb,int selLevel)
	{
	// Either just copy it from the existing cache or rebuild from previous level!
	if ( !GetFlag(EPD_UPDATING_CACHE) && tempData 
	      && tempData->PatchCached(t) ) {
		patchOb->patch.DeepCopy( 
			tempData->GetPatch(t),
			PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|
			PART_DISPLAY|PART_TOPO|TEXMAP_CHANNEL );		
		patchOb->PointsWereChanged();
		}	
	else if ( GetFlag(EPD_HASDATA) ) {
		// For old files, which contain exhaustive data to reconstruct the editing process
		// of patches, we'll have data in the 'changes' table.  If it's there, go ahead and
		// replay the edits, then store the alterations in our new delta format and discard
		// the change table!
		int count = changes.Count();
		if(count) {
//DebugPrint("*** Applying old style (%d) ***\n", count);
			// Store the topology for future reference
			vertMap.Build(patchOb->patch);
			finalPatch = patchOb->patch;
			for(int i = 0; i < count; ++i) {
				PModRecord *rec = changes[i];
				// Record the topo flags
				RecordTopologyTags(&patchOb->patch);
				BOOL result = rec->Redo(&patchOb->patch,0);
				UpdateChanges(&patchOb->patch);
				// If we hit one that didn't play back OK, we need to flush the remainder
				if(!result) {
					for(int j = i; j < count; ++j)
						delete changes[j];
					changes.Delete(i, count - i);
					break;
					}
				}
			// Nuke the changes table
			count = changes.Count();
			for(int k = 0; k < count; ++k)
				delete changes[k];
			changes.Delete(0, count);
			changes.Shrink();
			count = 0;
			}
		else {
			// Apply deltas to incoming shape, placing into finalPatch
			vertMap.UpdateAndApplyDeltas(patchOb->patch, finalPatch);
			patchOb->patch = finalPatch;
			}
		patchOb->PointsWereChanged();
		// Kind of a waste when there's no animation...		
		patchOb->UpdateValidity(GEOM_CHAN_NUM,FOREVER);
		patchOb->UpdateValidity(TOPO_CHAN_NUM,FOREVER);
		patchOb->UpdateValidity(SELECT_CHAN_NUM,FOREVER);
		patchOb->UpdateValidity(SUBSEL_TYPE_CHAN_NUM,FOREVER);
		patchOb->UpdateValidity(DISP_ATTRIB_CHAN_NUM,FOREVER);		
		}
	else {	// No data yet -- Store initial required data
//DebugPrint("<<<Storing Initial Data>>>\n");
		vertMap.Build(patchOb->patch);
		finalPatch = patchOb->patch;
		}

	// Hand it its mesh interpolation info
	patchOb->SetMeshSteps(meshSteps);
//3-18-99 to suport render steps and removal of the mental tesselator
	patchOb->SetMeshStepsRender(meshStepsRender);
	patchOb->SetShowInterior(showInterior);

//	patchOb->SetAdaptive(meshAdaptive);	// Future use (Not used now)
	patchOb->SetViewTess(viewTess);
	patchOb->SetProdTess(prodTess);
	patchOb->SetDispTess(dispTess);
	patchOb->SetViewTessNormals(mViewTessNormals);
	patchOb->SetProdTessNormals(mProdTessNormals);
	patchOb->SetViewTessWeld(mViewTessWeld);
	patchOb->SetProdTessWeld(mProdTessWeld);

	patchOb->showMesh = displaySurface;
	patchOb->SetShowLattice(displayLattice);
	patchOb->patch.dispFlags = 0;	// TH 3/3/99
	switch ( selLevel ) {
		case EP_PATCH:
			patchOb->patch.SetDispFlag(DISP_SELPATCHES);
			break;
		case EP_EDGE:
			patchOb->patch.SetDispFlag(DISP_SELEDGES);
			break;
		case EP_VERTEX:
			patchOb->patch.SetDispFlag(DISP_VERTTICKS|DISP_SELVERTS|DISP_VERTS);
			break;
		}
	patchOb->patch.selLevel = patchLevel[selLevel];
	
	if ( GetFlag(EPD_UPDATING_CACHE) ) {
		assert(tempData);
		tempData->UpdateCache(patchOb);
		SetFlag(EPD_UPDATING_CACHE,FALSE);
		}		
	}

void EditPatchData::Invalidate(PartID part,BOOL patchValid)
	{
	if ( tempData ) {
		tempData->Invalidate(part,patchValid);
		}
	}

void EditPatchData::BeginEdit(TimeValue t)
	{
	assert(tempData);
	if ( !GetFlag(EPD_HASDATA) )
		SetFlag(EPD_HASDATA,TRUE);
	}

EPTempData *EditPatchData::TempData(EditPatchMod *mod)
	{
	if ( !tempData ) {
		assert(mod->ip);
		tempData = new EPTempData(mod,this);
		}
	return tempData;
	}

void EditPatchData::RescaleWorldUnits(float f) {
	// Scale the deltas inside the vertex map
	vertMap.RescaleWorldUnits(f);
	// Now rescale stuff inside our data structures
	Matrix3 stm = ScaleMatrix(Point3(f, f, f));
	finalPatch.Transform(stm);
	}

void EditPatchData::RecordTopologyTags(PatchMesh *patch) {
	// First, stuff all -1's into aux fields
	for(int i = 0; i < patch->numVerts; ++i)
		patch->verts[i].aux1 = 0xffffffff;
	for(i = 0; i < patch->numVecs; ++i)
		patch->vecs[i].aux1 = 0xffffffff;
	// Now put in our tags
	vertMap.RecordTopologyTags(*patch);
	}

GenericNamedSelSetList &EditPatchData::GetSelSet(EditPatchMod *mod) {
	switch(mod->GetSubobjectLevel()) {
		case EP_VERTEX:
			return vselSet;
		case EP_EDGE:
			return eselSet;
		case EP_PATCH:
		default:
			return pselSet;
		}
	}

GenericNamedSelSetList &EditPatchData::GetSelSet(int level) {
	switch(level+EP_VERTEX) {
		case EP_VERTEX:
			return vselSet;
		case EP_EDGE:
			return eselSet;
		case EP_PATCH:
		default:
			return pselSet;
		}
	}

// --------------------------------------------------------------------------------------

class EPVertMapRestore : public RestoreObj {
public:
	BOOL gotRedo;
	EPVertMapper undo;
	EPVertMapper redo;
	EditPatchData *epd;
	
	EPVertMapRestore(EditPatchData *d) {
		undo = d->vertMap;
		epd = d;
		gotRedo = FALSE;
		}

	void Restore(int isUndo) {
		if(!gotRedo) {
			gotRedo = TRUE;
			redo = epd->vertMap;
			}
		epd->vertMap = undo;
		}

	void Redo() {
		epd->vertMap = redo;
		}

	int Size() { return 1; }
	void EndHold() { }
	TSTR Description() { return TSTR(_T("EPVertMapRestore")); }
};

// --------------------------------------------------------------------------------------

class FinalPatchRestore : public RestoreObj {
public:
	BOOL gotRedo;
	PatchMesh undo;
	PatchMesh redo;
	PatchMesh *patch;
	
	FinalPatchRestore(PatchMesh *s) {
		undo = *s;
		patch = s;
		gotRedo = FALSE;
		}

	void Restore(int isUndo) {
		if(!gotRedo) {
			gotRedo = TRUE;
			redo = *patch;
			}
		*patch = undo;
		}

	void Redo() {
		*patch = redo;
		}

	int Size() { return 1; }
	void EndHold() { }
	TSTR Description() { return TSTR(_T("FinalPatchRestore")); }
};

// --------------------------------------------------------------------------------------

void EditPatchData::UpdateChanges(PatchMesh *patch, BOOL checkTopology) {
	if(theHold.Holding()) {
		theHold.Put(new EPVertMapRestore(this));
		theHold.Put(new FinalPatchRestore(&finalPatch));
		}
	// Update the mapper's indices
	if(checkTopology)
		vertMap.UpdateMapping(*patch);
	// Update mapper's XYZ deltas
	vertMap.RecomputeDeltas(*patch);
	// Store the final shape
	finalPatch = *patch;
	}

#define EPD_GENERAL_CHUNK		0x1000	// Obsolete as of 11/12/98 (r3)
#define CHANGE_CHUNK			0x1010 	// Obsolete as of 11/12/98 (r3)
#define EPD_R3_GENERAL_CHUNK	0x1015
#define MESH_ATTRIB_CHUNK		0x1020
#define DISP_PARTS_CHUNK		0x1030
#define VTESS_ATTRIB_CHUNK		0x1070
#define PTESS_ATTRIB_CHUNK		0x1080
#define DTESS_ATTRIB_CHUNK		0x1090
#define NORMAL_TESS_ATTRIB_CHUNK	0x1110
#define WELD_TESS_ATTRIB_CHUNK	0x1120
#define VERTMAP_CHUNK			0x1130
#define FINALPATCH_CHUNK		0x1140
#define RENDERSTEPS_CHUNK		0x1150
#define SHOWINTERIOR_CHUNK		0x1160

// Named sel set chunks
#define VSELSET_CHUNK		0x1040
#define ESELSET_CHUNK		0x1050
#define PSELSET_CHUNK		0x1060


IOResult EditPatchData::Save(ISave *isave) {
	ULONG nb;
	isave->BeginChunk(EPD_R3_GENERAL_CHUNK);
	isave->Write(&flags,sizeof(DWORD),&nb);
	isave->EndChunk();
	isave->BeginChunk(MESH_ATTRIB_CHUNK);
	isave->Write(&meshSteps,sizeof(int),&nb);
// Future use (Not used now)
	BOOL fakeAdaptive = FALSE;	
	isave->Write(&fakeAdaptive,sizeof(BOOL),&nb);
//	isave->Write(&meshAdaptive,sizeof(BOOL),&nb);	// Future use (Not used now)
	isave->EndChunk();

//3-18-99 to suport render steps and removal of the mental tesselator
	isave->BeginChunk(RENDERSTEPS_CHUNK);
	if ( (meshStepsRender < 0) || (meshStepsRender > 100))
		{
		meshStepsRender = 5;
		DbgAssert(0);
		}
	isave->Write(&meshStepsRender,sizeof(int),&nb);
	isave->EndChunk();
	isave->BeginChunk(SHOWINTERIOR_CHUNK);
	isave->Write(&showInterior,sizeof(BOOL),&nb);
	isave->EndChunk();


	isave->BeginChunk(VTESS_ATTRIB_CHUNK);
	viewTess.Save(isave);
	isave->EndChunk();
	isave->BeginChunk(PTESS_ATTRIB_CHUNK);
	prodTess.Save(isave);
	isave->EndChunk();
	isave->BeginChunk(DTESS_ATTRIB_CHUNK);
	dispTess.Save(isave);
	isave->EndChunk();
	isave->BeginChunk(DISP_PARTS_CHUNK);
	isave->Write(&displaySurface,sizeof(BOOL),&nb);
	isave->Write(&displayLattice,sizeof(BOOL),&nb);
	isave->EndChunk();

	isave->BeginChunk(NORMAL_TESS_ATTRIB_CHUNK);
	isave->Write(&mViewTessNormals,sizeof(BOOL),&nb);
	isave->Write(&mProdTessNormals,sizeof(BOOL),&nb);
	isave->EndChunk();

	isave->BeginChunk(WELD_TESS_ATTRIB_CHUNK);
	isave->Write(&mViewTessWeld,sizeof(BOOL),&nb);
	isave->Write(&mProdTessWeld,sizeof(BOOL),&nb);
	isave->EndChunk();

	
	// Save named sel sets
	if (vselSet.Count()) {
		isave->BeginChunk(VSELSET_CHUNK);
		vselSet.Save(isave);
		isave->EndChunk();
		}
	if (eselSet.Count()) {
		isave->BeginChunk(ESELSET_CHUNK);
		eselSet.Save(isave);
		isave->EndChunk();
		}
	if (pselSet.Count()) {
		isave->BeginChunk(PSELSET_CHUNK);
		pselSet.Save(isave);
		isave->EndChunk();
		}

	isave->BeginChunk(VERTMAP_CHUNK);
	vertMap.Save(isave);
	isave->EndChunk();
	isave->BeginChunk(FINALPATCH_CHUNK);
	finalPatch.Save(isave);
	isave->EndChunk();

	return IO_OK;
	}

IOResult EditPatchData::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	PModRecord *theChange;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			// The following code is here to load pre-release 3 files.
			case EPD_GENERAL_CHUNK:
				iload->SetObsolete();
				iload->Read(&flags,sizeof(DWORD),&nb);
				break;
			case CLEARVERTSELRECORD_CHUNK:
				theChange = new ClearPVertSelRecord;
				goto load_change;
			case SETVERTSELRECORD_CHUNK:
				theChange = new SetPVertSelRecord;
				goto load_change;
			case INVERTVERTSELRECORD_CHUNK:
				theChange = new InvertPVertSelRecord;
				goto load_change;
			case CLEAREDGESELRECORD_CHUNK:
				theChange = new ClearPEdgeSelRecord;
				goto load_change;
			case SETEDGESELRECORD_CHUNK:
				theChange = new SetPEdgeSelRecord;
				goto load_change;
			case INVERTEDGESELRECORD_CHUNK:
				theChange = new InvertPEdgeSelRecord;
				goto load_change;
			case CLEARPATCHSELRECORD_CHUNK:
				theChange = new ClearPatchSelRecord;
				goto load_change;
			case SETPATCHSELRECORD_CHUNK:
				theChange = new SetPatchSelRecord;
				goto load_change;
			case INVERTPATCHSELRECORD_CHUNK:
				theChange = new InvertPatchSelRecord;
				goto load_change;
			case VERTSELRECORD_CHUNK:
				theChange = new PVertSelRecord;
				goto load_change;
			case EDGESELRECORD_CHUNK:
				theChange = new PEdgeSelRecord;
				goto load_change;
			case PATCHSELRECORD_CHUNK:
				theChange = new PatchSelRecord;
				goto load_change;
			case PATCHDELETERECORD_CHUNK:
				theChange = new PatchDeleteRecord;
				goto load_change;
			case VERTMOVERECORD_CHUNK:
				theChange = new PVertMoveRecord;
				goto load_change;
			case PATCHCHANGERECORD_CHUNK:
				theChange = new PatchChangeRecord;
				goto load_change;
			case VERTCHANGERECORD_CHUNK:
				theChange = new PVertChangeRecord;
				goto load_change;
			case PATCHADDRECORD_CHUNK:
				theChange = new PatchAddRecord;
				goto load_change;
			case EDGESUBDIVIDERECORD_CHUNK:
				theChange = new EdgeSubdivideRecord;
				goto load_change;
			case PATCHSUBDIVIDERECORD_CHUNK:
				theChange = new PatchSubdivideRecord;
				goto load_change;
			case PATTACHRECORD_CHUNK:
				theChange = new PAttachRecord;
				goto load_change;
			case PATCHDETACHRECORD_CHUNK:
				theChange = new PatchDetachRecord;
				goto load_change;
			case PATCHMTLRECORD_CHUNK:
				theChange = new PatchMtlRecord;
				goto load_change;
			case VERTWELDRECORD_CHUNK:
				theChange = new PVertWeldRecord;
				goto load_change;
			case VERTDELETERECORD_CHUNK:
				theChange = new PVertDeleteRecord;
				// Intentional fall-thru!
				load_change:
				changes.Append(1,&theChange);
				changes[changes.Count()-1]->Load(iload);
				break;
			//
			// The following code is used for post-release 3 files
			//
			case EPD_R3_GENERAL_CHUNK:
				res = iload->Read(&flags,sizeof(DWORD),&nb);
				break;
			case VERTMAP_CHUNK:
				res = vertMap.Load(iload);
				break;
			case FINALPATCH_CHUNK:
				res = finalPatch.Load(iload);
				break;
			//
			// The following code is common to all versions' files
			//
			case MESH_ATTRIB_CHUNK:
				iload->Read(&meshSteps,sizeof(int),&nb);
				res = iload->Read(&meshAdaptive,sizeof(BOOL),&nb);	// Future use (Not used now)
				break;
//3-18-99 to suport render steps and removal of the mental tesselator
			case RENDERSTEPS_CHUNK:
				iload->Read(&meshStepsRender,sizeof(int),&nb);
				if ( (meshStepsRender < 0) || (meshStepsRender > 100))
					{
					meshStepsRender = 5;
					DbgAssert(0);
					}

				break;
			case SHOWINTERIOR_CHUNK:
				iload->Read(&showInterior,sizeof(BOOL),&nb);
				break;

			case VTESS_ATTRIB_CHUNK:
				viewTess.Load(iload);
				break;
			case PTESS_ATTRIB_CHUNK:
				prodTess.Load(iload);
				break;
			case DTESS_ATTRIB_CHUNK:
				dispTess.Load(iload);
				break;
			case NORMAL_TESS_ATTRIB_CHUNK:
				iload->Read(&mViewTessNormals,sizeof(BOOL),&nb);
				res = iload->Read(&mProdTessNormals,sizeof(BOOL),&nb);
				break;
			case WELD_TESS_ATTRIB_CHUNK:
				iload->Read(&mViewTessWeld,sizeof(BOOL),&nb);
				res = iload->Read(&mProdTessWeld,sizeof(BOOL),&nb);
				break;
			case DISP_PARTS_CHUNK:
				iload->Read(&displaySurface,sizeof(BOOL),&nb);
				res = iload->Read(&displayLattice,sizeof(BOOL),&nb);
				break;
			// Load named selection sets
			case VSELSET_CHUNK:
				res = vselSet.Load(iload);
				break;
			case PSELSET_CHUNK:
				res = pselSet.Load(iload);
				break;
			case ESELSET_CHUNK:
				res = eselSet.Load(iload);
				break;

			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL ClearPVertSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		sel = patch->vertSel;
	patch->vertSel.ClearAll();
	return TRUE;
	}

#define CVSR_SEL_CHUNK 0x1000

IOResult ClearPVertSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case CVSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL SetPVertSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		sel = patch->vertSel;
	patch->vertSel.SetAll();
	return TRUE;
	}

#define SVSR_SEL_CHUNK 0x1000

IOResult SetPVertSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SVSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL InvertPVertSelRecord::Redo(PatchMesh *patch,int reRecord) {
	patch->vertSel = ~patch->vertSel;
	return TRUE;
	}

IOResult InvertPVertSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
//		switch(iload->CurChunkID())  {
//			default:
//				break;
//			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL ClearPEdgeSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		sel = patch->edgeSel;
	patch->edgeSel.ClearAll();
	return TRUE;
	}

#define CESR_SEL_CHUNK 0x1000

IOResult ClearPEdgeSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case CESR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL SetPEdgeSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		sel = patch->edgeSel;
	patch->edgeSel.SetAll();
	return TRUE;
	}

#define SESR_SEL_CHUNK 0x1000

IOResult SetPEdgeSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SESR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL InvertPEdgeSelRecord::Redo(PatchMesh *patch,int reRecord) {
	patch->edgeSel = ~patch->edgeSel;
	return TRUE;
	}

IOResult InvertPEdgeSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
//		switch(iload->CurChunkID())  {
//			default:
//				break;
//			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL ClearPatchSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		sel = patch->patchSel;
	patch->patchSel.ClearAll();
	return TRUE;
	}

#define CPSR_SEL_CHUNK 0x1000

IOResult ClearPatchSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case CPSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL SetPatchSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		sel = patch->patchSel;
	patch->patchSel.SetAll();
	return TRUE;
	}

#define SPSR_SEL_CHUNK 0x1000

IOResult SetPatchSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case SPSR_SEL_CHUNK:
				res = sel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL InvertPatchSelRecord::Redo(PatchMesh *patch,int reRecord) {
	patch->patchSel = ~patch->patchSel;
	return TRUE;
	}

IOResult InvertPatchSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
//		switch(iload->CurChunkID())  {
//			default:
//				break;
//			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PVertSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(!IsCompatible(patch->vertSel, newSel))
		return FALSE;
	patch->vertSel = newSel;
	return TRUE;
	}

#define VSR_OLDSEL_CHUNK 0x1000
#define VSR_NEWSEL_CHUNK 0x1010

IOResult PVertSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VSR_OLDSEL_CHUNK:
				res = oldSel.Load(iload);
				break;
			case VSR_NEWSEL_CHUNK:
				res = newSel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PEdgeSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(!IsCompatible(patch->edgeSel, newSel))
		return FALSE;
	patch->edgeSel = newSel;
	return TRUE;
	}

#define ESR_OLDSEL_CHUNK 0x1000
#define ESR_NEWSEL_CHUNK 0x1010

IOResult PEdgeSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case ESR_OLDSEL_CHUNK:
				res = oldSel.Load(iload);
				break;
			case ESR_NEWSEL_CHUNK:
				res = newSel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PatchSelRecord::Redo(PatchMesh *patch,int reRecord) {
	if(!IsCompatible(patch->patchSel, newSel))
		return FALSE;
	patch->patchSel = newSel;
	return TRUE;
	}

#define PSR_OLDSEL_CHUNK 0x1000
#define PSR_NEWSEL_CHUNK 0x1010

IOResult PatchSelRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PSR_OLDSEL_CHUNK:
				res = oldSel.Load(iload);
				break;
			case PSR_NEWSEL_CHUNK:
				res = newSel.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void DeleteSelPatches(PatchMesh *patch) {
	if(!patch->patchSel.NumberSet())
		return;		// Nothing to do!

	int patches = patch->getNumPatches();
	int verts = patch->getNumVerts();

	// Tag the patches that are selected
	BitArray delPatches(patches);
	delPatches = patch->patchSel;

	BitArray delVerts(verts);
	delVerts.ClearAll();

	DeletePatchParts(patch, delVerts, delPatches);
	patch->computeInteriors();
	}

BOOL PatchDeleteRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		oldPatch = *patch;
	DeleteSelPatches(patch);
	return TRUE;
	}

#define PDELR_PATCH_CHUNK		0x1060

IOResult PatchDeleteRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
//		switch(iload->CurChunkID())  {
//			case PDELR_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
//			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PVertMoveRecord::Redo(PatchMesh *patch,int reRecord) {
	if(!delta.IsCompatible(*patch))
		return FALSE;
	delta.Apply(*patch);
	return TRUE;
	}

#define VMR_DELTA_CHUNK		0x1000

IOResult PVertMoveRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VMR_DELTA_CHUNK:
				res = delta.Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void DeleteSelVerts(PatchMesh *patch) {
	if(!patch->vertSel.NumberSet())
		return;		// Nothing to do!

	int patches = patch->getNumPatches();
	int verts = patch->getNumVerts();

	// Tag the patches that use selected vertices
	BitArray delPatches(patches);
	delPatches.ClearAll();
	for(int i = 0; i < patches; ++i) {
		Patch& p = patch->patches[i];
		for(int j = 0; j < p.type; ++j) {
			if(patch->vertSel[p.v[j]]) {
				delPatches.Set(i);
				goto next_patch;
				}
			}
		next_patch:;
		}

	BitArray delVerts(verts);
	delVerts = patch->vertSel;
	DeletePatchParts(patch, delVerts, delPatches);
	patch->computeInteriors();
	}

BOOL PVertDeleteRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		oldPatch = *patch;
	DeleteSelVerts(patch);
	return TRUE;
	}

#define VDELR_PATCH_CHUNK		0x1060

IOResult PVertDeleteRecord::Load(ILoad *iload) {
	IOResult res;
	while (IO_OK==(res=iload->OpenChunk())) {
//		switch(iload->CurChunkID())  {
//			case VDELR_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
//			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PVertChangeRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		oldPatch = *patch;
	patch->ChangeVertType(index, type);
	return TRUE;
	}

#define VCHG_GENERAL_CHUNK		0x1001
#define VCHG_PATCH_CHUNK		0x1010

IOResult PVertChangeRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case VCHG_GENERAL_CHUNK:
				res = iload->Read(&index,sizeof(int),&nb);
				res = iload->Read(&type,sizeof(int),&nb);
				break;
//			case VCHG_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PAttachRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		oldPatchCount = patch->numPatches;
	patch->Attach(&attPatch, mtlOffset);
	return TRUE;
	}

#define ATTR_GENERAL_CHUNK		0x1001
#define ATTR_ATTPATCH_CHUNK		0x1010
#define ATTR_MTLOFFSET_CHUNK	0x1020

IOResult PAttachRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case ATTR_GENERAL_CHUNK:
				res = iload->Read(&oldPatchCount,sizeof(int),&nb);
				break;
			case ATTR_ATTPATCH_CHUNK:
				res = attPatch.Load(iload);
				break;
			case ATTR_MTLOFFSET_CHUNK:
				res = iload->Read(&mtlOffset,sizeof(int),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PatchDetachRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord && !copy)
		oldPatch = *patch;
	if(!copy) {
		BitArray vdel(patch->numVerts);
		vdel.ClearAll();
		BitArray pdel = patch->patchSel;
		DeletePatchParts(patch, vdel, pdel);
		}
	return TRUE;
	}

#define PDETR_GENERAL_CHUNK		0x1000
#define PDETR_PATCH_CHUNK		0x1030

IOResult PatchDetachRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PDETR_GENERAL_CHUNK:
				res = iload->Read(&copy,sizeof(int),&nb);
				break;
//			case PDETR_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PatchMtlRecord::Redo(PatchMesh *patch,int reRecord) {
	for(int i = 0; i < patch->numPatches; ++i) {
		if(patch->patchSel[i])
			patch->patches[i].setMatID(index);
		}
	return TRUE;
	}

#define PMTLR_GENERAL_CHUNK		0x1000
#define PMTLR_INDEX_CHUNK		0x1020

IOResult PatchMtlRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PMTLR_INDEX_CHUNK:
				res = iload->Read(&index,sizeof(MtlID),&nb);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void ChangePatchType(PatchMesh *patch, int index, int type) {
	// If positive vertex number, do it to just one vertex
	if(index >= 0) {
		patch->patches[index].flags = type;
		patch->computeInteriors();
		return;
		}

	// Otherwise, do it to all selected vertices!
	int patches = patch->numPatches;
	BitArray &psel = patch->patchSel;
	for(int i = 0; i < patches; ++i) {
		if(psel[i])
			patch->patches[i].flags = type;
		}
	patch->computeInteriors();
	}

//watje
static void FixUpVerts(PatchMesh *patch) {
	int patches = patch->numPatches;
	for(int i = 0; i < patches; i++) {

		if (!(patch->patches[i].IsHidden()))
			{
			int ct = 4;
			if (patch->patches[i].type==PATCH_TRI)
				ct = 3;
			for (int k = 0; k < ct; k++)
				{
				int a = patch->patches[i].v[k];
				patch->verts[a].SetHidden(FALSE);
				}

			}
		}

	}

//watje unhide all
static void UnHidePatches(PatchMesh *patch) {
	// If positive vertex number, do it to just one vertex
	int patches = patch->numPatches;
	for(int i = 0; i < patches; i++) {
		if (patch->patches[i].IsHidden())
			patch->patches[i].SetHidden(FALSE);
		}
	int verts = patch->numVerts;
	for(i = 0; i < verts; i++) {
		if (patch->verts[i].IsHidden())
			patch->verts[i].SetHidden(FALSE);
		}
	}

//watje hide patch
static void HidePatches(PatchMesh *patch) {
	// If positive vertex number, do it to just one vertex
	int patches = patch->numPatches;
	BitArray &psel = patch->patchSel;
	for(int i = 0; i < patches; i++) {
		if(psel[i])
			{
			patch->patches[i].SetHidden(TRUE);
//hide all 
			int ct = 4;
			if (patch->patches[i].type==PATCH_TRI)
				ct = 3;
			for (int k = 0; k < ct; k++)
				{
				int a = patch->patches[i].v[k];
				patch->verts[a].SetHidden(TRUE);
				}
			}
		}
	FixUpVerts(patch);
	}
//watje hide patches by verts
static void HideVerts(PatchMesh *patch) {
	// If positive vertex number, do it to just one vertex
	int patches = patch->numPatches;
	BitArray &vsel = patch->vertSel;
	for(int i = 0; i < patches; i++) {
		int ct = 4;
		if (patch->patches[i].type==PATCH_TRI)
			ct = 3;
		for (int k = 0; k < ct; k++)
			{
			int a = patch->patches[i].v[k];

			if(vsel[a])
				{
				patch->patches[i].SetHidden(TRUE);
				}
			}
		}
	for(i = 0; i < patches; i++) {
		if(patch->patches[i].IsHidden())
			{
//hide all 
			int ct = 4;
			if (patch->patches[i].type==PATCH_TRI)
				ct = 3;
			for (int k = 0; k < ct; k++)
				{
				int a = patch->patches[i].v[k];
				patch->verts[a].SetHidden(TRUE);
				}
			}
		}

	FixUpVerts(patch);
	}
//watje hide patches by verts
static void HideEdges(PatchMesh *patch) {
	// If positive vertex number, do it to just one vertex
	int edges = patch->numEdges;
	BitArray &esel = patch->edgeSel;
	for(int i = 0; i < edges; i++) {
		if (esel[i])
			{
			int a = patch->edges[i].patch1;
			int b = patch->edges[i].patch2;
			if (a>0)
				patch->patches[a].SetHidden(TRUE);
			if (b>0)
				patch->patches[b].SetHidden(TRUE);
			}
		}
	int patches = patch->numPatches;
	for(i = 0; i < patches; i++) {
		if(patch->patches[i].IsHidden())
			{
//hide all 
			int ct = 4;
			if (patch->patches[i].type==PATCH_TRI)
				ct = 3;
			for (int k = 0; k < ct; k++)
				{
				int a = patch->patches[i].v[k];
				patch->verts[a].SetHidden(TRUE);
				}
			}
		}
	FixUpVerts(patch);
	}



BOOL PatchChangeRecord::Redo(PatchMesh *patch,int reRecord) {
	if(index >= 0 && index >= patch->numPatches)
		return FALSE;
	if(reRecord)
		oldPatch = *patch;
	ChangePatchType(patch, index, type);
	return TRUE;
	}

#define PCHG_GENERAL_CHUNK		0x1001
#define PCHG_PATCH_CHUNK		0x1010

IOResult PatchChangeRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PCHG_GENERAL_CHUNK:
				res = iload->Read(&index,sizeof(int),&nb);
				res = iload->Read(&type,sizeof(int),&nb);
				break;
//			case PCHG_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

static void AddPatches(int type, PatchMesh *patch, BOOL postWeld) {
	if(!patch->edgeSel.NumberSet())
		return;		// Nothing to do!

	int lastVert = patch->getNumVerts();
	int edges = patch->getNumEdges();

	// Add a patch of the desired type to each selected edge that doesn't have two patches atatched!
	for(int i = 0; i < edges; ++i) {
		if(patch->edgeSel[i]) {
			PatchEdge &edge = patch->edges[i];
			if(edge.patch2 < 0) {
				int verts = patch->getNumVerts();
				int vecs = patch->getNumVecs();
				int patches = patch->getNumPatches();
				patch->setNumPatches(patches+1, TRUE);			// Add a patch
				patch->patches[patches].SetType(type);			// Make it the type we want
				patch->setNumVerts(verts + type - 2, TRUE);		// Add the appropriate number of verts
				patch->setNumVecs(vecs + (type-1) * 2 + type, TRUE);	// And the appropriate vector count
				Point3 p1 = patch->verts[edge.v1].p;
				Point3 p2 = patch->verts[edge.v2].p;
				Point3 v12 = patch->vecs[edge.vec12].p;
				Point3 v21 = patch->vecs[edge.vec21].p;
				Point3 edgeCenter = (p1 + p2) / 2.0f;
				// Load up the patch with the correct vert/vector indices
				Patch &spatch = patch->patches[edge.patch1];
				Patch &dpatch = patch->patches[patches];
				switch(type) {
					case PATCH_TRI:
						dpatch.setVerts(edge.v2, edge.v1, verts);
						dpatch.setVecs(edge.vec21, edge.vec12, vecs, vecs+1, vecs+2, vecs+3);
						dpatch.setInteriors(vecs+4, vecs+5, vecs+6);
						switch(spatch.type) {
							case PATCH_TRI: {		// Tri from Tri
								// Find the opposite vertex in the source triangle
								int opposite, o2a, o1a;
								if(spatch.edge[0] == i) {
									opposite = 2;
									o1a = 5;
									o2a = 2;
									}
								else
								if(spatch.edge[1] == i) {
									opposite = 0;
									o1a = 1;
									o2a = 4;
									}
								else {
									opposite = 1;
									o1a = 3;
									o2a = 0;
									}
								// Compute the new vert position
								Point3 oppVec = edgeCenter - patch->verts[spatch.v[opposite]].p;
								float oppLen = Length(oppVec);
								if(oppLen == 0.0f) {
									oppVec = Point3(0,0,1);
									oppLen = 1.0f;
									}
								Point3 v1a = patch->vecs[spatch.vec[o1a]].p - p1;
								Point3 v2a = patch->vecs[spatch.vec[o2a]].p - p2;
								Point3 n1a, n2a;
								if(Length(v1a) > 0.0f)
									n1a = Normalize(v1a);
								else
									n1a = Normalize(oppVec);
								if(Length(v2a) > 0.0f)
									n2a = Normalize(v2a);
								else
									n2a = Normalize(oppVec);
								
								// Build a composite vector based on the two edge vectors
								Point3 compVec = Normalize((n1a + n2a) / 2.0f);
								
								// Create the new vertex
								Point3 newPos = edgeCenter - compVec * oppLen;
								patch->verts[verts].p = newPos;

								// Compute the vectors
								patch->vecs[vecs].p = p1 - v1a;
								patch->vecs[vecs+1].p = newPos - (newPos - p1) / 3.0f;
								patch->vecs[vecs+2].p = newPos - (newPos - p2) / 3.0f;
								patch->vecs[vecs+3].p = p2 - v2a;
								}
								break;
							case PATCH_QUAD: {	// Tri from Quad
								// Find the opposite edge verts in the source quad
								int opposite1, opposite2, o1a, o2a;
								if(spatch.edge[0] == i) {
									opposite1 = 2;
									opposite2 = 3;
									o1a = 7;
									o2a = 2;
									}
								else
								if(spatch.edge[1] == i) {
									opposite1 = 3;
									opposite2 = 0;
									o1a = 1;
									o2a = 4;
									}
								else
								if(spatch.edge[2] == i) {
									opposite1 = 0;
									opposite2 = 1;
									o1a = 3;
									o2a = 6;
									}
								else {
									opposite1 = 1;
									opposite2 = 2;
									o1a = 5;
									o2a = 0;
									}
								// Compute the new vert position
								Point3 otherCenter = (patch->verts[spatch.v[opposite1]].p + patch->verts[spatch.v[opposite2]].p) / 2.0f;
								Point3 oppVec = edgeCenter - otherCenter;
								float oppLen = Length(oppVec);
								if(oppLen == 0.0f) {
									oppVec = Point3(0,0,1);
									oppLen = 1.0f;
									}
								Point3 v1a = patch->vecs[spatch.vec[o1a]].p - p1;
								Point3 v2a = patch->vecs[spatch.vec[o2a]].p - p2;
								Point3 n1a, n2a;
								if(Length(v1a) > 0.0f)
									n1a = Normalize(v1a);
								else
									n1a = Normalize(oppVec);
								if(Length(v2a) > 0.0f)
									n2a = Normalize(v2a);
								else
									n2a = Normalize(oppVec);
								
								// Build a composite vector based on the two edge vectors
								Point3 compVec = Normalize((n1a + n2a) / 2.0f);
								
								// Create the new vertex
								Point3 newPos = edgeCenter - compVec * oppLen;
								patch->verts[verts].p = newPos;

								// Compute the vectors
								patch->vecs[vecs].p = p1 - v1a;
								patch->vecs[vecs+1].p = newPos - (newPos - p1) / 3.0f;
								patch->vecs[vecs+2].p = newPos - (newPos - p2) / 3.0f;
								patch->vecs[vecs+3].p = p2 - v2a;
								}
								break;
							}
						break;
					case PATCH_QUAD:
						dpatch.setVerts(edge.v2, edge.v1, verts, verts+1);
						dpatch.setVecs(edge.vec21, edge.vec12, vecs, vecs+1, vecs+2, vecs+3, vecs+4, vecs+5);
						dpatch.setInteriors(vecs+6, vecs+7, vecs+8, vecs+9);
						switch(spatch.type) {
							case PATCH_TRI: {		// Quad from Tri
								// Find the opposite vertex in the source triangle
								int opposite, o2a, o1a;
								if(spatch.edge[0] == i) {
									opposite = 2;
									o1a = 5;
									o2a = 2;
									}
								else
								if(spatch.edge[1] == i) {
									opposite = 0;
									o1a = 1;
									o2a = 4;
									}
								else {
									opposite = 1;
									o1a = 3;
									o2a = 0;
									}

								Point3 oppVec = edgeCenter - patch->verts[spatch.v[opposite]].p;
								float oppLen = Length(oppVec);
								if(oppLen == 0.0f) {
									oppVec = Point3(0,0,1);
									oppLen = 1.0f;
									}
								Point3 v1a = patch->vecs[spatch.vec[o1a]].p - p1;
								Point3 v2a = patch->vecs[spatch.vec[o2a]].p - p2;
								Point3 n1a, n2a;
								if(Length(v1a) > 0.0f)
									n1a = Normalize(v1a);
								else
									n1a = Normalize(oppVec);
								if(Length(v2a) > 0.0f)
									n2a = Normalize(v2a);
								else
									n2a = Normalize(oppVec);

								// Compute the new vert positions
								Point3 newPos1 = p1 - n1a * oppLen;
								Point3 newPos2 = p2 - n2a * oppLen;
								patch->verts[verts].p = newPos1;
								patch->verts[verts+1].p = newPos2;
								// Compute the vectors
								patch->vecs[vecs].p = p1 - v1a;
								patch->vecs[vecs+1].p = newPos1 - (newPos1 - p1) / 3.0f;
								patch->vecs[vecs+2].p = newPos1 + (v12 - p1);
								patch->vecs[vecs+3].p = newPos2 + (v21 - p2);
								patch->vecs[vecs+4].p = newPos2 + (p2 - newPos2) / 3.0f;
								patch->vecs[vecs+5].p = p2 - v2a;
								}
								break;
							case PATCH_QUAD: {	// Quad from Quad
								// Find the opposite edge verts in the source quad
								int opposite1, opposite2, o1a, o2a;
								if(spatch.edge[0] == i) {
									opposite1 = 2;
									opposite2 = 3;
									o1a = 7;
									o2a = 2;
									}
								else
								if(spatch.edge[1] == i) {
									opposite1 = 3;
									opposite2 = 0;
									o1a = 1;
									o2a = 4;
									}
								else
								if(spatch.edge[2] == i) {
									opposite1 = 0;
									opposite2 = 1;
									o1a = 3;
									o2a = 6;
									}
								else {
									opposite1 = 1;
									opposite2 = 2;
									o1a = 5;
									o2a = 0;
									}

								Point3 otherCenter = (patch->verts[spatch.v[opposite1]].p + patch->verts[spatch.v[opposite2]].p) / 2.0f;
								Point3 oppVec = edgeCenter - otherCenter;
								float oppLen = Length(oppVec);
								if(oppLen == 0.0f) {
									oppVec = Point3(0,0,1);
									oppLen = 1.0f;
									}
								Point3 v1a = patch->vecs[spatch.vec[o1a]].p - p1;
								Point3 v2a = patch->vecs[spatch.vec[o2a]].p - p2;
								Point3 n1a, n2a;
								if(Length(v1a) > 0.0f)
									n1a = Normalize(v1a);
								else
									n1a = Normalize(oppVec);
								if(Length(v2a) > 0.0f)
									n2a = Normalize(v2a);
								else
									n2a = Normalize(oppVec);

								// Compute the new vert position
								Point3 newPos1 = p1 - n1a * oppLen;
								Point3 newPos2 = p2 - n2a * oppLen;
								patch->verts[verts].p = newPos1;
								patch->verts[verts+1].p = newPos2;

								// Compute the vectors
								patch->vecs[vecs].p = p1 - v1a;
								patch->vecs[vecs+1].p = newPos1 - (newPos1 - p1) / 3.0f;
								patch->vecs[vecs+2].p = newPos1 + (v12 - p1);
								patch->vecs[vecs+3].p = newPos2 + (v21 - p2);
								patch->vecs[vecs+4].p = newPos2 + (p2 - newPos2) / 3.0f;
								patch->vecs[vecs+5].p = p2 - v2a;
								}
								break;
							}
						break;
					}
				}
			}
		}
	patch->computeInteriors();
	patch->buildLinkages();
	// This step welds all new identical verts
	if(postWeld && (patch->getNumVerts() != lastVert))
		patch->Weld(0.0f, TRUE, lastVert);
	}

BOOL PatchAddRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		oldPatch = *patch;
	AddPatches(type, patch, postWeld);
	return TRUE;
	}

#define PADDR_TYPE_CHUNK		0x1000
#define PADDR_PATCH_CHUNK		0x1010
#define PADDR_POSTWELD_CHUNK	0x1020

IOResult PatchAddRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	postWeld = FALSE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PADDR_TYPE_CHUNK:
				res = iload->Read(&type,sizeof(int),&nb);
				break;
//			case PADDR_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
			// If the following chunk is present, it's a MAX 2.0 file and a post-addition
			// weld is to be performed
			case PADDR_POSTWELD_CHUNK:
				postWeld = TRUE;
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

class NewEdge {
	public:
		int oldEdge;
		int v1;
		int vec12;
		int vec21;
		int v2;
		int vec23;
		int vec32;
		int v3;
		NewEdge() { oldEdge = v1 = v2 = v3 = vec12 = vec21 = vec23 = vec32 = -1; }
	};

class PatchDivInfo {
	public:
		BOOL div02;
		BOOL div13;
		PatchDivInfo() { div02 = div13 = FALSE; }
	};

// Compute midpoint division for patch vectors -- Provide patchmesh, patch number, 4 bez points
// returns 2 new vectors

static Point3 InterpCenter(PatchMesh *patch, int index, int e1, int i1, int i2, int e2, Point3 *v1=NULL, Point3 *v2=NULL, Point3 *v3=NULL, Point3 *v4=NULL) {
	PatchVec *v = patch->vecs;
	Patch &p = patch->patches[index];
	Point3 e1i1 = (v[p.vec[e1]].p + v[p.interior[i1]].p) / 2.0f;
	Point3 i1i2 = (v[p.interior[i1]].p + v[p.interior[i2]].p) / 2.0f;
	Point3 i2e2 = (v[p.interior[i2]].p + v[p.vec[e2]].p) / 2.0f;
	Point3 a = (e1i1 + i1i2) / 2.0f;
	Point3 b = (i1i2 + i2e2) / 2.0f;
	if(v1) *v1 = e1i1;
	if(v2) *v2 = a;
	if(v3) *v3 = b;
	if(v4) *v4 = i2e2;
	return (a + b) / 2.0f;
	}

static Point3 InterpCenter(PatchMesh *patch, int index, int e1, int i1, int e2, Point3 *v1=NULL, Point3 *v2=NULL) {
	PatchVec *v = patch->vecs;
	Patch &p = patch->patches[index];
	Point3 a = (p.aux[e1] + v[p.interior[i1]].p) / 2.0f;
	Point3 b = (v[p.interior[i1]].p + p.aux[e2]) / 2.0f;
	if(v1) *v1 = a;
	if(v2) *v2 = b;
	return (a + b) / 2.0f;
	}

static Point3 InterpCenter(Point3 e1, Point3 i1, Point3 i2, Point3 e2, Point3 *v1=NULL, Point3 *v2=NULL, Point3 *v3=NULL, Point3 *v4=NULL ) {
	Point3 e1i1 = (e1 + i1) / 2.0f;
	Point3 i1i2 = (i1 + i2) / 2.0f;
	Point3 i2e2 = (i2 + e2) / 2.0f;
	Point3 a = (e1i1 + i1i2) / 2.0f;
	Point3 b = (i1i2 + i2e2) / 2.0f;
	if(v1) *v1 = e1i1;
	if(v2) *v2 = a;
	if(v3) *v3 = b;
	if(v4) *v4 = i2e2;
	return (a + b) / 2.0f;
	}

static Point3 InterpCenter(Point3 e1, Point3 i1, Point3 e2, Point3 *v1=NULL, Point3 *v2=NULL) {
	Point3 a = (e1 + i1) / 2.0f;
	Point3 b = (i1 + e2) / 2.0f;
	if(v1) *v1 = a;
	if(v2) *v2 = b;
	return (a + b) / 2.0f;
	}

static Point3 InterpEdge(PatchMesh *patch, int index, float pct, int c1, int e1, int e2, int c2, Point3 *v1=NULL, Point3 *v2=NULL, Point3 *v3=NULL, Point3 *v4=NULL) {
	PatchVert *vert = patch->verts;
	PatchVec *v = patch->vecs;
	Patch &p = patch->patches[index];
	Point3 pv1 = vert[p.v[c1]].p;
	Point3 pv2 = vert[p.v[c2]].p;
	Point3 pe1 = v[p.vec[e1]].p;
	Point3 pe2 = v[p.vec[e2]].p;
	Point3 v1e1 = pv1 + (pe1 - pv1) * pct;
	Point3 e1e2 = pe1 + (pe2 - pe1) * pct;
	Point3 e2v2 = pe2 + (pv2 - pe2) * pct;
	Point3 a = v1e1 + (e1e2 - v1e1) * pct;
	Point3 b = e1e2 + (e2v2 - e1e2) * pct;
	if(v1) *v1 = v1e1;
	if(v2) *v2 = a;
	if(v3) *v3 = b;
	if(v4) *v4 = e2v2;
	return a + (b - a) * pct;
	}

static Point3 InterpPoint(PatchMesh *patch, int index, float pct, int e1, int i1, int i2, int e2, Point3 *v1=NULL, Point3 *v2=NULL, Point3 *v3=NULL, Point3 *v4=NULL) {
	PatchVec *v = patch->vecs;
	Patch &p = patch->patches[index];
	Point3 pe1 = v[p.vec[e1]].p;
	Point3 pe2 = v[p.vec[e2]].p;
	Point3 pi1 = v[p.interior[i1]].p;
	Point3 pi2 = v[p.interior[i2]].p;
	Point3 e1i1 = pe1 + (pi1 - pe1) * pct;
	Point3 i1i2 = pi1 + (pi2 - pi1) * pct;
	Point3 i2e2 = pi2 + (pe2 - pi2) * pct;
	Point3 a = e1i1 + (i1i2 - e1i1) * pct;
	Point3 b = i1i2 + (i2e2 - i1i2) * pct;
	if(v1) *v1 = e1i1;
	if(v2) *v2 = a;
	if(v3) *v3 = b;
	if(v4) *v4 = i2e2;
	return a + (b - a) * pct;
	}

static Point3 InterpPoint(float pct, Point3 e1, Point3 i1, Point3 i2, Point3 e2, Point3 *v1=NULL, Point3 *v2=NULL, Point3 *v3=NULL, Point3 *v4=NULL ) {
	Point3 e1i1 = e1 + (i1 - e1) * pct;
	Point3 i1i2 = i1 + (i2 - i1) * pct;
	Point3 i2e2 = i2 + (e2 - i2) * pct;
	Point3 a = e1i1 + (i1i2 - e1i1) * pct;
	Point3 b = i1i2 + (i2e2 - i1i2) * pct;
	if(v1) *v1 = e1i1;
	if(v2) *v2 = a;
	if(v3) *v3 = b;
	if(v4) *v4 = i2e2;
	return a + (b - a) * pct;
	}

static Point3 InterpLinear(Point3 a, Point3 b, float interp) {
	return a + (a - b) * interp;
	}

static Point3 InterpDegree2(Point3 a, Point3 b, Point3 c, float interp) {
	Point3 ab = a + (b - a) * interp;
	Point3 bc = b + (c - b) * interp;
	return ab + (bc - ab) * interp;
	}

static Point3 InterpDegree3(Point3 a, Point3 b, Point3 c, Point3 d, float interp) {
	Point3 ab = a + (b - a) * interp;
	Point3 bc = b + (c - b) * interp;
	Point3 cd = c + (d - c) * interp;
	Point3 abbc = ab + (bc - ab) * interp;
	Point3 bccd = bc + (cd - bc) * interp;
	return abbc + (bccd - abbc) * interp;
	}

// Handy fractional constants
#define _1_16 0.0625f
#define _1_8 0.125f
#define _3_16 0.1875f
#define _1_4 0.25f

static Point3 GetOuterInside(Point3 a, Point3 b, Point3 c, Point3 d, Point3 e, Point3 f) {
	return a * _1_8 + b * _1_8 + c * _1_4 + d * _1_8 + e * _1_4 + f * _1_8;
	}

static Point3 GetNewEdgeVec(Point3 a, Point3 b, Point3 c, Point3 d, Point3 e, Point3 f, Point3 g, Point3 h) {
	return a * _1_16 + b * _1_16 + c * _3_16 + d * _3_16 + e * _1_16 + f * _1_16 + g * _3_16 + h * _3_16;
	}

static Point3 GetCentralInterior(Point3 a, Point3 b, Point3 c, Point3 d, Point3 e, Point3 f, Point3 g, Point3 h, Point3 i, Point3 j) {
	return a * _1_16 + b * _1_8 + c * _1_16 + d * _1_16 + e * _1_16 + f * _1_16 + g * _1_16 + h * _3_16 + i * _3_16 + j * _1_8;
	}

static Point3 GetNewEdgeCenter(Point3 a, Point3 b, Point3 c, Point3 d, Point3 e, Point3 f, Point3 g, Point3 h, Point3 i) {
	return a * _1_16 + b * _1_8 + c * _1_16 + d * _1_8 + e * _1_16 + f * _1_16 + g * _1_4 + h * _1_8 + i * _1_8;
	}

static Point3 GetOuterOutside(Point3 a, Point3 b, Point3 c, Point3 d) {
	return a * _1_4 + b * _1_4 + c * _1_4 + d * _1_4;
	}

static void FindNewTriEdge(PatchMesh *patch, Patch &p, int vert, Point3 &e1, Point3 &e2, Point3 &e3) {
	int a = vert;
	int b = vert * 3;
	int c = b + 1;
	int d = (b + 8) % 9;
	int e = (b + 7) % 9;
	int f = (b + 4) % 9;
	int g = vert;
	int h = (g + 1) % 3;
	int i = (g + 2) % 3;
	int j = (b + 6) % 9;
	int k = (b + 5) % 9;
	int l = b + 2;
	int m = (b + 3) % 9;
	Point3 pa = patch->verts[p.v[a]].p;
	Point3 pb = p.aux[b];
	Point3 pc = p.aux[c];
	Point3 pd = p.aux[d];
	Point3 pe = p.aux[e];
	Point3 pf = p.aux[f];
	Point3 pg = patch->vecs[p.interior[g]].p;
	Point3 ph = patch->vecs[p.interior[h]].p;
	Point3 pi = patch->vecs[p.interior[i]].p;
	Point3 pj = p.aux[j];
	Point3 pk = p.aux[k];
	Point3 pl = p.aux[l];
	Point3 pm = p.aux[m];
	e1 = GetNewEdgeVec(pa,pb,pd,pe,pj,pk,pg,pi);
	e2 = GetNewEdgeCenter(pa,pb,pc,pd,pe,pf,pg,ph,pi);
	e3 = GetNewEdgeVec(pa,pd,pb,pc,pl,pm,pg,ph);
	}

static void FindNewOuterTriInteriors(PatchMesh *patch, Patch &p, int vert, Point3 &i1, Point3 &i2, Point3 &i3) {
	int a = vert;
	int b = vert * 3;
	int c = (b + 8) % 9;
	int d = (b + 7) % 9;
	int e = vert;
	int f = (e + 2) % 3;
	int g = b + 1;
	int h = (e + 1) % 3;
	Point3 pa = patch->verts[p.v[a]].p;
	Point3 pb = p.aux[b];
	Point3 pc = p.aux[c];
	Point3 pd = p.aux[d];
	Point3 pe = patch->vecs[p.interior[e]].p;
	Point3 pf = patch->vecs[p.interior[f]].p;
	Point3 pg = p.aux[g];
	Point3 ph = patch->vecs[p.interior[h]].p;
	i1 = GetOuterOutside(pa,pb,pc,pe);
	i2 = GetOuterInside(pa,pc,pb,pg,pe,ph);
	i3 = GetOuterInside(pa,pb,pc,pd,pe,pf);
	}

static void FindNewInnerTriInteriors(PatchMesh *patch, Patch &p, Point3 &i1, Point3 &i2, Point3 &i3) {
	Point3 pa = p.aux[0];
	Point3 pb = p.aux[1];
	Point3 pc = p.aux[2];
	Point3 pd = p.aux[3];
	Point3 pe = p.aux[4];
	Point3 pf = p.aux[5];
	Point3 pg = p.aux[6];
	Point3 ph = p.aux[7];
	Point3 pi = p.aux[8];
	Point3 pj = patch->vecs[p.interior[0]].p;
	Point3 pk = patch->vecs[p.interior[1]].p;
	Point3 pl = patch->vecs[p.interior[2]].p;
	i1 = GetCentralInterior(pa,pb,pc,pi,ph,pe,pd,pj,pk,pl);
	i2 = GetCentralInterior(pd,pe,pf,pc,pb,ph,pg,pk,pl,pj);
	i3 = GetCentralInterior(pg,ph,pi,pf,pe,pb,pa,pl,pj,pk);
	}

// This is a first shot at a degree reducer which turns a degree-4 curve into a degree-3 curve,
// it probably won't give very good results unless the curve was converted from degree 3 to degree 4
// returns just the vector points
static void CubicFromQuartic(Point3 q1, Point3 q2, Point3 q3, Point3 q4, Point3 q5, Point3 &c2, Point3 &c3) {
	c2 = q1 + (q2 - q1) * 1.33333f;
	c3 = q5 + (q4 - q5) * 1.33333f;
	}

#define SUBDIV_EDGES 0
#define SUBDIV_PATCHES 1

static void SubdividePatch(int type, BOOL propagate, PatchMesh *patch) {
	int i;

	int verts = patch->getNumVerts();
	int vecs = patch->getNumVecs();
	int edges = patch->getNumEdges();
	int patches = patch->getNumPatches();

	// Make an edge flags array to note which edges must be processed
	BitArray eDiv(edges);
	// Make a patch flags array to note which patches must be processed
	BitArray pDiv(patches);
	// Make an edge flags array to note which edges have been done
	BitArray eDone(edges);
	eDone.ClearAll();
	// Make a patch flags array to note which patches have been done
	BitArray pDone(patches);
	pDone.ClearAll();

	switch(type) {
		case SUBDIV_EDGES:
			if(!patch->edgeSel.NumberSet())
				return;		// Nothing to do!
			eDiv = patch->edgeSel;
			pDiv.ClearAll();
			break;
		case SUBDIV_PATCHES:
			if(!patch->patchSel.NumberSet())
				return;		// Nothing to do!
			eDiv.ClearAll();
			pDiv = patch->patchSel;
			for(i = 0; i < patches; ++i) {
				if(pDiv[i]) {
					Patch &p = patch->patches[i];
					// Mark all edges for division
					eDiv.Set(p.edge[0]);
					eDiv.Set(p.edge[1]);
					eDiv.Set(p.edge[2]);
					if(p.type == PATCH_QUAD)
						eDiv.Set(p.edge[3]);
					}
				}
			// If not propagating, mark the edges as done
			if(!propagate)
				eDone = eDiv;
			break;
		}

	BOOL more = TRUE;
	while(more) {
		BOOL altered = FALSE;
		for(i = 0; i < edges; ++i) {
			if(eDiv[i] && !eDone[i]) {
				PatchEdge &e = patch->edges[i];
				pDiv.Set(e.patch1);
				if(e.patch2 >= 0)
					pDiv.Set(e.patch2);
				eDone.Set(i);
				altered = TRUE;
				}
			}
		if(altered && propagate) {
			for(i = 0; i < patches; ++i) {
				if(pDiv[i] && !pDone[i]) {
					Patch &p = patch->patches[i];
					if(p.type == PATCH_TRI) {	// Triangle -- tag all edges for division
						eDiv.Set(p.edge[0]);
						eDiv.Set(p.edge[1]);
						eDiv.Set(p.edge[2]);
						}
					else {		// Quad -- Tag edges opposite tagged edges
						if(eDiv[p.edge[0]])
							eDiv.Set(p.edge[2]);
						if(eDiv[p.edge[1]])
							eDiv.Set(p.edge[3]);
						if(eDiv[p.edge[2]])
							eDiv.Set(p.edge[0]);
						if(eDiv[p.edge[3]])
							eDiv.Set(p.edge[1]);
						}
					pDone.Set(i);
					}
				}
			}
		else
			more = FALSE;
		}

	// Keep a count of the new interior vectors
	int newInteriors = 0;

	// Also keep a count of the new vertices inside double-divided quads
	int newCenters = 0;

	// And a count of new texture vertices
	Tab<int> newTVerts;
	newTVerts.SetCount (patch->getNumMaps());
	for(int chan = 0; chan < patch->getNumMaps(); ++chan)
		newTVerts[chan] = 0;

	// And a count of new patches
	int newPatches = 0;

	int divPatches = pDiv.NumberSet();
	PatchDivInfo *pInfo = new PatchDivInfo [divPatches];
	int pDivIx;

	// Tag the edges that are on tagged patches but aren't tagged (only happens in propagate=0)
	// And set up a table with useful division info
	for(i = 0, pDivIx = 0; i < patches; ++i) {
		if(pDiv[i]) {
			PatchDivInfo &pi = pInfo[pDivIx];
			Patch &p = patch->patches[i];
			if(p.type == PATCH_TRI) {	// Triangle -- tag all edges for division
				eDiv.Set(p.edge[0]);
				eDiv.Set(p.edge[1]);
				eDiv.Set(p.edge[2]);
				newInteriors += (6 + 12);
				newPatches += 4;
				for(chan = 0; chan < patch->getNumMaps(); ++chan) {
					if(patch->tvPatches[chan])
						newTVerts[chan] += 3;
					}
				}
			else {		// Quad -- Tag edges opposite tagged edges
				int divs = 0;
				pi.div02 = pi.div13 = FALSE;
				if(eDiv[p.edge[0]]) {
					eDiv.Set(p.edge[2]);
					divs++;
					pi.div02 = TRUE;
					}
				else
				if(eDiv[p.edge[2]]) {
					eDiv.Set(p.edge[0]);
					divs++;
					pi.div02 = TRUE;
					}
				if(eDiv[p.edge[1]]) {
					eDiv.Set(p.edge[3]);
					divs++;
					pi.div13 = TRUE;
					}
				else
				if(eDiv[p.edge[3]]) {
					eDiv.Set(p.edge[1]);
					divs++;
					pi.div13 = TRUE;
					}
				newPatches += (divs==1) ? 2 : 4;
				newInteriors += (divs==1) ? (2 + 8) : (8 + 16);
				for(chan = 0; chan < patch->getNumMaps(); ++chan) {
					if(patch->tvPatches[chan]) {
						if(divs == 2)
							newTVerts[chan] += 5;
						else
							newTVerts[chan] += 2;
						}
					}
				if(divs==2)
					newCenters++;
				}
			pDivIx++;
			}
		}

	// Figure out how many new verts and vecs we'll need...
	int divEdges = eDiv.NumberSet();
	int newVerts = divEdges + newCenters;		// 1 new vert per edge
	int newVecs = divEdges * 4 + newInteriors;	// 4 new vectors per edge + new interior verts

	int vert = verts;
	Tab<int> tvert;
	tvert.SetCount (patch->getNumMaps());
	Tab<int> tverts;
	tverts.SetCount (patch->getNumMaps());
	Tab<int> tpat;
	tpat.SetCount (patch->getNumMaps());
	for(chan = 0; chan < patch->getNumMaps(); ++chan) {
		tverts[chan] = tvert[chan] = patch->getNumMapVerts (chan);
		tpat[chan] = patches;
	}
	int vec = vecs;
	int pat = patches;

	// Add the new vertices
	patch->setNumVerts(verts + newVerts, TRUE);

	// Add the new texture vertices
	for(chan = 0; chan < patch->getNumMaps(); ++chan)
		patch->setNumMapVerts (chan, tverts[chan] + newTVerts[chan], TRUE);

	// Add the new vectors
	patch->setNumVecs(vecs + newVecs, TRUE);

	// Add the new patches
	patch->setNumPatches(patches + newPatches, TRUE);

	// Create a new edge map
	NewEdge *eMap = new NewEdge [edges];
	for(i = 0; i < edges; ++i) {
		if(eDiv[i]) {
			PatchEdge &edge = patch->edges[i];
			NewEdge &map = eMap[i];
			map.oldEdge = i;
			map.v1 = edge.v1;
			map.vec12 = vec++;
			map.vec21 = vec++;
			map.v2 = vert++;
			map.vec23 = vec++;
			map.vec32 = vec++;
			map.v3 = edge.v2;
			
			// Compute the new edge vertex and vectors
			Point3 v00 = patch->verts[edge.v1].p;
			Point3 v10 = patch->vecs[edge.vec12].p;
			Point3 v20 = patch->vecs[edge.vec21].p;
			Point3 v30 = patch->verts[edge.v2].p;
			Point3 v01 = (v10 + v00) / 2.0f;
			Point3 v21 = (v30 + v20) / 2.0f;
			Point3 v11 = (v20 + v10) / 2.0f;
			Point3 v02 = (v11 + v01) / 2.0f;
			Point3 v12 = (v21 + v11) / 2.0f;
			Point3 v03 = (v12 + v02) / 2.0f;

			patch->verts[map.v2].p = v03;
			patch->vecs[map.vec12].p = v01;
			patch->vecs[map.vec21].p = v02;
			patch->vecs[map.vec23].p = v12;
			patch->vecs[map.vec32].p = v21;
			}
		}

#ifdef DUMPING
// Dump edge map
DebugPrint("Edge map:\n");
for(i = 0; i < edges; ++i) {
	NewEdge &e = eMap[i];
	DebugPrint("Old edge: %d  New edge: %d (%d %d) %d (%d %d) %d\n",e.oldEdge,e.v1,e.vec12,e.vec21,e.v2,e.vec23,e.vec32,e.v3);
	}
#endif

	// Now go and subdivide them!

	for(i = 0, pDivIx = 0; i < patches; ++i) {
		if(pDiv[i]) {
			PatchDivInfo &pi = pInfo[pDivIx];
			Patch &p = patch->patches[i];
			if(p.type == PATCH_TRI) {
				// Need to create four new patches
				int newev1 = vec++;	// edge 0 -> edge 1
				int newev2 = vec++;	// edge 1 -> edge 0
				int newev3 = vec++;	// edge 1 -> edge 2
				int newev4 = vec++;	// edge 2 -> edge 1
				int newev5 = vec++;	// edge 2 -> edge 0
				int newev6 = vec++;	// edge 0 -> edge 2

				// Get pointers to new edges
				NewEdge &e0 = eMap[p.edge[0]];
				NewEdge &e1 = eMap[p.edge[1]];
				NewEdge &e2 = eMap[p.edge[2]];

				// See if edges need to be flopped
				BOOL flop0 = (e0.v1 == p.v[0]) ? FALSE : TRUE;
				BOOL flop1 = (e1.v1 == p.v[1]) ? FALSE : TRUE;
				BOOL flop2 = (e2.v1 == p.v[2]) ? FALSE : TRUE;

				// Create the four new patches
				Patch &p1 = patch->patches[pat++];
				Patch &p2 = patch->patches[pat++];
				Patch &p3 = patch->patches[pat++];
				Patch &p4 = patch->patches[pat++];

				p1.SetType(PATCH_TRI);
				p1.v[0] = e0.v2;
				p1.v[1] = flop1 ? e1.v3 : e1.v1;
				p1.v[2] = e1.v2;
				p1.vec[0] = flop0 ? e0.vec21 : e0.vec23;
				p1.vec[1] = flop0 ? e0.vec12 : e0.vec32;
				p1.vec[2] = flop1 ? e1.vec32 : e1.vec12;
				p1.vec[3] = flop1 ? e1.vec23 : e1.vec21;
				p1.vec[4] = newev2;
				p1.vec[5] = newev1;
				p1.interior[0] = vec++;
				p1.interior[1] = vec++;
				p1.interior[2] = vec++;

				p2.SetType(PATCH_TRI);
				p2.v[0] = e1.v2;
				p2.v[1] = flop2 ? e2.v3 : e2.v1;
				p2.v[2] = e2.v2;
				p2.vec[0] = flop1 ? e1.vec21 : e1.vec23;
				p2.vec[1] = flop1 ? e1.vec12 : e1.vec32;
				p2.vec[2] = flop2 ? e2.vec32 : e2.vec12;
				p2.vec[3] = flop2 ? e2.vec23 : e2.vec21;
				p2.vec[4] = newev4;
				p2.vec[5] = newev3;
				p2.interior[0] = vec++;
				p2.interior[1] = vec++;
				p2.interior[2] = vec++;

				p3.SetType(PATCH_TRI);
				p3.v[0] = e0.v2;
				p3.v[1] = e1.v2;
				p3.v[2] = e2.v2;
				p3.vec[0] = newev1;
				p3.vec[1] = newev2;
				p3.vec[2] = newev3;
				p3.vec[3] = newev4;
				p3.vec[4] = newev5;
				p3.vec[5] = newev6;
				p3.interior[0] = vec++;
				p3.interior[1] = vec++;
				p3.interior[2] = vec++;

				p4.SetType(PATCH_TRI);
				p4.v[0] = flop0 ? e0.v3 : e0.v1;
				p4.v[1] = e0.v2;
				p4.v[2] = e2.v2;
				p4.vec[0] = flop0 ? e0.vec32 : e0.vec12;
				p4.vec[1] = flop0 ? e0.vec23 : e0.vec21;
				p4.vec[2] = newev6;
				p4.vec[3] = newev5;
				p4.vec[4] = flop2 ? e2.vec21 : e2.vec23;
				p4.vec[5] = flop2 ? e2.vec12 : e2.vec32;
				p4.interior[0] = vec++;
				p4.interior[1] = vec++;
				p4.interior[2] = vec++;

				// If this patch is textured, create three new texture verts for it
				for(chan = 0; chan < patch->getNumMaps(); ++chan) {
					if(patch->tvPatches[chan]) {
						int tva = tvert[chan]++;
						int tvb = tvert[chan]++;
						int tvc = tvert[chan]++;
						TVPatch &tp = patch->tvPatches[chan][i];
						TVPatch &tp1 = patch->tvPatches[chan][tpat[chan]++];
						TVPatch &tp2 = patch->tvPatches[chan][tpat[chan]++];
						TVPatch &tp3 = patch->tvPatches[chan][tpat[chan]++];
						TVPatch &tp4 = patch->tvPatches[chan][tpat[chan]++];
						tp1.tv[0] = tva;
						tp1.tv[1] = tp.tv[1];
						tp1.tv[2] = tvb;
						tp2.tv[0] = tvb;
						tp2.tv[1] = tp.tv[2];
						tp2.tv[2] = tvc;
						tp3.tv[0] = tva;
						tp3.tv[1] = tvb;
						tp3.tv[2] = tvc;
						tp4.tv[0] = tp.tv[0];
						tp4.tv[1] = tva;
						tp4.tv[2] = tvc;
						patch->tVerts[chan][tva] = (patch->tVerts[chan][tp.tv[0]] + patch->tVerts[chan][tp.tv[1]]) / 2.0f;
						patch->tVerts[chan][tvb] = (patch->tVerts[chan][tp.tv[1]] + patch->tVerts[chan][tp.tv[2]]) / 2.0f;
						patch->tVerts[chan][tvc] = (patch->tVerts[chan][tp.tv[2]] + patch->tVerts[chan][tp.tv[0]]) / 2.0f;
						}
					}

				// Now we'll compute the vectors for the three new edges being created inside this patch
				// These come back as degree 4's, and we need to reduce them to degree 3 for use in our
				// edges -- This is a bit risky because we aren't guaranteed a perfect fit.
				Point3 i1, i2, i3, i4, i5, i6, i7, i8, i9;
				FindNewTriEdge(patch, p, 0, i1, i2, i3);
				FindNewTriEdge(patch, p, 1, i4, i5, i6);
				FindNewTriEdge(patch, p, 2, i7, i8, i9);
				Point3 v1, v2, v3, v4, v5, v6;
				CubicFromQuartic(patch->verts[e2.v2].p, i1, i2, i3, patch->verts[e0.v2].p, v1, v2);
				CubicFromQuartic(patch->verts[e0.v2].p, i4, i5, i6, patch->verts[e1.v2].p, v3, v4);
				CubicFromQuartic(patch->verts[e1.v2].p, i7, i8, i9, patch->verts[e2.v2].p, v5, v6);
				patch->vecs[newev1].p = v3;
				patch->vecs[newev2].p = v4;
				patch->vecs[newev3].p = v5;
				patch->vecs[newev4].p = v6;
				patch->vecs[newev5].p = v1;
				patch->vecs[newev6].p = v2;
				// Now compute the interior vectors for the new patches if the one we're dividing isn't automatic
				// Must compute vectors for this patch's divided edges
				if(!(p.flags & PATCH_AUTO)) {
					p1.flags &= ~PATCH_AUTO;
					p2.flags &= ~PATCH_AUTO;
					p3.flags &= ~PATCH_AUTO;
					p4.flags &= ~PATCH_AUTO;

					FindNewOuterTriInteriors(patch, p, 1, patch->vecs[p1.interior[1]].p, patch->vecs[p1.interior[2]].p, patch->vecs[p1.interior[0]].p);
					FindNewOuterTriInteriors(patch, p, 2, patch->vecs[p2.interior[1]].p, patch->vecs[p2.interior[2]].p, patch->vecs[p2.interior[0]].p);
					FindNewInnerTriInteriors(patch, p, patch->vecs[p3.interior[0]].p, patch->vecs[p3.interior[1]].p, patch->vecs[p3.interior[2]].p);
					FindNewOuterTriInteriors(patch, p, 0, patch->vecs[p4.interior[0]].p, patch->vecs[p4.interior[1]].p, patch->vecs[p4.interior[2]].p);
					}
				}
			else {		// Quad patch
				// Check division flags to see how many patches we'll need
				if(pi.div02 && pi.div13) {		// Divide both ways
					// Need a new central vertex
					Point3 newc = p.interp(patch, 0.5f, 0.5f);
					patch->verts[vert].p = newc;
					int center = vert++;

					// Need to create four new patches
					int newev1 = vec++;	// edge 0 -> center
					int newev2 = vec++;	// center -> edge 0
					int newev3 = vec++;	// edge 1 -> center
					int newev4 = vec++;	// center -> edge 1
					int newev5 = vec++;	// edge 2 -> center
					int newev6 = vec++;	// center -> edge 2
					int newev7 = vec++;	// edge 3 -> center
					int newev8 = vec++;	// center -> edge 3

					// Get pointers to new edges
					NewEdge &e0 = eMap[p.edge[0]];
					NewEdge &e1 = eMap[p.edge[1]];
					NewEdge &e2 = eMap[p.edge[2]];
					NewEdge &e3 = eMap[p.edge[3]];

					// See if edges need to be flopped
					BOOL flop0 = (e0.v1 == p.v[0]) ? FALSE : TRUE;
					BOOL flop1 = (e1.v1 == p.v[1]) ? FALSE : TRUE;
					BOOL flop2 = (e2.v1 == p.v[2]) ? FALSE : TRUE;
					BOOL flop3 = (e3.v1 == p.v[3]) ? FALSE : TRUE;

					// Compute the new vectors for the dividing line
					Point3 w1,w2,w3,w4;
					w1 = InterpCenter(patch, i, 7, 0, 1, 2);
					w2 = InterpCenter(patch, i, 6, 3, 2, 3);
					w3 = InterpCenter(patch, i, 1, 1, 2, 4);
					w4 = InterpCenter(patch, i, 0, 0, 3, 5);
					Point3 new0 = patch->verts[e0.v2].p;
					Point3 new1 = patch->verts[e1.v2].p;
					Point3 new2 = patch->verts[e2.v2].p;
					Point3 new3 = patch->verts[e3.v2].p;
					InterpCenter(new0, w1, w2, new2, &patch->vecs[newev1].p, &patch->vecs[newev2].p, &patch->vecs[newev6].p, &patch->vecs[newev5].p);
					InterpCenter(new1, w3, w4, new3, &patch->vecs[newev3].p, &patch->vecs[newev4].p, &patch->vecs[newev8].p, &patch->vecs[newev7].p);

					// Create the four new patches
					Patch &p1 = patch->patches[pat++];
					Patch &p2 = patch->patches[pat++];
					Patch &p3 = patch->patches[pat++];
					Patch &p4 = patch->patches[pat++];

					p1.SetType(PATCH_QUAD);
					p1.v[0] = p.v[0];
					p1.v[1] = e0.v2;
					p1.v[2] = center;
					p1.v[3] = e3.v2;
					p1.vec[0] = flop0 ? e0.vec32 : e0.vec12;
					p1.vec[1] = flop0 ? e0.vec23 : e0.vec21;
					p1.vec[2] = newev1;
					p1.vec[3] = newev2;
					p1.vec[4] = newev8;
					p1.vec[5] = newev7;
					p1.vec[6] = flop3 ? e3.vec21 : e3.vec23;
					p1.vec[7] = flop3 ? e3.vec12 : e3.vec32;
					p1.interior[0] = vec++;
					p1.interior[1] = vec++;
					p1.interior[2] = vec++;
					p1.interior[3] = vec++;

					p2.SetType(PATCH_QUAD);
					p2.v[0] = p.v[1];
					p2.v[1] = e1.v2;
					p2.v[2] = center;
					p2.v[3] = e0.v2;
					p2.vec[0] = flop1 ? e1.vec32 : e1.vec12;
					p2.vec[1] = flop1 ? e1.vec23 : e1.vec21;
					p2.vec[2] = newev3;
					p2.vec[3] = newev4;
					p2.vec[4] = newev2;
					p2.vec[5] = newev1;
					p2.vec[6] = flop0 ? e0.vec21 : e0.vec23;
					p2.vec[7] = flop0 ? e0.vec12 : e0.vec32;
					p2.interior[0] = vec++;
					p2.interior[1] = vec++;
					p2.interior[2] = vec++;
					p2.interior[3] = vec++;

					p3.SetType(PATCH_QUAD);
					p3.v[0] = p.v[2];
					p3.v[1] = e2.v2;
					p3.v[2] = center;
					p3.v[3] = e1.v2;
					p3.vec[0] = flop2 ? e2.vec32 : e2.vec12;
					p3.vec[1] = flop2 ? e2.vec23 : e2.vec21;
					p3.vec[2] = newev5;
					p3.vec[3] = newev6;
					p3.vec[4] = newev4;
					p3.vec[5] = newev3;
					p3.vec[6] = flop1 ? e1.vec21 : e1.vec23;
					p3.vec[7] = flop1 ? e1.vec12 : e1.vec32;
					p3.interior[0] = vec++;
					p3.interior[1] = vec++;
					p3.interior[2] = vec++;
					p3.interior[3] = vec++;

					p4.SetType(PATCH_QUAD);
					p4.v[0] = p.v[3];
					p4.v[1] = e3.v2;
					p4.v[2] = center;
					p4.v[3] = e2.v2;
					p4.vec[0] = flop3 ? e3.vec32 : e3.vec12;
					p4.vec[1] = flop3 ? e3.vec23 : e3.vec21;
					p4.vec[2] = newev7;
					p4.vec[3] = newev8;
					p4.vec[4] = newev6;
					p4.vec[5] = newev5;
					p4.vec[6] = flop2 ? e2.vec21 : e2.vec23;
					p4.vec[7] = flop2 ? e2.vec12 : e2.vec32;
					p4.interior[0] = vec++;
					p4.interior[1] = vec++;
					p4.interior[2] = vec++;
					p4.interior[3] = vec++;

					// If this patch is textured, create five new texture verts for it
					for(chan = 0; chan < patch->getNumMaps(); ++chan) {
						if(patch->tvPatches[chan]) {
							int tva = tvert[chan]++;
							int tvb = tvert[chan]++;
							int tvc = tvert[chan]++;
							int tvd = tvert[chan]++;
							int tve = tvert[chan]++;
							TVPatch &tp = patch->tvPatches[chan][i];
							TVPatch &tp1 = patch->tvPatches[chan][tpat[chan]++];
							TVPatch &tp2 = patch->tvPatches[chan][tpat[chan]++];
							TVPatch &tp3 = patch->tvPatches[chan][tpat[chan]++];
							TVPatch &tp4 = patch->tvPatches[chan][tpat[chan]++];
							tp1.tv[0] = tp.tv[0];
							tp1.tv[1] = tva;
							tp1.tv[2] = tve;
							tp1.tv[3] = tvd;
							tp2.tv[0] = tp.tv[1];
							tp2.tv[1] = tvb;
							tp2.tv[2] = tve;
							tp2.tv[3] = tva;
							tp3.tv[0] = tp.tv[2];
							tp3.tv[1] = tvc;
							tp3.tv[2] = tve;
							tp3.tv[3] = tvb;
							tp4.tv[0] = tp.tv[3];
							tp4.tv[1] = tvd;
							tp4.tv[2] = tve;
							tp4.tv[3] = tvc;
							patch->tVerts[chan][tva] = (patch->tVerts[chan][tp.tv[0]] + patch->tVerts[chan][tp.tv[1]]) / 2.0f;
							patch->tVerts[chan][tvb] = (patch->tVerts[chan][tp.tv[1]] + patch->tVerts[chan][tp.tv[2]]) / 2.0f;
							patch->tVerts[chan][tvc] = (patch->tVerts[chan][tp.tv[2]] + patch->tVerts[chan][tp.tv[3]]) / 2.0f;
							patch->tVerts[chan][tvd] = (patch->tVerts[chan][tp.tv[3]] + patch->tVerts[chan][tp.tv[0]]) / 2.0f;
							patch->tVerts[chan][tve] = (patch->tVerts[chan][tp.tv[0]] + patch->tVerts[chan][tp.tv[1]] + patch->tVerts[chan][tp.tv[2]] + patch->tVerts[chan][tp.tv[3]]) / 4.0f;
							}
						}

					// If it's not an auto patch, compute the new interior points
					if(!(p.flags & PATCH_AUTO)) {
						p1.flags &= ~PATCH_AUTO;
						p2.flags &= ~PATCH_AUTO;
						p3.flags &= ~PATCH_AUTO;
						p4.flags &= ~PATCH_AUTO;

						Point3 a,b,c,d;
						Point3 a1,b1,c1,d1;
						Point3 a2,b2,c2,d2;
						Point3 a3,b3,c3,d3;
						Point3 a4,b4,c4,d4;
						InterpEdge(patch, i, 0.5f, 0, 0, 1, 1, &a1, &b1, &c1, &d1);
						InterpCenter(patch, i, 7, 0, 1, 2, &a2, &b2, &c2, &d2);
						InterpCenter(patch, i, 6, 3, 2, 3, &a3, &b3, &c3, &d3);
						InterpEdge(patch, i, 0.5f, 3, 5, 4, 2, &a4, &b4, &c4, &d4);

						InterpCenter(a1, a2, a3, a4, &a, &b, &c, &d);
						patch->vecs[p1.interior[0]].p = a;
						patch->vecs[p1.interior[3]].p = b;
						patch->vecs[p4.interior[1]].p = c;
						patch->vecs[p4.interior[0]].p = d;
						InterpCenter(b1, b2, b3, b4, &a, &b, &c, &d);
						patch->vecs[p1.interior[1]].p = a;
						patch->vecs[p1.interior[2]].p = b;
						patch->vecs[p4.interior[2]].p = c;
						patch->vecs[p4.interior[3]].p = d;
						InterpCenter(c1, c2, c3, c4, &a, &b, &c, &d);
						patch->vecs[p2.interior[3]].p = a;
						patch->vecs[p2.interior[2]].p = b;
						patch->vecs[p3.interior[2]].p = c;
						patch->vecs[p3.interior[1]].p = d;
						InterpCenter(d1, d2, d3, d4, &a, &b, &c, &d);
						patch->vecs[p2.interior[0]].p = a;
						patch->vecs[p2.interior[1]].p = b;
						patch->vecs[p3.interior[3]].p = c;
						patch->vecs[p3.interior[0]].p = d;
						}
					}
				else
				if(pi.div02) {					// Divide edges 0 & 2
					// Need to create two new patches
					// Compute new edge vectors between new edge verts
					int newev1 = vec++;	// edge 0 -> edge 2
					int newev2 = vec++;	// edge 2 -> edge 0

					// Get pointers to new edges
					NewEdge &e0 = eMap[p.edge[0]];
					NewEdge &e2 = eMap[p.edge[2]];

					// See if edges need to be flopped
					BOOL flop0 = (e0.v1 == p.v[0]) ? FALSE : TRUE;
					BOOL flop2 = (e2.v1 == p.v[2]) ? FALSE : TRUE;

					// Compute the new vectors for the dividing line
					
					patch->vecs[newev1].p = InterpCenter(patch, i, 7, 0, 1, 2);
					patch->vecs[newev2].p = InterpCenter(patch, i, 6, 3, 2, 3);

					// Create the two new patches
					Patch &p1 = patch->patches[pat++];
					Patch &p2 = patch->patches[pat++];

					p1.SetType(PATCH_QUAD);
					p1.v[0] = flop0 ? e0.v3 : e0.v1;
					p1.v[1] = e0.v2;
					p1.v[2] = e2.v2;
					p1.v[3] = flop2 ? e2.v1 : e2.v3;
					p1.vec[0] = flop0 ? e0.vec32 : e0.vec12;
					p1.vec[1] = flop0 ? e0.vec23 : e0.vec21;
					p1.vec[2] = newev1;
					p1.vec[3] = newev2;
					p1.vec[4] = flop2 ? e2.vec21 : e2.vec23;
					p1.vec[5] = flop2 ? e2.vec12 : e2.vec32;
					p1.vec[6] = p.vec[6];
					p1.vec[7] = p.vec[7];
					p1.interior[0] = vec++;
					p1.interior[1] = vec++;
					p1.interior[2] = vec++;
					p1.interior[3] = vec++;

					p2.SetType(PATCH_QUAD);
					p2.v[0] = e0.v2;
					p2.v[1] = flop0 ? e0.v1 : e0.v3;
					p2.v[2] = flop2 ? e2.v3 : e2.v1;
					p2.v[3] = e2.v2;
					p2.vec[0] = flop0 ? e0.vec21 : e0.vec23;
					p2.vec[1] = flop0 ? e0.vec12 : e0.vec32;
					p2.vec[2] = p.vec[2];
					p2.vec[3] = p.vec[3];
					p2.vec[4] = flop2 ? e2.vec32 : e2.vec12;
					p2.vec[5] = flop2 ? e2.vec23 : e2.vec21;
					p2.vec[6] = newev2;
					p2.vec[7] = newev1;
					p2.interior[0] = vec++;
					p2.interior[1] = vec++;
					p2.interior[2] = vec++;
					p2.interior[3] = vec++;

					// If this patch is textured, create two new texture verts for it
					for(chan = 0; chan < patch->getNumMaps(); ++chan) {
						if(patch->tvPatches[chan]) {
							int tva = tvert[chan]++;
							int tvb = tvert[chan]++;
							TVPatch &tp = patch->tvPatches[chan][i];
							TVPatch &tp1 = patch->tvPatches[chan][tpat[chan]++];
							TVPatch &tp2 = patch->tvPatches[chan][tpat[chan]++];
							tp1.tv[0] = tp.tv[0];
							tp1.tv[1] = tva;
							tp1.tv[2] = tvb;
							tp1.tv[3] = tp.tv[3];
							tp2.tv[0] = tva;
							tp2.tv[1] = tp.tv[1];
							tp2.tv[2] = tp.tv[2];
							tp2.tv[3] = tvb;
							patch->tVerts[chan][tva] = (patch->tVerts[chan][tp.tv[0]] + patch->tVerts[chan][tp.tv[1]]) / 2.0f;
							patch->tVerts[chan][tvb] = (patch->tVerts[chan][tp.tv[2]] + patch->tVerts[chan][tp.tv[3]]) / 2.0f;
							}
						}

					// If it's not an auto patch, compute the new interior points
					if(!(p.flags & PATCH_AUTO)) {
						p1.flags &= ~PATCH_AUTO;
						p2.flags &= ~PATCH_AUTO;

						Point3 a,b,c,d;
						InterpCenter(patch, i, 7, 0, 1, 2, &a, &b, &c, &d);
						patch->vecs[p1.interior[0]].p = a;
						patch->vecs[p1.interior[1]].p = b;
						patch->vecs[p2.interior[0]].p = c;
						patch->vecs[p2.interior[1]].p = d;
						InterpCenter(patch, i, 6, 3, 2, 3, &a, &b, &c, &d);
						patch->vecs[p1.interior[3]].p = a;
						patch->vecs[p1.interior[2]].p = b;
						patch->vecs[p2.interior[3]].p = c;
						patch->vecs[p2.interior[2]].p = d;
						}
					}
				else {							// Divide edges 1 & 3
					// Need to create two new patches
					// Compute new edge vectors between new edge verts
					int newev1 = vec++;	// edge 1 -> edge 3
					int newev2 = vec++;	// edge 3 -> edge 1

					// Get pointers to new edges
					NewEdge &e1 = eMap[p.edge[1]];
					NewEdge &e3 = eMap[p.edge[3]];

					// See if edges need to be flopped
					BOOL flop1 = (e1.v1 == p.v[1]) ? FALSE : TRUE;
					BOOL flop3 = (e3.v1 == p.v[3]) ? FALSE : TRUE;

					// Compute the new vectors for the dividing line
					patch->vecs[newev1].p = InterpCenter(patch, i, 1, 1, 2, 4);
					patch->vecs[newev2].p = InterpCenter(patch, i, 0, 0, 3, 5);

					// Create the two new patches
					Patch &p1 = patch->patches[pat++];
					Patch &p2 = patch->patches[pat++];

					p1.SetType(PATCH_QUAD);
					p1.v[0] = p.v[1];
					p1.v[1] = e1.v2;
					p1.v[2] = e3.v2;
					p1.v[3] = p.v[0];
					p1.vec[0] = flop1 ? e1.vec32 : e1.vec12;
					p1.vec[1] = flop1 ? e1.vec23 : e1.vec21;
					p1.vec[2] = newev1;
					p1.vec[3] = newev2;
					p1.vec[4] = flop3 ? e3.vec21 : e3.vec23;
					p1.vec[5] = flop3 ? e3.vec12 : e3.vec32;
					p1.vec[6] = p.vec[0];
					p1.vec[7] = p.vec[1];
					p1.interior[0] = vec++;
					p1.interior[1] = vec++;
					p1.interior[2] = vec++;
					p1.interior[3] = vec++;

					p2.SetType(PATCH_QUAD);
					p2.v[0] = e1.v2;
					p2.v[1] = p.v[2];
					p2.v[2] = p.v[3];
					p2.v[3] = e3.v2;
					p2.vec[0] = flop1 ? e1.vec21 : e1.vec23;
					p2.vec[1] = flop1 ? e1.vec12 : e1.vec32;
					p2.vec[2] = p.vec[4];
					p2.vec[3] = p.vec[5];
					p2.vec[4] = flop3 ? e3.vec32 : e3.vec12;
					p2.vec[5] = flop3 ? e3.vec23 : e3.vec21;
					p2.vec[6] = newev2;
					p2.vec[7] = newev1;
					p2.interior[0] = vec++;
					p2.interior[1] = vec++;
					p2.interior[2] = vec++;
					p2.interior[3] = vec++;

					// If this patch is textured, create two new texture verts for it
					for(chan = 0; chan < patch->getNumMaps(); ++chan) {
						if(patch->tvPatches[chan]) {
							int tva = tvert[chan]++;
							int tvb = tvert[chan]++;
							TVPatch &tp = patch->tvPatches[chan][i];
							TVPatch &tp1 = patch->tvPatches[chan][tpat[chan]++];
							TVPatch &tp2 = patch->tvPatches[chan][tpat[chan]++];
							tp1.tv[0] = tp.tv[1];
							tp1.tv[1] = tva;
							tp1.tv[2] = tvb;
							tp1.tv[3] = tp.tv[0];
							tp2.tv[0] = tva;
							tp2.tv[1] = tp.tv[2];
							tp2.tv[2] = tp.tv[3];
							tp2.tv[3] = tvb;
							patch->tVerts[chan][tva] = (patch->tVerts[chan][tp.tv[1]] + patch->tVerts[chan][tp.tv[2]]) / 2.0f;
							patch->tVerts[chan][tvb] = (patch->tVerts[chan][tp.tv[0]] + patch->tVerts[chan][tp.tv[3]]) / 2.0f;
							}
						}

					// If it's not an auto patch, compute the new interior points
					if(!(p.flags & PATCH_AUTO)) {
						p1.flags &= ~PATCH_AUTO;
						p2.flags &= ~PATCH_AUTO;

						Point3 a,b,c,d;
						InterpCenter(patch, i, 1, 1, 2, 4, &a, &b, &c, &d);
						patch->vecs[p1.interior[0]].p = a;
						patch->vecs[p1.interior[1]].p = b;
						patch->vecs[p2.interior[0]].p = c;
						patch->vecs[p2.interior[1]].p = d;
						InterpCenter(patch, i, 0, 0, 3, 5, &a, &b, &c, &d);
						patch->vecs[p1.interior[3]].p = a;
						patch->vecs[p1.interior[2]].p = b;
						patch->vecs[p2.interior[3]].p = c;
						patch->vecs[p2.interior[2]].p = d;
						}
					}	
				}
			pDivIx++;
			}
		}

	delete [] pInfo;
	delete [] eMap;

	// Now call the DeletePatchParts function to clean it all up
	BitArray dumVerts(patch->getNumVerts());
	dumVerts.ClearAll();
	BitArray dumPatches(patch->getNumPatches());
	dumPatches.ClearAll();
	// Mark the subdivided patches as deleted
	for(i = 0; i < patches; ++i)
		dumPatches.Set(i, pDiv[i]);

#ifdef DUMPING
DebugPrint("Before:\n");
patch->Dump();
#endif

	DeletePatchParts(patch, dumVerts, dumPatches);

#ifdef DUMPING
DebugPrint("After:\n");
patch->Dump();
#endif

	patch->computeInteriors();
	patch->buildLinkages();
	}

BOOL EdgeSubdivideRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		oldPatch = *patch;
	SubdividePatch(SUBDIV_EDGES, propagate, patch);
	return TRUE;
	}

#define ESUBR_PROPAGATE_CHUNK		0x1000
#define ESUBR_PATCH_CHUNK			0x1010

IOResult EdgeSubdivideRecord::Load(ILoad *iload) {
	IOResult res;
	propagate = FALSE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case ESUBR_PROPAGATE_CHUNK:
				propagate = TRUE;
				break;
//			case ESUBR_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/		

BOOL PatchSubdivideRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		oldPatch = *patch;
	SubdividePatch(SUBDIV_PATCHES, propagate, patch);
	return TRUE;
	}

#define PSUBR_PROPAGATE_CHUNK		0x1000
#define PSUBR_PATCH_CHUNK			0x1010

IOResult PatchSubdivideRecord::Load(ILoad *iload) {
	IOResult res;
	propagate = FALSE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case PSUBR_PROPAGATE_CHUNK:
				propagate = TRUE;
				break;
//			case PSUBR_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

BOOL PVertWeldRecord::Redo(PatchMesh *patch,int reRecord) {
	if(reRecord)
		oldPatch = *patch;
	patch->Weld(thresh);
	return TRUE;
	}

#define WELDR_THRESH_CHUNK			0x1010
#define WELDR_PATCH_CHUNK			0x1000

IOResult PVertWeldRecord::Load(ILoad *iload) {
	IOResult res;
	ULONG nb;
	propagate = FALSE;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case WELDR_THRESH_CHUNK:
				res = iload->Read(&thresh,sizeof(float),&nb);
				break;
//			case WELDR_PATCH_CHUNK:
//				res = oldPatch.Load(iload);
//				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}
	return IO_OK;
	}

/*-------------------------------------------------------------------*/

PatchRestore::PatchRestore(EditPatchData* pd, EditPatchMod* mod, PatchMesh *patch, TCHAR *id)
	{
	gotRedo = FALSE;
	epd = pd;
	this->mod = mod;
	oldPatch = *patch;
	t = mod->ip->GetTime();
	where = TSTR(id);
	}

void PatchRestore::Restore(int isUndo)
	{
	if ( epd->tempData && epd->TempData(mod)->PatchCached(t) ) {
		PatchMesh *patch = epd->TempData(mod)->GetPatch(t);
		if(patch) {
			if(isUndo && !gotRedo) {
				newPatch = *patch;
				gotRedo = TRUE;
				}
			}
		DWORD selLevel = patch->selLevel;	// Grab this...
		DWORD dispFlags = patch->dispFlags;	// Grab this...
		*patch = oldPatch;
		patch->selLevel = selLevel;	// ...and put it back in
		patch->dispFlags = dispFlags;	// ...and put it back in
		patch->InvalidateGeomCache();
		epd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT);
		}
	else
	if ( epd->tempData ) {
		epd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT, FALSE);
		}
	if(mod->ip)
		Cancel2StepPatchModes(mod->ip);
	mod->InvalidateSurfaceUI();
	mod->SelectionChanged();
	mod->NotifyDependents(FOREVER, PART_GEOM | PART_TOPO | PART_SELECT, REFMSG_CHANGE);
	}

void PatchRestore::Redo()
	{
	if ( epd->tempData && epd->TempData(mod)->PatchCached(t) ) {
		PatchMesh *patch = epd->TempData(mod)->GetPatch(t);
		if(patch) {
			DWORD selLevel = patch->selLevel;	// Grab this...
			DWORD dispFlags = patch->dispFlags;	// Grab this...
			*patch = newPatch;
			patch->selLevel = selLevel;	// ...and put it back in
			patch->dispFlags = dispFlags;	// ...and put it back in
			patch->InvalidateGeomCache();
			}
		epd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT);
		}
	else
	if ( epd->tempData ) {
		epd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT,FALSE);
		}
	if(mod->ip)
		Cancel2StepPatchModes(mod->ip);
	mod->InvalidateSurfaceUI();
	mod->SelectionChanged();
	mod->NotifyDependents(FOREVER, PART_GEOM | PART_TOPO | PART_SELECT, REFMSG_CHANGE);
	}

/*-------------------------------------------------------------------*/

PatchSelRestore::PatchSelRestore(EditPatchData* pd, EditPatchMod* mod, PatchMesh *patch)
	{
	gotRedo = FALSE;
	epd = pd;
	this->mod = mod;
	oldVSel = patch->vertSel;
	oldESel = patch->edgeSel;
	oldPSel = patch->patchSel;
	t = mod->ip->GetTime();
	}

void PatchSelRestore::Restore(int isUndo)
	{
	if ( epd->tempData && epd->TempData(mod)->PatchCached(t) ) {
		PatchMesh *patch = epd->TempData(mod)->GetPatch(t);
		if(patch) {
			if(isUndo && !gotRedo) {
				newVSel = patch->vertSel;
				newESel = patch->edgeSel;
				newPSel = patch->patchSel;
				gotRedo = TRUE;
				}
			}
		patch->vertSel = oldVSel;
		patch->edgeSel = oldESel;
		patch->patchSel = oldPSel;
		epd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT);
		}
	else
	if ( epd->tempData ) {
		epd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT, FALSE);
		}
	if(mod->ip)
		Cancel2StepPatchModes(mod->ip);
	mod->InvalidateSurfaceUI();
//	mod->PatchSelChanged();
//	mod->UpdateSelectDisplay();
	mod->NotifyDependents(FOREVER, PART_GEOM | PART_TOPO | PART_SELECT, REFMSG_CHANGE);
	}

void PatchSelRestore::Redo()
	{
	if ( epd->tempData && epd->TempData(mod)->PatchCached(t) ) {
		PatchMesh *patch = epd->TempData(mod)->GetPatch(t);
		if(patch) {
			patch->vertSel = newVSel;
			patch->edgeSel = newESel;
			patch->patchSel = newPSel;
			}
		epd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT);
		}
	else
	if ( epd->tempData ) {
		epd->TempData(mod)->Invalidate(PART_GEOM | PART_TOPO | PART_SELECT,FALSE);
		}
	if(mod->ip)
		Cancel2StepPatchModes(mod->ip);
	mod->InvalidateSurfaceUI();
//	mod->PatchSelChanged();
//	mod->UpdateSelectDisplay();
	mod->NotifyDependents(FOREVER, PART_GEOM | PART_TOPO | PART_SELECT, REFMSG_CHANGE);
	}

/*-------------------------------------------------------------------*/

BOOL PickPatchAttach::Filter(INode *node)
	{
	ModContextList mcList;		
	INodeTab nodes;
	if (node) {
		// Make sure the node does not depend on us
		node->BeginDependencyTest();
		ep->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
		if (node->EndDependencyTest()) return FALSE;

		ObjectState os = node->GetObjectRef()->Eval(ep->ip->GetTime());
		GeomObject *object = (GeomObject *)os.obj;
		// Make sure it isn't one of the nodes we're editing, for heaven's sake!
		ep->ip->GetModContexts(mcList,nodes);
		int numNodes = nodes.Count();
		for(int i = 0; i < numNodes; ++i) {
			if(nodes[i] == node) {
				nodes.DisposeTemporary();
				return FALSE;
				}
			}
		if(object->CanConvertToType(patchObjectClassID)) {
			nodes.DisposeTemporary();
			return TRUE;
			}
		}
	nodes.DisposeTemporary();
	return FALSE;
	}

BOOL PickPatchAttach::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	ModContextList mcList;		
	INodeTab nodes;
	
	if (node) {
		ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		GeomObject *object = (GeomObject *)os.obj;
		// Make sure it isn't one of the nodes we're editing, for heaven's sake!
		ep->ip->GetModContexts(mcList,nodes);
		int numNodes = nodes.Count();
		for(int i = 0; i < numNodes; ++i) {
			if(nodes[i] == node) {
				nodes.DisposeTemporary();
				return FALSE;
				}
			}
		if(object->CanConvertToType(patchObjectClassID)) {
			nodes.DisposeTemporary();
			return TRUE;
			}
		}

	nodes.DisposeTemporary();
	return FALSE;
	}

BOOL PickPatchAttach::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	GeomObject *object = (GeomObject *)node->GetObjectRef()->Eval(ip->GetTime()).obj;
	if(object->CanConvertToType(patchObjectClassID)) {
		PatchObject *attPatch = (PatchObject *)object->ConvertToType(ip->GetTime(),patchObjectClassID);
		if(attPatch) {
			PatchMesh patch = attPatch->patch;
			ModContextList mcList;
			INodeTab nodes;
			ip->GetModContexts(mcList,nodes);
			BOOL res = TRUE;
			if (nodes[0]->GetMtl() && node->GetMtl() && (nodes[0]->GetMtl()!=node->GetMtl()))
				res = DoAttachMatOptionDialog(ep->ip, ep);
			if(res) {
				bool canUndo = TRUE;
				ep->DoAttach(node, &patch, canUndo);
				if (!canUndo)
					GetSystemSetting (SYSSET_CLEAR_UNDO);
				}
			nodes.DisposeTemporary();
			// Discard the copy it made, if it isn't the same as the object itself
			if(attPatch != (PatchObject *)object)
				delete attPatch;
			}
		}
	return FALSE;
	}


void PickPatchAttach::EnterMode(IObjParam *ip)
	{
	if ( ep->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(ep->hOpsPanel,IDC_ATTACH));
		but->SetCheck(TRUE);
		ReleaseICustButton(but);
		}
	}

void PickPatchAttach::ExitMode(IObjParam *ip)
	{
	if ( ep->hOpsPanel ) {
		ICustButton *but = GetICustButton(GetDlgItem(ep->hOpsPanel,IDC_ATTACH));
		but->SetCheck(FALSE);
		ReleaseICustButton(but);
		}
	}

HCURSOR PickPatchAttach::GetHitCursor(IObjParam *ip) {
	return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_ATTACHCUR));
	}

int EditPatchMod::DoAttach(INode *node, PatchMesh *attPatch, bool & canUndo) {
	ModContextList mcList;	
	INodeTab nodes;	

	if ( !ip ) return 0;

	ip->GetModContexts(mcList,nodes);

	if(mcList.Count() != 1) {
		nodes.DisposeTemporary();
		return 0;
		}

	EditPatchData *patchData = (EditPatchData*)mcList[0]->localData;
	if ( !patchData ) {
		nodes.DisposeTemporary();
		return 0;
		}
	patchData->BeginEdit(ip->GetTime());

	// If the mesh isn't yet cached, this will cause it to get cached.
	PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
	if(!patch) {
		nodes.DisposeTemporary();
		return 0;
		}
	patchData->RecordTopologyTags(patch);
	RecordTopologyTags();

	// Transform the shape for attachment:
	// If reorienting, just translate to align pivots
	// Otherwise, transform to match our transform
	Matrix3 attMat(1);
	if(attachReorient) {
		Matrix3 thisTM = nodes[0]->GetNodeTM(ip->GetTime());
		Matrix3 thisOTMBWSM = nodes[0]->GetObjTMBeforeWSM(ip->GetTime());
		Matrix3 thisPivTM = thisTM * Inverse(thisOTMBWSM);
		Matrix3 otherTM = node->GetNodeTM(ip->GetTime());
		Matrix3 otherOTMBWSM = node->GetObjTMBeforeWSM(ip->GetTime());
		Matrix3 otherPivTM = otherTM * Inverse(otherOTMBWSM);
		Point3 otherObjOffset = node->GetObjOffsetPos();
		attMat = Inverse(otherPivTM) * thisPivTM;
		}
	else {
		attMat = node->GetObjectTM(ip->GetTime()) *
			Inverse(nodes[0]->GetObjectTM(ip->GetTime()));
		}
		
	// RB 3-17-96 : Check for mirroring
	AffineParts parts;
	decomp_affine(attMat,&parts);
	if (parts.f<0.0f) {
		int v[8], ct, ct2, j;
		Point3 p[9];
//watje 10-21-99  212991 since there is topochange need to record and resolve topo 
//		even though it is a temporary object  to update any bind
		attPatch->RecordTopologyTags();

		for (int i=0; i<attPatch->numPatches; i++) {
			
			// Re-order vertices
			ct = attPatch->patches[i].type==PATCH_QUAD ? 4 : 3;
			for (j=0; j<ct; j++) {
				v[j] = attPatch->patches[i].v[j];
				}
			for (j=0; j<ct; j++) {
				attPatch->patches[i].v[j] = v[ct-j-1];
				}

			// Re-order vecs
			ct  = attPatch->patches[i].type==PATCH_QUAD ? 8 : 6;
			ct2 = attPatch->patches[i].type==PATCH_QUAD ? 5 : 3;
			for (j=0; j<ct; j++) {
				v[j] = attPatch->patches[i].vec[j];
				}
			for (j=0; j<ct; j++,ct2--) {
				if (ct2<0) ct2 = ct-1;
				attPatch->patches[i].vec[j] = v[ct2];
				}

			// Re-order enteriors
			if (attPatch->patches[i].type==PATCH_QUAD) {
				ct = 4;
				for (j=0; j<ct; j++) {
					v[j] = attPatch->patches[i].interior[j];
					}
				for (j=0; j<ct; j++) {
					attPatch->patches[i].interior[j] = v[ct-j-1];
					}
				}

			// Re-order aux
			if (attPatch->patches[i].type==PATCH_TRI) {
				ct = 9;
				for (j=0; j<ct; j++) {
					p[j] = attPatch->patches[i].aux[j];
					}
				for (j=0; j<ct; j++) {
					attPatch->patches[i].aux[j] = p[ct-j-1];
					}
				}

			// Re-order TV faces if present
			for(int chan = 0; chan < patch->getNumMaps(); ++chan) {
				if (attPatch->tvPatches[chan]) {
					ct = attPatch->patches[i].type==PATCH_QUAD ? 4 : 3;
					for (j=0; j<ct; j++) {
						v[j] = attPatch->tvPatches[chan][i].tv[j];
						}
					for (j=0; j<ct; j++) {
						attPatch->tvPatches[chan][i].tv[j] = v[ct-j-1];
						}
					}
				}
			}
//watje 10-21-99  212991 since there is topochange need to record and resolve topo 
//		even though it is a temporary object  to update any bind
		attPatch->buildLinkages();
		attPatch->HookFixTopology();
		}

	for(int i = 0; i < attPatch->numVerts; ++i)
		attPatch->verts[i].p = attPatch->verts[i].p * attMat;
	for(i = 0; i < attPatch->numVecs; ++i)
		attPatch->vecs[i].p = attPatch->vecs[i].p * attMat;
	attPatch->computeInteriors();

	theHold.Begin();

	// Combine the materials of the two nodes.
	int mat2Offset=0;
	Mtl *m1 = nodes[0]->GetMtl();
	Mtl *m2 = node->GetMtl();
	bool condenseMe = FALSE;
	if (m1 && m2 && (m1 != m2)) {
		if (attachMat==ATTACHMAT_IDTOMAT) {
			int ct=1;
			if (m1->IsMultiMtl())
				ct = m1->NumSubMtls();
			for(int i = 0; i < patch->numPatches; ++i) {
				int mtid = patch->getPatchMtlIndex(i);
				if(mtid >= ct)
					patch->setPatchMtlIndex(i, mtid % ct);
				}
			FitPatchIDsToMaterial (*attPatch, m2);
			if (condenseMat) condenseMe = TRUE;
			}
		// the theHold calls here were a vain attempt to make this all undoable.
		// This should be revisited in the future so we don't have to use the SYSSET_CLEAR_UNDO.
		theHold.Suspend ();
		if (attachMat==ATTACHMAT_MATTOID) {
			m1 = FitMaterialToPatchIDs (*patch, m1);
			m2 = FitMaterialToPatchIDs (*attPatch, m2);
			}

		Mtl *multi = CombineMaterials (m1, m2, mat2Offset);
		if (attachMat == ATTACHMAT_NEITHER) mat2Offset = 0;
		theHold.Resume ();
		// We can't be in face subobject mode, else we screw up the materials:
		DWORD oldSL = patch->selLevel;
		patch->selLevel = PATCH_OBJECT;
		nodes[0]->SetMtl(multi);
		patch->selLevel = oldSL;
		m1 = multi;
		canUndo = FALSE;	// Absolutely cannot undo material combinations.
		}
	if (!m1 && m2) {
		// We can't be in face subobject mode, else we screw up the materials:
		DWORD oldSL = patch->selLevel;
		patch->selLevel = PATCH_OBJECT;
		nodes[0]->SetMtl(m2);
		patch->selLevel = oldSL;
		m1 = m2;
		}

	// Start a restore object...
	if ( theHold.Holding() )
		theHold.Put(new PatchRestore(patchData,this,patch,"DoAttach"));

	// Do the attach
	patch->Attach(attPatch, mat2Offset);
	patchData->UpdateChanges(patch);
	patchData->TempData(this)->Invalidate(PART_TOPO|PART_GEOM);

	// Get rid of the original node
	ip->DeleteNode(node);

	ResolveTopoChanges();
	theHold.Accept(GetString(IDS_TH_ATTACH));

	if (m1 && condenseMe) {
		// Following clears undo stack.
		patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		m1 = CondenseMatAssignments (*patch, m1);
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO|PART_GEOM, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	return 1;
	}

/*-------------------------------------------------------------------*/

EditPatchMod::EditPatchMod()
	{
	selLevel = EP_OBJECT;
	displayLattice = TRUE;
	displaySurface = TRUE;
	propagate = TRUE;
	meshSteps = 5;
//3-18-99 to suport render steps and removal of the mental tesselator
	meshStepsRender = 5;
	showInterior = TRUE;

	namedSelNeedsFixup = FALSE;
//	meshAdaptive = FALSE;	// Future use (Not used now)
	}

EditPatchMod::~EditPatchMod()
	{
	ClearSetNames();
	}

Interval EditPatchMod::LocalValidity(TimeValue t)
	{
	// Force a cache if being edited.
	if (TestAFlag(A_MOD_BEING_EDITED))
		return NEVER;  			   
	return FOREVER;
	}

RefTargetHandle EditPatchMod::Clone(RemapDir& remap) {
	EditPatchMod* newmod = new EditPatchMod();	
	newmod->selLevel = selLevel;
	newmod->displaySurface = displaySurface;
	newmod->displayLattice = displayLattice;
	newmod->meshSteps = meshSteps;
//3-18-99 to suport render steps and removal of the mental tesselator
	newmod->meshStepsRender = meshStepsRender;
	newmod->showInterior = showInterior;

//	newmod->meshAdaptive = meshAdaptive;	// Future use (Not used now)
	newmod->viewTess = viewTess;
	newmod->prodTess = prodTess;
	newmod->dispTess = dispTess;
	newmod->mViewTessNormals = mViewTessNormals;
	newmod->mProdTessNormals = mProdTessNormals;
	newmod->mViewTessWeld = mViewTessWeld;
	newmod->mProdTessWeld = mProdTessWeld;
	newmod->propagate = propagate;
	return(newmod);
	}

void EditPatchMod::ClearPatchDataFlag(ModContextList& mcList,DWORD f)
	{
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		patchData->SetFlag(f,FALSE);
		}
	}

void EditPatchMod::XFormHandles(XFormProc *xproc, TimeValue t, Matrix3& partm, Matrix3& tmAxis,	int object, int handleIndex)
	{	
	ModContextList mcList;		
	INodeTab nodes;
	Matrix3 mat,imat,theMatrix;
	Interval valid;
	int numAxis;
	Point3 oldpt,newpt,oldin,oldout,rel;
	BOOL shiftPressed = FALSE;
	static BOOL wasBroken;
	Point3 theKnot;
	Point3 oldVector;
	Point3 newVector;
	float oldLen;
	float newLen;
//DebugPrint("XFormHandles\n");
	shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) ? TRUE : FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	numAxis = ip->GetNumAxis();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	EditPatchData *patchData = (EditPatchData*)mcList[object]->localData;
	if ( !patchData ) {
		nodes.DisposeTemporary();
		return;
		}
	
	// If the mesh isn't yet cache, this will cause it to get cached.
	PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
	if(!patch) {
		nodes.DisposeTemporary();
		return;
		}
			
	// If this is the first edit, then the delta arrays will be allocated
	patchData->BeginEdit(t);

	// Create a change record for this object and store a pointer to its delta info in this EditPatchData
	if(!TestAFlag(A_HELD)) {
		patchData->vdelta.SetSize(*patch,FALSE);
		if ( theHold.Holding() ) {
			theHold.Put(new PatchRestore(patchData,this,patch,"XFormHandles"));
			}
		patchData->vdelta.Zero();		// Reset all deltas
		patchData->ClearHandleFlag();
		wasBroken = FALSE;
		}
	else {
		if(wasBroken && !shiftPressed)
			wasBroken = FALSE;
		if(patchData->DoingHandles())
			patchData->ApplyHandlesAndZero(*patch);		// Reapply the slave handle deltas
		else
			patchData->vdelta.Zero();
		}

	patchData->SetHandleFlag(handleIndex);
	int primaryKnot = patch->vecs[handleIndex].vert;
	Point3Tab &pDeltas = patchData->vdelta.dtab.vtab;

	tmAxis = ip->GetTransformAxis(nodes[object],primaryKnot);
	mat    = nodes[object]->GetObjectTM(t,&valid) * Inverse(tmAxis);
	imat   = Inverse(mat);
	xproc->SetMat(mat);
				
	// XForm the cache vertices
	oldpt = patch->vecs[handleIndex].p;
	newpt = xproc->proc(oldpt,mat,imat);

	// Update the vector being moved
	patch->vecs[handleIndex].p = newpt;

	// Move the delta's vertices.
	patchData->vdelta.SetVec(handleIndex,newpt - oldpt);

	if(primaryKnot >= 0) {
		PatchVert &vert = patch->verts[primaryKnot];
		theKnot = vert.p;
		// If locked handles, turn the movement into a transformation matrix
		// and transform all the handles attached to the owner vertex
		if(lockedHandles) {
			if(!wasBroken && shiftPressed)
				wasBroken = TRUE;
			goto locked_handles;
			}
		else {
			if(shiftPressed) {
				wasBroken = TRUE;
				vert.flags &= ~PVERT_COPLANAR;
				// Need to record this for undo!
				patchData->vdelta.SetVertType(primaryKnot,PVERT_COPLANAR);
				}
			// If a coplanar knot, do the other vectors!
			// If at the same point as knot, do nothing!
			if((vert.flags & PVERT_COPLANAR) && (vert.vectors.Count() > 2) && !(newpt == theKnot)) {
locked_handles:
				oldVector = oldpt - theKnot;
				newVector = newpt - theKnot;
				oldLen = Length(oldVector);
				newLen = Length(newVector);
				Point3 oldNorm = Normalize(oldVector);
				Point3 newNorm = Normalize(newVector);
				theMatrix.IdentityMatrix();
				Point3 axis;
				float angle = 0.0f;
				int owner = patch->vecs[handleIndex].vert;
				if(owner >= 0) {
					PatchVert &vert = patch->verts[owner];
					int vectors = vert.vectors.Count();
					// Watch out for cases where the vectors are exactly opposite -- This
					// results in an invalid axis for transformation!
					// In this case, we look for a vector to one of the other handles that
					// will give us a useful vector for the rotational axis
					if(newNorm == -oldNorm) {
						for(int v = 0; v < vectors; ++v) {
							int theVec = vert.vectors[v];
							// Ignore the vector being moved!
							if(theVec != handleIndex) {
								Point3 testVec = patch->vecs[theVec].p - pDeltas[theVec] - theKnot;
								if(testVec != zeroPoint) {
									Point3 testNorm = Normalize(testVec);
									if(!(testNorm == newNorm) && !(testNorm == oldNorm)) {
										// Cross product gives us the normal of the rotational axis
										axis = Normalize(testNorm ^ newNorm);
										// The angle is 180 degrees
										angle = PI;
										goto build_matrix;
										}
									}
								}
							}
						}
					else {
						// Get a matrix that will transform the old point to the new one
						// Cross product gives us the normal of the rotational axis
						axis = Normalize(oldNorm ^ newNorm);
						// Dot product gives us the angle
						float dot = DotProd(oldNorm, newNorm);
						if(dot >= -1.0f && dot <= 1.0f)
							angle = (float)-acos(dot);
						}
build_matrix:
					if(angle != 0.0f) {
						// Now let's build a matrix that'll do this for us!
						Quat quat = QFromAngAxis(angle, axis);
						quat.MakeMatrix(theMatrix);
						if(lockedHandles) {
							// If need to break the vector, 
							if(shiftPressed && vert.flags & PVERT_COPLANAR) {
								vert.flags &= ~PVERT_COPLANAR;
								patchData->vdelta.SetVertType(primaryKnot,PVERT_COPLANAR);
								}
							}
						}
					// Process all other handles through the matrix
					for(int v = 0; v < vectors; ++v) {
						int theVec = vert.vectors[v];
						// Ignore the vector being moved!
						if(theVec != handleIndex) {
							Point3 oldpt2 = patch->vecs[theVec].p - pDeltas[theVec];
							Point3 newpt2 = (oldpt2 - theKnot) * theMatrix + theKnot;
							patch->vecs[theVec].p = newpt2;
							// Move the delta's vertices.
							patchData->vdelta.SetVec(theVec,newpt2 - oldpt2);
							}
						}
					}
				}
			}
		}

	// Really only need to do this if neighbor knots are non-bezier
	patch->computeInteriors();

	patchData->UpdateChanges(patch);					
	patchData->TempData(this)->Invalidate(PART_GEOM);
	patchData->SetFlag(EPD_BEENDONE,TRUE);
	
	// Mark all objects in selection set
	SetAFlag(A_HELD);
	
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

void EditPatchMod::XFormVerts( 
		XFormProc *xproc, 
		TimeValue t, 
		Matrix3& partm, 
		Matrix3& tmAxis  ) 
	{	
	ModContextList mcList;		
	INodeTab nodes;
	Matrix3 mat,imat;	
	Interval valid;
	int numAxis;
	Point3 oldpt,newpt,rel,delta;
	int shiftPressed = (GetKeyState(VK_SHIFT) & 0x8000) ? 1 : 0;
	static BOOL wasBroken;
	static BOOL handleEdit = FALSE;
	static int handleObject;
	static int handleIndex;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	numAxis = ip->GetNumAxis();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	if(!TestAFlag(A_HELD)) {
		handleEdit = FALSE;
//DebugPrint("Handle edit cleared\n");
		// Check all patches to see if they are altering a bezier vector handle...
		if(selLevel == EP_VERTEX) {
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
				if ( !patchData ) continue;
				if ( patchData->GetFlag(EPD_BEENDONE) ) continue;
		
				// If the mesh isn't yet cache, this will cause it to get cached.
				PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
				if(!patch)
					continue;

				if(!ip->SelectionFrozen() && patch->bezVecVert >= 0) {
					// Editing a bezier handle -- Go do it!
					handleEdit = TRUE;
					handleObject = i;
					handleIndex = patch->bezVecVert;
					goto edit_handles;
					}
	 			patchData->SetFlag(EPD_BEENDONE,TRUE);
				}
			}
		}
	
	// If editing the handles, cut to the chase!
	if(handleEdit) {
		edit_handles:
		XFormHandles(xproc, t, partm, tmAxis, handleObject, handleIndex);
		nodes.DisposeTemporary();
		return;
		}

	// Not doing handles, just plain ol' verts
	ClearPatchDataFlag(mcList,EPD_BEENDONE);	// Clear these out again
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;
		
		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
					
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// Create a change record for this object and store a pointer to its delta info in this EditPatchData
		if(!TestAFlag(A_HELD)) {
			patchData->vdelta.SetSize(*patch,FALSE);
			if ( theHold.Holding() ) {
				theHold.Put(new PatchRestore(patchData,this,patch,"XFormVerts"));
				}
			patchData->vdelta.Zero();		// Reset all deltas
			patchData->ClearHandleFlag();
			wasBroken = FALSE;
			}
		else {
			if(wasBroken)
				shiftPressed = TRUE;
			if(patchData->DoingHandles())
				patchData->ApplyHandlesAndZero(*patch);		// Reapply the slave handle deltas
			else
				patchData->vdelta.Zero();
			}

		// Compute the transforms
		if (numAxis==NUMAXIS_INDIVIDUAL) {
			switch(selLevel) {
				case EP_VERTEX: {
					// Selected vertices - either directly or indirectly through selected faces or edges.
					BitArray sel = patch->VertexTempSel();
					int verts = patch->numVerts;
					for( int vert = 0; vert < verts; vert++ ) {
						if ( sel[vert] ) {
							tmAxis = ip->GetTransformAxis(nodes[i],vert);
							mat    = nodes[i]->GetObjectTM(t,&valid) * Inverse(tmAxis);
							imat   = Inverse(mat);
							xproc->SetMat(mat);
			
							// XForm the cache vertices
							oldpt = patch->verts[vert].p;
							newpt = xproc->proc(oldpt,mat,imat);
							patch->verts[vert].p = newpt;
							delta = newpt - oldpt;

							// Move the delta's vertices.
							patchData->vdelta.MoveVert(vert,delta);

							// Also affect its vectors
							int vecs = patch->verts[vert].vectors.Count();
							for(int vec = 0; vec < vecs; ++vec) {
								int index = patch->verts[vert].vectors[vec];
								// XForm the cache vertices
								oldpt = patch->vecs[index].p;
								newpt = xproc->proc(oldpt,mat,imat);
								patch->vecs[index].p = newpt;
								delta = newpt - oldpt;

								// Move the delta's vertices.
								patchData->vdelta.MoveVec(index,delta);
								}
							}
						}
					patch->computeInteriors();	// Kind of broad-spectrum -- only need to recompute affected patches
					}
					break;
				case EP_EDGE:
				case EP_PATCH: {
					// Selected vertices - either directly or indirectly through selected faces or edges.
					BitArray sel = patch->VertexTempSel();
					int verts = patch->numVerts;
					for( int vert = 0; vert < verts; vert++ ) {
						if ( sel[vert] ) {
							tmAxis = ip->GetTransformAxis(nodes[i],vert);
							mat    = nodes[i]->GetObjectTM(t,&valid) * Inverse(tmAxis);
							imat   = Inverse(mat);
							xproc->SetMat(mat);
			
							// XForm the cache vertices
							oldpt = patch->verts[vert].p;
							newpt = xproc->proc(oldpt,mat,imat);
							patch->verts[vert].p = newpt;
							delta = newpt - oldpt;

							// Move the delta's vertices.
							patchData->vdelta.MoveVert(vert,delta);

							// Also affect its vectors
							int vecs = patch->verts[vert].vectors.Count();
							for(int vec = 0; vec < vecs; ++vec) {
								int index = patch->verts[vert].vectors[vec];
								// XForm the cache vertices
								oldpt = patch->vecs[index].p;
								newpt = xproc->proc(oldpt,mat,imat);
								patch->vecs[index].p = newpt;
								delta = newpt - oldpt;

								// Move the delta's vertices.
								patchData->vdelta.MoveVec(index,delta);
								}
							}
						}
					patch->computeInteriors();
					}
					break;
				}			
			}
		else {
			mat = nodes[i]->GetObjectTM(t,&valid) * Inverse(tmAxis);
			imat = Inverse(mat);
			xproc->SetMat(mat);

			// Selected vertices - either directly or indirectly through selected faces or edges.
			BitArray sel = patch->VertexTempSel();
			int verts = patch->numVerts;
			for( int vert = 0; vert < verts; vert++ ) {
				if ( sel[vert] ) {
					// XForm the cache vertices
					oldpt = patch->verts[vert].p;
					newpt = xproc->proc(oldpt,mat,imat);
					patch->verts[vert].p = newpt;
					delta = newpt - oldpt;

					// Move the delta's vertices.
					patchData->vdelta.MoveVert(vert,delta);

					// Also affect its vectors
					int vecs = patch->verts[vert].vectors.Count();
					for(int vec = 0; vec < vecs; ++vec) {
						int index = patch->verts[vert].vectors[vec];
						// XForm the cache vertices
						oldpt = patch->vecs[index].p;
						newpt = xproc->proc(oldpt,mat,imat);
						patch->vecs[index].p = newpt;
						delta = newpt - oldpt;

						// Move the delta's vertices.
						patchData->vdelta.MoveVec(index,delta);
						}
					}
				}
			patch->computeInteriors();
			}
		patchData->UpdateChanges(patch);					
		patchData->TempData(this)->Invalidate(PART_GEOM);
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	// Mark all objects in selection set
	SetAFlag(A_HELD);
	
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

void EditPatchMod::Move( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin )
	{
	MoveXForm proc(val);
	XFormVerts(&proc,t,partm,tmAxis); 	
	}

void EditPatchMod::Rotate( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Quat& val, BOOL localOrigin )
	{
	RotateXForm proc(val);
	XFormVerts(&proc,t,partm,tmAxis); 	
	}

void EditPatchMod::Scale( TimeValue t, Matrix3& partm, Matrix3& tmAxis, Point3& val, BOOL localOrigin )
	{
	ScaleXForm proc(val);
	XFormVerts(&proc,t,partm,tmAxis); 	
	}

void EditPatchMod::TransformStart(TimeValue t)
	{
	if (ip) ip->LockAxisTripods(TRUE);
	}

void EditPatchMod::TransformFinish(TimeValue t)
	{
	if (ip) ip->LockAxisTripods(FALSE);
	UpdateSelectDisplay();

	if ( !ip ) return;	
	ModContextList mcList;
	INodeTab nodes;
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;
		patchData->UpdateChanges(patch, FALSE);
		}
	}

void EditPatchMod::TransformCancel(TimeValue t)
	{
	if (ip) ip->LockAxisTripods(FALSE);
	}

void EditPatchMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState * os, INode *node) 
	{		
//Alert(_T("in ModifyObject"));
	assert( os->obj->ClassID() == Class_ID(PATCHOBJ_CLASS_ID,0) );
//Alert(_T("ModifyObject class ID is OK"));
	
	PatchObject *patchOb = (PatchObject *)os->obj;
	EditPatchData *patchData;

	if ( !mc.localData ) {
		mc.localData = new EditPatchData(this);
		patchData = (EditPatchData*)mc.localData;
		meshSteps = patchData->meshSteps = patchOb->GetMeshSteps();
//3-18-99 to suport render steps and removal of the mental tesselator
		meshStepsRender = patchData->meshStepsRender = patchOb->GetMeshStepsRender();
		showInterior = patchData->showInterior = patchOb->GetShowInterior();

//		meshAdaptive = patchData->meshAdaptive = patchOb->GetAdaptive();	// Future use (Not used now)
		viewTess = patchData->viewTess = patchOb->GetViewTess();
		prodTess = patchData->prodTess = patchOb->GetProdTess();
		dispTess = patchData->dispTess = patchOb->GetDispTess();
		mViewTessNormals = patchData->mViewTessNormals = patchOb->GetViewTessNormals();
		mProdTessNormals = patchData->mProdTessNormals = patchOb->GetProdTessNormals();
		mViewTessWeld = patchData->mViewTessWeld = patchOb->GetViewTessWeld();
		mProdTessWeld = patchData->mProdTessWeld = patchOb->GetProdTessWeld();
		displayLattice = patchData->displayLattice = patchOb->ShowLattice();
		displaySurface = patchData->displaySurface = patchOb->showMesh;
	} else {
		patchData = (EditPatchData*)mc.localData;
		}

	PatchMesh &pmesh = patchOb->patch;	
	assert(pmesh.numVerts == pmesh.vertSel.GetSize());
	assert(pmesh.getNumEdges() == pmesh.edgeSel.GetSize());
	assert(pmesh.numPatches == pmesh.patchSel.GetSize());

	patchData->Apply(t,patchOb,selLevel);
	}

void EditPatchMod::NotifyInputChanged(Interval changeInt, PartID partID, RefMessage message, ModContext *mc)
	{
	if ( mc->localData ) {
		EditPatchData *patchData = (EditPatchData*)mc->localData;
		if ( patchData ) {
			// The FALSE parameter indicates the the mesh cache itself is
			// invalid in addition to any other caches that depend on the
			// mesh cache.
			patchData->Invalidate(partID,FALSE);
			}
		}
	}

// Select a subcomponent within our object(s).  WARNING! Because the HitRecord list can
// indicate any of the objects contained within the group of patches being edited, we need
// to watch for control breaks in the patchData pointer within the HitRecord!

void EditPatchMod::SelectSubComponent( HitRecord *hitRec, BOOL selected, BOOL all, BOOL invert )
	{
	// Don't do anything if at vertex level with verts turned off
	if(selLevel == EP_VERTEX && !filterVerts)
		return;

	if ( !ip ) return; 
	TimeValue t = ip->GetTime();

	ip->ClearCurNamedSelSet();

	// Keep processing hit records as long as we have them!
	while(hitRec) {	
		EditPatchData *patchData = (EditPatchData*)hitRec->modContext->localData;
	
		if ( !patchData )
			return;

		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			return;

		patchData->BeginEdit(t);
		if ( theHold.Holding() ) 
			theHold.Put(new PatchRestore(patchData,this,patch,"SelectSubComponent"));

		switch ( selLevel ) {
			case EP_VERTEX: {
				if ( all ) {				
					if ( invert ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto vert_done;
							int index = ((PatchHitData *)(hitRec->hitData))->index;
							if(((PatchHitData *)(hitRec->hitData))->type == PATCH_HIT_VERTEX) {
								if(patch->vertSel[index])
									patch->vertSel.Clear(index);
								else
									patch->vertSel.Set(index);
								}
							hitRec = hitRec->Next();
							}
						}
					else
					if ( selected ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto vert_done;
							PatchHitData *hit = (PatchHitData *)(hitRec->hitData);
							if(hit->type == PATCH_HIT_VERTEX)
								patch->vertSel.Set(hit->index);
							hitRec = hitRec->Next();
							}
						}
					else {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto vert_done;
							PatchHitData *hit = (PatchHitData *)(hitRec->hitData);
							if(hit->type == PATCH_HIT_VERTEX)
								patch->vertSel.Clear(hit->index);
							hitRec = hitRec->Next();
							}
						}
					}
				else {
					int index = ((PatchHitData *)(hitRec->hitData))->index;
					if(((PatchHitData *)(hitRec->hitData))->type == PATCH_HIT_VERTEX) {
						if( invert ) {
							if(patch->vertSel[index])
								patch->vertSel.Clear(index);
							else
								patch->vertSel.Set(index);
							}
						else
						if ( selected )
							patch->vertSel.Set(index);
						else
							patch->vertSel.Clear(index);
						}
					hitRec = NULL;	// Reset it so we can exit	
					}
				vert_done:
				break;
				}
			case EP_EDGE: {
				if ( all ) {				
					if ( invert ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto edge_done;
							int index = ((PatchHitData *)(hitRec->hitData))->index;
							if(patch->edgeSel[index])
								patch->edgeSel.Clear(index);
							else
								patch->edgeSel.Set(index);
							hitRec = hitRec->Next();
							}
						}
					else
					if ( selected ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto edge_done;
							patch->edgeSel.Set(((PatchHitData *)(hitRec->hitData))->index);
							hitRec = hitRec->Next();
							}
						}
					else {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto edge_done;
							patch->edgeSel.Clear(((PatchHitData *)(hitRec->hitData))->index);
							hitRec = hitRec->Next();
							}
						}
					}
				else {
					int index = ((PatchHitData *)(hitRec->hitData))->index;
					if( invert ) {
						if(patch->edgeSel[index])
							patch->edgeSel.Clear(index);
						else
							patch->edgeSel.Set(index);
						}
					else
					if ( selected ) {
						patch->edgeSel.Set(index);
						}
					else {
						patch->edgeSel.Clear(index);
						}
					hitRec = NULL;	// Reset it so we can exit	
					}
				edge_done:
				break;
				}
			case EP_PATCH: {
				if ( all ) {				
					if ( invert ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto patch_done;
							int index = ((PatchHitData *)(hitRec->hitData))->index;
							if(patch->patchSel[index])
								patch->patchSel.Clear(index);
							else
								patch->patchSel.Set(index);
							hitRec = hitRec->Next();
							}
						}
					else
					if ( selected ) {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto patch_done;
							patch->patchSel.Set(((PatchHitData *)(hitRec->hitData))->index);
							hitRec = hitRec->Next();
							}
						}
					else {
						while( hitRec ) {
							// If the object changes, we're done!
							if(patchData != (EditPatchData*)hitRec->modContext->localData)
								goto patch_done;
							patch->patchSel.Clear(((PatchHitData *)(hitRec->hitData))->index);
							hitRec = hitRec->Next();
							}
						}
					}
				else {
					int index = ((PatchHitData *)(hitRec->hitData))->index;
					if( invert ) {
						if(patch->patchSel[index])
							patch->patchSel.Clear(index);
						else
							patch->patchSel.Set(index);
						}
					else
					if ( selected ) {
						patch->patchSel.Set(index);
						}
					else {
						patch->patchSel.Clear(index);
						}
					hitRec = NULL;	// Reset it so we can exit	
					}
				patch_done:
				break;
				}
			case EP_OBJECT:
			default:
				return;
			}
		patchData->UpdateChanges(patch, FALSE);
		if ( patchData->tempData ) {
			patchData->tempData->Invalidate(PART_SELECT);
			}
		PatchSelChanged();
		}

	UpdateSelectDisplay();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void EditPatchMod::ClearSelection(int selLevel) 
	{
	// Don't do anything if at vertex level with verts turned off
	if(selLevel == EP_VERTEX && !filterVerts)
		return;
	if(selLevel == EP_OBJECT)
		return;

	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	ip->ClearCurNamedSelSet();
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patchData->BeginEdit(ip->GetTime());
		if ( theHold.Holding() ) {
			theHold.Put(new PatchRestore(patchData,this,patch,"ClearSelection"));
			}

		switch ( selLevel ) {
			case EP_VERTEX: {
				patch->vertSel.ClearAll();
				break;
				}
			case EP_EDGE: {
				patch->edgeSel.ClearAll();
				break;
				}
			case EP_PATCH: {
				patch->patchSel.ClearAll();
				break;
				}
			}
		patchData->UpdateChanges(patch, FALSE);
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_SELECT);
			}
		PatchSelChanged();
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}


void UnselectHiddenPatches(int level, PatchMesh *patch)
{
switch ( level ) {
	case EP_VERTEX: 
		{
		for (int i = 0; i < patch->numVerts; i++)
			{
			if (patch->getVert(i).IsHidden())
				patch->vertSel.Set(i,FALSE);
			}
		break;
		}
	case EP_EDGE: 
		{
		for (int i = 0; i < patch->numEdges; i++)
			{
			int a,b;
			a = patch->edges[i].v1;
			b = patch->edges[i].v2;
			if (patch->getVert(a).IsHidden() && patch->getVert(b).IsHidden())
				patch->edgeSel.Set(i,FALSE);
			}
		break;
		}
	case EP_PATCH: 
		{
		for (int i = 0; i < patch->numPatches; i++)
			{
			if (patch->patches[i].IsHidden())
				patch->patchSel.Set(i,FALSE);
			}
		break;
		}

	}


}

void EditPatchMod::SelectAll(int selLevel) 
	{
	// Don't do anything if at vertex level with verts turned off
	if(selLevel == EP_VERTEX && !filterVerts)
		return;
	if(selLevel == EP_OBJECT)
		return;

	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);
	ip->ClearCurNamedSelSet();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patchData->BeginEdit(ip->GetTime());
		if ( theHold.Holding() ) {
			theHold.Put(new PatchRestore(patchData,this,patch,"SelectAll"));
			}

		switch ( selLevel ) {
			case EP_VERTEX: {
				patch->vertSel.SetAll();
				break;
				}
			case EP_EDGE: {
				patch->edgeSel.SetAll();
				break;
				}
			case EP_PATCH: {
				patch->patchSel.SetAll();
				break;
				}
			}
		UnselectHiddenPatches(selLevel, patch);
		patchData->UpdateChanges(patch, FALSE);
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_SELECT);
			}
		PatchSelChanged();
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void EditPatchMod::InvertSelection(int selLevel) 
	{
	// Don't do anything if at vertex level with verts turned off
	if(selLevel == EP_VERTEX && !filterVerts)
		return;
	if(selLevel == EP_OBJECT)
		return;

	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);
	ip->ClearCurNamedSelSet();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patchData->BeginEdit(ip->GetTime());
		if ( theHold.Holding() )
			theHold.Put(new PatchRestore(patchData,this,patch,"InvertSelection"));

		switch ( selLevel ) {
			case EP_VERTEX: {
				patch->vertSel = ~patch->vertSel;
				break;
				}
			case EP_EDGE: {
				patch->edgeSel = ~patch->edgeSel;
				break;
				}
			case EP_PATCH: {
				patch->patchSel = ~patch->patchSel;
				break;
				}
			}
		UnselectHiddenPatches(selLevel, patch);
		patchData->UpdateChanges(patch, FALSE);
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_SELECT);
			}
		PatchSelChanged();
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	}

void EditPatchMod::SetDisplaySurface(BOOL sw) {
	sw = TRUE;
	displaySurface = sw;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		patchData->displaySurface = sw;

		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetDisplayLattice(BOOL sw) {
	displayLattice = sw;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		patchData->displayLattice = sw;

		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;
		if(sw)
			patch->SetDispFlag(DISP_LATTICE);
		else
			patch->ClearDispFlag(DISP_LATTICE);
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetPropagate(BOOL sw) {
	propagate = sw;
	}

void EditPatchMod::SetMeshSteps(int steps) {
	meshSteps = steps;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetMeshSteps(steps);
		patchData->meshSteps = steps;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

//3-18-99 to suport render steps and removal of the mental tesselator
void EditPatchMod::SetMeshStepsRender(int steps) {
	meshStepsRender = steps;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetMeshStepsRender(steps);
		patchData->meshStepsRender = steps;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetShowInterior(BOOL si) {
	showInterior = si;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetShowInterior(si);
		patchData->showInterior = si;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}


/*
// Future use (Not used now)
void EditPatchMod::SetMeshAdaptive(BOOL sw) {
	meshAdaptive = sw;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		patch->SetAdaptive(sw);
		patchData->meshAdaptive = sw;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}
*/



void EditPatchMod::SetViewTess(TessApprox &tess) {
	viewTess = tess;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetViewTess(tess);
		patchData->viewTess = tess;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetProdTess(TessApprox &tess) {
	prodTess = tess;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetProdTess(tess);
		patchData->prodTess = tess;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetDispTess(TessApprox &tess) {
	dispTess = tess;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetDispTess(tess);
		patchData->dispTess = tess;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetViewTessNormals(BOOL use) {
	mViewTessNormals = use;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetViewTessNormals(use);
		patchData->mViewTessNormals = use;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetProdTessNormals(BOOL use) {
	mProdTessNormals = use;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetProdTessNormals(use);
		patchData->mProdTessNormals = use;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetViewTessWeld(BOOL weld) {
	mViewTessWeld = weld;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetViewTessWeld(weld);
		patchData->mViewTessWeld = weld;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::SetProdTessWeld(BOOL weld) {
	mProdTessWeld = weld;
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;	
	
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;

		patch->SetProdTessWeld(weld);
		patchData->mProdTessWeld = weld;
		if ( patchData->tempData ) {
			patchData->TempData(this)->Invalidate(PART_DISPLAY);
			}
		}
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}


void EditPatchMod::ActivateSubobjSel(int level, XFormModes& modes )
	{	
	ModContextList mcList;
	INodeTab nodes;
	int old = selLevel;

	if ( !ip ) return;
	ip->GetModContexts(mcList,nodes);

	selLevel = level;
//3-10-99 watje
	if (level != EP_PATCH)
		{
		if (ip->GetCommandMode()==bevelMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		if (ip->GetCommandMode()==extrudeMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		if (inBevel)
			{
			ISpinnerControl *spin;
			spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_EP_OUTLINESPINNER));
			if (spin) {
				HWND hWnd = spin->GetHwnd();
				SendMessage(hWnd,WM_LBUTTONUP,0,0);
				ReleaseISpinner(spin);
				}

			}
		if (inExtrude)
			{
			ISpinnerControl *spin;
			spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_EP_EXTRUDESPINNER));
			if (spin) {
				HWND hWnd = spin->GetHwnd();
				SendMessage(hWnd,WM_LBUTTONUP,0,0);
				ReleaseISpinner(spin);
				}
			}
		}	
	if (level != EP_VERTEX)
		{
		if (ip->GetCommandMode()==bindMode)
			ip->SetStdCommandMode(CID_OBJMOVE);
		}


	switch ( level ) {
		case EP_OBJECT:
			// Not imp.
			break;

		case EP_PATCH:
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
			break;

		case EP_EDGE:
			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
			break;

		case EP_VERTEX:

			modes = XFormModes(moveMode,rotMode,nuscaleMode,uscaleMode,squashMode,selectMode);
			break;
		}

	if ( selLevel != old ) {
		SetSubobjectLevel(level);

		// Modify the caches to reflect the new sel level.
		for ( int i = 0; i < mcList.Count(); i++ ) {
			EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
			if ( !patchData ) continue;		
		
			if ( patchData->tempData && patchData->TempData(this)->PatchCached(ip->GetTime()) ) {
				
				PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
				if(patch) {
					if(selLevel == EP_VERTEX)
						patch->dispFlags = DISP_VERTS;
					else
						patch->dispFlags = 0;
					if(displayLattice)
						patch->SetDispFlag(DISP_LATTICE);
					patch->SetDispFlag(patchLevelDispFlags[selLevel]);
					patch->selLevel = patchLevel[selLevel];
					}
				}
			}		

		NotifyDependents(FOREVER, PART_SUBSEL_TYPE|PART_DISPLAY,REFMSG_CHANGE);
		ip->PipeSelLevelChanged();
		// Update selection UI display, named sel
		SelectionChanged();
		}
	
	nodes.DisposeTemporary();
	}


int EditPatchMod::SubObjectIndex(HitRecord *hitRec)
	{	
	EditPatchData *patchData = (EditPatchData*)hitRec->modContext->localData;
	if ( !patchData ) return 0;
	if ( !ip ) return 0;
	TimeValue t = ip->GetTime();
	PatchHitData *hit = (PatchHitData *)(hitRec->hitData);
	switch ( selLevel ) {
		case EP_VERTEX: {
			if(hit->type != PATCH_HIT_VERTEX)
				return 0;
			int hitIndex = hit->index;
			return hitIndex;
			}
		case EP_EDGE: {
			int hitIndex = hit->index;
			return hitIndex;
			}
		case EP_PATCH: {
			int hitIndex = hit->index;
			return hitIndex;
			}
		default:
			return 0;
		}
	}

void EditPatchMod::GetSubObjectTMs(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Interval valid;
	if ( mc->localData ) {
		EditPatchData *patchData = (EditPatchData*)mc->localData;
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		// Watch out -- The system can call us even if we didn't get a valid patch object
		if(!patch)
			return;

		switch ( selLevel ) {
			case EP_VERTEX: {
				Matrix3 otm = node->GetObjectTM(t,&valid);
				Matrix3 tm = node->GetNodeTM(t,&valid);
				BitArray sel = patch->VertexTempSel();
				int count = sel.GetSize();
				for(int i = 0; i < count; ++i) {
					if(sel[i]) {
						tm.SetTrans(patch->verts[i].p * otm);
						cb->TM(tm, i);
						}
					}
				break;
				}
			case EP_EDGE:
			case EP_PATCH: {
 				Matrix3 otm = node->GetObjectTM(t,&valid);
				Matrix3 tm = node->GetNodeTM(t,&valid);
				Box3 box;
				BitArray sel = patch->VertexTempSel();
				int count = sel.GetSize();
				for ( int i = 0; i < count; i++ ) {
					if ( sel[i] )
						box += patch->verts[i].p;
					}
				tm.SetTrans(otm * box.Center());
				cb->TM(tm, 0);
				break;
				}
			}
		}
	}

void EditPatchMod::GetSubObjectCenters(
		SubObjAxisCallback *cb,TimeValue t,INode *node,ModContext *mc)
	{
	Interval valid;
	Matrix3 tm = node->GetObjectTM(t,&valid);	
	
	assert(ip);
	if ( mc->localData ) {	
		EditPatchData *patchData = (EditPatchData*)mc->localData;		
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		// Watch out -- The system can call us even if we didn't get a valid patch object
		if(!patch)
			return;

		switch ( selLevel ) {
			case EP_VERTEX: {
				Box3 box;
				BitArray sel = patch->VertexTempSel();
				int verts = patch->numVerts;
				for ( int i = 0; i < verts; i++ ) {
					if ( sel[i] )
						cb->Center(patch->verts[i].p * tm, i);
					}
				break;
				}
			case EP_EDGE:
			case EP_PATCH: {
				Box3 box;
				BOOL bHasSel = FALSE;
				BitArray sel = patch->VertexTempSel();
				int verts = patch->numVerts;
				for ( int i = 0; i < verts; i++ ) {
					if ( sel[i] ) {
						box += patch->verts[i].p * tm;
						bHasSel = TRUE;
						}
					}
				if (bHasSel)
					cb->Center(box.Center(), 0);
				break;
				}
			default:
				cb->Center(tm.GetTrans(), 0);
				break;
			}		
		}
	}

BOOL EditPatchMod::DependOnTopology(ModContext &mc)
	{
	EditPatchData *patchData = (EditPatchData*)mc.localData;
	if (patchData) {
		if (patchData->GetFlag(EPD_HASDATA)) {
			return TRUE;
			}
		}
	return FALSE;
	}

void EditPatchMod::DeletePatchDataTempData()
	{
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;		
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;				
		if ( patchData->tempData ) {
			delete patchData->tempData;
			}
		patchData->tempData = NULL;
		}
	nodes.DisposeTemporary();
	}


void EditPatchMod::CreatePatchDataTempData()
	{
	ModContextList mcList;
	INodeTab nodes;

	if ( !ip ) return;		
	ip->GetModContexts(mcList,nodes);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;				
		if ( !patchData->tempData ) {
			patchData->tempData = new EPTempData(this,patchData);
			}		
		}
	nodes.DisposeTemporary();
	}

//--------------------------------------------------------------

int EditPatchMod::RememberPatchThere(HWND hWnd, IPoint2 m) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	// Initialize so there isn't any remembered patch
	rememberedPatch = NULL;

	if ( !ip ) return 0;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	// See if we're over a patch
	ViewExp *vpt = ip->GetViewport(hWnd);
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr, HITTYPE_POINT, 1, 4, &m);
	gw->setHitRegion(&hr);
	SubPatchHitList hitList;

	int result = 0;

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		INode *inode = nodes[i];
		Matrix3 mat = inode->GetObjectTM(t);
		gw->setTransform(mat);	
		patch->SubObjectHitTest(gw, gw->getMaterial(), &hr, SUBHIT_PATCH_PATCHES/* | HIT_ABORTONHIT*/, hitList );
		PatchSubHitRec *hit = hitList.First();
		if(hit) {
			result = 1;
			// Go thru the list and see if we have one that's selected
			// If more than one selected and they're different types, set unknown type
			hit = hitList.First();
			while(hit) {
				if(patch->patchSel[hit->index]) {
					if(patch->SelPatchesSameType()) {
						rememberedPatch = NULL;
						rememberedData = patch->patches[hit->index].flags & (~PATCH_INTERIOR_MASK);
						goto finish;
						}
					// Selected patches not all the same type!
					rememberedPatch = NULL;
					rememberedData = -1;	// Not all the same!
					goto finish;
					}
				hit = hit->Next();
				}
			if(ip->SelectionFrozen())
				goto finish;
			// Select just this patch
			hit = hitList.First();
			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new PatchSelRestore(patchData,this,patch));
			patch->patchSel.ClearAll();
			patch->patchSel.Set(hit->index);
			patchData->UpdateChanges(patch, FALSE);
			theHold.Accept(GetString(IDS_DS_SELECT));
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
			PatchSelChanged();

			rememberedPatch = patch;
			rememberedIndex = hit->index;
			rememberedData = patch->patches[rememberedIndex].flags & (~PATCH_INTERIOR_MASK);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
finish:
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	if ( vpt ) ip->ReleaseViewport(vpt);
	return result;
	}

void EditPatchMod::ChangeRememberedPatch(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		if(patch == rememberedPatch) {
			// If this is the first edit, then the delta arrays will be allocated
			patchData->BeginEdit(t);

			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"ChangeRememberedPatch"));
			// Call the patch type change function
			ChangePatchType(patch, rememberedIndex, type);
			patchData->UpdateChanges(patch, FALSE);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
			ClearPatchDataFlag(mcList,EPD_BEENDONE);
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
			nodes.DisposeTemporary();
			return;
 			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	}

void EditPatchMod::ChangeSelPatches(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->patchSel.NumberSet()) {
			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"ChangeSelPatches"));
			// Call the vertex type change function
			ChangePatchType(patch, -1, type);
			patchData->UpdateChanges(patch, FALSE);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}


void EditPatchMod::SetRememberedPatchType(int type) {
	if(rememberedPatch)
		ChangeRememberedPatch(type);
	else
		ChangeSelPatches(type);
	}

//--------------------------------------------------------------

int EditPatchMod::RememberVertThere(HWND hWnd, IPoint2 m) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	// Initialize so there isn't any remembered patch
	rememberedPatch = NULL;

	if ( !ip ) return 0;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	// See if we're over a vertex
	ViewExp *vpt = ip->GetViewport(hWnd);
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr, HITTYPE_POINT, 1, 4, &m);
	gw->setHitRegion(&hr);
	SubPatchHitList hitList;

	int result = 0;
	
	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		INode *inode = nodes[i];
		Matrix3 mat = inode->GetObjectTM(t);
		gw->setTransform(mat);	
		patch->SubObjectHitTest(gw, gw->getMaterial(), &hr, SUBHIT_PATCH_VERTS/* | HIT_ABORTONHIT*/, hitList );
		PatchSubHitRec *hit = hitList.First();
		if(hit) {
			result = 1;
			// Go thru the list and see if we have one that's selected
			// If more than one selected and they're different types, set unknown type
			hit = hitList.First();
			while(hit) {
				if(patch->vertSel[hit->index]) {
					if(patch->SelVertsSameType()) {
						rememberedPatch = NULL;
						rememberedData = patch->verts[hit->index].flags & (~PVERT_TYPE_MASK);
						goto finish;
						}
					// Selected verts not all the same type!
					rememberedPatch = NULL;
					rememberedData = -1;	// Not all the same!
					goto finish;
					}
				hit = hit->Next();
				}
			if(ip->SelectionFrozen())
				goto finish;
			// Select just this vertex
			hit = hitList.First();
			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new PatchSelRestore(patchData,this,patch));
			patch->vertSel.ClearAll();
			patch->vertSel.Set(hit->index);
			patchData->UpdateChanges(patch, FALSE);
			theHold.Accept(GetString(IDS_DS_SELECT));
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
			PatchSelChanged();

			rememberedPatch = patch;
			rememberedIndex = hit->index;
			rememberedData = patch->verts[rememberedIndex].flags & (~PVERT_TYPE_MASK);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
finish:
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	if ( vpt ) ip->ReleaseViewport(vpt);
	return result;
	}

void EditPatchMod::ChangeRememberedVert(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		if(patch == rememberedPatch) {
			// If this is the first edit, then the delta arrays will be allocated
			patchData->BeginEdit(t);

			theHold.Begin();
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"ChangeRememberedVert"));
			// Call the vertex type change function
			patch->ChangeVertType(rememberedIndex, type);
			patchData->UpdateChanges(patch, FALSE);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			theHold.Accept(GetString(IDS_TH_VERTCHANGE));
			ClearPatchDataFlag(mcList,EPD_BEENDONE);
			NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
			ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
			nodes.DisposeTemporary();
			return;
 			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	}

void EditPatchMod::ChangeSelVerts(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
					
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->vertSel.NumberSet()) {
			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"ChangeSelVerts"));
			// Call the vertex type change function
			patch->ChangeVertType(-1, type);
			patchData->UpdateChanges(patch, FALSE);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_VERTCHANGE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVERTSSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}


void EditPatchMod::SetRememberedVertType(int type) {
	if(rememberedPatch)
		ChangeRememberedVert(type);
	else
		ChangeSelVerts(type);
	}

//--------------------------------------------------------------
int EditPatchMod::HitTest(TimeValue t, INode* inode, int type, int crossing, 
		int flags, IPoint2 *p, ViewExp *vpt, ModContext* mc) 
	{
	Interval valid;
	int savedLimits,res = 0;
	GraphicsWindow *gw = vpt->getGW();
	HitRegion hr;
	MakeHitRegion(hr,type, crossing,4,p);
	gw->setHitRegion(&hr);
	Matrix3 mat = inode->GetObjectTM(t);
	gw->setTransform(mat);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	gw->clearHitCode();
	
	if ( mc->localData ) {		
		EditPatchData *patchData = (EditPatchData*)mc->localData;
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			return FALSE;

		SubPatchHitList hitList;
		PatchSubHitRec *rec;
		res = patch->SubObjectHitTest( gw, gw->getMaterial(), &hr,
			flags|((patchHitOverride) ? patchHitLevel[patchHitOverride] : patchHitLevel[selLevel]), hitList );
	
		rec = hitList.First();
		while( rec ) {
			vpt->LogHit(inode,mc,rec->dist,123456,new PatchHitData(rec->patch, rec->index, rec->type));
			rec = rec->Next();
			}
		}

	gw->setRndLimits(savedLimits);	
	return res;
	}

int EditPatchMod::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags, ModContext *mc) {	
	return 0;	
	}

void EditPatchMod::GetWorldBoundBox(TimeValue t,INode* inode, ViewExp *vpt, Box3& box, ModContext *mc) {
	box.Init();
	}



//---------------------------------------------------------------------
// UI stuff

void EditPatchMod::RecordTopologyTags() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;
		
		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patch->RecordTopologyTags();
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	}

class ChangeNamedSetRestore : public RestoreObj {
	public:
		BitArray oldset,newset;
		int index;
		GenericNamedSelSetList *setList;

		ChangeNamedSetRestore(GenericNamedSelSetList *sl,int ix,BitArray *o) {
			setList = sl; index = ix; oldset = *o;
			}   		
		void Restore(int isUndo) {
			newset = *(setList->sets[index]);
			*(setList->sets[index]) = oldset;
			}
		void Redo() {
			*(setList->sets[index]) = newset;
			}
				
		TSTR Description() {return TSTR(_T("Change Named Sel Set"));}
	};

// Selection set, misc fixup utility function
// This depends on PatchMesh::RecordTopologyTags being called prior to the topo changes
void EditPatchMod::ResolveTopoChanges() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	for ( int i = 0; i < mcList.Count(); i++ ) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;
		
		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		// First, the vertex selections
		for(int set = 0; set < patchData->vselSet.Count(); ++set) {
			BitArray *oldVS = &patchData->vselSet[set];
			BitArray newVS;
			newVS.SetSize(patch->numVerts);
			for(int vert = 0; vert < patch->numVerts; ++vert) {
				// Get the knot's previous location, then copy that selection into the new set
				int tag = patch->verts[vert].aux1;
				if(tag >= 0)
					newVS.Set(vert, (*oldVS)[tag]);
				else
					newVS.Clear(vert);
				}
			if(theHold.Holding())
				theHold.Put(new ChangeNamedSetRestore(&patchData->vselSet, set, oldVS));
			patchData->vselSet[set] = newVS;
			}
		// Now the edge selections
		for(set = 0; set < patchData->eselSet.Count(); ++set) {
			BitArray *oldES = &patchData->eselSet[set];
			BitArray newES;
			newES.SetSize(patch->numEdges);
			for(int edge = 0; edge < patch->numEdges; ++edge) {
				// Get the knot's previous location, then copy that selection into the new set
				int tag = patch->edges[edge].aux1;
				if(tag >= 0)
					newES.Set(edge, (*oldES)[tag]);
				else
					newES.Clear(edge);
				}
			if(theHold.Holding())
				theHold.Put(new ChangeNamedSetRestore(&patchData->eselSet, set, oldES));
			patchData->eselSet[set] = newES;
			}
		// Now the patch selections
		for(set = 0; set < patchData->pselSet.Count(); ++set) {
			BitArray *oldPS = &patchData->pselSet[set];
			BitArray newPS;
			newPS.SetSize(patch->numPatches);
			for(int p = 0; p < patch->numPatches; ++p) {
				// Get the knot's previous location, then copy that selection into the new set
				int tag = patch->patches[p].aux1;
				if(tag >= 0)
					newPS.Set(p, (*oldPS)[tag]);
				else
					newPS.Clear(p);
				}
			if(theHold.Holding())
				theHold.Put(new ChangeNamedSetRestore(&patchData->pselSet, set, oldPS));
			patchData->pselSet[set] = newPS;
			}

//watje 4-16-99
		patch->HookFixTopology();
//watje 8-23-99 fiexs collapse crash
		patchData->finalPatch.hooks = patch->hooks;

		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	}

class EPModContextEnumProc : public ModContextEnumProc {
	float f;
	public:
		EPModContextEnumProc(float f) { this->f = f; }
		BOOL proc(ModContext *mc);  // Return FALSE to stop, TRUE to continue.
	};

BOOL EPModContextEnumProc::proc(ModContext *mc) {
	EditPatchData *patchData = (EditPatchData*)mc->localData;
	if ( patchData )		
		patchData->RescaleWorldUnits(f);
	return TRUE;
	}

// World scaling
void EditPatchMod::RescaleWorldUnits(float f) {
	if (TestAFlag(A_WORK1))
		return;
	SetAFlag(A_WORK1);
	
	// rescale all our references
	for (int i=0; i<NumRefs(); i++) {
		ReferenceMaker *srm = GetReference(i);
		if (srm) 
			srm->RescaleWorldUnits(f);
		}
	
	// Now rescale stuff inside our data structures
	EPModContextEnumProc proc(f);
	EnumModContexts(&proc);
	NotifyDependents(FOREVER, PART_GEOM, REFMSG_CHANGE);
	}

int EditPatchMod::GetSubobjectLevel()
	{
	return selLevel;
	}

void EditPatchMod::SetSubobjectLevel(int level)
	{
	selLevel = level;
	if(hSelectPanel)
		RefreshSelType();
	// Setup named selection sets	
	SetupNamedSelDropDown();
	}

static int butIDs[] = { 0, EP_VERTEX, EP_EDGE, EP_PATCH };

void EditPatchMod::RefreshSelType () {
	if(!hSelectPanel)
		return;
	if(hOpsPanel) {
		// Set up or remove the surface properties rollup if needed
		if(hSurfPanel) {
			rsSurf = IsRollupPanelOpen (hSurfPanel);
			ip->DeleteRollupPage(hSurfPanel);
			hSurfPanel = NULL;
			}
/* watje 3-18-99
		if(selLevel == EP_OBJECT) {
			hSurfPanel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDPATCH_SURF_OBJ),
				PatchObjSurfDlgProc, GetString (IDS_TH_SURFACEPROPERTIES), (LPARAM) this, rsSurf ? 0 : APPENDROLL_CLOSED);
			}
		else
*/
		if(selLevel == EP_PATCH) {
			hSurfPanel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDPATCH_SURF),
				PatchSurfDlgProc, GetString (IDS_TH_SURFACEPROPERTIES), (LPARAM) this, rsSurf ? 0 : APPENDROLL_CLOSED);
			}
		SetSurfDlgEnables();
		}

	ICustToolbar *iToolbar = GetICustToolbar(GetDlgItem(hSelectPanel,IDC_SELTYPE));
	ICustButton *but;
	for (int i=1; i<4; i++) {
		but = iToolbar->GetICustButton (butIDs[i]);
		but->SetCheck (GetSubobjectLevel()==i);
		ReleaseICustButton (but);
	}
	ReleaseICustToolbar(iToolbar);
	SetSelDlgEnables();
	SetOpsDlgEnables();
	UpdateSelectDisplay();
}

void EditPatchMod::SelectionChanged() {
	if (hSelectPanel) {
		UpdateSelectDisplay();
		InvalidateRect(hSelectPanel,NULL,FALSE);
		}
	// Now see if the selection set matches one of the named selections!
	if(ip && (selLevel != EP_OBJECT)) {
		ModContextList mcList;		
		INodeTab nodes;
		TimeValue t = ip->GetTime();
		ip->GetModContexts(mcList,nodes);
		int sublevel = selLevel - 1;
		int dataSet;
		for(int set = 0; set < namedSel[sublevel].Count(); ++set) {
			ClearPatchDataFlag(mcList,EPD_BEENDONE);
			BOOL gotMatch = FALSE;
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
				if ( !patchData ) continue;
				if ( patchData->GetFlag(EPD_BEENDONE) ) continue;
				PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
				if(!patch) continue;
				// See if this patch has the named selection set
				switch(selLevel) {
					case EP_VERTEX: 
						for(dataSet = 0; dataSet < patchData->vselSet.Count(); ++dataSet) {
							if(*(patchData->vselSet.names[dataSet]) == *namedSel[sublevel][set]) {
								if(!(*patchData->vselSet.sets[set] == patch->vertSel))
									goto next_set;
								gotMatch = TRUE;
								break;
								}
							}
						break;
					case EP_EDGE:
						for(dataSet = 0; dataSet < patchData->eselSet.Count(); ++dataSet) {
							if(*(patchData->eselSet.names[dataSet]) == *namedSel[sublevel][set]) {
								if(!(*patchData->eselSet.sets[set] == patch->edgeSel))
									goto next_set;
								gotMatch = TRUE;
								break;
								}
							}
						break;
					case EP_PATCH:
						for(dataSet = 0; dataSet < patchData->pselSet.Count(); ++dataSet) {
							if(*(patchData->pselSet.names[dataSet]) == *namedSel[sublevel][set]) {
								if(!(*patchData->pselSet.sets[set] == patch->patchSel))
									goto next_set;
								gotMatch = TRUE;
								break;
								}
							}
						break;
					}
				patchData->SetFlag(EPD_BEENDONE,TRUE);
				}
			// If we reach here, we might have a set that matches
			if(gotMatch) {
				ip->SetCurNamedSelSet(*namedSel[sublevel][set]);
				goto namedSelUpdated;
				}
next_set:;
			}
		// No set matches, clear the named selection
		ip->ClearCurNamedSelSet();
				

namedSelUpdated:
		nodes.DisposeTemporary();
		ClearPatchDataFlag(mcList,EPD_BEENDONE);
		}
	}

void EditPatchMod::InvalidateSurfaceUI() {
	if(hSurfPanel && selLevel == EP_PATCH) {
		InvalidateRect (hSurfPanel, NULL, FALSE);
		patchUIValid = FALSE;
		}
	}

BitArray *EditPatchMod::GetLevelSelectionSet(PatchMesh *patch) {
	switch(selLevel) {
		case EP_VERTEX:
			return &patch->vertSel;

		case EP_PATCH:
			return &patch->patchSel;

		case EP_EDGE:
			return &patch->edgeSel;
		}
	assert(0);
	return NULL;
	}

void EditPatchMod::UpdateSelectDisplay() {	
	TSTR buf;
	int num, j;

	if (!hSelectPanel) return;

	ModContextList mcList;
	INodeTab nodes;
	if ( !ip )
		return;
	ip->GetModContexts(mcList,nodes);

	switch (GetSubobjectLevel()) {
		case EP_OBJECT:
			buf.printf (GetString (IDS_TH_OBJECT_SEL));
			break;

		case EP_VERTEX: {
			num = 0;
			PatchMesh *thePatch = NULL;
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
				if ( !patchData ) continue;		
			
				if ( patchData->tempData && patchData->TempData(this)->PatchCached(ip->GetTime()) ) {
					PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
					if(!patch) continue;
					int thisNum = patch->vertSel.NumberSet();
					if(thisNum) {
						num += thisNum;
						thePatch = patch;
						}
					}
				}
			if (num==1) {
				for (j=0; j<thePatch->vertSel.GetSize(); j++)
					if (thePatch->vertSel[j]) break;
				buf.printf (GetString(IDS_TH_NUMVERTSEL), j+1);
				}
			else
				buf.printf (GetString(IDS_TH_NUMVERTSELP), num);
			}
			break;

		case EP_PATCH: {
			num = 0;
			PatchMesh *thePatch = NULL;
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
				if ( !patchData ) continue;		
			
				if ( patchData->tempData && patchData->TempData(this)->PatchCached(ip->GetTime()) ) {
					PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
					if(!patch) continue;
					int thisNum = patch->patchSel.NumberSet();
					if(thisNum) {
						num += thisNum;
						thePatch = patch;
						}
					}
				}
			if (num==1) {
				for (j=0; j<thePatch->patchSel.GetSize(); j++)
					if (thePatch->patchSel[j]) break;
				buf.printf (GetString(IDS_TH_NUMPATCHSEL), j+1);
				}
			else
				buf.printf(GetString(IDS_TH_NUMPATCHSELP),num);
			}
			break;

		case EP_EDGE: {
			num = 0;
			PatchMesh *thePatch = NULL;
			for ( int i = 0; i < mcList.Count(); i++ ) {
				EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
				if ( !patchData ) continue;		
			
				if ( patchData->tempData && patchData->TempData(this)->PatchCached(ip->GetTime()) ) {
					PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
					if(!patch) continue;
					int thisNum = patch->edgeSel.NumberSet();
					if(thisNum) {
						num += thisNum;
						thePatch = patch;
						}
					}
				}
			if (num==1) {
				for (j=0; j<thePatch->edgeSel.GetSize(); j++)
					if (thePatch->edgeSel[j]) break;
				buf.printf (GetString(IDS_TH_NUMEDGESEL), j+1);
				}
			else
				buf.printf(GetString(IDS_TH_NUMEDGESELP),num);
			}
			break;
		}

	nodes.DisposeTemporary();
	SetDlgItemText(hSelectPanel, IDC_NUMSEL_LABEL, buf);
	}

void EditPatchMod::BeginEditParams( IObjParam *ip, ULONG flags, Animatable *prev )
	{
	this->ip = ip;

	patchUIValid = FALSE;
	CreatePatchDataTempData();

	hSelectPanel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDPATCH_SELECT),
		PatchSelectDlgProc, GetString(IDS_TH_SELECTION), (LPARAM)this, rsSel ? 0 : APPENDROLL_CLOSED);
	hOpsPanel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDPATCH_OPS),
		PatchOpsDlgProc, GetString (IDS_TH_GEOMETRY), (LPARAM) this, rsOps ? 0 : APPENDROLL_CLOSED);
/* watje 3-18-99
	if(selLevel == EP_OBJECT) {
		hSurfPanel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDPATCH_SURF_OBJ),
			PatchObjSurfDlgProc, GetString (IDS_TH_SURFACEPROPERTIES), (LPARAM) this, rsSurf ? 0 : APPENDROLL_CLOSED);
		}
	else
*/
	if(selLevel == EP_PATCH) {
		hSurfPanel = ip->AddRollupPage (hInstance, MAKEINTRESOURCE(IDD_EDPATCH_SURF),
			PatchSurfDlgProc, GetString (IDS_TH_SURFACEPROPERTIES), (LPARAM) this, rsSurf ? 0 : APPENDROLL_CLOSED);
		}
	else
		hSurfPanel = NULL;

	// Create sub object editing modes.
	moveMode        = new MoveModBoxCMode(this,ip);
	rotMode         = new RotateModBoxCMode(this,ip);
	uscaleMode      = new UScaleModBoxCMode(this,ip);
	nuscaleMode     = new NUScaleModBoxCMode(this,ip);
	squashMode      = new SquashModBoxCMode(this,ip);
	selectMode      = new SelectModBoxCMode(this,ip);
	extrudeMode    = new EPM_ExtrudeCMode(this,ip);
	bevelMode    = new EPM_BevelCMode(this,ip);
	bindMode    = new EPM_BindCMode(this,ip);


	// Add our sub object type
	TSTR type1( GetString(IDS_TH_VERTEX) );
	TSTR type2( GetString(IDS_TH_EDGE) );
	TSTR type3( GetString(IDS_TH_PATCH) );
	const TCHAR *ptype[] = { type1, type2, type3 };
	ip->RegisterSubObjectTypes( ptype, 3 );

	// Restore the selection level.
	ip->SetSubObjectLevel(selLevel);
	
	// Disable show end result.
	ip->EnableShowEndResult(FALSE);

	// Setup named selection sets	
	SetupNamedSelDropDown();

	// Update selection UI display
	SelectionChanged();

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);	
	}
		
void EditPatchMod::EndEditParams( IObjParam *ip, ULONG flags, Animatable *next )
	{
	if (hSelectPanel) {
		rsSel = IsRollupPanelOpen (hSelectPanel);
		ip->DeleteRollupPage(hSelectPanel);
		hSelectPanel = NULL;
		}
	if (hOpsPanel) {
		rsOps = IsRollupPanelOpen (hOpsPanel);
		ip->DeleteRollupPage(hOpsPanel);
		hOpsPanel = NULL;
		}
	if (hSurfPanel) {
		rsSurf = IsRollupPanelOpen (hSurfPanel);
		ip->DeleteRollupPage(hSurfPanel);
		hSurfPanel = NULL;
		}

	// Enable show end result
	ip->EnableShowEndResult(TRUE);

	CancelEditPatchModes(ip);

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
	ClearAFlag(A_MOD_BEING_EDITED);
	
	DeletePatchDataTempData();
	this->ip = NULL;

//	if ( ip->GetCommandMode()->ID() == CID_EP_EXTRUDE ) ip->SetStdCommandMode( CID_OBJMOVE );
//	if ( ip->GetCommandMode()->ID() == CID_EP_BEVEL ) ip->SetStdCommandMode( CID_OBJMOVE );

	
	ip->DeleteMode(moveMode);
	ip->DeleteMode(rotMode);
	ip->DeleteMode(uscaleMode);
	ip->DeleteMode(nuscaleMode);
	ip->DeleteMode(squashMode);
	ip->DeleteMode(selectMode);
	ip->DeleteMode(extrudeMode);
	ip->DeleteMode(bevelMode);
	ip->DeleteMode(bindMode);

	if ( moveMode ) delete moveMode;
	moveMode = NULL;
	if ( rotMode ) delete rotMode;
	rotMode = NULL;
	if ( uscaleMode ) delete uscaleMode;
	uscaleMode = NULL;
	if ( nuscaleMode ) delete nuscaleMode;
	nuscaleMode = NULL;
	if ( squashMode ) delete squashMode;
	squashMode = NULL;
	if ( selectMode ) delete selectMode;
	selectMode = NULL;

	if( extrudeMode ) delete extrudeMode;
	extrudeMode = NULL;

	if( bevelMode ) delete bevelMode;
	bevelMode = NULL;
	if( bindMode ) delete bindMode;
	bindMode = NULL;
	}

void EditPatchMod::DoDeleteSelected() {
	switch(GetSubobjectLevel()) {
		case EP_VERTEX:
			DoVertDelete();
			break;
		case EP_EDGE:
			DoEdgeDelete();
			break;
		case EP_PATCH:
			DoPatchDelete();
			break;
		}
	}

// Vertex Delete modifier method
void EditPatchMod::DoVertDelete() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patchData->RecordTopologyTags(patch);

		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->vertSel.NumberSet()) {
			altered = holdNeeded = 1;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"DoVertDelete"));
			// Call the vertex delete function
			DeleteSelVerts(patch);
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_VERTDELETE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVERTSSEL),PROMPT_TIME);
		theHold.End();
		}
	
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

// Edger Delete modifier method
void EditPatchMod::DoEdgeDelete() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patchData->RecordTopologyTags(patch);

		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->edgeSel.NumberSet()) {
			altered = holdNeeded = 1;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"DoEdgeDelete"));
			int edges = patch->getNumEdges();
			int patches = patch->getNumPatches();
			int verts = patch->getNumVerts();

			// Tag the patches that are attached to selected edges
			BitArray delPatches(patches);
			delPatches.ClearAll();

			for(int i = 0; i < edges; ++i) {
				if(patch->edgeSel[i]) {
					if(patch->edges[i].patch1 >= 0)
						delPatches.Set(patch->edges[i].patch1);
					if(patch->edges[i].patch2 >= 0)
						delPatches.Set(patch->edges[i].patch2);
					}
				}

			BitArray delVerts(verts);
			delVerts.ClearAll();

			DeletePatchParts(patch, delVerts, delPatches);
			patch->computeInteriors();

			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_EDGEDELETE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOEDGESSEL),PROMPT_TIME);
		theHold.End();
		}
	
	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::DoPatchAdd(int type) {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patchData->RecordTopologyTags(patch);

		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->edgeSel.NumberSet()) {
			altered = holdNeeded = 1;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"DoPatchAdd"));
			// Call the patch add function
			AddPatches(type, patch, TRUE);
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHADD));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDEDGESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::DoPatchDelete() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patchData->RecordTopologyTags(patch);
					
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->patchSel.NumberSet()) {
			altered = holdNeeded = 1;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"DoPatchDelete"));
			// Call the patch delete function
			DeleteSelPatches(patch);
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHDELETE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

//watje 12-10-98
void EditPatchMod::DoUnHide() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
//		if(patch->patchSel.NumberSet()) {
		if(1) {
			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			UnHidePatches(patch);
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::DoHide(int type) {
	switch(type) {
		case EP_VERTEX:
			DoVertHide();
			break;
		case EP_EDGE:
			DoEdgeHide();
			break;
		case EP_PATCH:
			DoPatchHide();
			break;
		}
	}

void EditPatchMod::DoPatchHide() 
	{
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->patchSel.NumberSet()) {
			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			HidePatches(patch);
			patch->patchSel.ClearAll();
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

	}

void EditPatchMod::DoVertHide() 
	{
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->vertSel.NumberSet()) {
			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			HideVerts(patch);
			patch->vertSel.ClearAll();
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

	}

void EditPatchMod::DoEdgeHide() 
	{
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->edgeSel.NumberSet()) {
			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			HideEdges(patch);
			patch->edgeSel.ClearAll();
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

	}


void EditPatchMod::DoAddHook(PatchMesh *pMesh, int vert, int seg) {


	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);


	if (mcList.Count() != 1) return;

	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
//	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if ((!patch) || (patch != pMesh))
			continue;		
//		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
//		if(patch->vertSel.NumberSet()) {

		altered = holdNeeded = TRUE;
		if ( theHold.Holding() )
			theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
		patch->AddHook(vert,seg);
//		patch->UpdateHooks();
//			InvalidateMesh();

		patchData->UpdateChanges(patch);
		patchData->TempData(this)->Invalidate(PART_TOPO);
//			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
//		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

/*	// If any bits are set in the selection set, let's DO IT!!
	if ( !ip ) return;
	theHold.Begin();
	POPatchGenRecord *rec = new POPatchGenRecord(this);
	if ( theHold.Holding() )
		theHold.Put(new PatchObjectRestore(this,rec));
		// Call the patch type change function

	patch.AddHook();
	patch.InvalidateGeomCache();
	InvalidateMesh();
	theHold.Accept(GetResString(IDS_TH_PATCHCHANGE));

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
*/
	}

void EditPatchMod::DoRemoveHook() 
{

	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->vertSel.NumberSet()) {

			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			patch->RemoveHook();
//			patch->InvalidateGeomCache();
//			InvalidateMesh();
 


			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);

//watje 10-14-99 bug 212886 some spurious topo flags need to be cleared
			patch->hookTopoMarkers.ZeroCount();
			patch->hookTopoMarkersA.ZeroCount();
			patch->hookTopoMarkersB.ZeroCount();

			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}


void EditPatchMod::DoExtrude()
{


	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->patchSel.NumberSet()) {

			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			patch->CreateExtrusion();
//			patch->InvalidateGeomCache();
//			InvalidateMesh();

			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}


	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

/*
	theHold.Begin();
	patch.RecordTopologyTags();
	POPatchGenRecord *rec = new POPatchGenRecord(this);
	if ( theHold.Holding() )
		theHold.Put(new PatchObjectRestore(this,rec));

	patch.CreateExtrusion();
	
	ResolveTopoChanges();
	theHold.Accept(GetResString(IDS_TH_PATCHADD));

	patch.InvalidateGeomCache();
	InvalidateMesh();

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
*/
}


void EditPatchMod::BeginExtrude(TimeValue t) {	
	if (inExtrude) return;
	inExtrude = TRUE;
	theHold.SuperBegin();
	DoExtrude();
//	PlugControllersSel(t,sel);
	theHold.Begin();
}

void EditPatchMod::EndExtrude (TimeValue t, BOOL accept) {		
	if (!ip) return;

	if (!inExtrude) return;

	ISpinnerControl *spin;
	inExtrude = FALSE;
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_EP_EXTRUDESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
		}
//	TempData()->freeBevelInfo();

	theHold.Accept(GetString(IDS_RB_EXTRUDE));
	if (accept) theHold.SuperAccept(GetString(IDS_RB_EXTRUDE));
	else theHold.SuperCancel();

}



void EditPatchMod::Extrude( TimeValue t, float amount, BOOL useLocalNorms ) {
	if (!inExtrude) return;


	ModContextList mcList;		
	INodeTab nodes;
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

//	theHold.Begin();
	RecordTopologyTags();

	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->patchSel.NumberSet()) {

			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			patch->MoveNormal(amount,useLocalNorms);
//			patch->InvalidateGeomCache();
//			InvalidateMesh();

			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}


	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

/*	theHold.Restore();
	patch.MoveNormal(amount,useLocalNorms);

	patch.InvalidateGeomCache();
	InvalidateMesh();

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
*/


}


void EditPatchMod::DoBevel()
{

	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->patchSel.NumberSet()) {

			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			patch->CreateBevel();
//			patch->CreateExtrusion();
//			patch->InvalidateGeomCache();
//			InvalidateMesh();

			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}


	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);

	/*
	theHold.Begin();
	patch.RecordTopologyTags();
	POPatchGenRecord *rec = new POPatchGenRecord(this);
	if ( theHold.Holding() )
		theHold.Put(new PatchObjectRestore(this,rec));

	patch.CreateBevel();
	
	ResolveTopoChanges();
	theHold.Accept(GetResString(IDS_TH_PATCHADD));

	patch.InvalidateGeomCache();
	InvalidateMesh();

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
*/
}


void EditPatchMod::BeginBevel(TimeValue t) {	
	if (inBevel) return;
	inBevel = TRUE;
	theHold.SuperBegin();
	DoBevel();
//	PlugControllersSel(t,sel);
	theHold.Begin();
}

void EditPatchMod::EndBevel (TimeValue t, BOOL accept) {		
	if (!ip) return;
	if (!inBevel) return;
	inBevel = FALSE;
//	TempData()->freeBevelInfo();
	ISpinnerControl *spin;

	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_EP_OUTLINESPINNER));
	if (spin) {
		spin->SetValue(0,FALSE);
		ReleaseISpinner(spin);
		}


	theHold.Accept(GetString(IDS_EM_BEVEL));
	if (accept) theHold.SuperAccept(GetString(IDS_EM_BEVEL));
	else theHold.SuperCancel();

}



void EditPatchMod::Bevel( TimeValue t, float amount, BOOL smoothStart, BOOL smoothEnd ) {
	if (!inBevel) return;


	ModContextList mcList;		
	INodeTab nodes;
	BOOL holdNeeded = FALSE;
	BOOL hadSelected = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

//	theHold.Begin();

	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;		
		patchData->RecordTopologyTags(patch);
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->patchSel.NumberSet()) {

			altered = holdNeeded = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch));
			// Call the vertex type change function
			patch->Bevel(amount,smoothStart, smoothEnd);
//			patch->MoveNormal(amount,useLocalNorms);
//			patch->InvalidateGeomCache();
//			InvalidateMesh();

			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHCHANGE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}


	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
/*
	theHold.Restore();
	patch.Bevel(amount,smoothStart, smoothEnd);

	patch.InvalidateGeomCache();
	InvalidateMesh();

	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
*/
}









void EditPatchMod::DoSubdivide(int type) {
	switch(type) {
		case EP_EDGE:
			DoEdgeSubdivide();
			break;
		case EP_PATCH:
			DoPatchSubdivide();
			break;
		}
	}

void EditPatchMod::DoEdgeSubdivide() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patchData->RecordTopologyTags(patch);
					
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->edgeSel.NumberSet()) {
			altered = holdNeeded = 1;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"DoEdgeSubdivide"));
			// Call the patch add function
			SubdividePatch(SUBDIV_EDGES, propagate, patch);
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_EDGESUBDIVIDE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOVALIDEDGESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::DoPatchSubdivide() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patchData->RecordTopologyTags(patch);
					
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->patchSel.NumberSet()) {
			altered = holdNeeded = 1;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"DoPatchSubdivide"));
			// Call the patch add function
			SubdividePatch(SUBDIV_PATCHES, propagate, patch);
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_PATCHSUBDIVIDE));
		}
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

void EditPatchMod::DoVertWeld() {
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;
	BOOL hadSel = FALSE;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();
	for ( int i = 0; i < mcList.Count(); i++ ) {
		BOOL altered = FALSE;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patchData->RecordTopologyTags(patch);
		
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any bits are set in the selection set, let's DO IT!!
		if(patch->vertSel.NumberSet() > 1) {
			hadSel = TRUE;
			if ( theHold.Holding() )
				theHold.Put(new PatchRestore(patchData,this,patch,"DoVertWeld"));
			// Call the patch weld function
			if(patch->Weld(weldThreshold)) {
				altered = holdNeeded = TRUE;
				patchData->UpdateChanges(patch);
				patchData->TempData(this)->Invalidate(PART_TOPO);
				}
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_VERTWELD));
		}
	else {
		if(!hadSel)
			ip->DisplayTempPrompt(GetString(IDS_TH_NOVERTSSEL),PROMPT_TIME);
		else
			ip->DisplayTempPrompt(GetString(IDS_TH_NOWELDPERFORMED),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime(),REDRAW_NORMAL);
	}

static void MakeDummyMapPatches(int channel, PatchMesh *patch) {
	patch->setNumMapVerts (channel, 1);
	patch->tVerts[channel][0] = UVVert(0,0,0);
	patch->setNumMapPatches (channel, patch->numPatches);
	for(int i = 0; i < patch->numPatches; ++i) {
		Patch &p = patch->patches[i];
		TVPatch &tp = patch->tvPatches[channel][i];
		tp.Init();	// Sets all indices to zero
		}
	}

// Detach all selected patches
void EditPatchMod::DoPatchDetach(int copy, int reorient) {
	int dialoged = 0;
	TSTR newName(GetString(IDS_TH_PATCH));
	ModContextList mcList;		
	INodeTab nodes;
	TimeValue t = ip->GetTime();
	int holdNeeded = 0;

	if ( !ip ) return;

	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	theHold.Begin();
	RecordTopologyTags();

	// Create a patch mesh object
	PatchObject *patchOb = new PatchObject;
	PatchMesh &pmesh = patchOb->patch;
	int verts = 0;
	int vecs = 0;
	int patches = 0;

	int multipleObjects = (mcList.Count() > 1) ? 1 : 0;

//watje 10-4-99  184681 
	Tab<HookPoint> whooks;

	for ( int i = 0; i < mcList.Count(); i++ ) {
		int altered = 0;
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if ( !patchData ) continue;
		if ( patchData->GetFlag(EPD_BEENDONE) ) continue;

		// If the mesh isn't yet cache, this will cause it to get cached.
		PatchMesh *patch = patchData->TempData(this)->GetPatch(t);
		if(!patch)
			continue;
		patchData->RecordTopologyTags(patch);
		
		// If this is the first edit, then the delta arrays will be allocated
		patchData->BeginEdit(t);

		// If any patches selected, we'll need to process this one
		if(patch->patchSel.NumberSet()) {
			if(!dialoged) {
				dialoged = 1;
				if(!GetDetachOptions(ip, newName))
					goto bail_out;
				}
			// Save the unmodified info.
			if ( theHold.Holding() ) {
				theHold.Put(new PatchRestore(patchData,this,patch,"DoPatchDetach"));
				}
			PatchMesh wpatch = *patch;
//watje 10-4-99 184681
			wpatch.hooks = patch->hooks;
			wpatch.hookTopoMarkers = patch->hookTopoMarkers;
			wpatch.hookTopoMarkersA = patch->hookTopoMarkersA;
			wpatch.hookTopoMarkersB = patch->hookTopoMarkersB;

			BitArray vdel(wpatch.numVerts);
			vdel.ClearAll();
			BitArray pdel = wpatch.patchSel;	// Get inverse selection set
			// If not copying, delete the patches from this object
			if(!copy)
				DeletePatchParts(patch, vdel, pdel);
			pdel = ~wpatch.patchSel;	// Get inverse selection set
			if(pdel.NumberSet()) {
				vdel.ClearAll();
				DeletePatchParts(&wpatch, vdel, pdel);
				}
//watje 10-4-99 184681
			wpatch.HookFixTopology();
//watje 10-4-99 184681
			int oldEdges = pmesh.numEdges;


			// We've deleted everything that wasn't selected -- Now add this to the patch object accumulator
			int oldVerts = pmesh.numVerts;
			int oldVecs = pmesh.numVecs;
			int oldPatches = pmesh.numPatches;

//watje 10-4-99 184681
			for (int hi = 0; hi < wpatch.hooks.Count(); hi++)
				{
				HookPoint tempHook = wpatch.hooks[hi];
				tempHook.upperPoint += oldVerts;
				tempHook.lowerPoint += oldVerts;
				tempHook.hookPoint += oldVerts;
				tempHook.upperVec += oldVecs;
				tempHook.lowerVec += oldVecs;
				tempHook.upperHookVec += oldVecs;
				tempHook.lowerHookVec += oldVecs;
				tempHook.upperPatch += oldPatches; 
				tempHook.lowerPatch += oldPatches;
				tempHook.hookPatch += oldPatches;
				tempHook.hookEdge += oldEdges;
				tempHook.upperEdge += oldEdges;
				tempHook.lowerEdge += oldEdges;

				whooks.Append(1,&tempHook,1);

				}

			int newVerts = oldVerts + wpatch.numVerts;
			int newVecs = oldVecs + wpatch.numVecs;
			int newPatches = oldPatches + wpatch.numPatches;
			pmesh.setNumVerts(newVerts, TRUE);
			pmesh.setNumVecs(newVecs, TRUE);
			pmesh.setNumPatches(newPatches, TRUE);
			altered = holdNeeded = 1;
			Matrix3 tm(1);
			if(multipleObjects && !reorient)
				tm = nodes[i]->GetObjectTM(t);
			for(int i = 0, i2 = oldVerts; i < wpatch.numVerts; ++i, ++i2) {
				pmesh.verts[i2] = wpatch.verts[i];
				pmesh.verts[i2].p = pmesh.verts[i2].p * tm;
				}
			for(i = 0, i2 = oldVecs; i < wpatch.numVecs; ++i, ++i2) {
				pmesh.vecs[i2] = wpatch.vecs[i];
				pmesh.vecs[i2].p = pmesh.vecs[i2].p * tm;
				}
			for(i = 0, i2 = oldPatches; i < wpatch.numPatches; ++i, ++i2) {
				Patch &p = wpatch.patches[i];
				Patch &p2 = pmesh.patches[i2];
				p2 = p;
				for(int j = 0; j < p2.type; ++j) {	// Adjust vertices and interior vectors
					p2.v[j] += oldVerts;
					p2.interior[j] += oldVecs;
					}
				for(j = 0; j < (p2.type * 2); ++j)	// Adjust edge vectors
					p2.vec[j] += oldVecs;
				}
			// Now copy over mapping information
			int dmaps = pmesh.getNumMaps();
			int smaps = wpatch.getNumMaps();
			int maxMaps = dmaps > smaps ? dmaps : smaps;
			if(maxMaps != dmaps)
				pmesh.setNumMaps (maxMaps, TRUE);
			if(maxMaps != smaps)
				wpatch.setNumMaps(maxMaps, TRUE);
			// Then make sure any active maps are active in both:
			for(int chan = 0; chan < maxMaps; ++chan) {
				if(pmesh.tvPatches[chan] || wpatch.tvPatches[chan]) {
					if(!pmesh.tvPatches[chan]) MakeDummyMapPatches(chan, &pmesh);
					if(!wpatch.tvPatches[chan]) MakeDummyMapPatches(chan, &wpatch);
					}
				}
			for(chan = 0; chan < pmesh.getNumMaps(); ++chan) {
				if(chan < wpatch.getNumMaps()) {
					int oldTVerts = pmesh.numTVerts[chan];
					int newTVerts = oldTVerts + wpatch.numTVerts[chan];
					pmesh.setNumMapVerts (chan, newTVerts, TRUE);
					for(i = 0, i2 = oldTVerts; i < wpatch.numTVerts[chan]; ++i, ++i2)
						pmesh.tVerts[chan][i2] = wpatch.tVerts[chan][i];
					if(pmesh.tvPatches[chan]) {
						for(i = 0, i2 = oldPatches; i < wpatch.numPatches; ++i, ++i2) {
							Patch &p = wpatch.patches[i];
							TVPatch &tp = wpatch.tvPatches[chan][i];
							TVPatch &tp2 = pmesh.tvPatches[chan][i2];
							tp2 = tp;
							for(int j = 0; j < p.type; ++j)	// Adjust vertices
								tp2.tv[j] += oldTVerts;
							}
						}
					}
				}
			patchData->UpdateChanges(patch);
			patchData->TempData(this)->Invalidate(PART_TOPO);
//watje 10-4-99 184681
			pmesh.buildLinkages();
			}

		bail_out:
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
	
	if(holdNeeded) {
		pmesh.computeInteriors();
		pmesh.buildLinkages();
//watje 10-4-99 184681
		pmesh.hooks = whooks;

		INode *newNode = ip->CreateObjectNode(patchOb);
		newNode->SetMtl(nodes[0]->GetMtl());
		newNode->SetName(newName.data());
		patchOb->patch.InvalidateGeomCache();
		if(!multipleObjects) {	// Single input object?
			if(!reorient) {
				Matrix3 tm = nodes[0]->GetObjectTM(t);
				newNode->SetNodeTM(t, tm);	// Use this object's TM.
				}
			}
		else {
			if(!reorient) {
				Matrix3 matrix;
				matrix.IdentityMatrix();
				newNode->SetNodeTM(t, matrix);	// Use identity TM
				}
			}
		newNode->FlagForeground(t);		// WORKAROUND!
		ResolveTopoChanges();
		theHold.Accept(GetString(IDS_TH_DETACHPATCH));
		}
	else {
		delete patchOb;	// Didn't need it after all!
		if(!dialoged)
			ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(t,REDRAW_NORMAL);
	}


void EditPatchMod::SetTessUI(HWND hDlg, TessApprox *tess)
{
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_U), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_U_SPINNER), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_V), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_SPINNER), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_EDGE), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_EDGE_SPINNER), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_DIST), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_DIST_SPINNER), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_ANG), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_ANG_SPINNER), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_PARAMETERS), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_NORMALS), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), FALSE);
	EnableWindow(GetDlgItem(hDlg, IDC_WELDTESS), FALSE);
	CheckDlgButton( hDlg, IDC_TESS_SET, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_REGULAR, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_PARAM, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_SPATIAL, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_CURV, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_LDA, FALSE);

	ShowWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), SW_HIDE);
	ShowWindow(GetDlgItem(hDlg, IDC_TESS_NORMALS), SW_HIDE);
	ShowWindow(GetDlgItem(hDlg, IDC_WELDTESS), SW_HIDE);
	ShowWindow(GetDlgItem(hDlg, IDC_MESH), SW_HIDE);
	ShowWindow(GetDlgItem(hDlg, IDC_DISP), SW_HIDE);

//watje 12-10-98
	if (tess->showInteriorFaces)
		CheckDlgButton( hDlg, IDC_SHOW_INTERIOR_FACES, TRUE);
	else CheckDlgButton( hDlg, IDC_SHOW_INTERIOR_FACES, FALSE);

	switch (tess->type) {
	case TESS_SET:
		CheckDlgButton( hDlg, IDC_TESS_SET, TRUE);
		mergeSpin->Disable();
		EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), TRUE);
		break;

	case TESS_REGULAR:
		CheckDlgButton( hDlg, IDC_TESS_REGULAR, TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_U), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_U_SPINNER), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_SPINNER), TRUE);

		ShowWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), SW_HIDE);
		mergeSpin->Enable();
		EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), FALSE);
		break;

	case TESS_PARAM:
		CheckDlgButton( hDlg, IDC_TESS_PARAM, TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_U), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_U_SPINNER), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_SPINNER), TRUE);

		mergeSpin->Enable();
		EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), FALSE);
		break;

	case TESS_SPATIAL:
		CheckDlgButton( hDlg, IDC_TESS_SPATIAL, TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_EDGE), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_EDGE_SPINNER), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), TRUE);

		EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), !settingViewportTess);
		ShowWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), settingViewportTess?SW_HIDE:SW_SHOW);
		EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_PARAMETERS), TRUE);
		mergeSpin->Enable();
		EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), FALSE);
		break;

	case TESS_CURVE:
		CheckDlgButton( hDlg, IDC_TESS_CURV, TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_DIST), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_DIST_SPINNER), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_ANG), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_ANG_SPINNER), TRUE);

		EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), !settingViewportTess);
		ShowWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), settingViewportTess?SW_HIDE:SW_SHOW);
		EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_PARAMETERS), TRUE);
		mergeSpin->Enable();
		EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), FALSE);
		break;

	case TESS_LDA:
		CheckDlgButton( hDlg, IDC_TESS_LDA, TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_EDGE), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_EDGE_SPINNER), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_DIST), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_DIST_SPINNER), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_ANG), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_ANG_SPINNER), TRUE);

		EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), !settingViewportTess);
		ShowWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), settingViewportTess?SW_HIDE:SW_SHOW);
		EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_PARAMETERS), TRUE);
		mergeSpin->Enable();
		EnableWindow(GetDlgItem(hDlg, IDC_SHOW_INTERIOR_FACES), FALSE);
		break;
	}


	if (settingViewportTess) {
		ShowWindow(GetDlgItem(hDlg, IDC_TESS_SET), SW_SHOW);

		if (tess->type != TESS_SET) {
			ShowWindow(GetDlgItem(hDlg, IDC_TESS_NORMALS), SW_SHOW);
			ShowWindow(GetDlgItem(hDlg, IDC_WELDTESS), SW_SHOW);
			EnableWindow(GetDlgItem(hDlg, IDC_TESS_NORMALS), !GetViewTessWeld());
			EnableWindow(GetDlgItem(hDlg, IDC_WELDTESS), tess->merge > 0.0f);
		}
	} else {
		if (settingDisp) {
			ShowWindow(GetDlgItem(hDlg, IDC_MESH), SW_SHOW);
			ShowWindow(GetDlgItem(hDlg, IDC_DISP), SW_SHOW);
		} else {
			if (tess->type != TESS_SET) {
				ShowWindow(GetDlgItem(hDlg, IDC_MESH), SW_SHOW);
				ShowWindow(GetDlgItem(hDlg, IDC_DISP), SW_SHOW);
				ShowWindow(GetDlgItem(hDlg, IDC_TESS_NORMALS), SW_SHOW);
				ShowWindow(GetDlgItem(hDlg, IDC_WELDTESS), SW_SHOW);
				EnableWindow(GetDlgItem(hDlg, IDC_TESS_NORMALS), !GetProdTessWeld());
				EnableWindow(GetDlgItem(hDlg, IDC_WELDTESS), tess->merge > 0.0f);
				CheckDlgButton( hDlg, IDC_MESH, TRUE);
			}
			ShowWindow(GetDlgItem(hDlg, IDC_TESS_SET), SW_SHOW);
		}
	}

	// now set all the settings
	uSpin->SetValue(tess->u, FALSE);
	vSpin->SetValue(tess->v, FALSE);
	edgeSpin->SetValue(tess->edge, FALSE);
	distSpin->SetValue(tess->dist, FALSE);
	angSpin->SetValue(tess->ang, FALSE);
	mergeSpin->SetValue(tess->merge, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_VIEW_DEP, tess->view);
	if (settingViewportTess) {
		CheckDlgButton( hDlg, IDC_TESS_VIEW, TRUE);
		CheckDlgButton( hDlg, IDC_TESS_RENDERER, FALSE);
		CheckDlgButton( hDlg, IDC_TESS_NORMALS, GetViewTessNormals());
		CheckDlgButton( hDlg, IDC_WELDTESS, GetViewTessWeld());
	} else {
		CheckDlgButton( hDlg, IDC_TESS_VIEW, FALSE);
		CheckDlgButton( hDlg, IDC_TESS_RENDERER, TRUE);
		CheckDlgButton( hDlg, IDC_TESS_NORMALS, GetProdTessNormals());
		CheckDlgButton( hDlg, IDC_WELDTESS, GetProdTessWeld());
	}
	CheckDlgButton( hDlg, IDC_DISP, settingDisp);
}

int EditPatchMod::GetSelMatIndex()
	{
	ModContextList mcList;	
	INodeTab nodes;
	BOOL first = 1;
	int mat=-1;

	if (!ip) return -1;
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;
		if (patchData->GetFlag(EPD_BEENDONE)) continue;
		patchData->BeginEdit(ip->GetTime());
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());
		if(!patch)
			continue;
		for (int j=0; j<patch->getNumPatches(); j++) {
			if (patch->patchSel[j]) {
				if (first) {
					first = FALSE;
					mat   = (int)patch->getPatchMtlIndex(j);					
				} else {
					if ((int)patch->getPatchMtlIndex(j) != mat) {
						return -1;
						}
					}
				}
			}
		}
	
	nodes.DisposeTemporary();
	return mat;
	}

void EditPatchMod::SetSelMatIndex(int index)
	{
	ModContextList mcList;	
	INodeTab nodes;
	BOOL holdNeeded = FALSE;

	if (!ip) return;
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);	

	theHold.Begin();
	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		BOOL altered = FALSE;
		if (!patchData) continue;
		if (patchData->GetFlag(EPD_BEENDONE)) continue;
		patchData->BeginEdit(ip->GetTime());
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());		
		if(!patch)
			continue;

		// Start a restore object...
		if (theHold.Holding()) {
			theHold.Put(new PatchRestore(patchData,this,patch,"SetSelMatIndex"));
			}

		for (int j=0; j<patch->getNumPatches(); j++) {			
			if (patch->patchSel[j]) {
				altered = holdNeeded = TRUE;
				patch->setPatchMtlIndex(j,(MtlID)index);			
				}
			}
		
		if(altered) {
			patchData->UpdateChanges(patch, FALSE);
			patchData->TempData(this)->Invalidate(PART_TOPO);
			}
		patchData->SetFlag(EPD_BEENDONE,TRUE);		
		}	
	
	if(holdNeeded)
		theHold.Accept(GetString(IDS_TH_PATCHMTLCHANGE));
	else {
		ip->DisplayTempPrompt(GetString(IDS_TH_NOPATCHESSEL),PROMPT_TIME);
		theHold.End();
		}

	nodes.DisposeTemporary();
	InvalidateSurfaceUI();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

void EditPatchMod::SelectByMat(int index,BOOL clear)
	{
	ModContextList mcList;	
	INodeTab nodes;

	if (!ip) return;
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	
	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;
		if (patchData->GetFlag(EPD_BEENDONE)) continue;
		patchData->BeginEdit(ip->GetTime());
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());		
		if(!patch)
			continue;

		// Start a restore object...
		if (theHold.Holding()) {
			theHold.Put(new PatchSelRestore(patchData,this,patch));
			}
		
		if (clear)
			patch->patchSel.ClearAll();

		for (int j=0; j<patch->getNumPatches(); j++) {			
			if (patch->getPatchMtlIndex(j)==index)
				patch->patchSel.Set(j);
			}
		
		patchData->UpdateChanges(patch, FALSE);
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		patchData->TempData(this)->Invalidate(PART_SELECT);
		}
		
	PatchSelChanged();
	theHold.Accept(GetString(IDS_RB_SELECTBYMATID));
	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

DWORD EditPatchMod::GetSelSmoothBits(DWORD &invalid)
	{
	BOOL first = 1;
	DWORD bits = 0;
	invalid = 0;
	ModContextList mcList;	
	INodeTab nodes;

	if (!ip) return 0;
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	
	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;
		if (patchData->GetFlag(EPD_BEENDONE)) continue;
		patchData->BeginEdit(ip->GetTime());
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());		
		if(!patch)
			continue;

		for (int j=0; j<patch->getNumPatches(); j++) {
			if (patch->patchSel[j]) {
				if (first) {
					first = FALSE;
					bits  = patch->patches[j].smGroup;					
				} else {
					if (patch->patches[j].smGroup != bits) {
						invalid |= patch->patches[j].smGroup^bits;
						}
					}
				}
			}

		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
		
	nodes.DisposeTemporary();
	return bits;
	}

DWORD EditPatchMod::GetUsedSmoothBits()
	{	
	DWORD bits = 0;
	ModContextList mcList;	
	INodeTab nodes;

	if (!ip) return 0;
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	
	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;
		if (patchData->GetFlag(EPD_BEENDONE)) continue;
		patchData->BeginEdit(ip->GetTime());
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());		
		if(!patch)
			continue;

		for (int j=0; j<patch->getNumPatches(); j++) {
			bits |= patch->patches[j].smGroup;
			}		

		patchData->SetFlag(EPD_BEENDONE,TRUE);
		}
		
	nodes.DisposeTemporary();
	return bits;
	}

void EditPatchMod::SelectBySmoothGroup(DWORD bits,BOOL clear)
	{
	ModContextList mcList;	
	INodeTab nodes;

	if (!ip) return;
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	
	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;
		if (patchData->GetFlag(EPD_BEENDONE)) continue;
		patchData->BeginEdit(ip->GetTime());
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());		
		if(!patch)
			continue;

		// Start a restore object...
		if (theHold.Holding()) {
			theHold.Put(new PatchSelRestore(patchData,this,patch));
			}
		
		if (clear)
			patch->patchSel.ClearAll();			
		for (int j=0; j<patch->getNumPatches(); j++) {			
			if (patch->patches[j].smGroup & bits) {
				patch->patchSel.Set(j);			
				}
			}
		
		patchData->UpdateChanges(patch, FALSE);
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		patchData->TempData(this)->Invalidate(PART_SELECT);
		}
		
	PatchSelChanged();
	theHold.Accept(GetString(IDS_RB_SELECTBYSMOOTH));
	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_SELECT, REFMSG_CHANGE);
	ip->RedrawViews(ip->GetTime());
	}

void EditPatchMod::SetSelSmoothBits(DWORD bits,DWORD which)
	{
	ModContextList mcList;	
	INodeTab nodes;

	if (!ip) return;
	ip->GetModContexts(mcList,nodes);
	ClearPatchDataFlag(mcList,EPD_BEENDONE);
	
	theHold.Begin();

	for (int i = 0; i < mcList.Count(); i++) {
		EditPatchData *patchData = (EditPatchData*)mcList[i]->localData;
		if (!patchData) continue;
		if (patchData->GetFlag(EPD_BEENDONE)) continue;
		patchData->BeginEdit(ip->GetTime());
		PatchMesh *patch = patchData->TempData(this)->GetPatch(ip->GetTime());		
		if(!patch)
			continue;

		// Start a restore object...
		if (theHold.Holding()) {
			theHold.Put(new PatchSelRestore(patchData,this,patch));
			}
		
		for (int j=0; j<patch->getNumPatches(); j++) {			
			if (patch->patchSel[j]) {
				patch->patches[j].smGroup &= ~which;
				patch->patches[j].smGroup |= bits&which;			
				}
			}
		
		patchData->UpdateChanges(patch, FALSE);
		patchData->SetFlag(EPD_BEENDONE,TRUE);
		patchData->TempData(this)->Invalidate(PART_SELECT);
		}
		
	PatchSelChanged();
	theHold.Accept(GetString(IDS_RB_SETSMOOTHGROUP));
	
	nodes.DisposeTemporary();
	NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
	InvalidateSurfaceUI();
	ip->RedrawViews(ip->GetTime());
	}

void EditPatchMod::PatchSelChanged() {
	SelectionChanged();
	if (hSurfPanel && selLevel == EP_PATCH)
		InvalidateSurfaceUI();
	}

class AdvParams {
public:
	TessSubdivStyle mStyle;
	int mMin, mMax;
	int mTris;
};

static AdvParams sParams;

BOOL CALLBACK AdvParametersDialogProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam ); 

void EditPatchMod::SetSelDlgEnables() {
	if(!hSelectPanel)
		return;
	ICustButton *but = GetICustButton(GetDlgItem(hSelectPanel,IDC_NS_PASTE));
	but->Disable();
	switch(GetSubobjectLevel()) {
		case PO_VERTEX:
			if (GetPatchNamedSelClip(CLIP_P_VERT))
				but->Enable();
			break;
		case PO_EDGE:
			if (GetPatchNamedSelClip(CLIP_P_EDGE))
				but->Enable();
			break;
		case PO_PATCH:
			if (GetPatchNamedSelClip(CLIP_P_PATCH))
				but->Enable();
			break;
		}
	ReleaseICustButton(but);
	}

void EditPatchMod::SetOpsDlgEnables() {
	if(!hOpsPanel)
		return;
	
	assert(ip);
	
	// Disconnect right-click and delete mechanisms
	ip->GetRightClickMenuManager()->Unregister(&pMenu);
	ip->UnRegisterDeleteUser(&pDel);

	BOOL oType = (GetSubobjectLevel() == EP_OBJECT) ? TRUE : FALSE;
	BOOL vType = (GetSubobjectLevel() == EP_VERTEX) ? TRUE : FALSE;
	BOOL eType = (GetSubobjectLevel() == EP_EDGE) ? TRUE : FALSE;
	BOOL pType = (GetSubobjectLevel() == EP_PATCH) ? TRUE : FALSE;
	BOOL epType = (eType || pType) ? TRUE : FALSE;
	BOOL vepType = (vType || eType || pType) ? TRUE : FALSE;


	ICustButton *but;
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_BIND));
	but->Enable (vType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_UNBIND));
	but->Enable (vType);
	ReleaseICustButton (but);

	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_SUBDIVIDE));
	but->Enable (epType);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_PROPAGATE), epType);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ADDTRI));
	but->Enable (eType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_ADDQUAD));
	but->Enable (eType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_WELD));
	but->Enable (vType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_DETACH));
	but->Enable (pType);
	ReleaseICustButton (but);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_DETACHREORIENT), pType);
	EnableWindow (GetDlgItem (hOpsPanel, IDC_DETACHCOPY), pType);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_PATCH_DELETE));
	but->Enable (vepType);
	ReleaseICustButton (but);
	ISpinnerControl *spin;
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_THRESHSPINNER));
	spin->Enable(vType);
	ReleaseISpinner(spin);

//3-1-99 watje
	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_HIDE));
	spin->Enable(vepType);
	ReleaseISpinner(spin);

	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_EP_EXTRUDE));
	but->Enable (pType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hOpsPanel, IDC_EP_BEVEL));
	but->Enable (pType);
	ReleaseICustButton (but);

	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_EP_EXTRUDESPINNER));
	spin->Enable(pType);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hOpsPanel,IDC_EP_OUTLINESPINNER));
	spin->Enable(pType);
	ReleaseISpinner(spin);
	EnableWindow(GetDlgItem(hOpsPanel,IDC_EM_EXTYPE_A),pType);
	EnableWindow(GetDlgItem(hOpsPanel,IDC_EM_EXTYPE_B),pType);

	EnableWindow(GetDlgItem(hOpsPanel,IDC_EP_SM_SMOOTH4),pType);
	EnableWindow(GetDlgItem(hOpsPanel,IDC_EP_SM_SMOOTH5),pType);
	EnableWindow(GetDlgItem(hOpsPanel,IDC_EP_SM_SMOOTH6),pType);

	EnableWindow(GetDlgItem(hOpsPanel,IDC_EP_SM_SMOOTH),pType);
	EnableWindow(GetDlgItem(hOpsPanel,IDC_EP_SM_SMOOTH2),pType);
	EnableWindow(GetDlgItem(hOpsPanel,IDC_EP_SM_SMOOTH3),pType);

	// Enable/disable right-click and delete mechanisms
	if(!oType) {			
		pMenu.SetMod(this);
		ip->GetRightClickMenuManager()->Register(&pMenu);
		pDel.SetMod(this);
		ip->RegisterDeleteUser(&pDel);
		}
	}

void EditPatchMod::SetSurfDlgEnables() {
	if(!hSurfPanel)
		return;
	
	assert(ip);
	
	BOOL oType = (GetSubobjectLevel() == EP_OBJECT) ? TRUE : FALSE;
	BOOL pType = (GetSubobjectLevel() == EP_PATCH) ? TRUE : FALSE;

	if(oType)
		return;
	if(!pType)
		return;

	ICustButton *but;
	ISpinnerControl *spin;
	but = GetICustButton (GetDlgItem (hSurfPanel, IDC_SELECT_BYID));
	but->Enable (pType);
	ReleaseICustButton (but);
	spin = GetISpinner(GetDlgItem(hSurfPanel,IDC_MAT_IDSPIN));
	spin->Enable(pType);
	ReleaseISpinner(spin);
	for(int i = 0; i < 32; ++i) {
		but = GetICustButton (GetDlgItem (hSurfPanel, IDC_SMOOTH_GRP1+i));
		but->Enable (pType);
		ReleaseICustButton (but);
		}
	but = GetICustButton (GetDlgItem (hSurfPanel, IDC_SELECTBYSMOOTH));
	but->Enable (pType);
	ReleaseICustButton (but);
	but = GetICustButton (GetDlgItem (hSurfPanel, IDC_SMOOTH_CLEAR));
	but->Enable (pType);
	ReleaseICustButton (but);
	}

/*-------------------------------------------------------------------*/

BOOL CALLBACK PatchSelectDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	EditPatchMod *ep = (EditPatchMod *)GetWindowLong( hDlg, GWL_USERDATA );
	ICustToolbar *iToolbar;
	if ( !ep && message != WM_INITDIALOG ) return FALSE;
	
	switch ( message ) {
		case WM_INITDIALOG: {
		 	ep = (EditPatchMod *)lParam;
		 	ep->hSelectPanel = hDlg;
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)ep );		 	
			// Set up the editing level selector
			LoadImages();
			iToolbar = GetICustToolbar(GetDlgItem(hDlg,IDC_SELTYPE));
			iToolbar->SetImage(hFaceImages);
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,0,3,0,3,24,23,24,23,EP_VERTEX));
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,1,4,1,4,24,23,24,23,EP_EDGE));
			iToolbar->AddTool(ToolButtonItem(CTB_CHECKBUTTON,2,5,2,5,24,23,24,23,EP_PATCH));
			ReleaseICustToolbar(iToolbar);
			ep->RefreshSelType();
			CheckDlgButton( hDlg, IDC_DISPLATTICE, ep->displayLattice);
//			CheckDlgButton( hDlg, IDC_DISPSURFACE, ep->displaySurface);
			CheckDlgButton( hDlg, IDC_FILTVERTS, filterVerts);
			CheckDlgButton( hDlg, IDC_FILTVECS, filterVecs);
			CheckDlgButton( hDlg, IDC_LOCK_HANDLES, lockedHandles);
			ep->SetSelDlgEnables();
		 	return TRUE;
			}

		case WM_DESTROY:
			// Don't leave in one of our modes!
			ep->ip->ClearPickMode();
			CancelEditPatchModes(ep->ip);
			return FALSE;
		
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			ep->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;		
		
		case WM_COMMAND: {
			BOOL needRedraw = FALSE;
			switch ( LOWORD(wParam) ) {				
				case EP_VERTEX:
					if (ep->GetSubobjectLevel() == EP_VERTEX)
						ep->ip->SetSubObjectLevel (PO_OBJECT);
					else ep->ip->SetSubObjectLevel (EP_VERTEX);
					needRedraw = TRUE;
					break;

				case EP_EDGE:
					if (ep->GetSubobjectLevel() == EP_EDGE)
						ep->ip->SetSubObjectLevel (PO_OBJECT);
					else ep->ip->SetSubObjectLevel (EP_EDGE);
					needRedraw = TRUE;
					break;

				case EP_PATCH:
					if (ep->GetSubobjectLevel() == EP_PATCH)
						ep->ip->SetSubObjectLevel (PO_OBJECT);
					else ep->ip->SetSubObjectLevel (EP_PATCH);
					needRedraw = TRUE;
					break;

				case IDC_DISPLATTICE:
					ep->SetDisplayLattice(IsDlgButtonChecked(hDlg, IDC_DISPLATTICE));
					needRedraw = TRUE;
					break;
				case IDC_DISPSURFACE:
					ep->SetDisplaySurface(IsDlgButtonChecked(hDlg, IDC_DISPSURFACE));
					needRedraw = TRUE;
					break;
				case IDC_FILTVERTS:
					filterVerts = IsDlgButtonChecked(hDlg, IDC_FILTVERTS);
					EnableWindow(GetDlgItem(hDlg,IDC_FILTVECS), filterVerts ? TRUE : FALSE);
					SetVertFilter();
					break;
				case IDC_FILTVECS:
					filterVecs = IsDlgButtonChecked(hDlg, IDC_FILTVECS);
					EnableWindow(GetDlgItem(hDlg,IDC_FILTVERTS), filterVecs ? TRUE : FALSE);
					SetVertFilter();
					break;
				case IDC_LOCK_HANDLES:
					lockedHandles = IsDlgButtonChecked( hDlg, IDC_LOCK_HANDLES);
					break;
				case IDC_NS_COPY:
					ep->NSCopy();
					break;
				case IDC_NS_PASTE:
					ep->NSPaste();
					break;
				}
			if(needRedraw) {
				ep->NotifyDependents(FOREVER, PART_DISPLAY, REFMSG_CHANGE);
				ep->ip->RedrawViews(ep->ip->GetTime(),REDRAW_NORMAL);
				}
			}
			break;
		case WM_NOTIFY:
			if(((LPNMHDR)lParam)->code == TTN_NEEDTEXT) {
				LPTOOLTIPTEXT lpttt;
				lpttt = (LPTOOLTIPTEXT)lParam;				
				switch (lpttt->hdr.idFrom) {
				case EP_VERTEX:
					lpttt->lpszText = GetString (IDS_TH_VERTEX);
					break;
				case EP_EDGE:
					lpttt->lpszText = GetString (IDS_TH_EDGE);
					break;
				case EP_PATCH:
					lpttt->lpszText = GetString(IDS_TH_PATCH);
					break;
				}
			}
			break;

		}
	
	return FALSE;
	}

static void SetSmoothButtonState (HWND hWnd,DWORD bits,DWORD invalid,DWORD unused=0) {
	for (int i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++) {
		if ( (unused&(1<<(i-IDC_SMOOTH_GRP1))) ) {
			ShowWindow(GetDlgItem(hWnd,i),SW_HIDE);
			continue;
		}

		if ( (invalid&(1<<(i-IDC_SMOOTH_GRP1))) ) {
			SetWindowText(GetDlgItem(hWnd,i),NULL);
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_STATE,FALSE);
		} else {
			TSTR buf;
			buf.printf(_T("%d"),i-IDC_SMOOTH_GRP1+1);
			SetWindowText(GetDlgItem(hWnd,i),buf);
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_STATE,
				(bits&(1<<(i-IDC_SMOOTH_GRP1)))?TRUE:FALSE);
		}
		InvalidateRect(GetDlgItem(hWnd,i),NULL,TRUE);
	}
}

static BOOL CALLBACK SelectBySmoothDlgProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) {
	static DWORD *param;
	switch (msg) {
	case WM_INITDIALOG:
		param = (DWORD*)lParam;
		int i;
		for (i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++)
			SendMessage(GetDlgItem(hWnd,i),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
		SetSmoothButtonState(hWnd,param[0],0,param[2]);
		CheckDlgButton(hWnd,IDC_CLEARSELECTION,param[1]);
		CenterWindow(hWnd,GetParent(hWnd));
		break;

	case WM_COMMAND: 
		if (LOWORD(wParam)>=IDC_SMOOTH_GRP1 &&
			LOWORD(wParam)<=IDC_SMOOTH_GRP32) {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,LOWORD(wParam)));				
			int shift = LOWORD(wParam) - IDC_SMOOTH_GRP1;				
			if (iBut->IsChecked()) {
				param[0] |= 1<<shift;
			} else {
				param[0] &= ~(1<<shift);
			}				
			ReleaseICustButton(iBut);
			break;
		}

		switch (LOWORD(wParam)) {
		case IDOK:
			param[1] = IsDlgButtonChecked(hWnd,IDC_CLEARSELECTION);					
			EndDialog(hWnd,1);					
			break;					

		case IDCANCEL:
			EndDialog(hWnd,0);
			break;
		}
		break;			

	default:
		return FALSE;
	}
	return TRUE;
}

static BOOL CALLBACK SelectByMatDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	static int *param;
	switch (msg) {
		case WM_INITDIALOG:
			param = (int*)lParam;
			SetupIntSpinner(hWnd,IDC_MAT_IDSPIN,IDC_MAT_ID,1,MAX_MATID,param[0]);			
			CheckDlgButton(hWnd,IDC_CLEARSELECTION,param[1]);
			CenterWindow(hWnd,GetParent(hWnd));
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK: {
					ISpinnerControl *spin = GetISpinner(GetDlgItem(hWnd,IDC_MAT_IDSPIN));
					param[0] = spin->GetIVal();
					param[1] = IsDlgButtonChecked(hWnd,IDC_CLEARSELECTION);
					ReleaseISpinner(spin);
					EndDialog(hWnd,1);					
					break;
					}

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

BOOL CALLBACK PatchOpsDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	EditPatchMod *ep = (EditPatchMod *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !ep && message != WM_INITDIALOG ) return FALSE;

	
	ISpinnerControl *spin;
	ICustButton *ebut;

	switch ( message ) {
		case WM_INITDIALOG: {

		 	ep = (EditPatchMod *)lParam;
		 	ep->hOpsPanel = hDlg;
			for (int i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++)
				SendMessage(GetDlgItem(hDlg,i),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)ep );		 	
			ICustButton *but = GetICustButton(GetDlgItem(hDlg,IDC_ATTACH));
			but->SetHighlightColor(GREEN_WASH);
			but->SetType(CBT_CHECK);
			ReleaseICustButton(but);
			CheckDlgButton( hDlg, IDC_ATTACHREORIENT, attachReorient);
			CheckDlgButton( hDlg, IDC_DETACHCOPY, patchDetachCopy);
			CheckDlgButton( hDlg, IDC_DETACHREORIENT, patchDetachReorient);
			CheckDlgButton( hDlg, IDC_PROPAGATE, ep->GetPropagate());
		 	ep->stepsSpin = GetISpinner(GetDlgItem(hDlg,IDC_STEPSSPINNER));
			ep->stepsSpin->SetLimits( 0, 100, FALSE );
			ep->stepsSpin->LinkToEdit( GetDlgItem(hDlg,IDC_STEPS), EDITTYPE_POS_INT );
			ep->stepsSpin->SetValue(ep->GetMeshSteps(),FALSE);

//3-18-99 to suport render steps and removal of the mental tesselator
		 	ep->stepsRenderSpin = GetISpinner(GetDlgItem(hDlg,IDC_STEPSRENDERSPINNER));
			ep->stepsRenderSpin->SetLimits( 0, 100, FALSE );
			ep->stepsRenderSpin->LinkToEdit( GetDlgItem(hDlg,IDC_STEPS_RENDER), EDITTYPE_POS_INT );
			ep->stepsRenderSpin->SetValue(ep->GetMeshStepsRender(),FALSE);
			CheckDlgButton( hDlg, IDC_SHOW_INTERIOR_FACES, ep->GetShowInterior());

		 	ep->weldSpin = GetISpinner(GetDlgItem(hDlg,IDC_THRESHSPINNER));
			ep->weldSpin->SetLimits( 0, 999999, FALSE );
			ep->weldSpin->LinkToEdit( GetDlgItem(hDlg,IDC_WELDTHRESH), EDITTYPE_UNIVERSE );
			ep->weldSpin->SetValue(weldThreshold,FALSE);

			CheckDlgButton( hDlg, IDC_EM_EXTYPE_B, TRUE);
			CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH, TRUE);
			CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH4, TRUE);

			ep->inExtrude  = FALSE;
			ep->inBevel  = FALSE;

		// Set up spinners
			spin = GetISpinner(GetDlgItem(hDlg,IDC_EP_EXTRUDESPINNER));
			spin->SetLimits(-9999999, 9999999, FALSE);
			spin->LinkToEdit (GetDlgItem (hDlg,IDC_EP_EXTRUDEAMOUNT), EDITTYPE_UNIVERSE);
			ReleaseISpinner (spin);

			spin = GetISpinner(GetDlgItem(hDlg,IDC_EP_OUTLINESPINNER));
			spin->SetLimits(-9999999, 9999999, FALSE);
			spin->LinkToEdit (GetDlgItem (hDlg,IDC_EP_OUTLINEAMOUNT), EDITTYPE_UNIVERSE);
			ReleaseISpinner (spin);


			ebut = GetICustButton(GetDlgItem(hDlg,IDC_EP_EXTRUDE));
			ebut->SetType(CBT_CHECK);
			ebut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(ebut);

			ebut = GetICustButton(GetDlgItem(hDlg,IDC_EP_BEVEL));
			ebut->SetType(CBT_CHECK);
			ebut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(ebut);

			ebut = GetICustButton(GetDlgItem(hDlg,IDC_BIND));
			ebut->SetType(CBT_CHECK);
			ebut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(ebut);


			ep->matSpin = SetupIntSpinner(hDlg,IDC_MAT_IDSPIN,IDC_MAT_ID,1,MAX_MATID,0);
		 	ep->SetOpsDlgEnables();
			return TRUE;
			}

		case WM_DESTROY:
			if( ep->weldSpin ) {
				ReleaseISpinner(ep->weldSpin);
				ep->weldSpin = NULL;
				}
			if( ep->stepsSpin ) {
				ReleaseISpinner(ep->stepsSpin);
				ep->stepsSpin = NULL;
				}
//3-18-99 to suport render steps and removal of the mental tesselator
			if( ep->stepsRenderSpin ) {
				ReleaseISpinner(ep->stepsRenderSpin);
				ep->stepsRenderSpin = NULL;
				}

			// Don't leave in one of our modes!
			ep->ip->ClearPickMode();
			CancelEditPatchModes(ep->ip);
			ep->ip->UnRegisterDeleteUser(&pDel);
			ep->ip->GetRightClickMenuManager()->Unregister(&pMenu);
			return FALSE;
		
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_STEPSSPINNER:
					ep->SetMeshSteps(ep->stepsSpin->GetIVal());
					ep->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
					ep->ip->RedrawViews(ep->ip->GetTime(),REDRAW_NORMAL);
					break;
				case IDC_STEPSRENDERSPINNER:
					ep->SetMeshStepsRender(ep->stepsRenderSpin->GetIVal());
					break;

				case IDC_THRESHSPINNER:
					weldThreshold = ep->weldSpin->GetFVal();
					break;
				case IDC_EP_EXTRUDESPINNER:
					{
					bool enterKey;
					enterKey = FALSE;
					if (!HIWORD(wParam) && !ep->inExtrude) {
						enterKey = TRUE;
						ep->BeginExtrude(ep->ip->GetTime());
						}
					BOOL ln = IsDlgButtonChecked(hDlg,IDC_EM_EXTYPE_B);
					spin = GetISpinner(GetDlgItem(hDlg,IDC_EP_EXTRUDESPINNER));

					ep->Extrude (ep->ip->GetTime(),spin->GetFVal(),ln);
					if (enterKey) {
						ep->EndExtrude (ep->ip->GetTime(),TRUE);
						spin = GetISpinner(GetDlgItem(hDlg,IDC_EP_EXTRUDESPINNER));
						if (spin) {
							spin->SetValue(0,FALSE);
							ReleaseISpinner(spin);
							}

						ep->ip->RedrawViews (ep->ip->GetTime(), REDRAW_END);
						} else {
						ep->ip->RedrawViews (ep->ip->GetTime(),REDRAW_INTERACTIVE);
						}
					break;
					}
				case IDC_EP_OUTLINESPINNER:
					{
					bool enterKey;
					enterKey = FALSE;
					if (!HIWORD(wParam) && !ep->inBevel) {
						enterKey = TRUE;
						ep->BeginBevel (ep->ip->GetTime ());
						}
					int sm =0;
					int sm2 = 0;
					if (IsDlgButtonChecked(hDlg,IDC_EP_SM_SMOOTH)) sm = 0;					
					else if (IsDlgButtonChecked(hDlg,IDC_EP_SM_SMOOTH2)) sm = 1;					
					else if (IsDlgButtonChecked(hDlg,IDC_EP_SM_SMOOTH3)) sm = 2;					

					if (IsDlgButtonChecked(hDlg,IDC_EP_SM_SMOOTH4)) sm2 = 0;					
					else if (IsDlgButtonChecked(hDlg,IDC_EP_SM_SMOOTH5)) sm2 = 1;					
					else if (IsDlgButtonChecked(hDlg,IDC_EP_SM_SMOOTH6)) sm2 = 2;					

					spin = GetISpinner(GetDlgItem(hDlg,IDC_EP_OUTLINESPINNER));
					ep->Bevel (ep->ip->GetTime (), spin->GetFVal (),sm,sm2);
					if (enterKey) {
						ep->EndBevel (ep->ip->GetTime (), TRUE);
						spin = GetISpinner(GetDlgItem(hDlg,IDC_EP_OUTLINESPINNER));
						if (spin) {
							spin->SetValue(0,FALSE);
							ReleaseISpinner(spin);
							}

						ep->ip->RedrawViews (ep->ip->GetTime(), REDRAW_END);
						} else {
						ep->ip->RedrawViews (ep->ip->GetTime(),REDRAW_INTERACTIVE);
						}
					break;
					}

				}
			break;
		case CC_SPINNER_BUTTONDOWN:
			switch (LOWORD(wParam)) {
			case IDC_EP_EXTRUDESPINNER:
				ep->BeginExtrude (ep->ip->GetTime());
				break;
			case IDC_EP_OUTLINESPINNER:
				ep->BeginBevel (ep->ip->GetTime ());
				break;
			}
			break;

		case CC_SPINNER_BUTTONUP:
			switch( LOWORD(wParam) ) {
				case IDC_EP_EXTRUDESPINNER:
					ep->EndExtrude (ep->ip->GetTime(), HIWORD(wParam));
					spin = GetISpinner(GetDlgItem(hDlg,IDC_EP_EXTRUDESPINNER));
					if (spin) {
						spin->SetValue(0,FALSE);
						ReleaseISpinner(spin);
						}

					ep->ip->RedrawViews (ep->ip->GetTime(),REDRAW_END);
					break;
				case IDC_EP_OUTLINESPINNER:
					ep->EndBevel (ep->ip->GetTime(), HIWORD(wParam));
					spin = GetISpinner(GetDlgItem(hDlg,IDC_EP_OUTLINESPINNER));
					if (spin) {
						spin->SetValue(0,FALSE);
						ReleaseISpinner(spin);
						}

					ep->ip->RedrawViews (ep->ip->GetTime(),REDRAW_END);
					break;


				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			ep->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;		
		
		case WM_COMMAND:			
			switch ( LOWORD(wParam) ) {				
				// Subdivision
//watje 3-18-99
				case IDC_SHOW_INTERIOR_FACES:
						ep->SetShowInterior(IsDlgButtonChecked(hDlg, IDC_SHOW_INTERIOR_FACES));
//						ep->InvalidateMesh();
//						ep->NotifyDependents(FOREVER, PART_TOPO, REFMSG_CHANGE);
//						ep->ip->RedrawViews (ep->ip->GetTime(),REDRAW_END);
						break;

//watje 12-10-98
				case IDC_HIDE:
					ep->DoHide(ep->GetSubobjectLevel());
					break;
				case IDC_UNHIDE:
					ep->DoUnHide();
					break;
				case IDC_BIND:
//			ep->DoAddHook();
					if (ep->ip->GetCommandMode()==ep->bindMode)
						ep->ip->SetStdCommandMode(CID_OBJMOVE);
					else ep->ip->SetCommandMode(ep->bindMode);
					break;

					break;
				case IDC_UNBIND:
					ep->DoRemoveHook();
					break;
//extrude and bevel stuff
//watje 12-10-98
				case IDC_EP_SM_SMOOTH:
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH2, FALSE);
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH3, FALSE);
					break;
				case IDC_EP_SM_SMOOTH2:
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH, FALSE);
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH3, FALSE);
					break;
				case IDC_EP_SM_SMOOTH3:
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH2, FALSE);
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH, FALSE);
					break;

				case IDC_EP_SM_SMOOTH4:
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH5, FALSE);
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH6, FALSE);
					break;
				case IDC_EP_SM_SMOOTH5:
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH4, FALSE);
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH6, FALSE);
					break;
				case IDC_EP_SM_SMOOTH6:
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH4, FALSE);
					CheckDlgButton( hDlg, IDC_EP_SM_SMOOTH5, FALSE);
					break;


				case IDC_EP_EXTRUDE:
					if (ep->ip->GetCommandMode()==ep->extrudeMode)
						ep->ip->SetStdCommandMode(CID_OBJMOVE);
					else ep->ip->SetCommandMode(ep->extrudeMode);
					break;
				case IDC_EP_BEVEL:
					if (ep->ip->GetCommandMode()==ep->bevelMode)
						ep->ip->SetStdCommandMode(CID_OBJMOVE);
					else ep->ip->SetCommandMode(ep->bevelMode);
					break;


				case IDC_SUBDIVIDE:
					ep->DoSubdivide(ep->GetSubobjectLevel());
					break;
				case IDC_PROPAGATE:
					ep->SetPropagate(IsDlgButtonChecked(hDlg, IDC_PROPAGATE));
					break;
				// Topology
				case IDC_ADDTRI:
					if(ep->GetSubobjectLevel() == PO_EDGE)
						ep->DoPatchAdd(PATCH_TRI);
					break;
				case IDC_ADDQUAD:
					if(ep->GetSubobjectLevel() == PO_EDGE)
						ep->DoPatchAdd(PATCH_QUAD);
					break;
				case IDC_WELD:
					ep->DoVertWeld();
					break;
				case IDC_DETACH:
					ep->DoPatchDetach(patchDetachCopy, patchDetachReorient);
					break;
				case IDC_DETACHCOPY:
					patchDetachCopy = IsDlgButtonChecked( hDlg, IDC_DETACHCOPY);
					break;
				case IDC_DETACHREORIENT:
					patchDetachReorient = IsDlgButtonChecked( hDlg, IDC_DETACHREORIENT);
					break;
				case IDC_ATTACH: {
					ModContextList mcList;
					INodeTab nodes;
					// If the mode is on, turn it off and bail
					if (ep->ip->GetCommandMode()->ID() == CID_STDPICK) {
						ep->ip->SetStdCommandMode(CID_OBJMOVE);
						return FALSE;
						}
					// Want to turn on the mode.  Make sure we're valid first
					ep->ip->GetModContexts(mcList,nodes);
					ep->pickCB.ep = ep;
					ep->ip->SetPickMode(&ep->pickCB);
					nodes.DisposeTemporary();
					break;
					}
				case IDC_ATTACHREORIENT:
					attachReorient = IsDlgButtonChecked( hDlg, IDC_ATTACHREORIENT);
					break;
				case IDC_PATCH_DELETE:
					ep->DoDeleteSelected();
					break;
				}
			break;
		}
	
	return FALSE;
	}

BOOL CALLBACK PatchSurfDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
	{
	EditPatchMod *ep = (EditPatchMod *)GetWindowLong( hDlg, GWL_USERDATA );
	if ( !ep && message != WM_INITDIALOG ) return FALSE;
	
	switch ( message ) {
		case WM_INITDIALOG: {

		 	ep = (EditPatchMod *)lParam;
		 	ep->hSurfPanel = hDlg;
			for (int i=IDC_SMOOTH_GRP1; i<IDC_SMOOTH_GRP1+32; i++)
				SendMessage(GetDlgItem(hDlg,i),CC_COMMAND,CC_CMD_SET_TYPE,CBT_CHECK);
			SetWindowLong( hDlg, GWL_USERDATA, (LONG)ep );		 	
			ep->matSpin = SetupIntSpinner(hDlg,IDC_MAT_IDSPIN,IDC_MAT_ID,1,MAX_MATID,0);
		 	ep->SetSurfDlgEnables();
			return TRUE;
			}

		case WM_DESTROY:
			if( ep->matSpin ) {
				ReleaseISpinner(ep->matSpin);
				ep->matSpin = NULL;
				}
			return FALSE;
		
		case CC_SPINNER_CHANGE:
			switch ( LOWORD(wParam) ) {
				case IDC_MAT_IDSPIN: 
					if(HIWORD(wParam))
						break;		// No interactive action
					ep->SetSelMatIndex(ep->matSpin->GetIVal()-1);
					break;
				}
			break;

		case CC_SPINNER_BUTTONUP:
			switch( LOWORD(wParam) ) {
				case IDC_MAT_IDSPIN:
					ep->SetSelMatIndex(ep->matSpin->GetIVal()-1);
					ep->ip->RedrawViews(ep->ip->GetTime(),REDRAW_END);
					break;
				}
			break;

		case WM_PAINT:
			if (!ep->patchUIValid) {
				// Material index
				int mat = ep->GetSelMatIndex();
				if (mat == -1) {
					ep->matSpin->SetIndeterminate(TRUE);
				} else {
					ep->matSpin->SetIndeterminate(FALSE);
					ep->matSpin->SetValue(mat+1,FALSE);
					}
				// Smoothing groups
				DWORD invalid, bits;
				bits = ep->GetSelSmoothBits(invalid);
				SetSmoothButtonState(hDlg,bits,invalid);

				ep->patchUIValid = TRUE;
				}
			return FALSE;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:   			
   			ep->ip->RollupMouseMessage(hDlg,message,wParam,lParam);
			return FALSE;		
		
		case WM_COMMAND:			
			if (LOWORD(wParam)>=IDC_SMOOTH_GRP1 &&
				LOWORD(wParam)<=IDC_SMOOTH_GRP32) {
				ICustButton *iBut = GetICustB