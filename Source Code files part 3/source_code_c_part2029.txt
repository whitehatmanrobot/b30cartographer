   /// <summary>
        /// Gets or sets the leaderboard server used during LTC file creation.
        /// </summary>
        public string LeaderboardServer
        {
            get { return _lbServer; }
            set { _lbServer = value; }
        }

        /// <summary>
        /// Gets or sets the semi-colon delimited list of match servers used during LTC 
        /// file creation.
        /// </summary>
        public string MatchServers
        {
            get { return _matchServers; }
            set { _matchServers = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of LiveTitle.
        /// </summary>
        public string Output
        {
            get { return _liveTitleProcess.Output; }
        }

        /// <summary>
        /// Exposes the Execution Timeout value for the underlying Process wrapper.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _liveTitleProcess.ExecutionTimeout; }
            set { _liveTitleProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Runs LiveTitle to create an LTC file for an Xbox 360 title.
        /// </summary>
        public void CreateXbox360LTCFile()
        {
            CreateXbox360LTCFile(0, 0);
        }

        /// <summary>
        /// Runs LiveTitle with a title id and a disc id to create an LTC file for an Xbox 360 title.
        /// </summary>
        /// <param name="titleId">Title ID to specify with the /titleid parameter. Optional.</param>
        /// <param name="discId">Disc ID to specify with the /discid parameter. Optional.</param>
        public void CreateXbox360LTCFile(uint titleId, uint discId)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();
            
            arguments.AppendFormat("/livetitledefault /xlastpath:{0} /lbs:{1} /matchsvr:{2}",
                _xlastPath, _lbServer, _matchServers);
            if (titleId != 0)
            {
                arguments.AppendFormat(" /titleid:0x{0:x}", titleId);
            }

            if (discId != 0)
            {
                arguments.AppendFormat(" /discid:0x{0:x}", discId);
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _ltcPath = GetLTCPath(_liveTitleProcess.Output);
            }
            else
            {
                throw new LiveTitleException("LiveTitle failed to create the LTC file.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// DeployXbox360Title will run LiveTitle with the /deploy command-line argument.  
        /// If the
        /// LTCPath property does not point to an existing LTC file, then 
        /// CreateXbox360LTCFile
        /// will be called first to generate the LTC file before trying to deploy.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="deployImages">
        /// Flag indicating whether the /images argument should appear on the command 
        /// line.
        /// It is highly recommended that this be set to True for initial deployments.
        /// </param>
        /// <param name="contentUpdate">
        /// Flag indicating whether the /contentupdate argument should be added to the 
        /// command line.
        /// </param>
        /// <param name="version">
        /// Initial version of the title.
        /// </param>
        public void DeployXbox360Title(uint titleId, bool deployImages, bool contentUpdate, uint version)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();
            
            // Make sure the LTC file exists - if not, create one
            if (!File.Exists(_ltcPath))
            {
                CreateXbox360LTCFile(0, 0);
            }

            arguments.AppendFormat("/deploy /xlastpath:{0} /ltcpath:{1}", _xlastPath, _ltcPath);
            if (deployImages)
            {
                arguments.Append(" /images");
            }
            if (contentUpdate)
            {
                arguments.Append(" /contentupdate");
            }
            arguments.AppendFormat(" /version:0x{0:X8}", version);

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new LiveTitleException("Xbox 360 Title deployment failed.", _liveTitleProcess.Output);
            }

            // Validate the data has made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 title without the optional /version parameter.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="deployImages">Images parameter flag</param>
        /// <param name="contentUpdate">Content Update parameter flag</param>
        public void DeployXbox360Title(uint titleId, bool deployImages, bool contentUpdate)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            // Make sure the LTC file exists - if not, create one
            if (!File.Exists(_ltcPath))
            {
                CreateXbox360LTCFile(0, 0);
            }

            arguments.AppendFormat("/deploy /xlastpath:{0} /ltcpath:{1}", _xlastPath, _ltcPath);
            if (deployImages)
            {
                arguments.Append(" /images");
            }
            if (contentUpdate)
            {
                arguments.Append(" /contentupdate");
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new LiveTitleException("Xbox 360 Title deployment failed.", _liveTitleProcess.Output);
            }

            // Validate the data has made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 title with images.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        public void DeployXbox360Title(uint titleId)
        {
            DeployXbox360Title(titleId, true, false);
        }

        /// <summary>
        /// Creates an LTC file for an Xbox1 title.
        /// </summary>
        public void CreateXbox1LTCFile()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/xboxdefault /xboxpath:{0} /lbs:{1}", _xboxPath, _lbServer);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }

            if (_matchServers != null && _matchServers.Length > 0)
            {
                arguments.AppendFormat(" /matchsvr:{0}", _matchServers);
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _ltcPath = GetLTCPath(_liveTitleProcess.Output);
            }
            else
            {
                throw new LiveTitleException("LiveTitle failed to create the LTC file.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Deploys an Xbox1 title, creating the default LTC file, if needed.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        public void DeployXbox1Title(uint titleId)
        {
            if (!File.Exists(_ltcPath))
            {
                CreateXbox1LTCFile();
            }

            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deployxbox /xboxpath:{0} /ltcpath:{1}", _xboxPath, _ltcPath);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }
            if (_xmsPath.Length > 0)
            {
                arguments.AppendFormat(" /xmspath:{0}", _xmsPath);
            }

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Xbox1 title deployment failed.", _liveTitleProcess.Output);
            }

            // Verify the data made it into NPDB
            ValidateTitleData(titleId);
        }
        public void DeployXbox1Title(uint titleId, uint version)
        {
            if (!File.Exists(_ltcPath))
            {
                CreateXbox1LTCFile();
            }

            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deployxbox /xboxpath:{0} /ltcpath:{1}", _xboxPath, _ltcPath);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }
            if (_xmsPath.Length > 0)
            {
                arguments.AppendFormat(" /xmspath:{0}", _xmsPath);
            }
            arguments.AppendFormat(" /version:0x{0:X8}", version);

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Xbox1 title deployment failed.", _liveTitleProcess.Output);
            }

            // Verify the data made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 Marketplace-only title.
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <param name="images">
        /// Flag indicating whether the /images parameter should appear on the command line.
        /// </param>
        public void DeployMarketplaceOnlyTitle(uint titleId, bool images)
        {
            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deploy /marketplacepath:{0}", _marketplacePath);
            if (images)
            {
                arguments.Append(" /images");
            }

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Marketplace-only title deployment failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Locks the game configuration for an Xbox 360 title.
        /// </summary>
        public void LockTitle()
        {
            if (_liveTitleProcess.Run(String.Format("/lock /xlastpath:{0}", _xlastPath)) != 0)
            {
                throw new LiveTitleException("Locking " + _xlastPath + " failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Reports the existing versions for the specified title id.
        /// </summary>
        /// <param name="titleId">The title id</param>
        /// <returns>An array of version strings in the form "base,update,beta"</returns>
        public string [] ReportTitleVersion(uint titleId)
        {
            string [] baseVersions = null;
            Regex r = new Regex(titleId.ToString() + "( )+[0-9]+( )+[0-9]+( )+[0-9]+");
            int i = 0;

            if (_liveTitleProcess.Run(String.Format("/reportver /titleid:0x{0:X}", titleId)) == 0)
            {
                MatchCollection matches = r.Matches(_liveTitleProcess.Output);
                baseVersions = new string[matches.Count];
                foreach (Match row in matches)
                {
                    string[] version = row.Value.Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    baseVersions[i++] = String.Format("{0}:{1},{2},{3}", version[0], version[1], version[2], version[3]);
                }
            }
            else
            {
                throw new LiveTitleException("Version reporting failed.", _liveTitleProcess.Output);
            }

            return baseVersions;
        }

        /// <summary>
        /// Adds a base version entry to UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">New base version to add for this title</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public void AddTitleBaseVersion(uint titleId, uint baseVersion, ConsoleTypeEnum consoleType)
        {
            if (_liveTitleProcess.Run(String.Format("/addbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, baseVersion, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Adding a base version failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Deletes a base version entry from UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">Base version to remove</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public void DeleteTitleBaseVersion(uint titleId, uint baseVersion, ConsoleTypeEnum consoleType)
        {
            if (_liveTitleProcess.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, baseVersion, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Adds a base version entry to UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">New base version to add for this title</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public static void AddBaseVersion(uint titleId, uint version, ConsoleTypeEnum consoleType)
        {
            ProcessWrapper liveTitle = new ProcessWrapper("LiveTitle", LiveTitle.DefaultLiveTitlePath);
            if (liveTitle.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, version, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", liveTitle.Output);
            }
        }

        /// <summary>
        /// Deletes a base version entry from UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">Base version to remove</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public static void DeleteBaseVersion(uint titleId, uint version, ConsoleTypeEnum consoleType)
        {
            ProcessWrapper liveTitle = new ProcessWrapper("LiveTitle", LiveTitle.DefaultLiveTitlePath);
            if (liveTitle.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, version, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", liveTitle.Output);
            }
        }

        /// <summary>
        /// Props a title.  If no path is specified it will be copied from titlevault.
        /// </summary>
        public static void PropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType)
        {
            PropTitle(titleID, version, clientType, null);
        }
        public static void PropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType, string filePath)
        {
            //fix path
            string titleStringNo0x = String.Format("{0:X8}", titleID);

            if (filePath == null || filePath.Length == 0)
            {
                // Retrieve the path to the current environment's Titlevault
                filePath = Config.GetSetting(Setting.titlevault_root);
                if (filePath == null || filePath.Length == 0)
                {
                    throw new LiveTitleException("Unable to get the path to the TitleVault in the " + Global.CurrentEnvironment.Environment + " environment.");
                }
                filePath = Path.Combine(filePath, titleStringNo0x);
            }

            // Check the existence of this title's directory in Titlevault
            if (!Directory.Exists(filePath))
            {
                throw new LiveTitleException("No files exist in the Titlevault for title id 0x" + titleStringNo0x);
            }

            // Copy the title files to a local temp directory (because you're not allowed to prop from Titlevault)
            string tempTitlePath = "LiveTitleTempFiles\\title\\" + titleStringNo0x + "\\";
            System.IO.Directory.CreateDirectory(tempTitlePath);
            int numCopied = 0;
            foreach (string fname in System.IO.Directory.GetFiles(filePath))
            {
                string baseFName = System.IO.Path.GetFileName(fname);
                string srcFile = filePath + "\\" + baseFName;
                string dstFile = tempTitlePath + baseFName;
                //Global.RO.Debug("copying file: "+srcFile+" TO "+dstFile);
                System.IO.File.Copy(srcFile, dstFile, true);
                ++numCopied;
            }
            if (numCopied == 0)
            {
                throw new LiveTitleException("Could not find files for title " + titleStringNo0x + " to prop from " + filePath);
            }
            else
            {
                Global.RO.Debug("Copied " + numCopied + " files for title " + titleStringNo0x + " to a local temp store.");
            }

            //deploy it
            LiveTitle lt = new LiveTitle();
            lt.LTCPath = tempTitlePath + titleStringNo0x + ".ltc";
            lt.XlastPath = tempTitlePath + titleStringNo0x + ".xlast";
            //lt.XSCPath=tempTitlePath+titleStringNo0x+".xsc";
            lt.XBOXPath = tempTitlePath + titleStringNo0x + ".xbox";
            lt.XMSPath = tempTitlePath + titleStringNo0x + ".xms";

            if (clientType == AuthContext.ClientTypes.Xenon)
            {
                lt.DeployXbox360Title(titleID, true, true, version);
            }
            else if (clientType == AuthContext.ClientTypes.Xbox)
            {
                lt.DeployXbox1Title(titleID, version);
            }
            else if (clientType == AuthContext.ClientTypes.Panorama)
            {
                lt.DeployXbox360Title(titleID, true, true, version);
            }
            else
            {
                throw new LiveTitleException("Unhandled platform type specified when trying to deploy title " + titleStringNo0x);
            }

            //
            Global.RO.Debug("Propped title 0x" + titleStringNo0x + " version " + version + ".");
        }

        /// <summary>
        /// Checks if a title is propped.
        /// </summary>
        public static bool CheckIfTitleIsPropped(uint titleID)
        {
            bool isPropped=false;
            try
            {
                string query="select count(*) from t_titles WHERE i_title_id="+(int)titleID;
                int rows=(int)UodbWS.ExecuteSQLSelectCount(query);
                if (rows!=0) isPropped=true;
            }
            catch (Exception e)
            {
                Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check title "+titleID+": "+e.Message+"\nWill assume this indicates that it is not propped.");
            }
            return isPropped;
        }
        public static bool CheckIfTitleIsPropped(uint titleID, uint version)
        {
            //see if the title is there at all
            bool isPropped=CheckIfTitleIsPropped(titleID);            

            //if it is, is this version propped?
            if (isPropped)
            {
                try
                {
                    string query="select count(*) from t_title_versions WHERE i_title_id="+(int)titleID+" and i_base_version="+(int)version;
                    int rows=(int)UodbWS.ExecuteSQLSelectCount(query);
                    if (rows==0) isPropped=false;
                }
                catch (Exception e)
                {
                    Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check version "+version+" of title "+titleID+": "+e.Message+"\nWill assume this indicates that it is not propped.");
                    isPropped=false;
                }
            }

            return isPropped;
        }

        /// <summary>
        /// Checks if a title is propped, and if not, props it.  If no path is specified it will be copied from stressnet titlevault.
        /// </summary>
        public static void CheckAndPropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType, string filePath)
        {
            if (!CheckIfTitleIsPropped(titleID,version))
            {
                Global.RO.Debug("Title 0x{0:X8} version "+version+" is not propped.  Will try to prop it.", titleID);
                PropTitle(titleID,version,clientType,filePath);
            }
            else
            {
                Global.RO.Debug("Title 0x{0:X8} version "+version+" is already propped.", titleID);
            }
        }

        /// <summary>
        /// Performs basic validation that the title deployment succeeded.
        /// </summary>
        private void ValidateTitleData(uint titleId)
        {
            NpdbUtility npdb = new NpdbUtility();
            LiveTitleConfigRow ltcRow;
            GameConfigRow gcRow;

            npdb.ConnectToServer();
            try
            {
                npdb.GetGameConfig(titleId, out gcRow);
                ltcRow = npdb.GetLiveTitleConfig(titleId);

                if (gcRow == null || ltcRow == null)
                {
                    throw new LiveTitleException("Unable to get title data from NPDB.", _liveTitleProcess.Output);
                }
            }
            catch (DatabaseException dEx)
            {
                throw new LiveTitleException("Unable to verify title data.", _liveTitleProcess.Output, dEx);
            }
            finally
            {
                npdb.Close();
            }
        }

        private string GetLTCPath(string liveTitleOutput)
        {
            Regex reg = new Regex("[0-9a-fA-F]{8}_ltc.xml");
            Match match = reg.Match(liveTitleOutput);
            string ltcPath = "";

            if (match.Success)
            {
                // The LTC file is created in the current directory

                ltcPath = Path.Combine(_liveTitleProcess.WorkingDirectory, match.Value);
                if (!File.Exists(ltcPath))
                {
                    throw new LiveTitleException("Unable to find the LTC file at " + ltcPath);
                }
            }
            else
            {
                throw new LiveTitleException("Unable to find the LTC file name in the LiveTitle output.",
                    liveTitleOutput);
            }

            return ltcPath;
        }
    }

    public class LiveTitleException : ProcessException
    {
        public LiveTitleException() : base("LiveTitle") {}
        public LiveTitleException(string message) : base("LiveTitle", message) {}
        public LiveTitleException(string message, Exception innerException) : base("LiveTitle", message, innerException) {}
        public LiveTitleException(string message, string liveTitleOutput) : base("LiveTitle", message, liveTitleOutput) {}
        public LiveTitleException(string message, string liveTitleOutput, Exception innerException) :
            base("LiveTitle", liveTitleOutput, message, innerException) {}

        public override string Message
        {
            get { return string.Format("{0}\r\nLiveTitle Output:\r\n{1}\r\nEnd LiveTitle Output\r\n",
                      base.Message, base.ProcessOutput); }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\spac.cs ===
using System;
using System.IO;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    public enum SPACReturnCode
    {
        Success = 0,
        BadUsage,
        NonFatalError,
        FatalError
    };

	/// <summary>
	/// Utility class that runs the SPA Compiler (SPAC) tool.
	/// </summary>
	/// <remarks>
	/// Unlike many of the other tools, SPAC supports multiple return codes. Therefore, all the
	/// methods that execute SPAC will not raise exceptions on failure, but rather simply return
	/// the exit code from the tool itself. It is the caller's responsibility to check this code
	/// and take the appropriate action.
	/// </remarks>
	public class SPAC
	{
        const string DefaultSpacPath = @"D:\webroot\xbltools";

        private ProcessWrapper _spacProcess;
        private string _xlastPath;
        private string _headerFile;
        private string _spaFile;
        private string _configOverrideFile;
        private bool _noLogo;
        private bool _verbose;
        private bool _noSpa;
        private bool _noHeader;
        private string _unCompileOutFile;

        /// <summary>
        /// Creates a SPAC object and initializes the process wrapper to the default SPAC path.
        /// </summary>
		public SPAC()
		{
            _spacProcess = new ProcessWrapper("SPAC", Path.Combine(DefaultSpacPath, "spac.exe"));

            // Set the values for the default command line
            _noLogo = true;
            _verbose = true;
            _noSpa = false;
            _noHeader = false;
		}

        /// <summary>
        /// Gets or sets the full path of the SPAC executable.
        /// </summary>
        public string SpacPath
        {
            get { return _spacProcess.ExecutablePath; }
            set
            {
                _spacProcess.ExecutablePath = Path.GetFullPath(value);
                _spacProcess.WorkingDirectory = Path.GetDirectoryName(value);
            }
        }

        /// <summary>
        /// Gets or sets the name of the working directory under which SPAC will be run.
        /// </summary>
        public string WorkingDirectory
        {
            get { return _spacProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _spacProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _spacProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the name of the XLAST file to compile.
        /// </summary>
        public string XlastPath
        {
            get { return _xlastPath; }
            set
            {
                if (value != null)
                {
                    _xlastPath = Path.GetFullPath(value);
                }
                else
                {
                    _xlastPath = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of the header file that SPAC outputs when compiling an XLAST file.
        /// </summary>
        public string HeaderFile
        {
            get { return _headerFile; }
            set
            {
                if (value != null)
                {
                    _headerFile = Path.GetFullPath(value);
                }
                else
                {
                    _headerFile = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of the SPA file that SPAC outputs when compiling an XLAST file.
        /// </summary>
        public string SpaFile
        {
            get { return _spaFile; }
            set
            {
                if (value != null)
                {
                    _spaFile = Path.GetFullPath(value);
                }
                else
                {
                    _spaFile = null;  
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of a file containing configuration overrides.
        /// </summary>
        public string ConfigOverrideFile
        {
            get { return _configOverrideFile; }
            set
            {
                if (value != null)
                {
                    _configOverrideFile = Path.GetFullPath(value);
                }
                else
                {
                    _configOverrideFile = null;
                }
            }
        }

		
        /// <summary>
        /// Gets or sets the name of the decompiled output file 
        /// </summary>
        public string UncompileOutputFile
        {
            get { return _unCompileOutFile; }
            set
            {
                if (value != null)
                {
                    _unCompileOutFile = Path.GetFullPath(value);
                }
                else
                {
                    _unCompileOutFile = null;
                }
            }
        }


        /// <summary>
        /// Gets the output text of SPAC.
        /// </summary>
        public string Output
        {
            get { return _spacProcess.Output; }
        }

        /// <summary>
        /// Gets or sets the default value for the -nologo option.
        /// </summary>
        public bool NoLogo
        {
            get { return _noLogo; }
            set { _noLogo = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -verbose option.
        /// </summary>
        public bool Verbose
        {
            get { return _verbose; }
            set { _verbose = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -nospa option.
        /// </summary>
        public bool NoSpa
        {
            get { return _noSpa; }
            set { _noSpa = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -noh option.
        /// </summary>
        public bool NoHeader
        {
            get { return _noHeader; }
            set { _noHeader = value; }
        }

        /// <summary>
        /// Compiles an XLAST file using the default parameter values.
        /// </summary>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile()
        {
            return Compile(_noLogo, _verbose, _noSpa, _noHeader);
        }

        /// <summary>
        /// Allows the default nospa and noh parameter values to be overridden when compiling an XLAST file.
        /// </summary>
        /// <param name="noSpa">Flag indicating whether or not a SPA file should be generated.</param>
        /// <param name="noHeader">Flag indicating whether or not a SPA.H file should be generated.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile(bool noSpa, bool noHeader)
        {
            return Compile(_noLogo, _verbose, noSpa, noHeader);
        }

        /// <summary>
        /// Allows all the default flag parameter values to be overridden when compiling an XLAST file.
        /// </summary>
        /// <param name="noLogo">Flag indicating whether the copyright message is printed when SPAC is run.</param>
        /// <param name="verbose">Flag specifying whether the compile output should be normal or verbose.</param>
        /// <param name="noSpa">Flag indicating whether or not a SPA file should be generated.</param>
        /// <param name="noHeader">Flag indicating whether or not a SPA.H file should be generated.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile(bool noLogo, bool verbose, bool noSpa, bool noHeader)
        {
            StringBuilder args = new StringBuilder();

            if (noLogo) args.Append("/nologo ");
            if (verbose) args.Append("/verbose ");
            if (noSpa) args.Append("/nospa ");
            if (noHeader) args.Append("/noh ");
            if (_spaFile != null && _spaFile.Length > 0) args.AppendFormat("/o {0} ", _spaFile);
            if (_headerFile != null && _headerFile.Length > 0) args.AppendFormat("/h {0} ", _headerFile);
            if (_configOverrideFile != null && _configOverrideFile.Length > 0) args.AppendFormat("/config {0} ", _configOverrideFile);

            args.Append(_xlastPath);

            return (SPACReturnCode)_spacProcess.Run(args.ToString());
        }

		
        /// <summary>
        /// UnCompiles a SPA file using the default parameter values.
        /// </summary>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode UnCompile()
        {
              StringBuilder args = new StringBuilder();

        	if (_spaFile != null && _spaFile.Length > 0) args.AppendFormat("/u {0} ", _spaFile);
		if (_unCompileOutFile != null && _unCompileOutFile.Length > 0) args.AppendFormat("/o {0}", _unCompileOutFile);
              return (SPACReturnCode)_spacProcess.Run(args.ToString());
        }


        /// <summary>
        /// Executes SPAC to output the XSD file it is using to validate XLAST files.
        /// </summary>
        /// <param name="xsdFile">Name of the XSD file to create.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode OutputXSD(string xsdFile)
        {
            return (SPACReturnCode)_spacProcess.Run("/nologo /xsd " + xsdFile);
        }

        /// <summary>
        /// Reports the version information of a given SPA file.
        /// </summary>
        /// <param name="spaFile">Name of the SPA file for which version information is to be reported.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// 
        /// The version information will be found in the output text.
        /// </returns>
        public SPACReturnCode ReportSPAVersion(string spaFile)
        {
            return (SPACReturnCode)_spacProcess.Run("/nologo /u " + spaFile);
        }
	}
/*
    public class SPACException : ProcessException
    {
        public SPACException() : base("SPAC") {}
        public SPACException(string message) : base("SPAC", message) {}
        public SPACException(string message, Exception innerException) : base("SPAC", message, innerException) {}
        public SPACException(string message, string spacOutput) : base("SPAC", message, spacOutput) {}
        public SPACException(string message, string spacOutput, Exception innerException) :
            base("SPAC", spacOutput, message, innerException) {}

        public override string Message
        {
            get 
            {
                return string.Format("{0}\r\nSPAC Output:\r\n{1}\r\nEnd SPAC Output\r\n",
                      base.Message, base.ProcessOutput);
            }
        }

    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ConfigFiles\XmlOfferFile.cs ===
using System;
using System.Xml;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    /// <summary>
    /// Wrapper for common operations on offer files.
    /// </summary>
    public class XmlOfferFile
    {
        private XmlDocument _offerXml;
        private XmlNamespaceManager _nsmgr;
        public enum platform{xbox1, xbox360};

		/// <summary>
		/// Create a representation of an xml offer file which can be accessed through
		/// XPATH calls.
		/// </summary>
		/// <param name="filename">File to open.</param>
		/// <param name="consoleType">Console type for this xml offer file.  Necessary because
		/// they use different namespaces.</param>
        public XmlOfferFile(string filename, platform consoleType)
        {
            _offerXml = new XmlDocument();
            _offerXml.Load(filename);
            _nsmgr = new XmlNamespaceManager(_offerXml.NameTable);
            if (consoleType == platform.xbox1) {
                _nsmgr.AddNamespace("xbo", "http://www.xboxlive.com/xboxoffer");
            } else if (consoleType == platform.xbox360) {
                _nsmgr.AddNamespace("xbo", "http://www.xboxlive.com/offer");                
            }
        }

		/// <summary>
		/// Returns the contentID of this offer.
		/// </summary>
        public string getContentId() 
        {
            XmlNode contentIdNode;
            XmlElement root = _offerXml.DocumentElement;
            contentIdNode=root.SelectSingleNode("xbo:content/xbo:contentID", _nsmgr);

            return contentIdNode.InnerXml.Substring(2);
        }

	        
		/// <summary>
		/// Returns a nodelist of nodes that match this xpath query.
		/// </summary>
		/// <param name="xpath">XPATH pointing to nodes to select.</param>
		/// <returns>XMLNodeList containing all nodes matched, or null if there are none.</returns>
		public XmlNodeList MultipleQuery(string xpath) {
            XmlNodeList ansList;
            XmlElement root = _offerXml.DocumentElement;
            ansList = root.SelectNodes(xpath, _nsmgr);
            if (ansList.Count == 0) {
                Global.RO.Warn("Warning:Multiple Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }

            return ansList;
		}

		/// <summary>
		/// Returns the first XmlNode that matches the given XPATH.
		/// </summary>
		/// <param name="xpath">XPATH pointing to the node to select.</param>
		/// <returns>XmlNode of selected node, or null if there is no match.</returns>
        public XmlNode ArbitraryXpath(string xpath) {
            XmlNode contentIdNode;
            XmlElement root = _offerXml.DocumentElement;
            contentIdNode=root.SelectSingleNode(xpath, _nsmgr);
            if (contentIdNode == null) {
                Global.RO.Warn("Warning:Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }
            return contentIdNode;
        }

        
		/// <summary>
		/// Takes a node already selected from this offer file, and selects from it again.  Required
		/// here because it needs the namespace manager.
		/// </summary>
		/// <param name="node">Node to select from.</param>
		/// <param name="xpath">XPATH to use relative to this node.</param>
		/// <returns>New XmlNode, relative from the given one.  Returns null if there is no match.</returns>
        public XmlNode RelativeXpath(XmlNode node, string xpath) {
            XmlNode ansNode = node.SelectSingleNode(xpath, _nsmgr);
            if (ansNode == null) {
                Global.RO.Warn("Warning:Relative Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }
            return ansNode;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\Achievements.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public void AddAchievements(XboxLiveSubmissionProject xlast, uint count, uint totalCred)
        {
            ushort credPerAchievment = (ushort)(count > 1 ? totalCred / count : totalCred);

            for (uint i = 1; i <= count; i++)
            {
                bool showUnachieved = (_rnd.Next() % 2) != 0;
                int type = _rnd.Next((int)achievementType.Completion, (int)achievementType.Other + 1);
                int imageId = _rnd.Next(1, 11);

                // Make sure we use up all the cred
                if (i == count)
                {
                    credPerAchievment += (ushort)(totalCred - (credPerAchievment * count));
                }

                AddAchievement(xlast, (achievementType)type, credPerAchievment, string.Format("AchievementImage{0:d02}.png", imageId), showUnachieved);
            }
        }

        public void AddAchievement(XboxLiveSubmissionProject xlast)
        {
            bool showUnachieved = (_rnd.Next() % 2) != 0;
            int type = _rnd.Next((int)achievementType.Completion, (int)achievementType.Other + 1);
            int imageId = _rnd.Next(1, 11);

            AddAchievement(xlast, (achievementType)type, 0, String.Format("AchievementImage{0:d02}.png", imageId), showUnachieved);
        }

        public void AddAchievement(XboxLiveSubmissionProject xlast, achievementType type, ushort cred, string imagePath, bool showUnachieved)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Achievement ach = new Achievement();
            ach.clsid = AchievementCLSID;
            ach.id = xlast.GameConfigProject.Achievements.nextId;
            ach.achievementType = type;
            ach.cred = cred;
            ach.friendlyName = "Achievement" + ach.id.ToString("d3");
            ach.imageId = AddImage(xlast, imagePath);
            ach.titleStringId = AddString(xlast, ach.friendlyName + " Title String");
            ach.descriptionStringId = AddString(xlast, ach.friendlyName + " Description String");
            ach.showUnachieved = showUnachieved;
            if (showUnachieved)
            {
                ach.unachievedStringId = AddString(xlast, ach.friendlyName + " Unachieved String");
            }
            xlast.GameConfigProject.Achievements.Add(ach);
            xlast.GameConfigProject.Achievements.nextId++;
        }

        private void CreateAchievements(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Achievements.clsid = AchievementsCLSID;
            xlast.GameConfigProject.Achievements.nextId = 1;

            // If this is an Arcade title, we must provide exactly 12 Achievements with 200 cred
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                AddAchievements(xlast, 12, 200);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\Contexts.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const string GAME_TYPE_CONTEXT_ID = "0x0000800A";

        public void AddContexts(XboxLiveSubmissionProject xlast, int count, int maxValues)
        {
            for (int i = 1; i <= count; i++)
            {
                string id = AddContext(xlast);
                int values = _rnd.Next(1, maxValues + 1);

                for (int j = 1; j <= values; j++)
                {
                    AddContextValue(xlast, id, string.Format("Context{0:d3}Value{1:d3}",i, j));
                }
                if (values > 1)
                {
                    SetContextDefaultValue(xlast, id, (ushort)_rnd.Next(0, values));
                }
                else
                {
                    SetContextDefaultValue(xlast, id, 0);
                }
            }
        }

        public string AddContext(XboxLiveSubmissionProject xlast)
        {
            Context ctx = new Context();
            uint id = UInt32.Parse(xlast.GameConfigProject.Contexts.nextId.Substring(2), System.Globalization.NumberStyles.HexNumber);

            ctx.clsid = ContextCLSID;
            ctx.id = "0x" + id.ToString("X8");
            ctx.friendlyName = "Context" + id.ToString();
            ctx.stringId = AddString(xlast, ctx.friendlyName + " string.");
            ctx.defaultValue = 0;
            xlast.GameConfigProject.Contexts.Add(ctx);
            xlast.GameConfigProject.Contexts.nextId = "0x" + (id + 1).ToString("X8");
            return ctx.id;
        }

        public void AddContextValue(XboxLiveSubmissionProject xlast, string id, string name)
        {
            Context ctx = GetContext(xlast, id);
            if (ctx != null)
            {
                ContextValue ctxValue = new ContextValue();
                ctxValue.friendlyName = name;
                ctxValue.stringId = AddString(xlast, name + " String.");
                ctxValue.value = (ushort)ctx.Count;
                ctx.Add(ctxValue);
            }
        }

        public void SetContextDefaultValue(XboxLiveSubmissionProject xlast, string id, ushort defaultValue)
        {
            Context ctx = GetContext(xlast, id);
            if (ctx != null)
            {
                ctx.defaultValue = defaultValue;
            }
        }

        private Context GetContext(XboxLiveSubmissionProject xlast, string id)
        {
            foreach (Context ctx in xlast.GameConfigProject.Contexts)
            {
                if (string.Compare(ctx.id, id, true) == 0)
                    return ctx;
            }
            return null;
        }

        private void CreateContexts(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Contexts.clsid = ContextsCLSID;
            xlast.GameConfigProject.Contexts.nextId = "0x00000000";

            Context newCtx = new Context();
            newCtx.clsid = ContextCLSID;
            newCtx.id = GAME_TYPE_CONTEXT_ID;
            newCtx.defaultValue = 0;
            newCtx.friendlyName = "GAME_TYPE";
            newCtx.stringId = (ushort)XLASTDefaultString.X_STRINGID_GAMETYPE;

            ContextValue ctxValue = new ContextValue();
            ctxValue.friendlyName = "RANKED";
            ctxValue.stringId = (ushort)XLASTDefaultString.X_STRINGID_RANKED;
            ctxValue.value = 0;
            newCtx.Add(ctxValue);

            ctxValue = new ContextValue();
            ctxValue.friendlyName = "STANDARD";
            ctxValue.stringId = (ushort)XLASTDefaultString.X_STRINGID_STANDARD;
            ctxValue.value = 1;
            newCtx.Add(ctxValue);

            xlast.GameConfigProject.Contexts.Add(newCtx);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\GameModes.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const string GAME_MODE_ID = "0x0000800B";

        public void AddGameModes(XboxLiveSubmissionProject xlast, int count)
        {
            for (int i = 0; i < count; i++)
            {
                AddGameMode(xlast);
            }
        }

        public void AddGameMode(XboxLiveSubmissionProject xlast, string name, ushort value, byte drawProbability)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            GameMode gameMode = new GameMode();
            gameMode.friendlyName = name;
            gameMode.stringId = AddString(xlast, name + " string");
            gameMode.value = value;
            gameMode.drawProbability = drawProbability;
            xlast.GameConfigProject.GameModes.Add(gameMode);
        }

        public void SetGameModeDefaultValue(XboxLiveSubmissionProject xlast, ushort defaultValue)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GameModes.defaultValue = defaultValue;
        }

        private ushort AddGameMode(XboxLiveSubmissionProject xlast)
        {
            ushort value = (ushort)xlast.GameConfigProject.GameModes.Count;
            byte draw = (byte)_rnd.Next(0, 101);
            AddGameMode(xlast, "GameMode" + value.ToString("d3"), value, draw);
            return value;
        }

        private void CreateGameModes(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GameModes.clsid = GameModesCLSID;
            SetGameModeDefaultValue(xlast, AddGameMode(xlast));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\GamerPictures.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const uint GAMERPIC_SMALL = 0x00010000;
        private const uint GAMERPIC_LARGE = 0x00020000;

        public void AddGamerPicture(XboxLiveSubmissionProject xlast, string smallImage, string largeImage)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            // Make sure the CLSID is set
            if (null == xlast.GameConfigProject.GamerPictures.clsid)
            {
                CreateGamerPictures(xlast);
            }

            Picture gamerPic = new Picture();
            Picture largePic = new Picture();
            uint imageId;

            // Gamer pictures start at ID 2 (for some reason)
            gamerPic.id = (uint)xlast.GameConfigProject.GamerPictures.Count + 2;
            gamerPic.friendlyName = "GamerPic" + (xlast.GameConfigProject.GamerPictures.Count + 2).ToString("d3");

            // Each Gamer Picture consists of two images - small and large
            imageId = GAMERPIC_SMALL | gamerPic.id;
            AddImage(xlast, smallImage, imageId, gamerPic.friendlyName + "_SMALL");

            imageId = GAMERPIC_LARGE | gamerPic.id;
            AddImage(xlast, largeImage, imageId, gamerPic.friendlyName + "_LARGE");

            // Finally add the GamerPic element
            xlast.GameConfigProject.GamerPictures.Add(gamerPic);
        }

        private void CreateGamerPictures(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GamerPictures.clsid = GamerPicturesCLSID;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\Images.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public uint AddImage(XboxLiveSubmissionProject xlast, string imagePath)
        {
            uint id = GetNextImageId(xlast);
            AddImage(xlast, imagePath, id, "Image" + id.ToString("d3"));
            return id;
        }

        public uint AddImage(XboxLiveSubmissionProject xlast, string imagePath, string name)
        {
            uint id = GetNextImageId(xlast);
            AddImage(xlast, imagePath, id, name);
            return id;
        }

        private void AddImage(XboxLiveSubmissionProject xlast, string imagePath, uint id, string friendlyName)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Image newImage = new Image();
            newImage.Path = imagePath;
            newImage.id = id;
            newImage.friendlyName = friendlyName;
            xlast.GameConfigProject.Images.Add(newImage);
        }

        private void CreateImages(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Images.clsid = ImagesCLSID;
            AddImage(xlast, "GameImage.png", 32768, "X_IMAGEID_GAME");
            AddImage(xlast, "GameMarketplaceImage.png", 32772, "X_IMAGEID_GAME_MARKETPLACE");
        }

        private uint GetNextImageId(XboxLiveSubmissionProject xlast)
        {
            uint id = 0;
            foreach (Image img in xlast.GameConfigProject.Images.ImageCollection)
            {
                if (img.id < 32768)
                    id = Math.Max(id, img.id);
            }

            return id + 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ConfigFiles\LiveTitleConfig.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    public enum Generation
    {
        Unknown = 0,
        Xbox,
        Xenon
    }

    public struct LtcDeclarations
    {
        public const string SchemaVersion = "http://www.xboxlive.com/livetitleconfig";
    }

    [XmlType(Namespace=LtcDeclarations.SchemaVersion)]
    [XmlRoot(Namespace=LtcDeclarations.SchemaVersion, IsNullable=false)]
    public class LiveTitleConfig
    {
        public Generation   TitleGeneration;
        public uint         TitleID;
        public bool         AllowCrossPlatformPlay;

        //stats related
        public int          StatsMaxReads;
        public int          StatsMaxWrites;
        public int          StatsMaxLeaderboards;
        public bool         BountyExempt;
        public float        MuSigmaBeta;
        public float        MuSigmaTau;


        //Achievement related
        public int          MinAchievements;
        public int          MaxAchievements;
        public int          MinAchievementsWithCred;
        public int          MaxAchievementsWithCred;
        public int          MinCred;
        public int          MaxCred;
        public int          MaxUniqueAchImages;
        public int          MaxContexts;
        public int          MaxContextValues;

        public int          MaxGamerPictures;
        public int          MaxProperties;
        public int          MaxRichPresenceModes;
        public int          MaxGameModes;
        public bool         TitlePictureRequired;
        public bool         TitleMarketplacePictureRequired;

        //Alternate titleids
        public int          TitleRegion;
        public int          DiscMediaID;
        public int          LiveTitleID;
        public int          AlternateTitleID1;
        public int          AlternateTitleID2;
        public int          AlternateTitleID3;
        public int          AlternateTitleID4;
        public int          Service1;
        public int          Service1AltID;
        public int          Service2;
        public int          Service2AltID;
        public int          Service3;
        public int          Service3AltID;
        public int          Service4;
        public int          Service4AltID;

        public const uint   SkillLBIDBase = 0xfffe0000;
        public const uint   RankedLBIDBase = 0xffff0000;

        // match related
        [XmlElement("MatchServerList", typeof(string))]
        public string       MatchServerList;

        [XmlElement("MatchExpiration", typeof(Int32))]
        public int          MatchExpiration;

        [XmlElement("MatchDeleteDelaySeconds", typeof(Int32))]
        public int MatchDeleteDelaySeconds;

        [XmlElement("MatchSessionLimitJobExists", typeof(Boolean))]
        public bool MatchSessionLimitJobExists;

        [XmlElement("MatchSessionLimitEnabled", typeof(Boolean))]
        public bool MatchSessionLimitEnabled;

        [XmlElement("MatchSessionMaxAvail", typeof(Int32))]
        public int MatchSessionMaxAvail;

        [XmlElement("MatchSessionTruncateLevelAvail", typeof(Int32))]
        public int MatchSessionTruncateLevelAvail;

        [XmlElement("MatchSessionWarnLevelAvail", typeof(Int32))]
        public int MatchSessionWarnLevelAvail;

        [XmlElement("MatchSessionMaxUnavail", typeof(Int32))]
        public int MatchSessionMaxUnavail;

        [XmlElement("MatchSessionTruncateLevelUnavail", typeof(Int32))]
        public int MatchSessionTruncateLevelUnavail;

        [XmlElement("MatchSessionWarnLevelUnavail", typeof(Int32))]
        public int MatchSessionWarnLevelUnavail;

        [XmlElement("MatchSessionCleanupPeriodMinutes", typeof(Int32))]
        public int MatchSessionCleanupPeriodMinutes;

        [XmlElement("MatchSessionCleanupOffsetMinutes", typeof(Int32))]
        public int MatchSessionCleanupOffsetMinutes;

        // Miscellaneous section...
        [XmlElement("clusterid", typeof(string))]
        public string       ClusterId;

        [XmlElement("locale", typeof(string))]
        public string       Locale;

        [XmlElement(ElementName="LeaderboardConfigs", Type=typeof(LeaderboardConfigs), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=LtcDeclarations.SchemaVersion)]
        public LeaderboardConfigs LeaderboardConfigs;

        /// <summary>
        /// Creates a LiveTitleConfig object from an LTC file
        /// </summary>
        /// <param name="ltcFile">Path and name of the LTC file to de-serialize.</param>
        /// <returns>A LiveTitleConfig object that represents the file.</returns>
        public static LiveTitleConfig FromXml(string ltcFile)
        {
            if (ltcFile == null)
            {
                throw new ArgumentNullException("ltcFile");
            }

            if (!File.Exists(ltcFile))
            {
                return null;
            }

            LiveTitleConfig ltc = null;
            StreamReader reader = null;
            try
            {
                reader = new StreamReader(ltcFile);
                ltc = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return ltc;
        }

        /// <summary>
        /// Deserializes LTC XML into a LiveTitleConfig object.
        /// </summary>
        /// <param name="xml">A TextReader object that holds the LTC XML.</param>
        /// <returns>A LiveTitleConfig object that represents the LTC data</returns>
        public static LiveTitleConfig FromXml(TextReader xml)
        {
            if (xml == null)
            {
                return null;
            }

            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            LiveTitleConfig ltc = null;
            try
            {
                xmlReader = new XmlTextReader(xml);
                serializer = new XmlSerializer(typeof(LiveTitleConfig));
                ltc = (serializer.Deserialize(xmlReader) as LiveTitleConfig);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return ltc;
        }

        /// <summary>
        /// Serailizes the LiveTitleConfig object to an LTC file
        /// </summary>
        /// <param name="ltcFile">Path and name of the target LTC file</param>
        public void ToXml(string ltcFile)
        {
            if (ltcFile == null)
            {
                throw new ArgumentNullException("ltcFile");
            }

            /*
             * We need to go through the pain of creating an XmlDocument from
             * the serialized XML stream so that when we can duplicate the
             * format of the LTC file when it's saved from LiveTitle.
             */
            StringWriter sw = new StringWriter();
            XmlDocument doc = new XmlDocument();
            XmlTextWriter xtw = new XmlTextWriter(ltcFile, System.Text.Encoding.Unicode);
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 2;
            xtw.IndentChar = ' ';
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(LiveTitleConfig));
                serializer.Serialize(sw, this);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
            finally
            {
                xtw.Close();
                sw.Close();
            }
        }
    }

    [XmlType(TypeName="LeaderboardConfigs",Namespace=LtcDeclarations.SchemaVersion),Serializable]
    public class LeaderboardConfigs
    {
        [XmlElement(ElementName="LeaderboardConfig",Type=typeof(LeaderboardConfig),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=LtcDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public LeaderboardConfigCollection _leaderboardConfigCollection;

        [XmlIgnore]
        public LeaderboardConfigCollection LeaderboardConfigCollection
        {
            get
            {
                if (_leaderboardConfigCollection == null) _leaderboardConfigCollection = new LeaderboardConfigCollection();
                return _leaderboardConfigCollection;
            }
            set { _leaderboardConfigCollection = value; }
        }

        public LeaderboardConfigs()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class LeaderboardConfigCollection : ArrayList
    {
        public LeaderboardConfig Add(LeaderboardConfig obj)
        {
            base.Add(obj);
            return obj;
        }

        public LeaderboardConfig Add()
        {
            return Add(new LeaderboardConfig());
        }

        public void Insert(int index, LeaderboardConfig obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(LeaderboardConfig obj)
        {
            base.Remove(obj);
        }

        new public LeaderboardConfig this[int index]
        {
            get { return base[index] as LeaderboardConfig; }
            set { base[index] = value; }
        }

        public LeaderboardConfigCollection()
        {
        }
    }

    public class LeaderboardConfig
    {
        [XmlAttribute()]
        public int LeaderboardID;

        [XmlAttribute()]
        public string HostingLbs;

        [XmlAttribute()]
        public bool IsCompetition = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ConfigFiles\XboxConfig.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: xboxConfig.xsd
// Creation Date: 2/24/2006 11:01:59
//--------------------------------------------------------------

using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct XboxDeclarations
	{
		public const string SchemaVersion = "";
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxLocalizedStringCollection : ArrayList
	{
		public XboxLocalizedString Add(XboxLocalizedString obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxLocalizedString Add()
		{
			return Add(new XboxLocalizedString());
		}

		public void Insert(int index, XboxLocalizedString obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxLocalizedString obj)
		{
			base.Remove(obj);
		}

		new public XboxLocalizedString this[int index]
		{
			get { return (XboxLocalizedString) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxTranslationCollection : ArrayList
	{
		public XboxTranslation Add(XboxTranslation obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxTranslation Add()
		{
			return Add(new XboxTranslation());
		}

		public void Insert(int index, XboxTranslation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxTranslation obj)
		{
			base.Remove(obj);
		}

		new public XboxTranslation this[int index]
		{
			get { return (XboxTranslation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxConfigurationCollection : ArrayList
	{
		public XboxConfiguration Add(XboxConfiguration obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxConfiguration Add()
		{
			return Add(new XboxConfiguration());
		}

		public void Insert(int index, XboxConfiguration obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxConfiguration obj)
		{
			base.Remove(obj);
		}

		new public XboxConfiguration this[int index]
		{
			get { return (XboxConfiguration) base[index]; }
			set { base[index] = value; }
		}
	}


    /// <summary>
    /// Root class for deserializing an Xbox 1 configuration file (.XBOX).
    /// </summary>
	[XmlRoot(ElementName="XboxConfiguration",IsNullable=false),Serializable]
	public class XboxConfiguration
	{

		[XmlElement(Type=typeof(XboxGameConfig),ElementName="GameConfig",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxGameConfig _GameConfig;
		
		[XmlIgnore]
		public XboxGameConfig GameConfig
		{
			get
			{
				if (_GameConfig == null) _GameConfig = new XboxGameConfig();		
				return _GameConfig;
			}
			set {_GameConfig = value;}
		}

		[XmlElement(Type=typeof(XboxLocalizedStrings),ElementName="LocalizedStrings",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxLocalizedStrings _LocalizedStrings;
		
		[XmlIgnore]
		public XboxLocalizedStrings LocalizedStrings
		{
			get
			{
				if (_LocalizedStrings == null) _LocalizedStrings = new XboxLocalizedStrings();		
				return _LocalizedStrings;
			}
			set {_LocalizedStrings = value;}
		}

		[XmlElement(ElementName="Bounty",IsNullable=false,DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool _Bounty;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool _BountySpecified;
		
		[XmlIgnore]
		public bool Bounty
		{ 
			get { return _Bounty; }
			set { _Bounty = value; _BountySpecified = true; }
		}

		[XmlElement(Type=typeof(XboxWebdbInfo),ElementName="WebdbInfo",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxWebdbInfo _WebdbInfo;
		
		[XmlIgnore]
		public XboxWebdbInfo WebdbInfo
		{
			get
			{
				if (_WebdbInfo == null) _WebdbInfo = new XboxWebdbInfo();		
				return _WebdbInfo;
			}
			set {_WebdbInfo = value;}
		}

		[XmlElement(Type=typeof(XboxProductInformation),ElementName="ProductInformation",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxProductInformation _ProductInformation;
		
		[XmlIgnore]
		public XboxProductInformation ProductInformation
		{
			get
			{
				if (_ProductInformation == null) _ProductInformation = new XboxProductInformation();		
				return _ProductInformation;
			}
			set {_ProductInformation = value;}
		}

		public XboxConfiguration()
		{
		}

        /// <summary>
        /// Static method to deserialize an XBOX file into a hierarchy of objects.
        /// </summary>
        /// <param name="xboxFile">The name of the XBOX file to deserialize.</param>
        /// <returns>An XboxConfiguration object that describes the XBOX file.</returns>
        public static XboxConfiguration FromXml(string xboxFile)
        {
            if (xboxFile == null)
            {
                throw new ArgumentNullException("xboxFile");
            }
            
            if (!File.Exists(xboxFile))
            {
                return null;
            }

            StreamReader reader = null;
            XboxConfiguration xbox = null;
            try
            {
                reader = new StreamReader(xboxFile);
                xbox = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return xbox;
        }

        /// <summary>
        /// Static method to deserialize an XBOX XML stream into a hierarchy of objects.
        /// </summary>
        /// <param name="xboxFile">A TextReader object that contains the raw XML of an XBOX file.</param>
        /// <returns>An XboxConfiguration object that describes the XBOX file.</returns>
        public static XboxConfiguration FromXml(TextReader xboxXml)
        {
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxConfiguration xbox = null;
            try
            {
                xmlReader = new XmlTextReader(xboxXml);
                serializer = new XmlSerializer(typeof(XboxConfiguration));
                xbox = (serializer.Deserialize(xmlReader) as XboxConfiguration);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return xbox;
        }

        /// <summary>
        /// Serializes the object hierarchy out to an XBOX file.
        /// </summary>
        /// <param name="xboxFile">The name of the XBOX file to create.</param>
        public void ToXml(string xboxFile)
        {
            if (xboxFile == null)
            {
                throw new ArgumentNullException("xboxFile");
            }

            StreamWriter stream = new StreamWriter(xboxFile);
            StringWriter sw = new StringWriter();
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxConfiguration));
                serializer.Serialize(sw, this);
                stream.WriteLine(sw);
            }
            finally
            {
                stream.Close();
                sw.Close();
            }
        }
	}


	[XmlType(TypeName="GameConfig"),Serializable]
	public class XboxGameConfig
	{

		[XmlAttribute(AttributeName="version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return _version; }
			set { _version = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _titleId;
		
		[XmlIgnore]
		public string TitleId
		{ 
			get { return _titleId; }
			set { _titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _titleName;
		
		[XmlIgnore]
		public string TitleName
		{ 
			get { return _titleName; }
			set { _titleName = value; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _name;
		
		[XmlIgnore]
		public string Name
		{ 
			get { return _name; }
			set { _name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _projectVersion;
		
		[XmlIgnore]
		public string ProjectVersion
		{ 
			get { return _projectVersion; }
			set { _projectVersion = value; }
		}

		public XboxGameConfig()
		{
		}
	}


	[XmlType(TypeName="LocalizedStrings"),Serializable]
	public class XboxLocalizedStrings
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return LocalizedStringCollection.GetEnumerator();
		}

		public XboxLocalizedString Add(XboxLocalizedString obj)
		{
			return LocalizedStringCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxLocalizedString this[int index]
		{
			get { return (XboxLocalizedString) LocalizedStringCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return LocalizedStringCollection.Count; }
        }

        public void Clear()
		{
            LocalizedStringCollection.Clear();
        }

		public XboxLocalizedString Remove(int index) 
		{ 
            XboxLocalizedString obj = LocalizedStringCollection[index];
            LocalizedStringCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            LocalizedStringCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(XboxLocalizedString),ElementName="LocalizedString",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxLocalizedStringCollection _LocalizedStringCollection;
		
		[XmlIgnore]
		public XboxLocalizedStringCollection LocalizedStringCollection
		{
			get
			{
				if (_LocalizedStringCollection == null) _LocalizedStringCollection = new XboxLocalizedStringCollection();
				return _LocalizedStringCollection;
			}
			set {_LocalizedStringCollection = value;}
		}

		public XboxLocalizedStrings()
		{
		}
	}


	[XmlType(TypeName="XboxLocalizedString"),Serializable]
	public class XboxLocalizedString
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return TranslationCollection.GetEnumerator();
		}

		public XboxTranslation Add(XboxTranslation obj)
		{
			return TranslationCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxTranslation this[int index]
		{
			get { return (XboxTranslation) TranslationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return TranslationCollection.Count; }
        }

        public void Clear()
		{
            TranslationCollection.Clear();
        }

		public XboxTranslation Remove(int index) 
		{ 
            XboxTranslation obj = TranslationCollection[index];
            TranslationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            TranslationCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _id;
		
		[XmlIgnore]
		public string Id
		{ 
			get { return _id; }
			set { _id = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _friendlyName;
		
		[XmlIgnore]
		public string FriendlyName
		{ 
			get { return _friendlyName; }
			set { _friendlyName = value; }
		}

		[XmlElement(Type=typeof(XboxTranslation),ElementName="Translation",IsNullable=true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxTranslationCollection _TranslationCollection;
		
		[XmlIgnore]
		public XboxTranslationCollection TranslationCollection
		{
			get
			{
				if (_TranslationCollection == null) _TranslationCollection = new XboxTranslationCollection();
				return _TranslationCollection;
			}
			set {_TranslationCollection = value;}
		}

		public XboxLocalizedString()
		{
		}
	}


	[XmlType(TypeName="XboxTranslation"),Serializable]
	public class XboxTranslation
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _locale;
		
		[XmlIgnore]
		public string Locale
		{ 
			get { return _locale; }
			set { _locale = value; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return _Value; }
			set { _Value = value; }
		}

		public XboxTranslation()
		{
		}
	}


	[XmlType(TypeName="XboxWebdbInfo"),Serializable]
	public class XboxWebdbInfo
	{

		[XmlElement(ElementName="ESRB",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _ESRB;
		
		[XmlIgnore]
		public string ESRB
		{ 
			get { return _ESRB; }
			set { _ESRB = value; }
		}

		[XmlElement(ElementName="ClusterID",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _ClusterID;
		
		[XmlIgnore]
		public string ClusterID
		{ 
			get { return _ClusterID; }
			set { _ClusterID = value; }
		}

		[XmlElement(ElementName="DefaultLocale",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _DefaultLocale;
		
		[XmlIgnore]
		public string DefaultLocale
		{ 
			get { return _DefaultLocale; }
			set { _DefaultLocale = value; }
		}

		public XboxWebdbInfo()
		{
		}
	}


	[XmlType(TypeName="XboxProductInformation"),Serializable]
	public class XboxProductInformation
	{

		[XmlElement(Type=typeof(XboxPublisher),ElementName="Publisher",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxPublisher _Publisher;
		
		[XmlIgnore]
		public XboxPublisher Publisher
		{
			get
			{
				if (_Publisher == null) _Publisher = new XboxPublisher();		
				return _Publisher;
			}
			set {_Publisher = value;}
		}

		public XboxProductInformation()
		{
		}
	}


	[XmlType(TypeName="XboxPublisher"),Serializable]
	public class XboxPublisher
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _name;
		
		[XmlIgnore]
		public string Name
		{ 
			get { return _name; }
			set { _name = value; }
		}

		public XboxPublisher()
		{
		}
	}


	[XmlRoot(ElementName="NewDataSet",IsNullable=false),Serializable]
	public class NewDataSet
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return XboxConfigurationCollection.GetEnumerator();
		}

		public XboxConfiguration Add(XboxConfiguration obj)
		{
			return XboxConfigurationCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxConfiguration this[int index]
		{
			get { return (XboxConfiguration) XboxConfigurationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return XboxConfigurationCollection.Count; }
        }

        public void Clear()
		{
            XboxConfigurationCollection.Clear();
        }

		public XboxConfiguration Remove(int index) 
		{ 
            XboxConfiguration obj = XboxConfigurationCollection[index];
            XboxConfigurationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            XboxConfigurationCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(XboxConfiguration),ElementName="XboxConfiguration",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxConfigurationCollection _XboxConfigurationCollection;
		
		[XmlIgnore]
		public XboxConfigurationCollection XboxConfigurationCollection
		{
			get
			{
				if (_XboxConfigurationCollection == null) _XboxConfigurationCollection = new XboxConfigurationCollection();
				return _XboxConfigurationCollection;
			}
			set {_XboxConfigurationCollection = value;}
		}

		public NewDataSet()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\Presence.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public PresenceMode AddPresence(XboxLiveSubmissionProject xlast)
        {
            PresenceMode newMode = new PresenceMode();

            newMode.clsid = PresenceModeCLSID;
            newMode.contextValue = xlast.GameConfigProject.Presence.nextContextValue;
            newMode.friendlyName = "RichPresenceString" + newMode.contextValue.ToString("d3");
            newMode.stringId = AddString(xlast, newMode.friendlyName + " String.");
            xlast.GameConfigProject.Presence.Add(newMode);
            xlast.GameConfigProject.Presence.nextContextValue++;
            return newMode;
        }

        private void CreatePresence(XboxLiveSubmissionProject xlast)
        {
            xlast.GameConfigProject.Presence.clsid = PresenceCLSID;
            xlast.GameConfigProject.Presence.nextContextValue = 0;

            // XLAST files without at least one Presence mode are invalid, so add one.
            AddPresence(xlast);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\Matchmaking.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public void AddMatchAttribute(XboxLiveSubmissionProject xlast, uint attributeId)
        {
            AddMatchAttribute(xlast, "0x" + attributeId.ToString("X8"));
        }

        public void AddMatchAttribute(XboxLiveSubmissionProject xlast, string attributeId)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            ServerTestFramework.STFTools.ConfigFiles.Attribute newAttrib = new ServerTestFramework.STFTools.ConfigFiles.Attribute();
            newAttrib.id = attributeId;
            xlast.GameConfigProject.Matchmaking.Schema.Add(newAttrib);
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, int value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.Integer, value.ToString());
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, long value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.LongInteger, value.ToString());
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, float value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.Float, value.ToString("f6"));
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, double value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.LongFloat, value.ToString("f6"));
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, DateTime value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.DateTime, value.ToShortDateString());
        }

        private void AddMatchConstant(XboxLiveSubmissionProject xlast, XLASTPropertyType type, string value)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            Constant newConst = new Constant();
            newConst.id = String.Format("0x{0}500{1}", (uint)type, xlast.GameConfigProject.Matchmaking.Constants.nextId.ToString("d04"));
            newConst.value = value;
            newConst.name = String.Format("MatchConstant{0:d03}", xlast.GameConfigProject.Matchmaking.Constants.nextId + 1);
            xlast.GameConfigProject.Matchmaking.Constants.Add(newConst);
            xlast.GameConfigProject.Matchmaking.Constants.nextId++;
        }

        public uint AddMatchQuery(XboxLiveSubmissionProject xlast, ushort maxResults, type2 queryType, bool qosProbe)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            Query newQuery = new Query();
            newQuery.clsid = QueryCLSID;
            // The Query element is weird: the nextId attribute actually bahaves more like a maxId value.
            // Because of this, we need to use the collection count as the id.
            newQuery.id = (uint)xlast.GameConfigProject.Matchmaking.Queries.QueryCollection.Count;
            newQuery.groupBy = "0xFFFFFFFF";
            newQuery.friendlyName = String.Format("MatchQuery{0:d03}", newQuery.id + 1);
            newQuery.maxResults = maxResults;
            newQuery.type = queryType;
            newQuery.qosProbe = qosProbe;

            xlast.GameConfigProject.Matchmaking.Queries.QueryCollection.Add(newQuery);
            xlast.GameConfigProject.Matchmaking.Queries.nextId = newQuery.id;
            
            // Every query requires Game Type and Game Mode return values
            AddMatchQueryReturnValue(xlast, newQuery.id, GAME_TYPE_CONTEXT_ID, type234.Normal);
            AddMatchQueryReturnValue(xlast, newQuery.id, GAME_MODE_ID, type234.Normal);

            return newQuery.id;
        }

        public void AddMatchQueryReturnValue(XboxLiveSubmissionProject xlast, uint queryId, string id, type234 returnType)
        {
            Query query = FindQuery(xlast, queryId);
            if (query == null)
            {
                throw new StfException("Query id {0} doesn't exist in the XLAST file.", queryId);
            }

            Return newReturn = new Return();
            newReturn.id = id;
            newReturn.type = returnType;
            newReturn.ordinal = (ushort)query.Returns.Count;
            query.Returns.Add(newReturn);
        }

        public void AddMatchQueryParameter(XboxLiveSubmissionProject xlast, uint queryId, string id)
        {
        }

        private void CreateMatchmaking(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Matchmaking.clsid = MatchmakingCLSID;
            xlast.GameConfigProject.Matchmaking.Constants.clsid = ConstantsCLSID;
            xlast.GameConfigProject.Matchmaking.Constants.nextId = 0;
            xlast.GameConfigProject.Matchmaking.Schema.clsid = SchemaCLSID;
            AddMatchAttribute(xlast, GAME_TYPE_CONTEXT_ID);
            AddMatchAttribute(xlast, GAME_MODE_ID);
            AddMatchAttribute(xlast, GAMER_ZONE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_COUNTRY_PROPERTY_ID);
            AddMatchAttribute(xlast, LANGUAGE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_RATING_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_MU_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_SIGMA_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_PUID_PROPERTY_ID);
            AddMatchAttribute(xlast, AFFILIATE_VALUE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_HOSTNAME_PROPERTY_ID);
            AddMatchAttribute(xlast, PLATFORM_TYPE_PROPERTY_ID);
            AddMatchAttribute(xlast, PLATFORM_LOCK_PROPERTY_ID);
            xlast.GameConfigProject.Matchmaking.Queries.clsid = QueriesCLSID;
            xlast.GameConfigProject.Matchmaking.Queries.nextId = 0;
        }

        private Query FindQuery(XboxLiveSubmissionProject xlast, uint queryId)
        {
            foreach (Query query in xlast.GameConfigProject.Matchmaking.Queries.QueryCollection)
            {
                if (query.id == queryId)
                    return query;
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ConfigFiles\XmlOfferMap.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;

namespace ServerTestFramework.STFTools.ConfigFiles
{
	/// <summary>
	/// Represents a mapping from an XML Offer file to the database entry it should
	/// correspond to.
	/// </summary>
    public class XmlOfferMap {
        ArrayList tests;
        Hashtable maps;


		/// <summary>
		/// Generate an XmlOfferMap, which will contain a parsed version of the map file.
		/// </summary>
		/// <param name="filename">Path to the offer map file.</param>
        public XmlOfferMap(string filename) {
            tests = new ArrayList();
            maps = new Hashtable();

            //Preprocess--grab the entire offer map and store it in a structure.
            StreamReader offerMapStream = File.OpenText(filename);
            String line;
            line = offerMapStream.ReadLine();
            while (line != null) {
                if (line.StartsWith("MAPDEFINITION")) { //this is a mapping of xpath, followed by
                                                       //string number pairs.  It is a simple conversion of 
													   //string to number, as is required by some offer fields.
                    string xpath = GetWord(line, 1);
                    Hashtable newMap = new Hashtable();
                    line = offerMapStream.ReadLine();
                    while (!line.StartsWith("END")) {
                        newMap.Add(GetWord(line,0), GetWord(line, 1));
                        line = offerMapStream.ReadLine();
                    }
                    line = offerMapStream.ReadLine();
                    maps.Add(xpath, newMap);
                    continue;
                }
                if (line.StartsWith("TABLE")) { //this is the start of a TableMapping--a table, followed by where all the
												//columns of that table map to in the offer file.
                    TableMapping newTest = new TableMapping(GetWord(line, 1));
                    ParseMultipleRowsInfo(offerMapStream, newTest, GetWord(line,2));

                    line = offerMapStream.ReadLine(); //we should now be reading the first map of
                                                      //Xpath to column name
                    while (!line.StartsWith("END")) {
                        if (line.StartsWith("CONSTANT") ||
                            line.StartsWith("MAP")) {
                            EntryMapping newMap = new EntryMapping(GetWord(line, 1), GetWord(line,2), GetWord(line,3));
                            newMap.flag = GetWord(line, 0);
                            newTest.dataMappings.Add(newMap);
                        } else if (!line.StartsWith("#")) {
                            EntryMapping newMap = new EntryMapping(GetWord(line, 0), GetWord(line,1), GetWord(line,2));
                            newTest.dataMappings.Add(newMap);
                        }
                        line = offerMapStream.ReadLine();
                    }
                    tests.Add(newTest);
                    line = offerMapStream.ReadLine();
                    continue;
                }
                if ((line.Equals("")) || (line.StartsWith("#"))) {
                    line = offerMapStream.ReadLine();
                    continue;
                }
                //if we get down here, we're parsing something we're not expecting.  Fail unhappily.
                Global.RO.Error("Unrecognized line:" + line);
                throw new Exception("Parse error in XmlOfferMap.cs: Unexpected data(neither comment, blank, nor recognized keyword");
            }
            offerMapStream.Close();
	}

		/// <summary>
		/// Parse the MANYROWS and ONEROW keywords.
		/// The MANYROWS keyword at the end of a table definition means that there will be
		/// multiple nodes that match the XPATH.  Each matching node corresponds to a separate
		/// row in the table.  A ONEROW keyword indicates that each field will be searched once,
		/// and matched against only one row in the database.
		/// </summary>
		/// <param name="offerMapStream">The offer map file</param>
		/// <param name="test">The table mapping to create</param>
		/// <param name="keyword">An optional keyword</param>
        private void ParseMultipleRowsInfo(StreamReader offerMapStream, TableMapping test, string keyword) {
            if (keyword.Equals("MANYROWS")) 
            {
                String line = offerMapStream.ReadLine();
                if (!line.StartsWith("LIST")) 
                {
                    throw new Exception("Parse error in XmlOfferMap.cs: Expecting LIST keyword after MANYROWS keyword");
                } 
                else 
                {
                    test.listQuery = GetWord(line, 1);
                    test.optionalTest = "";
                }
            } 
            else if (keyword.Equals("ONEROW")) 
            {
                test.listQuery = "";
                test.optionalTest = "";
 
            } 
            else if (keyword.Equals("OPTIONAL"))
            {
                test.listQuery = "";
                String line = offerMapStream.ReadLine();
                if (!line.StartsWith("TEST"))
                {
                    throw new Exception("Parse error in XmlOfferGapMap.cs: Expecting TEST keyword after OPTIONAL TABLE declared.");
                }
                else
                {
                    test.optionalTest = GetWord(line,1);
                }
            }
            else throw new Exception("Parse error in XmlOfferMap.cs: Table description must be MANYROWS, ONEROW or OPTIONAL");
        }

    
        //Get the num-th word in this line.  Words are separated by tabs, spaces, or newlines.
        public static string GetWord(string input, int num) {
            int curchar = 0;
            while (num > 0) {
                //skip a word
                while (!IsWhitespace(input[curchar])) {
                    curchar++;
                    if (curchar >= input.Length) {
                        Global.RO.Error("Error, attempt to read " + num  + " words, but line does not contain that many words.");
                        Global.RO.Error("Line text is:" + input);
                    }
                }
                //skip some spaces
                while (IsWhitespace(input[curchar])) {
                    curchar++;
                    if (curchar >= input.Length) {
                        Global.RO.Error("Error, attempt to read " + num  + " words, but line does not contain that many words.");
                        Global.RO.Error("Line text is:" + input);
                    }
                }
                num --;  //we've skipped a word.
            }
            int beginWord = curchar;
            while ((curchar < input.Length) && 
                   (!IsWhitespace(input[curchar]))) {
                curchar++;
            }
            return input.Substring(beginWord, curchar - beginWord);
        }

        public static bool IsWhitespace(char c) {
            return (c == ' ') || (c == '\n') || (c == '\t');
        }

		/// <summary>
		/// Combine the stored data of a map with the offer file to create a SELECT query.  This query should
		/// isolate a row in the database, and is expected to return precisely one entry.
		/// </summary>
		/// <param name="offer">The offer file to which this map will be applied.</param>
		/// <returns>An ArrayList of strings, each one SQL query that should return one row.</returns>
        public ArrayList CreateQueries(XmlOfferFile offer) {
            ArrayList queriesToReturn = new ArrayList();
            foreach (TableMapping test in tests) {
                // Skip over the table if the test node is set and the doesn't exist in the offer...
                if ((test.optionalTest.Equals(""))||(offer.ArbitraryXpath(test.optionalTest)!=null))
                {
                    if (test.listQuery.Equals("")) 
                    {
                        AddSingleQueryString(offer, test, queriesToReturn);
                    } 
                    else 
                    {
                        AddMultipleQueryStrings(offer, test, queriesToReturn);
                    }
                }
            }
            return queriesToReturn;
        }

        
		/// <summary>
		/// Given a table described by a MANYROWS keyword, add multiple SQL queries, one for each
		/// corresponding tag found in the offer file.  Add each of them to queriesToReturn.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="test">Table being checked.</param>
		/// <param name="queriesToReturn">A list of queries that will have strings added.</param>
        public void AddMultipleQueryStrings(XmlOfferFile offer, TableMapping test, ArrayList queriesToReturn) {
            bool quiet = false;
            XmlNodeList offerNodes = offer.MultipleQuery(test.listQuery); //all nodes that match the
                                                                          //LIST xpath
            //go through each node, forming a query off of each.
            if (offerNodes.Count >= 100) {  //let's not go overboard.
                Global.RO.Warn("Over 100 queries generated for this MANYROWS command.  Suppressing query output.");
                quiet = true;
            }
            foreach (XmlNode node in offerNodes) {
                String query = "SELECT COUNT(*) FROM " + test.tableName + " WHERE ";
                bool firstClause = true;
                foreach (EntryMapping dataMap in test.dataMappings) {
                    if (!firstClause) {
                        query += " AND ";
                    }
                    query += GenerateOneWhereClause(offer, dataMap, node);
                    firstClause = false;
                }
                if (!quiet) {
                    Global.RO.Warn(query);
                }
                queriesToReturn.Add(query);                
            }
        }

        
		/// <summary>
		/// Given a ONEROW table description, add the SQL query string that would be used to verify
		/// this row is present in the DB.  Add the string to queriesToReturn.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="test">Table being checked.</param>
		/// <param name="queriesToReturn">A list of queries that will have one string added.</param>
        public void AddSingleQueryString(XmlOfferFile offer, TableMapping test, ArrayList queriesToReturn) {
            String query = "SELECT COUNT(*) FROM " + test.tableName + " WHERE ";
            bool firstClause = true;
            foreach (EntryMapping dataMap in test.dataMappings) {
                if (!firstClause) {
                    query += " AND ";
                }
                query += GenerateOneWhereClause(offer, dataMap, null);
                firstClause = false;
            }
            Global.RO.Warn(query);
            queriesToReturn.Add(query);
        }

		/// <summary>
		/// Used when generating an SQL select query.  This iterates through all the fields that should
		/// be checked.  For each one it pulls the appropriate data out of the offer file, using the XPATH for
		/// that field.  It returns a boolean test to determine if the data in the db matches that of the offer file.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="dataMap">A single instance of mapping one XPATH in the offer file to one field in the DB.</param>
		/// <param name="multipleQueryNode">If the table was defined using MANYROWS, the XPATH is taken relative to this node.</param>
		/// <returns>A string to be added to a where clause.  e.g. "bi_offer_id = 0xfffe07d100000001"</returns>
		public string GenerateOneWhereClause(XmlOfferFile offer, EntryMapping dataMap, XmlNode multipleQueryNode) {
            string whereClause = "";
            string expectedValue;

            //handle specific flags
            if (dataMap.flag.Equals("CONSTANT")) {
                expectedValue = dataMap.offerXmlXPATH;  //if constant, the XPATH is actually the value.
            } else if (multipleQueryNode != null) {
                //this means we want a relative XPATH, from a given node.
                expectedValue = offer.RelativeXpath(multipleQueryNode, dataMap.offerXmlXPATH).InnerXml;
            } else {
                //otherwise it's arbitrary, from the top.
                expectedValue = offer.ArbitraryXpath(dataMap.offerXmlXPATH).InnerXml;
            }
            if (dataMap.flag.Equals("MAP")) {
                if (maps[dataMap.offerXmlXPATH] == null) {
                    Global.RO.Warn("Warning:There is no MAPDEFINITION for the given xpath, " + dataMap.offerXmlXPATH);
                }
                expectedValue = (string) ((Hashtable) maps[dataMap.offerXmlXPATH])[expectedValue];
            }

            //handle datatype-specific issues
            if (dataMap.dataType.Equals("datetime")) {  //trim off everything from the dot onwards.
                //expectedValue = expectedValue.Substring(0, expectedValue.IndexOf('.'));
                DateTime dt = Convert.ToDateTime(expectedValue);
                expectedValue = dt.ToString("s");
            }

            whereClause += dataMap.columnName + " = ";
            if (dataMap.NeedsQuotes()) {
                whereClause += "\'" + expectedValue + "\'";
            } else {
                whereClause += expectedValue;
            }
            return whereClause;
        }

    }

	/// <summary>
	/// A mapping of the fields of one table with the XPATHs that locate those fields in an offer file.
	/// </summary>
	public class TableMapping {
        public string tableName;
        public ArrayList dataMappings;
        public string listQuery;  //this is optional.  If MANYROWS is used to define the table,
                                  //then we expect multiple tags of the same name.  This XPATH query
                                  //will select them all.  The data mappings will be relative,
                                  //unless they have a keyword STATIC
        public string optionalTest;  // Makes this Table optional.  Should be an xpath statement.  
                                     // If it returns NULL, it will skip the check on this table.

        public TableMapping(string tableName) {
            this.tableName = tableName;
            dataMappings = new ArrayList();
            listQuery = null; //must be set during parse.
            optionalTest = null;
        }
    }

	//a mapping of one particular field to one particular XPATH.
    public class EntryMapping {
        public string offerXmlXPATH;
        public string dataType;
        public string columnName;
        public string flag;

        public EntryMapping (string offerXmlXPATH, string dataType, string columnName) {
            this.offerXmlXPATH = offerXmlXPATH;
            this.dataType = dataType;
            this.columnName = columnName;
            this.flag = "";
        }
        //returns true if this data type needs quotes in the SQL query.
        public bool NeedsQuotes() {
            return (dataType.StartsWith("datetime")) ||
                (dataType.IndexOf("char") != -1);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\WSTRunner.cs ===
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the WSTRunner tool.
    /// </summary>
    public class WSTRunner
    {
        const string DefaultWSTRunnerPath = "D:\\webroot\\xbltools";

        private string _manifestPath = "";
        private string _deploymentPath = "";
        private ProcessWrapper _wstRunnerProcess;
        private Report _report;

        public WSTRunner()
        {
            _wstRunnerProcess = new ProcessWrapper("WSTRunner", Path.Combine(DefaultWSTRunnerPath, "WSTRunner.exe"));
            //_wstRunnerProcess.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.DefaultNpdbSetting.ip);
            _wstRunnerProcess.Verbose = true;
            _report = new Report("WSTRunner");
        }

        public WSTRunner(string wstRunnerPath)
            : this()
        {
            WSTRunnerPath = wstRunnerPath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the WSTRunner executable.
        /// </summary>
        public string WSTRunnerPath
        {
            get { return _wstRunnerProcess.ExecutablePath; }
            set
            {
                _wstRunnerProcess.ExecutablePath = Path.GetFullPath(value);
                _wstRunnerProcess.WorkingDirectory = Path.GetDirectoryName(_wstRunnerProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for WSTRunner
        /// </summary>
        public string WorkingDirectory
        {
            get { return _wstRunnerProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _wstRunnerProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _wstRunnerProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Manifest file used during database 
        /// deployment.
        /// </summary>
        public string ManifestFilePath
        {
            get { return _manifestPath; }
            set
            {
                if (value != null)
                {
                    _manifestPath = Path.GetFullPath(value);
                }
                else
                {
                    _manifestPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Deployment file used during database 
        /// deployment.
        /// </summary>
        public string DeploymentFilePath
        {
            get { return _deploymentPath; }
            set
            {
                if (value != null)
                {
                    _deploymentPath = Path.GetFullPath(value);
                }
                else
                {
                    _deploymentPath = "";
                }
            }
        }

        /// <summary>
        /// Gets the output text from the most recent run of WSTRunner.
        /// </summary>
        public string Output
        {
            get { return _wstRunnerProcess.Output; }
        }

        /// <summary>
        /// Exposes the Execution Timeout value for the underlying Process wrapper.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _wstRunnerProcess.ExecutionTimeout; }
            set { _wstRunnerProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Runs WSTRunner to setup a database using the provided manifest and deployment files.
        /// </summary>
        /// <param name="manifestFile">Manifest File to be used with the /m parameter. Required.</param>
        /// <param name="deploymentFile">Deployment File to be used with the /d parameter. Required.</param>
        public void WSTRunnerSetup(string manifestFile, string deploymentFile)
        {
            this.ManifestFilePath = manifestFile;
            this.DeploymentFilePath = deploymentFile;

            WSTRunnerSetup();
        }

        /// <summary>
        /// Runs WSTRunner to setup a database using the provided manifest and deployment files.
        /// </summary>
        public void WSTRunnerSetup()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/setup");
            if (_manifestPath.Length > 0)
            {
                arguments.AppendFormat(" /m {0}", _manifestPath);
            }
            if (_deploymentPath.Length > 0)
            {
                arguments.AppendFormat(" /d {0}", _deploymentPath);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to setup the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to drop a database using the provided manifest and deployment files.
        /// </summary>
        /// <param name="manifestFile">Manifest File to be used with the /m parameter. Required.</param>
        /// <param name="deploymentFile">Deployment File to be used with the /d parameter. Required.</param>
        public void WSTRunnerDrop(string manifestFile, string deploymentFile)
        {
            this.ManifestFilePath = manifestFile;
            this.DeploymentFilePath = deploymentFile;

            WSTRunnerSetup();
        }

        /// <summary>
        /// Runs WSTRunner to drop a database using the provided manifest and deployment files.
        /// </summary>
        public void WSTRunnerDrop()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/drop");
            if (_manifestPath.Length > 0)
            {
                arguments.AppendFormat(" /m {0}", _manifestPath);
            }
            if (_deploymentPath.Length > 0)
            {
                arguments.AppendFormat(" /d {0}", _deploymentPath);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(bool setupParam, bool dropParam, bool mParam, string manifestFile, bool dParam, string deploymentFile)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            if (setupParam == true)
            {
                arguments.AppendFormat(" /setup");
            }
            if (dropParam == true)
            {
                arguments.AppendFormat(" /drop");
            }
            if (mParam == true)
            {
                arguments.AppendFormat(" /m");
            }
            if (manifestFile != null)
            {
                arguments.AppendFormat(" {0}", manifestFile);
            }
            if (dParam == true)
            {
                arguments.AppendFormat(" /d");
            }
            if (deploymentFile != null)
            {
                arguments.AppendFormat(" {0}", deploymentFile);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(params string[] args)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            if (args != null)
            {
                for (int i = 0; i < args.Length; i++)
                {
                    arguments.AppendFormat(" {0}", args[i]);
                }
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(string commandLine)
        {
            int exitCode;

            exitCode = _wstRunnerProcess.Run(commandLine);
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }
    }

    public class WSTRunnerException : ProcessException
    {
        public WSTRunnerException() : base("WSTRunner") { }
        public WSTRunnerException(string message) : base("WSTRunner", message) { }
        public WSTRunnerException(string message, Exception innerException) : base("WSTRunner", message, innerException) { }
        public WSTRunnerException(string message, string wstRunnerOutput) : base("WSTRunner", message, wstRunnerOutput) { }
        public WSTRunnerException(string message, string wstRunnerOutput, Exception innerException)
            :
            base("WSTRunner", wstRunnerOutput, message, innerException) { }

        public override string Message
        {
            get
            {
                return string.Format("{0}\r\nWSTRunner Output:\r\n{1}\r\nEnd WSTRunner Output\r\n",
                    base.Message, base.ProcessOutput);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\Properties.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTPropertyType : uint
    {
        Integer = 1,
        LongInteger,
        LongFloat,
        String,
        Float,
        DateTime = 7
    }

    public partial class XLASTFactory
    {
        private const uint RATING_PROPERTY_ID = 0x20000001;
        private const uint RANK_PROPERTY_ID = 0x10008001;
        private const uint GAMERNAME_PROPERTY_ID = 0x40008002;
        private const uint GAMER_ZONE_PROPERTY_ID = 0x10008101;
        private const uint GAMER_COUNTRY_PROPERTY_ID = 0x10008102;
        private const uint LANGUAGE_PROPERTY_ID = 0x10008103;
        private const uint GAMER_RATING_PROPERTY_ID = 0x50008104;
        private const uint GAMER_MU_PROPERTY_ID = 0x30008105;
        private const uint GAMER_SIGMA_PROPERTY_ID = 0x30008106;
        private const uint GAMER_PUID_PROPERTY_ID = 0x20008107;
        private const uint AFFILIATE_VALUE_PROPERTY_ID = 0x20008108;
        private const uint GAMER_HOSTNAME_PROPERTY_ID = 0x40008109;
        private const uint PLATFORM_TYPE_PROPERTY_ID = 0x10008201;
        private const uint PLATFORM_LOCK_PROPERTY_ID = 0x10008202;

        public void AddProperties(XboxLiveSubmissionProject xlast, int count)
        {
            for (int i = 1; i <= count; i++)
            {
                XLASTPropertyType type = GetRandomPropertyType();
                AddProperty(xlast, type);
            }
        }

        public string AddProperty(XboxLiveSubmissionProject xlast, XLASTPropertyType propertyType)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            string newId;
            uint id = ((uint)propertyType << 28) | xlast.GameConfigProject.Properties.nextId;
            string name = "Property" + xlast.GameConfigProject.Properties.nextId.ToString("d3");
            ushort stringId = AddString(xlast, name + " string");
            newId = AddProperty(xlast, id, stringId, propertyType, name);

            return newId;
        }

        public string AddProperty(XboxLiveSubmissionProject xlast, uint id, ushort stringId, XLASTPropertyType propertyType, string friendlyName)
        {
            Property newProperty = new Property();

            newProperty.clsid = PropertyCLSID;
            newProperty.id = "0x" + id.ToString("X8");
            newProperty.stringId = stringId;
            newProperty.friendlyName = friendlyName;
            switch (propertyType)
            {
                case XLASTPropertyType.DateTime:
                    newProperty.dataSize = 8;
                    newProperty.Format.year = true;
                    newProperty.Format.month = true;
                    newProperty.Format.day = true;
                    newProperty.Format.hours = true;
                    newProperty.Format.minutes = true;
                    newProperty.Format.seconds = true;
                    newProperty.Format.milliseconds = true;
                    break;
                case XLASTPropertyType.Float:
                    newProperty.dataSize = 4;
                    newProperty.Format.decimals = 2;
                    break;
                case XLASTPropertyType.Integer:
                    newProperty.dataSize = 4;
                    newProperty.Format.hours = false;
                    newProperty.Format.minutes = false;
                    newProperty.Format.seconds = false;
                    newProperty.Format.milliseconds = false;
                    break;
                case XLASTPropertyType.LongFloat:
                    newProperty.dataSize = 8;
                    newProperty.Format.decimals = 2;
                    break;
                case XLASTPropertyType.LongInteger:
                    newProperty.dataSize = 8;
                    newProperty.Format.hours = false;
                    newProperty.Format.minutes = false;
                    newProperty.Format.seconds = false;
                    newProperty.Format.milliseconds = false;
                    break;
                case XLASTPropertyType.String:
                    newProperty.dataSize = 0;
                    break;
            }
            xlast.GameConfigProject.Properties.Add(newProperty);
            xlast.GameConfigProject.Properties.nextId++;

            return newProperty.id;
        }

        private void CreateProperties(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Properties.clsid = PropertiesCLSID;
            xlast.GameConfigProject.Properties.nextId = 1;

            AddProperty(xlast, RANK_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_RANK, XLASTPropertyType.Integer, "RANK");
            AddProperty(xlast, GAMERNAME_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMERNAME, XLASTPropertyType.String, "GAMERNAME");
            AddProperty(xlast, GAMER_ZONE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_ZONE, XLASTPropertyType.Integer, "GAMERZONE");
            AddProperty(xlast, GAMER_COUNTRY_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_COUNTRY, XLASTPropertyType.Integer, "GAMERCOUNTRY");
            AddProperty(xlast, LANGUAGE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_LANGUAGE, XLASTPropertyType.Integer, "LANGUAGE");
            AddProperty(xlast, GAMER_RATING_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_RATING, XLASTPropertyType.Float, "GAMERRATING");
            AddProperty(xlast, GAMER_MU_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_MU, XLASTPropertyType.LongFloat, "GAMERMU");
            AddProperty(xlast, GAMER_SIGMA_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_SIGMA, XLASTPropertyType.LongFloat, "GAMERSIGMA");
            AddProperty(xlast, GAMER_PUID_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_PUID, XLASTPropertyType.LongInteger, "GAMERPUID");
            AddProperty(xlast, AFFILIATE_VALUE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_AFFILIATE_VALUE, XLASTPropertyType.LongInteger, "AFFILIATEVALUE");
            AddProperty(xlast, GAMER_HOSTNAME_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_HOSTNAME, XLASTPropertyType.String, "GAMERHOSTNAME");
            AddProperty(xlast, PLATFORM_TYPE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_PLATFORM_TYPE, XLASTPropertyType.String, "PLATFORMTYPE");
            AddProperty(xlast, PLATFORM_LOCK_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_PLATFORM_LOCK, XLASTPropertyType.String, "PLATFORMLOCK");

            // We need to add a well-known long int property to be used as the rating column in leaderboards
            AddProperty(xlast, RATING_PROPERTY_ID, AddString(xlast, "Rating"), XLASTPropertyType.LongInteger, "Rating");
        }

        private XLASTPropertyType GetRandomPropertyType()
        {
            int val;
            do
            {
                // There is no property ID 6 and string properties (ID 4) are not allowed by users.
                val = _rnd.Next((int)XLASTPropertyType.Integer, (int)XLASTPropertyType.DateTime + 1);
            } while (val == 4 || val == 6);

            return (XLASTPropertyType)val;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ClientTools\VoucherMgr.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the VoucherMgr tool.
	/// </summary>
	public class VoucherMgr
	{
            private ProcessWrapper _voucherMgrProcess;
            private const string _defaultVoucherMgrPath = "D:\\webroot\\xbltools";
            static public string InvalidEMSOfferId;

            public bool IsEmsOfferId(string offerId)
            {

                try
                {
                    if (offerId == InvalidEMSOfferId) return true;
                    Guid guidId = new Guid(offerId);
                    return true;
                }
                catch
                {
                    return false;
                }
            }

            public VoucherMgr() {
                _voucherMgrProcess = new ProcessWrapper("VoucherMgr", Path.Combine(_defaultVoucherMgrPath, "VoucherMgr.exe"));
            }

            public VoucherMgr(string voucherMgrPath) : this()
            {
                _voucherMgrProcess.ExecutablePath = Path.GetFullPath(voucherMgrPath);
            }

            public string Output
            {
                get { return _voucherMgrProcess.Output; }
            }

            

            public void Import(string key_or_file, bool isFile, string emsofferid, int mediatype, string espofferid, int useCount,
                   int useSCG, uint consoleVer)
            {
                Import(key_or_file, isFile, emsofferid, mediatype, espofferid, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void Import(string key_or_file, bool isFile, string emsofferid, int mediatype, string espofferid, int useCount,
                   int useSCG, uint consoleVer, int minseq,
                   int maxseq, int retries)
            {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += "/emsofferid:" + emsofferid + " ";
                arguments += "/mediatype:" + mediatype + " ";
                arguments += "/espofferid:" + espofferid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1)
                {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Import(string key_or_file, bool isFile, string offerid, int mediatype, int useCount,
                               int useSCG, uint consoleVer)
            {
                Import(key_or_file, isFile, offerid, mediatype, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void ImportOld(string key_or_file, bool isFile, string offerid, int useCount,
                   int useSCG, uint consoleVer)
            {
                ImportOld(key_or_file, isFile, offerid, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void Import(string key_or_file, bool isFile, string offerid, int mediatype, int useCount, 
                               int useSCG, uint consoleVer, int minseq,
                               int maxseq, int retries) {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);

                if (IsEmsOfferId(offerid))
                {
                    arguments += "/emsofferid:" + offerid + " ";
                    arguments += "/mediatype:" + mediatype + " ";
                }
                else
                    arguments += "/espofferid:" + offerid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1) {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void ImportOld(string key_or_file, bool isFile, string offerid, int useCount,
                   int useSCG, uint consoleVer, int minseq,
                   int maxseq, int retries)
            {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);


                arguments += "/offerid:" + offerid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1)
                {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }            
            public void Disable(string key_or_file, bool isFile) {
                Disable(key_or_file, isFile, -1, -1);
            }

            public void Disable(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/disable ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Enable(string key_or_file, bool isFile) {
                Enable(key_or_file, isFile, -1, -1);
            }

            public void Enable(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/enable ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Delete(string key_or_file, bool isFile, string offerid) {
                Delete(key_or_file, isFile, offerid, -1, -1, -1);
            }


            public void Delete(string key_or_file, bool isFile, string offerid,  
                               int minseq, int maxseq, int retries) {
                string arguments = "/delete ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                if (offerid != "") {
                    if (IsEmsOfferId(offerid)) {
                        arguments += "/emsofferid:" + offerid + " ";
                    }
                    else
                        arguments += "/espofferid:" + offerid + " ";
                }
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1) {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

        public void Delete(string key_or_file, bool isFile, string emsofferid, string espofferid,
               int minseq, int maxseq, int retries)
        {
            string arguments = "/delete ";
            arguments += CreateKeyOrFileArg(key_or_file, isFile);


            if (emsofferid != "")
                arguments += "/emsofferid:" + emsofferid + " ";
            
            if(espofferid !="")
                    arguments += "/espofferid:" + espofferid + " ";

           
            arguments += CreateMinMaxArg(minseq, maxseq);
            if (retries != -1)
            {
                arguments += "/retries:" + retries + " ";
            }
            if (_voucherMgrProcess.Run(arguments) != 0)
            {
                throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
            }
        }


            public string View(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/view ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            public string Summary() {
                string arguments = "/summary";
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            public string EmsSummary()
            {
                string arguments = "/emssummary";
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            private string CreateKeyOrFileArg(string key_or_file, bool isFile) {
                if (isFile) {
                    return "/file:" + key_or_file + " ";
                } else {
                    return "/key:" + key_or_file + " ";
                }
            }

            private string CreateMinMaxArg(int minseq, int maxseq) {
                string returnedArgs = "";
                if (minseq != -1) {
                    returnedArgs += "/minseq:" + minseq + " ";
                }
                if (maxseq != -1) {
                    returnedArgs += "/maxseq:" + maxseq + " ";
                }
                return returnedArgs;
            }

            public string ArbitraryCommand(string args) {
                if (_voucherMgrProcess.Run(args) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }


        }



	public class VoucherMgrException : ProcessException
	{
		public VoucherMgrException() : base("VoucherMgr") {}
		public VoucherMgrException(string message) : base("VoucherMgr", message) {}
		public VoucherMgrException(string message, Exception innerException) : base("VoucherMgr", message, innerException) {}
		public VoucherMgrException(string message, string output) : base("VoucherMgr", message, output) {}
		public VoucherMgrException(string message, string output, Exception innerException) :
			base("VoucherMgr", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ConfigFiles\XscConfig.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    public struct XscDeclarations
    {
        public const string SchemaVersion = "http://www.xboxlive.com";
    }

    [Serializable]
    public enum ContainerType
    {
        [XmlEnum("individual")] Individual,
        [XmlEnum("units")] Units,
        [XmlEnum("competitions")] Competitions
    }

    [XmlType(IncludeInSchema=false)]
    public enum ContainerClassChoices
    {
        Leaderboard,
        LeaderboardTemplate
    }

    /// <summary>
    /// Root class for the Xbox1 Leaderboard Configuration (XSC) file hierarchy.
    /// </summary>
    [XmlRoot(ElementName="Title",Namespace=XscDeclarations.SchemaVersion,IsNullable=false),Serializable]
    public class XboxLeaderboardConfiguration
    {
        [XmlAttribute(AttributeName="TitleID",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _titleId;

        /// <summary>
        /// The value ot the TitleID attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        [XmlAttribute(AttributeName="UnitLeaderboardDecayConstant", DataType="int")]
        public int _unitLeaderboardDecayConstant;

        /// <summary>
        /// The value of the UnitLeaderboardDecayConstant attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public int UnitLeaderboardDecayConstant
        {
            get { return _unitLeaderboardDecayConstant; }
            set { _unitLeaderboardDecayConstant = value; }
        }

        [XmlAttribute(AttributeName="Version",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _version;

        /// <summary>
        /// The value of the Version attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string Version
        {
            get { return _version; }
            set { _version = value; }
        }

        [XmlAttribute(AttributeName="Default_Locale",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _defaultLocale;

        /// <summary>
        /// The value of the Default_Locale attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string DefaultLocale
        {
            get { return _defaultLocale; }
            set { _defaultLocale = value; }
        }

        [XmlElement(Type=typeof(XscLeaderboardContainer),ElementName="LeaderboardContainer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLeaderboardContainerCollection _leaderboardContainers;

        /// <summary>
        /// Collection of XscLeaderboardContainer objects that represent the three possible types of leaderboards in the file
        /// </summary>
        [XmlIgnore]
        public XscLeaderboardContainerCollection LeaderboardContainers
        {
            get
            {
                if (_leaderboardContainers == null) _leaderboardContainers = new XscLeaderboardContainerCollection();
                return _leaderboardContainers;
            }
            set { _leaderboardContainers = value; }
        }

        public XboxLeaderboardConfiguration()
        {
        }

        /// <summary>
        /// Static method to deserialize an XSC file into a class hierarchy
        /// </summary>
        /// <param name="xscFile">Full path and filename of the XSC file to deserialize</param>
        /// <returns>Returns an XboxLeaderboardConfiguration object defining the XSC file</returns>
        /// <example>
        /// XboxLeaderboardConfiguration xsc = XboxLeaderboardConfiguration.FromXml("FFFFAB08.XSC");
        /// </example>
        public static XboxLeaderboardConfiguration FromXml(string xscFile)
        {
            if (xscFile == null)
            {
                throw new ArgumentNullException("xscFile");
            }
            
            if (!File.Exists(xscFile))
            {
                return null;
            }

            StreamReader reader = null;
            XboxLeaderboardConfiguration xsc = null;
            try
            {
                reader = new StreamReader(xscFile);
                xsc = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return xsc;
        }

        /// <summary>
        /// Static method to deserialize raw XSC xml into a class hierarchy
        /// </summary>
        /// <param name="xscXml">A TextReader-derived object that contains the XSC XML to deserialize</param>
        /// <returns>Returns an XboxLeaderboardConfiguration object defining the XSC XML</returns>
        /// <example>
        /// StreamReader reader = new StreamReader("FFFFAB08.XSC");
        /// XboxLeaderboardConfiguration xsc = XboxLeaderboardConfiguration.FromXml(reader);
        /// </example>
        public static XboxLeaderboardConfiguration FromXml(TextReader xscXml)
        {
            if (xscXml == null)
            {
                return null;
            }

            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxLeaderboardConfiguration xsc = null;
            try
            {
                xmlReader = new XmlTextReader(xscXml);
                serializer = new XmlSerializer(typeof(XboxLeaderboardConfiguration));
                xsc = (serializer.Deserialize(xmlReader) as XboxLeaderboardConfiguration);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return xsc;
        }

        /// <summary>
        /// Serializes Xbox1 leaderboard configuration data into an XSC file
        /// </summary>
        /// <param name="xscFile">Full path and filename to which the XML data should be serialized</param>
        public void ToXml(string xscFile)
        {
            if (xscFile == null)
            {
                throw new ArgumentNullException("xscFile");
            }

            StreamWriter stream = new StreamWriter(xscFile);
            StringWriter sw = new StringWriter();
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxLeaderboardConfiguration));
                serializer.Serialize(sw, this);
                stream.WriteLine(sw);
            }
            finally
            {
                stream.Close();
                sw.Close();
            }
        }
    }

    /// <summary>
    /// A collection of Leaderboard Containers in an XSC file.
    /// </summary>
    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLeaderboardContainerCollection : ArrayList
    {
        /// <summary>
        /// Adds an existing XscLeaderboardContainer object to the collection
        /// </summary>
        /// <param name="obj">An existing XscLeaderboardContainer object</param>
        /// <returns>The added object</returns>
        public XscLeaderboardContainer Add(XscLeaderboardContainer obj)
        {
            base.Add(obj);
            return obj;
        }

        /// <summary>
        /// Creates a new XscLeaderboardContainer object and adds it to the collection
        /// </summary>
        /// <returns>The newly created object</returns>
        public XscLeaderboardContainer Add()
        {
            return Add(new XscLeaderboardContainer());
        }

        /// <summary>
        /// Inserts an existing XscLeaderboardContainer object into the collection
        /// </summary>
        /// <param name="index">0-based index at which the XscLeaderboardContainer object should be inserted</param>
        /// <param name="obj">The XscLeaderboardContainer object to insert</param>
        public void Insert(int index, XscLeaderboardContainer obj)
        {
            base.Insert(index, obj);
        }

        /// <summary>
        /// Removes the first occurance of the specified XscLeaderboardContainer object from the collection
        /// </summary>
        /// <param name="obj">The XscLeaderboardContainer object to remove</param>
        public void Remove(XscLeaderboardContainer obj)
        {
            base.Remove(obj);
        }

        new public XscLeaderboardContainer this[int index]
        {
            get { return base[index] as XscLeaderboardContainer; }
            set { base[index] = value; }
        }
    }

    [XmlType(TypeName="LeaderboardContainer",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLeaderboardContainer
    {
        [XmlAttribute(AttributeName="type")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ContainerType _type;

        [XmlIgnore]
        public ContainerType Type
        {
            get { return _type; }
            set { _type = value; }
        }

        [XmlIgnore]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ContainerClassChoices [] _ContainerClassTypes;

        [XmlElement(Type=typeof(XscLeaderboard),ElementName="Leaderboard",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [XmlElement(Type=typeof(XscLeaderboard),ElementName="LeaderboardTemplate",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [XmlChoiceIdentifier("_ContainerClassTypes")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLeaderboard [] _leaderboards;

        [XmlIgnore]
        public XscLeaderboard [] Leaderboards
        {
            get { return _leaderboards; }
            set { _leaderboards = value; }
        }

        public XscLeaderboardContainer()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLeaderboardCollection : ArrayList
    {
        public XscLeaderboard Add(XscLeaderboard obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscLeaderboard Add()
        {
            return Add(new XscLeaderboard());
        }

        public void Insert(int index, XscLeaderboard obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscLeaderboard obj)
        {
            base.Remove(obj);
        }

        new public XscLeaderboard this[int index]
        {
            get { return base[index] as XscLeaderboard; }
            set { base[index] = value; }
        }
    }

    [XmlType(TypeName="Leaderboard",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLeaderboard
    {
        [XmlAttribute(AttributeName="ID",DataType="unsignedShort")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _id;

        [XmlIgnore]
        public ushort Id
        {
            get { return _id; }
            set { _id = value; }
        }

        [XmlElement("Reset", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _reset;

        [XmlIgnore]
        public ushort Reset
        {
            get { return _reset; }
            set { _reset = value; }
        }

        [XmlElement("TopOneHundred", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _topOneHundred;

        [XmlIgnore]
        public bool TopOneHundred
        {
            get { return _topOneHundred; }
            set { _topOneHundred = value; }
        }

        [XmlElement("DecayDays", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _decayDays;

        [XmlIgnore]
        public ushort DecayDays
        {
            get { return _decayDays; }
            set { _decayDays = value; }
        }

        [XmlElement("TeamsLeaderboard", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _teamsLeaderboard;

        [XmlIgnore]
        public bool TeamsLeaderboard
        {
            get { return _teamsLeaderboard; }
            set { _teamsLeaderboard = value; }
        }

        [XmlElement("Arbitrate", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _arbitrated;

        [XmlIgnore]
        public bool Arbitrated
        {
            get { return _arbitrated; }
            set { _arbitrated = value; }
        }

        [XmlElement(ElementName="Attachments", Type=typeof(XscAttachments), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscAttachments _attachments;

        [XmlIgnore]
        public XscAttachments Attachments
        {
            get { return _attachments; }
            set { _attachments = value; }
        }

        [XmlElement(ElementName="ELO", Type=typeof(XscElo), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscElo _elo;

        [XmlIgnore]
        public XscElo Elo
        {
            get { return _elo; }
            set { _elo = value; }
        }

        [XmlElement(ElementName="Names", Type=typeof(XscNames), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscNames _names;

        [XmlIgnore]
        public XscNames Names
        {
            get { return _names; }
            set { _names = value; }
        }

        [XmlElement(ElementName="FormattedValues", Type=typeof(XscFormattedValues), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscFormattedValues _formattedValues;

        [XmlIgnore]
        public XscFormattedValues FormattedValues
        {
            get { return _formattedValues; }
            set { _formattedValues = value; }
        }

        [XmlElement(ElementName="RawAttributes", Type=typeof(XscRawAttributes), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscRawAttributes _rawAttributes;

        [XmlIgnore]
        public XscRawAttributes RawAttributes
        {
            get { return _rawAttributes; }
            set { _rawAttributes = value; }
        }

        public XscLeaderboard()
        {
        }
    }

    [XmlType(TypeName="Attachments",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscAttachments
    {
        [XmlElement("Uploads", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _uploads;

        [XmlIgnore]
        public ushort Uploads
        {
            get { return _uploads; }
            set { _uploads = value; }
        }

        [XmlElement("Size", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _size;

        [XmlIgnore]
        public ushort Size
        {
            get { return _size; }
            set { _size = value; }
        }

        public XscAttachments()
        {
        }
    }

    [XmlType(TypeName="ELO",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscElo
    {
        [XmlElement("InitialPlayerRating", typeof(uint))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public uint _initialPlayerRating;

        [XmlIgnore]
        public uint InitialPlayerRating
        {
            get { return _initialPlayerRating; }
            set { _initialPlayerRating = value; }
        }

        [XmlElement("RatingScaleFactor", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _ratingScaleFactor;

        [XmlIgnore]
        public ushort RatingScaleFactor
        {
            get { return _ratingScaleFactor; }
            set { _ratingScaleFactor = value; }
        }

        [XmlElement("ExponentialBase", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _exponentialBase;

        [XmlIgnore]
        public string ExponentialBase
        {
            get { return _exponentialBase; }
            set { _exponentialBase = value; }
        }

        [XmlElement("MaxWeightRatingRangeArray", typeof(XscMaxWeightRatingRangeArray))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscMaxWeightRatingRangeArray _maxWeightRatingRangeArray;

        [XmlIgnore]
        public XscMaxWeightRatingRangeArray MaxWeightRatingRangeArray
        {
            get { return _maxWeightRatingRangeArray; }
            set { _maxWeightRatingRangeArray = value; }
        }

        public XscElo()
        {
        }
    }

    [XmlType(TypeName="MaxWeightRatingRangeArray",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscMaxWeightRatingRangeArray
    {
        [XmlElement(ElementName="MaxWeightRatingRange",Type=typeof(XscMaxWeightRatingRange),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscMaxWeightRatingRangeCollection _maxWeightRatingRanges;

        [XmlIgnore]
        public XscMaxWeightRatingRangeCollection MaxWeightRatingRanges
        {
            get { return _maxWeightRatingRanges; }
            set { _maxWeightRatingRanges = value; }
        }

        public XscMaxWeightRatingRangeArray()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscMaxWeightRatingRangeCollection : ArrayList
    {
        public XscMaxWeightRatingRange Add(XscMaxWeightRatingRange obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscMaxWeightRatingRange Add()
        {
            return Add(new XscMaxWeightRatingRange());
        }

        public void Insert(int index, XscMaxWeightRatingRange obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscMaxWeightRatingRange obj)
        {
            base.Remove(obj);
        }

        new public XscMaxWeightRatingRange this[int index]
        {
            get { return base[index] as XscMaxWeightRatingRange; }
            set { base[index] = value; }
        }

        public XscMaxWeightRatingRangeCollection()
        {
        }
    }

    [XmlType(TypeName="MaxWeightRatingRange",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscMaxWeightRatingRange
    {
        [XmlAttribute(AttributeName="start", DataType="unsignedInt")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public uint _start;

        [XmlIgnore]
        public uint Start
        {
            get { return _start; }
            set { _start = value; }
        }

        [XmlAttribute(AttributeName="maxweight", DataType="unsignedShort")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _maxWeight;

        [XmlIgnore]
        public ushort MaxWeight
        {
            get { return _maxWeight; }
            set { _maxWeight = value; }
        }

        public XscMaxWeightRatingRange()
        {
        }
    }

    [XmlType(TypeName="Names",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscNames
    {
        [XmlElement(ElementName="LocalizedName",Type=typeof(XscLocalizedName),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLocalizedNameCollection _localizedNames;

        [XmlIgnore]
        public XscLocalizedNameCollection LocalizedNames
        {
            get
            {
                if (_localizedNames == null) _localizedNames = new XscLocalizedNameCollection();
                return _localizedNames;
            }
            set { _localizedNames = value; }
        }

        public XscNames()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLocalizedNameCollection : ArrayList
    {
        public XscLocalizedName Add(XscLocalizedName obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscLocalizedName Add()
        {
            return Add(new XscLocalizedName());
        }

        public void Insert(int index, XscLocalizedName obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscLocalizedName obj)
        {
            base.Remove(obj);
        }

        new public XscLocalizedName this[int index]
        {
            get { return base[index] as XscLocalizedName; }
            set { base[index] = value; }
        }

        public XscLocalizedNameCollection()
        {
        }
    }

    [XmlType(TypeName="LocalizedName",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLocalizedName
    {
        [XmlElement("Name", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _name;

        [XmlIgnore]
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        [XmlElement("Locale", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _locale;

        [XmlIgnore]
        public string Locale
        {
            get { return _locale; }
            set { _locale = value; }
        }

        public XscLocalizedName()
        {
        }
    }

    [XmlType(TypeName="FormattedValues",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormattedValues
    {
        [XmlElement(ElementName="FormattedValue",Type=typeof(XscFormattedValue),IsNullable=true,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscFormattedValueCollection _formattedValues;

        [XmlIgnore]
        public XscFormattedValueCollection FormattedValues
        {
            get { return _formattedValues; }
            set { _formattedValues = value; }
        }

        public XscFormattedValues()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscFormattedValueCollection : ArrayList
    {
        public XscFormattedValue Add(XscFormattedValue obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscFormattedValue Add()
        {
            return Add(new XscFormattedValue());
        }

        public void Insert(int index, XscFormattedValue obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscFormattedValue obj)
        {
            base.Remove(obj);
        }

        new public XscFormattedValue this[int index]
        {
            get { return base[index] as XscFormattedValue; }
            set { base[index] = value; }
        }

        public XscFormattedValueCollection()
        {
        }
    }

    [XmlType(TypeName="FormattedValue",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormattedValue
    {
        [XmlElement(ElementName="Names",Type=typeof(XscNames),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscNames _names;

        [XmlIgnore]
        public XscNames Names
        {
            get
            {
                if (_names == null) _names = new XscNames();
                return _names;
            }
            set { _names = value; }
        }

        [XmlElement("NameID",typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _nameId;

        [XmlIgnore]
        public ushort NameId
        {
            get { return _nameId; }
            set { _nameId = value; }
        }

        [XmlElement("Type",typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _type;

        [XmlIgnore]
        public string Type
        {
            get { return _type; }
            set { _type = value; }
        }

        [XmlElement("FriendlyAdminName",typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _friendlyAdminName;

        [XmlIgnore]
        public string FriendlyAdminName
        {
            get { return _friendlyAdminName; }
            set { _friendlyAdminName = value; }
        }

        [XmlElement("Formula", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _formula;

        [XmlIgnore]
        public string Formula
        {
            get { return _formula.Trim(); }
            set { _formula = value; }
        }

        public XscFormattedValue()
        {
        }
    }

    [XmlType(TypeName="Formula",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormula
    {
        [XmlElement("!", typeof(string))]
        public string _cdata;

        [XmlIgnore]
        public string CData
        {
            get { return _cdata; }
            set { _cdata = value; }
        }

        public XscFormula()
        {
        }
    }

    [XmlType(TypeName="RawAttributes",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscRawAttributes
    {
        [XmlElement(ElementName="Attribute",Type=typeof(XscAttribute),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscRawAttributeCollection _rawAttributes;

        [XmlIgnore]
        public XscRawAttributeCollection RawAttributes
        {
            get
            {
                if (_rawAttributes == null) _rawAttributes = new XscRawAttributeCollection();
                return _rawAttributes;
            }
            set { _rawAttributes = value; }
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscRawAttributeCollection : ArrayList
    {
        public XscAttribute Add(XscAttribute obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscAttribute Add()
        {
            return Add(new XscAttribute());
        }

        public void Insert(int index, XscAttribute obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscAttribute obj)
        {
            base.Remove(obj);
        }

        new public XscAttribute this[int index]
        {
            get { return base[index] as XscAttribute; }
            set { base[index] = value; }
        }

        public XscRawAttributeCollection()
        {
        }
    }

    [XmlType(TypeName="Attribute",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscAttribute
    {
        [XmlElement("PUID", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _puid;

        [XmlIgnore]
        public bool Puid
        {
            get { return _puid; }
            set { _puid = value; }
        }

        [XmlElement("Index", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _index;

        [XmlIgnore]
        public ushort Index
        {
            get { return _index; }
            set { _index = value; }
        }

        public XscAttribute()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\ClientToolBase.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Reflection;
using ServerTestFramework.Utilities;
using Microsoft.Win32;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Base class for all client tool wrappers
    /// </summary>
    abstract public class ClientToolBase
    {
        public const string DefaultBasePath = @"D:\Webroot\xbltools";
        public readonly string ToolPath;

        private ProcessWrapper m_Process;
        private string m_RemoteServer = null;

        public ClientToolBase(string toolPath) : this(toolPath, false, null) { }

        public ClientToolBase(string toolPath, bool isRemote) : this(toolPath, isRemote, isRemote ? GetToolServer() : null) {}

        public ClientToolBase(string toolPath, bool isRemote, string remoteServer)
        {
            ToolPath = toolPath;

            if (isRemote)
            {
                m_RemoteServer = remoteServer;
                m_Process = new ProcessWrapper(Path.GetFileNameWithoutExtension(ToolPath) + " (Remote)", "psexec.exe");
                AcceptPsExecEula();
            }
            else
            {
                m_Process = new ProcessWrapper(Path.GetFileNameWithoutExtension(ToolPath), ToolPath);
            }
        }

        /// <summary>
        /// Standard Error for the completed process
        /// </summary>
        public string StandardError
        {
            get
            {
                return m_Process.Error;
            }
        }

        /// <summary>
        /// Standard Output for the completed process
        /// </summary>
        public string StandardOutput
        {
            get
            {
                return m_Process.Output;
            }
        }

        /// <summary>
        /// Gets the first server for the toolsmgmtsrv interface
        /// </summary>
        /// <returns>Server name</returns>
        private static string GetToolServer()
        {
            string[] toolServers = Global.XEnv.GetServerListByInterface("toolsmgmtsrv"); // TODO: Put this into xonline.common.config.Interface

            if (toolServers.Length < 1)
                throw new Exception("Could not find server for \"toolsmgmtsrv\" interface");

            return toolServers[0];
        }

        /// <summary>
        /// Sets the flag in the registry saying that we accepted the PsExec license agreement.
        /// Without this, the first execution pops up an Accept/Decline UI that currently can't
        /// be overridden on the command line.
        /// </summary>
        private void AcceptPsExecEula()
        {
            const string psExecSubKey = @"Software\Sysinternals\PsExec";
            const string psExecValueName = "EulaAccepted";

            RegistryKey psExecKey = Registry.CurrentUser.OpenSubKey(psExecSubKey, true);

            if (psExecKey == null)
            {
                psExecKey = Registry.CurrentUser.CreateSubKey(psExecSubKey);
            }

            int eulaAccepted = (int)psExecKey.GetValue(psExecValueName, 0);

            if (eulaAccepted != 1)
            {
                psExecKey.SetValue(psExecValueName, 1, RegistryValueKind.DWord);
            }
        }

        /// <summary>
        /// Executes the tool with the given arguments
        /// </summary>
        /// <param name="args">Arguments for the tool</param>
        /// <returns>Process exit code</returns>
        public int Run(string args)
        {
            if (String.IsNullOrEmpty(m_RemoteServer))
            {
                // Local run
                return m_Process.Run(args);
            }
            else
            {
                // Remote run, marshal real parameters to psexec
                return m_Process.Run(String.Format("\\\\{0} {1} {2}", m_RemoteServer, ToolPath, args));
            }
        }

        /// <summary>
        /// Executes the tool with the given arguments and throws an exception if the
        /// exit code is non-zero.
        /// </summary>
        /// <typeparam name="T">Type of exception to throw</typeparam>
        /// <param name="args">Arguments for the tool</param>
        /// <param name="message">Error message</param>
        public void RunThrowOnFailure<T>(string args, string message) where T : ProcessException
        {
            int exitCode = Run(args);

            if (exitCode != 0)
            {
                // Special case the scenario where psexec couldn't start the binary
                if (StandardError.Contains("could not start " + ToolPath))
                {
                    message = String.Format("Could not start {0} on server {1}.  Is the path correct?", ToolPath, m_RemoteServer);
                }

                // This preserves the pattern of each client tool wrapper specifying
                // its own Exception when the tool fails.  Having all tools simply
                // throw a ProcessException is much simpler and still readable, but
                // that is too big a change for now.
                T ex = (T)Activator.CreateInstance(typeof(T), message, StandardOutput);
                throw ex;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\EmulatorUtil.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for emulator.
    /// </summary>
    public class EmulatorUtil
    {
        public static bool IsEmulatorUp(string emulatorType)
        {            
            string url = null;
            if (String.IsNullOrEmpty(emulatorType))
            {
                return true;
            }
            string template = "http://"+ System.Net.Dns.GetHostName() +"/MusicNetEmulator/";
            switch (emulatorType.Trim().ToLower())
            {
                case "ppsaprofile":
                    url = template + "ppsaProfileEmulator.asmx";
                    break;
                case "ppsacredential":
                    url = template + "ppsaCredentialEmulator.asmx";                    
                    break;
                case "abch":
                    url = template + "abchEmulator.asmx";                    
                    break;
                case "aggregator":
                    url = template + "AggregatorEmulator.asmx";
                    break;
                case "bdk":
                    url = template + "BdkEmulator.asmx";
                    break;
                case "controller":
                    url = template + "Controller.asmx";
                    break;
                case "dmp":
                    url = template + "DMPEmulator.asmx";
                    break;
                case "multirating":
                    url = template + "MultiRatingEmulator.asmx";
                    break;
                case "musicnet":
                    url = template + "MusicNetEmulator.asmx";
                    break;
                case "nicknamelistener":
                    url = template + "NickNameListenerEmulator.asmx";
                    break;
                case "singlerating":
                    url = template + "SingleRatingEmulator.asmx";
                    break;
                case "ups":
                    url = template + "upsEmulator.asmx";
                    break;
                default:
                    break;
            }
            if (String.IsNullOrEmpty(url))
            {
                return true;
            }
            try
            {
                // Create a request to the passed URI.   
                HttpWebRequest req = (HttpWebRequest)WebRequest.Create(url);
                req.Credentials = CredentialCache.DefaultNetworkCredentials;

                // Get the response object.   
                HttpWebResponse webResponse = (HttpWebResponse)req.GetResponse();
                
                return true;
            }
            catch (Exception e)
            {
                Global.RO.Error(String.Format("Check emulator {0} failed and threw exception {1}.", emulatorType, e.Message));
                return false;
            }  
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\LiveOffer.cs ===
/*
TODO: 
	- Add 585207D1 Peg PC subscription to Positive Tests
	- add BitFilter Neg case: Filter set to 0 should error as well as multiple set (Schema error)
	- add Mis-sized PNG case
*/
using System;
using System.IO;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the LiveOffer tool.
	/// </summary>
	public class LiveOffer
	{
		private ProcessWrapper _liveOfferProcess;
		private const string _defaultLiveOfferPath = "D:\\webroot\\xbltools";
		public enum dbType {all, uodb, productdb, noflag};
		public bool noTransaction;

		public LiveOffer()
		{
			_liveOfferProcess = new ProcessWrapper("LiveOffer", Path.Combine(_defaultLiveOfferPath, "LiveOffer.exe"));
		}

		public LiveOffer(string liveOfferPath) : this()
		{
			_liveOfferProcess.ExecutablePath = Path.GetFullPath(liveOfferPath);
		}

		public string Output
		{
			get { return _liveOfferProcess.Output; }
		}

		/// <summary>
		/// Returns the appropriate string for the given dbType.
		/// </summary>
		public string DbTypeToString(dbType db) 
		{
            // Attribute not currently supported by LiveOffer. May come-back someday.
            /*
			switch (db) 
			{
				case dbType.uodb:
					return "-targetdb:uodb";
				case dbType.productdb:
					return "-targetdb:productdb";
				case dbType.all:
					return "-targetdb:all";
				case dbType.noflag:
			}
			throw new LiveOfferException("Invalid type(" + db + ") given to LiveOffer.cs::DbTypeToString");
            */

            return "";
		}
		/// <summary>
		/// Reloads the front doors.  Offers are cached and will not be seen unless the 
		/// this occurs--however, LiveOffer will by default reload the front doors after
		/// every prop.
		/// </summary>
		public void ReloadFrontDoors() 
		{
			string arguments = "-action:reload";
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Reload of front doors failed.", _liveOfferProcess.Output);			
		}
		/// <summary>
		/// Checks if the given XML file follows the format given in the file LiveOffer.xsd
		/// </summary>
		/// <param name="filePath">File to be validated.</param>
		public void Validate360Offer(string filePath) 
		{
			string arguments = String.Format("-action:validate -file:{0}", filePath);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Xbox 360 offer validation failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Checks if the given XML file follows the format given in the file Xbox1Offer.xsd
		/// </summary>
		/// <param name="filePath">File to be validated.</param>
		public void ValidateXboxOffer(string filePath)
		{
			string arguments = String.Format("-action:validatexbox -file:{0}", filePath);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Xbox offer validation failed.", _liveOfferProcess.Output);
		}

        /// <summary>
        /// Checks if a offer is propped.
        /// </summary>
        public static bool CheckIfOfferIsPropped(ulong offerID)
        {
            bool isPropped = false;
            try
            {
                string query = "select count(*) from t_offers WHERE bi_offer_id=" + (long)offerID;
                int rows = (int)UodbWS.ExecuteSQLSelectCount(query);
                if (rows != 0) isPropped = true;
            }
            catch (Exception e)
            {
                Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check offer " + offerID.ToString("x") + ": " + e.Message + "\nWill assume this indicates that it is not propped.");
            }
            return isPropped;
        }

		/// <summary>
		/// Places an Xbox360 offer file on the Live service.  This populates a large number of tables 
		/// that begin with uodb..t_offer.
		/// </summary>
		/// <param name="filePath">Path to the offer file.</param>
		/// <param name="titleId">Titleid the offer is related to.</param>
		/// <param name="targetDBs">Flag determining which DBs should be updated</param>
		/// <param name="overwriteDMPSettings">If they exist, clobber existing DMP settings.</param>
		public void Prop360Offer(string filePath, uint titleId, dbType targetDBs, bool overwriteDMPSettings) 
		{
			string arguments = String.Format("-action:prop -file:{0} -titleid:{1:x} {2} {3} {4}", filePath, titleId,
				DbTypeToString(targetDBs), overwriteDMPSettings ? "-overwriteDMPSettings" : "", noTransaction ? "-noTransaction":"");
			int res = _liveOfferProcess.Run(arguments);
			if (res != 0) /* || (grep some kind of error string in output) */
				{
				throw new LiveOfferException(String.Format("Prop of Xbox 360 offer failed. ({0})",res), _liveOfferProcess.Output);
				}
		}

		/// <summary>
		/// Places an Xbox1 offer file on the Live service.  This populates a distinctly different set of tables
		/// than in the XBox360 case.
		/// </summary>
		/// <param name="filePath">Path to the offer file.</param>
		/// <param name="titleId">Titleid the offer is related to.</param>
		/// <param name="targetDBs">Flag determining which DBs should be updated</param>
		/// <param name="overwriteDMPSettings">If they exist, clobber existing DMP settings.</param>
		public void PropXboxOffer(string filePath, uint titleId, dbType targetDBs, bool overwriteDMPSettings) 
		{
			string arguments = String.Format("-action:propxbox -file:{0} -titleid:{1:x} {2} {3} {4}", filePath, titleId,
				DbTypeToString(targetDBs), overwriteDMPSettings ? "-overwriteDMPSettings" : "", noTransaction ? "-noTransaction":"");
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Removes an offer from the Live service.  Requires an offerid.  This is only available on the
		/// debug build of LiveOffer.
		/// </summary>
		/// <param name="offerid">The offerId to remove.</param>
		public void NukeOffer(ulong offerid) {
			string arguments = String.Format("-action:nukeOffer -offerid:{0:x}", offerid);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}

		/// <summary>
		/// Removes all offers from the Live service under a certain title.  Requires a titleid.  This
		/// is only available on the debug build of LiveOffer.
		/// </summary>
		/// <param name="titleid">The titleId whose offers will be removed.</param>
		public void NukeAllOffers(uint titleid) {
			string arguments = String.Format("-action:nukeAllOffers -titleid:{0:x}", titleid);
			if (_liveOfferProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveOfferException("Prop of Xbox offer failed.", _liveOfferProcess.Output);
		}
		//automation for "nukealloffersforalltitles" is deliberately not included"
	}

	public class LiveOfferException : ProcessException
	{
		public LiveOfferException() : base("LiveOffer") {}
		public LiveOfferException(string message) : base("LiveOffer", message) {}
		public LiveOfferException(string message, Exception innerException) : base("LiveOffer", message, innerException) {}
		public LiveOfferException(string message, string output) : base("LiveOffer", message, output) {}
		public LiveOfferException(string message, string output, Exception innerException) :
			base("LiveOffer", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\StatsViews.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        // This gets set to a single string ID for the required rating column in all leaderboards.
        private ushort _ratingColumnStringId = 0;

        public uint AddStatsView(XboxLiveSubmissionProject xlast, resetType reset, ushort entryExpiration, ushort maxAttachments, bool hidden, bool arbitrated, bool top100)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.StatsViews.clsid)
            {
                CreateStatsViews(xlast);
            }

            StatsView newView = new StatsView();
            newView.clsid = StatsViewCLSID;
            newView.resetType = reset;
            newView.entryExpiration = entryExpiration;
            newView.maxAttachments = maxAttachments;
            newView.hidden = hidden;
            newView.arbitrated = arbitrated;
            newView.onlineOnly = false;
            newView.topEntries = top100 ? 100 : uint.MaxValue;
            newView.id = xlast.GameConfigProject.StatsViews.nextViewId;
            newView.friendlyName = String.Format("StatsView{0:d03}", newView.id);
            newView.viewType = "Leaderboard";
            newView.stringId = AddString(xlast, String.Format("{0} Name", newView.friendlyName));
            xlast.GameConfigProject.StatsViews.Add(newView);
            xlast.GameConfigProject.StatsViews.nextViewId++;

            // Every leaderboard must have a Rank column, a Gamer Name column and a Rating column
            AddStatsViewColumn(newView, "0x10008001", type.Last, false, false, (ushort)XLASTDefaultString.X_STRINGID_RANKCOL, 65535);
            AddStatsViewColumn(newView, "0x40008002", type.Last, false, false, (ushort)XLASTDefaultString.X_STRINGID_GAMERNAMECOL, 65533);
            AddStatsViewColumn(newView, "0x" + RATING_PROPERTY_ID.ToString("X8"), type.Last, false, true, _ratingColumnStringId, 65534);

            // If this is an Arcade title, add another column to be the one required Arcade Leaderboard column
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                string propertyId = AddProperty(xlast, XLASTPropertyType.Integer);
                ushort arcadeStringId = AddString(xlast, "Arcade Leaderboard Column");
                AddStatsViewColumn(FindStatsView(xlast, newView.id), propertyId, type.Last, false, false, arcadeStringId,
                    GetNextAttributeId(newView.Columns.FieldCollection), true, ArcadeLeaderboardSortType.Ascending, arcadeStringId);
            }

            return newView.id;
        }

        /// <summary>
        /// Adds a Context field to a StatsView (leaderboard)
        /// </summary>
        /// <param name="xlast">The xlast file object.</param>
        /// <param name="viewId">The ID of the StatView to which the column will be added.</param>
        /// <param name="contextId">The ID of the existing Context to use.</param>
        /// <param name="hidden">Flag indicating whether this column is hidden.</param>
        public void AddStatsViewColumn(XboxLiveSubmissionProject xlast, uint viewId, string contextId, bool hidden)
        {
            StatsView statsView = FindStatsView(xlast, viewId);
            if (statsView == null)
            {
                throw new StfException("Unable to find a StatsView with the id {0}", viewId);
            }

            ViewFieldType newField = new ViewFieldType();
            newField.ordinal = (ushort)statsView.Columns.FieldCollection.Count;
            newField.friendlyName = String.Format("StatsViewColumn{0:d03}", newField.ordinal);
            newField.stringId = AddString(xlast, newField.friendlyName + " Name");
            newField.hidden = hidden;
            newField.Context.id = UInt32.Parse(contextId.Substring(2), System.Globalization.NumberStyles.HexNumber);
            newField.attributeId = GetNextAttributeId(statsView.Columns.FieldCollection);

            statsView.Columns.FieldCollection.Add(newField);
        }

        /// <summary>
        /// Adds a Property field to a StatsView (leaderboard)
        /// </summary>
        /// <param name="xlast">The xlast file object.</param>
        /// <param name="viewId">The ID of the StatView to which the Property will be added.</param>
        /// <param name="propertyId">The ID of the existing Property to use.</param>
        /// <param name="aggregationType">The aggregation type to use for this column.</param>
        /// <param name="hidden">A flag indicating whether this column is hidden.</param>
        /// <param name="rank">A flag indicating whether this column is used for ranking.</param>
        public void AddStatsViewColumn(XboxLiveSubmissionProject xlast, uint viewId, string propertyId, type aggregationType, bool hidden, bool rank)
        {
            StatsView statsView = FindStatsView(xlast, viewId);
            if (statsView == null)
            {
                throw new StfException("Unable to find a StatsView with the id {0}", viewId);
            }

            ushort stringId = AddString(xlast, String.Format("StatsViewColumn{0:d03}", statsView.Columns.FieldCollection.Count));
            ushort attributeId = rank ? (ushort)65534 : GetNextAttributeId(statsView.Columns.FieldCollection);
            AddStatsViewColumn(statsView, propertyId, aggregationType, hidden, rank, stringId, attributeId);
        }

        /// <summary>
        /// Adds a number of StatsViews to an XLAST file.
        /// </summary>
        /// <param name="xlast">An XLAST file object.</param>
        /// <param name="count">The number of StatsViews to add to the XLAST file object.</param>
        public void AddStatsViews(XboxLiveSubmissionProject xlast, uint count)
        {
            int reset;
            ushort entryExpiration;
            ushort maxAttachments;
            bool hidden;
            bool arbitrated;
            bool top100;
            int columnCount;
            uint viewId;

            for (int i = 0; i < count; i++)
            {
                reset = _rnd.Next((int)resetType.Weekly, (int)resetType.Never + 1);
                entryExpiration = (ushort)_rnd.Next(0, ((int)ushort.MaxValue) + 1);
                maxAttachments = (ushort)_rnd.Next(0, ((int)ushort.MaxValue) + 1);
                hidden = (_rnd.Next(1, 101) > 90);          // 10% chance of being hidden
                arbitrated = (_rnd.Next(1, 101) > 60);      // 40% chance of being arbitrated
                top100 = (_rnd.Next(1, 101) > 50);          // 50% chance of being Top 100
                columnCount = _rnd.Next(0, 11);

                viewId = AddStatsView(xlast, (resetType)reset, entryExpiration, maxAttachments, hidden, arbitrated, top100);
                AddStatsViewColumns(xlast, viewId, columnCount);
            }
        }

        /// <summary>
        /// Adds a number of columns to a specified StatsView.
        /// </summary>
        /// <param name="xlast">An XLAST file object.</param>
        /// <param name="viewId">The ID os the StatsView to which the columns will be added.</param>
        /// <param name="count">The number of columns to add.</param>
        public void AddStatsViewColumns(XboxLiveSubmissionProject xlast, uint viewId, int count)
        {
            PropertyCollection properties = FindAvailableProperties(xlast);
            ContextCollection contexts = FindAvailableContexts(xlast);
            bool hidden = (_rnd.Next(1, 101) > 90);
            int index;

            // If there are no Contexts available for use, add some
            if (contexts.Count == 0)
            {
                AddContexts(xlast, 3, 4);
                contexts = FindAvailableContexts(xlast);
            }

            // If there are no Properties available for use, add some
            if (properties.Count == 0)
            {
                AddProperties(xlast, 5);
                properties = FindAvailableProperties(xlast);
            }

            for (int i = 0; i < count; i++)
            {
                if (_rnd.Next(1, 101) > 50)
                {
                    // Create a Context column
                    index = _rnd.Next(0, contexts.Count);
                    AddStatsViewColumn(xlast, viewId, contexts[index].id, hidden);
                }
                else
                {
                    // Create a Property column
                    index = _rnd.Next(0, properties.Count);
                    type aggregationType = (type)_rnd.Next((int)type.Min, (int)type.Last + 1);
                    AddStatsViewColumn(xlast, viewId, properties[index].id, aggregationType, hidden, false);
                }
            }
        }

        // Since every new leaderboard requires two well-known columns, this is provided to specify
        // the correct string ID and attribute ID for the columns.
        private void AddStatsViewColumn(
            StatsView statsView,
            string propertyId,
            type aggregationType,
            bool hidden,
            bool rank,
            ushort stringId,
            ushort attributeId)
        {
            AddStatsViewColumn(statsView, propertyId, aggregationType, hidden, rank, stringId, attributeId, false, ArcadeLeaderboardSortType.Ascending, 0);
        }
        
        private void AddStatsViewColumn(
            StatsView statsView,
            string propertyId,
            type aggregationType,
            bool hidden,
            bool rank,
            ushort stringId,
            ushort attributeId,
            bool arcadeLeaderboard,
            ArcadeLeaderboardSortType arcadeSort,
            ushort arcadeStringId)
        {
            ViewFieldType newField = new ViewFieldType();
            newField.ordinal = (ushort)statsView.Columns.FieldCollection.Count;
            newField.friendlyName = String.Format("StatsViewColumn{0:d03}", newField.ordinal);
            newField.stringId = stringId;
            newField.hidden = hidden;
            newField.Property.id = propertyId;
            newField.Property.Aggregation.type = aggregationType;
            newField.attributeId = attributeId;
            if (arcadeLeaderboard)
            {
                newField.arcadeLeaderboard = arcadeLeaderboard;
                newField.arcadeSort = arcadeSort;
                newField.arcadeStringId = arcadeStringId;
            }

            statsView.Columns.FieldCollection.Add(newField);
        }

        private void CreateStatsViews(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.StatsViews.clsid = StatsViewsCLSID;
            xlast.GameConfigProject.StatsViews.nextViewId = 1;

            // Add a string for the required Rating column
            _ratingColumnStringId = AddString(xlast, "RatingColumn_NAME", "Rating");

            // Arcade titles are the only ones that require a leaderboard
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                AddStatsViews(xlast, 1);
            }
        }

        private StatsView FindStatsView(XboxLiveSubmissionProject xlast, uint viewId)
        {
            foreach (StatsView view in xlast.GameConfigProject.StatsViews.StatsViewCollection)
            {
                if (view.id == viewId)
                    return view;
            }
            return null;
        }

        private ushort GetNextAttributeId(ViewFieldTypeCollection fields)
        {
            ushort attributeId = 0;
            foreach (ViewFieldType field in fields)
            {
                if ((short)field.attributeId > 0)
                    attributeId = field.attributeId;
            }
            return ++attributeId;
        }

        private ContextCollection FindAvailableContexts(XboxLiveSubmissionProject xlast)
        {
            ContextCollection contexts = new ContextCollection();

            // Walk the list of Contexts to find ones available to be leaderboard columns
            foreach (Context ctx in xlast.GameConfigProject.Contexts.ContextCollection)
            {
                uint id = UInt32.Parse(ctx.id.Substring(2), System.Globalization.NumberStyles.HexNumber);
                if ((id & 0x0000F000) == 0)
                {
                    contexts.Add(ctx);
                }
            }

            return contexts;
        }

        private PropertyCollection FindAvailableProperties(XboxLiveSubmissionProject xlast)
        {
            PropertyCollection properties = new PropertyCollection();

            // Walk the list of properties to find ones available to be leaderboard columns
            foreach (Property property in xlast.GameConfigProject.Properties.PropertyCollection)
            {
                uint id = UInt32.Parse(property.id.Substring(2), System.Globalization.NumberStyles.HexNumber);
                XLASTPropertyType type = (XLASTPropertyType)(id >> 28);
                id = id & 0x0000FFFF;
                if (id < 0x8000 && type != XLASTPropertyType.Float && type != XLASTPropertyType.DateTime)
                {
                    properties.Add(property);
                }
            }

            return properties;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\LocalizedStrings.cs ===
u s i n g   S y s t e m ; 
 
 u s i n g   S y s t e m . C o l l e c t i o n s . G e n e r i c ; 
 
 u s i n g   S y s t e m . I O ; 
 
 u s i n g   S y s t e m . X m l ; 
 
 u s i n g   S y s t e m . X m l . S e r i a l i z a t i o n ; 
 
 u s i n g   S y s t e m . T e x t ; 
 
 u s i n g   S e r v e r T e s t F r a m e w o r k . S T F T o o l s . C o n f i g F i l e s ; 
 
 
 
 n a m e s p a c e   S e r v e r T e s t F r a m e w o r k . S T F T o o l s 
 
 { 
 
         p u b l i c   e n u m   X L A S T D e f a u l t S t r i n g   :   u s h o r t 
 
         { 
 
                 X _ S T R I N G I D _ G A M E T Y P E   =   3 2 5 1 2 , 
 
                 X _ S T R I N G I D _ R A N K E D , 
 
                 X _ S T R I N G I D _ S T A N D A R D , 
 
                 X _ S T R I N G I D _ G A M E R N A M E , 
 
                 X _ S T R I N G I D _ R A N K C O L , 
 
                 X _ S T R I N G I D _ R A N K , 
 
                 X _ S T R I N G I D _ G A M E R N A M E C O L , 
 
                 X _ S T R I N G I D _ G A M E R _ Z O N E , 
 
                 X _ S T R I N G I D _ G A M E R _ C O U N T R Y , 
 
                 X _ S T R I N G I D _ L A N G U A G E , 
 
                 X _ S T R I N G I D _ G A M E R _ R A T I N G , 
 
                 X _ S T R I N G I D _ G A M E R _ M U , 
 
                 X _ S T R I N G I D _ G A M E R _ S I G M A , 
 
                 X _ S T R I N G I D _ G A M E R _ P U I D , 
 
                 X _ S T R I N G I D _ A F F I L I A T E _ V A L U E , 
 
                 X _ S T R I N G I D _ G A M E R _ H O S T N A M E , 
 
                 X _ S T R I N G I D _ P L A T F O R M _ T Y P E , 
 
                 X _ S T R I N G I D _ P L A T F O R M _ L O C K , 
 
                 X _ S T R I N G I D _ T I T L E N A M E   =   3 2 7 6 8 
 
         } 
 
 
 
         p u b l i c   p a r t i a l   c l a s s   X L A S T F a c t o r y 
 
         { 
 
                 p r i v a t e   D i c t i o n a r y < u s h o r t ,   L i s t < s t r i n g > >   _ d e f a u l t S t r i n g s ; 
 
                 p r i v a t e   X L A S T L a n g u a g e   _ d e f a u l t L a n g u a g e ; 
 
                 p r i v a t e   s t a t i c   s t r i n g [ ]   L o c a l e S t r i n g s   =   n e w   s t r i n g [ ] 
 
                         {   " e n - U S " ,   " f r - F R " ,   " d e - D E " ,   " i t - I T " ,   " j a - J P " ,   " k o - K R " ,   " p l - P L " ,   " p t - P T " ,   " r u - R U " ,   " e s - E S " ,   " z h - C H T "   } ; 
 
 
 
                 p r i v a t e   v o i d   I n i t L o c a l i z e d S t r i n g s ( ) 
 
                 { 
 
                         _ d e f a u l t S t r i n g s   =   n e w   D i c t i o n a r y < u s h o r t ,   L i s t < s t r i n g > > ( ) ; 
 
                         L i s t < s t r i n g >   t r a n s l a t i o n s ; 
 
 
 
                         / /   G a m e   T y p e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e   T y p e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T y p e   d e   j e u " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l t y p " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d i   g i o c o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000n0.z^" ) ; 
 
                         t r a n s l a t i o n s . A d d ( "   X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T y p   g r y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d e   J o g o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " "8?  83@K" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d e   p a r t i d a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " J2b^W" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E T Y P E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k e d 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k e d   M a t c h " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i e   a v e c   C l a s s e m e n t " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g l i s t e n - S p i e l " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i t a   C l a s s i f i c a t a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000  000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( "   X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P o j e d y n e k   r a n k i n g o w y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   p o r   R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " >41>@  ?>  C@>2=N" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   I g u a l a d a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}M
\" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K E D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   S t a n d a r d 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a y e r   M a t c h " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " M i s e   e n   R e l a t i o n " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " M i t s p i e l e r - S u c h e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i t a   d e l   G i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 00000  000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " t  X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P o j e d y n e k   g r a c z y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   p o r   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " >41>@  83@>:>2" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   d e   J u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[M
\" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ S T A N D A R D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   N a m e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   N a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m   d u   j o u e u r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l e r n a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   g i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 0000
T" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " t8  t" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N a z w a   g r a c z a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   d o   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " <O  83@>:0" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m b r e   d e l   j u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[Y
T" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R N A M E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   N a m e   C o l 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   N a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m   d u   j o u e u r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l e r n a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   g i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 0000
T" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " t8  t" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N a z w a   g r a c z a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   d o   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " <O  83@>:0" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m b r e   d e l   j u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[Y
T" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R N A M E C O L ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " E i n s t u f u n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a   o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 5AB>" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s i f i c a r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k   C o l 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " E i n s t u f u n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a   o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 5AB>" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s i f i c a r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K C O L ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   Z o n e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   Z o n e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ Z O N E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   C o u n t r y 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   C o u n t r y " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ C O U N T R Y ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   L a n g u a g e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " L a n g u a g e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ L A N G U A G E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   R a t i n g 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   R a t i n g " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ R A T I N G ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   M u 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   M u " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ M U ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   S i g m a 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   S i g m a " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ S I G M A ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   P U I D 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   P U I D " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ P U I D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   A f f i l i a t e   V a l u e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " A f f i l i a t e   V a l u e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ A F F I L I A T E _ V A L U E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   H o s t   N a m e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   H o s t   N a m e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ H O S T N A M E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   P l a t f o r m   T y p e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a t f o r m   T y p e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ P L A T F O R M _ T Y P E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   P l a t f o r m   L o c k 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a t f o r m   L o c k " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ P L A T F O R M _ L O C K ,   t r a n s l a t i o n s ) ; 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   C r e a t e L o c a l i z e d S t r i n g s ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T L a n g u a g e   d e f a u l t L a n g u a g e ) 
 
                 { 
 
                         i f   ( x l a s t   ! =   n u l l ) 
 
                         { 
 
                                 _ d e f a u l t L a n g u a g e   =   d e f a u l t L a n g u a g e ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s   =   n e w   L o c a l i z e d S t r i n g s ( ) ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . c l s i d   =   L o c a l i z e d S t r i n g s C L S I D ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . d e f a u l t L o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) d e f a u l t L a n g u a g e ] ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . A d d ( ) . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) d e f a u l t L a n g u a g e ] ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d   =   1 ; 
 
 
 
                                 u s h o r t [ ]   d e f I d s   =   ( u s h o r t [ ] ) E n u m . G e t V a l u e s ( t y p e o f ( X L A S T D e f a u l t S t r i n g ) ) ; 
 
                                 f o r e a c h   ( u s h o r t   i d   i n   d e f I d s ) 
 
                                 { 
 
                                         A d d D e f a u l t S t r i n g ( x l a s t ,   ( X L A S T D e f a u l t S t r i n g ) i d ,   d e f a u l t L a n g u a g e ) ; 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p u b l i c   v o i d   A d d L a n g u a g e ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         S u p p o r t e d L o c a l e   l o c a l e   =   n u l l ; 
 
 
 
                         i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n   = =   n u l l ) 
 
                         { 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n   =   n e w   S u p p o r t e d L o c a l e C o l l e c t i o n ( ) ; 
 
                         } 
 
                         e l s e 
 
                         { 
 
                                 f o r   ( i n t   i   =   0 ;   i   <   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . C o u n t ;   i + + ) 
 
                                 { 
 
                                         i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n [ i ] . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 l o c a l e   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n [ i ] ; 
 
                                                 b r e a k ; 
 
                                         } 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c a l e   = =   n u l l ) 
 
                         { 
 
                                 l o c a l e   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . A d d ( ) ; 
 
                                 l o c a l e . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ; 
 
 
 
                                 / /   G o   t h r o u g h   e a c h   s t r i n g   a n d   a d d   t h e   d e f a u l t   v a l u e   f o r   t h i s   n e w   l a n g u a g e 
 
                                 f o r e a c h   ( L o c a l i z e d S t r i n g   l o c S t r i n g   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n ) 
 
                                 { 
 
                                         A d d T r a n s l a t i o n ( l o c S t r i n g ,   l a n g ,   G e t D e f a u l t S t r i n g V a l u e ( l o c S t r i n g . i d ,   l a n g ) ) ; 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p u b l i c   u s h o r t   A d d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   s t r i n g   i n i t i a l V a l u e ) 
 
                 { 
 
                         r e t u r n   A d d S t r i n g ( x l a s t ,   " S t r i n g "   +   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d . T o S t r i n g ( " d 3 " ) ,   i n i t i a l V a l u e ) ; 
 
                 } 
 
 
 
                 p u b l i c   u s h o r t   A d d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   s t r i n g   f r i e n d l y N a m e ,   s t r i n g   i n i t i a l V a l u e ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         L o c a l i z e d S t r i n g   n e w S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . A d d ( ) ; 
 
                         n e w S t r i n g . c l s i d   =   L o c a l i z e d S t r i n g C L S I D ; 
 
                         n e w S t r i n g . i d   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d ; 
 
                         n e w S t r i n g . f r i e n d l y N a m e   =   f r i e n d l y N a m e ; 
 
 
 
                         f o r e a c h   ( S u p p o r t e d L o c a l e   l o c a l e   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n ) 
 
                         { 
 
                                 A d d T r a n s l a t i o n ( n e w S t r i n g ,   l o c a l e . l o c a l e ,   i n i t i a l V a l u e ) ; 
 
                         } 
 
 
 
                         x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d + + ; 
 
                         r e t u r n   n e w S t r i n g . i d ; 
 
                 } 
 
 
 
                 p u b l i c   v o i d   M o d i f y S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   u s h o r t   s t r i n g I d ,   X L A S T L a n g u a g e   l a n g ,   s t r i n g   n e w V a l u e ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         / /   F i n d   t h e   s t r i n g   i n   q u e s t i o n 
 
                         L o c a l i z e d S t r i n g   l o c S t r i n g   =   F i n d L o c a l i z e d S t r i n g ( x l a s t ,   s t r i n g I d ) ; 
 
                         i f   ( l o c S t r i n g   ! =   n u l l ) 
 
                         { 
 
                                 / /   U p d a t e   t h e   g i v e n   t r a n s l a t i o n   o f   t h i s   s t r i n g 
 
                                 f o r e a c h   ( T r a n s l a t i o n   t r a n s   i n   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n ) 
 
                                 { 
 
                                         i f   ( t r a n s . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 t r a n s . V a l u e   =   n e w V a l u e ; 
 
                                         } 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d D e f a u l t S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T D e f a u l t S t r i n g   d e f S t r i n g ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         L o c a l i z e d S t r i n g   l o c S t r i n g   =   n u l l ; 
 
 
 
                         / /   I f   t h e   s t r i n g   d o e s n ' t   y e t   e x i s t   i n   t h e   X L A S T   f i l e ,   c r e a t e   i t 
 
                         f o r   ( i n t   i   =   0 ;   i   <   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . C o u n t ;   i + + ) 
 
                         { 
 
                                 i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n [ i ] . i d   = =   ( u s h o r t ) d e f S t r i n g ) 
 
                                 { 
 
                                         l o c S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n [ i ] ; 
 
                                         b r e a k ; 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c S t r i n g   = =   n u l l ) 
 
                         { 
 
                                 l o c S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . A d d ( ) ; 
 
                                 l o c S t r i n g . c l s i d   =   L o c a l i z e d S t r i n g C L S I D ; 
 
                                 l o c S t r i n g . i d   =   ( u s h o r t ) d e f S t r i n g ; 
 
                                 l o c S t r i n g . f r i e n d l y N a m e   =   E n u m . G e t N a m e ( t y p e o f ( X L A S T D e f a u l t S t r i n g ) ,   d e f S t r i n g ) ; 
 
                         } 
 
 
 
                         / /   A d d   t h e   s p e c i f i e d   l a n g u a g e   t o   t h e   l i s t   o f   t r a n s l a t i o n s 
 
                         T r a n s l a t i o n   l o c T r a n s   =   n u l l ; 
 
                         i f   ( l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n   = =   n u l l ) 
 
                         { 
 
                                 l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n   =   n e w   T r a n s l a t i o n C o l l e c t i o n ( ) ; 
 
                         } 
 
                         e l s e 
 
                         { 
 
                                 f o r   ( i n t   i   =   0 ;   i   <   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . C o u n t ;   i + + ) 
 
                                 { 
 
                                         i f   ( l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n [ i ] . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 l o c T r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n [ i ] ; 
 
                                                 b r e a k ; 
 
                                         } 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c T r a n s   = =   n u l l ) 
 
                         { 
 
                                 l o c T r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . A d d ( ) ;   
 
                                 l o c T r a n s . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ; 
 
                                 l o c T r a n s . V a l u e   =   G e t D e f a u l t S t r i n g V a l u e ( ( u s h o r t ) d e f S t r i n g ,   l a n g ) ; 
 
                         } 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d T r a n s l a t i o n ( L o c a l i z e d S t r i n g   l o c S t r i n g ,   X L A S T L a n g u a g e   l a n g ,   s t r i n g   v a l u e ) 
 
                 { 
 
                         A d d T r a n s l a t i o n ( l o c S t r i n g ,   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ,   v a l u e ) ; 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d T r a n s l a t i o n ( L o c a l i z e d S t r i n g   l o c S t r i n g ,   s t r i n g   l o c a l e ,   s t r i n g   v a l u e ) 
 
                 { 
 
                         T r a n s l a t i o n   t r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . A d d ( ) ; 
 
                         t r a n s . l o c a l e   =   l o c a l e ; 
 
                         i f   ( v a l u e   ! =   n u l l ) 
 
                                 t r a n s . V a l u e   =   v a l u e ; 
 
                         e l s e 
 
                                 t r a n s . V a l u e   =   l o c a l e   +   "   s t r i n g . " ; 
 
                 } 
 
 
 
                 p r i v a t e   s t r i n g   G e t D e f a u l t S t r i n g V a l u e ( u s h o r t   s t r i n g I d ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         i f   ( _ d e f a u l t S t r i n g s . C o n t a i n s K e y ( s t r i n g I d ) ) 
 
                         { 
 
                                 L i s t < s t r i n g >   t r a n s l a t i o n s   =   _ d e f a u l t S t r i n g s [ s t r i n g I d ] ; 
 
                                 i f   ( t r a n s l a t i o n s . C o u n t   >   1 ) 
 
                                 { 
 
                                         r e t u r n   t r a n s l a t i o n s [ ( i n t ) l a n g ] ; 
 
                                 } 
 
                                 e l s e 
 
                                 { 
 
                                         r e t u r n   t r a n s l a t i o n s [ 0 ] ; 
 
                                 } 
 
                         } 
 
 
 
                         r e t u r n   L o c a l e S t r i n g s [ ( i n t ) l a n g ]   +   "   s t r i n g . " ; 
 
                 } 
 
 
 
                 p r i v a t e   L o c a l i z e d S t r i n g   F i n d L o c a l i z e d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   u s h o r t   s t r i n g I d ) 
 
                 { 
 
                         f o r e a c h   ( L o c a l i z e d S t r i n g   s t r   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n ) 
 
                         { 
 
                                 i f   ( s t r . i d   = =   s t r i n g I d ) 
 
                                         r e t u r n   s t r ; 
 
                         } 
 
                         r e t u r n   n u l l ; 
 
                 } 
 
         } 
 
 } 
 
 
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\ProductInformation.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTPlatform
    {
        Xbox360 = 2,
        PC = 4
    }

    public enum XLASTGenre : uint
    {
        Other = 101,
        Action,             // 102
        Adventure,          // 103
        Compilations,       // 104
        Family,             // 105
        Fighting,           // 106
        Music = 108,        // 108
        Platform,           // 109
        Racing,             // 110
        RolePlaying,        // 111
        Shooter,            // 112
        Simulation,         // 113
        Sports,             // 114
        Strategy,           // 115
        DemoTitle=701       // Genre required for Demo titles
    }

    public enum XLASTArcadeGenre : uint
    {
        Arcade = 11600,     // This one is required for all Arcade titles
        ActionArcade,       // 11601
        CardAndBoard,       // 11602
        CoinOpClassics,     // 11603
        PuzzleAndWord,      // 11604
        BarSports,          // 11605
        StrategyAndSims,    // 11606
        ConsoleClassics,    // 11607
        GameShows,          // 11608
        FamilyGames,        // 11609
        Trivia,             // 11610
        SportsGames,        // 11611
        PartyGames,         // 11612
        RacingGames,        // 11613
        RolePlayingGames,   // 11614
        CameraEnabled       // 11615
    }

    public enum XLASTFeature : uint
    {
        Camera = 1,
        CoOp,
        CustomSoundtrack,
        Dolby51,
        HardDriveEnhanced,
        HardDriveRequired,
        LiveAware,
        LiveClans,
        LiveCoOp,
        LiveDownloads,
        LiveFriends,
        LiveMessaging,
        LiveMultiplayer,
        LiveScoreboard,
        LiveServiceProxy,
        LiveStats,
        LiveTournaments,
        LiveVoice,
        LiveVoiceMessaging,
        MemoryUnit,
        MultiplayerVersus,
        Peripherals,
        PremiumOffers,
        SystemLink,
        UserCreatableContent,
        Xbox2Support,
        XboxSupport
    }

    public enum XLASTRating : uint
    {
        ESRB_EC = 1,
        ESRB_E,
        ESRB_E10,
        ESRB_T,
        ESRB_M,
        ESRB_AO,
        ESRB_RP,
        PEGI_3 = 11,
        PEGI_7,
        PEGI_12,
        PEGI_16,
        PEGI_18,
        PEGIFinland_3 = 21,
        PEGIFinland_7,
        PEGIFinland_12,
        PEGIFinland_16,
        PEGIFinland_18,
        PEGIPortugal_4 = 31,
        PEGIPortugal_6,
        PEGIPortugal_12,
        PEGIPortugal_16,
        PEGIPortugal_18,
        PEGIBBFC_3 = 41,
        PEGIBBFC_U,
        PEGIBBFC_7,
        PEGIBBFC_PG,
        PEGIBBFC_12,
        PEGIBBFC_15,
        PEGIBBFC_16,
        PEGIBBFC_18,
        CERO_AllAges = 51,
        CERO_12,
        CERO_15,
        CERO_17,
        CERO_Standard,
        CERO_18,
        USK_All = 61,
        USK_6,
        USK_12,
        USK_16,
        USK_NoYouth,
        OFLCAus_G = 71,
        OFLCAus_G8,
        OFLCAus_M15,
        OFLCAus_MA15,
        OFLCAus_RC,
        OFLCNZ_G = 81,
        OFLCNZ_G8,
        OFLCNZ_M15,
        OFLCNZ_MA15,
        OFLCNZ_RC,
        KMRB_All = 91,
        KMRB_12,
        KMRB_15,
        KMRB_18,
        Brazil_All = 101,
        Brazil_12,
        Brazil_14,
        Brazil_16,
        Brazil_18,
        FPB_All = 111,
        FPB_PG,
        FPB_10,
        FPB_13,
        FPB_16,
        FPB_18
    }

    public enum XLASTRatingSystem : uint
    {
        ESRB = 0,
        PEGI,
        PEGIFinland,
        PEGIPortugal,
        PEGIBBFC,
        CERO,
        USK,
        OFLCAustralia,
        OFLCNewZealand,
        KMRB,
        Brazil,
        FPB
    }

    public partial class XLASTFactory
    {
        public void SetPlatform(XboxLiveSubmissionProject xlast, XLASTPlatform platform)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Platform newPlatform = new Platform();
            newPlatform.name = Enum.GetName(typeof(XLASTPlatform), platform);
            newPlatform.id = (uint)platform;

            if (!xlast.GameConfigProject.ProductInformation.PlatformCollection.Contains(newPlatform))
            {
                xlast.GameConfigProject.ProductInformation.PlatformCollection.Add(newPlatform);
            }
        }

        public void AddGenre(XboxLiveSubmissionProject xlast, XLASTGenre genre)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Genre newGenre = new Genre();
            newGenre.genreId = (uint)genre * 1000000;

            // Only add the Genre if it doesn't already exist
            if (!ContainsGenre(xlast.GameConfigProject.ProductInformation.GenreCollection, newGenre.genreId))
            {
                xlast.GameConfigProject.ProductInformation.GenreCollection.Add(newGenre);
            }
        }

        public void AddArcadeGenre(XboxLiveSubmissionProject xlast, XLASTArcadeGenre arcadeGenre)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Genre newGenre = new Genre();
            newGenre.genreId = (uint)arcadeGenre * 10000;

            // Only add the Genre if it doesn't already exist
            if (!ContainsGenre(xlast.GameConfigProject.ProductInformation.GenreCollection, newGenre.genreId))
            {
                xlast.GameConfigProject.ProductInformation.GenreCollection.Add(newGenre);
            }
        }

        public void AddRating(XboxLiveSubmissionProject xlast, XLASTRating rating)
        {
            AddRating(xlast, rating, 0, null);
        }

        public void AddRating(XboxLiveSubmissionProject xlast, XLASTRating rating, uint imageId, string description)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            uint ratingSystem = (uint)((uint)rating / 10);
            Rating newRating = new Rating();
            newRating.ratingSystemId = ratingSystem;
            newRating.ratingId = (uint)rating;
            newRating.Description = description;
            newRating.imageId = imageId;
            if (!ContainsRating(xlast.GameConfigProject.ProductInformation.RatingCollection, newRating))
            {
                xlast.GameConfigProject.ProductInformation.RatingCollection.Add(newRating);
            }
        }

        public void AddAllRatings(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            // Add one of each rating system
            uint[] systems = (uint[])Enum.GetValues(typeof(XLASTRatingSystem));
            foreach (uint sys in systems)
            {
                AddRating(xlast, GetRandomRating((XLASTRatingSystem)sys));
            }
        }

        public void AddFeature(XboxLiveSubmissionProject xlast, XLASTFeature feature)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Feature newFeature = new Feature();
            newFeature.name = Enum.GetName(typeof(XLASTFeature), feature);
            newFeature.enabled = true;
            if (!ContainsFeature(xlast.GameConfigProject.ProductInformation.FeatureCollection, newFeature))
            {
                xlast.GameConfigProject.ProductInformation.FeatureCollection.Add(newFeature);
            }
        }

        public void AddFeatures(XboxLiveSubmissionProject xlast, int count)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            for (int i = 0; i < count; i++)
            {
                AddFeature(xlast, (XLASTFeature)_rnd.Next((int)XLASTFeature.Camera, (int)XLASTFeature.XboxSupport + 1));
            }
        }

        public void AddProductInformation(XboxLiveSubmissionProject xlast)
        {
            int i;
            int count;

            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                string desc;
                uint imageId;

                // Genres
                count = _rnd.Next(1, 8);
                for (i = 0; i < count; i++)
                {
                    AddArcadeGenre(xlast, GetRandomArcadeGenre());
                }

                // Ratings
                count = _rnd.Next(1, 11);
                for (i = 0; i < count; i++)
                {
                    if (_rnd.Next(1, 101) > 50)
                    {
                        desc = _rnd.GenerateUnicodeString(10, 128, false);
                    }
                    else
                    {
                        desc = "";
                    }
                    imageId = (uint)_rnd.Next(0, xlast.GameConfigProject.Images.Count);
                    AddRating(xlast, GetRandomRating(GetRandomRatingSystem()), imageId, desc);
                }
            }
            else
            {
                // Genres
                if (xlast.GameConfigProject.titleType != (uint)XLASTTitleType.DemoTitle)
                {
                    count = _rnd.Next(1, 8);
                    for (i = 0; i < count; i++)
                    {
                        AddGenre(xlast, GetRandomGenre());
                    }
                }

                // Ratings
                count = _rnd.Next(1, 21);
                for (i = 0; i < count; i++)
                {
                    AddRating(xlast, GetRandomRating(GetRandomRatingSystem()));
                }
            }

            // Features
            count = _rnd.Next(1, 14);
            AddFeatures(xlast, count);
        }

        private void CreateProductInformation(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.ProductInformation.developerStringId = AddString(xlast, "Developer String");
            xlast.GameConfigProject.ProductInformation.publisherStringId = AddString(xlast, "Publisher String");
            xlast.GameConfigProject.ProductInformation.sellTextStringId = AddString(xlast, "SellText String");
            xlast.GameConfigProject.ProductInformation.genreTextStringId = AddString(xlast, "Genre String");
            xlast.GameConfigProject.ProductInformation.offlinePlayersMax = 0;
            xlast.GameConfigProject.ProductInformation.livePlayersMax = 0;
            xlast.GameConfigProject.ProductInformation.systemLinkPlayersMax = 0;
            SetPlatform(xlast, XLASTPlatform.Xbox360);

            switch (xlast.GameConfigProject.titleType)
            {
                case (uint)XLASTTitleType.ArcadeTitle:
                    xlast.GameConfigProject.ProductInformation.arcadeDescriptionStringId = AddString(xlast, "Arcade Description String");
                    AddArcadeGenre(xlast, XLASTArcadeGenre.Arcade);
                    AddArcadeGenre(xlast, GetRandomArcadeGenre());
                    break;
                case (uint)XLASTTitleType.FullGame:
                    AddGenre(xlast, GetRandomGenre());
                    break;
                case (uint)XLASTTitleType.DemoTitle:
                    AddGenre(xlast, XLASTGenre.DemoTitle);
                    break;
                case (uint)XLASTTitleType.SystemTitle:
                    break;
            }
        }

        private XLASTGenre GetRandomGenre()
        {
            int val;

            do
            {
                val = _rnd.Next((int)XLASTGenre.Other, (int)XLASTGenre.Strategy + 1);
            } while (val == 107);

            return (XLASTGenre)val;
        }

        private XLASTArcadeGenre GetRandomArcadeGenre()
        {
            return (XLASTArcadeGenre)_rnd.Next((int)XLASTArcadeGenre.ActionArcade, (int)XLASTArcadeGenre.CameraEnabled + 1);
        }

        private XLASTRating GetRandomRating(XLASTRatingSystem ratingSystem)
        {
            int rating;
            int upperBound = 1;

            switch (ratingSystem)
            {
                case XLASTRatingSystem.PEGI:
                case XLASTRatingSystem.PEGIFinland:
                case XLASTRatingSystem.PEGIPortugal:
                case XLASTRatingSystem.USK:
                case XLASTRatingSystem.OFLCAustralia:
                case XLASTRatingSystem.OFLCNewZealand:
                case XLASTRatingSystem.Brazil:
                    upperBound = 6;
                    break;
                case XLASTRatingSystem.CERO:
                case XLASTRatingSystem.FPB:
                    upperBound = 7;
                    break;
                case XLASTRatingSystem.ESRB:
                    upperBound = 8;
                    break;
                case XLASTRatingSystem.PEGIBBFC:
                    upperBound = 9;
                    break;
            }
            rating = _rnd.Next(1, upperBound);
            return (XLASTRating)(((int)ratingSystem * 10) + rating);
        }

        private XLASTRatingSystem GetRandomRatingSystem()
        {
            return (XLASTRatingSystem)_rnd.Next((int)XLASTRatingSystem.ESRB, (int)XLASTRatingSystem.FPB + 1);
        }

        private bool ContainsGenre(GenreCollection genres, uint genreId)
        {
            foreach (Genre g in genres)
            {
                if (g.genreId == genreId)
                    return true;
            }
            return false;
        }

        private bool ContainsRating(RatingCollection ratings, Rating rating)
        {
            foreach (Rating r in ratings)
            {
                if (r.ratingSystemId == rating.ratingSystemId)
                    return true;
            }
            return false;
        }

        private bool ContainsFeature(FeatureCollection features, Feature feature)
        {
            foreach (Feature f in features)
            {
                if (String.Compare(f.name, feature.name, true) == 0)
                    return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\QuickEnforce.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;
namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the QuickEnforce tool.
	/// </summary>
	public class QuickEnforce
	{
		private ProcessWrapper _quickEnforceProcess;
		const string DefaultQuickEnforcePath = "D:\\webroot\\xbltools";  //where is it?

		public QuickEnforce()
		{
			_quickEnforceProcess = new ProcessWrapper("QuickEnforce", DefaultQuickEnforcePath);

		}
		public QuickEnforce(string quickEnforcePath) : this()
		{
			_quickEnforceProcess.ExecutablePath = Path.GetFullPath(quickEnforcePath);
		}

        public void EnforceUsers(string SQLServer, string EnforcementDB, string reportEmailAddy,
							string SMTP, int delayBetweenEnforcements, string custURL,
							string certPath) 
		{
			string commandArgs = "";
			commandArgs += String.Format("/SQLE {0}", SQLServer);
			commandArgs += String.Format(" /DBEN {0}", EnforcementDB);
			commandArgs += String.Format(" /MAIL {0}", reportEmailAddy);
			commandArgs += String.Format(" /SMTP {0}", SMTP);
			commandArgs += String.Format(" /WAIT {0}", delayBetweenEnforcements);
			commandArgs += String.Format(" /CURL {0}", custURL);
			commandArgs += String.Format(" /CERT {0}", certPath);
			if (_quickEnforceProcess.Run(commandArgs) != 0)
				throw new LiveStatsException("QuickEnforce failed.", _quickEnforceProcess.Output);
		}

	}

	
	public class QuickEnforceException : ProcessException
	{
		public QuickEnforceException() : base("QuickEnforce") {}
		public QuickEnforceException(string message) : base("QuickEnforce", message) {}
		public QuickEnforceException(string message, Exception innerException) : base("QuickEnforce", message, innerException) {}
		public QuickEnforceException(string message, string QuickEnforceOutput) : base("QuickEnforce", message, QuickEnforceOutput) {}
		public QuickEnforceException(string message, string QuickEnforceOutput, Exception innerException) :
			base("QuickEnforce", QuickEnforceOutput, message, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\XLASTFactory\XLASTFactory.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTTitleType
    {
        SystemTitle = 0,
        FullGame,
        DemoTitle,
        ArcadeTitle
    }

    public enum XLASTLanguage
    {
        English = 0,
        French,
        German,
        Italian,
        Japanese,
        Korean,
        Polish,
        Portuguese,
        Russian,
        Spanish,
        TraditionalChinese
    }

    public partial class XLASTFactory
    {
        public static XLASTSchemaVersion SchemaVersion00 = new XLASTSchemaVersion(1, 0);
        public static XLASTSchemaVersion SchemaVersion01 = new XLASTSchemaVersion(1, 1);
        public static XLASTSchemaVersion SchemaVersion02 = new XLASTSchemaVersion(1, 2);
        public static XLASTSchemaVersion SchemaVersion03 = new XLASTSchemaVersion(1, 3);
        
        // These are the CLSIDs used in XLAST files
        private static string GameConfigProjectCLSID = "{77E1A64F-5837-489B-AF8E-E4BA0FDACE7D}";
        private static string LocalizedStringsCLSID = "{BB833025-27FE-4BBD-87B6-DECD32039CED}";
        private static string LocalizedStringCLSID = "{F88D7D87-B2C0-452D-977D-297D70400AFF}";
        private static string PresenceCLSID = "{4EDB88EF-4341-49E4-B0AC-80CEA33F8EB8}";
        private static string PresenceModeCLSID = "{B94DA191-595F-40BB-99F1-3A78DAD90D9F}";
        private static string PropertiesCLSID = "{84CF9B0C-8512-4E46-B20F-D26A55A7AC6E}";
        private static string PropertyCLSID = "{43CE4FA7-6DE9-4F37-A929-49BFE63CBAAA}";
        private static string ContextsCLSID = "{7F6BA3D8-BB76-46CC-AD28-A4E0C8D6E1EF}";
        private static string ContextCLSID = "{7F343825-DBB8-4BC0-ACF2-533263622341}";
        private static string GameModesCLSID = "{A4C90625-725A-4DD2-B26B-E7F33F9DA808}";
        private static string ImagesCLSID = "{5B5F14C2-99F6-409A-BE85-15137524035C}";
        private static string GamerPicturesCLSID = "{3A23EFFB-83E1-415E-A7F2-1BD3004F83F5}";
        private static string AchievementsCLSID = "{42B49E61-A989-4D38-A1E3-74859D420C15}";
        private static string AchievementCLSID = "{3B0C2ED0-B7E7-4129-B35D-A90639E96DAC}";
        private static string StatsViewsCLSID = "{7FD2B836-2D93-490B-96C9-AEE936158AE8}";
        private static string StatsViewCLSID = "{6B341F2D-7A8A-43BC-AABF-949D6B9F28C7}";
        private static string MatchmakingCLSID = "{9D99E88A-2774-422A-8558-9B7487A37732}";
        private static string ConstantsCLSID = "{9DEE98C4-441C-4103-861B-464DF03B36B1}";
        private static string SchemaCLSID = "{7134D48F-9957-4515-850B-A7426E51345F}";
        private static string QueriesCLSID = "{50783AEA-2512-4F78-938B-F8DB911A0F9A}";
        private static string QueryCLSID = "{7FEE4CB1-F3F0-48BF-9CA1-F1B2306E32E3}";

        private RandomEx _rnd = new RandomEx();

        public XLASTFactory()
        {
            InitLocalizedStrings();
        }

        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            return xlast;
        }
        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema, XLASTTitleType titleType)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            xlast.GameConfigProject.titleType = (uint)titleType;
            return xlast;
        }
        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema, XLASTTitleType titleType,
            uint titleId, string titleName, XLASTLanguage defaultLanguage)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            xlast.GameConfigProject.titleType = (uint)titleType;
            xlast.GameConfigProject.titleName = titleName;
            xlast.GameConfigProject.titleId = "0x" + titleId.ToString("X8");

            CreateLocalizedStrings(xlast, defaultLanguage); // This one must come first
            CreateImages(xlast);
            CreateProductInformation(xlast);
            CreatePresence(xlast);
            CreateProperties(xlast);
            CreateContexts(xlast);
            CreateGameModes(xlast);
            CreateAchievements(xlast);
            CreateGamerPictures(xlast);
            CreateMatchmaking(xlast);
            if (titleType == XLASTTitleType.ArcadeTitle)
            {
                CreateStatsViews(xlast);
            }

            return xlast;
        }

        public void UpdateVersion(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            string[] ver = xlast.GameConfigProject.projectVersion.Split('.');
            xlast.GameConfigProject.projectVersion = string.Format("{0}.{1}.{2:d4}.{3}", ver[0], ver[1], (ushort.Parse(ver[2]) + 1), ver[3]);
        }

        /// <summary>
        /// Static method to deserialize an XLAST file into a hierarchy of objects.
        /// </summary>
        /// <param name="xlastFile">The name of the XLAST file to deserialize.</param>
        /// <returns>An XboxLiveSubmissionProject object that describes the XLAST file.</returns>
        //public static XboxLiveSubmissionProject FromXml(string xlastFile)
        //{
        //    if (xlastFile == null)
        //    {
        //        throw new ArgumentNullException("xlastFile");
        //    }

        //    if (!File.Exists(xlastFile))
        //    {
        //        return null;
        //    }

        //    StreamReader reader = null;
        //    XboxLiveSubmissionProject xlast = null;
        //    try
        //    {
        //        reader = new StreamReader(xlastFile);
        //        xlast = FromXml(reader);
        //    }
        //    finally
        //    {
        //        if (reader != null)
        //        {
        //            reader.Close();
        //        }
        //    }

        //    return xlast;
        //}

        /// <summary>
        /// Static method to deserialize an XLAST XML stream into a hierarchy of objects.
        /// </summary>
        /// <param name="xlastXml">A TextReader object that contains the raw XML of an XLAST file.</param>
        /// <returns>An XboxLiveSubmissionProject object that describes the XLAST XML data.</returns>
        //public static XboxLiveSubmissionProject FromXml(TextReader xlastXml)
        //{
        //    if (xlastXml == null)
        //    {
        //        return null;
        //    }

        //    XmlTextReader xmlReader = null;
        //    XmlSerializer serializer = null;
        //    XboxLiveSubmissionProject xlast = null;
        //    try
        //    {
        //        xmlReader = new XmlTextReader(xlastXml);
        //        serializer = new XmlSerializer(typeof(XboxLiveSubmissionProject));
        //        xlast = (serializer.Deserialize(xmlReader) as XboxLiveSubmissionProject);
        //    }
        //    finally
        //    {
        //        if (xmlReader != null)
        //        {
        //            xmlReader.Close();
        //        }
        //    }

        //    return xlast;
        //}

        //public static void ToXml(XboxLiveSubmissionProject xlast, string xlastFile)
        //{
        //    if (xlastFile == null)
        //    {
        //        throw new ArgumentNullException("xlastFile");
        //    }
        //    if (xlast == null)
        //    {
        //        throw new ArgumentNullException("xlast");
        //    }

        //    /*
        //     * We need to go through the pain of creating an XmlDocument from
        //     * the serialized XML stream so that when we can duplicate the
        //     * format of the XLAST file when it's saved from XLAST.
        //     */
        //    StringWriter sw = new StringWriter();
        //    XmlDocument doc = new XmlDocument();
        //    XmlTextWriter xtw = new XmlTextWriter(xlastFile, System.Text.Encoding.Unicode);
        //    xtw.Formatting = Formatting.Indented;
        //    xtw.Indentation = 1;
        //    xtw.IndentChar = (char)0x9;
        //    try
        //    {
        //        XmlSerializer serializer = new XmlSerializer(typeof(XboxLiveSubmissionProject));
        //        serializer.Serialize(sw, xlast);
        //        doc.LoadXml(sw.ToString());
        //        doc.Save(xtw);
        //    }
        //    finally
        //    {
        //        xtw.Close();
        //        sw.Close();
        //    }
        //}
    }

    public sealed class XLASTSchemaVersion
    {
        private byte _major;
        private byte _minor;

        public XLASTSchemaVersion(byte major, byte minor)
        {
            _major = major;
            _minor = minor;
        }

        public byte Major
        {
            get { return _major; }
        }

        public byte Minor
        {
            get { return _minor; }
        }

        public override string ToString()
        {
 	         return string.Format("{0}.{1:00}.0000.0", _major, _minor);
        }

        public override bool Equals(object obj)
        {
            if (obj is XLASTSchemaVersion)
            {
                return ((obj as XLASTSchemaVersion)._major == _major &&
                        (obj as XLASTSchemaVersion)._minor == _minor);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\LiveMatch.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveMatch tool.
    /// </summary>
    public class LiveMatch : ClientToolBase
    {
        private string _scriptFile = "";
        private bool _noReloadFrontDoors = false;
        private int _typeID = -1;
        private int _modeID = -1;
        private int _rrID = -1;

        public LiveMatch() : base(Path.Combine(DefaultBasePath, "LiveMatch.exe")) { }
        public LiveMatch(string liveMatchPath) : base(liveMatchPath) { }
        public LiveMatch(string liveMatchPath, bool isRemote) : base(liveMatchPath, isRemote) { }
        public LiveMatch(string liveMatchPath, bool isRemote, string remoteServer) : base(liveMatchPath, isRemote, remoteServer) { }

        /// <summary>
        /// Gets or sets the name of the SQL file generated when using the /script option.
        /// </summary>
        public string ScriptFile
        {
            get { return _scriptFile; }
            set { _scriptFile = (value == null ? "" : value); }
        }

        /// <summary>
        /// Gets or sets the typeid
        /// </summary>
        public int TypeID
        {
            get { return _typeID; }
            set { _typeID = value; }
        }

        /// <summary>
        /// Gets or sets the modeid
        /// </summary>
        public int ModeID
        {
            get { return _modeID; }
            set { _modeID = value; }
        }

        /// <summary>
        /// Gets or sets the rrid
        /// </summary>
        public int RRID
        {
            get { return _rrID; }
            set { _rrID = value; }
        }

        /// <summary>
        /// Turn on or off the /noreload option.  Defaults at false so that it does not use switch.
        /// </summary>
        public bool NoReloadFrontDoors
        {
            get { return _noReloadFrontDoors; }
            set { _noReloadFrontDoors = value; }
        }

        /// <summary>
        /// Deploys the matchmaking database(s) for the current title.
        /// </summary>
        /// <param name="dropTable">
        /// Flag indicating whether to drop the current match table.
        /// </param>
        /// <param name="scriptSQL">
        /// Flag indicating whether to write the SQL commands to a local file instead of to the databases.
        /// The name of the file can be specified using the ScriptFile property.
        /// </param>
        public void DeployMatchServer(uint titleId, bool dropTable, bool scriptSQL, bool removeMode , string newModeServer)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/DeployMatch /titleid:0x{0:x}", titleId);

            if (dropTable)
            {
                arguments.Append(" /droptable");
            }

            if (scriptSQL)
            {
                arguments.AppendFormat(" /script:{0}", _scriptFile);
            }

            // If the _noReloadFrontDoors is true, then specify /noreload
            if (_noReloadFrontDoors)
            {
                arguments.Append(" /noreload");
            }

            if (removeMode)
            {
                arguments.Append(" /removemode");
            }

            if ((newModeServer != null) && (newModeServer != ""))
            {
                arguments.AppendFormat(" /newmodeserver:{0}", newModeServer);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }


        /// <summary>
        /// Used for different migrations for an interface bucket
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForBucket
        /// 1 = MigrationStatusForBucket
        /// 2 = ExpediteMigrationForBucket
        /// 3 = EndMigrationForBucket
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForBucket</param>
        public void MatchMigrationBucket(uint titleID, int migrationState, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForBucket");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForBucket");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForBucket");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForBucket");
                    break;
                default:
                    break;
            }

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if (_rrID != -1)
            {
                arguments.AppendFormat(" /rrid:{0}", _rrID);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used for different title migrations
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForTitle
        /// 1 = MigrationStatusForTitle
        /// 2 = ExpediteMigrationForTitle
        /// 3 = EndMigrationForTitle
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForBucket</param>
        public void MatchMigrationTitle(uint titleID, int migrationState, string sourceServerName, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForTitle");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForTitle");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForTitle");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForTitle");
                    break;
                default:
                    break;
            }

            if ((sourceServerName != null) && (sourceServerName != ""))
            {
                arguments.AppendFormat(" /source:{0}", sourceServerName);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        #region ServerMigrationCutForFall
        /*
        /// <summary>
        /// Used for different migrations for a server migration
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="migrationState">
        /// 0 = StartMigrationForServer
        /// 1 = MigrationStatusForServer
        /// 2 = ExpediteMigrationForServer
        /// 3 = EndMigrationForServer
        /// </param>
        /// <param name="destServerName">Destination server, only required for StartMigrationForServer</param>
        public void MatchMigrationServer(uint titleID, int migrationState, string sourceServerName, string destServerName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/titleid:0x{0:x}", titleID);

            switch (migrationState)
            {
                case 0:
                    arguments.Append(" /StartMigrationForServer");
                    break;
                case 1:
                    arguments.Append(" /MigrationStatusForServer");
                    break;
                case 2:
                    arguments.Append(" /ExpediteMigrationForServer");
                    break;
                case 3:
                    arguments.Append(" /EndMigrationForServer");
                    break;
                default:
                    break;
            }

            if ((sourceServerName != null) && (sourceServerName != ""))
            {
                arguments.AppendFormat(" /source:{0}", sourceServerName);
            }

            if ((destServerName != null) && (destServerName != ""))
            {
                arguments.AppendFormat(" /dest:{0}", destServerName);
            }

            if (_liveMatchProcess.Run(arguments.ToString()) != 0)
                throw new LiveMatchException("Matchmaking configuration failed.", _liveMatchProcess.Output);
        }
        */
        #endregion

        /// <summary>
        /// Used for adding a RR bucket to an existing type/mode
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        /// <param name="serverName">The server that is going to be added for round robin</param>
        public void MatchAddRRBucket(uint titleID, string serverName)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/AddRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if ((serverName != null) && (serverName != ""))
            {
                arguments.AppendFormat(" /server:{0}", serverName);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used to begin draining the top round robined bucket.  Draining buckets no longer add
        /// sessions to them.
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        public void MatchDrainTopRRBucket(uint titleID)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/drainTopRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }

        /// <summary>
        /// Used to begin draining the top round robined bucket.  Draining buckets no longer add
        /// sessions to them.
        /// </summary>
        /// <param name="titleID">TitleId used for migration</param>
        public void MatchRemoveTopRRBucket(uint titleID, bool force)
        {
            StringBuilder arguments = new StringBuilder(128);

            arguments.AppendFormat("/removeTopRRBucket /titleid:0x{0:x}", titleID);

            if (_typeID != -1)
            {
                arguments.AppendFormat(" /type:{0}", _typeID);
            }

            if (_modeID != -1)
            {
                arguments.AppendFormat(" /mode:{0}", _modeID);
            }

            if (force)
            {
                arguments.Append(" /force");
            }

            RunThrowOnFailure<LiveMatchException>(arguments.ToString(), "Matchmaking configuration failed.");
        }


        /// <summary>
        /// Adds a new matchmaking server.
        /// </summary>
        /// <param name="serverName">
        /// Name of the server to which matchmaking tables and queries will be added.
        /// </param>
        public void AddMatchServer(uint xboxtitleID, string serverName)
        {
            RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /add:{1}", xboxtitleID, serverName), "Failed to add match server.");
        }

        /// <summary>
        /// Deletes an existing matchmaking server.
        /// </summary>
        /// <param name="serverName">
        /// Name of the server to remove from the match titles table.
        /// </param>
        public void DeleteMatchServer(uint xboxtitleID, string serverName)
        {
            RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /delete:{1}", xboxtitleID, serverName), "Failed to delete match server.");
        }

        /// <summary>
        /// Allows direct passing of Arguments on command line to LiveMatch, primarily used for negative testing.
        /// </summary>
        /// <param name="arguments">String to pass to LiveMatch</param>
        public void RunLiveMatch(string arguments)
        {
            RunThrowOnFailure<LiveMatchException>(arguments, "LiveMatch failed");
        }

        /// <summary>
        /// Static method for running Live Match with the default settings of titleid and the droptable option.
        /// </summary>
        /// <param name="titleID">The TitleID to which you want to run LiveMatch for</param>
        public static void RunLiveMatchDefault(uint titleID)
        {
            LiveMatch liveMatch = new LiveMatch();
            liveMatch.RunThrowOnFailure<LiveMatchException>(String.Format("/titleid:0x{0:x} /droptable", titleID), "Live Match Default failed.");
        }

    }

    public class LiveMatchException : ProcessException
    {
        public LiveMatchException(string message, string output) : base("LiveMatch", message, output) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\LiveContent.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the LiveContent tool.
	/// </summary>
	public class LiveContent
	{
		
		private ProcessWrapper _liveContentProcess;
		const string _defaultLiveContentPath = "D:\\webroot\\xbltools";
	
		//Info about the files to be propped
		private string _packagePath = "";
		private uint _titleId = 0;
		private string _offerPath = "";
		private ulong _offerId = 0;
		private string _offerPath2 = "";
		private ulong _offerId2 = 0;

		//flag arguments
		private string _isDefaultOffer = "";
	        private string _useDefaultOffer = "";
		private const string _overwrite = "/overwrite";  //This should always be on.
		private string _sites = "/site:1";
		private string _startDateFlag = "";
		private string _endDateFlag = "";
		private string _shares = "";
		private string _xrls = "";
		
		public enum updateType {selective, global, noflag};
		private string _updateFlag = "";
			
		public enum dbType {all, uodb, productdb, noflag};
		private string _targetFlag = "";

        public enum platformType { xbox1, xenon, pc };

		public LiveContent()
		{
			_liveContentProcess = new ProcessWrapper("LiveContent", Path.Combine(_defaultLiveContentPath, "LiveContent.exe"));
		}

		/// <summary>
		/// Define a non-default location for the LiveContent exe.  This location includes the exe in the path.
		/// </summary>
		/// <param name="liveContentPath">
		/// Path to the executable, including the exe filename.
		/// </param>
		public LiveContent(string liveContentPath) : this()
		{
			_liveContentProcess.ExecutablePath = Path.GetFullPath(liveContentPath);
		}

		public int Timeout {
			get { return _liveContentProcess.ExecutionTimeout; }
			set { _liveContentProcess.ExecutionTimeout = value; }
		}

		/// <summary>
		/// Gets the output after the LiveContent process has been run.
		/// </summary>
		public string Output
		{
			get { return _liveContentProcess.Output; }
		}

		/// <summary>
		/// Gets or sets the /_isDefaultOffer flag for a future run of LiveContent.
		/// </summary>
		public bool IsDefaultOffer
		{
			get { return (_isDefaultOffer != "");  }
			set { _isDefaultOffer = value ? "/isdefaultOffer:yes" : ""; }
		}

        /// <summary>
        /// Gets or sets the /usedefaultoffer flag for a future run of LiveContent
        /// </summary>
        public bool UseDefaultOffer
        {
            get { return (_useDefaultOffer != ""); }
            set { _useDefaultOffer = value ? "/usedefaultoffer" : ""; }
        }

		/// <summary>
		/// Gets or sets the site flag for a future run of LiveContent.
		/// </summary>
		public string Sites
		{
			get { return _sites;  }
			set { _sites = value; }
		}

		/// <summary>
		/// Gets or sets the start date flag for a future run of LiveContent.
		/// </summary>
		public string StartDateFlag
		{
			get { return _startDateFlag;  }
			set { _startDateFlag = value; }
		}

		/// <summary>
		/// Gets or sets the end date flag for a future run of LiveContent.
		/// </summary>
		public string EndDateFlag
		{
			get { return _endDateFlag;  }
			set { _endDateFlag = value; }
		}

		/// <summary>
		/// Gets or sets the _shares flag for a future run of LiveContent.
		/// </summary>
		public string Shares
		{
			get { return _shares;  }
			set { _shares = value; }
		}

		/// <summary>
		/// Gets or sets the _sites flag for a future run of LiveContent.
		/// </summary>
		public string Xrls
		{
			get { return _xrls;  }
			set { _xrls = value; }
		}

		/// <summary>
		/// Sets the update flag for a future run of LiveContent.
		/// </summary>
		/// <param name="type">
		/// Possible choices for the /update: option.
		/// </param>
		public void setUpdateFlag(updateType type)
		{
			switch (type) 
			{
				case updateType.selective:
					_updateFlag = "/update:selective";
					break;
				case updateType.global:
					_updateFlag = "/update:full";
					break;
				case updateType.noflag:
					_updateFlag= "";
					break;
			}
		}

		/// <summary>
		/// Sets the package and associated titleID for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /package: argument.
		/// </param>
		/// <param name="_titleId">
		/// OfferId which will be passed in the /titleid: argument.
		/// </param>
		public void SetPackageFile(string path, uint _titleId) 
		{
			_packagePath = path;
			this._titleId=_titleId;
		}
		
		/// <summary>
		/// Sets the optional first offer and its associated offerID
		/// for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /offerfile: argument.
		/// </param>
		/// <param name="_offerId">
		/// OfferId which will be passed in the /offerid: argument.
		/// </param>
		public void SetOfferFile(string path, ulong _offerId) 
		{
			_offerPath = path;
			this._offerId = _offerId;
		}

		/// <summary>
		/// Sets the optional second offer and its associated offerID
		/// for a future run of LiveContent.
		/// </summary>
		/// <param name="path">
		/// File path which will be passed in the /offerfile2: argument.
		/// </param>
		/// <param name="_offerId">
		/// OfferId which will be passed in the /offerid2: argument.
		/// </param>
		public void SetOfferFile2(string path, ulong _offerId)
		{
			_offerPath2 = path;
			this._offerId2=_offerId;
		}

		/// <summary>
		/// Sets the _targetFlag string from the given dbType.
		/// </summary>
		/// <param name="selectedDB">
		/// Possible choices for the /targetDB: option.
		/// </param>
		public void setTargetFlag(dbType selectedDB) 
		{
			switch (selectedDB)
			{
				case dbType.uodb:
					_targetFlag = "/targetdb:uodb";
					break;
				case dbType.productdb:
					_targetFlag = "/targetdb:productdb";
					break;
				case dbType.all:
					_targetFlag = "/targetdb:all";
					break;
				case dbType.noflag:
					_targetFlag = "";
					break;
			}
		}
		/// <summary>
		/// Returns a combined string of all the flags used when propping 
		/// content(and not autoupdates).  If in the future flags are added, they should be 
		/// added to this string as well.
		/// </summary>
		private string CombineFlagsForContent() 
		{
			return _isDefaultOffer + " " +
		        _useDefaultOffer + " " +
				_overwrite + " " +
				_sites + " " +
				_startDateFlag + " " +
				_endDateFlag + " " +
				_updateFlag + " " +
				_targetFlag;
		}

		/// <summary>
		/// Expects SetPackageFile to be set.  Optionally expects SetOfferFile, SetOfferFile2, 
		/// IsDefaultOffer, etc. to be called to set other parameters.  WARNING:Content files
		/// require an offer file, and should not be run without them.
		/// </summary>
		public void Deploy360Package() 
		{
			string arguments = "/action:build ";
			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} ", _packagePath, _titleId); }

			if (_offerPath != "" && !UseDefaultOffer) 
			{
				arguments += String.Format("/offerfile:{0} /offerid:{1:x} ", _offerPath, _offerId);
			}

			if (_offerPath2 != "" && !UseDefaultOffer)
			{
				arguments += String.Format("/offerfile2:{0} /offerid2:{1:x} ", _offerPath2, _offerId2);
			}
			arguments += CombineFlagsForContent();

			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox360 Content or AutoUpdate failed.", _liveContentProcess.Output);			
		}

		/// <summary>
		/// Expects SetPackageFile to be set.  Optionally expects SetOfferFile and
		/// IsDefaultOffer to be called to set other parameters.
		/// </summary>
		public void DeployXbox1Content() 
		{
			string arguments = "/action:xbox1content ";

			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} ", _packagePath, _titleId); }

			if (_offerPath != "") 
			{
				arguments += String.Format("/offerfile:{0} /offerid:{1:x} ", _offerPath, _offerId);
			}
			arguments += CombineFlagsForContent();

			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox1 Content failed.", _liveContentProcess.Output);			
		}		

		/// <summary>
		/// Deploys an xbox1 AutoUpdate.  This expects SetPackageFile to be called beforehand.
		/// Arguments it does not use will be dropped.
		/// </summary>
		public void DeployXbox1AutoUpdate() 
		{
			string arguments = "/action:xbox1update ";
			if ((_packagePath== "") || (_titleId == 0)) 
			{
				//TODO: error out somehow.
			} 
			else { arguments += String.Format("/package:{0} /titleid:0x{1:x} " + _sites + " " + _updateFlag + " ", _packagePath, _titleId); }
			arguments += _overwrite + " ";
		
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Prop of Xbox1 AutoUpdate failed.", _liveContentProcess.Output);			
		}

		/// <summary>
		/// Converts a selective update into a global autoupdate.
		/// </summary>
		/// <param name="_titleId">
		/// The titleid to apply this change.
		/// </param>
		/// <param name="oldVersion">
		/// The version number that the selective update begins.
		/// </param>
		/// <param name="newVersion">
		/// The version number to which the selective update will update.
		/// </param>
        /// <param name="platform">
        /// The platform this update applies.
        /// </param>
        public void MakeAutoUpdateFull(uint titleId, uint oldVersion, uint newVersion, platformType platform) 
		{
			string arguments = "/action:makefull ";
			arguments += String.Format("/titleid:0x{0:x} /package:{1:x}{2:x} ", titleId, Hex8(oldVersion), Hex8(newVersion));
            switch (platform)
            {
                case platformType.xbox1:
                    arguments += "/platform:xbox1 ";
                    break;
                case platformType.xenon:
                    arguments += "/platform:xenon ";
                    break;
                case platformType.pc:
                    arguments += "/platform:pc ";
                    break;
            }
			arguments += _sites;
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Attempt to make selective update a global one failed.", _liveContentProcess.Output);
		}

        /// <summary>
        /// Makes a zero paded hex value.  ie 00000101
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        private string Hex8(uint value)
        {
            string newVal;
            newVal = String.Format("0000000{0:x}", value);
            return newVal.Substring(newVal.Length - 8);
        }

		/// <summary>
		/// Runs LiveContent with a string of command-line arguments and nothing else.
		/// </summary>
		/// <param name="arguments">
		/// String of command line arguments.
		/// </param>
		public void RunWithOnlyStringArguments(string arguments) 
		{
			if (_liveContentProcess.Run(arguments) != 0) /* || (grep some kind of error string in output) */
				throw new LiveContentException("Run with specific user arguments failed.", _liveContentProcess.Output);			
		}
	}
	
	public class LiveContentException : ProcessException
	{
		public LiveContentException() : base("LiveContent") {}
		public LiveContentException(string message) : base("LiveContent", message) {}
		public LiveContentException(string message, Exception innerException) : base("LiveContent", message, innerException) {}
		public LiveContentException(string message, string output) : base("LiveContent", message, output) {}
		public LiveContentException(string message, string output, Exception innerException) :
			base("LiveContent", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\SPUT.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running SPUT.
	/// </summary>
	public class SPUT
	{
        const string DefaultSPUTPath = "D:\\webroot\\xbltools";

        private ProcessWrapper _SPUTProcess;
        private string _csvFile = "";

        public SPUT()
		{
            _SPUTProcess = new ProcessWrapper("SPUT", Path.Combine(DefaultSPUTPath, "SPUT.exe"));
        }

        public SPUT(string toolPath) : this()
        {
        _SPUTProcess.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to SPUT
        /// </summary>
        public string SPUTPath
        {
            get { return _SPUTProcess.ExecutablePath; }
            set { _SPUTProcess.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets or sets the CSV File to use when running SPUT.  Can be NULL.
        /// </summary>
        public string CSVFile
        {
            get { return _csvFile; }
            set { _csvFile = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of SPUT.
        /// </summary>
        public string Output
        {
            get { return _SPUTProcess.Output; }
        }

        /// <summary>
        /// Writes the titleID for the specified serialNum to the table
        /// </summary>
        /// <param name="serialNum">The serial number of the Xbox</param>
        /// <param name="titleID">The title ID or value to set.  Must have length of 1,4 or 8.</param>
        public void ChangeTitleID(string serialNum, string titleID)
        {
            string args = String.Format("/serialNum:{0} /titleid:{1}", serialNum, titleID);
            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

        /// <summary>
        /// Lookup the titleID associated with an xbox.
        /// </summary>
        /// <param name="serialNum">The serial number of the Xbox</param>
        /// <returns>Output returned from SPUT.</returns>
        public string DumpTitleID(string serialNum)
        {
            string titleID;
            string args = String.Format("/serialNum:{0} /dump", serialNum);
            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
            titleID = _SPUTProcess.Output;
            titleID = titleID.Substring(titleID.IndexOf(":")+1).Trim();
            return titleID;
        }

        /// <summary>
        /// Runs SPUT specifying CSV File
        /// </summary>
        /// <param name="fileName">CSV file to be used</param>
        public void RunSPUTFile(string fileName)
        {
            RunSPUTFile(fileName, null);
        }

        /// <summary>
        /// Runs SPUT specifying File that is set in CSVFIle Property
        /// </summary>
        public void RunSPUTFile()
        {
            RunSPUTFile(_csvFile, null);
        }

        /// <summary>
        /// Runs SPUT specifying File and TitleID to use
        /// </summary>
        /// <param name="fileName">CSV File of Serial numbers</param>
        /// <param name="titleID">Title ID to use or override</param>
        public void RunSPUTFile(string fileName, string titleID)
        {
            string args;
            if (titleID == null)
            {
                args = String.Format("/file:{0}", fileName);
            }
            else
            {
                args = String.Format("/file:{0} /titleid:{1}", fileName, titleID);
            }

            if (_SPUTProcess.Run(args) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

        /// <summary>
        /// Allows running SPUT with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling SPUT.</param>
        public void RunSPUT(string arguments)
        {
            if (_SPUTProcess.Run(arguments) != 0)
            {
                throw new SPUTException("SPUT Failed.", _SPUTProcess.Output);
            }
        }

	}

    public class SPUTException : ProcessException
    {
        public SPUTException() : base("SPUT") {}
        public SPUTException(string message) : base("SPUT", message) {}
        public SPUTException(string message, Exception innerException) : base("SPUT", message, innerException) {}
        public SPUTException(string message, string output) : base("SPUT", message, output) {}
        public SPUTException(string message, string output, Exception innerException) :
            base("SPUT", message, output, innerException) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\SystemCheck.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the SystemCheck tool.
    /// </summary>
    public class SystemCheck
    {
        const string DefaultSystemCheckPath = "D:\\webroot\\xbltools";
        const string DefaultThreads = "5";
        const string DefaultTimeout = "60000";

        private string _configfilePath = "";
        private string _outfilePath = "";
        private ProcessWrapper _systemCheckProcess;
        private Report _report;

        public SystemCheck()
        {
            _systemCheckProcess = new ProcessWrapper("SystemCheck", Path.Combine(DefaultSystemCheckPath, "SystemCheck.exe"));
            _report = new Report("SystemCheck");
        }

        public SystemCheck(string systemCheckPath)
            : this()
        {
            SystemCheckPath = systemCheckPath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the SystemCheck executable.
        /// </summary>
        public string SystemCheckPath
        {
            get { return _systemCheckProcess.ExecutablePath; }
            set
            {
                _systemCheckProcess.ExecutablePath = Path.GetFullPath(value);
                _systemCheckProcess.WorkingDirectory = Path.GetDirectoryName(_systemCheckProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for SystemCheck
        /// </summary>
        public string WorkingDirectory
        {
            get { return _systemCheckProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _systemCheckProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _systemCheckProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the number of milliseconds to allow LiveStats to run before killing the process.
        /// </summary>
        public int Timeout
        {
            get { return _systemCheckProcess.ExecutionTimeout; }
            set { _systemCheckProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Config file used during SystemCheck running 
        /// </summary>
        public string ConfigFilePath
        {
            get { return _configfilePath; }
            set
            {
                if (value != null)
                {
                    _configfilePath = Path.GetFullPath(value);
                }
                else
                {
                    _configfilePath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Output file used during SystemCheck running 
        /// </summary>
        public string OutFilePath
        {
            get { return _outfilePath; }
            set
            {
                if (value != null)
                {
                    _outfilePath = Path.GetFullPath(value);
                }
                else
                {
                    _outfilePath = "";
                }
            }
        }

        /// <summary>
        /// Gets the output text from the most recent run of SystemCheck.
        /// </summary>
        public string Output
        {
            get { return _systemCheckProcess.Output; }
        }

        /// <summary>
        /// Runs SystemCheck with /reloadfd parameter to reload the front doord.
        /// </summary>
        public void Reloadfd()
        {
            Reloadfd("");
        }

        /// <summary>
        /// Runs SystemCheck with /reloadfd parameter to reload the front doord.
        /// </summary>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void Reloadfd(string timeout)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/reloadfd");

            if (timeout != "")
            {
                arguments.AppendFormat(" /timeout:{0}", timeout);
            }

            exitCode = _systemCheckProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _report.Debug(_systemCheckProcess.Output);
            }
            else
            {
                throw new SystemCheckException("SystemCheck failed to Reload the Front Doors.", _systemCheckProcess.Output);
            }
        }

        /// <summary>
        /// Runs SystemCheck with a configfile and outputfile.
        /// </summary>
        public void CallUrl()
        {
            CallUrl(DefaultThreads, DefaultTimeout);
        }

        /// <summary>
        /// Runs SystemCheck with a configfile and outputfile.
        /// </summary>
        /// <param name="threads"># of threads to speciffy with the /threads parameter. Optional.</param>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void CallUrl(uint threads, uint timeout)
        {
            CallUrl(threads.ToString(), timeout.ToString());
        }

        /// <summary>
        /// Runs SystemCheck with a configfile, # of threads, timout, and outputfile.
        /// </summary>
        /// <param name="threads"># of threads to speciffy with the /threads parameter. Optional.</param>
        /// <param name="timeout">timeout (in ms) to specify with the /timeout parameter. Optional.</param>
        public void CallUrl(string threads, string timeout)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/configfile:{0} /threads:{1} /timeout:{2}", _configfilePath, threads, timeout);

            if (_outfilePath != "")
            {
                arguments.AppendFormat(" /outfile:{0}", _outfilePath);
            }

            exitCode = _systemCheckProcess.Run(arguments.ToString());
            // SystemCheck returns 1 on success and -1 on failure.
            if (exitCode != 1)
            {
                throw new SystemCheckException("SystemCheck failed to run.", _systemCheckProcess.Output);
            }
        }


    }

    public class SystemCheckException : ProcessException
    {
        public SystemCheckException() : base("SystemCheck") { }
        public SystemCheckException(string message) : base("SystemCheck", message) { }
        public SystemCheckException(string message, Exception innerException) : base("SystemCheck", message, innerException) { }
        public SystemCheckException(string message, string output) : base("SystemCheck", message, output) { }
        public SystemCheckException(string message, string output, Exception innerException)
            :
            base("SystemCheck", message, output, innerException) { }

        public override string Message
        {
            get
            {
                return string.Format("{0}\r\nSystemCheck Output:\r\n{1}\r\nEnd SystemCheck Output\r\n",
                    base.Message, base.ProcessOutput);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\XblCfg.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Net;

using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.Utilities;

using xonline.common.config;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running XblCfg
    /// </summary>
    public class XblCfg
    {
        // Known blob names
        public const string Blobs_DrmWhitelist      = "xbos_wmdrm_whitelist";

        // Search the path?
        const string DefaultXblCfgPath = "";


        private static int          XblCfgInstance = 0;
        private ProcessWrapper      _Process;
        private string              _TempFile;

        public XblCfg()
        {
            _Process = new ProcessWrapper("XblCfg", Path.Combine(DefaultXblCfgPath, "XblCfg.exe"));
            int id = System.Threading.Interlocked.Increment(ref XblCfgInstance);
            _TempFile = "xblcfg_temp_" + id + ".txt";

            // Turn off verbose output in ProcessWrapper
            ProcessWrapper.ro.DisableFilter(Report.DEBUG);
            ProcessWrapper.ro.DisableFilter(Report.INFO);
        }

        public XblCfg(string toolPath) : this()
        {
            _Process.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to XblCfg
        /// </summary>
        public string XblCfgPath
        {
            get { return _Process.ExecutablePath; }
            set { _Process.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of XblCfg.
        /// </summary>
        public string Output
        {
            get { return _Process.Output; }
        }

        /// <summary>
        /// Add blob to npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <param name="blob">The blob data</param>
        public void AddBlob(string name, byte[] blob)
        {
            if (blob == null)
                return;

            File.WriteAllBytes(_TempFile, blob);

            try
            {
                string args = String.Format(
                    "-blob -add -name:{0} -file:{1}",
                    name,
                    _TempFile);

                if (_Process.Run(args) != 0)
                {
                    throw new XblCfgException("XblCfg Failed.", _Process.Output);
                }
            }
            finally
            {
                if (File.Exists(_TempFile))
                    File.Delete(_TempFile);
            }
        }

        /// <summary>
        /// Delete blob in npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob to delete</param>
        public void DeleteBlob(string name)
        {
            string args = String.Format(
                "-blob -delete -name:{0}",
                name);

            if (_Process.Run(args) != 0)
            {
                throw new XblCfgException("XblCfg Failed.", _Process.Output);
            }
        }

        /// <summary>
        /// Gets blob from npdb..t_config_blobs
        /// </summary>
        /// <param name="name">The name of the blob</param>
        /// <param name="blob">The blob data retrieved</param>
        public void GetBlob(string name, out byte[] blob)
        {
            blob = null;
            try
            {
                string args = String.Format(
                    "-blob -get -name:{0} -file:{1}",
                    name,
                    _TempFile);

                if (_Process.Run(args) != 0)
                {
                    throw new XblCfgException("XblCfg Failed.", _Process.Output);
                }
                
                if (File.Exists(_TempFile))
                    blob = File.ReadAllBytes(_TempFile);
            }
            finally
            {
                if (File.Exists(_TempFile))
                    File.Delete(_TempFile);
            }
        }


        /// <summary>
        /// Allows running XblCfg with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling XblCfg.</param>
        public void RunXblCfg(string arguments)
        {
            if (_Process.Run(arguments) != 0)
            {
                throw new XblCfgException("XblCfg Failed.", _Process.Output);
            }
        }


        /// <summary>
        /// Reloads the xbos servers after changing the wmdrm whitelist blob.
        /// Helper function.
        /// </summary>
        public void ReloadWmdrmSettings()
        {
            IPEndPoint[] serverIps = Global.XEnv.GetInterface(Interface.xbos_int);
            foreach (IPEndPoint ip in serverIps)
            {
                string response;
                ManagementConsole.Execute(ip, "e :xbos reloadwmdrmsettings", out response);
                //Global.RO.Debug("[Xmgmt] Executed \"e :xbos reloadwmdrmsettings\" on 
                //{0}, response: {1}", ip.ToString(), response);
            }
        }



    }

    public class XblCfgException : ProcessException
    {
        public XblCfgException() : base("XblCfg") {}
        public XblCfgException(string message) : base("XblCfg", message) {}
        public XblCfgException(string message, Exception innerException) : base("XblCfg", message, innerException) {}
        public XblCfgException(string message, string output) : base("XblCfg", message, output) {}
        public XblCfgException(string message, string output, Exception innerException) :
            base("XblCfg", message, output, innerException) {}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ConfigFiles\ConfigFileSerializer.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

/// <summary>
/// Utility class for serializing and deserializing various configuration files.
/// </summary>
public static class ConfigFileSerializer
{
    public static object FromXml(Type configFileType, string configFilePath)
    {
        if (null == configFilePath)
        {
            throw new ArgumentNullException("configFilePath");
        }

        if (!File.Exists(configFilePath))
        {
            return null;
        }

        object configObj = null;
        StreamReader reader = null;
        using (reader = new StreamReader(configFilePath))
        {
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            using (xmlReader = new XmlTextReader(reader))
            {
                serializer = new XmlSerializer(configFileType);
                configObj = serializer.Deserialize(xmlReader);
            }
        }

        return configObj;
    }

    public static void ToXml(string configFilePath, object configObject)
    {
        if (null == configFilePath)
        {
            throw new ArgumentNullException("configFilePath");
        }

        if (configObject == null)
            return;

        /*
         * We need to go through the pain of creating an XmlDocument from
         * the serialized XML stream so that when we can duplicate the
         * format of the config file when it's saved from the tools.
         */
        XmlDocument doc = new XmlDocument();
        using (XmlTextWriter xtw = new XmlTextWriter(configFilePath, System.Text.Encoding.Unicode))
        {
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 2;
            xtw.IndentChar = ' ';

            XmlSerializer serializer = new XmlSerializer(configObject.GetType());
            using (StringWriter sw = new StringWriter())
            {
                serializer.Serialize(sw, configObject);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\LiveStats.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using System.Collections;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveStats tool.
    /// </summary>
    public class LiveStats
    {
	    // Some commands allow the leaderboard id to be "ALL".
	    // Use this constant to specify that value.
	    public const int ALL_LEADERBOARDS = -1;
        const string DefaultLiveStatsPath = "D:\\webroot\\xbltools";

        private ProcessWrapper _liveStatsProcess;
        private Report _report;

		public LiveStats()
		{
            _liveStatsProcess = new ProcessWrapper("LiveStats", Path.Combine(DefaultLiveStatsPath, "LiveStats.exe"));
            _report = new Report("LiveStats");
        }

		public LiveStats(string liveStatsPath) : this()
		{
			_liveStatsProcess.ExecutablePath = Path.GetFullPath(liveStatsPath);
		}

		/// <summary>
		/// Gets or sets the fully-qualified name of the LiveStats executable.
		/// </summary>
		public string LiveStatsPath
		{
			get { return _liveStatsProcess.ExecutablePath; }
            set
            {
                _liveStatsProcess.ExecutablePath = Path.GetFullPath(value);
                _liveStatsProcess.WorkingDirectory = Path.GetDirectoryName(_liveStatsProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for LiveStats
        /// </summary>
        public string WorkingDirectory
        {
            get { return _liveStatsProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _liveStatsProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _liveStatsProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the number of milliseconds to allow LiveStats to run before killing the process.
        /// </summary>
        public int Timeout
        {
            get { return _liveStatsProcess.ExecutionTimeout; }
            set { _liveStatsProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of LiveStats.
        /// </summary>
        public string Output
        {
            get { return _liveStatsProcess.Output; }
        }

		/// <summary>
		/// Deploys the leaderboards for an Xbox1 title.
		/// </summary>
		/// <param name="force">Flag indicating whether or not to include the /force argument.</param>
		public void DeployXbox1Leaderboard(uint titleId, bool force)
		{
			string arguments = String.Format("/deployxboxlb /titleid:0x{0:x8}", titleId);

			if (force)
				arguments += " /force";

			if (_liveStatsProcess.Run(arguments) != 0)
				throw new LiveStatsException("Deploying an Xbox1 leaderboard failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deploys the leaderboards for an Xbox 360 title.
		/// </summary>
		/// <param name="force">Flag indicating whether or not to include the /force argument.</param>
		public void DeployXbox360Leaderboard(uint titleId, bool force)
		{
			string arguments = String.Format("/deploylb /titleid:0x{0:x8}", titleId);

			if (force)
				arguments += " /force";

			if (_liveStatsProcess.Run(arguments) != 0)
				throw new LiveStatsException("Deploying an Xbox 360 leaderboard failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deletes the leaderboards from the Web DB and re-deploys them.
		/// </summary>
		public void DeployWebOnlyLeaderboard(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/deploywebdbonlylb /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Deploying to Web only failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Moves one or all leaderboards from one server to another.
		/// </summary>
		/// <param name="leaderboardId">
		/// ID of the leaderboard to move. Use the ALL_LEADERBOARDS constant to move all leaderboards.
		/// </param>
		/// <param name="sourceServer">
		/// The name of the server on which the leaderboard currently resides.
		/// </param>
		/// <param name="destServer">
		/// The name of the server to which the leaderboard will be moved.
		/// </param>
		public void MoveLeaderboard(uint titleId, int leaderboardId, string sourceServer, string destServer)
		{
			if (_liveStatsProcess.Run(String.Format("/movelb /titleid:0x{0:x8} /lbid:{1} /source:{2} /dest:{3}",
				titleId, (leaderboardId == ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString()),
				sourceServer, destServer)) != 0)
			{
				throw new LiveStatsException("Leaderboard move failed.", _liveStatsProcess.Output);
			}
		}

        /// <summary>
        /// Reports the leaderboard configuration for a title.
        /// </summary>
        /// <param name="leaderboardId">
        /// The ID of the leaderboard to report.
        /// </param>
        public string[] ReportConfiguration(uint titleId)
		{
            ArrayList lbArray = new ArrayList();
            string [] returnString;
            int stringEndLoc;

            if (_liveStatsProcess.Run(String.Format("/reportconfiguration /titleid:0x{0:x8}",
                titleId)) != 0)
            {
                throw new LiveStatsException("Report Configuration failed.", _liveStatsProcess.Output);
            }

            // Parse the output for the leaderboard information
            if (_liveStatsProcess.Output.IndexOf("No leaderboards are configured in NPDB for titleID") > 0)
                return null;
            string parseOutput = _liveStatsProcess.Output;
            if (parseOutput.IndexOf("ServerName") < 0)
            {
                // Couldn't find the list of leaderboards
                return null;
            }

            // Find the Start of the Leadboard List and End, We're includind the Column header bar for now. To remove just skip the first line.
            parseOutput = parseOutput.Substring(parseOutput.IndexOf("ServerName"));
            parseOutput = parseOutput.Substring(0, parseOutput.LastIndexOf("Succesfully Executed reportconfiguration") - 2); // -2 to remove the blank line at the end
            //_report.Debug("Leaderboard List:{0}{1}", Environment.NewLine, parseOutput);

            // Find the End of the first leaderboard line and start getting entries
            stringEndLoc = parseOutput.IndexOf(Environment.NewLine);
            while (stringEndLoc > 0) // Once the first char is new line we're at the end of the list or we're at the end
            {
                // Get the First line and add it to the array list
                lbArray.Add(parseOutput.Substring(0, stringEndLoc));
                //_report.Debug("Entry {0}: {1}", lbArray.Count, lbArray[lbArray.Count-1]);

                // Trim the First line out of the remaining string and get the next End of Line Char loc
                parseOutput = parseOutput.Substring(stringEndLoc + 2);
                stringEndLoc = parseOutput.IndexOf(Environment.NewLine);
            }

            returnString = (string []) lbArray.ToArray(typeof(string));
            return returnString;
		}

		/// <summary>
		/// Resets the data for a single leaderboard.
		/// </summary>
		/// <param name="leaderboardId">
		/// The ID of the leaderboard to reset.
		/// </param>
		public void ResetLeaderboard(uint titleId, int leaderboardId)
		{
			if (_liveStatsProcess.Run(String.Format("/resetlb /titleid:0x{0:x8} /lbid:{1}",
				titleId, (leaderboardId == ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString()))) != 0)
			{
				throw new LiveStatsException("Reset leaderboard failed.", _liveStatsProcess.Output);
			}
		}

		/// <summary>
		/// Resets the data for all leaderboards in the current title.
		/// </summary>
		public void ResetAllLeaderboards(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/resettitle /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Reset all leaderboards failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Deletes all stats data and leaderboard definitions for the current title.
		/// </summary>
		public void DeleteLeaderboards(uint titleId)
		{
			if (_liveStatsProcess.Run(String.Format("/deletetitle /titleid:0x{0:x8}", titleId)) != 0)
				throw new LiveStatsException("Delete leaderboards failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Reloads the Stats front door.
		/// </summary>
		public void ReloadFrontDoor()
		{
			if (_liveStatsProcess.Run("/reloadfrontdoor") != 0)
				throw new LiveStatsException("Reload front door failed.", _liveStatsProcess.Output);
		}

		/// <summary>
		/// Reloads the Web stats front door.
		/// </summary>
		public void ReloadWebStats()
		{
			if (_liveStatsProcess.Run("/reloadwebstats") != 0)
				throw new LiveStatsException("Reload web stats failed.", _liveStatsProcess.Output);
		}

        /// <summary>
        /// Sets up a clean clips CRON job for the specified Xbox360 title id
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="hoursFromNow">The number of hours to wait before running the CRON job.</param>
        public void CleanClip(uint titleId, int hoursFromNow)
        {
            if (_liveStatsProcess.Run(string.Format("/cleanclip /titleid:0x{0:x8} /hoursfromnow:{1}",
                titleId, hoursFromNow)) != 0)
            {
                throw new LiveStatsException("CleanClip failed.", _liveStatsProcess.Output);
            }
        }

        /// <summary>
        /// Sets up a clean clips CRON job for the specified Xbox1 title id
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="hoursFromNow">The number of hours to wait before running the CRON job.</param>
        public void CleanXboxClip(uint titleId, int hoursFromNow)
        {
            if (_liveStatsProcess.Run(string.Format("/cleanxboxclip /titleid:0x{0:x8} /hoursfromnow:{1}",
                titleId, hoursFromNow)) != 0)
            {
                throw new LiveStatsException("CleanXboxClip failed.", _liveStatsProcess.Output);
            }
        }

        public void SetToReadOnly(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/settoreadonly /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("SetToReadOnly failed.", _liveStatsProcess.Output);
            }
        }

        public void SetToReadWrite(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/settoreadwrite /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("SetToReadWrite failed.", _liveStatsProcess.Output);
            }
        }

        public void Unload(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/unload /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("Unload failed.", _liveStatsProcess.Output);
            }
        }

        public void Load(uint titleId, int leaderboardId, string server)
        {
            StringBuilder args = new StringBuilder();

            args.AppendFormat("/load /titleid:0x{0:x8} /lbid:{1} /server:{2}", titleId,
                leaderboardId == LiveStats.ALL_LEADERBOARDS ? "ALL" : leaderboardId.ToString(), server);
            if (_liveStatsProcess.Run(args.ToString()) != 0)
            {
                throw new LiveStatsException("Load failed.", _liveStatsProcess.Output);
            }
        }
	}

	public class LiveStatsException : ProcessException
	{
		public LiveStatsException() : base("LiveStats") {}
		public LiveStatsException(string message) : base("LiveStats", message) {}
		public LiveStatsException(string message, Exception innerException) : base("LiveStats", message, innerException) {}
		public LiveStatsException(string message, string output) : base("LiveStats", message, output) {}
		public LiveStatsException(string message, string output, Exception innerException) :
			base("LiveStats", message, output, innerException) {}

        public override string Message
        {
            get { return string.Format("{0}\r\nLiveStats Output:\r\n{1}\r\nEnd LiveStats Output\r\n",
                      base.Message, base.ProcessOutput); }
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ConfigFiles\MarketplaceConfig.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: MarketplaceConfig.xsd
// Creation Date: 3/10/2006 9:57:00
//--------------------------------------------------------------

using System;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using System.Collections;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct MktPlaceDeclarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/xlast";
	}

	[XmlRoot(ElementName="XboxLiveSubmissionProject",Namespace=MktPlaceDeclarations.SchemaVersion,IsNullable=false),Serializable]
	public class XboxLiveMarketplaceProject
	{

		[XmlAttribute(AttributeName="Version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return __Version; }
			set { __Version = value; }
		}

		[XmlElement(Type=typeof(MarketplaceConfigProject),ElementName="MarketplaceConfigProject",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public MarketplaceConfigProject __MarketplaceConfigProject;
		
		[XmlIgnore]
		public MarketplaceConfigProject MarketplaceConfigProject
		{
			get
			{
				if (__MarketplaceConfigProject == null) __MarketplaceConfigProject = new MarketplaceConfigProject();		
				return __MarketplaceConfigProject;
			}
			set {__MarketplaceConfigProject = value;}
		}

		public XboxLiveMarketplaceProject()
		{
		}

        public static XboxLiveMarketplaceProject FromXml(string marketplaceFile)
        {
            if (marketplaceFile == null)
            {
                throw new ArgumentNullException("marketplaceFile");
            }
            
            if (!File.Exists(marketplaceFile))
            {
                return null;
            }

            StreamReader reader = null;
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxLiveMarketplaceProject marketplace = null;
            try
            {
                reader = new StreamReader(marketplaceFile);
                xmlReader = new XmlTextReader(reader);
                serializer = new XmlSerializer(typeof(XboxLiveMarketplaceProject));
                marketplace = (serializer.Deserialize(xmlReader) as XboxLiveMarketplaceProject);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return marketplace;
        }

        public void ToXml(string marketplaceFile)
        {
            if (marketplaceFile == null)
            {
                throw new ArgumentNullException("marketplaceFile");
            }

            /*
             * We need to go through the pain of creating an XmlDocument from
             * the serialized XML stream so that when we can duplicate the
             * format of the Marketplace file when it's saved from XLAST.
             */
            StringWriter sw = new StringWriter();
            XmlDocument doc = new XmlDocument();
            XmlTextWriter xtw = new XmlTextWriter(marketplaceFile, System.Text.Encoding.Unicode);
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 1;
            xtw.IndentChar = (char)0x9;
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxLiveMarketplaceProject));
                serializer.Serialize(sw, this);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
            finally
            {
                xtw.Close();
                sw.Close();
            }
        }
	}

	[XmlType(TypeName="MarketplaceConfigProject",Namespace=MktPlaceDeclarations.SchemaVersion),Serializable]
	public class MarketplaceConfigProject
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleId;
		
		[XmlIgnore]
		public string titleId
		{ 
			get { return __titleId; }
			set { __titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleName;
		
		[XmlIgnore]
		public string titleName
		{ 
			get { return __titleName; }
			set { __titleName = value; }
		}

		[XmlAttribute(AttributeName="titleType",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __titleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleTypeSpecified;
		
		[XmlIgnore]
		public uint titleType
		{ 
			get { return __titleType; }
			set { __titleType = value; __titleTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __projectVersion;
		
		[XmlIgnore]
		public string projectVersion
		{ 
			get { return __projectVersion; }
			set { __projectVersion = value; }
		}

		[XmlAttribute(AttributeName="schemaVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __schemaVersion;
		
		[XmlIgnore]
		public string schemaVersion
		{ 
			get { return __schemaVersion; }
			set { __schemaVersion = value; }
		}

		[XmlElement(Type=typeof(LocalizedStrings),ElementName="LocalizedStrings",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStrings __LocalizedStrings;
		
		[XmlIgnore]
		public LocalizedStrings LocalizedStrings
		{
			get
			{
				if (__LocalizedStrings == null) __LocalizedStrings = new LocalizedStrings();		
				return __LocalizedStrings;
			}
			set {__LocalizedStrings = value;}
		}

		[XmlElement(Type=typeof(Images),ElementName="Images",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Images __Images;
		
		[XmlIgnore]
		public Images Images
		{
			get
			{
				if (__Images == null) __Images = new Images();		
				return __Images;
			}
			set {__Images = value;}
		}

		[XmlElement(Type=typeof(ProductInformation),ElementName="ProductInformation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=MktPlaceDeclarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ProductInformation __ProductInformation;
		
		[XmlIgnore]
		public ProductInformation ProductInformation
		{
			get
			{
				if (__ProductInformation == null) __ProductInformation = new ProductInformation();		
				return __ProductInformation;
			}
			set {__ProductInformation = value;}
		}

		public MarketplaceConfigProject()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\Backup1\ConfigFiles\XlastConfigV03.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: gi.03.xsd
// Creation Date: 6/19/2007 12:58:07
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/xlast";
	}

	[Serializable]
	public enum type23
	{
		[XmlEnum(Name="Ascending")] Ascending,
		[XmlEnum(Name="Descending")] Descending,
		[XmlEnum(Name="Near")] Near,
		[XmlEnum(Name="Far")] Far
	}

	[Serializable]
	public enum resetType
	{
		[XmlEnum(Name="Weekly")] Weekly,
		[XmlEnum(Name="Biweekly")] Biweekly,
		[XmlEnum(Name="Monthly")] Monthly,
		[XmlEnum(Name="Bimonthly")] Bimonthly,
		[XmlEnum(Name="Annually")] Annually,
		[XmlEnum(Name="Never")] Never
	}

	[Serializable]
	public enum MatchFilterItemType
	{
		[XmlEnum(Name="Attribute")] Attribute,
		[XmlEnum(Name="Parameter")] Parameter,
		[XmlEnum(Name="Constant")] Constant,
		[XmlEnum(Name="ContextValue")] ContextValue
	}

    [Serializable]
    public enum type
    {
        [XmlEnum(Name = "Min")] Min,
        [XmlEnum(Name = "Max")] Max,
        [XmlEnum(Name = "Sum")] Sum,
        [XmlEnum(Name = "Last")] Last
    }

	[Serializable]
	public enum type234
	{
		[XmlEnum(Name="Normal")] Normal,
		[XmlEnum(Name="Average")] Average,
		[XmlEnum(Name="Sum")] Sum,
		[XmlEnum(Name="Minimum")] Minimum,
		[XmlEnum(Name="Maximum")] Maximum,
		[XmlEnum(Name="Count")] Count
	}

	[Serializable]
	public enum achievementType
	{
		[XmlEnum(Name="Completion")] Completion,
		[XmlEnum(Name="Leveling")] Leveling,
		[XmlEnum(Name="Unlock")] Unlock,
		[XmlEnum(Name="Event")] @Event,
		[XmlEnum(Name="Tournament")] Tournament,
		[XmlEnum(Name="Checkpoint")] Checkpoint,
		[XmlEnum(Name="Other")] Other
	}

	[Serializable]
	public enum type2
	{
		[XmlEnum(Name="Normal")] Normal,
		[XmlEnum(Name="Findfromid")] Findfromid,
		[XmlEnum(Name="Aggregate")] Aggregate
	}

	[Serializable]
	public enum ArcadeLeaderboardSortType
	{
		[XmlEnum(Name="Ascending")] Ascending,
		[XmlEnum(Name="Descending")] Descending
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class FeatureCollection : ArrayList
	{
		public Feature Add(Feature obj)
		{
			base.Add(obj);
			return obj;
		}

		public Feature Add()
		{
			return Add(new Feature());
		}

		public void Insert(int index, Feature obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Feature obj)
		{
			base.Remove(obj);
		}

		new public Feature this[int index]
		{
			get { return (Feature) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PlatformCollection : ArrayList
	{
		public Platform Add(Platform obj)
		{
			base.Add(obj);
			return obj;
		}

		public Platform Add()
		{
			return Add(new Platform());
		}

		public void Insert(int index, Platform obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Platform obj)
		{
			base.Remove(obj);
		}

		new public Platform this[int index]
		{
			get { return (Platform) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ConstantCollection : ArrayList
	{
		public Constant Add(Constant obj)
		{
			base.Add(obj);
			return obj;
		}

		public Constant Add()
		{
			return Add(new Constant());
		}

		public void Insert(int index, Constant obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Constant obj)
		{
			base.Remove(obj);
		}

		new public Constant this[int index]
		{
			get { return (Constant) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PictureCollection : ArrayList
	{
		public Picture Add(Picture obj)
		{
			base.Add(obj);
			return obj;
		}

		public Picture Add()
		{
			return Add(new Picture());
		}

		public void Insert(int index, Picture obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Picture obj)
		{
			base.Remove(obj);
		}

		new public Picture this[int index]
		{
			get { return (Picture) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ReturnCollection : ArrayList
	{
		public @Return Add(@Return obj)
		{
			base.Add(obj);
			return obj;
		}

		public @Return Add()
		{
			return Add(new @Return());
		}

		public void Insert(int index, @Return obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(@Return obj)
		{
			base.Remove(obj);
		}

		new public @Return this[int index]
		{
			get { return (@Return) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ParameterCollection : ArrayList
	{
		public Parameter Add(Parameter obj)
		{
			base.Add(obj);
			return obj;
		}

		public Parameter Add()
		{
			return Add(new Parameter());
		}

		public void Insert(int index, Parameter obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Parameter obj)
		{
			base.Remove(obj);
		}

		new public Parameter this[int index]
		{
			get { return (Parameter) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TranslationCollection : ArrayList
	{
		public Translation Add(Translation obj)
		{
			base.Add(obj);
			return obj;
		}

		public Translation Add()
		{
			return Add(new Translation());
		}

		public void Insert(int index, Translation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Translation obj)
		{
			base.Remove(obj);
		}

		new public Translation this[int index]
		{
			get { return (Translation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GameModeCollection : ArrayList
	{
		public GameMode Add(GameMode obj)
		{
			base.Add(obj);
			return obj;
		}

		public GameMode Add()
		{
			return Add(new GameMode());
		}

		public void Insert(int index, GameMode obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(GameMode obj)
		{
			base.Remove(obj);
		}

		new public GameMode this[int index]
		{
			get { return (GameMode) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class AttributeCollection : ArrayList
	{
		public Attribute Add(Attribute obj)
		{
			base.Add(obj);
			return obj;
		}

		public Attribute Add()
		{
			return Add(new Attribute());
		}

		public void Insert(int index, Attribute obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Attribute obj)
		{
			base.Remove(obj);
		}

		new public Attribute this[int index]
		{
			get { return (Attribute) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class RatingCollection : ArrayList
	{
		public Rating Add(Rating obj)
		{
			base.Add(obj);
			return obj;
		}

		public Rating Add()
		{
			return Add(new Rating());
		}

		public void Insert(int index, Rating obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Rating obj)
		{
			base.Remove(obj);
		}

		new public Rating this[int index]
		{
			get { return (Rating) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class FilterCollection : ArrayList
	{
		public Filter Add(Filter obj)
		{
			base.Add(obj);
			return obj;
		}

		public Filter Add()
		{
			return Add(new Filter());
		}

		public void Insert(int index, Filter obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Filter obj)
		{
			base.Remove(obj);
		}

		new public Filter this[int index]
		{
			get { return (Filter) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SortOperationCollection : ArrayList
	{
		public SortOperation Add(SortOperation obj)
		{
			base.Add(obj);
			return obj;
		}

		public SortOperation Add()
		{
			return Add(new SortOperation());
		}

		public void Insert(int index, SortOperation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(SortOperation obj)
		{
			base.Remove(obj);
		}

		new public SortOperation this[int index]
		{
			get { return (SortOperation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PresenceModeCollection : ArrayList
	{
		public PresenceMode Add(PresenceMode obj)
		{
			base.Add(obj);
			return obj;
		}

		public PresenceMode Add()
		{
			return Add(new PresenceMode());
		}

		public void Insert(int index, PresenceMode obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(PresenceMode obj)
		{
			base.Remove(obj);
		}

		new public PresenceMode this[int index]
		{
			get { return (PresenceMode) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LocalizedStringCollection : ArrayList
	{
		public LocalizedString Add(LocalizedString obj)
		{
			base.Add(obj);
			return obj;
		}

		public LocalizedString Add()
		{
			return Add(new LocalizedString());
		}

		public void Insert(int index, LocalizedString obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(LocalizedString obj)
		{
			base.Remove(obj);
		}

		new public LocalizedString this[int index]
		{
			get { return (LocalizedString) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextValueCollection : ArrayList
	{
		public ContextValue Add(ContextValue obj)
		{
			base.Add(obj);
			return obj;
		}

		public ContextValue Add()
		{
			return Add(new ContextValue());
		}

		public void Insert(int index, ContextValue obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(ContextValue obj)
		{
			base.Remove(obj);
		}

		new public ContextValue this[int index]
		{
			get { return (ContextValue) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewFieldTypeCollection : ArrayList
	{
		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Add(obj);
			return obj;
		}

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add()
		{
			return Add(new ServerTestFramework.STFTools.ConfigFiles.ViewFieldType());
		}

		public void Insert(int index, ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Remove(obj);
		}

		new public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType this[int index]
		{
			get { return (ServerTestFramework.STFTools.ConfigFiles.ViewFieldType) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class AchievementCollection : ArrayList
	{
		public Achievement Add(Achievement obj)
		{
			base.Add(obj);
			return obj;
		}

		public Achievement Add()
		{
			return Add(new Achievement());
		}

		public void Insert(int index, Achievement obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Achievement obj)
		{
			base.Remove(obj);
		}

		new public Achievement this[int index]
		{
			get { return (Achievement) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PropertyCollection : ArrayList
	{
		public Property Add(Property obj)
		{
			base.Add(obj);
			return obj;
		}

		public Property Add()
		{
			return Add(new Property());
		}

		public void Insert(int index, Property obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Property obj)
		{
			base.Remove(obj);
		}

		new public Property this[int index]
		{
			get { return (Property) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SupportedLocaleCollection : ArrayList
	{
		public SupportedLocale Add(SupportedLocale obj)
		{
			base.Add(obj);
			return obj;
		}

		public SupportedLocale Add()
		{
			return Add(new SupportedLocale());
		}

		public void Insert(int index, SupportedLocale obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(SupportedLocale obj)
		{
			base.Remove(obj);
		}

		new public SupportedLocale this[int index]
		{
			get { return (SupportedLocale) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class StatsViewCollection : ArrayList
	{
		public StatsView Add(StatsView obj)
		{
			base.Add(obj);
			return obj;
		}

		public StatsView Add()
		{
			return Add(new StatsView());
		}

		public void Insert(int index, StatsView obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(StatsView obj)
		{
			base.Remove(obj);
		}

		new public StatsView this[int index]
		{
			get { return (StatsView) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class QueryCollection : ArrayList
	{
		public Query Add(Query obj)
		{
			base.Add(obj);
			return obj;
		}

		public Query Add()
		{
			return Add(new Query());
		}

		public void Insert(int index, Query obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Query obj)
		{
			base.Remove(obj);
		}

		new public Query this[int index]
		{
			get { return (Query) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GenreCollection : ArrayList
	{
		public Genre Add(Genre obj)
		{
			base.Add(obj);
			return obj;
		}

		public Genre Add()
		{
			return Add(new Genre());
		}

		public void Insert(int index, Genre obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Genre obj)
		{
			base.Remove(obj);
		}

		new public Genre this[int index]
		{
			get { return (Genre) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ImageCollection : ArrayList
	{
		public Image Add(Image obj)
		{
			base.Add(obj);
			return obj;
		}

		public Image Add()
		{
			return Add(new Image());
		}

		public void Insert(int index, Image obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Image obj)
		{
			base.Remove(obj);
		}

		new public Image this[int index]
		{
			get { return (Image) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextCollection : ArrayList
	{
		public Context Add(Context obj)
		{
			base.Add(obj);
			return obj;
		}

		public Context Add()
		{
			return Add(new Context());
		}

		public void Insert(int index, Context obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Context obj)
		{
			base.Remove(obj);
		}

		new public Context this[int index]
		{
			get { return (Context) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="ViewAxisType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewAxisType
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return FieldCollection.GetEnumerator();
		}

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			return FieldCollection.Add(obj);
		}

		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType this[int index]
		{
			get { return (ServerTestFramework.STFTools.ConfigFiles.ViewFieldType) FieldCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return FieldCollection.Count; }
        }

        public void Clear()
		{
            FieldCollection.Clear();
        }

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Remove(int index) 
		{ 
            ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj = FieldCollection[index];
            FieldCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            FieldCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType),ElementName="Field",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ViewFieldTypeCollection __FieldCollection;
		
		[XmlIgnore]
		public ViewFieldTypeCollection FieldCollection
		{
			get
			{
				if (__FieldCollection == null) __FieldCollection = new ViewFieldTypeCollection();
				return __FieldCollection;
			}
			set {__FieldCollection = value;}
		}

		public ViewAxisType()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (FieldCollection.Count == 0)
			{
				ViewFieldType _c = FieldCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (ViewFieldType _c in FieldCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="PropertyFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PropertyFieldType
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlElement(Type=typeof(Aggregation),ElementName="Aggregation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Aggregation __Aggregation;
		
		[XmlIgnore]
		public Aggregation Aggregation
		{
			get
			{
				if (__Aggregation == null) __Aggregation = new Aggregation();		
				return __Aggregation;
			}
			set {__Aggregation = value;}
		}

		public PropertyFieldType()
		{
		}

		public void MakeSchemaCompliant()
		{
			Aggregation.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Aggregation",Namespace=Declarations.SchemaVersion),Serializable]
	public class Aggregation
	{

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		public Aggregation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="NonValidatedElement",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class NonValidatedElement
	{

		[XmlAnyElement()]
		public System.Xml.XmlElement[] Any;

		public NonValidatedElement()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ContextFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextFieldType
	{

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public ContextFieldType()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ViewFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewFieldType
	{

		[XmlAttribute(AttributeName="attributeId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __attributeId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __attributeIdSpecified;
		
		[XmlIgnore]
		public ushort attributeId
		{ 
			get { return __attributeId; }
			set { __attributeId = value; __attributeIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="hidden",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hidden;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hiddenSpecified;
		
		[XmlIgnore]
		public bool hidden
		{ 
			get { return __hidden; }
			set { __hidden = value; __hiddenSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeLeaderboard",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeLeaderboard;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeLeaderboardSpecified;
		
		[XmlIgnore]
		public bool arcadeLeaderboard
		{ 
			get { return __arcadeLeaderboard; }
			set { __arcadeLeaderboard = value; __arcadeLeaderboardSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeSort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType __arcadeSort;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeSortSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType arcadeSort
		{ 
			get { return __arcadeSort; }
			set { __arcadeSort = value; __arcadeSortSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __arcadeStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeStringIdSpecified;
		
		[XmlIgnore]
		public ushort arcadeStringId
		{ 
			get { return __arcadeStringId; }
			set { __arcadeStringId = value; __arcadeStringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ContextFieldType),ElementName="Context",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ContextFieldType __Context;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ContextFieldType Context
		{
			get
			{
				if (__Context == null) __Context = new ServerTestFramework.STFTools.ConfigFiles.ContextFieldType();		
				return __Context;
			}
			set {__Context = value;}
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType),ElementName="Property",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType __Property;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType Property
		{
			get
			{
				if (__Property == null) __Property = new ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType();		
				return __Property;
			}
			set {__Property = value;}
		}

		public ViewFieldType()
		{
			arcadeLeaderboard = false;
			arcadeSort = ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType.Ascending;
		}

		public void MakeSchemaCompliant()
		{
			Context.MakeSchemaCompliant();
			Property.MakeSchemaCompliant();
		}
	}


	[XmlRoot(ElementName="XboxLiveSubmissionProject",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	public class XboxLiveSubmissionProject
	{

		[XmlAttribute(AttributeName="Version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return __Version; }
			set { __Version = value; }
		}

		[XmlElement(Type=typeof(GameConfigProject),ElementName="GameConfigProject",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameConfigProject __GameConfigProject;
		
		[XmlIgnore]
		public GameConfigProject GameConfigProject
		{
			get
			{
				if (__GameConfigProject == null) __GameConfigProject = new GameConfigProject();		
				return __GameConfigProject;
			}
			set {__GameConfigProject = value;}
		}

		public XboxLiveSubmissionProject()
		{
		}

		public void MakeSchemaCompliant()
		{
			GameConfigProject.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="GameConfigProject",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameConfigProject
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleId;
		
		[XmlIgnore]
		public string titleId
		{ 
			get { return __titleId; }
			set { __titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleName;
		
		[XmlIgnore]
		public string titleName
		{ 
			get { return __titleName; }
			set { __titleName = value; }
		}

		[XmlAttribute(AttributeName="titleType",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __titleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleTypeSpecified;
		
		[XmlIgnore]
		public uint titleType
		{ 
			get { return __titleType; }
			set { __titleType = value; __titleTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="multiplayer",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __multiplayer;
		
		[XmlIgnore]
		public string multiplayer
		{ 
			get { return __multiplayer; }
			set { __multiplayer = value; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __projectVersion;
		
		[XmlIgnore]
		public string projectVersion
		{ 
			get { return __projectVersion; }
			set { __projectVersion = value; }
		}

		[XmlAttribute(AttributeName="schemaVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __schemaVersion;
		
		[XmlIgnore]
		public string schemaVersion
		{ 
			get { return __schemaVersion; }
			set { __schemaVersion = value; }
		}

		[XmlElement(Type=typeof(LocalizedStrings),ElementName="LocalizedStrings",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStrings __LocalizedStrings;
		
		[XmlIgnore]
		public LocalizedStrings LocalizedStrings
		{
			get
			{
				if (__LocalizedStrings == null) __LocalizedStrings = new LocalizedStrings();		
				return __LocalizedStrings;
			}
			set {__LocalizedStrings = value;}
		}

		[XmlElement(Type=typeof(GameModes),ElementName="GameModes",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameModes __GameModes;
		
		[XmlIgnore]
		public GameModes GameModes
		{
			get
			{
				if (__GameModes == null) __GameModes = new GameModes();		
				return __GameModes;
			}
			set {__GameModes = value;}
		}

		[XmlElement(Type=typeof(Contexts),ElementName="Contexts",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Contexts __Contexts;
		
		[XmlIgnore]
		public Contexts Contexts
		{
			get
			{
				if (__Contexts == null) __Contexts = new Contexts();		
				return __Contexts;
			}
			set {__Contexts = value;}
		}

		[XmlElement(Type=typeof(Images),ElementName="Images",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Images __Images;
		
		[XmlIgnore]
		public Images Images
		{
			get
			{
				if (__Images == null) __Images = new Images();		
				return __Images;
			}
			set {__Images = value;}
		}

		[XmlElement(Type=typeof(Achievements),ElementName="Achievements",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Achievements __Achievements;
		
		[XmlIgnore]
		public Achievements Achievements
		{
			get
			{
				if (__Achievements == null) __Achievements = new Achievements();		
				return __Achievements;
			}
			set {__Achievements = value;}
		}

		[XmlElement(Type=typeof(Properties),ElementName="Properties",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Properties __Properties;
		
		[XmlIgnore]
		public Properties Properties
		{
			get
			{
				if (__Properties == null) __Properties = new Properties();		
				return __Properties;
			}
			set {__Properties = value;}
		}

		[XmlElement(Type=typeof(Presence),ElementName="Presence",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Presence __Presence;
		
		[XmlIgnore]
		public Presence Presence
		{
			get
			{
				if (__Presence == null) __Presence = new Presence();		
				return __Presence;
			}
			set {__Presence = value;}
		}

		[XmlElement(Type=typeof(StatsViews),ElementName="StatsViews",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public StatsViews __StatsViews;
		
		[XmlIgnore]
		public StatsViews StatsViews
		{
			get
			{
				if (__StatsViews == null) __StatsViews = new StatsViews();		
				return __StatsViews;
			}
			set {__StatsViews = value;}
		}

		[XmlElement(Type=typeof(Matchmaking),ElementName="Matchmaking",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Matchmaking __Matchmaking;
		
		[XmlIgnore]
		public Matchmaking Matchmaking
		{
			get
			{
				if (__Matchmaking == null) __Matchmaking = new Matchmaking();		
				return __Matchmaking;
			}
			set {__Matchmaking = value;}
		}

		[XmlElement(Type=typeof(ProductInformation),ElementName="ProductInformation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ProductInformation __ProductInformation;
		
		[XmlIgnore]
		public ProductInformation ProductInformation
		{
			get
			{
				if (__ProductInformation == null) __ProductInformation = new ProductInformation();		
				return __ProductInformation;
			}
			set {__ProductInformation = value;}
		}

		[XmlElement(Type=typeof(GamerPictures),ElementName="GamerPictures",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GamerPictures __GamerPictures;
		
		[XmlIgnore]
		public GamerPictures GamerPictures
		{
			get
			{
				if (__GamerPictures == null) __GamerPictures = new GamerPictures();		
				return __GamerPictures;
			}
			set {__GamerPictures = value;}
		}

		public GameConfigProject()
		{
		}

		public void MakeSchemaCompliant()
		{
			LocalizedStrings.MakeSchemaCompliant();
			GameModes.MakeSchemaCompliant();
			Presence.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="LocalizedStrings",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedStrings
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="defaultLocale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __defaultLocale;
		
		[XmlIgnore]
		public string defaultLocale
		{ 
			get { return __defaultLocale; }
			set { __defaultLocale = value; }
		}

		[XmlElement(Type=typeof(SupportedLocale),ElementName="SupportedLocale",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SupportedLocaleCollection __SupportedLocaleCollection;
		
		[XmlIgnore]
		public SupportedLocaleCollection SupportedLocaleCollection
		{
			get
			{
				if (__SupportedLocaleCollection == null) __SupportedLocaleCollection = new SupportedLocaleCollection();
				return __SupportedLocaleCollection;
			}
			set {__SupportedLocaleCollection = value;}
		}

		[XmlElement(Type=typeof(LocalizedString),ElementName="LocalizedString",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStringCollection __LocalizedStringCollection;
		
		[XmlIgnore]
		public LocalizedStringCollection LocalizedStringCollection
		{
			get
			{
				if (__LocalizedStringCollection == null) __LocalizedStringCollection = new LocalizedStringCollection();
				return __LocalizedStringCollection;
			}
			set {__LocalizedStringCollection = value;}
		}

		public LocalizedStrings()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (SupportedLocaleCollection.Count == 0)
			{
				SupportedLocale _c = SupportedLocaleCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (SupportedLocale _c in SupportedLocaleCollection) _c.MakeSchemaCompliant();
			if (LocalizedStringCollection.Count == 0)
			{
				LocalizedString _c = LocalizedStringCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (LocalizedString _c in LocalizedStringCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="SupportedLocale",Namespace=Declarations.SchemaVersion),Serializable]
	public class SupportedLocale
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __locale;
		
		[XmlIgnore]
		public string locale
		{ 
			get { return __locale; }
			set { __locale = value; }
		}

		public SupportedLocale()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="LocalizedString",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedString
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public ushort id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlElement(Type=typeof(Translation),ElementName="Translation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TranslationCollection __TranslationCollection;
		
		[XmlIgnore]
		public TranslationCollection TranslationCollection
		{
			get
			{
				if (__TranslationCollection == null) __TranslationCollection = new TranslationCollection();
				return __TranslationCollection;
			}
			set {__TranslationCollection = value;}
		}

		[XmlElement(Type=typeof(LocalizedStringPresence),ElementName="Presence",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStringPresence __Presence;
		
		[XmlIgnore]
		public LocalizedStringPresence Presence
		{
			get
			{
				if (__Presence == null) __Presence = new LocalizedStringPresence();		
				return __Presence;
			}
			set {__Presence = value;}
		}

		public LocalizedString()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (TranslationCollection.Count == 0)
			{
				Translation _c = TranslationCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (Translation _c in TranslationCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Translation",Namespace=Declarations.SchemaVersion),Serializable]
	public class Translation
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __locale;
		
		[XmlIgnore]
		public string locale
		{ 
			get { return __locale; }
			set { __locale = value; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return __Value; }
			set { __Value = value; }
		}

		public Translation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="LocalizedStringPresence",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedStringPresence
	{

		public LocalizedStringPresence()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GameModes",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameModes
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return GameModeCollection.GetEnumerator();
		}

		public GameMode Add(GameMode obj)
		{
			return GameModeCollection.Add(obj);
		}

		[XmlIgnore]
		public GameMode this[int index]
		{
			get { return (GameMode) GameModeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return GameModeCollection.Count; }
        }

        public void Clear()
		{
            GameModeCollection.Clear();
        }

		public GameMode Remove(int index) 
		{ 
            GameMode obj = GameModeCollection[index];
            GameModeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            GameModeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="defaultValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __defaultValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __defaultValueSpecified;
		
		[XmlIgnore]
		public ushort defaultValue
		{ 
			get { return __defaultValue; }
			set { __defaultValue = value; __defaultValueSpecified = true; }
		}

		[XmlElement(Type=typeof(GameMode),ElementName="GameMode",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameModeCollection __GameModeCollection;
		
		[XmlIgnore]
		public GameModeCollection GameModeCollection
		{
			get
			{
				if (__GameModeCollection == null) __GameModeCollection = new GameModeCollection();
				return __GameModeCollection;
			}
			set {__GameModeCollection = value;}
		}

		public GameModes()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GameMode",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameMode
	{

		[XmlAttribute(AttributeName="value",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __value;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __valueSpecified;
		
		[XmlIgnore]
		public ushort @value
		{ 
			get { return __value; }
			set { __value = value; __valueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="drawProbability",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __drawProbability;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __drawProbabilitySpecified;
		
		[XmlIgnore]
		public byte drawProbability
		{ 
			get { return __drawProbability; }
			set { __drawProbability = value; __drawProbabilitySpecified = true; }
		}

		public GameMode()
		{
			__drawProbabilitySpecified = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Contexts",Namespace=Declarations.SchemaVersion),Serializable]
	public class Contexts
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ContextCollection.GetEnumerator();
		}

		public Context Add(Context obj)
		{
			return ContextCollection.Add(obj);
		}

		[XmlIgnore]
		public Context this[int index]
		{
			get { return (Context) ContextCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ContextCollection.Count; }
        }

        public void Clear()
		{
            ContextCollection.Clear();
        }

		public Context Remove(int index) 
		{ 
            Context obj = ContextCollection[index];
            ContextCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ContextCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __nextId;
		
		[XmlIgnore]
		public string nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; }
		}

		[XmlElement(Type=typeof(Context),ElementName="Context",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContextCollection __ContextCollection;
		
		[XmlIgnore]
		public ContextCollection ContextCollection
		{
			get
			{
				if (__ContextCollection == null) __ContextCollection = new ContextCollection();
				return __ContextCollection;
			}
			set {__ContextCollection = value;}
		}

		public Contexts()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Context",Namespace=Declarations.SchemaVersion),Serializable]
	public class Context
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ContextValueCollection.GetEnumerator();
		}

		public ContextValue Add(ContextValue obj)
		{
			return ContextValueCollection.Add(obj);
		}

		[XmlIgnore]
		public ContextValue this[int index]
		{
			get { return (ContextValue) ContextValueCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ContextValueCollection.Count; }
        }

        public void Clear()
		{
            ContextValueCollection.Clear();
        }

		public ContextValue Remove(int index) 
		{ 
            ContextValue obj = ContextValueCollection[index];
            ContextValueCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ContextValueCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="defaultValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __defaultValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __defaultValueSpecified;
		
		[XmlIgnore]
		public ushort defaultValue
		{ 
			get { return __defaultValue; }
			set { __defaultValue = value; __defaultValueSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(ContextValue),ElementName="ContextValue",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContextValueCollection __ContextValueCollection;
		
		[XmlIgnore]
		public ContextValueCollection ContextValueCollection
		{
			get
			{
				if (__ContextValueCollection == null) __ContextValueCollection = new ContextValueCollection();
				return __ContextValueCollection;
			}
			set {__ContextValueCollection = value;}
		}

		public Context()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ContextValue",Namespace=Declarations.SchemaVersion),Serializable]
	public class ContextValue
	{

		[XmlAttribute(AttributeName="value",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __value;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __valueSpecified;
		
		[XmlIgnore]
		public ushort @value
		{ 
			get { return __value; }
			set { __value = value; __valueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public ContextValue()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Images",Namespace=Declarations.SchemaVersion),Serializable]
	public class Images
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ImageCollection.GetEnumerator();
		}

		public Image Add(Image obj)
		{
			return ImageCollection.Add(obj);
		}

		[XmlIgnore]
		public Image this[int index]
		{
			get { return (Image) ImageCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ImageCollection.Count; }
        }

        public void Clear()
		{
            ImageCollection.Clear();
        }

		public Image Remove(int index) 
		{ 
            Image obj = ImageCollection[index];
            ImageCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ImageCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Image),ElementName="Image",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ImageCollection __ImageCollection;
		
		[XmlIgnore]
		public ImageCollection ImageCollection
		{
			get
			{
				if (__ImageCollection == null) __ImageCollection = new ImageCollection();
				return __ImageCollection;
			}
			set {__ImageCollection = value;}
		}

		public Images()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Image",Namespace=Declarations.SchemaVersion),Serializable]
	public class Image
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlElement(ElementName="Path",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Path;
		
		[XmlIgnore]
		public string Path
		{ 
			get { return __Path; }
			set { __Path = value; }
		}

		public Image()
		{
			Path = string.Empty;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Achievements",Namespace=Declarations.SchemaVersion),Serializable]
	public class Achievements
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return AchievementCollection.GetEnumerator();
		}

		public Achievement Add(Achievement obj)
		{
			return AchievementCollection.Add(obj);
		}

		[XmlIgnore]
		public Achievement this[int index]
		{
			get { return (Achievement) AchievementCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return AchievementCollection.Count; }
        }

        public void Clear()
		{
            AchievementCollection.Clear();
        }

		public Achievement Remove(int index) 
		{ 
            Achievement obj = AchievementCollection[index];
            AchievementCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            AchievementCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Achievement),ElementName="Achievement",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public AchievementCollection __AchievementCollection;
		
		[XmlIgnore]
		public AchievementCollection AchievementCollection
		{
			get
			{
				if (__AchievementCollection == null) __AchievementCollection = new AchievementCollection();
				return __AchievementCollection;
			}
			set {__AchievementCollection = value;}
		}

		public Achievements()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Achievement",Namespace=Declarations.SchemaVersion),Serializable]
	public class Achievement
	{

		[XmlAttribute(AttributeName="achievementType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public achievementType __achievementType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __achievementTypeSpecified;
		
		[XmlIgnore]
		public achievementType achievementType
		{ 
			get { return __achievementType; }
			set { __achievementType = value; __achievementTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="descriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __descriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __descriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort descriptionStringId
		{ 
			get { return __descriptionStringId; }
			set { __descriptionStringId = value; __descriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public ushort id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="imageId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __imageId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __imageIdSpecified;
		
		[XmlIgnore]
		public uint imageId
		{ 
			get { return __imageId; }
			set { __imageId = value; __imageIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="showUnachieved",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __showUnachieved;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __showUnachievedSpecified;
		
		[XmlIgnore]
		public bool showUnachieved
		{ 
			get { return __showUnachieved; }
			set { __showUnachieved = value; __showUnachievedSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __titleStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleStringIdSpecified;
		
		[XmlIgnore]
		public ushort titleStringId
		{ 
			get { return __titleStringId; }
			set { __titleStringId = value; __titleStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="unachievedStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __unachievedStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __unachievedStringIdSpecified;
		
		[XmlIgnore]
		public ushort unachievedStringId
		{ 
			get { return __unachievedStringId; }
			set { __unachievedStringId = value; __unachievedStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="webDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __webDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __webDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort webDescriptionStringId
		{ 
			get { return __webDescriptionStringId; }
			set { __webDescriptionStringId = value; __webDescriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="cred",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __cred;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __credSpecified;
		
		[XmlIgnore]
		public ushort cred
		{ 
			get { return __cred; }
			set { __cred = value; __credSpecified = true; }
		}

		public Achievement()
		{
			showUnachieved = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Properties",Namespace=Declarations.SchemaVersion),Serializable]
	public class Properties
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PropertyCollection.GetEnumerator();
		}

		public Property Add(Property obj)
		{
			return PropertyCollection.Add(obj);
		}

		[XmlIgnore]
		public Property this[int index]
		{
			get { return (Property) PropertyCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PropertyCollection.Count; }
        }

        public void Clear()
		{
            PropertyCollection.Clear();
        }

		public Property Remove(int index) 
		{ 
            Property obj = PropertyCollection[index];
            PropertyCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PropertyCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Property),ElementName="Property",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PropertyCollection __PropertyCollection;
		
		[XmlIgnore]
		public PropertyCollection PropertyCollection
		{
			get
			{
				if (__PropertyCollection == null) __PropertyCollection = new PropertyCollection();
				return __PropertyCollection;
			}
			set {__PropertyCollection = value;}
		}

		public Properties()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Property",Namespace=Declarations.SchemaVersion),Serializable]
	public class Property
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="dataSize",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __dataSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __dataSizeSpecified;
		
		[XmlIgnore]
		public ushort dataSize
		{ 
			get { return __dataSize; }
			set { __dataSize = value; __dataSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(DefaultValue),ElementName="DefaultValue",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DefaultValue __DefaultValue;
		
		[XmlIgnore]
		public DefaultValue DefaultValue
		{
			get
			{
				if (__DefaultValue == null) __DefaultValue = new DefaultValue();		
				return __DefaultValue;
			}
			set {__DefaultValue = value;}
		}

		[XmlElement(Type=typeof(Format),ElementName="Format",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Format __Format;
		
		[XmlIgnore]
		public Format Format
		{
			get
			{
				if (__Format == null) __Format = new Format();		
				return __Format;
			}
			set {__Format = value;}
		}

		public Property()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="DefaultValue",Namespace=Declarations.SchemaVersion),Serializable]
	public class DefaultValue
	{

		public DefaultValue()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Format",Namespace=Declarations.SchemaVersion),Serializable]
	public class Format
	{

		[XmlAttribute(AttributeName="decimals",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __decimals;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __decimalsSpecified;
		
		[XmlIgnore]
		public byte decimals
		{ 
			get { return __decimals; }
			set { __decimals = value; __decimalsSpecified = true; }
		}

		[XmlAttribute(AttributeName="year",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __year;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __yearSpecified;
		
		[XmlIgnore]
		public bool year
		{ 
			get { return __year; }
			set { __year = value; __yearSpecified = true; }
		}

		[XmlAttribute(AttributeName="month",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __month;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __monthSpecified;
		
		[XmlIgnore]
		public bool month
		{ 
			get { return __month; }
			set { __month = value; __monthSpecified = true; }
		}

		[XmlAttribute(AttributeName="day",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __day;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __daySpecified;
		
		[XmlIgnore]
		public bool day
		{ 
			get { return __day; }
			set { __day = value; __daySpecified = true; }
		}

		[XmlAttribute(AttributeName="hours",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hours;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hoursSpecified;
		
		[XmlIgnore]
		public bool hours
		{ 
			get { return __hours; }
			set { __hours = value; __hoursSpecified = true; }
		}

		[XmlAttribute(AttributeName="minutes",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __minutes;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __minutesSpecified;
		
		[XmlIgnore]
		public bool minutes
		{ 
			get { return __minutes; }
			set { __minutes = value; __minutesSpecified = true; }
		}

		[XmlAttribute(AttributeName="seconds",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __seconds;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __secondsSpecified;
		
		[XmlIgnore]
		public bool seconds
		{ 
			get { return __seconds; }
			set { __seconds = value; __secondsSpecified = true; }
		}

		[XmlAttribute(AttributeName="milliseconds",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __milliseconds;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __millisecondsSpecified;
		
		[XmlIgnore]
		public bool milliseconds
		{ 
			get { return __milliseconds; }
			set { __milliseconds = value; __millisecondsSpecified = true; }
		}

		public Format()
		{
			decimals = 2;
			year = true;
			month = true;
			day = true;
			hours = true;
			minutes = true;
			seconds = true;
			milliseconds = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Presence",Namespace=Declarations.SchemaVersion),Serializable]
	public class Presence
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PresenceModeCollection.GetEnumerator();
		}

		public PresenceMode Add(PresenceMode obj)
		{
			return PresenceModeCollection.Add(obj);
		}

		[XmlIgnore]
		public PresenceMode this[int index]
		{
			get { return (PresenceMode) PresenceModeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PresenceModeCollection.Count; }
        }

        public void Clear()
		{
            PresenceModeCollection.Clear();
        }

		public PresenceMode Remove(int index) 
		{ 
            PresenceMode obj = PresenceModeCollection[index];
            PresenceModeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PresenceModeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextContextValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextContextValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextContextValueSpecified;
		
		[XmlIgnore]
		public ushort nextContextValue
		{ 
			get { return __nextContextValue; }
			set { __nextContextValue = value; __nextContextValueSpecified = true; }
		}

		[XmlElement(Type=typeof(PresenceMode),ElementName="PresenceMode",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PresenceModeCollection __PresenceModeCollection;
		
		[XmlIgnore]
		public PresenceModeCollection PresenceModeCollection
		{
			get
			{
				if (__PresenceModeCollection == null) __PresenceModeCollection = new PresenceModeCollection();
				return __PresenceModeCollection;
			}
			set {__PresenceModeCollection = value;}
		}

		public Presence()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="PresenceMode",Namespace=Declarations.SchemaVersion),Serializable]
	public class PresenceMode
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="contextValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __contextValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __contextValueSpecified;
		
		[XmlIgnore]
		public ushort contextValue
		{ 
			get { return __contextValue; }
			set { __contextValue = value; __contextValueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public PresenceMode()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="StatsViews",Namespace=Declarations.SchemaVersion),Serializable]
	public class StatsViews
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return StatsViewCollection.GetEnumerator();
		}

		public StatsView Add(StatsView obj)
		{
			return StatsViewCollection.Add(obj);
		}

		[XmlIgnore]
		public StatsView this[int index]
		{
			get { return (StatsView) StatsViewCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return StatsViewCollection.Count; }
        }

        public void Clear()
		{
            StatsViewCollection.Clear();
        }

		public StatsView Remove(int index) 
		{ 
            StatsView obj = StatsViewCollection[index];
            StatsViewCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            StatsViewCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextViewId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextViewId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextViewIdSpecified;
		
		[XmlIgnore]
		public uint nextViewId
		{ 
			get { return __nextViewId; }
			set { __nextViewId = value; __nextViewIdSpecified = true; }
		}

		[XmlElement(Type=typeof(StatsView),ElementName="StatsView",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public StatsViewCollection __StatsViewCollection;
		
		[XmlIgnore]
		public StatsViewCollection StatsViewCollection
		{
			get
			{
				if (__StatsViewCollection == null) __StatsViewCollection = new StatsViewCollection();
				return __StatsViewCollection;
			}
			set {__StatsViewCollection = value;}
		}

		public StatsViews()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="StatsView",Namespace=Declarations.SchemaVersion),Serializable]
	public class StatsView
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
        
        [XmlAttribute(AttributeName = "platformVisible", DataType = "string")]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public string platformVisible;

        [XmlAttribute(AttributeName = "platformVisibleRatingAttributeId", DataType = "unsignedInt")]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public System.UInt32 platformVisibleRatingAttributeId;

        [XmlIgnore]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool platformVisibleRatingAttributeIdSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="resetType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public resetType __resetType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __resetTypeSpecified;
		
		[XmlIgnore]
		public resetType resetType
		{ 
			get { return __resetType; }
			set { __resetType = value; __resetTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="entryExpiration",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __entryExpiration;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __entryExpirationSpecified;
		
		[XmlIgnore]
		public ushort entryExpiration
		{ 
			get { return __entryExpiration; }
			set { __entryExpiration = value; __entryExpirationSpecified = true; }
		}

		[XmlAttribute(AttributeName="topEntries",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __topEntries;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __topEntriesSpecified;
		
		[XmlIgnore]
		public uint topEntries
		{ 
			get { return __topEntries; }
			set { __topEntries = value; __topEntriesSpecified = true; }
		}

		[XmlAttribute(AttributeName="arbitrated",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arbitrated;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arbitratedSpecified;
		
		[XmlIgnore]
		public bool arbitrated
		{ 
			get { return __arbitrated; }
			set { __arbitrated = value; __arbitratedSpecified = true; }
		}

		[XmlAttribute(AttributeName="hidden",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hidden;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hiddenSpecified;
		
		[XmlIgnore]
		public bool hidden
		{ 
			get { return __hidden; }
			set { __hidden = value; __hiddenSpecified = true; }
		}

		[XmlAttribute(AttributeName="maxAttachments",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __maxAttachments;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __maxAttachmentsSpecified;
		
		[XmlIgnore]
		public ushort maxAttachments
		{ 
			get { return __maxAttachments; }
			set { __maxAttachments = value; __maxAttachmentsSpecified = true; }
		}

		[XmlAttribute(AttributeName="onlineOnly",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __onlineOnly;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __onlineOnlySpecified;
		
		[XmlIgnore]
		public bool onlineOnly
		{ 
			get { return __onlineOnly; }
			set { __onlineOnly = value; __onlineOnlySpecified = true; }
		}

		[XmlAttribute(AttributeName="flipAxes",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __flipAxes;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __flipAxesSpecified;
		
		[XmlIgnore]
		public bool flipAxes
		{ 
			get { return __flipAxes; }
			set { __flipAxes = value; __flipAxesSpecified = true; }
		}

		[XmlAttribute(AttributeName="viewType",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __viewType;
		
		[XmlIgnore]
		public string viewType
		{ 
			get { return __viewType; }
			set { __viewType = value; }
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ViewAxisType),ElementName="Columns",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ViewAxisType __Columns;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ViewAxisType Columns
		{
			get
			{
				if (__Columns == null) __Columns = new ServerTestFramework.STFTools.ConfigFiles.ViewAxisType();		
				return __Columns;
			}
			set {__Columns = value;}
		}

		public StatsView()
		{
		}

		public void MakeSchemaCompliant()
		{
			Columns.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Matchmaking",Namespace=Declarations.SchemaVersion),Serializable]
	public class Matchmaking
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="isV1Title",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isV1Title;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isV1TitleSpecified;
		
		[XmlIgnore]
		public bool isV1Title
		{ 
			get { return __isV1Title; }
			set { __isV1Title = value; __isV1TitleSpecified = true; }
		}

		[XmlElement(Type=typeof(Schema),ElementName="Schema",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Schema __Schema;
		
		[XmlIgnore]
		public Schema Schema
		{
			get
			{
				if (__Schema == null) __Schema = new Schema();		
				return __Schema;
			}
			set {__Schema = value;}
		}

		[XmlElement(Type=typeof(Constants),ElementName="Constants",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Constants __Constants;
		
		[XmlIgnore]
		public Constants Constants
		{
			get
			{
				if (__Constants == null) __Constants = new Constants();		
				return __Constants;
			}
			set {__Constants = value;}
		}

		[XmlElement(Type=typeof(Queries),ElementName="Queries",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Queries __Queries;
		
		[XmlIgnore]
		public Queries Queries
		{
			get
			{
				if (__Queries == null) __Queries = new Queries();		
				return __Queries;
			}
			set {__Queries = value;}
		}

		public Matchmaking()
		{
			isV1Title = false;
		}

		public void MakeSchemaCompliant()
		{
			Schema.MakeSchemaCompliant();
			Constants.MakeSchemaCompliant();
			Queries.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Schema",Namespace=Declarations.SchemaVersion),Serializable]
	public class Schema
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return AttributeCollection.GetEnumerator();
		}

		public Attribute Add(Attribute obj)
		{
			return AttributeCollection.Add(obj);
		}

		[XmlIgnore]
		public Attribute this[int index]
		{
			get { return (Attribute) AttributeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return AttributeCollection.Count; }
        }

        public void Clear()
		{
            AttributeCollection.Clear();
        }

		public Attribute Remove(int index) 
		{ 
            Attribute obj = AttributeCollection[index];
            AttributeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            AttributeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Attribute),ElementName="Attribute",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public AttributeCollection __AttributeCollection;
		
		[XmlIgnore]
		public AttributeCollection AttributeCollection
		{
			get
			{
				if (__AttributeCollection == null) __AttributeCollection = new AttributeCollection();
				return __AttributeCollection;
			}
			set {__AttributeCollection = value;}
		}

		public Schema()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Attribute",Namespace=Declarations.SchemaVersion),Serializable]
	public class Attribute
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		public Attribute()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Constants",Namespace=Declarations.SchemaVersion),Serializable]
	public class Constants
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ConstantCollection.GetEnumerator();
		}

		public Constant Add(Constant obj)
		{
			return ConstantCollection.Add(obj);
		}

		[XmlIgnore]
		public Constant this[int index]
		{
			get { return (Constant) ConstantCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ConstantCollection.Count; }
        }

        public void Clear()
		{
            ConstantCollection.Clear();
        }

		public Constant Remove(int index) 
		{ 
            Constant obj = ConstantCollection[index];
            ConstantCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ConstantCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public uint nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Constant),ElementName="Constant",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ConstantCollection __ConstantCollection;
		
		[XmlIgnore]
		public ConstantCollection ConstantCollection
		{
			get
			{
				if (__ConstantCollection == null) __ConstantCollection = new ConstantCollection();
				return __ConstantCollection;
			}
			set {__ConstantCollection = value;}
		}

		public Constants()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Constant",Namespace=Declarations.SchemaVersion),Serializable]
	public class Constant
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="value",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __value;
		
		[XmlIgnore]
		public string @value
		{ 
			get { return __value; }
			set { __value = value; }
		}

		public Constant()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Queries",Namespace=Declarations.SchemaVersion),Serializable]
	public class Queries
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return QueryCollection.GetEnumerator();
		}

		public Query Add(Query obj)
		{
			return QueryCollection.Add(obj);
		}

		[XmlIgnore]
		public Query this[int index]
		{
			get { return (Query) QueryCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return QueryCollection.Count; }
        }

        public void Clear()
		{
            QueryCollection.Clear();
        }

		public Query Remove(int index) 
		{ 
            Query obj = QueryCollection[index];
            QueryCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            QueryCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public uint nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Query),ElementName="Query",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public QueryCollection __QueryCollection;
		
		[XmlIgnore]
		public QueryCollection QueryCollection
		{
			get
			{
				if (__QueryCollection == null) __QueryCollection = new QueryCollection();
				return __QueryCollection;
			}
			set {__QueryCollection = value;}
		}

		public Queries()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Query",Namespace=Declarations.SchemaVersion),Serializable]
	public class Query
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="maxResults",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __maxResults;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __maxResultsSpecified;
		
		[XmlIgnore]
		public ushort maxResults
		{ 
			get { return __maxResults; }
			set { __maxResults = value; __maxResultsSpecified = true; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type2 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type2 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="qosProbe",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __qosProbe;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __qosProbeSpecified;
		
		[XmlIgnore]
		public bool qosProbe
		{ 
			get { return __qosProbe; }
			set { __qosProbe = value; __qosProbeSpecified = true; }
		}

		[XmlAttribute(AttributeName="groupBy",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __groupBy;
		
		[XmlIgnore]
		public string groupBy
		{ 
			get { return __groupBy; }
			set { __groupBy = value; }
		}

		[XmlElement(Type=typeof(Parameters),ElementName="Parameters",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Parameters __Parameters;
		
		[XmlIgnore]
		public Parameters Parameters
		{
			get
			{
				if (__Parameters == null) __Parameters = new Parameters();		
				return __Parameters;
			}
			set {__Parameters = value;}
		}

		[XmlElement(Type=typeof(Filters),ElementName="Filters",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Filters __Filters;
		
		[XmlIgnore]
		public Filters Filters
		{
			get
			{
				if (__Filters == null) __Filters = new Filters();		
				return __Filters;
			}
			set {__Filters = value;}
		}

		[XmlElement(Type=typeof(SortOperations),ElementName="SortOperations",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SortOperations __SortOperations;
		
		[XmlIgnore]
		public SortOperations SortOperations
		{
			get
			{
				if (__SortOperations == null) __SortOperations = new SortOperations();		
				return __SortOperations;
			}
			set {__SortOperations = value;}
		}

		[XmlElement(Type=typeof(Returns),ElementName="Returns",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Returns __Returns;
		
		[XmlIgnore]
		public Returns Returns
		{
			get
			{
				if (__Returns == null) __Returns = new Returns();		
				return __Returns;
			}
			set {__Returns = value;}
		}

		public Query()
		{
		}

		public void MakeSchemaCompliant()
		{
			Parameters.MakeSchemaCompliant();
			Filters.MakeSchemaCompliant();
			SortOperations.MakeSchemaCompliant();
			Returns.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Parameters",Namespace=Declarations.SchemaVersion),Serializable]
	public class Parameters
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ParameterCollection.GetEnumerator();
		}

		public Parameter Add(Parameter obj)
		{
			return ParameterCollection.Add(obj);
		}

		[XmlIgnore]
		public Parameter this[int index]
		{
			get { return (Parameter) ParameterCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ParameterCollection.Count; }
        }

        public void Clear()
		{
            ParameterCollection.Clear();
        }

		public Parameter Remove(int index) 
		{ 
            Parameter obj = ParameterCollection[index];
            ParameterCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ParameterCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Parameter),ElementName="Parameter",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ParameterCollection __ParameterCollection;
		
		[XmlIgnore]
		public ParameterCollection ParameterCollection
		{
			get
			{
				if (__ParameterCollection == null) __ParameterCollection = new ParameterCollection();
				return __ParameterCollection;
			}
			set {__ParameterCollection = value;}
		}

		public Parameters()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Parameter",Namespace=Declarations.SchemaVersion),Serializable]
	public class Parameter
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		public Parameter()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Filters",Namespace=Declarations.SchemaVersion),Serializable]
	public class Filters
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return FilterCollection.GetEnumerator();
		}

		public Filter Add(Filter obj)
		{
			return FilterCollection.Add(obj);
		}

		[XmlIgnore]
		public Filter this[int index]
		{
			get { return (Filter) FilterCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return FilterCollection.Count; }
        }

        public void Clear()
		{
            FilterCollection.Clear();
        }

		public Filter Remove(int index) 
		{ 
            Filter obj = FilterCollection[index];
            FilterCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            FilterCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Filter),ElementName="Filter",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public FilterCollection __FilterCollection;
		
		[XmlIgnore]
		public FilterCollection FilterCollection
		{
			get
			{
				if (__FilterCollection == null) __FilterCollection = new FilterCollection();
				return __FilterCollection;
			}
			set {__FilterCollection = value;}
		}

		public Filters()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Filter",Namespace=Declarations.SchemaVersion),Serializable]
	public class Filter
	{

		[XmlAttribute(AttributeName="left",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __left;
		
		[XmlIgnore]
		public string left
		{ 
			get { return __left; }
			set { __left = value; }
		}

		[XmlAttribute(AttributeName="leftType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType __leftType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __leftTypeSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType leftType
		{ 
			get { return __leftType; }
			set { __leftType = value; __leftTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="op",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __op;
		
		[XmlIgnore]
		public string op
		{ 
			get { return __op; }
			set { __op = value; }
		}

		[XmlAttribute(AttributeName="right",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __right;
		
		[XmlIgnore]
		public string right
		{ 
			get { return __right; }
			set { __right = value; }
		}

		[XmlAttribute(AttributeName="rightType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType __rightType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __rightTypeSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType rightType
		{ 
			get { return __rightType; }
			set { __rightType = value; __rightTypeSpecified = true; }
		}

		public Filter()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="SortOperations",Namespace=Declarations.SchemaVersion),Serializable]
	public class SortOperations
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return SortOperationCollection.GetEnumerator();
		}

		public SortOperation Add(SortOperation obj)
		{
			return SortOperationCollection.Add(obj);
		}

		[XmlIgnore]
		public SortOperation this[int index]
		{
			get { return (SortOperation) SortOperationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return SortOperationCollection.Count; }
        }

        public void Clear()
		{
            SortOperationCollection.Clear();
        }

		public SortOperation Remove(int index) 
		{ 
            SortOperation obj = SortOperationCollection[index];
            SortOperationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            SortOperationCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(SortOperation),ElementName="SortOperation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SortOperationCollection __SortOperationCollection;
		
		[XmlIgnore]
		public SortOperationCollection SortOperationCollection
		{
			get
			{
				if (__SortOperationCollection == null) __SortOperationCollection = new SortOperationCollection();
				return __SortOperationCollection;
			}
			set {__SortOperationCollection = value;}
		}

		public SortOperations()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="SortOperation",Namespace=Declarations.SchemaVersion),Serializable]
	public class SortOperation
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type23 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type23 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="distanceid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __distanceid;
		
		[XmlIgnore]
		public string distanceid
		{ 
			get { return __distanceid; }
			set { __distanceid = value; }
		}

		public SortOperation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Returns",Namespace=Declarations.SchemaVersion),Serializable]
	public class Returns
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ReturnCollection.GetEnumerator();
		}

		public @Return Add(@Return obj)
		{
			return ReturnCollection.Add(obj);
		}

		[XmlIgnore]
		public @Return this[int index]
		{
			get { return (@Return) ReturnCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ReturnCollection.Count; }
        }

        public void Clear()
		{
            ReturnCollection.Clear();
        }

		public @Return Remove(int index) 
		{ 
            @Return obj = ReturnCollection[index];
            ReturnCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ReturnCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Return),ElementName="Return",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ReturnCollection __ReturnCollection;
		
		[XmlIgnore]
		public ReturnCollection ReturnCollection
		{
			get
			{
				if (__ReturnCollection == null) __ReturnCollection = new ReturnCollection();
				return __ReturnCollection;
			}
			set {__ReturnCollection = value;}
		}

		public Returns()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Return",Namespace=Declarations.SchemaVersion),Serializable]
	public class @Return
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type234 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type234 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		public @Return()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ProductInformation",Namespace=Declarations.SchemaVersion),Serializable]
	public class ProductInformation
	{

		[XmlAttribute(AttributeName="offlinePlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __offlinePlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offlinePlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort offlinePlayersMax
		{ 
			get { return __offlinePlayersMax; }
			set { __offlinePlayersMax = value; __offlinePlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="systemLinkPlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __systemLinkPlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __systemLinkPlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort systemLinkPlayersMax
		{ 
			get { return __systemLinkPlayersMax; }
			set { __systemLinkPlayersMax = value; __systemLinkPlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="livePlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __livePlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __livePlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort livePlayersMax
		{ 
			get { return __livePlayersMax; }
			set { __livePlayersMax = value; __livePlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="shortDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __shortDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __shortDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort shortDescriptionStringId
		{ 
			get { return __shortDescriptionStringId; }
			set { __shortDescriptionStringId = value; __shortDescriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="sellTextStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __sellTextStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __sellTextStringIdSpecified;
		
		[XmlIgnore]
		public ushort sellTextStringId
		{ 
			get { return __sellTextStringId; }
			set { __sellTextStringId = value; __sellTextStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="publisherStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __publisherStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __publisherStringIdSpecified;
		
		[XmlIgnore]
		public ushort publisherStringId
		{ 
			get { return __publisherStringId; }
			set { __publisherStringId = value; __publisherStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="developerStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __developerStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __developerStringIdSpecified;
		
		[XmlIgnore]
		public ushort developerStringId
		{ 
			get { return __developerStringId; }
			set { __developerStringId = value; __developerStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="genreTextStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __genreTextStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreTextStringIdSpecified;
		
		[XmlIgnore]
		public ushort genreTextStringId
		{ 
			get { return __genreTextStringId; }
			set { __genreTextStringId = value; __genreTextStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __arcadeDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort arcadeDescriptionStringId
		{ 
			get { return __arcadeDescriptionStringId; }
			set { __arcadeDescriptionStringId = value; __arcadeDescriptionStringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Rating),ElementName="Rating",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public RatingCollection __RatingCollection;
		
		[XmlIgnore]
		public RatingCollection RatingCollection
		{
			get
			{
				if (__RatingCollection == null) __RatingCollection = new RatingCollection();
				return __RatingCollection;
			}
			set {__RatingCollection = value;}
		}

		[XmlElement(Type=typeof(Genre),ElementName="Genre",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GenreCollection __GenreCollection;
		
		[XmlIgnore]
		public GenreCollection GenreCollection
		{
			get
			{
				if (__GenreCollection == null) __GenreCollection = new GenreCollection();
				return __GenreCollection;
			}
			set {__GenreCollection = value;}
		}

		[XmlElement(Type=typeof(Feature),ElementName="Feature",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public FeatureCollection __FeatureCollection;
		
		[XmlIgnore]
		public FeatureCollection FeatureCollection
		{
			get
			{
				if (__FeatureCollection == null) __FeatureCollection = new FeatureCollection();
				return __FeatureCollection;
			}
			set {__FeatureCollection = value;}
		}

		[XmlElement(Type=typeof(Platform),ElementName="Platform",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PlatformCollection __PlatformCollection;
		
		[XmlIgnore]
		public PlatformCollection PlatformCollection
		{
			get
			{
				if (__PlatformCollection == null) __PlatformCollection = new PlatformCollection();
				return __PlatformCollection;
			}
			set {__PlatformCollection = value;}
		}

		public ProductInformation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Rating",Namespace=Declarations.SchemaVersion),Serializable]
	public class Rating
	{

		[XmlAttribute(AttributeName="ratingSystemId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __ratingSystemId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ratingSystemIdSpecified;
		
		[XmlIgnore]
		public uint ratingSystemId
		{ 
			get { return __ratingSystemId; }
			set { __ratingSystemId = value; __ratingSystemIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="ratingId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __ratingId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ratingIdSpecified;
		
		[XmlIgnore]
		public uint ratingId
		{ 
			get { return __ratingId; }
			set { __ratingId = value; __ratingIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="imageId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __imageId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __imageIdSpecified;
		
		[XmlIgnore]
		public uint imageId
		{ 
			get { return __imageId; }
			set { __imageId = value; __imageIdSpecified = true; }
		}

		[XmlElement(ElementName="Description",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Description;
		
		[XmlIgnore]
		public string Description
		{ 
			get { return __Description; }
			set { __Description = value; }
		}

		public Rating()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Genre",Namespace=Declarations.SchemaVersion),Serializable]
	public class Genre
	{

		[XmlAttribute(AttributeName="genreId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __genreId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreIdSpecified;
		
		[XmlIgnore]
		public uint genreId
		{ 
			get { return __genreId; }
			set { __genreId = value; __genreIdSpecified = true; }
		}

		public Genre()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Feature",Namespace=Declarations.SchemaVersion),Serializable]
	public class Feature
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="enabled",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __enabled;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __enabledSpecified;
		
		[XmlIgnore]
		public bool enabled
		{ 
			get { return __enabled; }
			set { __enabled = value; __enabledSpecified = true; }
		}

		public Feature()
		{
			enabled = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Platform",Namespace=Declarations.SchemaVersion),Serializable]
	public class Platform
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public Platform()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GamerPictures",Namespace=Declarations.SchemaVersion),Serializable]
	public class GamerPictures
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PictureCollection.GetEnumerator();
		}

		public Picture Add(Picture obj)
		{
			return PictureCollection.Add(obj);
		}

		[XmlIgnore]
		public Picture this[int index]
		{
			get { return (Picture) PictureCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PictureCollection.Count; }
        }

        public void Clear()
		{
            PictureCollection.Clear();
        }

		public Picture Remove(int index) 
		{ 
            Picture obj = PictureCollection[index];
            PictureCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PictureCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Picture),ElementName="Picture",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PictureCollection __PictureCollection;
		
		[XmlIgnore]
		public PictureCollection PictureCollection
		{
			get
			{
				if (__PictureCollection == null) __PictureCollection = new PictureCollection();
				return __PictureCollection;
			}
			set {__PictureCollection = value;}
		}

		public GamerPictures()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Picture",Namespace=Declarations.SchemaVersion),Serializable]
	public class Picture
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public Picture()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\MsgTool.cs ===
using System;
using System.IO;
using System.Diagnostics;
using System.Text;
using ServerTestFramework.Utilities;
using System.Collections;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running MsgTool.
    /// </summary>
    public class MsgTool
    {
        const string DefaultMsgToolPath = @"D:\webroot\xbltools";

        private ProcessWrapper _MsgToolProcess;
        
        public MsgTool()
        {
            _MsgToolProcess = new ProcessWrapper("MsgTool", Path.Combine(DefaultMsgToolPath, "MsgTool.exe"));
        }

        public MsgTool(string toolPath) : this()
        {
            _MsgToolProcess.ExecutablePath = Path.GetFullPath(toolPath);
        }

        /// <summary>
        /// Gets or sets path to MsgTool
        /// </summary>
        public string MsgToolPath
        {
            get { return _MsgToolProcess.ExecutablePath; }
            set { _MsgToolProcess.ExecutablePath = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of MsgTool.
        /// </summary>
        public string Output
        {
            get { return _MsgToolProcess.Output; }
        }


        /// <summary>
        /// Adds a string to the table.
        /// </summary>
        /// <param name="stringID">ID of the string to be added</param>
        /// <param name="text">The text of the string in the appropriate language.</param>
        /// <param name="lang">The language of this instance of the message.</param>
        /// <remarks> Command Line: 
        /// MSGTOOL /addstring /id:[id] /text:[text] /lang:[language]<br/> 
        /// You must add a string to the table before you send it via SystemMessage, UserMessage,
        /// or TitleMessage since these take the ID of the string.<br/>
        /// Msgtool generates the following for this command line:
        /// D:\msgtool /addstring /id:50001 /text:"This is a test." /lang:1
        /// <code>
        /// Adding string - id:50001,lang:1,text:This is a test.
        /// String Service address 10.20.1.5:11020
        /// String Service address 10.20.1.5:11020
        /// 
        /// 
        /// String added successfully.
        /// 
        /// </code></remarks>
        public void AddString(uint stringID, string text, StringLanguage lang)
        {
            string args = String.Format("/addstring /id:{0} /text:\"{1}\" /lang:{2}", stringID, text, (int)lang);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /addsystemmsg /id:[id] /expiration:[expiration] /recommended
        /// <summary>
        /// Sends a string to all users when they sign in their language or the default.
        /// Has the recommended option for sending to Xbox 1.
        /// </summary>
        /// <param name="stringID">ID of the string to be sent</param>
        /// <param name="expiration">When this message will expire from the server</param>
        /// <param name="recommended">Xbox 1 setting.  No effect on Xbox 360</param>
        /// <remarks>Add system message generates the following output from the command line:
        /// msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding system message - id:50001,expiration:5/17/2006
        /// System message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendSystemMsg(uint stringID, string expiration, bool recommended)
        {
            string args = String.Format("/addsystemmsg /id:{0} /expiration:{1}", stringID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Sends a string to all users when they sign in their language or the default.
        /// Defaults as required on Xbox1.
        /// </summary>
        /// <param name="stringID">ID of the string to be sent</param>
        /// <param name="expiration">When this message will expire from the server</param>
        /// <remarks>Command Line: MSGTOOL /addsystemmsg /id:[id] /expiration:[expiration]<br/>
        /// Adds the specified string to the table to be sent to all users.
        /// Add system message generates the following output from the command line:
        /// msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding system message - id:50001,expiration:5/17/2006
        /// System message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendSystemMsg(uint stringID, string expiration)
        {
            string args = String.Format("/addsystemmsg /id:{0} /expiration:{1}", stringID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumsysmsg
        /// <summary>
        /// Enumerate all the System Messages in the queue
        /// </summary>
        /// <returns>MessageEntries collection of the sent messages</returns>
        /// <remarks>
        /// Return is formatted like this: (Blank line appears to be output before and after.
        /// <code>
        ///     
        /// Enumerating System Messages...
        /// 
        /// TitleID, MsgID, Sent, ExpireDate, Description
        /// 0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live
        ///
        /// End Enumeration.
        ///         
        /// </code> OR <code>
        ///       
        /// Enumerating System Messages...
        /// There were no messages in the system message queue.
        ///        
        /// </code>                                         */
        /// </remarks>
        public MessageEntries EnumSystemMsg()
        {
            MessageEntries sysMsgs = new MessageEntries();

            if (_MsgToolProcess.Run("/enumsysmsg") != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[2] == "There were no messages in the system message queue.")
            {
                return sysMsgs;
            }
            int idx = 4;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                sysMsgs.Add(new MessageEntry(output[idx]));
                idx++;
            }
            
            return sysMsgs;
        }

        // MSGTOOL /addtitlemsg /id:[id] /title:[titleid] /expiration:[expiration] [/recommended]
        /// <summary>
        /// Sends a message to all users of a specified title
        /// </summary>
        /// <param name="stringID">ID of previously added string to be sent</param>
        /// <param name="titleID">TitleID</param>
        /// <param name="expiration">Expiration date of the message</param>
        /// <remarks>The following was generated from this command line: msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
        /// Title message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendTitleMsg(uint stringID, uint titleID, string expiration)
        {
            string args = String.Format("/addtitlemsg /id:{0} /title:0x{1:x} /expiration:{2}", stringID, titleID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Sends a message to all users of a specified title
        /// </summary>
        /// <param name="stringID">ID of previously added string to be sent</param>
        /// <param name="titleID">TitleID</param>>
        /// <param name="expiration">Expiration date of the message</param>
        /// <param name="recommended">Xbox1 recommended message or required</param>
        /// <remarks>The following was generated from this command line: msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
        /// <code>
        /// Checking for existence of string 50001...
        /// Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
        /// Title message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendTitleMsg(uint stringID, uint titleID, string expiration, bool recommended)
        {
            string args = String.Format("/addtitlemsg /id:{0} /title:0x{1:x} /expiration:{2}", stringID, titleID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumtitlemsg /title:[titleid]
        /// <summary>
        /// Enumerate all the System Messages in the queue
        /// </summary>
        /// <returns>MessageEntries collection of the sent messages</returns>
        /// <remarks>
        /// Return is formatted like this: (Blank line appears to be output before and after.
        /// <code>
        ///     
        /// Enumerating System Messages...
        /// 
        /// TitleID, MsgID, Sent, ExpireDate, Description
        /// 0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live
        ///
        /// End Enumeration.
        ///         
        /// </code> OR <code>
        ///       
        /// Enumerating System Messages...
        /// There were no messages in the system message queue.
        ///        
        /// </code>                                         */
        /// </remarks>
        public MessageEntries EnumTitleMsg(uint titleID)
        {
            MessageEntries titleMsgs = new MessageEntries();
            
            if (_MsgToolProcess.Run(String.Format("/enumtitlemsg /title:0x{0:x}",titleID)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[2] == "There were no messages in the system message queue.")
            {
                return titleMsgs;
            }
            int idx = 4;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                titleMsgs.Add(new MessageEntry(output[idx]));
                idx++;
            }
            return titleMsgs;
        }

        // MSGTOOL /deletemsg /id:[id] /title:[[titleid | 0]]
        /// <summary>
        /// Deletes a message that was added with the Send functions
        /// </summary>
        /// <param name="messageID">ID of the message.  This is returned from the enumMsg methods</param>
        /// <param name="titleID">TitleID of the Message.  Use 0 for system messages</param>
        /// <remarks>
        /// The following message is output, no matter if the message is deleted, the titleID or the Message isn't found.
        /// <code>
        /// System or title message was successfully deleted or revoked.
        /// 
        /// </code>
        /// </remarks>
        public void DeleteMsg(uint messageID, uint titleID)
        {
            string args;
            if (titleID == 0)
            {
                args = String.Format("/deletemsg /id:{0} /title:0", messageID);
            }
            else
            {
                args = String.Format("/deletemsg /id:{0} /title:0x{1:x}", messageID, titleID);
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /revokemsg /id:[id] /title:[[titleid | 0]]
        /// <summary>
        /// Revokes a message that was added with the Send functions.  Removes any sent instances as well.
        /// </summary>
        /// <param name="messageID">ID of the message.  This is returned from the enumMsg methods</param>
        /// <param name="titleID">TitleID of the Message.  Use 0 for system messages</param>
        /// <remarks>
        /// The following was generated using this command line: msgtool /revokemsg /id:1074107393 /title:0
        /// <code>
        /// System or title message was successfully deleted or revoked.
        /// 
        /// </code>
        /// This same output is generated even if the id does not exist.
        /// </remarks>
        public void RevokeMsg(uint messageID, uint titleID)
        {
            string args;
            if (titleID == 0)
            {
                args = String.Format("/revokemsg /id:{0} /title:0", messageID);
            }
            else
            {
                args = String.Format("/revokemsg /id:{0} /title:0x{1:x}", messageID, titleID);
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /addusermsg /id:[id] [ /user:[puid] | /usertag:[tag] ] /expiration:[expiration] [/recommended]
        /// <summary>
        /// Adds a message for a specified User by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="userPUID">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /user:2533274801615275 /expiration:"5/24/2006" /recommended
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, ulong userPUID, string expiration)
        {
            string args = String.Format("/addtitlemsg /id:{0} /user:{1} /expiration:{2}", stringID, userPUID, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Send a message for specified user on XBox 1 setting recommended by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="userPUID">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <param name="recommended">XBox 1 switch to make recommended or required</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, ulong userPUID, string expiration, bool recommended)
        {
            string args = String.Format("/addtitlemsg /id:{0} /user:{1} /expiration:{2}", stringID, userPUID, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Adds a message for a specified User by GamerTag
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="gamerTag">User's GamerTag</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, string gamerTag, string expiration)
        {
            string args = String.Format("/addusermsg /id:{0} /usertag:{1} /expiration:{2}", stringID, gamerTag, expiration);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
        /// <summary>
        /// Send a message for specified user on XBox 1 setting recommended by PUID
        /// </summary>
        /// <param name="stringID">ID of String to be sent to user</param>
        /// <param name="gamerTag">User's PUID</param>
        /// <param name="expiration">Message Expiration Date</param>
        /// <param name="recommended">XBox 1 switch to make recommended or required</param>
        /// <remarks>
        /// The following output was generated from this command line: msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/24/2006"
        /// <code>
        /// Checking user information ...
        /// Checking for existence of string 50001...
        /// Adding user message - user:2533274801615275,id:50001,expiration:5/24/2006
        /// User message added successfully.
        /// 
        /// </code>
        /// </remarks>
        public void SendUserMsg(uint stringID, string gamerTag, string expiration, bool recommended)
        {
            string args = String.Format("/addusermsg /id:{0} /usertag:{1} /expiration:{2}", stringID, gamerTag, expiration);
            if (recommended)
            {
                args=String.Concat(args, " /recommended");
            }
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        // MSGTOOL /enumusermsg [ /user:[puid] | /usertag:[tag] ]
        /// <summary>
        /// Enumerates the messages for a user from their PUID
        /// </summary>
        /// <param name="puid">PUID of the user</param>
        /// <returns>A collection of UserMessages</returns>
        /// <remarks>The following was returned by the command line: msgtool /enumusermsg /user:2533274801615275
        /// <code>
        /// Checking user information ...
        /// 
        /// SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        /// 0, 5/22/2006 4:52:24 PM, 2, 1, 4294836224, 5/24/2006 12:00:24 AM
        /// 
        /// End Enumeration.
        /// 
        /// </code>
        /// </remarks>
        public UserMessages EnumUserMsg(ulong puid)
        {
            UserMessages userMsgs = new UserMessages();
            
            if (_MsgToolProcess.Run(String.Format("/enumusermsg /user:{0}",puid)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[1] == "There were no messages in this user's message queue.")
            {
                return userMsgs;
            }
            int idx = 3;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                userMsgs.Add(new UserMessage(output[idx]));
                idx++;
            }
            return userMsgs;
        }

        /// <summary>
        /// Returns a list of user messages from a specified gamerTag
        /// </summary>
        /// <param name="gamerTag">User's gamertag</param>
        /// <returns>Collection of UserMessages</returns>
        /// <remarks>The following was returned by the command line: msgtool /enumusermsg /usertag:coerwyn
        /// <code>
        /// Checking user information ...
        /// 
        /// SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        /// 0, 5/22/2006 4:52:24 PM, 2, 1, 4294836224, 5/24/2006 12:00:24 AM
        /// 
        /// End Enumeration.
        /// 
        /// </code>
        /// </remarks>
        public UserMessages EnumUserMsg(string gamerTag)
        {
            UserMessages userMsgs = new UserMessages();
            
            if (_MsgToolProcess.Run(String.Format("/enumusermsg /usertag:{0}",gamerTag)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
            String[] output=_MsgToolProcess.Output.Split('\n');
            if (output[1] == "There were no messages in this user's message queue.")
            {
                return userMsgs;
            }
            int idx = 3;
            while (idx < output.Length && output[idx].Trim() != "")
            {
                userMsgs.Add(new UserMessage(output[idx]));
                idx++;
            }
            return userMsgs;
        }

        // MSGTOOL /deleteusermsg /id:[id] [ /user:[puid] | /usertag:[tag] ]
        /// <summary>
        /// Deletes a user message using the Message ID and PUID.
        /// </summary>
        /// <param name="MsgId">Message ID returned from EnumMessage function</param>
        /// <param name="puid">User's PUID</param>
        /// <remarks>This command line generated the following output: msgtool /deleteusermsg /id:2 /user:2533274801615275
        /// <code>
        /// Checking user information ...
        /// Successfully deleted message ID 2 from the queue of user 2533274801615275
        /// 
        /// </code>
        /// </remarks>
        public void DeleteUserMsg(uint MsgId, ulong puid)
        {
            string args = String.Format("/deleteusermsg /id:{0} /user:{1}", MsgId, puid);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Deletes a user message using the Message ID and GamerTag
        /// </summary>
        /// <param name="MsgId">Message ID returned from EnumMessage function</param>
        /// <param name="gamerTag">User's GamerTag</param>
        /// <remarks>This command line generated the following output: msgtool /deleteusermsg /id:2 /usertag:coerwyn
        /// <code>
        /// Checking user information ...
        /// Successfully deleted message ID 2 from the queue of user 2533274801615275
        /// 
        /// </code>
        /// </remarks>
        public void DeleteUserMsg(uint MsgId, string gamerTag)
        {
            string args = String.Format("/deleteusermsg /id:{0} /usertag:{1}", MsgId, gamerTag);
            if (_MsgToolProcess.Run(args) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Allows running MsgTool with custom argument string.
        /// Mainly used for negative testing.
        /// </summary>
        /// <param name="arguments">Argument string to be used when calling MsgTool.</param>
        public void RunMsgTool(string arguments)
        {
            if (_MsgToolProcess.Run(arguments) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Runs MsgTool taking an XML file of messages and recipients.
        /// </summary>
        /// <param name="XMLFile">XML File path</param>
        public void XMLMessage(string XMLFile)
        {
            _MsgToolProcess.ExecutionTimeout = 6000;  // Boost timeout to 100 mins
            if (_MsgToolProcess.Run(String.Format(@"/addxmlmsg /xml:{0}", XMLFile)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }

        /// <summary>
        /// Runs MsgTool taking an XML file of messages and recipients and *only* validates the XML format.
        /// </summary>
        /// <param name="XMLFile">XML File path</param>
        public void CheckXMLMessage(string XMLFile)
        {
            _MsgToolProcess.ExecutionTimeout = 6000;  // Boost timeout to 100 mins
            if (_MsgToolProcess.Run(String.Format(@"/addxmlmsg /xml:{0} /validatexml", XMLFile)) != 0)
            {
                throw new MsgToolException("MsgTool Failed.", _MsgToolProcess.Output);
            }
        }
    }

    /// <summary>
    /// Language Enum for the strings in MsgTool
    /// </summary>
    public enum StringLanguage
    {
    english=1,
    japanese,
    german,
    french,
    spanish,
    italian,
    korean,
    chinese,
    portuguese
    }

    /// <summary>
    /// Exception class for MsgTool runner
    /// </summary>
    public class MsgToolException : ProcessException
    {
        public MsgToolException() : base("MsgTool") {}
        public MsgToolException(string message) : base("MsgTool", message) {}
        public MsgToolException(string message, Exception innerException) : base("MsgTool", message, innerException) {}
        public MsgToolException(string message, string output) : base("MsgTool", message, output) {}
        public MsgToolException(string message, string output, Exception innerException) :
            base("MsgTool", message, output, innerException) {}
    }

    /// <summary>
    /// A Row returned from the Enum functions of MsgTool of what messages are sent.
    /// </summary>
    public class MessageEntry
    {
        // TitleID, MsgID, Sent, ExpireDate, Description
        public uint titleID;
        public uint msgID;
        public DateTime sentDate;
        public DateTime expireDate;
        public string description;

        /// <summary>
        /// Creates a new MsgTool Message line from a string that MsgTool returns.
        /// </summary>
        /// <param name="entry">Formatted String from MsgTool</param>
        /// <remarks>The tool returns each row like "TitleID, MsgID, Sent, ExpireDate, Description"</remarks>
        public MessageEntry(string entry)
        {
            string[] fields = entry.Split(',');
            if (fields.Length == 5)
            {
                titleID = Convert.ToUInt32(fields[0]);
                msgID = Convert.ToUInt32(fields[1]);
                sentDate = Convert.ToDateTime(fields[2]);
                expireDate = Convert.ToDateTime(fields[3]);
                description = fields[4];
            }
        }
        /// <summary>
        /// Tests if object is equal to this MessageEntry
        /// </summary>
        /// <param name="obj">Object to test</param>
        /// <returns>True if both objects are the same</returns>
        public override bool Equals(object obj)
        {
            if (obj is MessageEntry)
            {
                return
                    (
                    ((MessageEntry)obj).titleID == titleID &&
                    ((MessageEntry)obj).msgID == msgID &&
                    ((MessageEntry)obj).sentDate == sentDate &&
                    ((MessageEntry)obj).expireDate == expireDate &&
                    ((MessageEntry)obj).description == description 
                    );
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Gets the hashcode for this instance
        /// </summary>
        /// <returns>Hashcode</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

    }

    /// <summary>
    /// Collection of MessageEntry objects
    /// </summary>
    public class MessageEntries : CollectionBase
    {
        public MessageEntries() {}

        /// <summary>
        /// Indexer for MessageEntries
        /// </summary>
        public MessageEntry this[int index]
        {
            get { return List[index] as MessageEntry; }
            set { List[index] = value; }
        }

        /// <summary>
        /// Adds a MessageEntry to the collection
        /// </summary>
        /// <param name="val">MessageEntry to add</param>
        /// <returns>Index of MessageEntry</returns>
        public int Add(MessageEntry val)
        {
            return List.Add(val);
        }

        /// <summary>
        /// Tests if MessageEntry is in the collection
        /// </summary>
        /// <param name="val">MessageEntry to test</param>
        /// <returns>True if it is already in the collection</returns>
        public bool Contains(MessageEntry val)
        {
            return List.Contains(val);
        }

        /// <summary>
        /// Removes a MessageEntry from the collection
        /// </summary>
        /// <param name="val">MessageEntry to remove</param>
        public void Remove(MessageEntry val)
        {
            List.Remove(val);
        }
    }

    /// <summary>
    /// A Message for a particular User.  Returned in the collection from the EnumUserMsg function.
    /// </summary>
    public class UserMessage
    {
        // SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
        public uint senderID;
        public uint titleID;
        public uint msgID;
        public int MFlag;
        public DateTime sentDate;
        public DateTime expireDate;

        /// <summary>
        /// Creates a new MsgTool User Message line from a string that MsgTool enumUserMsg returns.
        /// </summary>
        /// <param name="entry">Formatted String from MsgTool</param>
        /// <remarks>The tool returns each row like "SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate"</remarks>
        public UserMessage(string entry)
        {
            string[] fields = entry.Split(',');
            if (fields.Length == 6)
            {
                senderID = Convert.ToUInt32(fields[0]);
                sentDate = Convert.ToDateTime(fields[1]);
                msgID = Convert.ToUInt32(fields[2]);
                MFlag = Convert.ToInt32(fields[3]);
                titleID = Convert.ToUInt32(fields[4]);
                expireDate = Convert.ToDateTime(fields[5]);
                
            }
        }

        /// <summary>
        /// Determines if this UserMessage is equal to another object
        /// </summary>
        /// <param name="obj">Object to be tested</param>
        /// <returns>True if they are equal</returns>
        public override bool Equals(object obj)
        {
            if (obj is UserMessage)
            {
                return
                    (
                    ((UserMessage)obj).senderID == senderID &&
                    ((UserMessage)obj).sentDate == sentDate &&
                    ((UserMessage)obj).msgID == msgID &&
                    ((UserMessage)obj).MFlag == MFlag &&
                    ((UserMessage)obj).titleID == titleID &&
                    ((UserMessage)obj).expireDate == expireDate
                    );
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Gets the hashcode for this object
        /// </summary>
        /// <returns>The hashcode</returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

    }

    /// <summary>
    /// Collection of UserMessage objects
    /// </summary>
    public class UserMessages : CollectionBase
    {
        public UserMessages() {}

        /// <summary>
        /// Indexer for UserMessage
        /// </summary>
        public UserMessage this[int index]
        {
            get { return List[index] as UserMessage; }
            set { List[index] = value; }
        }

        /// <summary>
        /// Adds a new UserMessage to the collection
        /// </summary>
        /// <param name="val">UserMessage to add</param>
        /// <returns>Index of message</returns>
        public int Add(UserMessage val)
        {
            return List.Add(val);
        }

        /// <summary>
        /// Tests if a UserMessage is already in the collection
        /// </summary>
        /// <param name="val">UserMessage to test</param>
        /// <returns>True if UserMessage is in the collection</returns>
        public bool Contains(UserMessage val)
        {
            return List.Contains(val);
        }

        /// <summary>
        /// Removes a UserMessage from the collection
        /// </summary>
        /// <param name="val">UserMessage to remove</param>
        public void Remove(UserMessage val)
        {
            List.Remove(val);
        }
    }
}
/* ------------------------------
 Microsoft Windows [Version 5.2.3790]
(C) Copyright 1985-2003 Microsoft Corp.

C:\Documents and Settings\a-johnk>path
PATH=C:\WINNT\system32;C:\WINNT;C:\WINNT\System32\Wbem;C:\Program Files\Microsoft ADS\bin;C:\Program Files\Microsoft ADS\tools;C:\
Program Files\Dell\SysMgt\oma\bin;C:\Program Files\Microsoft SQL Server\80\Tools\BINN;D:\webroot\xbltools

C:\Documents and Settings\a-johnk>dir
 Volume in drive C is Win2K
 Volume Serial Number is CC80-D514

 Directory of C:\Documents and Settings\a-johnk

05/12/2006  10:41 PM    <DIR>          .
05/12/2006  10:41 PM    <DIR>          ..
05/11/2006  10:13 PM    <DIR>          Desktop
05/11/2006  05:12 PM    <DIR>          Favorites
05/11/2006  09:48 PM    <DIR>          My Documents
08/11/2004  12:02 PM    <DIR>          Start Menu
08/11/2004  12:03 PM                 0 Sti_Trace.log
               1 File(s)              0 bytes
               6 Dir(s)   6,599,094,272 bytes free

C:\Documents and Settings\a-johnk>msgtool

Tool to add messages to the Xbox Live Messaging Service

Usage:
    MSGTOOL /addstring /id:<id> /text:<text> /lang:<language>
    MSGTOOL /addsystemmsg /id:<id> /expiration:<expiration> [/recommended]
    MSGTOOL /enumsysmsg
    MSGTOOL /addtitlemsg /id:<id> /title:<titleid> /expiration:<expiration> [/recommended]
    MSGTOOL /enumtitlemsg /title:<titleid>
    MSGTOOL /deletemsg /id:<id> /title:[<titleid | 0>]
    MSGTOOL /revokemsg /id:<id> /title:[<titleid | 0>]
    MSGTOOL /addusermsg /id:<id> [ /user:<puid> | /usertag:<tag> ] /expiration:<expiration> [/recommended]
    MSGTOOL /enumusermsg [ /user:<puid> | /usertag:<tag> ]
    MSGTOOL /deleteusermsg /id:<id> [ /user:<puid> | /usertag:<tag> ]

Definitions:
    <id>         - A numerical identifier for the string (in decimal)
    <user>       - Unique Xbox Live identifier for the desired user (in decimal)
    <usertag>    - Unique Xbox Live gamertag for the desired user
    <titleid>    - Unique Xbox Live identifier for the desired title (in decimal)
                   If title ID is in Hex notation, it must start with 0x (zero, then x)
                   Note: for /deletemsg or /revokemsg, use titleid 0 to delete system messages
    <language>   - Language of the given text string - 1=english
                                                       2=japanese
                                                       3=german
                                                       4=french
                                                       5=spanish
                                                       6=italian
                                                       7=korean
                                                       8=chinese
                                                       9=portuguese
    <text>       - Text for the message
    <expiration> - Date and time when the message will expire - Example: "10/31/2002"
                   Remember that dates for Live are in the UTC time zone (+8 from PST).
    recommended  - Specifies that the message is a recommended message. By default, messages
                   are marked as required.
                   Note: The Xbox 360 simply shows both recommended and required messages
                   in the message center. There is no enforced viewing of messages sent by
                   this tool. Special messages (such as voice bans) are sent through the
                   CUST front door that performs extra work to force the Xbox 360 to read
                   them. Recommended and required messages are still honored by the Xbox 1
                   dashboard

Description:
    Adding a message is a two step process. Typically, the message you are sending will
    be of a type that we commonly send, so you can skip the first step and simply use the known
    string ID in the second step.

    First, you need to add the message string to the string service in all required languages
    using the msgtool /addstring syntax.

    Second, you need to associate the string ID with the appropriate queue (system, title
    or user) using the msgtool /addXXXmsg syntax.

Examples:
    Adding a string for English:
    msgtool /addstring /id:50000 /text:"Message" /lang:1

    Adding a system message which uses the above string, expiring two days from now:
    msgtool /addsystemmsg /id:50000 /expiration:"5/17/2006"

    Adding a system-title message for users of title 1431502860:
    msgtool /addtitlemsg /id:50000 /title:1431502860 /expiration:"5/17/2006"

    Adding a system-title message for same title above, using Hex notation (Note the 0x):
    msgtool /addtitlemsg /id:50000 /title:0x5553000C /expiration:"5/17/2006"

    Adding a Recommended User message using user's PUID :
    msgtool /addusermsg /id:50000 /user:27517529866 /expiration:"5/17/2006" /recommended

    Adding a Required User message using user's Gamertag (Note: it's /usertag, not /user):
    msgtool /addusermsg /id:50000 /usertag:CreativeGamertag /expiration:"5/17/2006"

    Enumerating a User's messages using user's Gamertag:
    msgtool /enumusermsg /usertag:CreativeGamertag

    Enumerating title messages:
    msgtool /enumtitlemsg /title:0x5553000C

    Enumerating system messages:
    msgtool /enumsysmsg

    Deleting a title message:
    msgtool /deletemsg /id:<msgid> /title:0x5553000C

    Revoking a system message:
    msgtool /revokemsg /id:<msgid> /title:0

        Note: 'deleting' a system message means deleting it from the system message
        table so it will no longer be delivered to users when they sign in.
        'revoking' a system message means deleting it from the system message
        table so it will no longer be delivered to users when they sign in AND
        deleting all instances of it from user message table that have already
        been delivered.

    Deleting a message from a User's message queue:
    --> Do an /enumusermsg first, then use the msgid you get in the call below
    msgtool /deleteusermsg /user:27517529866  /id:<msgid>


C:\Documents and Settings\a-johnk>msgtool /addstring /id:50000 /text:"This is a test." /lang:1
Adding string - id:50000,lang:1,text:This is a test.
String Service address 10.20.1.5:11020
String Service address 10.20.1.5:11020


String added successfully.

C:\Documents and Settings\a-johnk>msgtool /addstring /id:50001 /text:"This is a test." /lang:1
Adding string - id:50001,lang:1,text:This is a test.
String Service address 10.20.1.5:11020
String Service address 10.20.1.5:11020


String added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /addsystemmsg /id:50001 /expiration:"5/17/2006"
Checking for existence of string 50001...
Adding system message - id:50001,expiration:5/17/2006
System message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...

TitleID, MsgID, Sent, ExpireDate, Description
0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /revokemsg /id:50001 /title:0
System or title message was successfully deleted or revoked.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...

TitleID, MsgID, Sent, ExpireDate, Description
0, 1074107393, 5/16/2006 10:45:58 PM, 5/16/2006 11:59:58 PM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /revokemsg /id:1074107393 /title:0
System or title message was successfully deleted or revoked.

C:\Documents and Settings\a-johnk>msgtool /enumsysmsg

Enumerating System Messages...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0

Error: An error occurred while attempting to use the TitleID supplied.
       Please check format and try again.

Exception text is: Invalid title id '0'

C:\Documents and Settings\a-johnk>msgtool /addtitlemsg /id:50001 /title:0xFFFE07D0 /expiration:"5/20/2006"
Checking for existence of string 50001...
Adding title message - title:0xFFFE07D0,id:50001,expiration:5/20/2006
Title message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0xFFFE07D0

Enumerating Messages for Title: 4294838224 ...

TitleID, MsgID, Sent, ExpireDate, Description
4294838224, 1074107394, 5/19/2006 4:21:07 PM, 5/20/2006 12:00:07 AM, Xbox Live

End Enumeration.


C:\Documents and Settings\a-johnk>msgtool /enumtitlemsg /title:0xFFFE07D1

Enumerating Messages for Title: 4294838225 ...
There were no messages in the system message queue.

C:\Documents and Settings\a-johnk>msgtool /addusermsg /id:50001 /usertag:coerwyn /expiration:"5/20/2006"
Checking user information ...
Checking for existence of string 50001...
Adding user message - user:2533274801615275,id:50001,expiration:5/20/2006
User message added successfully.

C:\Documents and Settings\a-johnk>msgtool /enumusermsg /usertag:coerwyn
Checking user information ...

SenderID, SentTime, MessageID, MFlg, SenderTitleID, ExpireDate
0, 5/19/2006 8:11:05 PM, 1, 1, 4294836224, 5/20/2006 12:00:05 AM

End Enumeration.


C:\Documents and Settings\a-johnk>
 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\LiveTitle.cs ===
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the LiveTitle tool.
    /// </summary>
    public class LiveTitle
    {
        const string DefaultLiveTitlePath = "D:\\webroot\\xbltools";

        private string _ltcPath = "";
        private string _xlastPath = "";
        private string _xscPath = "";
        private string _xboxPath = "";
        private string _xmsPath = "";
        private string _marketplacePath = "";
        private string _lbServer = "";
        private string _matchServers = "";
        private ProcessWrapper _liveTitleProcess;
        private Report _report;

        public LiveTitle()
        {
            _liveTitleProcess = new ProcessWrapper("LiveTitle", Path.Combine(DefaultLiveTitlePath, "LiveTitle.exe"));
            _liveTitleProcess.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.CurrentEnvironment.NpdbIp);
            _liveTitleProcess.Verbose = true;
            _report = new Report("LiveTitle");

            try
            {
                string [] servers = Global.XEnv.GetServerListByInterface(Interface.lbsvr);
                if (servers.Length > 0)
                {
                    _lbServer = servers[0];
                }
                else
                {
                    _report.Warn("The leaderboard server list is empty!");
                }

                servers = Global.XEnv.GetServerListByInterface(Interface.xmatch);
                if (servers.Length > 0)
                {
                    _matchServers = servers[0];
                }
                else
                {
                    _report.Warn("The matchmaking server list is empty!");
                }
            }
            catch (Exception e)
            {
                _report.Error("Exception while populating server list: " + e.Message);
            }
        }

        public LiveTitle(string liveTitlePath) : this()
        {
            LiveTitlePath = liveTitlePath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the LiveTitle executable.
        /// </summary>
        public string LiveTitlePath
        {
            get { return _liveTitleProcess.ExecutablePath; }
            set
            {
                _liveTitleProcess.ExecutablePath = Path.GetFullPath(value);
                _liveTitleProcess.WorkingDirectory = Path.GetDirectoryName(_liveTitleProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for LiveTitle
        /// </summary>
        public string WorkingDirectory
        {
            get { return _liveTitleProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _liveTitleProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _liveTitleProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the LTC file used during title 
        /// deployment.
        /// </summary>
        public string LTCPath
        {
            get { return _ltcPath; }
            set
            {
                if (value != null)
                {
                    _ltcPath = Path.GetFullPath(value);
                }
                else
                {
                    _ltcPath = "";
                }
            }
        }

        /// <summary>
        /// Xbox 360 LTC file creation and title deployment.
        /// </summary>
        public string XlastPath
        {
            get { return _xlastPath; }
            set
            {
                if (value != null)
                {
                    _xlastPath = Path.GetFullPath(value);
                }
                else
                {
                    _xlastPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Marketplace file used to deploy a Marketplace-only title.
        /// </summary>
        public string MarketplacePath
        {
            get { return _marketplacePath; }
            set
            {
                if (value != null)
                {
                    _marketplacePath = Path.GetFullPath(value);
                }
                else
                {
                    _marketplacePath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XSC file used during Xbox1 LTC 
        /// file creation and title deployment.
        /// </summary>
        public string XSCPath
        {
            get { return _xscPath; }
            set
            {
                if (value != null)
                {
                    _xscPath = Path.GetFullPath(value);
                }
                else
                {
                    _xscPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XBOX file used during Xbox1 LTC 
        /// file creation and title deployment.
        /// </summary>
        public string XBOXPath
        {
            get { return _xboxPath; }
            set
            {
                if (value != null)
                {
                    _xboxPath = Path.GetFullPath(value);
                }
                else
                {
                    _xboxPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the XMS file used during Xbox1 title 
        /// deployment (optional).
        /// </summary>
        public string XMSPath
        {
            get { return _xmsPath; }
            set
            {
                if (value != null)
                {
                    _xmsPath = Path.GetFullPath(value);
                }
                else
                {
                    _xmsPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the leaderboard server used during LTC file creation.
        /// </summary>
        public string LeaderboardServer
        {
            get { return _lbServer; }
            set { _lbServer = value; }
        }

        /// <summary>
        /// Gets or sets the semi-colon delimited list of match servers used during LTC 
        /// file creation.
        /// </summary>
        public string MatchServers
        {
            get { return _matchServers; }
            set { _matchServers = value; }
        }

        /// <summary>
        /// Gets the output text from the most recent run of LiveTitle.
        /// </summary>
        public string Output
        {
            get { return _liveTitleProcess.Output; }
        }

        /// <summary>
        /// Exposes the Execution Timeout value for the underlying Process wrapper.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _liveTitleProcess.ExecutionTimeout; }
            set { _liveTitleProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Runs LiveTitle to create an LTC file for an Xbox 360 title.
        /// </summary>
        public void CreateXbox360LTCFile()
        {
            CreateXbox360LTCFile(0, 0);
        }

        /// <summary>
        /// Runs LiveTitle with a title id and a disc id to create an LTC file for an Xbox 360 title.
        /// </summary>
        /// <param name="titleId">Title ID to specify with the /titleid parameter. Optional.</param>
        /// <param name="discId">Disc ID to specify with the /discid parameter. Optional.</param>
        public void CreateXbox360LTCFile(uint titleId, uint discId)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();
            
            arguments.AppendFormat("/livetitledefault /xlastpath:{0} /lbs:{1} /matchsvr:{2}",
                _xlastPath, _lbServer, _matchServers);
            if (titleId != 0)
            {
                arguments.AppendFormat(" /titleid:0x{0:x}", titleId);
            }

            if (discId != 0)
            {
                arguments.AppendFormat(" /discid:0x{0:x}", discId);
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _ltcPath = GetLTCPath(_liveTitleProcess.Output);
            }
            else
            {
                throw new LiveTitleException("LiveTitle failed to create the LTC file.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// DeployXbox360Title will run LiveTitle with the /deploy command-line argument.  
        /// If the
        /// LTCPath property does not point to an existing LTC file, then 
        /// CreateXbox360LTCFile
        /// will be called first to generate the LTC file before trying to deploy.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="deployImages">
        /// Flag indicating whether the /images argument should appear on the command 
        /// line.
        /// It is highly recommended that this be set to True for initial deployments.
        /// </param>
        /// <param name="contentUpdate">
        /// Flag indicating whether the /contentupdate argument should be added to the 
        /// command line.
        /// </param>
        /// <param name="version">
        /// Initial version of the title.
        /// </param>
        public void DeployXbox360Title(uint titleId, bool deployImages, bool contentUpdate, uint version)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();
            
            // Make sure the LTC file exists - if not, create one
            if (!File.Exists(_ltcPath))
            {
                CreateXbox360LTCFile(0, 0);
            }

            arguments.AppendFormat("/deploy /xlastpath:{0} /ltcpath:{1}", _xlastPath, _ltcPath);
            if (deployImages)
            {
                arguments.Append(" /images");
            }
            if (contentUpdate)
            {
                arguments.Append(" /contentupdate");
            }
            arguments.AppendFormat(" /version:0x{0:X8}", version);

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new LiveTitleException("Xbox 360 Title deployment failed.", _liveTitleProcess.Output);
            }

            // Validate the data has made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 title without the optional /version parameter.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="deployImages">Images parameter flag</param>
        /// <param name="contentUpdate">Content Update parameter flag</param>
        public void DeployXbox360Title(uint titleId, bool deployImages, bool contentUpdate)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            // Make sure the LTC file exists - if not, create one
            if (!File.Exists(_ltcPath))
            {
                CreateXbox360LTCFile(0, 0);
            }

            arguments.AppendFormat("/deploy /xlastpath:{0} /ltcpath:{1}", _xlastPath, _ltcPath);
            if (deployImages)
            {
                arguments.Append(" /images");
            }
            if (contentUpdate)
            {
                arguments.Append(" /contentupdate");
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new LiveTitleException("Xbox 360 Title deployment failed.", _liveTitleProcess.Output);
            }

            // Validate the data has made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 title with images.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        public void DeployXbox360Title(uint titleId)
        {
            DeployXbox360Title(titleId, true, false);
        }

        /// <summary>
        /// Creates an LTC file for an Xbox1 title.
        /// </summary>
        public void CreateXbox1LTCFile()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/xboxdefault /xboxpath:{0} /lbs:{1}", _xboxPath, _lbServer);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }

            if (_matchServers != null && _matchServers.Length > 0)
            {
                arguments.AppendFormat(" /matchsvr:{0}", _matchServers);
            }

            exitCode = _liveTitleProcess.Run(arguments.ToString());
            if (exitCode == 0)
            {
                _ltcPath = GetLTCPath(_liveTitleProcess.Output);
            }
            else
            {
                throw new LiveTitleException("LiveTitle failed to create the LTC file.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Deploys an Xbox1 title, creating the default LTC file, if needed.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        public void DeployXbox1Title(uint titleId)
        {
            if (!File.Exists(_ltcPath))
            {
                CreateXbox1LTCFile();
            }

            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deployxbox /xboxpath:{0} /ltcpath:{1}", _xboxPath, _ltcPath);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }
            if (_xmsPath.Length > 0)
            {
                arguments.AppendFormat(" /xmspath:{0}", _xmsPath);
            }

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Xbox1 title deployment failed.", _liveTitleProcess.Output);
            }

            // Verify the data made it into NPDB
            ValidateTitleData(titleId);
        }
        public void DeployXbox1Title(uint titleId, uint version)
        {
            if (!File.Exists(_ltcPath))
            {
                CreateXbox1LTCFile();
            }

            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deployxbox /xboxpath:{0} /ltcpath:{1}", _xboxPath, _ltcPath);
            if (_xscPath.Length > 0)
            {
                arguments.AppendFormat(" /xscpath:{0}", _xscPath);
            }
            if (_xmsPath.Length > 0)
            {
                arguments.AppendFormat(" /xmspath:{0}", _xmsPath);
            }
            arguments.AppendFormat(" /version:0x{0:X8}", version);

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Xbox1 title deployment failed.", _liveTitleProcess.Output);
            }

            // Verify the data made it into NPDB
            ValidateTitleData(titleId);
        }

        /// <summary>
        /// Deploys an Xbox 360 Marketplace-only title.
        /// </summary>
        /// <param name="titleId">Title Id</param>
        /// <param name="images">
        /// Flag indicating whether the /images parameter should appear on the command line.
        /// </param>
        public void DeployMarketplaceOnlyTitle(uint titleId, bool images)
        {
            StringBuilder arguments = new StringBuilder();
            arguments.AppendFormat("/deploy /marketplacepath:{0}", _marketplacePath);
            if (images)
            {
                arguments.Append(" /images");
            }

            if (_liveTitleProcess.Run(arguments.ToString()) != 0)
            {
                throw new LiveTitleException("Marketplace-only title deployment failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Locks the game configuration for an Xbox 360 title.
        /// </summary>
        public void LockTitle()
        {
            if (_liveTitleProcess.Run(String.Format("/lock /xlastpath:{0}", _xlastPath)) != 0)
            {
                throw new LiveTitleException("Locking " + _xlastPath + " failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Reports the existing versions for the specified title id.
        /// </summary>
        /// <param name="titleId">The title id</param>
        /// <returns>An array of version strings in the form "base,update,beta"</returns>
        public string [] ReportTitleVersion(uint titleId)
        {
            string [] baseVersions = null;
            Regex r = new Regex(titleId.ToString() + "( )+[0-9]+( )+[0-9]+( )+[0-9]+");
            int i = 0;

            if (_liveTitleProcess.Run(String.Format("/reportver /titleid:0x{0:X}", titleId)) == 0)
            {
                MatchCollection matches = r.Matches(_liveTitleProcess.Output);
                baseVersions = new string[matches.Count];
                foreach (Match row in matches)
                {
                    string[] version = row.Value.Split(new char[1] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
                    baseVersions[i++] = String.Format("{0}:{1},{2},{3}", version[0], version[1], version[2], version[3]);
                }
            }
            else
            {
                throw new LiveTitleException("Version reporting failed.", _liveTitleProcess.Output);
            }

            return baseVersions;
        }

        /// <summary>
        /// Adds a base version entry to UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">New base version to add for this title</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public void AddTitleBaseVersion(uint titleId, uint baseVersion, ConsoleTypeEnum consoleType)
        {
            if (_liveTitleProcess.Run(String.Format("/addbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, baseVersion, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Adding a base version failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Deletes a base version entry from UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">Base version to remove</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public void DeleteTitleBaseVersion(uint titleId, uint baseVersion, ConsoleTypeEnum consoleType)
        {
            if (_liveTitleProcess.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, baseVersion, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", _liveTitleProcess.Output);
            }
        }

        /// <summary>
        /// Adds a base version entry to UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">New base version to add for this title</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public static void AddBaseVersion(uint titleId, uint version, ConsoleTypeEnum consoleType)
        {
            ProcessWrapper liveTitle = new ProcessWrapper("LiveTitle", LiveTitle.DefaultLiveTitlePath);
            if (liveTitle.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, version, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", liveTitle.Output);
            }
        }

        /// <summary>
        /// Deletes a base version entry from UODB for the specified title.
        /// </summary>
        /// <param name="titleId">Title ID</param>
        /// <param name="baseVersion">Base version to remove</param>
        /// <param name="consoleType">The console type. May be Xbox1, Xenon, or PC</param>
        public static void DeleteBaseVersion(uint titleId, uint version, ConsoleTypeEnum consoleType)
        {
            ProcessWrapper liveTitle = new ProcessWrapper("LiveTitle", LiveTitle.DefaultLiveTitlePath);
            if (liveTitle.Run(String.Format("/delbasever /titleid:0x{0:x} /version:0x{1:x} /platform:{2}",
                titleId, version, consoleType.ToString())) != 0)
            {
                throw new LiveTitleException("Deleting a base version failed.", liveTitle.Output);
            }
        }

        /// <summary>
        /// Props a title.  If no path is specified it will be copied from titlevault.
        /// </summary>
        public static void PropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType)
        {
            PropTitle(titleID, version, clientType, null);
        }
        public static void PropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType, string filePath)
        {
            //fix path
            string titleStringNo0x = String.Format("{0:X8}", titleID);

            if (filePath == null || filePath.Length == 0)
            {
                // Retrieve the path to the current environment's Titlevault
                filePath = Config.GetSetting(Setting.titlevault_root);
                if (filePath == null || filePath.Length == 0)
                {
                    throw new LiveTitleException("Unable to get the path to the TitleVault in the " + Global.CurrentEnvironment.Environment + " environment.");
                }
                filePath = Path.Combine(filePath, titleStringNo0x);
            }

            // Check the existence of this title's directory in Titlevault
            if (!Directory.Exists(filePath))
            {
                throw new LiveTitleException("No files exist in the Titlevault for title id 0x" + titleStringNo0x);
            }

            // Copy the title files to a local temp directory (because you're not allowed to prop from Titlevault)
            string tempTitlePath = "LiveTitleTempFiles\\title\\" + titleStringNo0x + "\\";
            System.IO.Directory.CreateDirectory(tempTitlePath);
            int numCopied = 0;
            foreach (string fname in System.IO.Directory.GetFiles(filePath))
            {
                string baseFName = System.IO.Path.GetFileName(fname);
                string srcFile = filePath + "\\" + baseFName;
                string dstFile = tempTitlePath + baseFName;
                //Global.RO.Debug("copying file: "+srcFile+" TO "+dstFile);
                System.IO.File.Copy(srcFile, dstFile, true);
                ++numCopied;
            }
            if (numCopied == 0)
            {
                throw new LiveTitleException("Could not find files for title " + titleStringNo0x + " to prop from " + filePath);
            }
            else
            {
                Global.RO.Debug("Copied " + numCopied + " files for title " + titleStringNo0x + " to a local temp store.");
            }

            //deploy it
            LiveTitle lt = new LiveTitle();
            lt.LTCPath = tempTitlePath + titleStringNo0x + ".ltc";
            lt.XlastPath = tempTitlePath + titleStringNo0x + ".xlast";
            //lt.XSCPath=tempTitlePath+titleStringNo0x+".xsc";
            lt.XBOXPath = tempTitlePath + titleStringNo0x + ".xbox";
            lt.XMSPath = tempTitlePath + titleStringNo0x + ".xms";

            if (clientType == AuthContext.ClientTypes.Xenon)
            {
                lt.DeployXbox360Title(titleID, true, true, version);
            }
            else if (clientType == AuthContext.ClientTypes.Xbox)
            {
                lt.DeployXbox1Title(titleID, version);
            }
            else if (clientType == AuthContext.ClientTypes.Panorama)
            {
                lt.DeployXbox360Title(titleID, true, true, version);
            }
            else
            {
                throw new LiveTitleException("Unhandled platform type specified when trying to deploy title " + titleStringNo0x);
            }

            //
            Global.RO.Debug("Propped title 0x" + titleStringNo0x + " version " + version + ".");
        }

        /// <summary>
        /// Checks if a title is propped.
        /// </summary>
        public static bool CheckIfTitleIsPropped(uint titleID)
        {
            bool isPropped=false;
            try
            {
                string query="select count(*) from t_titles WHERE i_title_id="+(int)titleID;
                int rows=(int)UodbWS.ExecuteSQLSelectCount(query);
                if (rows!=0) isPropped=true;
            }
            catch (Exception e)
            {
                Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check title "+titleID+": "+e.Message+"\nWill assume this indicates that it is not propped.");
            }
            return isPropped;
        }
        public static bool CheckIfTitleIsPropped(uint titleID, uint version)
        {
            //see if the title is there at all
            bool isPropped=CheckIfTitleIsPropped(titleID);            

            //if it is, is this version propped?
            if (isPropped)
            {
                try
                {
                    string query="select count(*) from t_title_versions WHERE i_title_id="+(int)titleID+" and i_base_version="+(int)version;
                    int rows=(int)UodbWS.ExecuteSQLSelectCount(query);
                    if (rows==0) isPropped=false;
                }
                catch (Exception e)
                {
                    Global.RO.Error("UodbWS.ExecuteSQLSelectCount threw while trying to check version "+version+" of title "+titleID+": "+e.Message+"\nWill assume this indicates that it is not propped.");
                    isPropped=false;
                }
            }

            return isPropped;
        }

        /// <summary>
        /// Checks if a title is propped, and if not, props it.  If no path is specified it will be copied from stressnet titlevault.
        /// </summary>
        public static void CheckAndPropTitle(uint titleID, uint version, AuthContext.ClientTypes clientType, string filePath)
        {
            if (!CheckIfTitleIsPropped(titleID,version))
            {
                Global.RO.Debug("Title 0x{0:X8} version "+version+" is not propped.  Will try to prop it.", titleID);
                PropTitle(titleID,version,clientType,filePath);
            }
            else
            {
                Global.RO.Debug("Title 0x{0:X8} version "+version+" is already propped.", titleID);
            }
        }

        /// <summary>
        /// Performs basic validation that the title deployment succeeded.
        /// </summary>
        private void ValidateTitleData(uint titleId)
        {
            NpdbUtility npdb = new NpdbUtility();
            LiveTitleConfigRow ltcRow;
            GameConfigRow gcRow;

            npdb.ConnectToServer();
            try
            {
                npdb.GetGameConfig(titleId, out gcRow);
                ltcRow = npdb.GetLiveTitleConfig(titleId);

                if (gcRow == null || ltcRow == null)
                {
                    throw new LiveTitleException("Unable to get title data from NPDB.", _liveTitleProcess.Output);
                }
            }
            catch (DatabaseException dEx)
            {
                throw new LiveTitleException("Unable to verify title data.", _liveTitleProcess.Output, dEx);
            }
            finally
            {
                npdb.Close();
            }
        }

        private string GetLTCPath(string liveTitleOutput)
        {
            Regex reg = new Regex("[0-9a-fA-F]{8}_ltc.xml");
            Match match = reg.Match(liveTitleOutput);
            string ltcPath = "";

            if (match.Success)
            {
                // The LTC file is created in the current directory

                ltcPath = Path.Combine(_liveTitleProcess.WorkingDirectory, match.Value);
                if (!File.Exists(ltcPath))
                {
                    throw new LiveTitleException("Unable to find the LTC file at " + ltcPath);
                }
            }
            else
            {
                throw new LiveTitleException("Unable to find the LTC file name in the LiveTitle output.",
                    liveTitleOutput);
            }

            return ltcPath;
        }
    }

    public class LiveTitleException : ProcessException
    {
        public LiveTitleException() : base("LiveTitle") {}
        public LiveTitleException(string message) : base("LiveTitle", message) {}
        public LiveTitleException(string message, Exception innerException) : base("LiveTitle", message, innerException) {}
        public LiveTitleException(string message, string liveTitleOutput) : base("LiveTitle", message, liveTitleOutput) {}
        public LiveTitleException(string message, string liveTitleOutput, Exception innerException) :
            base("LiveTitle", liveTitleOutput, message, innerException) {}

        public override string Message
        {
            get { return string.Format("{0}\r\nLiveTitle Output:\r\n{1}\r\nEnd LiveTitle Output\r\n",
                      base.Message, base.ProcessOutput); }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\spac.cs ===
using System;
using System.IO;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
    public enum SPACReturnCode
    {
        Success = 0,
        BadUsage,
        NonFatalError,
        FatalError
    };

	/// <summary>
	/// Utility class that runs the SPA Compiler (SPAC) tool.
	/// </summary>
	/// <remarks>
	/// Unlike many of the other tools, SPAC supports multiple return codes. Therefore, all the
	/// methods that execute SPAC will not raise exceptions on failure, but rather simply return
	/// the exit code from the tool itself. It is the caller's responsibility to check this code
	/// and take the appropriate action.
	/// </remarks>
	public class SPAC
	{
        const string DefaultSpacPath = @"D:\webroot\xbltools";

        private ProcessWrapper _spacProcess;
        private string _xlastPath;
        private string _headerFile;
        private string _spaFile;
        private string _configOverrideFile;
        private bool _noLogo;
        private bool _verbose;
        private bool _noSpa;
        private bool _noHeader;
        private string _unCompileOutFile;

        /// <summary>
        /// Creates a SPAC object and initializes the process wrapper to the default SPAC path.
        /// </summary>
		public SPAC()
		{
            _spacProcess = new ProcessWrapper("SPAC", Path.Combine(DefaultSpacPath, "spac.exe"));

            // Set the values for the default command line
            _noLogo = true;
            _verbose = true;
            _noSpa = false;
            _noHeader = false;
		}

        /// <summary>
        /// Gets or sets the full path of the SPAC executable.
        /// </summary>
        public string SpacPath
        {
            get { return _spacProcess.ExecutablePath; }
            set
            {
                _spacProcess.ExecutablePath = Path.GetFullPath(value);
                _spacProcess.WorkingDirectory = Path.GetDirectoryName(value);
            }
        }

        /// <summary>
        /// Gets or sets the name of the working directory under which SPAC will be run.
        /// </summary>
        public string WorkingDirectory
        {
            get { return _spacProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _spacProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _spacProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the name of the XLAST file to compile.
        /// </summary>
        public string XlastPath
        {
            get { return _xlastPath; }
            set
            {
                if (value != null)
                {
                    _xlastPath = Path.GetFullPath(value);
                }
                else
                {
                    _xlastPath = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of the header file that SPAC outputs when compiling an XLAST file.
        /// </summary>
        public string HeaderFile
        {
            get { return _headerFile; }
            set
            {
                if (value != null)
                {
                    _headerFile = Path.GetFullPath(value);
                }
                else
                {
                    _headerFile = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of the SPA file that SPAC outputs when compiling an XLAST file.
        /// </summary>
        public string SpaFile
        {
            get { return _spaFile; }
            set
            {
                if (value != null)
                {
                    _spaFile = Path.GetFullPath(value);
                }
                else
                {
                    _spaFile = null;  
                }
            }
        }

        /// <summary>
        /// Gets or sets the optional name of a file containing configuration overrides.
        /// </summary>
        public string ConfigOverrideFile
        {
            get { return _configOverrideFile; }
            set
            {
                if (value != null)
                {
                    _configOverrideFile = Path.GetFullPath(value);
                }
                else
                {
                    _configOverrideFile = null;
                }
            }
        }

		
        /// <summary>
        /// Gets or sets the name of the decompiled output file 
        /// </summary>
        public string UncompileOutputFile
        {
            get { return _unCompileOutFile; }
            set
            {
                if (value != null)
                {
                    _unCompileOutFile = Path.GetFullPath(value);
                }
                else
                {
                    _unCompileOutFile = null;
                }
            }
        }


        /// <summary>
        /// Gets the output text of SPAC.
        /// </summary>
        public string Output
        {
            get { return _spacProcess.Output; }
        }

        /// <summary>
        /// Gets or sets the default value for the -nologo option.
        /// </summary>
        public bool NoLogo
        {
            get { return _noLogo; }
            set { _noLogo = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -verbose option.
        /// </summary>
        public bool Verbose
        {
            get { return _verbose; }
            set { _verbose = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -nospa option.
        /// </summary>
        public bool NoSpa
        {
            get { return _noSpa; }
            set { _noSpa = value; }
        }

        /// <summary>
        /// Gets or sets the default value of the -noh option.
        /// </summary>
        public bool NoHeader
        {
            get { return _noHeader; }
            set { _noHeader = value; }
        }

        /// <summary>
        /// Compiles an XLAST file using the default parameter values.
        /// </summary>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile()
        {
            return Compile(_noLogo, _verbose, _noSpa, _noHeader);
        }

        /// <summary>
        /// Allows the default nospa and noh parameter values to be overridden when compiling an XLAST file.
        /// </summary>
        /// <param name="noSpa">Flag indicating whether or not a SPA file should be generated.</param>
        /// <param name="noHeader">Flag indicating whether or not a SPA.H file should be generated.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile(bool noSpa, bool noHeader)
        {
            return Compile(_noLogo, _verbose, noSpa, noHeader);
        }

        /// <summary>
        /// Allows all the default flag parameter values to be overridden when compiling an XLAST file.
        /// </summary>
        /// <param name="noLogo">Flag indicating whether the copyright message is printed when SPAC is run.</param>
        /// <param name="verbose">Flag specifying whether the compile output should be normal or verbose.</param>
        /// <param name="noSpa">Flag indicating whether or not a SPA file should be generated.</param>
        /// <param name="noHeader">Flag indicating whether or not a SPA.H file should be generated.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode Compile(bool noLogo, bool verbose, bool noSpa, bool noHeader)
        {
            StringBuilder args = new StringBuilder();

            if (noLogo) args.Append("/nologo ");
            if (verbose) args.Append("/verbose ");
            if (noSpa) args.Append("/nospa ");
            if (noHeader) args.Append("/noh ");
            if (_spaFile != null && _spaFile.Length > 0) args.AppendFormat("/o {0} ", _spaFile);
            if (_headerFile != null && _headerFile.Length > 0) args.AppendFormat("/h {0} ", _headerFile);
            if (_configOverrideFile != null && _configOverrideFile.Length > 0) args.AppendFormat("/config {0} ", _configOverrideFile);

            args.Append(_xlastPath);

            return (SPACReturnCode)_spacProcess.Run(args.ToString());
        }

		
        /// <summary>
        /// UnCompiles a SPA file using the default parameter values.
        /// </summary>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode UnCompile()
        {
              StringBuilder args = new StringBuilder();

        	if (_spaFile != null && _spaFile.Length > 0) args.AppendFormat("/u {0} ", _spaFile);
		if (_unCompileOutFile != null && _unCompileOutFile.Length > 0) args.AppendFormat("/o {0}", _unCompileOutFile);
              return (SPACReturnCode)_spacProcess.Run(args.ToString());
        }


        /// <summary>
        /// Executes SPAC to output the XSD file it is using to validate XLAST files.
        /// </summary>
        /// <param name="xsdFile">Name of the XSD file to create.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// </returns>
        public SPACReturnCode OutputXSD(string xsdFile)
        {
            return (SPACReturnCode)_spacProcess.Run("/nologo /xsd " + xsdFile);
        }

        /// <summary>
        /// Reports the version information of a given SPA file.
        /// </summary>
        /// <param name="spaFile">Name of the SPA file for which version information is to be reported.</param>
        /// <returns>
        /// One of the four possible SPAC return codes:
        ///     0       Success
        ///     1       Bad Usage
        ///     2       Non-Fatal Error
        ///     3       Fatal Error
        /// 
        /// The version information will be found in the output text.
        /// </returns>
        public SPACReturnCode ReportSPAVersion(string spaFile)
        {
            return (SPACReturnCode)_spacProcess.Run("/nologo /u " + spaFile);
        }
	}
/*
    public class SPACException : ProcessException
    {
        public SPACException() : base("SPAC") {}
        public SPACException(string message) : base("SPAC", message) {}
        public SPACException(string message, Exception innerException) : base("SPAC", message, innerException) {}
        public SPACException(string message, string spacOutput) : base("SPAC", message, spacOutput) {}
        public SPACException(string message, string spacOutput, Exception innerException) :
            base("SPAC", spacOutput, message, innerException) {}

        public override string Message
        {
            get 
            {
                return string.Format("{0}\r\nSPAC Output:\r\n{1}\r\nEnd SPAC Output\r\n",
                      base.Message, base.ProcessOutput);
            }
        }

    }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ConfigFiles\XmlOfferFile.cs ===
using System;
using System.Xml;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    /// <summary>
    /// Wrapper for common operations on offer files.
    /// </summary>
    public class XmlOfferFile
    {
        private XmlDocument _offerXml;
        private XmlNamespaceManager _nsmgr;
        public enum platform{xbox1, xbox360};

		/// <summary>
		/// Create a representation of an xml offer file which can be accessed through
		/// XPATH calls.
		/// </summary>
		/// <param name="filename">File to open.</param>
		/// <param name="consoleType">Console type for this xml offer file.  Necessary because
		/// they use different namespaces.</param>
        public XmlOfferFile(string filename, platform consoleType)
        {
            _offerXml = new XmlDocument();
            _offerXml.Load(filename);
            _nsmgr = new XmlNamespaceManager(_offerXml.NameTable);
            if (consoleType == platform.xbox1) {
                _nsmgr.AddNamespace("xbo", "http://www.xboxlive.com/xboxoffer");
            } else if (consoleType == platform.xbox360) {
                _nsmgr.AddNamespace("xbo", "http://www.xboxlive.com/offer");                
            }
        }

		/// <summary>
		/// Returns the contentID of this offer.
		/// </summary>
        public string getContentId() 
        {
            XmlNode contentIdNode;
            XmlElement root = _offerXml.DocumentElement;
            contentIdNode=root.SelectSingleNode("xbo:content/xbo:contentID", _nsmgr);

            return contentIdNode.InnerXml.Substring(2);
        }

	        
		/// <summary>
		/// Returns a nodelist of nodes that match this xpath query.
		/// </summary>
		/// <param name="xpath">XPATH pointing to nodes to select.</param>
		/// <returns>XMLNodeList containing all nodes matched, or null if there are none.</returns>
		public XmlNodeList MultipleQuery(string xpath) {
            XmlNodeList ansList;
            XmlElement root = _offerXml.DocumentElement;
            ansList = root.SelectNodes(xpath, _nsmgr);
            if (ansList.Count == 0) {
                Global.RO.Warn("Warning:Multiple Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }

            return ansList;
		}

		/// <summary>
		/// Returns the first XmlNode that matches the given XPATH.
		/// </summary>
		/// <param name="xpath">XPATH pointing to the node to select.</param>
		/// <returns>XmlNode of selected node, or null if there is no match.</returns>
        public XmlNode ArbitraryXpath(string xpath) {
            XmlNode contentIdNode;
            XmlElement root = _offerXml.DocumentElement;
            contentIdNode=root.SelectSingleNode(xpath, _nsmgr);
            if (contentIdNode == null) {
                Global.RO.Warn("Warning:Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }
            return contentIdNode;
        }

        
		/// <summary>
		/// Takes a node already selected from this offer file, and selects from it again.  Required
		/// here because it needs the namespace manager.
		/// </summary>
		/// <param name="node">Node to select from.</param>
		/// <param name="xpath">XPATH to use relative to this node.</param>
		/// <returns>New XmlNode, relative from the given one.  Returns null if there is no match.</returns>
        public XmlNode RelativeXpath(XmlNode node, string xpath) {
            XmlNode ansNode = node.SelectSingleNode(xpath, _nsmgr);
            if (ansNode == null) {
                Global.RO.Warn("Warning:Relative Xpath query has retrieved zero nodes.  Xpath query is:");
                Global.RO.Warn(xpath);
            }
            return ansNode;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\WSTRunner.cs ===
using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;
using xonline.common.config;
using xonline.common.protocol;

namespace ServerTestFramework.STFTools
{
    /// <summary>
    /// Utility class for running the WSTRunner tool.
    /// </summary>
    public class WSTRunner
    {
        const string DefaultWSTRunnerPath = "D:\\webroot\\xbltools";

        private string _manifestPath = "";
        private string _deploymentPath = "";
        private ProcessWrapper _wstRunnerProcess;
        private Report _report;

        public WSTRunner()
        {
            _wstRunnerProcess = new ProcessWrapper("WSTRunner", Path.Combine(DefaultWSTRunnerPath, "WSTRunner.exe"));
            //_wstRunnerProcess.SetEnvironmentVariable("XBL_CONFIG_SERVER", Global.DefaultNpdbSetting.ip);
            _wstRunnerProcess.Verbose = true;
            _report = new Report("WSTRunner");
        }

        public WSTRunner(string wstRunnerPath)
            : this()
        {
            WSTRunnerPath = wstRunnerPath;
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the WSTRunner executable.
        /// </summary>
        public string WSTRunnerPath
        {
            get { return _wstRunnerProcess.ExecutablePath; }
            set
            {
                _wstRunnerProcess.ExecutablePath = Path.GetFullPath(value);
                _wstRunnerProcess.WorkingDirectory = Path.GetDirectoryName(_wstRunnerProcess.ExecutablePath);
            }
        }

        /// <summary>
        /// Gets or sets the working directory for WSTRunner
        /// </summary>
        public string WorkingDirectory
        {
            get { return _wstRunnerProcess.WorkingDirectory; }
            set
            {
                if (value != null)
                {
                    _wstRunnerProcess.WorkingDirectory = Path.GetFullPath(value);
                }
                else
                {
                    _wstRunnerProcess.WorkingDirectory = null;
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Manifest file used during database 
        /// deployment.
        /// </summary>
        public string ManifestFilePath
        {
            get { return _manifestPath; }
            set
            {
                if (value != null)
                {
                    _manifestPath = Path.GetFullPath(value);
                }
                else
                {
                    _manifestPath = "";
                }
            }
        }

        /// <summary>
        /// Gets or sets the fully-qualified name of the Deployment file used during database 
        /// deployment.
        /// </summary>
        public string DeploymentFilePath
        {
            get { return _deploymentPath; }
            set
            {
                if (value != null)
                {
                    _deploymentPath = Path.GetFullPath(value);
                }
                else
                {
                    _deploymentPath = "";
                }
            }
        }

        /// <summary>
        /// Gets the output text from the most recent run of WSTRunner.
        /// </summary>
        public string Output
        {
            get { return _wstRunnerProcess.Output; }
        }

        /// <summary>
        /// Exposes the Execution Timeout value for the underlying Process wrapper.
        /// </summary>
        public int ExecutionTimeout
        {
            get { return _wstRunnerProcess.ExecutionTimeout; }
            set { _wstRunnerProcess.ExecutionTimeout = value; }
        }

        /// <summary>
        /// Runs WSTRunner to setup a database using the provided manifest and deployment files.
        /// </summary>
        /// <param name="manifestFile">Manifest File to be used with the /m parameter. Required.</param>
        /// <param name="deploymentFile">Deployment File to be used with the /d parameter. Required.</param>
        public void WSTRunnerSetup(string manifestFile, string deploymentFile)
        {
            this.ManifestFilePath = manifestFile;
            this.DeploymentFilePath = deploymentFile;

            WSTRunnerSetup();
        }

        /// <summary>
        /// Runs WSTRunner to setup a database using the provided manifest and deployment files.
        /// </summary>
        public void WSTRunnerSetup()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/setup");
            if (_manifestPath.Length > 0)
            {
                arguments.AppendFormat(" /m {0}", _manifestPath);
            }
            if (_deploymentPath.Length > 0)
            {
                arguments.AppendFormat(" /d {0}", _deploymentPath);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to setup the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to drop a database using the provided manifest and deployment files.
        /// </summary>
        /// <param name="manifestFile">Manifest File to be used with the /m parameter. Required.</param>
        /// <param name="deploymentFile">Deployment File to be used with the /d parameter. Required.</param>
        public void WSTRunnerDrop(string manifestFile, string deploymentFile)
        {
            this.ManifestFilePath = manifestFile;
            this.DeploymentFilePath = deploymentFile;

            WSTRunnerSetup();
        }

        /// <summary>
        /// Runs WSTRunner to drop a database using the provided manifest and deployment files.
        /// </summary>
        public void WSTRunnerDrop()
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            arguments.AppendFormat("/drop");
            if (_manifestPath.Length > 0)
            {
                arguments.AppendFormat(" /m {0}", _manifestPath);
            }
            if (_deploymentPath.Length > 0)
            {
                arguments.AppendFormat(" /d {0}", _deploymentPath);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(bool setupParam, bool dropParam, bool mParam, string manifestFile, bool dParam, string deploymentFile)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            if (setupParam == true)
            {
                arguments.AppendFormat(" /setup");
            }
            if (dropParam == true)
            {
                arguments.AppendFormat(" /drop");
            }
            if (mParam == true)
            {
                arguments.AppendFormat(" /m");
            }
            if (manifestFile != null)
            {
                arguments.AppendFormat(" {0}", manifestFile);
            }
            if (dParam == true)
            {
                arguments.AppendFormat(" /d");
            }
            if (deploymentFile != null)
            {
                arguments.AppendFormat(" {0}", deploymentFile);
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(params string[] args)
        {
            int exitCode;
            StringBuilder arguments = new StringBuilder();

            if (args != null)
            {
                for (int i = 0; i < args.Length; i++)
                {
                    arguments.AppendFormat(" {0}", args[i]);
                }
            }

            exitCode = _wstRunnerProcess.Run(arguments.ToString());
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }

        /// <summary>
        /// Runs WSTRunner to manually allow invalid parameter variations.
        /// </summary>
        public void WSTRunnerManualParam(string commandLine)
        {
            int exitCode;

            exitCode = _wstRunnerProcess.Run(commandLine);
            if (exitCode != 0)
            {
                throw new WSTRunnerException("WSTRunner failed to drop the database.", _wstRunnerProcess.Output);
            }
        }
    }

    public class WSTRunnerException : ProcessException
    {
        public WSTRunnerException() : base("WSTRunner") { }
        public WSTRunnerException(string message) : base("WSTRunner", message) { }
        public WSTRunnerException(string message, Exception innerException) : base("WSTRunner", message, innerException) { }
        public WSTRunnerException(string message, string wstRunnerOutput) : base("WSTRunner", message, wstRunnerOutput) { }
        public WSTRunnerException(string message, string wstRunnerOutput, Exception innerException)
            :
            base("WSTRunner", wstRunnerOutput, message, innerException) { }

        public override string Message
        {
            get
            {
                return string.Format("{0}\r\nWSTRunner Output:\r\n{1}\r\nEnd WSTRunner Output\r\n",
                    base.Message, base.ProcessOutput);
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ClientTools\VoucherMgr.cs ===
using System;
using System.IO;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.STFTools
{
	/// <summary>
	/// Utility class for running the VoucherMgr tool.
	/// </summary>
	public class VoucherMgr
	{
            private ProcessWrapper _voucherMgrProcess;
            private const string _defaultVoucherMgrPath = "D:\\webroot\\xbltools";
            static public string InvalidEMSOfferId;

            public bool IsEmsOfferId(string offerId)
            {

                try
                {
                    if (offerId == InvalidEMSOfferId) return true;
                    Guid guidId = new Guid(offerId);
                    return true;
                }
                catch
                {
                    return false;
                }
            }

            public VoucherMgr() {
                _voucherMgrProcess = new ProcessWrapper("VoucherMgr", Path.Combine(_defaultVoucherMgrPath, "VoucherMgr.exe"));
            }

            public VoucherMgr(string voucherMgrPath) : this()
            {
                _voucherMgrProcess.ExecutablePath = Path.GetFullPath(voucherMgrPath);
            }

            public string Output
            {
                get { return _voucherMgrProcess.Output; }
            }

            

            public void Import(string key_or_file, bool isFile, string emsofferid, int mediatype, string espofferid, int useCount,
                   int useSCG, uint consoleVer)
            {
                Import(key_or_file, isFile, emsofferid, mediatype, espofferid, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void Import(string key_or_file, bool isFile, string emsofferid, int mediatype, string espofferid, int useCount,
                   int useSCG, uint consoleVer, int minseq,
                   int maxseq, int retries)
            {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += "/emsofferid:" + emsofferid + " ";
                arguments += "/mediatype:" + mediatype + " ";
                arguments += "/espofferid:" + espofferid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1)
                {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Import(string key_or_file, bool isFile, string offerid, int mediatype, int useCount,
                               int useSCG, uint consoleVer)
            {
                Import(key_or_file, isFile, offerid, mediatype, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void ImportOld(string key_or_file, bool isFile, string offerid, int useCount,
                   int useSCG, uint consoleVer)
            {
                ImportOld(key_or_file, isFile, offerid, useCount, useSCG, consoleVer, -1, -1, -1);
            }

            public void Import(string key_or_file, bool isFile, string offerid, int mediatype, int useCount, 
                               int useSCG, uint consoleVer, int minseq,
                               int maxseq, int retries) {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);

                if (IsEmsOfferId(offerid))
                {
                    arguments += "/emsofferid:" + offerid + " ";
                    arguments += "/mediatype:" + mediatype + " ";
                }
                else
                    arguments += "/espofferid:" + offerid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1) {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void ImportOld(string key_or_file, bool isFile, string offerid, int useCount,
                   int useSCG, uint consoleVer, int minseq,
                   int maxseq, int retries)
            {
                string arguments = "/import ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);


                arguments += "/offerid:" + offerid + " ";

                arguments += "/usecount:" + useCount + " ";
                arguments += "/SCG:" + useSCG + " ";
                arguments += "/consoleVer:" + consoleVer + " ";
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1)
                {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }            
            public void Disable(string key_or_file, bool isFile) {
                Disable(key_or_file, isFile, -1, -1);
            }

            public void Disable(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/disable ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Enable(string key_or_file, bool isFile) {
                Enable(key_or_file, isFile, -1, -1);
            }

            public void Enable(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/enable ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

            public void Delete(string key_or_file, bool isFile, string offerid) {
                Delete(key_or_file, isFile, offerid, -1, -1, -1);
            }


            public void Delete(string key_or_file, bool isFile, string offerid,  
                               int minseq, int maxseq, int retries) {
                string arguments = "/delete ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                if (offerid != "") {
                    if (IsEmsOfferId(offerid)) {
                        arguments += "/emsofferid:" + offerid + " ";
                    }
                    else
                        arguments += "/espofferid:" + offerid + " ";
                }
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (retries != -1) {
                    arguments += "/retries:" + retries + " ";
                }
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
            }

        public void Delete(string key_or_file, bool isFile, string emsofferid, string espofferid,
               int minseq, int maxseq, int retries)
        {
            string arguments = "/delete ";
            arguments += CreateKeyOrFileArg(key_or_file, isFile);


            if (emsofferid != "")
                arguments += "/emsofferid:" + emsofferid + " ";
            
            if(espofferid !="")
                    arguments += "/espofferid:" + espofferid + " ";

           
            arguments += CreateMinMaxArg(minseq, maxseq);
            if (retries != -1)
            {
                arguments += "/retries:" + retries + " ";
            }
            if (_voucherMgrProcess.Run(arguments) != 0)
            {
                throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
            }
        }


            public string View(string key_or_file, bool isFile, int minseq, int maxseq) {
                string arguments = "/view ";
                arguments += CreateKeyOrFileArg(key_or_file, isFile);
                arguments += CreateMinMaxArg(minseq, maxseq);
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            public string Summary() {
                string arguments = "/summary";
                if (_voucherMgrProcess.Run(arguments) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            public string EmsSummary()
            {
                string arguments = "/emssummary";
                if (_voucherMgrProcess.Run(arguments) != 0)
                {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }

            private string CreateKeyOrFileArg(string key_or_file, bool isFile) {
                if (isFile) {
                    return "/file:" + key_or_file + " ";
                } else {
                    return "/key:" + key_or_file + " ";
                }
            }

            private string CreateMinMaxArg(int minseq, int maxseq) {
                string returnedArgs = "";
                if (minseq != -1) {
                    returnedArgs += "/minseq:" + minseq + " ";
                }
                if (maxseq != -1) {
                    returnedArgs += "/maxseq:" + maxseq + " ";
                }
                return returnedArgs;
            }

            public string ArbitraryCommand(string args) {
                if (_voucherMgrProcess.Run(args) != 0) {
                    throw new VoucherMgrException("VoucherMgr exited with error.", _voucherMgrProcess.Output);
                }
                return _voucherMgrProcess.Output;
            }


        }



	public class VoucherMgrException : ProcessException
	{
		public VoucherMgrException() : base("VoucherMgr") {}
		public VoucherMgrException(string message) : base("VoucherMgr", message) {}
		public VoucherMgrException(string message, Exception innerException) : base("VoucherMgr", message, innerException) {}
		public VoucherMgrException(string message, string output) : base("VoucherMgr", message, output) {}
		public VoucherMgrException(string message, string output, Exception innerException) :
			base("VoucherMgr", message, output, innerException) {}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ConfigFiles\LiveTitleConfig.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    public enum Generation
    {
        Unknown = 0,
        Xbox,
        Xenon
    }

    public struct LtcDeclarations
    {
        public const string SchemaVersion = "http://www.xboxlive.com/livetitleconfig";
    }

    [XmlType(Namespace=LtcDeclarations.SchemaVersion)]
    [XmlRoot(Namespace=LtcDeclarations.SchemaVersion, IsNullable=false)]
    public class LiveTitleConfig
    {
        public Generation   TitleGeneration;
        public uint         TitleID;
        public bool         AllowCrossPlatformPlay;

        //stats related
        public int          StatsMaxReads;
        public int          StatsMaxWrites;
        public int          StatsMaxLeaderboards;
        public bool         BountyExempt;
        public float        MuSigmaBeta;
        public float        MuSigmaTau;


        //Achievement related
        public int          MinAchievements;
        public int          MaxAchievements;
        public int          MinAchievementsWithCred;
        public int          MaxAchievementsWithCred;
        public int          MinCred;
        public int          MaxCred;
        public int          MaxUniqueAchImages;
        public int          MaxContexts;
        public int          MaxContextValues;

        public int          MaxGamerPictures;
        public int          MaxProperties;
        public int          MaxRichPresenceModes;
        public int          MaxGameModes;
        public bool         TitlePictureRequired;
        public bool         TitleMarketplacePictureRequired;

        //Alternate titleids
        public int          TitleRegion;
        public int          DiscMediaID;
        public int          LiveTitleID;
        public int          AlternateTitleID1;
        public int          AlternateTitleID2;
        public int          AlternateTitleID3;
        public int          AlternateTitleID4;
        public int          Service1;
        public int          Service1AltID;
        public int          Service2;
        public int          Service2AltID;
        public int          Service3;
        public int          Service3AltID;
        public int          Service4;
        public int          Service4AltID;

        public const uint   SkillLBIDBase = 0xfffe0000;
        public const uint   RankedLBIDBase = 0xffff0000;

        // match related
        [XmlElement("MatchServerList", typeof(string))]
        public string       MatchServerList;

        [XmlElement("MatchExpiration", typeof(Int32))]
        public int          MatchExpiration;

        [XmlElement("MatchDeleteDelaySeconds", typeof(Int32))]
        public int MatchDeleteDelaySeconds;

        [XmlElement("MatchSessionLimitJobExists", typeof(Boolean))]
        public bool MatchSessionLimitJobExists;

        [XmlElement("MatchSessionLimitEnabled", typeof(Boolean))]
        public bool MatchSessionLimitEnabled;

        [XmlElement("MatchSessionMaxAvail", typeof(Int32))]
        public int MatchSessionMaxAvail;

        [XmlElement("MatchSessionTruncateLevelAvail", typeof(Int32))]
        public int MatchSessionTruncateLevelAvail;

        [XmlElement("MatchSessionWarnLevelAvail", typeof(Int32))]
        public int MatchSessionWarnLevelAvail;

        [XmlElement("MatchSessionMaxUnavail", typeof(Int32))]
        public int MatchSessionMaxUnavail;

        [XmlElement("MatchSessionTruncateLevelUnavail", typeof(Int32))]
        public int MatchSessionTruncateLevelUnavail;

        [XmlElement("MatchSessionWarnLevelUnavail", typeof(Int32))]
        public int MatchSessionWarnLevelUnavail;

        [XmlElement("MatchSessionCleanupPeriodMinutes", typeof(Int32))]
        public int MatchSessionCleanupPeriodMinutes;

        [XmlElement("MatchSessionCleanupOffsetMinutes", typeof(Int32))]
        public int MatchSessionCleanupOffsetMinutes;

        // Miscellaneous section...
        [XmlElement("clusterid", typeof(string))]
        public string       ClusterId;

        [XmlElement("locale", typeof(string))]
        public string       Locale;

        [XmlElement(ElementName="LeaderboardConfigs", Type=typeof(LeaderboardConfigs), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=LtcDeclarations.SchemaVersion)]
        public LeaderboardConfigs LeaderboardConfigs;

        /// <summary>
        /// Creates a LiveTitleConfig object from an LTC file
        /// </summary>
        /// <param name="ltcFile">Path and name of the LTC file to de-serialize.</param>
        /// <returns>A LiveTitleConfig object that represents the file.</returns>
        public static LiveTitleConfig FromXml(string ltcFile)
        {
            if (ltcFile == null)
            {
                throw new ArgumentNullException("ltcFile");
            }

            if (!File.Exists(ltcFile))
            {
                return null;
            }

            LiveTitleConfig ltc = null;
            StreamReader reader = null;
            try
            {
                reader = new StreamReader(ltcFile);
                ltc = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return ltc;
        }

        /// <summary>
        /// Deserializes LTC XML into a LiveTitleConfig object.
        /// </summary>
        /// <param name="xml">A TextReader object that holds the LTC XML.</param>
        /// <returns>A LiveTitleConfig object that represents the LTC data</returns>
        public static LiveTitleConfig FromXml(TextReader xml)
        {
            if (xml == null)
            {
                return null;
            }

            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            LiveTitleConfig ltc = null;
            try
            {
                xmlReader = new XmlTextReader(xml);
                serializer = new XmlSerializer(typeof(LiveTitleConfig));
                ltc = (serializer.Deserialize(xmlReader) as LiveTitleConfig);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return ltc;
        }

        /// <summary>
        /// Serailizes the LiveTitleConfig object to an LTC file
        /// </summary>
        /// <param name="ltcFile">Path and name of the target LTC file</param>
        public void ToXml(string ltcFile)
        {
            if (ltcFile == null)
            {
                throw new ArgumentNullException("ltcFile");
            }

            /*
             * We need to go through the pain of creating an XmlDocument from
             * the serialized XML stream so that when we can duplicate the
             * format of the LTC file when it's saved from LiveTitle.
             */
            StringWriter sw = new StringWriter();
            XmlDocument doc = new XmlDocument();
            XmlTextWriter xtw = new XmlTextWriter(ltcFile, System.Text.Encoding.Unicode);
            xtw.Formatting = Formatting.Indented;
            xtw.Indentation = 2;
            xtw.IndentChar = ' ';
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(LiveTitleConfig));
                serializer.Serialize(sw, this);
                doc.LoadXml(sw.ToString());
                doc.Save(xtw);
            }
            finally
            {
                xtw.Close();
                sw.Close();
            }
        }
    }

    [XmlType(TypeName="LeaderboardConfigs",Namespace=LtcDeclarations.SchemaVersion),Serializable]
    public class LeaderboardConfigs
    {
        [XmlElement(ElementName="LeaderboardConfig",Type=typeof(LeaderboardConfig),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=LtcDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public LeaderboardConfigCollection _leaderboardConfigCollection;

        [XmlIgnore]
        public LeaderboardConfigCollection LeaderboardConfigCollection
        {
            get
            {
                if (_leaderboardConfigCollection == null) _leaderboardConfigCollection = new LeaderboardConfigCollection();
                return _leaderboardConfigCollection;
            }
            set { _leaderboardConfigCollection = value; }
        }

        public LeaderboardConfigs()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class LeaderboardConfigCollection : ArrayList
    {
        public LeaderboardConfig Add(LeaderboardConfig obj)
        {
            base.Add(obj);
            return obj;
        }

        public LeaderboardConfig Add()
        {
            return Add(new LeaderboardConfig());
        }

        public void Insert(int index, LeaderboardConfig obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(LeaderboardConfig obj)
        {
            base.Remove(obj);
        }

        new public LeaderboardConfig this[int index]
        {
            get { return base[index] as LeaderboardConfig; }
            set { base[index] = value; }
        }

        public LeaderboardConfigCollection()
        {
        }
    }

    public class LeaderboardConfig
    {
        [XmlAttribute()]
        public int LeaderboardID;

        [XmlAttribute()]
        public string HostingLbs;

        [XmlAttribute()]
        public bool IsCompetition = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\Achievements.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public void AddAchievements(XboxLiveSubmissionProject xlast, uint count, uint totalCred)
        {
            ushort credPerAchievment = (ushort)(count > 1 ? totalCred / count : totalCred);

            for (uint i = 1; i <= count; i++)
            {
                bool showUnachieved = (_rnd.Next() % 2) != 0;
                int type = _rnd.Next((int)achievementType.Completion, (int)achievementType.Other + 1);
                int imageId = _rnd.Next(1, 11);

                // Make sure we use up all the cred
                if (i == count)
                {
                    credPerAchievment += (ushort)(totalCred - (credPerAchievment * count));
                }

                AddAchievement(xlast, (achievementType)type, credPerAchievment, string.Format("AchievementImage{0:d02}.png", imageId), showUnachieved);
            }
        }

        public void AddAchievement(XboxLiveSubmissionProject xlast)
        {
            bool showUnachieved = (_rnd.Next() % 2) != 0;
            int type = _rnd.Next((int)achievementType.Completion, (int)achievementType.Other + 1);
            int imageId = _rnd.Next(1, 11);

            AddAchievement(xlast, (achievementType)type, 0, String.Format("AchievementImage{0:d02}.png", imageId), showUnachieved);
        }

        public void AddAchievement(XboxLiveSubmissionProject xlast, achievementType type, ushort cred, string imagePath, bool showUnachieved)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Achievement ach = new Achievement();
            ach.clsid = AchievementCLSID;
            ach.id = xlast.GameConfigProject.Achievements.nextId;
            ach.achievementType = type;
            ach.cred = cred;
            ach.friendlyName = "Achievement" + ach.id.ToString("d3");
            ach.imageId = AddImage(xlast, imagePath);
            ach.titleStringId = AddString(xlast, ach.friendlyName + " Title String");
            ach.descriptionStringId = AddString(xlast, ach.friendlyName + " Description String");
            ach.showUnachieved = showUnachieved;
            if (showUnachieved)
            {
                ach.unachievedStringId = AddString(xlast, ach.friendlyName + " Unachieved String");
            }
            xlast.GameConfigProject.Achievements.Add(ach);
            xlast.GameConfigProject.Achievements.nextId++;
        }

        private void CreateAchievements(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Achievements.clsid = AchievementsCLSID;
            xlast.GameConfigProject.Achievements.nextId = 1;

            // If this is an Arcade title, we must provide exactly 12 Achievements with 200 cred
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                AddAchievements(xlast, 12, 200);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\Contexts.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const string GAME_TYPE_CONTEXT_ID = "0x0000800A";

        public void AddContexts(XboxLiveSubmissionProject xlast, int count, int maxValues)
        {
            for (int i = 1; i <= count; i++)
            {
                string id = AddContext(xlast);
                int values = _rnd.Next(1, maxValues + 1);

                for (int j = 1; j <= values; j++)
                {
                    AddContextValue(xlast, id, string.Format("Context{0:d3}Value{1:d3}",i, j));
                }
                if (values > 1)
                {
                    SetContextDefaultValue(xlast, id, (ushort)_rnd.Next(0, values));
                }
                else
                {
                    SetContextDefaultValue(xlast, id, 0);
                }
            }
        }

        public string AddContext(XboxLiveSubmissionProject xlast)
        {
            Context ctx = new Context();
            uint id = UInt32.Parse(xlast.GameConfigProject.Contexts.nextId.Substring(2), System.Globalization.NumberStyles.HexNumber);

            ctx.clsid = ContextCLSID;
            ctx.id = "0x" + id.ToString("X8");
            ctx.friendlyName = "Context" + id.ToString();
            ctx.stringId = AddString(xlast, ctx.friendlyName + " string.");
            ctx.defaultValue = 0;
            xlast.GameConfigProject.Contexts.Add(ctx);
            xlast.GameConfigProject.Contexts.nextId = "0x" + (id + 1).ToString("X8");
            return ctx.id;
        }

        public void AddContextValue(XboxLiveSubmissionProject xlast, string id, string name)
        {
            Context ctx = GetContext(xlast, id);
            if (ctx != null)
            {
                ContextValue ctxValue = new ContextValue();
                ctxValue.friendlyName = name;
                ctxValue.stringId = AddString(xlast, name + " String.");
                ctxValue.value = (ushort)ctx.Count;
                ctx.Add(ctxValue);
            }
        }

        public void SetContextDefaultValue(XboxLiveSubmissionProject xlast, string id, ushort defaultValue)
        {
            Context ctx = GetContext(xlast, id);
            if (ctx != null)
            {
                ctx.defaultValue = defaultValue;
            }
        }

        private Context GetContext(XboxLiveSubmissionProject xlast, string id)
        {
            foreach (Context ctx in xlast.GameConfigProject.Contexts)
            {
                if (string.Compare(ctx.id, id, true) == 0)
                    return ctx;
            }
            return null;
        }

        private void CreateContexts(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Contexts.clsid = ContextsCLSID;
            xlast.GameConfigProject.Contexts.nextId = "0x00000000";

            Context newCtx = new Context();
            newCtx.clsid = ContextCLSID;
            newCtx.id = GAME_TYPE_CONTEXT_ID;
            newCtx.defaultValue = 0;
            newCtx.friendlyName = "GAME_TYPE";
            newCtx.stringId = (ushort)XLASTDefaultString.X_STRINGID_GAMETYPE;

            ContextValue ctxValue = new ContextValue();
            ctxValue.friendlyName = "RANKED";
            ctxValue.stringId = (ushort)XLASTDefaultString.X_STRINGID_RANKED;
            ctxValue.value = 0;
            newCtx.Add(ctxValue);

            ctxValue = new ContextValue();
            ctxValue.friendlyName = "STANDARD";
            ctxValue.stringId = (ushort)XLASTDefaultString.X_STRINGID_STANDARD;
            ctxValue.value = 1;
            newCtx.Add(ctxValue);

            xlast.GameConfigProject.Contexts.Add(newCtx);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\GameModes.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const string GAME_MODE_ID = "0x0000800B";

        public void AddGameModes(XboxLiveSubmissionProject xlast, int count)
        {
            for (int i = 0; i < count; i++)
            {
                AddGameMode(xlast);
            }
        }

        public void AddGameMode(XboxLiveSubmissionProject xlast, string name, ushort value, byte drawProbability)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            GameMode gameMode = new GameMode();
            gameMode.friendlyName = name;
            gameMode.stringId = AddString(xlast, name + " string");
            gameMode.value = value;
            gameMode.drawProbability = drawProbability;
            xlast.GameConfigProject.GameModes.Add(gameMode);
        }

        public void SetGameModeDefaultValue(XboxLiveSubmissionProject xlast, ushort defaultValue)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GameModes.defaultValue = defaultValue;
        }

        private ushort AddGameMode(XboxLiveSubmissionProject xlast)
        {
            ushort value = (ushort)xlast.GameConfigProject.GameModes.Count;
            byte draw = (byte)_rnd.Next(0, 101);
            AddGameMode(xlast, "GameMode" + value.ToString("d3"), value, draw);
            return value;
        }

        private void CreateGameModes(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GameModes.clsid = GameModesCLSID;
            SetGameModeDefaultValue(xlast, AddGameMode(xlast));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\GamerPictures.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        private const uint GAMERPIC_SMALL = 0x00010000;
        private const uint GAMERPIC_LARGE = 0x00020000;

        public void AddGamerPicture(XboxLiveSubmissionProject xlast, string smallImage, string largeImage)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            // Make sure the CLSID is set
            if (null == xlast.GameConfigProject.GamerPictures.clsid)
            {
                CreateGamerPictures(xlast);
            }

            Picture gamerPic = new Picture();
            Picture largePic = new Picture();
            uint imageId;

            // Gamer pictures start at ID 2 (for some reason)
            gamerPic.id = (uint)xlast.GameConfigProject.GamerPictures.Count + 2;
            gamerPic.friendlyName = "GamerPic" + (xlast.GameConfigProject.GamerPictures.Count + 2).ToString("d3");

            // Each Gamer Picture consists of two images - small and large
            imageId = GAMERPIC_SMALL | gamerPic.id;
            AddImage(xlast, smallImage, imageId, gamerPic.friendlyName + "_SMALL");

            imageId = GAMERPIC_LARGE | gamerPic.id;
            AddImage(xlast, largeImage, imageId, gamerPic.friendlyName + "_LARGE");

            // Finally add the GamerPic element
            xlast.GameConfigProject.GamerPictures.Add(gamerPic);
        }

        private void CreateGamerPictures(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.GamerPictures.clsid = GamerPicturesCLSID;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\Images.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public uint AddImage(XboxLiveSubmissionProject xlast, string imagePath)
        {
            uint id = GetNextImageId(xlast);
            AddImage(xlast, imagePath, id, "Image" + id.ToString("d3"));
            return id;
        }

        public uint AddImage(XboxLiveSubmissionProject xlast, string imagePath, string name)
        {
            uint id = GetNextImageId(xlast);
            AddImage(xlast, imagePath, id, name);
            return id;
        }

        private void AddImage(XboxLiveSubmissionProject xlast, string imagePath, uint id, string friendlyName)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Image newImage = new Image();
            newImage.Path = imagePath;
            newImage.id = id;
            newImage.friendlyName = friendlyName;
            xlast.GameConfigProject.Images.Add(newImage);
        }

        private void CreateImages(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Images.clsid = ImagesCLSID;
            AddImage(xlast, "GameImage.png", 32768, "X_IMAGEID_GAME");
            AddImage(xlast, "GameMarketplaceImage.png", 32772, "X_IMAGEID_GAME_MARKETPLACE");
        }

        private uint GetNextImageId(XboxLiveSubmissionProject xlast)
        {
            uint id = 0;
            foreach (Image img in xlast.GameConfigProject.Images.ImageCollection)
            {
                if (img.id < 32768)
                    id = Math.Max(id, img.id);
            }

            return id + 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ConfigFiles\XboxConfig.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: xboxConfig.xsd
// Creation Date: 2/24/2006 11:01:59
//--------------------------------------------------------------

using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct XboxDeclarations
	{
		public const string SchemaVersion = "";
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxLocalizedStringCollection : ArrayList
	{
		public XboxLocalizedString Add(XboxLocalizedString obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxLocalizedString Add()
		{
			return Add(new XboxLocalizedString());
		}

		public void Insert(int index, XboxLocalizedString obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxLocalizedString obj)
		{
			base.Remove(obj);
		}

		new public XboxLocalizedString this[int index]
		{
			get { return (XboxLocalizedString) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxTranslationCollection : ArrayList
	{
		public XboxTranslation Add(XboxTranslation obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxTranslation Add()
		{
			return Add(new XboxTranslation());
		}

		public void Insert(int index, XboxTranslation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxTranslation obj)
		{
			base.Remove(obj);
		}

		new public XboxTranslation this[int index]
		{
			get { return (XboxTranslation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class XboxConfigurationCollection : ArrayList
	{
		public XboxConfiguration Add(XboxConfiguration obj)
		{
			base.Add(obj);
			return obj;
		}

		public XboxConfiguration Add()
		{
			return Add(new XboxConfiguration());
		}

		public void Insert(int index, XboxConfiguration obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(XboxConfiguration obj)
		{
			base.Remove(obj);
		}

		new public XboxConfiguration this[int index]
		{
			get { return (XboxConfiguration) base[index]; }
			set { base[index] = value; }
		}
	}


    /// <summary>
    /// Root class for deserializing an Xbox 1 configuration file (.XBOX).
    /// </summary>
	[XmlRoot(ElementName="XboxConfiguration",IsNullable=false),Serializable]
	public class XboxConfiguration
	{

		[XmlElement(Type=typeof(XboxGameConfig),ElementName="GameConfig",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxGameConfig _GameConfig;
		
		[XmlIgnore]
		public XboxGameConfig GameConfig
		{
			get
			{
				if (_GameConfig == null) _GameConfig = new XboxGameConfig();		
				return _GameConfig;
			}
			set {_GameConfig = value;}
		}

		[XmlElement(Type=typeof(XboxLocalizedStrings),ElementName="LocalizedStrings",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxLocalizedStrings _LocalizedStrings;
		
		[XmlIgnore]
		public XboxLocalizedStrings LocalizedStrings
		{
			get
			{
				if (_LocalizedStrings == null) _LocalizedStrings = new XboxLocalizedStrings();		
				return _LocalizedStrings;
			}
			set {_LocalizedStrings = value;}
		}

		[XmlElement(ElementName="Bounty",IsNullable=false,DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool _Bounty;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool _BountySpecified;
		
		[XmlIgnore]
		public bool Bounty
		{ 
			get { return _Bounty; }
			set { _Bounty = value; _BountySpecified = true; }
		}

		[XmlElement(Type=typeof(XboxWebdbInfo),ElementName="WebdbInfo",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxWebdbInfo _WebdbInfo;
		
		[XmlIgnore]
		public XboxWebdbInfo WebdbInfo
		{
			get
			{
				if (_WebdbInfo == null) _WebdbInfo = new XboxWebdbInfo();		
				return _WebdbInfo;
			}
			set {_WebdbInfo = value;}
		}

		[XmlElement(Type=typeof(XboxProductInformation),ElementName="ProductInformation",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxProductInformation _ProductInformation;
		
		[XmlIgnore]
		public XboxProductInformation ProductInformation
		{
			get
			{
				if (_ProductInformation == null) _ProductInformation = new XboxProductInformation();		
				return _ProductInformation;
			}
			set {_ProductInformation = value;}
		}

		public XboxConfiguration()
		{
		}

        /// <summary>
        /// Static method to deserialize an XBOX file into a hierarchy of objects.
        /// </summary>
        /// <param name="xboxFile">The name of the XBOX file to deserialize.</param>
        /// <returns>An XboxConfiguration object that describes the XBOX file.</returns>
        public static XboxConfiguration FromXml(string xboxFile)
        {
            if (xboxFile == null)
            {
                throw new ArgumentNullException("xboxFile");
            }
            
            if (!File.Exists(xboxFile))
            {
                return null;
            }

            StreamReader reader = null;
            XboxConfiguration xbox = null;
            try
            {
                reader = new StreamReader(xboxFile);
                xbox = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return xbox;
        }

        /// <summary>
        /// Static method to deserialize an XBOX XML stream into a hierarchy of objects.
        /// </summary>
        /// <param name="xboxFile">A TextReader object that contains the raw XML of an XBOX file.</param>
        /// <returns>An XboxConfiguration object that describes the XBOX file.</returns>
        public static XboxConfiguration FromXml(TextReader xboxXml)
        {
            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxConfiguration xbox = null;
            try
            {
                xmlReader = new XmlTextReader(xboxXml);
                serializer = new XmlSerializer(typeof(XboxConfiguration));
                xbox = (serializer.Deserialize(xmlReader) as XboxConfiguration);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return xbox;
        }

        /// <summary>
        /// Serializes the object hierarchy out to an XBOX file.
        /// </summary>
        /// <param name="xboxFile">The name of the XBOX file to create.</param>
        public void ToXml(string xboxFile)
        {
            if (xboxFile == null)
            {
                throw new ArgumentNullException("xboxFile");
            }

            StreamWriter stream = new StreamWriter(xboxFile);
            StringWriter sw = new StringWriter();
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxConfiguration));
                serializer.Serialize(sw, this);
                stream.WriteLine(sw);
            }
            finally
            {
                stream.Close();
                sw.Close();
            }
        }
	}


	[XmlType(TypeName="GameConfig"),Serializable]
	public class XboxGameConfig
	{

		[XmlAttribute(AttributeName="version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return _version; }
			set { _version = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _titleId;
		
		[XmlIgnore]
		public string TitleId
		{ 
			get { return _titleId; }
			set { _titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _titleName;
		
		[XmlIgnore]
		public string TitleName
		{ 
			get { return _titleName; }
			set { _titleName = value; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _name;
		
		[XmlIgnore]
		public string Name
		{ 
			get { return _name; }
			set { _name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _projectVersion;
		
		[XmlIgnore]
		public string ProjectVersion
		{ 
			get { return _projectVersion; }
			set { _projectVersion = value; }
		}

		public XboxGameConfig()
		{
		}
	}


	[XmlType(TypeName="LocalizedStrings"),Serializable]
	public class XboxLocalizedStrings
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return LocalizedStringCollection.GetEnumerator();
		}

		public XboxLocalizedString Add(XboxLocalizedString obj)
		{
			return LocalizedStringCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxLocalizedString this[int index]
		{
			get { return (XboxLocalizedString) LocalizedStringCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return LocalizedStringCollection.Count; }
        }

        public void Clear()
		{
            LocalizedStringCollection.Clear();
        }

		public XboxLocalizedString Remove(int index) 
		{ 
            XboxLocalizedString obj = LocalizedStringCollection[index];
            LocalizedStringCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            LocalizedStringCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(XboxLocalizedString),ElementName="LocalizedString",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxLocalizedStringCollection _LocalizedStringCollection;
		
		[XmlIgnore]
		public XboxLocalizedStringCollection LocalizedStringCollection
		{
			get
			{
				if (_LocalizedStringCollection == null) _LocalizedStringCollection = new XboxLocalizedStringCollection();
				return _LocalizedStringCollection;
			}
			set {_LocalizedStringCollection = value;}
		}

		public XboxLocalizedStrings()
		{
		}
	}


	[XmlType(TypeName="XboxLocalizedString"),Serializable]
	public class XboxLocalizedString
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return TranslationCollection.GetEnumerator();
		}

		public XboxTranslation Add(XboxTranslation obj)
		{
			return TranslationCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxTranslation this[int index]
		{
			get { return (XboxTranslation) TranslationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return TranslationCollection.Count; }
        }

        public void Clear()
		{
            TranslationCollection.Clear();
        }

		public XboxTranslation Remove(int index) 
		{ 
            XboxTranslation obj = TranslationCollection[index];
            TranslationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            TranslationCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _id;
		
		[XmlIgnore]
		public string Id
		{ 
			get { return _id; }
			set { _id = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _friendlyName;
		
		[XmlIgnore]
		public string FriendlyName
		{ 
			get { return _friendlyName; }
			set { _friendlyName = value; }
		}

		[XmlElement(Type=typeof(XboxTranslation),ElementName="Translation",IsNullable=true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxTranslationCollection _TranslationCollection;
		
		[XmlIgnore]
		public XboxTranslationCollection TranslationCollection
		{
			get
			{
				if (_TranslationCollection == null) _TranslationCollection = new XboxTranslationCollection();
				return _TranslationCollection;
			}
			set {_TranslationCollection = value;}
		}

		public XboxLocalizedString()
		{
		}
	}


	[XmlType(TypeName="XboxTranslation"),Serializable]
	public class XboxTranslation
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _locale;
		
		[XmlIgnore]
		public string Locale
		{ 
			get { return _locale; }
			set { _locale = value; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return _Value; }
			set { _Value = value; }
		}

		public XboxTranslation()
		{
		}
	}


	[XmlType(TypeName="XboxWebdbInfo"),Serializable]
	public class XboxWebdbInfo
	{

		[XmlElement(ElementName="ESRB",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _ESRB;
		
		[XmlIgnore]
		public string ESRB
		{ 
			get { return _ESRB; }
			set { _ESRB = value; }
		}

		[XmlElement(ElementName="ClusterID",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _ClusterID;
		
		[XmlIgnore]
		public string ClusterID
		{ 
			get { return _ClusterID; }
			set { _ClusterID = value; }
		}

		[XmlElement(ElementName="DefaultLocale",IsNullable=false,DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _DefaultLocale;
		
		[XmlIgnore]
		public string DefaultLocale
		{ 
			get { return _DefaultLocale; }
			set { _DefaultLocale = value; }
		}

		public XboxWebdbInfo()
		{
		}
	}


	[XmlType(TypeName="XboxProductInformation"),Serializable]
	public class XboxProductInformation
	{

		[XmlElement(Type=typeof(XboxPublisher),ElementName="Publisher",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxPublisher _Publisher;
		
		[XmlIgnore]
		public XboxPublisher Publisher
		{
			get
			{
				if (_Publisher == null) _Publisher = new XboxPublisher();		
				return _Publisher;
			}
			set {_Publisher = value;}
		}

		public XboxProductInformation()
		{
		}
	}


	[XmlType(TypeName="XboxPublisher"),Serializable]
	public class XboxPublisher
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string _name;
		
		[XmlIgnore]
		public string Name
		{ 
			get { return _name; }
			set { _name = value; }
		}

		public XboxPublisher()
		{
		}
	}


	[XmlRoot(ElementName="NewDataSet",IsNullable=false),Serializable]
	public class NewDataSet
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return XboxConfigurationCollection.GetEnumerator();
		}

		public XboxConfiguration Add(XboxConfiguration obj)
		{
			return XboxConfigurationCollection.Add(obj);
		}

		[XmlIgnore]
		public XboxConfiguration this[int index]
		{
			get { return (XboxConfiguration) XboxConfigurationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return XboxConfigurationCollection.Count; }
        }

        public void Clear()
		{
            XboxConfigurationCollection.Clear();
        }

		public XboxConfiguration Remove(int index) 
		{ 
            XboxConfiguration obj = XboxConfigurationCollection[index];
            XboxConfigurationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            XboxConfigurationCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(XboxConfiguration),ElementName="XboxConfiguration",IsNullable=false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public XboxConfigurationCollection _XboxConfigurationCollection;
		
		[XmlIgnore]
		public XboxConfigurationCollection XboxConfigurationCollection
		{
			get
			{
				if (_XboxConfigurationCollection == null) _XboxConfigurationCollection = new XboxConfigurationCollection();
				return _XboxConfigurationCollection;
			}
			set {_XboxConfigurationCollection = value;}
		}

		public NewDataSet()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\Matchmaking.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public void AddMatchAttribute(XboxLiveSubmissionProject xlast, uint attributeId)
        {
            AddMatchAttribute(xlast, "0x" + attributeId.ToString("X8"));
        }

        public void AddMatchAttribute(XboxLiveSubmissionProject xlast, string attributeId)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            ServerTestFramework.STFTools.ConfigFiles.Attribute newAttrib = new ServerTestFramework.STFTools.ConfigFiles.Attribute();
            newAttrib.id = attributeId;
            xlast.GameConfigProject.Matchmaking.Schema.Add(newAttrib);
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, int value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.Integer, value.ToString());
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, long value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.LongInteger, value.ToString());
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, float value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.Float, value.ToString("f6"));
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, double value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.LongFloat, value.ToString("f6"));
        }

        public void AddMatchConstant(XboxLiveSubmissionProject xlast, DateTime value)
        {
            AddMatchConstant(xlast, XLASTPropertyType.DateTime, value.ToShortDateString());
        }

        private void AddMatchConstant(XboxLiveSubmissionProject xlast, XLASTPropertyType type, string value)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            Constant newConst = new Constant();
            newConst.id = String.Format("0x{0}500{1}", (uint)type, xlast.GameConfigProject.Matchmaking.Constants.nextId.ToString("d04"));
            newConst.value = value;
            newConst.name = String.Format("MatchConstant{0:d03}", xlast.GameConfigProject.Matchmaking.Constants.nextId + 1);
            xlast.GameConfigProject.Matchmaking.Constants.Add(newConst);
            xlast.GameConfigProject.Matchmaking.Constants.nextId++;
        }

        public uint AddMatchQuery(XboxLiveSubmissionProject xlast, ushort maxResults, type2 queryType, bool qosProbe)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.Matchmaking.clsid)
            {
                CreateMatchmaking(xlast);
            }

            Query newQuery = new Query();
            newQuery.clsid = QueryCLSID;
            // The Query element is weird: the nextId attribute actually bahaves more like a maxId value.
            // Because of this, we need to use the collection count as the id.
            newQuery.id = (uint)xlast.GameConfigProject.Matchmaking.Queries.QueryCollection.Count;
            newQuery.groupBy = "0xFFFFFFFF";
            newQuery.friendlyName = String.Format("MatchQuery{0:d03}", newQuery.id + 1);
            newQuery.maxResults = maxResults;
            newQuery.type = queryType;
            newQuery.qosProbe = qosProbe;

            xlast.GameConfigProject.Matchmaking.Queries.QueryCollection.Add(newQuery);
            xlast.GameConfigProject.Matchmaking.Queries.nextId = newQuery.id;
            
            // Every query requires Game Type and Game Mode return values
            AddMatchQueryReturnValue(xlast, newQuery.id, GAME_TYPE_CONTEXT_ID, type234.Normal);
            AddMatchQueryReturnValue(xlast, newQuery.id, GAME_MODE_ID, type234.Normal);

            return newQuery.id;
        }

        public void AddMatchQueryReturnValue(XboxLiveSubmissionProject xlast, uint queryId, string id, type234 returnType)
        {
            Query query = FindQuery(xlast, queryId);
            if (query == null)
            {
                throw new StfException("Query id {0} doesn't exist in the XLAST file.", queryId);
            }

            Return newReturn = new Return();
            newReturn.id = id;
            newReturn.type = returnType;
            newReturn.ordinal = (ushort)query.Returns.Count;
            query.Returns.Add(newReturn);
        }

        public void AddMatchQueryParameter(XboxLiveSubmissionProject xlast, uint queryId, string id)
        {
        }

        private void CreateMatchmaking(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Matchmaking.clsid = MatchmakingCLSID;
            xlast.GameConfigProject.Matchmaking.Constants.clsid = ConstantsCLSID;
            xlast.GameConfigProject.Matchmaking.Constants.nextId = 0;
            xlast.GameConfigProject.Matchmaking.Schema.clsid = SchemaCLSID;
            AddMatchAttribute(xlast, GAME_TYPE_CONTEXT_ID);
            AddMatchAttribute(xlast, GAME_MODE_ID);
            AddMatchAttribute(xlast, GAMER_ZONE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_COUNTRY_PROPERTY_ID);
            AddMatchAttribute(xlast, LANGUAGE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_RATING_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_MU_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_SIGMA_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_PUID_PROPERTY_ID);
            AddMatchAttribute(xlast, AFFILIATE_VALUE_PROPERTY_ID);
            AddMatchAttribute(xlast, GAMER_HOSTNAME_PROPERTY_ID);
            AddMatchAttribute(xlast, PLATFORM_TYPE_PROPERTY_ID);
            AddMatchAttribute(xlast, PLATFORM_LOCK_PROPERTY_ID);
            xlast.GameConfigProject.Matchmaking.Queries.clsid = QueriesCLSID;
            xlast.GameConfigProject.Matchmaking.Queries.nextId = 0;
        }

        private Query FindQuery(XboxLiveSubmissionProject xlast, uint queryId)
        {
            foreach (Query query in xlast.GameConfigProject.Matchmaking.Queries.QueryCollection)
            {
                if (query.id == queryId)
                    return query;
            }

            return null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\Presence.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        public PresenceMode AddPresence(XboxLiveSubmissionProject xlast)
        {
            PresenceMode newMode = new PresenceMode();

            newMode.clsid = PresenceModeCLSID;
            newMode.contextValue = xlast.GameConfigProject.Presence.nextContextValue;
            newMode.friendlyName = "RichPresenceString" + newMode.contextValue.ToString("d3");
            newMode.stringId = AddString(xlast, newMode.friendlyName + " String.");
            xlast.GameConfigProject.Presence.Add(newMode);
            xlast.GameConfigProject.Presence.nextContextValue++;
            return newMode;
        }

        private void CreatePresence(XboxLiveSubmissionProject xlast)
        {
            xlast.GameConfigProject.Presence.clsid = PresenceCLSID;
            xlast.GameConfigProject.Presence.nextContextValue = 0;

            // XLAST files without at least one Presence mode are invalid, so add one.
            AddPresence(xlast);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\Properties.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTPropertyType : uint
    {
        Integer = 1,
        LongInteger,
        LongFloat,
        String,
        Float,
        DateTime = 7
    }

    public partial class XLASTFactory
    {
        private const uint RATING_PROPERTY_ID = 0x20000001;
        private const uint RANK_PROPERTY_ID = 0x10008001;
        private const uint GAMERNAME_PROPERTY_ID = 0x40008002;
        private const uint GAMER_ZONE_PROPERTY_ID = 0x10008101;
        private const uint GAMER_COUNTRY_PROPERTY_ID = 0x10008102;
        private const uint LANGUAGE_PROPERTY_ID = 0x10008103;
        private const uint GAMER_RATING_PROPERTY_ID = 0x50008104;
        private const uint GAMER_MU_PROPERTY_ID = 0x30008105;
        private const uint GAMER_SIGMA_PROPERTY_ID = 0x30008106;
        private const uint GAMER_PUID_PROPERTY_ID = 0x20008107;
        private const uint AFFILIATE_VALUE_PROPERTY_ID = 0x20008108;
        private const uint GAMER_HOSTNAME_PROPERTY_ID = 0x40008109;
        private const uint PLATFORM_TYPE_PROPERTY_ID = 0x10008201;
        private const uint PLATFORM_LOCK_PROPERTY_ID = 0x10008202;

        public void AddProperties(XboxLiveSubmissionProject xlast, int count)
        {
            for (int i = 1; i <= count; i++)
            {
                XLASTPropertyType type = GetRandomPropertyType();
                AddProperty(xlast, type);
            }
        }

        public string AddProperty(XboxLiveSubmissionProject xlast, XLASTPropertyType propertyType)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            string newId;
            uint id = ((uint)propertyType << 28) | xlast.GameConfigProject.Properties.nextId;
            string name = "Property" + xlast.GameConfigProject.Properties.nextId.ToString("d3");
            ushort stringId = AddString(xlast, name + " string");
            newId = AddProperty(xlast, id, stringId, propertyType, name);

            return newId;
        }

        public string AddProperty(XboxLiveSubmissionProject xlast, uint id, ushort stringId, XLASTPropertyType propertyType, string friendlyName)
        {
            Property newProperty = new Property();

            newProperty.clsid = PropertyCLSID;
            newProperty.id = "0x" + id.ToString("X8");
            newProperty.stringId = stringId;
            newProperty.friendlyName = friendlyName;
            switch (propertyType)
            {
                case XLASTPropertyType.DateTime:
                    newProperty.dataSize = 8;
                    newProperty.Format.year = true;
                    newProperty.Format.month = true;
                    newProperty.Format.day = true;
                    newProperty.Format.hours = true;
                    newProperty.Format.minutes = true;
                    newProperty.Format.seconds = true;
                    newProperty.Format.milliseconds = true;
                    break;
                case XLASTPropertyType.Float:
                    newProperty.dataSize = 4;
                    newProperty.Format.decimals = 2;
                    break;
                case XLASTPropertyType.Integer:
                    newProperty.dataSize = 4;
                    newProperty.Format.hours = false;
                    newProperty.Format.minutes = false;
                    newProperty.Format.seconds = false;
                    newProperty.Format.milliseconds = false;
                    break;
                case XLASTPropertyType.LongFloat:
                    newProperty.dataSize = 8;
                    newProperty.Format.decimals = 2;
                    break;
                case XLASTPropertyType.LongInteger:
                    newProperty.dataSize = 8;
                    newProperty.Format.hours = false;
                    newProperty.Format.minutes = false;
                    newProperty.Format.seconds = false;
                    newProperty.Format.milliseconds = false;
                    break;
                case XLASTPropertyType.String:
                    newProperty.dataSize = 0;
                    break;
            }
            xlast.GameConfigProject.Properties.Add(newProperty);
            xlast.GameConfigProject.Properties.nextId++;

            return newProperty.id;
        }

        private void CreateProperties(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.Properties.clsid = PropertiesCLSID;
            xlast.GameConfigProject.Properties.nextId = 1;

            AddProperty(xlast, RANK_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_RANK, XLASTPropertyType.Integer, "RANK");
            AddProperty(xlast, GAMERNAME_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMERNAME, XLASTPropertyType.String, "GAMERNAME");
            AddProperty(xlast, GAMER_ZONE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_ZONE, XLASTPropertyType.Integer, "GAMERZONE");
            AddProperty(xlast, GAMER_COUNTRY_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_COUNTRY, XLASTPropertyType.Integer, "GAMERCOUNTRY");
            AddProperty(xlast, LANGUAGE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_LANGUAGE, XLASTPropertyType.Integer, "LANGUAGE");
            AddProperty(xlast, GAMER_RATING_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_RATING, XLASTPropertyType.Float, "GAMERRATING");
            AddProperty(xlast, GAMER_MU_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_MU, XLASTPropertyType.LongFloat, "GAMERMU");
            AddProperty(xlast, GAMER_SIGMA_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_SIGMA, XLASTPropertyType.LongFloat, "GAMERSIGMA");
            AddProperty(xlast, GAMER_PUID_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_PUID, XLASTPropertyType.LongInteger, "GAMERPUID");
            AddProperty(xlast, AFFILIATE_VALUE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_AFFILIATE_VALUE, XLASTPropertyType.LongInteger, "AFFILIATEVALUE");
            AddProperty(xlast, GAMER_HOSTNAME_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_GAMER_HOSTNAME, XLASTPropertyType.String, "GAMERHOSTNAME");
            AddProperty(xlast, PLATFORM_TYPE_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_PLATFORM_TYPE, XLASTPropertyType.String, "PLATFORMTYPE");
            AddProperty(xlast, PLATFORM_LOCK_PROPERTY_ID, (ushort)XLASTDefaultString.X_STRINGID_PLATFORM_LOCK, XLASTPropertyType.String, "PLATFORMLOCK");

            // We need to add a well-known long int property to be used as the rating column in leaderboards
            AddProperty(xlast, RATING_PROPERTY_ID, AddString(xlast, "Rating"), XLASTPropertyType.LongInteger, "Rating");
        }

        private XLASTPropertyType GetRandomPropertyType()
        {
            int val;
            do
            {
                // There is no property ID 6 and string properties (ID 4) are not allowed by users.
                val = _rnd.Next((int)XLASTPropertyType.Integer, (int)XLASTPropertyType.DateTime + 1);
            } while (val == 4 || val == 6);

            return (XLASTPropertyType)val;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ConfigFiles\XmlOfferMap.cs ===
using System;
using System.Collections;
using System.IO;
using System.Xml;

namespace ServerTestFramework.STFTools.ConfigFiles
{
	/// <summary>
	/// Represents a mapping from an XML Offer file to the database entry it should
	/// correspond to.
	/// </summary>
    public class XmlOfferMap {
        ArrayList tests;
        Hashtable maps;


		/// <summary>
		/// Generate an XmlOfferMap, which will contain a parsed version of the map file.
		/// </summary>
		/// <param name="filename">Path to the offer map file.</param>
        public XmlOfferMap(string filename) {
            tests = new ArrayList();
            maps = new Hashtable();

            //Preprocess--grab the entire offer map and store it in a structure.
            StreamReader offerMapStream = File.OpenText(filename);
            String line;
            line = offerMapStream.ReadLine();
            while (line != null) {
                if (line.StartsWith("MAPDEFINITION")) { //this is a mapping of xpath, followed by
                                                       //string number pairs.  It is a simple conversion of 
													   //string to number, as is required by some offer fields.
                    string xpath = GetWord(line, 1);
                    Hashtable newMap = new Hashtable();
                    line = offerMapStream.ReadLine();
                    while (!line.StartsWith("END")) {
                        newMap.Add(GetWord(line,0), GetWord(line, 1));
                        line = offerMapStream.ReadLine();
                    }
                    line = offerMapStream.ReadLine();
                    maps.Add(xpath, newMap);
                    continue;
                }
                if (line.StartsWith("TABLE")) { //this is the start of a TableMapping--a table, followed by where all the
												//columns of that table map to in the offer file.
                    TableMapping newTest = new TableMapping(GetWord(line, 1));
                    ParseMultipleRowsInfo(offerMapStream, newTest, GetWord(line,2));

                    line = offerMapStream.ReadLine(); //we should now be reading the first map of
                                                      //Xpath to column name
                    while (!line.StartsWith("END")) {
                        if (line.StartsWith("CONSTANT") ||
                            line.StartsWith("MAP")) {
                            EntryMapping newMap = new EntryMapping(GetWord(line, 1), GetWord(line,2), GetWord(line,3));
                            newMap.flag = GetWord(line, 0);
                            newTest.dataMappings.Add(newMap);
                        } else if (!line.StartsWith("#")) {
                            EntryMapping newMap = new EntryMapping(GetWord(line, 0), GetWord(line,1), GetWord(line,2));
                            newTest.dataMappings.Add(newMap);
                        }
                        line = offerMapStream.ReadLine();
                    }
                    tests.Add(newTest);
                    line = offerMapStream.ReadLine();
                    continue;
                }
                if ((line.Equals("")) || (line.StartsWith("#"))) {
                    line = offerMapStream.ReadLine();
                    continue;
                }
                //if we get down here, we're parsing something we're not expecting.  Fail unhappily.
                Global.RO.Error("Unrecognized line:" + line);
                throw new Exception("Parse error in XmlOfferMap.cs: Unexpected data(neither comment, blank, nor recognized keyword");
            }
            offerMapStream.Close();
	}

		/// <summary>
		/// Parse the MANYROWS and ONEROW keywords.
		/// The MANYROWS keyword at the end of a table definition means that there will be
		/// multiple nodes that match the XPATH.  Each matching node corresponds to a separate
		/// row in the table.  A ONEROW keyword indicates that each field will be searched once,
		/// and matched against only one row in the database.
		/// </summary>
		/// <param name="offerMapStream">The offer map file</param>
		/// <param name="test">The table mapping to create</param>
		/// <param name="keyword">An optional keyword</param>
        private void ParseMultipleRowsInfo(StreamReader offerMapStream, TableMapping test, string keyword) {
            if (keyword.Equals("MANYROWS")) 
            {
                String line = offerMapStream.ReadLine();
                if (!line.StartsWith("LIST")) 
                {
                    throw new Exception("Parse error in XmlOfferMap.cs: Expecting LIST keyword after MANYROWS keyword");
                } 
                else 
                {
                    test.listQuery = GetWord(line, 1);
                    test.optionalTest = "";
                }
            } 
            else if (keyword.Equals("ONEROW")) 
            {
                test.listQuery = "";
                test.optionalTest = "";
 
            } 
            else if (keyword.Equals("OPTIONAL"))
            {
                test.listQuery = "";
                String line = offerMapStream.ReadLine();
                if (!line.StartsWith("TEST"))
                {
                    throw new Exception("Parse error in XmlOfferGapMap.cs: Expecting TEST keyword after OPTIONAL TABLE declared.");
                }
                else
                {
                    test.optionalTest = GetWord(line,1);
                }
            }
            else throw new Exception("Parse error in XmlOfferMap.cs: Table description must be MANYROWS, ONEROW or OPTIONAL");
        }

    
        //Get the num-th word in this line.  Words are separated by tabs, spaces, or newlines.
        public static string GetWord(string input, int num) {
            int curchar = 0;
            while (num > 0) {
                //skip a word
                while (!IsWhitespace(input[curchar])) {
                    curchar++;
                    if (curchar >= input.Length) {
                        Global.RO.Error("Error, attempt to read " + num  + " words, but line does not contain that many words.");
                        Global.RO.Error("Line text is:" + input);
                    }
                }
                //skip some spaces
                while (IsWhitespace(input[curchar])) {
                    curchar++;
                    if (curchar >= input.Length) {
                        Global.RO.Error("Error, attempt to read " + num  + " words, but line does not contain that many words.");
                        Global.RO.Error("Line text is:" + input);
                    }
                }
                num --;  //we've skipped a word.
            }
            int beginWord = curchar;
            while ((curchar < input.Length) && 
                   (!IsWhitespace(input[curchar]))) {
                curchar++;
            }
            return input.Substring(beginWord, curchar - beginWord);
        }

        public static bool IsWhitespace(char c) {
            return (c == ' ') || (c == '\n') || (c == '\t');
        }

		/// <summary>
		/// Combine the stored data of a map with the offer file to create a SELECT query.  This query should
		/// isolate a row in the database, and is expected to return precisely one entry.
		/// </summary>
		/// <param name="offer">The offer file to which this map will be applied.</param>
		/// <returns>An ArrayList of strings, each one SQL query that should return one row.</returns>
        public ArrayList CreateQueries(XmlOfferFile offer) {
            ArrayList queriesToReturn = new ArrayList();
            foreach (TableMapping test in tests) {
                // Skip over the table if the test node is set and the doesn't exist in the offer...
                if ((test.optionalTest.Equals(""))||(offer.ArbitraryXpath(test.optionalTest)!=null))
                {
                    if (test.listQuery.Equals("")) 
                    {
                        AddSingleQueryString(offer, test, queriesToReturn);
                    } 
                    else 
                    {
                        AddMultipleQueryStrings(offer, test, queriesToReturn);
                    }
                }
            }
            return queriesToReturn;
        }

        
		/// <summary>
		/// Given a table described by a MANYROWS keyword, add multiple SQL queries, one for each
		/// corresponding tag found in the offer file.  Add each of them to queriesToReturn.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="test">Table being checked.</param>
		/// <param name="queriesToReturn">A list of queries that will have strings added.</param>
        public void AddMultipleQueryStrings(XmlOfferFile offer, TableMapping test, ArrayList queriesToReturn) {
            bool quiet = false;
            XmlNodeList offerNodes = offer.MultipleQuery(test.listQuery); //all nodes that match the
                                                                          //LIST xpath
            //go through each node, forming a query off of each.
            if (offerNodes.Count >= 100) {  //let's not go overboard.
                Global.RO.Warn("Over 100 queries generated for this MANYROWS command.  Suppressing query output.");
                quiet = true;
            }
            foreach (XmlNode node in offerNodes) {
                String query = "SELECT COUNT(*) FROM " + test.tableName + " WHERE ";
                bool firstClause = true;
                foreach (EntryMapping dataMap in test.dataMappings) {
                    if (!firstClause) {
                        query += " AND ";
                    }
                    query += GenerateOneWhereClause(offer, dataMap, node);
                    firstClause = false;
                }
                if (!quiet) {
                    Global.RO.Warn(query);
                }
                queriesToReturn.Add(query);                
            }
        }

        
		/// <summary>
		/// Given a ONEROW table description, add the SQL query string that would be used to verify
		/// this row is present in the DB.  Add the string to queriesToReturn.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="test">Table being checked.</param>
		/// <param name="queriesToReturn">A list of queries that will have one string added.</param>
        public void AddSingleQueryString(XmlOfferFile offer, TableMapping test, ArrayList queriesToReturn) {
            String query = "SELECT COUNT(*) FROM " + test.tableName + " WHERE ";
            bool firstClause = true;
            foreach (EntryMapping dataMap in test.dataMappings) {
                if (!firstClause) {
                    query += " AND ";
                }
                query += GenerateOneWhereClause(offer, dataMap, null);
                firstClause = false;
            }
            Global.RO.Warn(query);
            queriesToReturn.Add(query);
        }

		/// <summary>
		/// Used when generating an SQL select query.  This iterates through all the fields that should
		/// be checked.  For each one it pulls the appropriate data out of the offer file, using the XPATH for
		/// that field.  It returns a boolean test to determine if the data in the db matches that of the offer file.
		/// </summary>
		/// <param name="offer">Offer this map is appliped to.</param>
		/// <param name="dataMap">A single instance of mapping one XPATH in the offer file to one field in the DB.</param>
		/// <param name="multipleQueryNode">If the table was defined using MANYROWS, the XPATH is taken relative to this node.</param>
		/// <returns>A string to be added to a where clause.  e.g. "bi_offer_id = 0xfffe07d100000001"</returns>
		public string GenerateOneWhereClause(XmlOfferFile offer, EntryMapping dataMap, XmlNode multipleQueryNode) {
            string whereClause = "";
            string expectedValue;

            //handle specific flags
            if (dataMap.flag.Equals("CONSTANT")) {
                expectedValue = dataMap.offerXmlXPATH;  //if constant, the XPATH is actually the value.
            } else if (multipleQueryNode != null) {
                //this means we want a relative XPATH, from a given node.
                expectedValue = offer.RelativeXpath(multipleQueryNode, dataMap.offerXmlXPATH).InnerXml;
            } else {
                //otherwise it's arbitrary, from the top.
                expectedValue = offer.ArbitraryXpath(dataMap.offerXmlXPATH).InnerXml;
            }
            if (dataMap.flag.Equals("MAP")) {
                if (maps[dataMap.offerXmlXPATH] == null) {
                    Global.RO.Warn("Warning:There is no MAPDEFINITION for the given xpath, " + dataMap.offerXmlXPATH);
                }
                expectedValue = (string) ((Hashtable) maps[dataMap.offerXmlXPATH])[expectedValue];
            }

            //handle datatype-specific issues
            if (dataMap.dataType.Equals("datetime")) {  //trim off everything from the dot onwards.
                //expectedValue = expectedValue.Substring(0, expectedValue.IndexOf('.'));
                DateTime dt = Convert.ToDateTime(expectedValue);
                expectedValue = dt.ToString("s");
            }

            whereClause += dataMap.columnName + " = ";
            if (dataMap.NeedsQuotes()) {
                whereClause += "\'" + expectedValue + "\'";
            } else {
                whereClause += expectedValue;
            }
            return whereClause;
        }

    }

	/// <summary>
	/// A mapping of the fields of one table with the XPATHs that locate those fields in an offer file.
	/// </summary>
	public class TableMapping {
        public string tableName;
        public ArrayList dataMappings;
        public string listQuery;  //this is optional.  If MANYROWS is used to define the table,
                                  //then we expect multiple tags of the same name.  This XPATH query
                                  //will select them all.  The data mappings will be relative,
                                  //unless they have a keyword STATIC
        public string optionalTest;  // Makes this Table optional.  Should be an xpath statement.  
                                     // If it returns NULL, it will skip the check on this table.

        public TableMapping(string tableName) {
            this.tableName = tableName;
            dataMappings = new ArrayList();
            listQuery = null; //must be set during parse.
            optionalTest = null;
        }
    }

	//a mapping of one particular field to one particular XPATH.
    public class EntryMapping {
        public string offerXmlXPATH;
        public string dataType;
        public string columnName;
        public string flag;

        public EntryMapping (string offerXmlXPATH, string dataType, string columnName) {
            this.offerXmlXPATH = offerXmlXPATH;
            this.dataType = dataType;
            this.columnName = columnName;
            this.flag = "";
        }
        //returns true if this data type needs quotes in the SQL query.
        public bool NeedsQuotes() {
            return (dataType.StartsWith("datetime")) ||
                (dataType.IndexOf("char") != -1);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\ProductInformation.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTPlatform
    {
        Xbox360 = 2,
        PC = 4
    }

    public enum XLASTGenre : uint
    {
        Other = 101,
        Action,             // 102
        Adventure,          // 103
        Compilations,       // 104
        Family,             // 105
        Fighting,           // 106
        Music = 108,        // 108
        Platform,           // 109
        Racing,             // 110
        RolePlaying,        // 111
        Shooter,            // 112
        Simulation,         // 113
        Sports,             // 114
        Strategy,           // 115
        DemoTitle=701       // Genre required for Demo titles
    }

    public enum XLASTArcadeGenre : uint
    {
        Arcade = 11600,     // This one is required for all Arcade titles
        ActionArcade,       // 11601
        CardAndBoard,       // 11602
        CoinOpClassics,     // 11603
        PuzzleAndWord,      // 11604
        BarSports,          // 11605
        StrategyAndSims,    // 11606
        ConsoleClassics,    // 11607
        GameShows,          // 11608
        FamilyGames,        // 11609
        Trivia,             // 11610
        SportsGames,        // 11611
        PartyGames,         // 11612
        RacingGames,        // 11613
        RolePlayingGames,   // 11614
        CameraEnabled       // 11615
    }

    public enum XLASTFeature : uint
    {
        Camera = 1,
        CoOp,
        CustomSoundtrack,
        Dolby51,
        HardDriveEnhanced,
        HardDriveRequired,
        LiveAware,
        LiveClans,
        LiveCoOp,
        LiveDownloads,
        LiveFriends,
        LiveMessaging,
        LiveMultiplayer,
        LiveScoreboard,
        LiveServiceProxy,
        LiveStats,
        LiveTournaments,
        LiveVoice,
        LiveVoiceMessaging,
        MemoryUnit,
        MultiplayerVersus,
        Peripherals,
        PremiumOffers,
        SystemLink,
        UserCreatableContent,
        Xbox2Support,
        XboxSupport
    }

    public enum XLASTRating : uint
    {
        ESRB_EC = 1,
        ESRB_E,
        ESRB_E10,
        ESRB_T,
        ESRB_M,
        ESRB_AO,
        ESRB_RP,
        PEGI_3 = 11,
        PEGI_7,
        PEGI_12,
        PEGI_16,
        PEGI_18,
        PEGIFinland_3 = 21,
        PEGIFinland_7,
        PEGIFinland_12,
        PEGIFinland_16,
        PEGIFinland_18,
        PEGIPortugal_4 = 31,
        PEGIPortugal_6,
        PEGIPortugal_12,
        PEGIPortugal_16,
        PEGIPortugal_18,
        PEGIBBFC_3 = 41,
        PEGIBBFC_U,
        PEGIBBFC_7,
        PEGIBBFC_PG,
        PEGIBBFC_12,
        PEGIBBFC_15,
        PEGIBBFC_16,
        PEGIBBFC_18,
        CERO_AllAges = 51,
        CERO_12,
        CERO_15,
        CERO_17,
        CERO_Standard,
        CERO_18,
        USK_All = 61,
        USK_6,
        USK_12,
        USK_16,
        USK_NoYouth,
        OFLCAus_G = 71,
        OFLCAus_G8,
        OFLCAus_M15,
        OFLCAus_MA15,
        OFLCAus_RC,
        OFLCNZ_G = 81,
        OFLCNZ_G8,
        OFLCNZ_M15,
        OFLCNZ_MA15,
        OFLCNZ_RC,
        KMRB_All = 91,
        KMRB_12,
        KMRB_15,
        KMRB_18,
        Brazil_All = 101,
        Brazil_12,
        Brazil_14,
        Brazil_16,
        Brazil_18,
        FPB_All = 111,
        FPB_PG,
        FPB_10,
        FPB_13,
        FPB_16,
        FPB_18
    }

    public enum XLASTRatingSystem : uint
    {
        ESRB = 0,
        PEGI,
        PEGIFinland,
        PEGIPortugal,
        PEGIBBFC,
        CERO,
        USK,
        OFLCAustralia,
        OFLCNewZealand,
        KMRB,
        Brazil,
        FPB
    }

    public partial class XLASTFactory
    {
        public void SetPlatform(XboxLiveSubmissionProject xlast, XLASTPlatform platform)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Platform newPlatform = new Platform();
            newPlatform.name = Enum.GetName(typeof(XLASTPlatform), platform);
            newPlatform.id = (uint)platform;

            if (!xlast.GameConfigProject.ProductInformation.PlatformCollection.Contains(newPlatform))
            {
                xlast.GameConfigProject.ProductInformation.PlatformCollection.Add(newPlatform);
            }
        }

        public void AddGenre(XboxLiveSubmissionProject xlast, XLASTGenre genre)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Genre newGenre = new Genre();
            newGenre.genreId = (uint)genre * 1000000;

            // Only add the Genre if it doesn't already exist
            if (!ContainsGenre(xlast.GameConfigProject.ProductInformation.GenreCollection, newGenre.genreId))
            {
                xlast.GameConfigProject.ProductInformation.GenreCollection.Add(newGenre);
            }
        }

        public void AddArcadeGenre(XboxLiveSubmissionProject xlast, XLASTArcadeGenre arcadeGenre)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Genre newGenre = new Genre();
            newGenre.genreId = (uint)arcadeGenre * 10000;

            // Only add the Genre if it doesn't already exist
            if (!ContainsGenre(xlast.GameConfigProject.ProductInformation.GenreCollection, newGenre.genreId))
            {
                xlast.GameConfigProject.ProductInformation.GenreCollection.Add(newGenre);
            }
        }

        public void AddRating(XboxLiveSubmissionProject xlast, XLASTRating rating)
        {
            AddRating(xlast, rating, 0, null);
        }

        public void AddRating(XboxLiveSubmissionProject xlast, XLASTRating rating, uint imageId, string description)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            uint ratingSystem = (uint)((uint)rating / 10);
            Rating newRating = new Rating();
            newRating.ratingSystemId = ratingSystem;
            newRating.ratingId = (uint)rating;
            newRating.Description = description;
            newRating.imageId = imageId;
            if (!ContainsRating(xlast.GameConfigProject.ProductInformation.RatingCollection, newRating))
            {
                xlast.GameConfigProject.ProductInformation.RatingCollection.Add(newRating);
            }
        }

        public void AddAllRatings(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            // Add one of each rating system
            uint[] systems = (uint[])Enum.GetValues(typeof(XLASTRatingSystem));
            foreach (uint sys in systems)
            {
                AddRating(xlast, GetRandomRating((XLASTRatingSystem)sys));
            }
        }

        public void AddFeature(XboxLiveSubmissionProject xlast, XLASTFeature feature)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            Feature newFeature = new Feature();
            newFeature.name = Enum.GetName(typeof(XLASTFeature), feature);
            newFeature.enabled = true;
            if (!ContainsFeature(xlast.GameConfigProject.ProductInformation.FeatureCollection, newFeature))
            {
                xlast.GameConfigProject.ProductInformation.FeatureCollection.Add(newFeature);
            }
        }

        public void AddFeatures(XboxLiveSubmissionProject xlast, int count)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            for (int i = 0; i < count; i++)
            {
                AddFeature(xlast, (XLASTFeature)_rnd.Next((int)XLASTFeature.Camera, (int)XLASTFeature.XboxSupport + 1));
            }
        }

        public void AddProductInformation(XboxLiveSubmissionProject xlast)
        {
            int i;
            int count;

            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                string desc;
                uint imageId;

                // Genres
                count = _rnd.Next(1, 8);
                for (i = 0; i < count; i++)
                {
                    AddArcadeGenre(xlast, GetRandomArcadeGenre());
                }

                // Ratings
                count = _rnd.Next(1, 11);
                for (i = 0; i < count; i++)
                {
                    if (_rnd.Next(1, 101) > 50)
                    {
                        desc = _rnd.GenerateUnicodeString(10, 128, false);
                    }
                    else
                    {
                        desc = "";
                    }
                    imageId = (uint)_rnd.Next(0, xlast.GameConfigProject.Images.Count);
                    AddRating(xlast, GetRandomRating(GetRandomRatingSystem()), imageId, desc);
                }
            }
            else
            {
                // Genres
                if (xlast.GameConfigProject.titleType != (uint)XLASTTitleType.DemoTitle)
                {
                    count = _rnd.Next(1, 8);
                    for (i = 0; i < count; i++)
                    {
                        AddGenre(xlast, GetRandomGenre());
                    }
                }

                // Ratings
                count = _rnd.Next(1, 21);
                for (i = 0; i < count; i++)
                {
                    AddRating(xlast, GetRandomRating(GetRandomRatingSystem()));
                }
            }

            // Features
            count = _rnd.Next(1, 14);
            AddFeatures(xlast, count);
        }

        private void CreateProductInformation(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.ProductInformation.developerStringId = AddString(xlast, "Developer String");
            xlast.GameConfigProject.ProductInformation.publisherStringId = AddString(xlast, "Publisher String");
            xlast.GameConfigProject.ProductInformation.sellTextStringId = AddString(xlast, "SellText String");
            xlast.GameConfigProject.ProductInformation.genreTextStringId = AddString(xlast, "Genre String");
            xlast.GameConfigProject.ProductInformation.offlinePlayersMax = 0;
            xlast.GameConfigProject.ProductInformation.livePlayersMax = 0;
            xlast.GameConfigProject.ProductInformation.systemLinkPlayersMax = 0;
            SetPlatform(xlast, XLASTPlatform.Xbox360);

            switch (xlast.GameConfigProject.titleType)
            {
                case (uint)XLASTTitleType.ArcadeTitle:
                    xlast.GameConfigProject.ProductInformation.arcadeDescriptionStringId = AddString(xlast, "Arcade Description String");
                    AddArcadeGenre(xlast, XLASTArcadeGenre.Arcade);
                    AddArcadeGenre(xlast, GetRandomArcadeGenre());
                    break;
                case (uint)XLASTTitleType.FullGame:
                    AddGenre(xlast, GetRandomGenre());
                    break;
                case (uint)XLASTTitleType.DemoTitle:
                    AddGenre(xlast, XLASTGenre.DemoTitle);
                    break;
                case (uint)XLASTTitleType.SystemTitle:
                    break;
            }
        }

        private XLASTGenre GetRandomGenre()
        {
            int val;

            do
            {
                val = _rnd.Next((int)XLASTGenre.Other, (int)XLASTGenre.Strategy + 1);
            } while (val == 107);

            return (XLASTGenre)val;
        }

        private XLASTArcadeGenre GetRandomArcadeGenre()
        {
            return (XLASTArcadeGenre)_rnd.Next((int)XLASTArcadeGenre.ActionArcade, (int)XLASTArcadeGenre.CameraEnabled + 1);
        }

        private XLASTRating GetRandomRating(XLASTRatingSystem ratingSystem)
        {
            int rating;
            int upperBound = 1;

            switch (ratingSystem)
            {
                case XLASTRatingSystem.PEGI:
                case XLASTRatingSystem.PEGIFinland:
                case XLASTRatingSystem.PEGIPortugal:
                case XLASTRatingSystem.USK:
                case XLASTRatingSystem.OFLCAustralia:
                case XLASTRatingSystem.OFLCNewZealand:
                case XLASTRatingSystem.Brazil:
                    upperBound = 6;
                    break;
                case XLASTRatingSystem.CERO:
                case XLASTRatingSystem.FPB:
                    upperBound = 7;
                    break;
                case XLASTRatingSystem.ESRB:
                    upperBound = 8;
                    break;
                case XLASTRatingSystem.PEGIBBFC:
                    upperBound = 9;
                    break;
            }
            rating = _rnd.Next(1, upperBound);
            return (XLASTRating)(((int)ratingSystem * 10) + rating);
        }

        private XLASTRatingSystem GetRandomRatingSystem()
        {
            return (XLASTRatingSystem)_rnd.Next((int)XLASTRatingSystem.ESRB, (int)XLASTRatingSystem.FPB + 1);
        }

        private bool ContainsGenre(GenreCollection genres, uint genreId)
        {
            foreach (Genre g in genres)
            {
                if (g.genreId == genreId)
                    return true;
            }
            return false;
        }

        private bool ContainsRating(RatingCollection ratings, Rating rating)
        {
            foreach (Rating r in ratings)
            {
                if (r.ratingSystemId == rating.ratingSystemId)
                    return true;
            }
            return false;
        }

        private bool ContainsFeature(FeatureCollection features, Feature feature)
        {
            foreach (Feature f in features)
            {
                if (String.Compare(f.name, feature.name, true) == 0)
                    return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SigRetriever\makefile.inc ===
!include $(INETROOT)\build\makefile.inc


!if defined(PASS2)

bin\$(TARGETNAME).exe: $(URTTARGET)
        -robocopy ($**D) ($@D) ($@F) /R:0 /NP /NJH /NJS /A-:R
        -robocopy $(TARGETPATH)\$(TARGET_DIRECTORY) bin $(TARGETNAME).pdb /R:0 /NP /NJH /NJS /A-:R

!else

bin\$(TARGETNAME).exe:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\StatsViews.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public partial class XLASTFactory
    {
        // This gets set to a single string ID for the required rating column in all leaderboards.
        private ushort _ratingColumnStringId = 0;

        public uint AddStatsView(XboxLiveSubmissionProject xlast, resetType reset, ushort entryExpiration, ushort maxAttachments, bool hidden, bool arbitrated, bool top100)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            if (null == xlast.GameConfigProject.StatsViews.clsid)
            {
                CreateStatsViews(xlast);
            }

            StatsView newView = new StatsView();
            newView.clsid = StatsViewCLSID;
            newView.resetType = reset;
            newView.entryExpiration = entryExpiration;
            newView.maxAttachments = maxAttachments;
            newView.hidden = hidden;
            newView.arbitrated = arbitrated;
            newView.onlineOnly = false;
            newView.topEntries = top100 ? 100 : uint.MaxValue;
            newView.id = xlast.GameConfigProject.StatsViews.nextViewId;
            newView.friendlyName = String.Format("StatsView{0:d03}", newView.id);
            newView.viewType = "Leaderboard";
            newView.stringId = AddString(xlast, String.Format("{0} Name", newView.friendlyName));
            xlast.GameConfigProject.StatsViews.Add(newView);
            xlast.GameConfigProject.StatsViews.nextViewId++;

            // Every leaderboard must have a Rank column, a Gamer Name column and a Rating column
            AddStatsViewColumn(newView, "0x10008001", type.Last, false, false, (ushort)XLASTDefaultString.X_STRINGID_RANKCOL, 65535);
            AddStatsViewColumn(newView, "0x40008002", type.Last, false, false, (ushort)XLASTDefaultString.X_STRINGID_GAMERNAMECOL, 65533);
            AddStatsViewColumn(newView, "0x" + RATING_PROPERTY_ID.ToString("X8"), type.Last, false, true, _ratingColumnStringId, 65534);

            // If this is an Arcade title, add another column to be the one required Arcade Leaderboard column
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                string propertyId = AddProperty(xlast, XLASTPropertyType.Integer);
                ushort arcadeStringId = AddString(xlast, "Arcade Leaderboard Column");
                AddStatsViewColumn(FindStatsView(xlast, newView.id), propertyId, type.Last, false, false, arcadeStringId,
                    GetNextAttributeId(newView.Columns.FieldCollection), true, ArcadeLeaderboardSortType.Ascending, arcadeStringId);
            }

            return newView.id;
        }

        /// <summary>
        /// Adds a Context field to a StatsView (leaderboard)
        /// </summary>
        /// <param name="xlast">The xlast file object.</param>
        /// <param name="viewId">The ID of the StatView to which the column will be added.</param>
        /// <param name="contextId">The ID of the existing Context to use.</param>
        /// <param name="hidden">Flag indicating whether this column is hidden.</param>
        public void AddStatsViewColumn(XboxLiveSubmissionProject xlast, uint viewId, string contextId, bool hidden)
        {
            StatsView statsView = FindStatsView(xlast, viewId);
            if (statsView == null)
            {
                throw new StfException("Unable to find a StatsView with the id {0}", viewId);
            }

            ViewFieldType newField = new ViewFieldType();
            newField.ordinal = (ushort)statsView.Columns.FieldCollection.Count;
            newField.friendlyName = String.Format("StatsViewColumn{0:d03}", newField.ordinal);
            newField.stringId = AddString(xlast, newField.friendlyName + " Name");
            newField.hidden = hidden;
            newField.Context.id = UInt32.Parse(contextId.Substring(2), System.Globalization.NumberStyles.HexNumber);
            newField.attributeId = GetNextAttributeId(statsView.Columns.FieldCollection);

            statsView.Columns.FieldCollection.Add(newField);
        }

        /// <summary>
        /// Adds a Property field to a StatsView (leaderboard)
        /// </summary>
        /// <param name="xlast">The xlast file object.</param>
        /// <param name="viewId">The ID of the StatView to which the Property will be added.</param>
        /// <param name="propertyId">The ID of the existing Property to use.</param>
        /// <param name="aggregationType">The aggregation type to use for this column.</param>
        /// <param name="hidden">A flag indicating whether this column is hidden.</param>
        /// <param name="rank">A flag indicating whether this column is used for ranking.</param>
        public void AddStatsViewColumn(XboxLiveSubmissionProject xlast, uint viewId, string propertyId, type aggregationType, bool hidden, bool rank)
        {
            StatsView statsView = FindStatsView(xlast, viewId);
            if (statsView == null)
            {
                throw new StfException("Unable to find a StatsView with the id {0}", viewId);
            }

            ushort stringId = AddString(xlast, String.Format("StatsViewColumn{0:d03}", statsView.Columns.FieldCollection.Count));
            ushort attributeId = rank ? (ushort)65534 : GetNextAttributeId(statsView.Columns.FieldCollection);
            AddStatsViewColumn(statsView, propertyId, aggregationType, hidden, rank, stringId, attributeId);
        }

        /// <summary>
        /// Adds a number of StatsViews to an XLAST file.
        /// </summary>
        /// <param name="xlast">An XLAST file object.</param>
        /// <param name="count">The number of StatsViews to add to the XLAST file object.</param>
        public void AddStatsViews(XboxLiveSubmissionProject xlast, uint count)
        {
            int reset;
            ushort entryExpiration;
            ushort maxAttachments;
            bool hidden;
            bool arbitrated;
            bool top100;
            int columnCount;
            uint viewId;

            for (int i = 0; i < count; i++)
            {
                reset = _rnd.Next((int)resetType.Weekly, (int)resetType.Never + 1);
                entryExpiration = (ushort)_rnd.Next(0, ((int)ushort.MaxValue) + 1);
                maxAttachments = (ushort)_rnd.Next(0, ((int)ushort.MaxValue) + 1);
                hidden = (_rnd.Next(1, 101) > 90);          // 10% chance of being hidden
                arbitrated = (_rnd.Next(1, 101) > 60);      // 40% chance of being arbitrated
                top100 = (_rnd.Next(1, 101) > 50);          // 50% chance of being Top 100
                columnCount = _rnd.Next(0, 11);

                viewId = AddStatsView(xlast, (resetType)reset, entryExpiration, maxAttachments, hidden, arbitrated, top100);
                AddStatsViewColumns(xlast, viewId, columnCount);
            }
        }

        /// <summary>
        /// Adds a number of columns to a specified StatsView.
        /// </summary>
        /// <param name="xlast">An XLAST file object.</param>
        /// <param name="viewId">The ID os the StatsView to which the columns will be added.</param>
        /// <param name="count">The number of columns to add.</param>
        public void AddStatsViewColumns(XboxLiveSubmissionProject xlast, uint viewId, int count)
        {
            PropertyCollection properties = FindAvailableProperties(xlast);
            ContextCollection contexts = FindAvailableContexts(xlast);
            bool hidden = (_rnd.Next(1, 101) > 90);
            int index;

            // If there are no Contexts available for use, add some
            if (contexts.Count == 0)
            {
                AddContexts(xlast, 3, 4);
                contexts = FindAvailableContexts(xlast);
            }

            // If there are no Properties available for use, add some
            if (properties.Count == 0)
            {
                AddProperties(xlast, 5);
                properties = FindAvailableProperties(xlast);
            }

            for (int i = 0; i < count; i++)
            {
                if (_rnd.Next(1, 101) > 50)
                {
                    // Create a Context column
                    index = _rnd.Next(0, contexts.Count);
                    AddStatsViewColumn(xlast, viewId, contexts[index].id, hidden);
                }
                else
                {
                    // Create a Property column
                    index = _rnd.Next(0, properties.Count);
                    type aggregationType = (type)_rnd.Next((int)type.Min, (int)type.Last + 1);
                    AddStatsViewColumn(xlast, viewId, properties[index].id, aggregationType, hidden, false);
                }
            }
        }

        // Since every new leaderboard requires two well-known columns, this is provided to specify
        // the correct string ID and attribute ID for the columns.
        private void AddStatsViewColumn(
            StatsView statsView,
            string propertyId,
            type aggregationType,
            bool hidden,
            bool rank,
            ushort stringId,
            ushort attributeId)
        {
            AddStatsViewColumn(statsView, propertyId, aggregationType, hidden, rank, stringId, attributeId, false, ArcadeLeaderboardSortType.Ascending, 0);
        }
        
        private void AddStatsViewColumn(
            StatsView statsView,
            string propertyId,
            type aggregationType,
            bool hidden,
            bool rank,
            ushort stringId,
            ushort attributeId,
            bool arcadeLeaderboard,
            ArcadeLeaderboardSortType arcadeSort,
            ushort arcadeStringId)
        {
            ViewFieldType newField = new ViewFieldType();
            newField.ordinal = (ushort)statsView.Columns.FieldCollection.Count;
            newField.friendlyName = String.Format("StatsViewColumn{0:d03}", newField.ordinal);
            newField.stringId = stringId;
            newField.hidden = hidden;
            newField.Property.id = propertyId;
            newField.Property.Aggregation.type = aggregationType;
            newField.attributeId = attributeId;
            if (arcadeLeaderboard)
            {
                newField.arcadeLeaderboard = arcadeLeaderboard;
                newField.arcadeSort = arcadeSort;
                newField.arcadeStringId = arcadeStringId;
            }

            statsView.Columns.FieldCollection.Add(newField);
        }

        private void CreateStatsViews(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            xlast.GameConfigProject.StatsViews.clsid = StatsViewsCLSID;
            xlast.GameConfigProject.StatsViews.nextViewId = 1;

            // Add a string for the required Rating column
            _ratingColumnStringId = AddString(xlast, "RatingColumn_NAME", "Rating");

            // Arcade titles are the only ones that require a leaderboard
            if (xlast.GameConfigProject.titleType == (uint)XLASTTitleType.ArcadeTitle)
            {
                AddStatsViews(xlast, 1);
            }
        }

        private StatsView FindStatsView(XboxLiveSubmissionProject xlast, uint viewId)
        {
            foreach (StatsView view in xlast.GameConfigProject.StatsViews.StatsViewCollection)
            {
                if (view.id == viewId)
                    return view;
            }
            return null;
        }

        private ushort GetNextAttributeId(ViewFieldTypeCollection fields)
        {
            ushort attributeId = 0;
            foreach (ViewFieldType field in fields)
            {
                if ((short)field.attributeId > 0)
                    attributeId = field.attributeId;
            }
            return ++attributeId;
        }

        private ContextCollection FindAvailableContexts(XboxLiveSubmissionProject xlast)
        {
            ContextCollection contexts = new ContextCollection();

            // Walk the list of Contexts to find ones available to be leaderboard columns
            foreach (Context ctx in xlast.GameConfigProject.Contexts.ContextCollection)
            {
                uint id = UInt32.Parse(ctx.id.Substring(2), System.Globalization.NumberStyles.HexNumber);
                if ((id & 0x0000F000) == 0)
                {
                    contexts.Add(ctx);
                }
            }

            return contexts;
        }

        private PropertyCollection FindAvailableProperties(XboxLiveSubmissionProject xlast)
        {
            PropertyCollection properties = new PropertyCollection();

            // Walk the list of properties to find ones available to be leaderboard columns
            foreach (Property property in xlast.GameConfigProject.Properties.PropertyCollection)
            {
                uint id = UInt32.Parse(property.id.Substring(2), System.Globalization.NumberStyles.HexNumber);
                XLASTPropertyType type = (XLASTPropertyType)(id >> 28);
                id = id & 0x0000FFFF;
                if (id < 0x8000 && type != XLASTPropertyType.Float && type != XLASTPropertyType.DateTime)
                {
                    properties.Add(property);
                }
            }

            return properties;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\XLASTFactory.cs ===
using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text;
using ServerTestFramework.Utilities;
using ServerTestFramework.STFTools.ConfigFiles;

namespace ServerTestFramework.STFTools
{
    public enum XLASTTitleType
    {
        SystemTitle = 0,
        FullGame,
        DemoTitle,
        ArcadeTitle
    }

    public enum XLASTLanguage
    {
        English = 0,
        French,
        German,
        Italian,
        Japanese,
        Korean,
        Polish,
        Portuguese,
        Russian,
        Spanish,
        TraditionalChinese
    }

    public partial class XLASTFactory
    {
        public static XLASTSchemaVersion SchemaVersion00 = new XLASTSchemaVersion(1, 0);
        public static XLASTSchemaVersion SchemaVersion01 = new XLASTSchemaVersion(1, 1);
        public static XLASTSchemaVersion SchemaVersion02 = new XLASTSchemaVersion(1, 2);
        public static XLASTSchemaVersion SchemaVersion03 = new XLASTSchemaVersion(1, 3);
        
        // These are the CLSIDs used in XLAST files
        private static string GameConfigProjectCLSID = "{77E1A64F-5837-489B-AF8E-E4BA0FDACE7D}";
        private static string LocalizedStringsCLSID = "{BB833025-27FE-4BBD-87B6-DECD32039CED}";
        private static string LocalizedStringCLSID = "{F88D7D87-B2C0-452D-977D-297D70400AFF}";
        private static string PresenceCLSID = "{4EDB88EF-4341-49E4-B0AC-80CEA33F8EB8}";
        private static string PresenceModeCLSID = "{B94DA191-595F-40BB-99F1-3A78DAD90D9F}";
        private static string PropertiesCLSID = "{84CF9B0C-8512-4E46-B20F-D26A55A7AC6E}";
        private static string PropertyCLSID = "{43CE4FA7-6DE9-4F37-A929-49BFE63CBAAA}";
        private static string ContextsCLSID = "{7F6BA3D8-BB76-46CC-AD28-A4E0C8D6E1EF}";
        private static string ContextCLSID = "{7F343825-DBB8-4BC0-ACF2-533263622341}";
        private static string GameModesCLSID = "{A4C90625-725A-4DD2-B26B-E7F33F9DA808}";
        private static string ImagesCLSID = "{5B5F14C2-99F6-409A-BE85-15137524035C}";
        private static string GamerPicturesCLSID = "{3A23EFFB-83E1-415E-A7F2-1BD3004F83F5}";
        private static string AchievementsCLSID = "{42B49E61-A989-4D38-A1E3-74859D420C15}";
        private static string AchievementCLSID = "{3B0C2ED0-B7E7-4129-B35D-A90639E96DAC}";
        private static string StatsViewsCLSID = "{7FD2B836-2D93-490B-96C9-AEE936158AE8}";
        private static string StatsViewCLSID = "{6B341F2D-7A8A-43BC-AABF-949D6B9F28C7}";
        private static string MatchmakingCLSID = "{9D99E88A-2774-422A-8558-9B7487A37732}";
        private static string ConstantsCLSID = "{9DEE98C4-441C-4103-861B-464DF03B36B1}";
        private static string SchemaCLSID = "{7134D48F-9957-4515-850B-A7426E51345F}";
        private static string QueriesCLSID = "{50783AEA-2512-4F78-938B-F8DB911A0F9A}";
        private static string QueryCLSID = "{7FEE4CB1-F3F0-48BF-9CA1-F1B2306E32E3}";

        private RandomEx _rnd = new RandomEx();

        public XLASTFactory()
        {
            InitLocalizedStrings();
        }

        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            return xlast;
        }
        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema, XLASTTitleType titleType)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            xlast.GameConfigProject.titleType = (uint)titleType;
            return xlast;
        }
        public XboxLiveSubmissionProject Create(XLASTSchemaVersion schema, XLASTTitleType titleType,
            uint titleId, string titleName, XLASTLanguage defaultLanguage)
        {
            XboxLiveSubmissionProject xlast = new XboxLiveSubmissionProject();
            xlast.Version = "2.00.0000.0";
            xlast.GameConfigProject.clsid = GameConfigProjectCLSID;
            xlast.GameConfigProject.schemaVersion = schema.ToString();
            xlast.GameConfigProject.projectVersion = "1.00.0000.0";
            xlast.GameConfigProject.titleType = (uint)titleType;
            xlast.GameConfigProject.titleName = titleName;
            xlast.GameConfigProject.titleId = "0x" + titleId.ToString("X8");

            CreateLocalizedStrings(xlast, defaultLanguage); // This one must come first
            CreateImages(xlast);
            CreateProductInformation(xlast);
            CreatePresence(xlast);
            CreateProperties(xlast);
            CreateContexts(xlast);
            CreateGameModes(xlast);
            CreateAchievements(xlast);
            CreateGamerPictures(xlast);
            CreateMatchmaking(xlast);
            if (titleType == XLASTTitleType.ArcadeTitle)
            {
                CreateStatsViews(xlast);
            }

            return xlast;
        }

        public void UpdateVersion(XboxLiveSubmissionProject xlast)
        {
            if (xlast == null)
                throw new ArgumentNullException("xlast");

            string[] ver = xlast.GameConfigProject.projectVersion.Split('.');
            xlast.GameConfigProject.projectVersion = string.Format("{0}.{1}.{2:d4}.{3}", ver[0], ver[1], (ushort.Parse(ver[2]) + 1), ver[3]);
        }

        /// <summary>
        /// Static method to deserialize an XLAST file into a hierarchy of objects.
        /// </summary>
        /// <param name="xlastFile">The name of the XLAST file to deserialize.</param>
        /// <returns>An XboxLiveSubmissionProject object that describes the XLAST file.</returns>
        //public static XboxLiveSubmissionProject FromXml(string xlastFile)
        //{
        //    if (xlastFile == null)
        //    {
        //        throw new ArgumentNullException("xlastFile");
        //    }

        //    if (!File.Exists(xlastFile))
        //    {
        //        return null;
        //    }

        //    StreamReader reader = null;
        //    XboxLiveSubmissionProject xlast = null;
        //    try
        //    {
        //        reader = new StreamReader(xlastFile);
        //        xlast = FromXml(reader);
        //    }
        //    finally
        //    {
        //        if (reader != null)
        //        {
        //            reader.Close();
        //        }
        //    }

        //    return xlast;
        //}

        /// <summary>
        /// Static method to deserialize an XLAST XML stream into a hierarchy of objects.
        /// </summary>
        /// <param name="xlastXml">A TextReader object that contains the raw XML of an XLAST file.</param>
        /// <returns>An XboxLiveSubmissionProject object that describes the XLAST XML data.</returns>
        //public static XboxLiveSubmissionProject FromXml(TextReader xlastXml)
        //{
        //    if (xlastXml == null)
        //    {
        //        return null;
        //    }

        //    XmlTextReader xmlReader = null;
        //    XmlSerializer serializer = null;
        //    XboxLiveSubmissionProject xlast = null;
        //    try
        //    {
        //        xmlReader = new XmlTextReader(xlastXml);
        //        serializer = new XmlSerializer(typeof(XboxLiveSubmissionProject));
        //        xlast = (serializer.Deserialize(xmlReader) as XboxLiveSubmissionProject);
        //    }
        //    finally
        //    {
        //        if (xmlReader != null)
        //        {
        //            xmlReader.Close();
        //        }
        //    }

        //    return xlast;
        //}

        //public static void ToXml(XboxLiveSubmissionProject xlast, string xlastFile)
        //{
        //    if (xlastFile == null)
        //    {
        //        throw new ArgumentNullException("xlastFile");
        //    }
        //    if (xlast == null)
        //    {
        //        throw new ArgumentNullException("xlast");
        //    }

        //    /*
        //     * We need to go through the pain of creating an XmlDocument from
        //     * the serialized XML stream so that when we can duplicate the
        //     * format of the XLAST file when it's saved from XLAST.
        //     */
        //    StringWriter sw = new StringWriter();
        //    XmlDocument doc = new XmlDocument();
        //    XmlTextWriter xtw = new XmlTextWriter(xlastFile, System.Text.Encoding.Unicode);
        //    xtw.Formatting = Formatting.Indented;
        //    xtw.Indentation = 1;
        //    xtw.IndentChar = (char)0x9;
        //    try
        //    {
        //        XmlSerializer serializer = new XmlSerializer(typeof(XboxLiveSubmissionProject));
        //        serializer.Serialize(sw, xlast);
        //        doc.LoadXml(sw.ToString());
        //        doc.Save(xtw);
        //    }
        //    finally
        //    {
        //        xtw.Close();
        //        sw.Close();
        //    }
        //}
    }

    public sealed class XLASTSchemaVersion
    {
        private byte _major;
        private byte _minor;

        public XLASTSchemaVersion(byte major, byte minor)
        {
            _major = major;
            _minor = minor;
        }

        public byte Major
        {
            get { return _major; }
        }

        public byte Minor
        {
            get { return _minor; }
        }

        public override string ToString()
        {
 	         return string.Format("{0}.{1:00}.0000.0", _major, _minor);
        }

        public override bool Equals(object obj)
        {
            if (obj is XLASTSchemaVersion)
            {
                return ((obj as XLASTSchemaVersion)._major == _major &&
                        (obj as XLASTSchemaVersion)._minor == _minor);
            }
            return false;
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SigRetriever\SigRetriever.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Signature;
using System.Net;
using System.IO;

namespace SigRetriever
{
    /// <summary>
    /// Summary description for Form1.
    /// </summary>
    public class SigRetriever : System.Windows.Forms.Form
    {
        private System.Windows.Forms.Button Exit;
        private System.Windows.Forms.Button btnGenerate;
        private System.Windows.Forms.TextBox txtDigest;
        private System.Windows.Forms.TextBox txtSignature;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox txtServer;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.TextBox txtPort;
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.Container components = null;

        public SigRetriever()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose( bool disposing )
        {
            if( disposing )
            {
                if (components != null) 
                {
                    components.Dispose();
                }
            }
            base.Dispose( disposing );
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.Exit = new System.Windows.Forms.Button();
            this.btnGenerate = new System.Windows.Forms.Button();
            this.txtDigest = new System.Windows.Forms.TextBox();
            this.txtSignature = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.txtServer = new System.Windows.Forms.TextBox();
            this.label4 = new System.Windows.Forms.Label();
            this.txtPort = new System.Windows.Forms.TextBox();
            this.SuspendLayout();
            // 
            // Exit
            // 
            this.Exit.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.Exit.Location = new System.Drawing.Point(71, 120);
            this.Exit.Name = "Exit";
            this.Exit.TabIndex = 1;
            this.Exit.Text = "Exit";
            this.Exit.Click += new System.EventHandler(this.Exit_Click);
            // 
            // btnGenerate
            // 
            this.btnGenerate.Location = new System.Drawing.Point(159, 120);
            this.btnGenerate.Name = "btnGenerate";
            this.btnGenerate.TabIndex = 2;
            this.btnGenerate.Text = "Generate";
            this.btnGenerate.Click += new System.EventHandler(this.btnGenerate_Click);
            // 
            // txtDigest
            // 
            this.txtDigest.Location = new System.Drawing.Point(80, 56);
            this.txtDigest.Name = "txtDigest";
            this.txtDigest.ReadOnly = true;
            this.txtDigest.Size = new System.Drawing.Size(208, 20);
            this.txtDigest.TabIndex = 3;
            this.txtDigest.Text = "";
            // 
            // txtSignature
            // 
            this.txtSignature.Location = new System.Drawing.Point(80, 88);
            this.txtSignature.Name = "txtSignature";
            this.txtSignature.ReadOnly = true;
            this.txtSignature.Size = new System.Drawing.Size(208, 20);
            this.txtSignature.TabIndex = 4;
            this.txtSignature.Text = "";
            // 
            // label1
            // 
            this.label1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(40, 56);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(39, 16);
            this.label1.TabIndex = 5;
            this.label1.Text = "Digest:";
            this.label1.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label2
            // 
            this.label2.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(24, 88);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(56, 16);
            this.label2.TabIndex = 6;
            this.label2.Text = "Signature:";
            this.label2.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // label3
            // 
            this.label3.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(8, 24);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(71, 16);
            this.label3.TabIndex = 8;
            this.label3.Text = "Environment:";
            this.label3.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // txtServer
            // 
            this.txtServer.Location = new System.Drawing.Point(80, 24);
            this.txtServer.Name = "txtServer";
            this.txtServer.Size = new System.Drawing.Size(120, 20);
            this.txtServer.TabIndex = 9;
            this.txtServer.Text = "10.10.2.180";
            // 
            // label4
            // 
            this.label4.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(216, 24);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(28, 16);
            this.label4.TabIndex = 10;
            this.label4.Text = "Port:";
            this.label4.TextAlign = System.Drawing.ContentAlignment.TopRight;
            // 
            // txtPort
            // 
            this.txtPort.Location = new System.Drawing.Point(248, 24);
            this.txtPort.Name = "txtPort";
            this.txtPort.Size = new System.Drawing.Size(40, 20);
            this.txtPort.TabIndex = 11;
            this.txtPort.Text = "8080";
            // 
            // SigRetriever
            // 
            this.AcceptButton = this.btnGenerate;
            this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
            this.CancelButton = this.Exit;
            this.ClientSize = new System.Drawing.Size(304, 149);
            this.Controls.Add(this.txtPort);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.txtServer);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.txtSignature);
            this.Controls.Add(this.txtDigest);
            this.Controls.Add(this.btnGenerate);
            this.Controls.Add(this.Exit);
            this.MaximizeBox = false;
            this.Name = "SigRetriever";
            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;
            this.Text = "Signature Retrieval Tool";
            this.Load += new System.EventHandler(this.SigRetriever_Load);
            this.ResumeLayout(false);

        }
        #endregion

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main() 
        {
            Application.Run(new SigRetriever());
        }

        public static string ByteArrayToHexString(byte[] arr)
        {
            if(arr == null)
                return null;
            string res = "";
            foreach(byte b in arr)
                res += b.ToString("X2");
            return res;
        }

        private void btnGenerate_Click(object sender, System.EventArgs e)
        {
            System.Random r = new Random();
            byte[] data = new byte[20];
            r.NextBytes(data);
                
            SigningRequest req = null;

            IPAddress hostIPAddress1 = null;
            int port = 80;
            try
            {
                hostIPAddress1 = (Dns.GetHostEntry(txtServer.Text)).AddressList[0];
            }
            catch(System.Exception f)
            {
                MessageBox.Show(f.Message + "\n" + f.StackTrace);
                return;
            }
            try
            {
                port = Convert.ToInt32(txtPort.Text, 10);
            }
            catch(System.Exception f)
            {
                MessageBox.Show(f.Message + "\n" + f.StackTrace);
                return;
            }

            try
            {
                string loc = hostIPAddress1.ToString() + ":" + port.ToString();
                Global.Env.XSIGServerT2 = new LiveServer(txtServer.Text, loc, new string[] {loc}, new string[] {loc}, new string[] {loc});
                req = new SigningRequest((uint)XOService.Signature, data);
                XRLSignOnBehalf sob = new XRLSignOnBehalf();
                SignOnBehalfResult[] res = sob.Execute(req);
                if(res != null)
                {
                    txtDigest.Text = ByteArrayToHexString(req.digest);
                    if(res[0].HResult != 0)
                    {
                        MessageBox.Show("Done! The request failed with HResult: " + res[0].HResult.ToString("X8"));
                        return;
                    }
                    else
                    {
                        System.IO.MemoryStream memStream = new System.IO.MemoryStream(100);
                        res[0].Signature.WriteStream(memStream);
                        txtSignature.Text = ByteArrayToHexString(memStream.ToArray());
                        return;
                    }
                }
                else
                {
                    MessageBox.Show("Done! No results returned from " + loc + ".\nHttpStatus: " + sob.httpStatus.ToString());
                    return;
                }
            }
            catch(System.Exception f)
            {
                MessageBox.Show(f.Message + "\n" + f.StackTrace);
                return;
            }
        }

        private void SigRetriever_Load(object sender, System.EventArgs e)
        {
        
        }

        private void Exit_Click(object sender, System.EventArgs e)
        {
            this.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ConfigFiles\XscConfig.cs ===
using System;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{
    public struct XscDeclarations
    {
        public const string SchemaVersion = "http://www.xboxlive.com";
    }

    [Serializable]
    public enum ContainerType
    {
        [XmlEnum("individual")] Individual,
        [XmlEnum("units")] Units,
        [XmlEnum("competitions")] Competitions
    }

    [XmlType(IncludeInSchema=false)]
    public enum ContainerClassChoices
    {
        Leaderboard,
        LeaderboardTemplate
    }

    /// <summary>
    /// Root class for the Xbox1 Leaderboard Configuration (XSC) file hierarchy.
    /// </summary>
    [XmlRoot(ElementName="Title",Namespace=XscDeclarations.SchemaVersion,IsNullable=false),Serializable]
    public class XboxLeaderboardConfiguration
    {
        [XmlAttribute(AttributeName="TitleID",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _titleId;

        /// <summary>
        /// The value ot the TitleID attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string TitleId
        {
            get { return _titleId; }
            set { _titleId = value; }
        }

        [XmlAttribute(AttributeName="UnitLeaderboardDecayConstant", DataType="int")]
        public int _unitLeaderboardDecayConstant;

        /// <summary>
        /// The value of the UnitLeaderboardDecayConstant attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public int UnitLeaderboardDecayConstant
        {
            get { return _unitLeaderboardDecayConstant; }
            set { _unitLeaderboardDecayConstant = value; }
        }

        [XmlAttribute(AttributeName="Version",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _version;

        /// <summary>
        /// The value of the Version attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string Version
        {
            get { return _version; }
            set { _version = value; }
        }

        [XmlAttribute(AttributeName="Default_Locale",DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _defaultLocale;

        /// <summary>
        /// The value of the Default_Locale attribute of the Title element
        /// </summary>
        [XmlIgnore]
        public string DefaultLocale
        {
            get { return _defaultLocale; }
            set { _defaultLocale = value; }
        }

        [XmlElement(Type=typeof(XscLeaderboardContainer),ElementName="LeaderboardContainer",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLeaderboardContainerCollection _leaderboardContainers;

        /// <summary>
        /// Collection of XscLeaderboardContainer objects that represent the three possible types of leaderboards in the file
        /// </summary>
        [XmlIgnore]
        public XscLeaderboardContainerCollection LeaderboardContainers
        {
            get
            {
                if (_leaderboardContainers == null) _leaderboardContainers = new XscLeaderboardContainerCollection();
                return _leaderboardContainers;
            }
            set { _leaderboardContainers = value; }
        }

        public XboxLeaderboardConfiguration()
        {
        }

        /// <summary>
        /// Static method to deserialize an XSC file into a class hierarchy
        /// </summary>
        /// <param name="xscFile">Full path and filename of the XSC file to deserialize</param>
        /// <returns>Returns an XboxLeaderboardConfiguration object defining the XSC file</returns>
        /// <example>
        /// XboxLeaderboardConfiguration xsc = XboxLeaderboardConfiguration.FromXml("FFFFAB08.XSC");
        /// </example>
        public static XboxLeaderboardConfiguration FromXml(string xscFile)
        {
            if (xscFile == null)
            {
                throw new ArgumentNullException("xscFile");
            }
            
            if (!File.Exists(xscFile))
            {
                return null;
            }

            StreamReader reader = null;
            XboxLeaderboardConfiguration xsc = null;
            try
            {
                reader = new StreamReader(xscFile);
                xsc = FromXml(reader);
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return xsc;
        }

        /// <summary>
        /// Static method to deserialize raw XSC xml into a class hierarchy
        /// </summary>
        /// <param name="xscXml">A TextReader-derived object that contains the XSC XML to deserialize</param>
        /// <returns>Returns an XboxLeaderboardConfiguration object defining the XSC XML</returns>
        /// <example>
        /// StreamReader reader = new StreamReader("FFFFAB08.XSC");
        /// XboxLeaderboardConfiguration xsc = XboxLeaderboardConfiguration.FromXml(reader);
        /// </example>
        public static XboxLeaderboardConfiguration FromXml(TextReader xscXml)
        {
            if (xscXml == null)
            {
                return null;
            }

            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            XboxLeaderboardConfiguration xsc = null;
            try
            {
                xmlReader = new XmlTextReader(xscXml);
                serializer = new XmlSerializer(typeof(XboxLeaderboardConfiguration));
                xsc = (serializer.Deserialize(xmlReader) as XboxLeaderboardConfiguration);
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return xsc;
        }

        /// <summary>
        /// Serializes Xbox1 leaderboard configuration data into an XSC file
        /// </summary>
        /// <param name="xscFile">Full path and filename to which the XML data should be serialized</param>
        public void ToXml(string xscFile)
        {
            if (xscFile == null)
            {
                throw new ArgumentNullException("xscFile");
            }

            StreamWriter stream = new StreamWriter(xscFile);
            StringWriter sw = new StringWriter();
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(XboxLeaderboardConfiguration));
                serializer.Serialize(sw, this);
                stream.WriteLine(sw);
            }
            finally
            {
                stream.Close();
                sw.Close();
            }
        }
    }

    /// <summary>
    /// A collection of Leaderboard Containers in an XSC file.
    /// </summary>
    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLeaderboardContainerCollection : ArrayList
    {
        /// <summary>
        /// Adds an existing XscLeaderboardContainer object to the collection
        /// </summary>
        /// <param name="obj">An existing XscLeaderboardContainer object</param>
        /// <returns>The added object</returns>
        public XscLeaderboardContainer Add(XscLeaderboardContainer obj)
        {
            base.Add(obj);
            return obj;
        }

        /// <summary>
        /// Creates a new XscLeaderboardContainer object and adds it to the collection
        /// </summary>
        /// <returns>The newly created object</returns>
        public XscLeaderboardContainer Add()
        {
            return Add(new XscLeaderboardContainer());
        }

        /// <summary>
        /// Inserts an existing XscLeaderboardContainer object into the collection
        /// </summary>
        /// <param name="index">0-based index at which the XscLeaderboardContainer object should be inserted</param>
        /// <param name="obj">The XscLeaderboardContainer object to insert</param>
        public void Insert(int index, XscLeaderboardContainer obj)
        {
            base.Insert(index, obj);
        }

        /// <summary>
        /// Removes the first occurance of the specified XscLeaderboardContainer object from the collection
        /// </summary>
        /// <param name="obj">The XscLeaderboardContainer object to remove</param>
        public void Remove(XscLeaderboardContainer obj)
        {
            base.Remove(obj);
        }

        new public XscLeaderboardContainer this[int index]
        {
            get { return base[index] as XscLeaderboardContainer; }
            set { base[index] = value; }
        }
    }

    [XmlType(TypeName="LeaderboardContainer",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLeaderboardContainer
    {
        [XmlAttribute(AttributeName="type")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ContainerType _type;

        [XmlIgnore]
        public ContainerType Type
        {
            get { return _type; }
            set { _type = value; }
        }

        [XmlIgnore]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ContainerClassChoices [] _ContainerClassTypes;

        [XmlElement(Type=typeof(XscLeaderboard),ElementName="Leaderboard",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [XmlElement(Type=typeof(XscLeaderboard),ElementName="LeaderboardTemplate",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [XmlChoiceIdentifier("_ContainerClassTypes")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLeaderboard [] _leaderboards;

        [XmlIgnore]
        public XscLeaderboard [] Leaderboards
        {
            get { return _leaderboards; }
            set { _leaderboards = value; }
        }

        public XscLeaderboardContainer()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLeaderboardCollection : ArrayList
    {
        public XscLeaderboard Add(XscLeaderboard obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscLeaderboard Add()
        {
            return Add(new XscLeaderboard());
        }

        public void Insert(int index, XscLeaderboard obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscLeaderboard obj)
        {
            base.Remove(obj);
        }

        new public XscLeaderboard this[int index]
        {
            get { return base[index] as XscLeaderboard; }
            set { base[index] = value; }
        }
    }

    [XmlType(TypeName="Leaderboard",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLeaderboard
    {
        [XmlAttribute(AttributeName="ID",DataType="unsignedShort")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _id;

        [XmlIgnore]
        public ushort Id
        {
            get { return _id; }
            set { _id = value; }
        }

        [XmlElement("Reset", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _reset;

        [XmlIgnore]
        public ushort Reset
        {
            get { return _reset; }
            set { _reset = value; }
        }

        [XmlElement("TopOneHundred", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _topOneHundred;

        [XmlIgnore]
        public bool TopOneHundred
        {
            get { return _topOneHundred; }
            set { _topOneHundred = value; }
        }

        [XmlElement("DecayDays", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _decayDays;

        [XmlIgnore]
        public ushort DecayDays
        {
            get { return _decayDays; }
            set { _decayDays = value; }
        }

        [XmlElement("TeamsLeaderboard", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _teamsLeaderboard;

        [XmlIgnore]
        public bool TeamsLeaderboard
        {
            get { return _teamsLeaderboard; }
            set { _teamsLeaderboard = value; }
        }

        [XmlElement("Arbitrate", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _arbitrated;

        [XmlIgnore]
        public bool Arbitrated
        {
            get { return _arbitrated; }
            set { _arbitrated = value; }
        }

        [XmlElement(ElementName="Attachments", Type=typeof(XscAttachments), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscAttachments _attachments;

        [XmlIgnore]
        public XscAttachments Attachments
        {
            get { return _attachments; }
            set { _attachments = value; }
        }

        [XmlElement(ElementName="ELO", Type=typeof(XscElo), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscElo _elo;

        [XmlIgnore]
        public XscElo Elo
        {
            get { return _elo; }
            set { _elo = value; }
        }

        [XmlElement(ElementName="Names", Type=typeof(XscNames), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscNames _names;

        [XmlIgnore]
        public XscNames Names
        {
            get { return _names; }
            set { _names = value; }
        }

        [XmlElement(ElementName="FormattedValues", Type=typeof(XscFormattedValues), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscFormattedValues _formattedValues;

        [XmlIgnore]
        public XscFormattedValues FormattedValues
        {
            get { return _formattedValues; }
            set { _formattedValues = value; }
        }

        [XmlElement(ElementName="RawAttributes", Type=typeof(XscRawAttributes), IsNullable=false, Form=XmlSchemaForm.Qualified, Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscRawAttributes _rawAttributes;

        [XmlIgnore]
        public XscRawAttributes RawAttributes
        {
            get { return _rawAttributes; }
            set { _rawAttributes = value; }
        }

        public XscLeaderboard()
        {
        }
    }

    [XmlType(TypeName="Attachments",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscAttachments
    {
        [XmlElement("Uploads", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _uploads;

        [XmlIgnore]
        public ushort Uploads
        {
            get { return _uploads; }
            set { _uploads = value; }
        }

        [XmlElement("Size", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _size;

        [XmlIgnore]
        public ushort Size
        {
            get { return _size; }
            set { _size = value; }
        }

        public XscAttachments()
        {
        }
    }

    [XmlType(TypeName="ELO",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscElo
    {
        [XmlElement("InitialPlayerRating", typeof(uint))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public uint _initialPlayerRating;

        [XmlIgnore]
        public uint InitialPlayerRating
        {
            get { return _initialPlayerRating; }
            set { _initialPlayerRating = value; }
        }

        [XmlElement("RatingScaleFactor", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _ratingScaleFactor;

        [XmlIgnore]
        public ushort RatingScaleFactor
        {
            get { return _ratingScaleFactor; }
            set { _ratingScaleFactor = value; }
        }

        [XmlElement("ExponentialBase", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _exponentialBase;

        [XmlIgnore]
        public string ExponentialBase
        {
            get { return _exponentialBase; }
            set { _exponentialBase = value; }
        }

        [XmlElement("MaxWeightRatingRangeArray", typeof(XscMaxWeightRatingRangeArray))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscMaxWeightRatingRangeArray _maxWeightRatingRangeArray;

        [XmlIgnore]
        public XscMaxWeightRatingRangeArray MaxWeightRatingRangeArray
        {
            get { return _maxWeightRatingRangeArray; }
            set { _maxWeightRatingRangeArray = value; }
        }

        public XscElo()
        {
        }
    }

    [XmlType(TypeName="MaxWeightRatingRangeArray",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscMaxWeightRatingRangeArray
    {
        [XmlElement(ElementName="MaxWeightRatingRange",Type=typeof(XscMaxWeightRatingRange),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscMaxWeightRatingRangeCollection _maxWeightRatingRanges;

        [XmlIgnore]
        public XscMaxWeightRatingRangeCollection MaxWeightRatingRanges
        {
            get { return _maxWeightRatingRanges; }
            set { _maxWeightRatingRanges = value; }
        }

        public XscMaxWeightRatingRangeArray()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscMaxWeightRatingRangeCollection : ArrayList
    {
        public XscMaxWeightRatingRange Add(XscMaxWeightRatingRange obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscMaxWeightRatingRange Add()
        {
            return Add(new XscMaxWeightRatingRange());
        }

        public void Insert(int index, XscMaxWeightRatingRange obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscMaxWeightRatingRange obj)
        {
            base.Remove(obj);
        }

        new public XscMaxWeightRatingRange this[int index]
        {
            get { return base[index] as XscMaxWeightRatingRange; }
            set { base[index] = value; }
        }

        public XscMaxWeightRatingRangeCollection()
        {
        }
    }

    [XmlType(TypeName="MaxWeightRatingRange",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscMaxWeightRatingRange
    {
        [XmlAttribute(AttributeName="start", DataType="unsignedInt")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public uint _start;

        [XmlIgnore]
        public uint Start
        {
            get { return _start; }
            set { _start = value; }
        }

        [XmlAttribute(AttributeName="maxweight", DataType="unsignedShort")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _maxWeight;

        [XmlIgnore]
        public ushort MaxWeight
        {
            get { return _maxWeight; }
            set { _maxWeight = value; }
        }

        public XscMaxWeightRatingRange()
        {
        }
    }

    [XmlType(TypeName="Names",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscNames
    {
        [XmlElement(ElementName="LocalizedName",Type=typeof(XscLocalizedName),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscLocalizedNameCollection _localizedNames;

        [XmlIgnore]
        public XscLocalizedNameCollection LocalizedNames
        {
            get
            {
                if (_localizedNames == null) _localizedNames = new XscLocalizedNameCollection();
                return _localizedNames;
            }
            set { _localizedNames = value; }
        }

        public XscNames()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscLocalizedNameCollection : ArrayList
    {
        public XscLocalizedName Add(XscLocalizedName obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscLocalizedName Add()
        {
            return Add(new XscLocalizedName());
        }

        public void Insert(int index, XscLocalizedName obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscLocalizedName obj)
        {
            base.Remove(obj);
        }

        new public XscLocalizedName this[int index]
        {
            get { return base[index] as XscLocalizedName; }
            set { base[index] = value; }
        }

        public XscLocalizedNameCollection()
        {
        }
    }

    [XmlType(TypeName="LocalizedName",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscLocalizedName
    {
        [XmlElement("Name", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _name;

        [XmlIgnore]
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        [XmlElement("Locale", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _locale;

        [XmlIgnore]
        public string Locale
        {
            get { return _locale; }
            set { _locale = value; }
        }

        public XscLocalizedName()
        {
        }
    }

    [XmlType(TypeName="FormattedValues",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormattedValues
    {
        [XmlElement(ElementName="FormattedValue",Type=typeof(XscFormattedValue),IsNullable=true,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscFormattedValueCollection _formattedValues;

        [XmlIgnore]
        public XscFormattedValueCollection FormattedValues
        {
            get { return _formattedValues; }
            set { _formattedValues = value; }
        }

        public XscFormattedValues()
        {
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscFormattedValueCollection : ArrayList
    {
        public XscFormattedValue Add(XscFormattedValue obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscFormattedValue Add()
        {
            return Add(new XscFormattedValue());
        }

        public void Insert(int index, XscFormattedValue obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscFormattedValue obj)
        {
            base.Remove(obj);
        }

        new public XscFormattedValue this[int index]
        {
            get { return base[index] as XscFormattedValue; }
            set { base[index] = value; }
        }

        public XscFormattedValueCollection()
        {
        }
    }

    [XmlType(TypeName="FormattedValue",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormattedValue
    {
        [XmlElement(ElementName="Names",Type=typeof(XscNames),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscNames _names;

        [XmlIgnore]
        public XscNames Names
        {
            get
            {
                if (_names == null) _names = new XscNames();
                return _names;
            }
            set { _names = value; }
        }

        [XmlElement("NameID",typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _nameId;

        [XmlIgnore]
        public ushort NameId
        {
            get { return _nameId; }
            set { _nameId = value; }
        }

        [XmlElement("Type",typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _type;

        [XmlIgnore]
        public string Type
        {
            get { return _type; }
            set { _type = value; }
        }

        [XmlElement("FriendlyAdminName",typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _friendlyAdminName;

        [XmlIgnore]
        public string FriendlyAdminName
        {
            get { return _friendlyAdminName; }
            set { _friendlyAdminName = value; }
        }

        [XmlElement("Formula", typeof(string))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public string _formula;

        [XmlIgnore]
        public string Formula
        {
            get { return _formula.Trim(); }
            set { _formula = value; }
        }

        public XscFormattedValue()
        {
        }
    }

    [XmlType(TypeName="Formula",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscFormula
    {
        [XmlElement("!", typeof(string))]
        public string _cdata;

        [XmlIgnore]
        public string CData
        {
            get { return _cdata; }
            set { _cdata = value; }
        }

        public XscFormula()
        {
        }
    }

    [XmlType(TypeName="RawAttributes",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscRawAttributes
    {
        [XmlElement(ElementName="Attribute",Type=typeof(XscAttribute),IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=XscDeclarations.SchemaVersion)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public XscRawAttributeCollection _rawAttributes;

        [XmlIgnore]
        public XscRawAttributeCollection RawAttributes
        {
            get
            {
                if (_rawAttributes == null) _rawAttributes = new XscRawAttributeCollection();
                return _rawAttributes;
            }
            set { _rawAttributes = value; }
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public class XscRawAttributeCollection : ArrayList
    {
        public XscAttribute Add(XscAttribute obj)
        {
            base.Add(obj);
            return obj;
        }

        public XscAttribute Add()
        {
            return Add(new XscAttribute());
        }

        public void Insert(int index, XscAttribute obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(XscAttribute obj)
        {
            base.Remove(obj);
        }

        new public XscAttribute this[int index]
        {
            get { return base[index] as XscAttribute; }
            set { base[index] = value; }
        }

        public XscRawAttributeCollection()
        {
        }
    }

    [XmlType(TypeName="Attribute",Namespace=XscDeclarations.SchemaVersion),Serializable]
    public class XscAttribute
    {
        [XmlElement("PUID", typeof(Boolean))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool _puid;

        [XmlIgnore]
        public bool Puid
        {
            get { return _puid; }
            set { _puid = value; }
        }

        [XmlElement("Index", typeof(ushort))]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public ushort _index;

        [XmlIgnore]
        public ushort Index
        {
            get { return _index; }
            set { _index = value; }
        }

        public XscAttribute()
        {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\XLASTFactory\LocalizedStrings.cs ===
u s i n g   S y s t e m ; 
 
 u s i n g   S y s t e m . C o l l e c t i o n s . G e n e r i c ; 
 
 u s i n g   S y s t e m . I O ; 
 
 u s i n g   S y s t e m . X m l ; 
 
 u s i n g   S y s t e m . X m l . S e r i a l i z a t i o n ; 
 
 u s i n g   S y s t e m . T e x t ; 
 
 u s i n g   S e r v e r T e s t F r a m e w o r k . S T F T o o l s . C o n f i g F i l e s ; 
 
 
 
 n a m e s p a c e   S e r v e r T e s t F r a m e w o r k . S T F T o o l s 
 
 { 
 
         p u b l i c   e n u m   X L A S T D e f a u l t S t r i n g   :   u s h o r t 
 
         { 
 
                 X _ S T R I N G I D _ G A M E T Y P E   =   3 2 5 1 2 , 
 
                 X _ S T R I N G I D _ R A N K E D , 
 
                 X _ S T R I N G I D _ S T A N D A R D , 
 
                 X _ S T R I N G I D _ G A M E R N A M E , 
 
                 X _ S T R I N G I D _ R A N K C O L , 
 
                 X _ S T R I N G I D _ R A N K , 
 
                 X _ S T R I N G I D _ G A M E R N A M E C O L , 
 
                 X _ S T R I N G I D _ G A M E R _ Z O N E , 
 
                 X _ S T R I N G I D _ G A M E R _ C O U N T R Y , 
 
                 X _ S T R I N G I D _ L A N G U A G E , 
 
                 X _ S T R I N G I D _ G A M E R _ R A T I N G , 
 
                 X _ S T R I N G I D _ G A M E R _ M U , 
 
                 X _ S T R I N G I D _ G A M E R _ S I G M A , 
 
                 X _ S T R I N G I D _ G A M E R _ P U I D , 
 
                 X _ S T R I N G I D _ A F F I L I A T E _ V A L U E , 
 
                 X _ S T R I N G I D _ G A M E R _ H O S T N A M E , 
 
                 X _ S T R I N G I D _ P L A T F O R M _ T Y P E , 
 
                 X _ S T R I N G I D _ P L A T F O R M _ L O C K , 
 
                 X _ S T R I N G I D _ T I T L E N A M E   =   3 2 7 6 8 
 
         } 
 
 
 
         p u b l i c   p a r t i a l   c l a s s   X L A S T F a c t o r y 
 
         { 
 
                 p r i v a t e   D i c t i o n a r y < u s h o r t ,   L i s t < s t r i n g > >   _ d e f a u l t S t r i n g s ; 
 
                 p r i v a t e   X L A S T L a n g u a g e   _ d e f a u l t L a n g u a g e ; 
 
                 p r i v a t e   s t a t i c   s t r i n g [ ]   L o c a l e S t r i n g s   =   n e w   s t r i n g [ ] 
 
                         {   " e n - U S " ,   " f r - F R " ,   " d e - D E " ,   " i t - I T " ,   " j a - J P " ,   " k o - K R " ,   " p l - P L " ,   " p t - P T " ,   " r u - R U " ,   " e s - E S " ,   " z h - C H T "   } ; 
 
 
 
                 p r i v a t e   v o i d   I n i t L o c a l i z e d S t r i n g s ( ) 
 
                 { 
 
                         _ d e f a u l t S t r i n g s   =   n e w   D i c t i o n a r y < u s h o r t ,   L i s t < s t r i n g > > ( ) ; 
 
                         L i s t < s t r i n g >   t r a n s l a t i o n s ; 
 
 
 
                         / /   G a m e   T y p e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e   T y p e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T y p e   d e   j e u " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l t y p " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d i   g i o c o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000n0.z^" ) ; 
 
                         t r a n s l a t i o n s . A d d ( "   X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T y p   g r y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d e   J o g o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " "8?  83@K" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " T i p o   d e   p a r t i d a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " J2b^W" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E T Y P E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k e d 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k e d   M a t c h " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i e   a v e c   C l a s s e m e n t " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g l i s t e n - S p i e l " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i t a   C l a s s i f i c a t a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000  000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( "   X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P o j e d y n e k   r a n k i n g o w y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   p o r   R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " >41>@  ?>  C@>2=N" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   I g u a l a d a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}M
\" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K E D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   S t a n d a r d 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a y e r   M a t c h " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " M i s e   e n   R e l a t i o n " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " M i t s p i e l e r - S u c h e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i t a   d e l   G i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 00000  000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " t  X" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P o j e d y n e k   g r a c z y " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   p o r   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " >41>@  83@>:>2" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P a r t i d a   d e   J u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[M
\" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ S T A N D A R D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   N a m e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   N a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m   d u   j o u e u r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l e r n a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   g i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 0000
T" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " t8  t" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N a z w a   g r a c z a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   d o   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " <O  83@>:0" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m b r e   d e l   j u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[Y
T" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R N A M E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   N a m e   C o l 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   N a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m   d u   j o u e u r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " S p i e l e r n a m e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   g i o c a t o r e " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 0000
T" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " t8  t" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N a z w a   g r a c z a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m e   d o   J o g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " <O  83@>:0" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " N o m b r e   d e l   j u g a d o r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " s[Y
T" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R N A M E C O L ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " E i n s t u f u n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a   o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 5AB>" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s i f i c a r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   R a n k   C o l 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " E i n s t u f u n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 000" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " R a n k i n g " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s s i f i c a   o " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " 5AB>" ) ; 
 
                         t r a n s l a t i o n s . A d d ( " C l a s i f i c a r " ) ; 
 
                         t r a n s l a t i o n s . A d d ( " I{}" ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ R A N K C O L ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   Z o n e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   Z o n e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ Z O N E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   C o u n t r y 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   C o u n t r y " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ C O U N T R Y ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   L a n g u a g e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " L a n g u a g e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ L A N G U A G E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   R a t i n g 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   R a t i n g " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ R A T I N G ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   M u 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   M u " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ M U ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   S i g m a 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   S i g m a " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ S I G M A ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   P U I D 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   P U I D " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ P U I D ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   A f f i l i a t e   V a l u e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " A f f i l i a t e   V a l u e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ A F F I L I A T E _ V A L U E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   G a m e r   H o s t   N a m e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " G a m e r   H o s t   N a m e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ G A M E R _ H O S T N A M E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   P l a t f o r m   T y p e 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a t f o r m   T y p e " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ P L A T F O R M _ T Y P E ,   t r a n s l a t i o n s ) ; 
 
 
 
                         / /   P l a t f o r m   L o c k 
 
                         t r a n s l a t i o n s   =   n e w   L i s t < s t r i n g > ( ) ; 
 
                         t r a n s l a t i o n s . A d d ( " P l a t f o r m   L o c k " ) ; 
 
                         _ d e f a u l t S t r i n g s . A d d ( ( u s h o r t ) X L A S T D e f a u l t S t r i n g . X _ S T R I N G I D _ P L A T F O R M _ L O C K ,   t r a n s l a t i o n s ) ; 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   C r e a t e L o c a l i z e d S t r i n g s ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T L a n g u a g e   d e f a u l t L a n g u a g e ) 
 
                 { 
 
                         i f   ( x l a s t   ! =   n u l l ) 
 
                         { 
 
                                 _ d e f a u l t L a n g u a g e   =   d e f a u l t L a n g u a g e ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s   =   n e w   L o c a l i z e d S t r i n g s ( ) ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . c l s i d   =   L o c a l i z e d S t r i n g s C L S I D ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . d e f a u l t L o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) d e f a u l t L a n g u a g e ] ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . A d d ( ) . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) d e f a u l t L a n g u a g e ] ; 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d   =   1 ; 
 
 
 
                                 u s h o r t [ ]   d e f I d s   =   ( u s h o r t [ ] ) E n u m . G e t V a l u e s ( t y p e o f ( X L A S T D e f a u l t S t r i n g ) ) ; 
 
                                 f o r e a c h   ( u s h o r t   i d   i n   d e f I d s ) 
 
                                 { 
 
                                         A d d D e f a u l t S t r i n g ( x l a s t ,   ( X L A S T D e f a u l t S t r i n g ) i d ,   d e f a u l t L a n g u a g e ) ; 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p u b l i c   v o i d   A d d L a n g u a g e ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         S u p p o r t e d L o c a l e   l o c a l e   =   n u l l ; 
 
 
 
                         i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n   = =   n u l l ) 
 
                         { 
 
                                 x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n   =   n e w   S u p p o r t e d L o c a l e C o l l e c t i o n ( ) ; 
 
                         } 
 
                         e l s e 
 
                         { 
 
                                 f o r   ( i n t   i   =   0 ;   i   <   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . C o u n t ;   i + + ) 
 
                                 { 
 
                                         i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n [ i ] . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 l o c a l e   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n [ i ] ; 
 
                                                 b r e a k ; 
 
                                         } 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c a l e   = =   n u l l ) 
 
                         { 
 
                                 l o c a l e   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n . A d d ( ) ; 
 
                                 l o c a l e . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ; 
 
 
 
                                 / /   G o   t h r o u g h   e a c h   s t r i n g   a n d   a d d   t h e   d e f a u l t   v a l u e   f o r   t h i s   n e w   l a n g u a g e 
 
                                 f o r e a c h   ( L o c a l i z e d S t r i n g   l o c S t r i n g   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n ) 
 
                                 { 
 
                                         A d d T r a n s l a t i o n ( l o c S t r i n g ,   l a n g ,   G e t D e f a u l t S t r i n g V a l u e ( l o c S t r i n g . i d ,   l a n g ) ) ; 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p u b l i c   u s h o r t   A d d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   s t r i n g   i n i t i a l V a l u e ) 
 
                 { 
 
                         r e t u r n   A d d S t r i n g ( x l a s t ,   " S t r i n g "   +   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d . T o S t r i n g ( " d 3 " ) ,   i n i t i a l V a l u e ) ; 
 
                 } 
 
 
 
                 p u b l i c   u s h o r t   A d d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   s t r i n g   f r i e n d l y N a m e ,   s t r i n g   i n i t i a l V a l u e ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         L o c a l i z e d S t r i n g   n e w S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . A d d ( ) ; 
 
                         n e w S t r i n g . c l s i d   =   L o c a l i z e d S t r i n g C L S I D ; 
 
                         n e w S t r i n g . i d   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d ; 
 
                         n e w S t r i n g . f r i e n d l y N a m e   =   f r i e n d l y N a m e ; 
 
 
 
                         f o r e a c h   ( S u p p o r t e d L o c a l e   l o c a l e   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . S u p p o r t e d L o c a l e C o l l e c t i o n ) 
 
                         { 
 
                                 A d d T r a n s l a t i o n ( n e w S t r i n g ,   l o c a l e . l o c a l e ,   i n i t i a l V a l u e ) ; 
 
                         } 
 
 
 
                         x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . n e x t I d + + ; 
 
                         r e t u r n   n e w S t r i n g . i d ; 
 
                 } 
 
 
 
                 p u b l i c   v o i d   M o d i f y S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   u s h o r t   s t r i n g I d ,   X L A S T L a n g u a g e   l a n g ,   s t r i n g   n e w V a l u e ) 
 
                 { 
 
                         i f   ( x l a s t   = =   n u l l ) 
 
                                 t h r o w   n e w   A r g u m e n t N u l l E x c e p t i o n ( " x l a s t " ) ; 
 
 
 
                         / /   F i n d   t h e   s t r i n g   i n   q u e s t i o n 
 
                         L o c a l i z e d S t r i n g   l o c S t r i n g   =   F i n d L o c a l i z e d S t r i n g ( x l a s t ,   s t r i n g I d ) ; 
 
                         i f   ( l o c S t r i n g   ! =   n u l l ) 
 
                         { 
 
                                 / /   U p d a t e   t h e   g i v e n   t r a n s l a t i o n   o f   t h i s   s t r i n g 
 
                                 f o r e a c h   ( T r a n s l a t i o n   t r a n s   i n   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n ) 
 
                                 { 
 
                                         i f   ( t r a n s . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 t r a n s . V a l u e   =   n e w V a l u e ; 
 
                                         } 
 
                                 } 
 
                         } 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d D e f a u l t S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   X L A S T D e f a u l t S t r i n g   d e f S t r i n g ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         L o c a l i z e d S t r i n g   l o c S t r i n g   =   n u l l ; 
 
 
 
                         / /   I f   t h e   s t r i n g   d o e s n ' t   y e t   e x i s t   i n   t h e   X L A S T   f i l e ,   c r e a t e   i t 
 
                         f o r   ( i n t   i   =   0 ;   i   <   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . C o u n t ;   i + + ) 
 
                         { 
 
                                 i f   ( x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n [ i ] . i d   = =   ( u s h o r t ) d e f S t r i n g ) 
 
                                 { 
 
                                         l o c S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n [ i ] ; 
 
                                         b r e a k ; 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c S t r i n g   = =   n u l l ) 
 
                         { 
 
                                 l o c S t r i n g   =   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n . A d d ( ) ; 
 
                                 l o c S t r i n g . c l s i d   =   L o c a l i z e d S t r i n g C L S I D ; 
 
                                 l o c S t r i n g . i d   =   ( u s h o r t ) d e f S t r i n g ; 
 
                                 l o c S t r i n g . f r i e n d l y N a m e   =   E n u m . G e t N a m e ( t y p e o f ( X L A S T D e f a u l t S t r i n g ) ,   d e f S t r i n g ) ; 
 
                         } 
 
 
 
                         / /   A d d   t h e   s p e c i f i e d   l a n g u a g e   t o   t h e   l i s t   o f   t r a n s l a t i o n s 
 
                         T r a n s l a t i o n   l o c T r a n s   =   n u l l ; 
 
                         i f   ( l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n   = =   n u l l ) 
 
                         { 
 
                                 l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n   =   n e w   T r a n s l a t i o n C o l l e c t i o n ( ) ; 
 
                         } 
 
                         e l s e 
 
                         { 
 
                                 f o r   ( i n t   i   =   0 ;   i   <   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . C o u n t ;   i + + ) 
 
                                 { 
 
                                         i f   ( l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n [ i ] . l o c a l e   = =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ) 
 
                                         { 
 
                                                 l o c T r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n [ i ] ; 
 
                                                 b r e a k ; 
 
                                         } 
 
                                 } 
 
                         } 
 
 
 
                         i f   ( l o c T r a n s   = =   n u l l ) 
 
                         { 
 
                                 l o c T r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . A d d ( ) ;   
 
                                 l o c T r a n s . l o c a l e   =   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ; 
 
                                 l o c T r a n s . V a l u e   =   G e t D e f a u l t S t r i n g V a l u e ( ( u s h o r t ) d e f S t r i n g ,   l a n g ) ; 
 
                         } 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d T r a n s l a t i o n ( L o c a l i z e d S t r i n g   l o c S t r i n g ,   X L A S T L a n g u a g e   l a n g ,   s t r i n g   v a l u e ) 
 
                 { 
 
                         A d d T r a n s l a t i o n ( l o c S t r i n g ,   L o c a l e S t r i n g s [ ( i n t ) l a n g ] ,   v a l u e ) ; 
 
                 } 
 
 
 
                 p r i v a t e   v o i d   A d d T r a n s l a t i o n ( L o c a l i z e d S t r i n g   l o c S t r i n g ,   s t r i n g   l o c a l e ,   s t r i n g   v a l u e ) 
 
                 { 
 
                         T r a n s l a t i o n   t r a n s   =   l o c S t r i n g . T r a n s l a t i o n C o l l e c t i o n . A d d ( ) ; 
 
                         t r a n s . l o c a l e   =   l o c a l e ; 
 
                         i f   ( v a l u e   ! =   n u l l ) 
 
                                 t r a n s . V a l u e   =   v a l u e ; 
 
                         e l s e 
 
                                 t r a n s . V a l u e   =   l o c a l e   +   "   s t r i n g . " ; 
 
                 } 
 
 
 
                 p r i v a t e   s t r i n g   G e t D e f a u l t S t r i n g V a l u e ( u s h o r t   s t r i n g I d ,   X L A S T L a n g u a g e   l a n g ) 
 
                 { 
 
                         i f   ( _ d e f a u l t S t r i n g s . C o n t a i n s K e y ( s t r i n g I d ) ) 
 
                         { 
 
                                 L i s t < s t r i n g >   t r a n s l a t i o n s   =   _ d e f a u l t S t r i n g s [ s t r i n g I d ] ; 
 
                                 i f   ( t r a n s l a t i o n s . C o u n t   >   1 ) 
 
                                 { 
 
                                         r e t u r n   t r a n s l a t i o n s [ ( i n t ) l a n g ] ; 
 
                                 } 
 
                                 e l s e 
 
                                 { 
 
                                         r e t u r n   t r a n s l a t i o n s [ 0 ] ; 
 
                                 } 
 
                         } 
 
 
 
                         r e t u r n   L o c a l e S t r i n g s [ ( i n t ) l a n g ]   +   "   s t r i n g . " ; 
 
                 } 
 
 
 
                 p r i v a t e   L o c a l i z e d S t r i n g   F i n d L o c a l i z e d S t r i n g ( X b o x L i v e S u b m i s s i o n P r o j e c t   x l a s t ,   u s h o r t   s t r i n g I d ) 
 
                 { 
 
                         f o r e a c h   ( L o c a l i z e d S t r i n g   s t r   i n   x l a s t . G a m e C o n f i g P r o j e c t . L o c a l i z e d S t r i n g s . L o c a l i z e d S t r i n g C o l l e c t i o n ) 
 
                         { 
 
                                 i f   ( s t r . i d   = =   s t r i n g I d ) 
 
                                         r e t u r n   s t r ; 
 
                         } 
 
                         r e t u r n   n u l l ; 
 
                 } 
 
         } 
 
 } 
 
 
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPAC\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPAC\SPACOverrides.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;

namespace SPACTest
{
	/// <summary>
	/// Summary description for SPACOverrides.
	/// </summary>
	[XmlType()]
    [XmlRoot(ElementName="TitleConfigs"), Serializable]
	public class SPACOverrides
	{
        private TitleConfigs _titleConfigs;

        [XmlElement(ElementName="TitleConfig", Type=typeof(SPACTitleConfig))]
        public TitleConfigs TitleConfigs
        {
            get { return _titleConfigs; }
            set { _titleConfigs = value; }
        }

        public static SPACOverrides FromXml(string overrideFile)
        {
            if (overrideFile == null)
            {
                throw new ArgumentNullException("overrideFile");
            }
            
            if (!File.Exists(overrideFile))
            {
                return null;
            }

            XmlTextReader xmlReader = null;
            XmlSerializer serializer = null;
            SPACOverrides overrides = null;
            try
            {
                xmlReader = new XmlTextReader(overrideFile);
                serializer = new XmlSerializer(typeof(SPACOverrides));
                overrides = serializer.Deserialize(xmlReader) as SPACOverrides;
            }
            finally
            {
                if (xmlReader != null)
                {
                    xmlReader.Close();
                }
            }

            return overrides;
        }

        public void ToXml(string overrideFile)
        {
            if (overrideFile == null)
            {
                throw new ArgumentNullException("overrideFile");
            }

            StreamWriter stream = new StreamWriter(overrideFile);
            StringWriter sw = new StringWriter();
            try
            {
                XmlSerializer serializer = new XmlSerializer(typeof(SPACOverrides));
                serializer.Serialize(sw, this);
                stream.WriteLine(sw);
            }
            finally
            {
                stream.Close();
                sw.Close();
            }
        }

		public SPACOverrides()
		{
            _titleConfigs = new TitleConfigs();
		}
	}

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Always)]
    public class TitleConfigs : ArrayList
    {
        public SPACTitleConfig Add(SPACTitleConfig obj)
        {
            base.Add(obj);
            return obj;
        }

        public SPACTitleConfig Add()
        {
            return Add(new SPACTitleConfig());
        }

        public void Insert(int index, SPACTitleConfig obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(SPACTitleConfig obj)
        {
            base.Remove(obj);
        }

        new public SPACTitleConfig this[int index]
        {
            get { return base[index] as SPACTitleConfig; }
            set { base[index] = value; }
        }
    }

    [XmlType(TypeName="TitleConfig"), Serializable]
    public class SPACTitleConfig
    {
        private ushort _titleType;
        private OverrideSettings _settings;

        [XmlAttribute(AttributeName="titleType", DataType="unsignedShort")]
        [EditorBrowsable(EditorBrowsableState.Always)]
        public ushort TitleType
        {
            get { return _titleType; }
            set { _titleType = value; }
        }

        [XmlElement(ElementName="Setting", Type=typeof(OverrideSetting))]
        [EditorBrowsable(EditorBrowsableState.Always)]
        public OverrideSettings Settings
        {
            get { return _settings; }
            set { _settings = value; }
        }

        public SPACTitleConfig()
        {
            _settings = new OverrideSettings();
        }

        public SPACTitleConfig(ushort titleType) : this ()
        {
            _titleType = titleType;
        }
    }

    [Serializable]
    [EditorBrowsable(EditorBrowsableState.Always)]
    public class OverrideSettings : ArrayList
    {
        public OverrideSetting Add(OverrideSetting obj)
        {
            base.Add(obj);
            return obj;
        }

        public OverrideSetting Add()
        {
            return Add(new OverrideSetting());
        }

        public void Insert(int index, OverrideSetting obj)
        {
            base.Insert(index, obj);
        }

        public void Remove(OverrideSetting obj)
        {
            base.Remove(obj);
        }

        new public OverrideSetting this[int index]
        {
            get { return base[index] as OverrideSetting; }
            set { base[index] = value; }
        }
    }

    [XmlType(TypeName="Setting"), Serializable]
    public class OverrideSetting
    {
        private string _name;
        private string _value;

        [XmlAttribute(AttributeName="name", DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Always)]
        public string Name
        {
            get { return _name; }
            set { _name = value; }
        }

        [XmlAttribute(AttributeName="value", DataType="string")]
        [EditorBrowsable(EditorBrowsableState.Always)]
        public string Value
        {
            get { return _value; }
            set { _value = value; }
        }

        public OverrideSetting()
        {
        }

        public OverrideSetting(string settingName, string settingValue)
        {
            _name = settingName;
            _value = settingValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPAC\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_spactest_none_12.4.56.0_none_a2e8a1bfa5d24a56
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=spactest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674.manifest
XP_MANIFEST_PATH=manifests\msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674.cat
XP_CATALOG_PATH=manifests\msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674.cat
XP_PAYLOAD_PATH=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=spactest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPAC\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_spactest_none_12.4.56.0_none_a2e8a1bfa5d24a56
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=spactest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674.manifest
XP_MANIFEST_PATH=manifests\msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674.cat
XP_CATALOG_PATH=manifests\msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674.cat
XP_PAYLOAD_PATH=msil_spactest_no-public-key_12.4.56.0_x-ww_3282e674
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=spactest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPAC\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPAC\SPACTests.cs ===
using System;
using ServerTestFramework;

namespace SPACTest
{
    /*public enum TestResult
    {
        NotExecuted = TEST_RESULTS.NOT_EXECUTED,
        Passed = TEST_RESULTS.PASSED,
        Failed = TEST_RESULTS.FAILED,
        Composite = TEST_RESULTS.COMPOSITE,
        VerificationFailure
    }/*

    /// <summary>
    /// Summary description for SPACTests.
    /// </summary>
    public class SPACTests : TestSuite
    {
      /*  public override InitializerInfo GetRequiredResources()
        {
            InitializerInfo ii = new InitializerInfo();
            ii.UseFakeSG = false;
            ii.UseUodb = true;
            return ii;
        }
    }*/
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFLiveTools\ConfigFiles\XlastConfigV03.cs ===
// Copyright 2004, Microsoft Corporation
// Sample Code - Use restricted to terms of use defined in the accompanying license agreement (EULA.doc)

//--------------------------------------------------------------
// Autogenerated by XSDObjectGen version 1.4.2.1
// Schema file: gi.03.xsd
// Creation Date: 6/19/2007 12:58:07
//--------------------------------------------------------------

using System;
using System.Xml.Serialization;
using System.Collections;
using System.Xml.Schema;
using System.ComponentModel;

namespace ServerTestFramework.STFTools.ConfigFiles
{

	public struct Declarations
	{
		public const string SchemaVersion = "http://www.xboxlive.com/xlast";
	}

	[Serializable]
	public enum type23
	{
		[XmlEnum(Name="Ascending")] Ascending,
		[XmlEnum(Name="Descending")] Descending,
		[XmlEnum(Name="Near")] Near,
		[XmlEnum(Name="Far")] Far
	}

	[Serializable]
	public enum resetType
	{
		[XmlEnum(Name="Weekly")] Weekly,
		[XmlEnum(Name="Biweekly")] Biweekly,
		[XmlEnum(Name="Monthly")] Monthly,
		[XmlEnum(Name="Bimonthly")] Bimonthly,
		[XmlEnum(Name="Annually")] Annually,
		[XmlEnum(Name="Never")] Never
	}

	[Serializable]
	public enum MatchFilterItemType
	{
		[XmlEnum(Name="Attribute")] Attribute,
		[XmlEnum(Name="Parameter")] Parameter,
		[XmlEnum(Name="Constant")] Constant,
		[XmlEnum(Name="ContextValue")] ContextValue
	}

    [Serializable]
    public enum type
    {
        [XmlEnum(Name = "Min")] Min,
        [XmlEnum(Name = "Max")] Max,
        [XmlEnum(Name = "Sum")] Sum,
        [XmlEnum(Name = "Last")] Last
    }

	[Serializable]
	public enum type234
	{
		[XmlEnum(Name="Normal")] Normal,
		[XmlEnum(Name="Average")] Average,
		[XmlEnum(Name="Sum")] Sum,
		[XmlEnum(Name="Minimum")] Minimum,
		[XmlEnum(Name="Maximum")] Maximum,
		[XmlEnum(Name="Count")] Count
	}

	[Serializable]
	public enum achievementType
	{
		[XmlEnum(Name="Completion")] Completion,
		[XmlEnum(Name="Leveling")] Leveling,
		[XmlEnum(Name="Unlock")] Unlock,
		[XmlEnum(Name="Event")] @Event,
		[XmlEnum(Name="Tournament")] Tournament,
		[XmlEnum(Name="Checkpoint")] Checkpoint,
		[XmlEnum(Name="Other")] Other
	}

	[Serializable]
	public enum type2
	{
		[XmlEnum(Name="Normal")] Normal,
		[XmlEnum(Name="Findfromid")] Findfromid,
		[XmlEnum(Name="Aggregate")] Aggregate
	}

	[Serializable]
	public enum ArcadeLeaderboardSortType
	{
		[XmlEnum(Name="Ascending")] Ascending,
		[XmlEnum(Name="Descending")] Descending
	}


	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class FeatureCollection : ArrayList
	{
		public Feature Add(Feature obj)
		{
			base.Add(obj);
			return obj;
		}

		public Feature Add()
		{
			return Add(new Feature());
		}

		public void Insert(int index, Feature obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Feature obj)
		{
			base.Remove(obj);
		}

		new public Feature this[int index]
		{
			get { return (Feature) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PlatformCollection : ArrayList
	{
		public Platform Add(Platform obj)
		{
			base.Add(obj);
			return obj;
		}

		public Platform Add()
		{
			return Add(new Platform());
		}

		public void Insert(int index, Platform obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Platform obj)
		{
			base.Remove(obj);
		}

		new public Platform this[int index]
		{
			get { return (Platform) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ConstantCollection : ArrayList
	{
		public Constant Add(Constant obj)
		{
			base.Add(obj);
			return obj;
		}

		public Constant Add()
		{
			return Add(new Constant());
		}

		public void Insert(int index, Constant obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Constant obj)
		{
			base.Remove(obj);
		}

		new public Constant this[int index]
		{
			get { return (Constant) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PictureCollection : ArrayList
	{
		public Picture Add(Picture obj)
		{
			base.Add(obj);
			return obj;
		}

		public Picture Add()
		{
			return Add(new Picture());
		}

		public void Insert(int index, Picture obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Picture obj)
		{
			base.Remove(obj);
		}

		new public Picture this[int index]
		{
			get { return (Picture) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ReturnCollection : ArrayList
	{
		public @Return Add(@Return obj)
		{
			base.Add(obj);
			return obj;
		}

		public @Return Add()
		{
			return Add(new @Return());
		}

		public void Insert(int index, @Return obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(@Return obj)
		{
			base.Remove(obj);
		}

		new public @Return this[int index]
		{
			get { return (@Return) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ParameterCollection : ArrayList
	{
		public Parameter Add(Parameter obj)
		{
			base.Add(obj);
			return obj;
		}

		public Parameter Add()
		{
			return Add(new Parameter());
		}

		public void Insert(int index, Parameter obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Parameter obj)
		{
			base.Remove(obj);
		}

		new public Parameter this[int index]
		{
			get { return (Parameter) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class TranslationCollection : ArrayList
	{
		public Translation Add(Translation obj)
		{
			base.Add(obj);
			return obj;
		}

		public Translation Add()
		{
			return Add(new Translation());
		}

		public void Insert(int index, Translation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Translation obj)
		{
			base.Remove(obj);
		}

		new public Translation this[int index]
		{
			get { return (Translation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GameModeCollection : ArrayList
	{
		public GameMode Add(GameMode obj)
		{
			base.Add(obj);
			return obj;
		}

		public GameMode Add()
		{
			return Add(new GameMode());
		}

		public void Insert(int index, GameMode obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(GameMode obj)
		{
			base.Remove(obj);
		}

		new public GameMode this[int index]
		{
			get { return (GameMode) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class AttributeCollection : ArrayList
	{
		public Attribute Add(Attribute obj)
		{
			base.Add(obj);
			return obj;
		}

		public Attribute Add()
		{
			return Add(new Attribute());
		}

		public void Insert(int index, Attribute obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Attribute obj)
		{
			base.Remove(obj);
		}

		new public Attribute this[int index]
		{
			get { return (Attribute) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class RatingCollection : ArrayList
	{
		public Rating Add(Rating obj)
		{
			base.Add(obj);
			return obj;
		}

		public Rating Add()
		{
			return Add(new Rating());
		}

		public void Insert(int index, Rating obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Rating obj)
		{
			base.Remove(obj);
		}

		new public Rating this[int index]
		{
			get { return (Rating) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class FilterCollection : ArrayList
	{
		public Filter Add(Filter obj)
		{
			base.Add(obj);
			return obj;
		}

		public Filter Add()
		{
			return Add(new Filter());
		}

		public void Insert(int index, Filter obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Filter obj)
		{
			base.Remove(obj);
		}

		new public Filter this[int index]
		{
			get { return (Filter) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SortOperationCollection : ArrayList
	{
		public SortOperation Add(SortOperation obj)
		{
			base.Add(obj);
			return obj;
		}

		public SortOperation Add()
		{
			return Add(new SortOperation());
		}

		public void Insert(int index, SortOperation obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(SortOperation obj)
		{
			base.Remove(obj);
		}

		new public SortOperation this[int index]
		{
			get { return (SortOperation) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PresenceModeCollection : ArrayList
	{
		public PresenceMode Add(PresenceMode obj)
		{
			base.Add(obj);
			return obj;
		}

		public PresenceMode Add()
		{
			return Add(new PresenceMode());
		}

		public void Insert(int index, PresenceMode obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(PresenceMode obj)
		{
			base.Remove(obj);
		}

		new public PresenceMode this[int index]
		{
			get { return (PresenceMode) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class LocalizedStringCollection : ArrayList
	{
		public LocalizedString Add(LocalizedString obj)
		{
			base.Add(obj);
			return obj;
		}

		public LocalizedString Add()
		{
			return Add(new LocalizedString());
		}

		public void Insert(int index, LocalizedString obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(LocalizedString obj)
		{
			base.Remove(obj);
		}

		new public LocalizedString this[int index]
		{
			get { return (LocalizedString) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextValueCollection : ArrayList
	{
		public ContextValue Add(ContextValue obj)
		{
			base.Add(obj);
			return obj;
		}

		public ContextValue Add()
		{
			return Add(new ContextValue());
		}

		public void Insert(int index, ContextValue obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(ContextValue obj)
		{
			base.Remove(obj);
		}

		new public ContextValue this[int index]
		{
			get { return (ContextValue) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewFieldTypeCollection : ArrayList
	{
		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Add(obj);
			return obj;
		}

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add()
		{
			return Add(new ServerTestFramework.STFTools.ConfigFiles.ViewFieldType());
		}

		public void Insert(int index, ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			base.Remove(obj);
		}

		new public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType this[int index]
		{
			get { return (ServerTestFramework.STFTools.ConfigFiles.ViewFieldType) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class AchievementCollection : ArrayList
	{
		public Achievement Add(Achievement obj)
		{
			base.Add(obj);
			return obj;
		}

		public Achievement Add()
		{
			return Add(new Achievement());
		}

		public void Insert(int index, Achievement obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Achievement obj)
		{
			base.Remove(obj);
		}

		new public Achievement this[int index]
		{
			get { return (Achievement) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PropertyCollection : ArrayList
	{
		public Property Add(Property obj)
		{
			base.Add(obj);
			return obj;
		}

		public Property Add()
		{
			return Add(new Property());
		}

		public void Insert(int index, Property obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Property obj)
		{
			base.Remove(obj);
		}

		new public Property this[int index]
		{
			get { return (Property) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class SupportedLocaleCollection : ArrayList
	{
		public SupportedLocale Add(SupportedLocale obj)
		{
			base.Add(obj);
			return obj;
		}

		public SupportedLocale Add()
		{
			return Add(new SupportedLocale());
		}

		public void Insert(int index, SupportedLocale obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(SupportedLocale obj)
		{
			base.Remove(obj);
		}

		new public SupportedLocale this[int index]
		{
			get { return (SupportedLocale) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class StatsViewCollection : ArrayList
	{
		public StatsView Add(StatsView obj)
		{
			base.Add(obj);
			return obj;
		}

		public StatsView Add()
		{
			return Add(new StatsView());
		}

		public void Insert(int index, StatsView obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(StatsView obj)
		{
			base.Remove(obj);
		}

		new public StatsView this[int index]
		{
			get { return (StatsView) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class QueryCollection : ArrayList
	{
		public Query Add(Query obj)
		{
			base.Add(obj);
			return obj;
		}

		public Query Add()
		{
			return Add(new Query());
		}

		public void Insert(int index, Query obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Query obj)
		{
			base.Remove(obj);
		}

		new public Query this[int index]
		{
			get { return (Query) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class GenreCollection : ArrayList
	{
		public Genre Add(Genre obj)
		{
			base.Add(obj);
			return obj;
		}

		public Genre Add()
		{
			return Add(new Genre());
		}

		public void Insert(int index, Genre obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Genre obj)
		{
			base.Remove(obj);
		}

		new public Genre this[int index]
		{
			get { return (Genre) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ImageCollection : ArrayList
	{
		public Image Add(Image obj)
		{
			base.Add(obj);
			return obj;
		}

		public Image Add()
		{
			return Add(new Image());
		}

		public void Insert(int index, Image obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Image obj)
		{
			base.Remove(obj);
		}

		new public Image this[int index]
		{
			get { return (Image) base[index]; }
			set { base[index] = value; }
		}
	}

	[Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextCollection : ArrayList
	{
		public Context Add(Context obj)
		{
			base.Add(obj);
			return obj;
		}

		public Context Add()
		{
			return Add(new Context());
		}

		public void Insert(int index, Context obj)
		{
			base.Insert(index, obj);
		}

		public void Remove(Context obj)
		{
			base.Remove(obj);
		}

		new public Context this[int index]
		{
			get { return (Context) base[index]; }
			set { base[index] = value; }
		}
	}



	[XmlType(TypeName="ViewAxisType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewAxisType
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return FieldCollection.GetEnumerator();
		}

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Add(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj)
		{
			return FieldCollection.Add(obj);
		}

		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType this[int index]
		{
			get { return (ServerTestFramework.STFTools.ConfigFiles.ViewFieldType) FieldCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return FieldCollection.Count; }
        }

        public void Clear()
		{
            FieldCollection.Clear();
        }

		public ServerTestFramework.STFTools.ConfigFiles.ViewFieldType Remove(int index) 
		{ 
            ServerTestFramework.STFTools.ConfigFiles.ViewFieldType obj = FieldCollection[index];
            FieldCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            FieldCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ViewFieldType),ElementName="Field",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ViewFieldTypeCollection __FieldCollection;
		
		[XmlIgnore]
		public ViewFieldTypeCollection FieldCollection
		{
			get
			{
				if (__FieldCollection == null) __FieldCollection = new ViewFieldTypeCollection();
				return __FieldCollection;
			}
			set {__FieldCollection = value;}
		}

		public ViewAxisType()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (FieldCollection.Count == 0)
			{
				ViewFieldType _c = FieldCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (ViewFieldType _c in FieldCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="PropertyFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class PropertyFieldType
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlElement(Type=typeof(Aggregation),ElementName="Aggregation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Aggregation __Aggregation;
		
		[XmlIgnore]
		public Aggregation Aggregation
		{
			get
			{
				if (__Aggregation == null) __Aggregation = new Aggregation();		
				return __Aggregation;
			}
			set {__Aggregation = value;}
		}

		public PropertyFieldType()
		{
		}

		public void MakeSchemaCompliant()
		{
			Aggregation.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Aggregation",Namespace=Declarations.SchemaVersion),Serializable]
	public class Aggregation
	{

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		public Aggregation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="NonValidatedElement",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class NonValidatedElement
	{

		[XmlAnyElement()]
		public System.Xml.XmlElement[] Any;

		public NonValidatedElement()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ContextFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ContextFieldType
	{

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public ContextFieldType()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ViewFieldType",Namespace=Declarations.SchemaVersion),Serializable]
	[EditorBrowsable(EditorBrowsableState.Advanced)]
	public class ViewFieldType
	{

		[XmlAttribute(AttributeName="attributeId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __attributeId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __attributeIdSpecified;
		
		[XmlIgnore]
		public ushort attributeId
		{ 
			get { return __attributeId; }
			set { __attributeId = value; __attributeIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="hidden",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hidden;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hiddenSpecified;
		
		[XmlIgnore]
		public bool hidden
		{ 
			get { return __hidden; }
			set { __hidden = value; __hiddenSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeLeaderboard",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeLeaderboard;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeLeaderboardSpecified;
		
		[XmlIgnore]
		public bool arcadeLeaderboard
		{ 
			get { return __arcadeLeaderboard; }
			set { __arcadeLeaderboard = value; __arcadeLeaderboardSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeSort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType __arcadeSort;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeSortSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType arcadeSort
		{ 
			get { return __arcadeSort; }
			set { __arcadeSort = value; __arcadeSortSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __arcadeStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeStringIdSpecified;
		
		[XmlIgnore]
		public ushort arcadeStringId
		{ 
			get { return __arcadeStringId; }
			set { __arcadeStringId = value; __arcadeStringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ContextFieldType),ElementName="Context",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ContextFieldType __Context;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ContextFieldType Context
		{
			get
			{
				if (__Context == null) __Context = new ServerTestFramework.STFTools.ConfigFiles.ContextFieldType();		
				return __Context;
			}
			set {__Context = value;}
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType),ElementName="Property",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType __Property;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType Property
		{
			get
			{
				if (__Property == null) __Property = new ServerTestFramework.STFTools.ConfigFiles.PropertyFieldType();		
				return __Property;
			}
			set {__Property = value;}
		}

		public ViewFieldType()
		{
			arcadeLeaderboard = false;
			arcadeSort = ServerTestFramework.STFTools.ConfigFiles.ArcadeLeaderboardSortType.Ascending;
		}

		public void MakeSchemaCompliant()
		{
			Context.MakeSchemaCompliant();
			Property.MakeSchemaCompliant();
		}
	}


	[XmlRoot(ElementName="XboxLiveSubmissionProject",Namespace=Declarations.SchemaVersion,IsNullable=false),Serializable]
	public class XboxLiveSubmissionProject
	{

		[XmlAttribute(AttributeName="Version",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Version;
		
		[XmlIgnore]
		public string Version
		{ 
			get { return __Version; }
			set { __Version = value; }
		}

		[XmlElement(Type=typeof(GameConfigProject),ElementName="GameConfigProject",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameConfigProject __GameConfigProject;
		
		[XmlIgnore]
		public GameConfigProject GameConfigProject
		{
			get
			{
				if (__GameConfigProject == null) __GameConfigProject = new GameConfigProject();		
				return __GameConfigProject;
			}
			set {__GameConfigProject = value;}
		}

		public XboxLiveSubmissionProject()
		{
		}

		public void MakeSchemaCompliant()
		{
			GameConfigProject.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="GameConfigProject",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameConfigProject
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="titleId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleId;
		
		[XmlIgnore]
		public string titleId
		{ 
			get { return __titleId; }
			set { __titleId = value; }
		}

		[XmlAttribute(AttributeName="titleName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __titleName;
		
		[XmlIgnore]
		public string titleName
		{ 
			get { return __titleName; }
			set { __titleName = value; }
		}

		[XmlAttribute(AttributeName="titleType",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __titleType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleTypeSpecified;
		
		[XmlIgnore]
		public uint titleType
		{ 
			get { return __titleType; }
			set { __titleType = value; __titleTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="multiplayer",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __multiplayer;
		
		[XmlIgnore]
		public string multiplayer
		{ 
			get { return __multiplayer; }
			set { __multiplayer = value; }
		}

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="projectVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __projectVersion;
		
		[XmlIgnore]
		public string projectVersion
		{ 
			get { return __projectVersion; }
			set { __projectVersion = value; }
		}

		[XmlAttribute(AttributeName="schemaVersion",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __schemaVersion;
		
		[XmlIgnore]
		public string schemaVersion
		{ 
			get { return __schemaVersion; }
			set { __schemaVersion = value; }
		}

		[XmlElement(Type=typeof(LocalizedStrings),ElementName="LocalizedStrings",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStrings __LocalizedStrings;
		
		[XmlIgnore]
		public LocalizedStrings LocalizedStrings
		{
			get
			{
				if (__LocalizedStrings == null) __LocalizedStrings = new LocalizedStrings();		
				return __LocalizedStrings;
			}
			set {__LocalizedStrings = value;}
		}

		[XmlElement(Type=typeof(GameModes),ElementName="GameModes",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameModes __GameModes;
		
		[XmlIgnore]
		public GameModes GameModes
		{
			get
			{
				if (__GameModes == null) __GameModes = new GameModes();		
				return __GameModes;
			}
			set {__GameModes = value;}
		}

		[XmlElement(Type=typeof(Contexts),ElementName="Contexts",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Contexts __Contexts;
		
		[XmlIgnore]
		public Contexts Contexts
		{
			get
			{
				if (__Contexts == null) __Contexts = new Contexts();		
				return __Contexts;
			}
			set {__Contexts = value;}
		}

		[XmlElement(Type=typeof(Images),ElementName="Images",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Images __Images;
		
		[XmlIgnore]
		public Images Images
		{
			get
			{
				if (__Images == null) __Images = new Images();		
				return __Images;
			}
			set {__Images = value;}
		}

		[XmlElement(Type=typeof(Achievements),ElementName="Achievements",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Achievements __Achievements;
		
		[XmlIgnore]
		public Achievements Achievements
		{
			get
			{
				if (__Achievements == null) __Achievements = new Achievements();		
				return __Achievements;
			}
			set {__Achievements = value;}
		}

		[XmlElement(Type=typeof(Properties),ElementName="Properties",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Properties __Properties;
		
		[XmlIgnore]
		public Properties Properties
		{
			get
			{
				if (__Properties == null) __Properties = new Properties();		
				return __Properties;
			}
			set {__Properties = value;}
		}

		[XmlElement(Type=typeof(Presence),ElementName="Presence",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Presence __Presence;
		
		[XmlIgnore]
		public Presence Presence
		{
			get
			{
				if (__Presence == null) __Presence = new Presence();		
				return __Presence;
			}
			set {__Presence = value;}
		}

		[XmlElement(Type=typeof(StatsViews),ElementName="StatsViews",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public StatsViews __StatsViews;
		
		[XmlIgnore]
		public StatsViews StatsViews
		{
			get
			{
				if (__StatsViews == null) __StatsViews = new StatsViews();		
				return __StatsViews;
			}
			set {__StatsViews = value;}
		}

		[XmlElement(Type=typeof(Matchmaking),ElementName="Matchmaking",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Matchmaking __Matchmaking;
		
		[XmlIgnore]
		public Matchmaking Matchmaking
		{
			get
			{
				if (__Matchmaking == null) __Matchmaking = new Matchmaking();		
				return __Matchmaking;
			}
			set {__Matchmaking = value;}
		}

		[XmlElement(Type=typeof(ProductInformation),ElementName="ProductInformation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ProductInformation __ProductInformation;
		
		[XmlIgnore]
		public ProductInformation ProductInformation
		{
			get
			{
				if (__ProductInformation == null) __ProductInformation = new ProductInformation();		
				return __ProductInformation;
			}
			set {__ProductInformation = value;}
		}

		[XmlElement(Type=typeof(GamerPictures),ElementName="GamerPictures",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GamerPictures __GamerPictures;
		
		[XmlIgnore]
		public GamerPictures GamerPictures
		{
			get
			{
				if (__GamerPictures == null) __GamerPictures = new GamerPictures();		
				return __GamerPictures;
			}
			set {__GamerPictures = value;}
		}

		public GameConfigProject()
		{
		}

		public void MakeSchemaCompliant()
		{
			LocalizedStrings.MakeSchemaCompliant();
			GameModes.MakeSchemaCompliant();
			Presence.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="LocalizedStrings",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedStrings
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="defaultLocale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __defaultLocale;
		
		[XmlIgnore]
		public string defaultLocale
		{ 
			get { return __defaultLocale; }
			set { __defaultLocale = value; }
		}

		[XmlElement(Type=typeof(SupportedLocale),ElementName="SupportedLocale",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SupportedLocaleCollection __SupportedLocaleCollection;
		
		[XmlIgnore]
		public SupportedLocaleCollection SupportedLocaleCollection
		{
			get
			{
				if (__SupportedLocaleCollection == null) __SupportedLocaleCollection = new SupportedLocaleCollection();
				return __SupportedLocaleCollection;
			}
			set {__SupportedLocaleCollection = value;}
		}

		[XmlElement(Type=typeof(LocalizedString),ElementName="LocalizedString",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStringCollection __LocalizedStringCollection;
		
		[XmlIgnore]
		public LocalizedStringCollection LocalizedStringCollection
		{
			get
			{
				if (__LocalizedStringCollection == null) __LocalizedStringCollection = new LocalizedStringCollection();
				return __LocalizedStringCollection;
			}
			set {__LocalizedStringCollection = value;}
		}

		public LocalizedStrings()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (SupportedLocaleCollection.Count == 0)
			{
				SupportedLocale _c = SupportedLocaleCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (SupportedLocale _c in SupportedLocaleCollection) _c.MakeSchemaCompliant();
			if (LocalizedStringCollection.Count == 0)
			{
				LocalizedString _c = LocalizedStringCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (LocalizedString _c in LocalizedStringCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="SupportedLocale",Namespace=Declarations.SchemaVersion),Serializable]
	public class SupportedLocale
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __locale;
		
		[XmlIgnore]
		public string locale
		{ 
			get { return __locale; }
			set { __locale = value; }
		}

		public SupportedLocale()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="LocalizedString",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedString
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public ushort id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlElement(Type=typeof(Translation),ElementName="Translation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public TranslationCollection __TranslationCollection;
		
		[XmlIgnore]
		public TranslationCollection TranslationCollection
		{
			get
			{
				if (__TranslationCollection == null) __TranslationCollection = new TranslationCollection();
				return __TranslationCollection;
			}
			set {__TranslationCollection = value;}
		}

		[XmlElement(Type=typeof(LocalizedStringPresence),ElementName="Presence",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public LocalizedStringPresence __Presence;
		
		[XmlIgnore]
		public LocalizedStringPresence Presence
		{
			get
			{
				if (__Presence == null) __Presence = new LocalizedStringPresence();		
				return __Presence;
			}
			set {__Presence = value;}
		}

		public LocalizedString()
		{
		}

		public void MakeSchemaCompliant()
		{
			if (TranslationCollection.Count == 0)
			{
				Translation _c = TranslationCollection.Add();
				_c.MakeSchemaCompliant();
			}
			else foreach (Translation _c in TranslationCollection) _c.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Translation",Namespace=Declarations.SchemaVersion),Serializable]
	public class Translation
	{

		[XmlAttribute(AttributeName="locale",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __locale;
		
		[XmlIgnore]
		public string locale
		{ 
			get { return __locale; }
			set { __locale = value; }
		}

		[XmlText(DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Value;
		
		[XmlIgnore]
		public string Value
		{ 
			get { return __Value; }
			set { __Value = value; }
		}

		public Translation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="LocalizedStringPresence",Namespace=Declarations.SchemaVersion),Serializable]
	public class LocalizedStringPresence
	{

		public LocalizedStringPresence()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GameModes",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameModes
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return GameModeCollection.GetEnumerator();
		}

		public GameMode Add(GameMode obj)
		{
			return GameModeCollection.Add(obj);
		}

		[XmlIgnore]
		public GameMode this[int index]
		{
			get { return (GameMode) GameModeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return GameModeCollection.Count; }
        }

        public void Clear()
		{
            GameModeCollection.Clear();
        }

		public GameMode Remove(int index) 
		{ 
            GameMode obj = GameModeCollection[index];
            GameModeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            GameModeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="defaultValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __defaultValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __defaultValueSpecified;
		
		[XmlIgnore]
		public ushort defaultValue
		{ 
			get { return __defaultValue; }
			set { __defaultValue = value; __defaultValueSpecified = true; }
		}

		[XmlElement(Type=typeof(GameMode),ElementName="GameMode",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GameModeCollection __GameModeCollection;
		
		[XmlIgnore]
		public GameModeCollection GameModeCollection
		{
			get
			{
				if (__GameModeCollection == null) __GameModeCollection = new GameModeCollection();
				return __GameModeCollection;
			}
			set {__GameModeCollection = value;}
		}

		public GameModes()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GameMode",Namespace=Declarations.SchemaVersion),Serializable]
	public class GameMode
	{

		[XmlAttribute(AttributeName="value",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __value;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __valueSpecified;
		
		[XmlIgnore]
		public ushort @value
		{ 
			get { return __value; }
			set { __value = value; __valueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="drawProbability",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __drawProbability;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __drawProbabilitySpecified;
		
		[XmlIgnore]
		public byte drawProbability
		{ 
			get { return __drawProbability; }
			set { __drawProbability = value; __drawProbabilitySpecified = true; }
		}

		public GameMode()
		{
			__drawProbabilitySpecified = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Contexts",Namespace=Declarations.SchemaVersion),Serializable]
	public class Contexts
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ContextCollection.GetEnumerator();
		}

		public Context Add(Context obj)
		{
			return ContextCollection.Add(obj);
		}

		[XmlIgnore]
		public Context this[int index]
		{
			get { return (Context) ContextCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ContextCollection.Count; }
        }

        public void Clear()
		{
            ContextCollection.Clear();
        }

		public Context Remove(int index) 
		{ 
            Context obj = ContextCollection[index];
            ContextCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ContextCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __nextId;
		
		[XmlIgnore]
		public string nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; }
		}

		[XmlElement(Type=typeof(Context),ElementName="Context",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContextCollection __ContextCollection;
		
		[XmlIgnore]
		public ContextCollection ContextCollection
		{
			get
			{
				if (__ContextCollection == null) __ContextCollection = new ContextCollection();
				return __ContextCollection;
			}
			set {__ContextCollection = value;}
		}

		public Contexts()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Context",Namespace=Declarations.SchemaVersion),Serializable]
	public class Context
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ContextValueCollection.GetEnumerator();
		}

		public ContextValue Add(ContextValue obj)
		{
			return ContextValueCollection.Add(obj);
		}

		[XmlIgnore]
		public ContextValue this[int index]
		{
			get { return (ContextValue) ContextValueCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ContextValueCollection.Count; }
        }

        public void Clear()
		{
            ContextValueCollection.Clear();
        }

		public ContextValue Remove(int index) 
		{ 
            ContextValue obj = ContextValueCollection[index];
            ContextValueCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ContextValueCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="defaultValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __defaultValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __defaultValueSpecified;
		
		[XmlIgnore]
		public ushort defaultValue
		{ 
			get { return __defaultValue; }
			set { __defaultValue = value; __defaultValueSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(ContextValue),ElementName="ContextValue",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ContextValueCollection __ContextValueCollection;
		
		[XmlIgnore]
		public ContextValueCollection ContextValueCollection
		{
			get
			{
				if (__ContextValueCollection == null) __ContextValueCollection = new ContextValueCollection();
				return __ContextValueCollection;
			}
			set {__ContextValueCollection = value;}
		}

		public Context()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ContextValue",Namespace=Declarations.SchemaVersion),Serializable]
	public class ContextValue
	{

		[XmlAttribute(AttributeName="value",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __value;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __valueSpecified;
		
		[XmlIgnore]
		public ushort @value
		{ 
			get { return __value; }
			set { __value = value; __valueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public ContextValue()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Images",Namespace=Declarations.SchemaVersion),Serializable]
	public class Images
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ImageCollection.GetEnumerator();
		}

		public Image Add(Image obj)
		{
			return ImageCollection.Add(obj);
		}

		[XmlIgnore]
		public Image this[int index]
		{
			get { return (Image) ImageCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ImageCollection.Count; }
        }

        public void Clear()
		{
            ImageCollection.Clear();
        }

		public Image Remove(int index) 
		{ 
            Image obj = ImageCollection[index];
            ImageCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ImageCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Image),ElementName="Image",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ImageCollection __ImageCollection;
		
		[XmlIgnore]
		public ImageCollection ImageCollection
		{
			get
			{
				if (__ImageCollection == null) __ImageCollection = new ImageCollection();
				return __ImageCollection;
			}
			set {__ImageCollection = value;}
		}

		public Images()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Image",Namespace=Declarations.SchemaVersion),Serializable]
	public class Image
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlElement(ElementName="Path",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Path;
		
		[XmlIgnore]
		public string Path
		{ 
			get { return __Path; }
			set { __Path = value; }
		}

		public Image()
		{
			Path = string.Empty;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Achievements",Namespace=Declarations.SchemaVersion),Serializable]
	public class Achievements
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return AchievementCollection.GetEnumerator();
		}

		public Achievement Add(Achievement obj)
		{
			return AchievementCollection.Add(obj);
		}

		[XmlIgnore]
		public Achievement this[int index]
		{
			get { return (Achievement) AchievementCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return AchievementCollection.Count; }
        }

        public void Clear()
		{
            AchievementCollection.Clear();
        }

		public Achievement Remove(int index) 
		{ 
            Achievement obj = AchievementCollection[index];
            AchievementCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            AchievementCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Achievement),ElementName="Achievement",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public AchievementCollection __AchievementCollection;
		
		[XmlIgnore]
		public AchievementCollection AchievementCollection
		{
			get
			{
				if (__AchievementCollection == null) __AchievementCollection = new AchievementCollection();
				return __AchievementCollection;
			}
			set {__AchievementCollection = value;}
		}

		public Achievements()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Achievement",Namespace=Declarations.SchemaVersion),Serializable]
	public class Achievement
	{

		[XmlAttribute(AttributeName="achievementType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public achievementType __achievementType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __achievementTypeSpecified;
		
		[XmlIgnore]
		public achievementType achievementType
		{ 
			get { return __achievementType; }
			set { __achievementType = value; __achievementTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="descriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __descriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __descriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort descriptionStringId
		{ 
			get { return __descriptionStringId; }
			set { __descriptionStringId = value; __descriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public ushort id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="imageId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __imageId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __imageIdSpecified;
		
		[XmlIgnore]
		public uint imageId
		{ 
			get { return __imageId; }
			set { __imageId = value; __imageIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="showUnachieved",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __showUnachieved;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __showUnachievedSpecified;
		
		[XmlIgnore]
		public bool showUnachieved
		{ 
			get { return __showUnachieved; }
			set { __showUnachieved = value; __showUnachievedSpecified = true; }
		}

		[XmlAttribute(AttributeName="titleStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __titleStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __titleStringIdSpecified;
		
		[XmlIgnore]
		public ushort titleStringId
		{ 
			get { return __titleStringId; }
			set { __titleStringId = value; __titleStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="unachievedStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __unachievedStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __unachievedStringIdSpecified;
		
		[XmlIgnore]
		public ushort unachievedStringId
		{ 
			get { return __unachievedStringId; }
			set { __unachievedStringId = value; __unachievedStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="webDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __webDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __webDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort webDescriptionStringId
		{ 
			get { return __webDescriptionStringId; }
			set { __webDescriptionStringId = value; __webDescriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="cred",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __cred;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __credSpecified;
		
		[XmlIgnore]
		public ushort cred
		{ 
			get { return __cred; }
			set { __cred = value; __credSpecified = true; }
		}

		public Achievement()
		{
			showUnachieved = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Properties",Namespace=Declarations.SchemaVersion),Serializable]
	public class Properties
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PropertyCollection.GetEnumerator();
		}

		public Property Add(Property obj)
		{
			return PropertyCollection.Add(obj);
		}

		[XmlIgnore]
		public Property this[int index]
		{
			get { return (Property) PropertyCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PropertyCollection.Count; }
        }

        public void Clear()
		{
            PropertyCollection.Clear();
        }

		public Property Remove(int index) 
		{ 
            Property obj = PropertyCollection[index];
            PropertyCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PropertyCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public ushort nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Property),ElementName="Property",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PropertyCollection __PropertyCollection;
		
		[XmlIgnore]
		public PropertyCollection PropertyCollection
		{
			get
			{
				if (__PropertyCollection == null) __PropertyCollection = new PropertyCollection();
				return __PropertyCollection;
			}
			set {__PropertyCollection = value;}
		}

		public Properties()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Property",Namespace=Declarations.SchemaVersion),Serializable]
	public class Property
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="dataSize",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __dataSize;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __dataSizeSpecified;
		
		[XmlIgnore]
		public ushort dataSize
		{ 
			get { return __dataSize; }
			set { __dataSize = value; __dataSizeSpecified = true; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(DefaultValue),ElementName="DefaultValue",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public DefaultValue __DefaultValue;
		
		[XmlIgnore]
		public DefaultValue DefaultValue
		{
			get
			{
				if (__DefaultValue == null) __DefaultValue = new DefaultValue();		
				return __DefaultValue;
			}
			set {__DefaultValue = value;}
		}

		[XmlElement(Type=typeof(Format),ElementName="Format",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Format __Format;
		
		[XmlIgnore]
		public Format Format
		{
			get
			{
				if (__Format == null) __Format = new Format();		
				return __Format;
			}
			set {__Format = value;}
		}

		public Property()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="DefaultValue",Namespace=Declarations.SchemaVersion),Serializable]
	public class DefaultValue
	{

		public DefaultValue()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Format",Namespace=Declarations.SchemaVersion),Serializable]
	public class Format
	{

		[XmlAttribute(AttributeName="decimals",DataType="unsignedByte")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public byte __decimals;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __decimalsSpecified;
		
		[XmlIgnore]
		public byte decimals
		{ 
			get { return __decimals; }
			set { __decimals = value; __decimalsSpecified = true; }
		}

		[XmlAttribute(AttributeName="year",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __year;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __yearSpecified;
		
		[XmlIgnore]
		public bool year
		{ 
			get { return __year; }
			set { __year = value; __yearSpecified = true; }
		}

		[XmlAttribute(AttributeName="month",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __month;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __monthSpecified;
		
		[XmlIgnore]
		public bool month
		{ 
			get { return __month; }
			set { __month = value; __monthSpecified = true; }
		}

		[XmlAttribute(AttributeName="day",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __day;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __daySpecified;
		
		[XmlIgnore]
		public bool day
		{ 
			get { return __day; }
			set { __day = value; __daySpecified = true; }
		}

		[XmlAttribute(AttributeName="hours",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hours;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hoursSpecified;
		
		[XmlIgnore]
		public bool hours
		{ 
			get { return __hours; }
			set { __hours = value; __hoursSpecified = true; }
		}

		[XmlAttribute(AttributeName="minutes",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __minutes;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __minutesSpecified;
		
		[XmlIgnore]
		public bool minutes
		{ 
			get { return __minutes; }
			set { __minutes = value; __minutesSpecified = true; }
		}

		[XmlAttribute(AttributeName="seconds",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __seconds;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __secondsSpecified;
		
		[XmlIgnore]
		public bool seconds
		{ 
			get { return __seconds; }
			set { __seconds = value; __secondsSpecified = true; }
		}

		[XmlAttribute(AttributeName="milliseconds",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __milliseconds;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __millisecondsSpecified;
		
		[XmlIgnore]
		public bool milliseconds
		{ 
			get { return __milliseconds; }
			set { __milliseconds = value; __millisecondsSpecified = true; }
		}

		public Format()
		{
			decimals = 2;
			year = true;
			month = true;
			day = true;
			hours = true;
			minutes = true;
			seconds = true;
			milliseconds = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Presence",Namespace=Declarations.SchemaVersion),Serializable]
	public class Presence
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PresenceModeCollection.GetEnumerator();
		}

		public PresenceMode Add(PresenceMode obj)
		{
			return PresenceModeCollection.Add(obj);
		}

		[XmlIgnore]
		public PresenceMode this[int index]
		{
			get { return (PresenceMode) PresenceModeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PresenceModeCollection.Count; }
        }

        public void Clear()
		{
            PresenceModeCollection.Clear();
        }

		public PresenceMode Remove(int index) 
		{ 
            PresenceMode obj = PresenceModeCollection[index];
            PresenceModeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PresenceModeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextContextValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __nextContextValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextContextValueSpecified;
		
		[XmlIgnore]
		public ushort nextContextValue
		{ 
			get { return __nextContextValue; }
			set { __nextContextValue = value; __nextContextValueSpecified = true; }
		}

		[XmlElement(Type=typeof(PresenceMode),ElementName="PresenceMode",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PresenceModeCollection __PresenceModeCollection;
		
		[XmlIgnore]
		public PresenceModeCollection PresenceModeCollection
		{
			get
			{
				if (__PresenceModeCollection == null) __PresenceModeCollection = new PresenceModeCollection();
				return __PresenceModeCollection;
			}
			set {__PresenceModeCollection = value;}
		}

		public Presence()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="PresenceMode",Namespace=Declarations.SchemaVersion),Serializable]
	public class PresenceMode
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="contextValue",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __contextValue;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __contextValueSpecified;
		
		[XmlIgnore]
		public ushort contextValue
		{ 
			get { return __contextValue; }
			set { __contextValue = value; __contextValueSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		public PresenceMode()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="StatsViews",Namespace=Declarations.SchemaVersion),Serializable]
	public class StatsViews
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return StatsViewCollection.GetEnumerator();
		}

		public StatsView Add(StatsView obj)
		{
			return StatsViewCollection.Add(obj);
		}

		[XmlIgnore]
		public StatsView this[int index]
		{
			get { return (StatsView) StatsViewCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return StatsViewCollection.Count; }
        }

        public void Clear()
		{
            StatsViewCollection.Clear();
        }

		public StatsView Remove(int index) 
		{ 
            StatsView obj = StatsViewCollection[index];
            StatsViewCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            StatsViewCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextViewId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextViewId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextViewIdSpecified;
		
		[XmlIgnore]
		public uint nextViewId
		{ 
			get { return __nextViewId; }
			set { __nextViewId = value; __nextViewIdSpecified = true; }
		}

		[XmlElement(Type=typeof(StatsView),ElementName="StatsView",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public StatsViewCollection __StatsViewCollection;
		
		[XmlIgnore]
		public StatsViewCollection StatsViewCollection
		{
			get
			{
				if (__StatsViewCollection == null) __StatsViewCollection = new StatsViewCollection();
				return __StatsViewCollection;
			}
			set {__StatsViewCollection = value;}
		}

		public StatsViews()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="StatsView",Namespace=Declarations.SchemaVersion),Serializable]
	public class StatsView
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
        
        [XmlAttribute(AttributeName = "platformVisible", DataType = "string")]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public string platformVisible;

        [XmlAttribute(AttributeName = "platformVisibleRatingAttributeId", DataType = "unsignedInt")]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public System.UInt32 platformVisibleRatingAttributeId;

        [XmlIgnore]
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        public bool platformVisibleRatingAttributeIdSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="resetType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public resetType __resetType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __resetTypeSpecified;
		
		[XmlIgnore]
		public resetType resetType
		{ 
			get { return __resetType; }
			set { __resetType = value; __resetTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="stringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __stringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __stringIdSpecified;
		
		[XmlIgnore]
		public ushort stringId
		{ 
			get { return __stringId; }
			set { __stringId = value; __stringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="entryExpiration",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __entryExpiration;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __entryExpirationSpecified;
		
		[XmlIgnore]
		public ushort entryExpiration
		{ 
			get { return __entryExpiration; }
			set { __entryExpiration = value; __entryExpirationSpecified = true; }
		}

		[XmlAttribute(AttributeName="topEntries",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __topEntries;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __topEntriesSpecified;
		
		[XmlIgnore]
		public uint topEntries
		{ 
			get { return __topEntries; }
			set { __topEntries = value; __topEntriesSpecified = true; }
		}

		[XmlAttribute(AttributeName="arbitrated",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arbitrated;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arbitratedSpecified;
		
		[XmlIgnore]
		public bool arbitrated
		{ 
			get { return __arbitrated; }
			set { __arbitrated = value; __arbitratedSpecified = true; }
		}

		[XmlAttribute(AttributeName="hidden",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hidden;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __hiddenSpecified;
		
		[XmlIgnore]
		public bool hidden
		{ 
			get { return __hidden; }
			set { __hidden = value; __hiddenSpecified = true; }
		}

		[XmlAttribute(AttributeName="maxAttachments",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __maxAttachments;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __maxAttachmentsSpecified;
		
		[XmlIgnore]
		public ushort maxAttachments
		{ 
			get { return __maxAttachments; }
			set { __maxAttachments = value; __maxAttachmentsSpecified = true; }
		}

		[XmlAttribute(AttributeName="onlineOnly",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __onlineOnly;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __onlineOnlySpecified;
		
		[XmlIgnore]
		public bool onlineOnly
		{ 
			get { return __onlineOnly; }
			set { __onlineOnly = value; __onlineOnlySpecified = true; }
		}

		[XmlAttribute(AttributeName="flipAxes",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __flipAxes;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __flipAxesSpecified;
		
		[XmlIgnore]
		public bool flipAxes
		{ 
			get { return __flipAxes; }
			set { __flipAxes = value; __flipAxesSpecified = true; }
		}

		[XmlAttribute(AttributeName="viewType",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __viewType;
		
		[XmlIgnore]
		public string viewType
		{ 
			get { return __viewType; }
			set { __viewType = value; }
		}

		[XmlElement(Type=typeof(ServerTestFramework.STFTools.ConfigFiles.ViewAxisType),ElementName="Columns",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.ViewAxisType __Columns;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.ViewAxisType Columns
		{
			get
			{
				if (__Columns == null) __Columns = new ServerTestFramework.STFTools.ConfigFiles.ViewAxisType();		
				return __Columns;
			}
			set {__Columns = value;}
		}

		public StatsView()
		{
		}

		public void MakeSchemaCompliant()
		{
			Columns.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Matchmaking",Namespace=Declarations.SchemaVersion),Serializable]
	public class Matchmaking
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="isV1Title",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isV1Title;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __isV1TitleSpecified;
		
		[XmlIgnore]
		public bool isV1Title
		{ 
			get { return __isV1Title; }
			set { __isV1Title = value; __isV1TitleSpecified = true; }
		}

		[XmlElement(Type=typeof(Schema),ElementName="Schema",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Schema __Schema;
		
		[XmlIgnore]
		public Schema Schema
		{
			get
			{
				if (__Schema == null) __Schema = new Schema();		
				return __Schema;
			}
			set {__Schema = value;}
		}

		[XmlElement(Type=typeof(Constants),ElementName="Constants",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Constants __Constants;
		
		[XmlIgnore]
		public Constants Constants
		{
			get
			{
				if (__Constants == null) __Constants = new Constants();		
				return __Constants;
			}
			set {__Constants = value;}
		}

		[XmlElement(Type=typeof(Queries),ElementName="Queries",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Queries __Queries;
		
		[XmlIgnore]
		public Queries Queries
		{
			get
			{
				if (__Queries == null) __Queries = new Queries();		
				return __Queries;
			}
			set {__Queries = value;}
		}

		public Matchmaking()
		{
			isV1Title = false;
		}

		public void MakeSchemaCompliant()
		{
			Schema.MakeSchemaCompliant();
			Constants.MakeSchemaCompliant();
			Queries.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Schema",Namespace=Declarations.SchemaVersion),Serializable]
	public class Schema
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return AttributeCollection.GetEnumerator();
		}

		public Attribute Add(Attribute obj)
		{
			return AttributeCollection.Add(obj);
		}

		[XmlIgnore]
		public Attribute this[int index]
		{
			get { return (Attribute) AttributeCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return AttributeCollection.Count; }
        }

        public void Clear()
		{
            AttributeCollection.Clear();
        }

		public Attribute Remove(int index) 
		{ 
            Attribute obj = AttributeCollection[index];
            AttributeCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            AttributeCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Attribute),ElementName="Attribute",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public AttributeCollection __AttributeCollection;
		
		[XmlIgnore]
		public AttributeCollection AttributeCollection
		{
			get
			{
				if (__AttributeCollection == null) __AttributeCollection = new AttributeCollection();
				return __AttributeCollection;
			}
			set {__AttributeCollection = value;}
		}

		public Schema()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Attribute",Namespace=Declarations.SchemaVersion),Serializable]
	public class Attribute
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		public Attribute()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Constants",Namespace=Declarations.SchemaVersion),Serializable]
	public class Constants
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ConstantCollection.GetEnumerator();
		}

		public Constant Add(Constant obj)
		{
			return ConstantCollection.Add(obj);
		}

		[XmlIgnore]
		public Constant this[int index]
		{
			get { return (Constant) ConstantCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ConstantCollection.Count; }
        }

        public void Clear()
		{
            ConstantCollection.Clear();
        }

		public Constant Remove(int index) 
		{ 
            Constant obj = ConstantCollection[index];
            ConstantCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ConstantCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public uint nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Constant),ElementName="Constant",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ConstantCollection __ConstantCollection;
		
		[XmlIgnore]
		public ConstantCollection ConstantCollection
		{
			get
			{
				if (__ConstantCollection == null) __ConstantCollection = new ConstantCollection();
				return __ConstantCollection;
			}
			set {__ConstantCollection = value;}
		}

		public Constants()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Constant",Namespace=Declarations.SchemaVersion),Serializable]
	public class Constant
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="value",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __value;
		
		[XmlIgnore]
		public string @value
		{ 
			get { return __value; }
			set { __value = value; }
		}

		public Constant()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Queries",Namespace=Declarations.SchemaVersion),Serializable]
	public class Queries
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return QueryCollection.GetEnumerator();
		}

		public Query Add(Query obj)
		{
			return QueryCollection.Add(obj);
		}

		[XmlIgnore]
		public Query this[int index]
		{
			get { return (Query) QueryCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return QueryCollection.Count; }
        }

        public void Clear()
		{
            QueryCollection.Clear();
        }

		public Query Remove(int index) 
		{ 
            Query obj = QueryCollection[index];
            QueryCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            QueryCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="nextId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __nextId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __nextIdSpecified;
		
		[XmlIgnore]
		public uint nextId
		{ 
			get { return __nextId; }
			set { __nextId = value; __nextIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Query),ElementName="Query",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public QueryCollection __QueryCollection;
		
		[XmlIgnore]
		public QueryCollection QueryCollection
		{
			get
			{
				if (__QueryCollection == null) __QueryCollection = new QueryCollection();
				return __QueryCollection;
			}
			set {__QueryCollection = value;}
		}

		public Queries()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Query",Namespace=Declarations.SchemaVersion),Serializable]
	public class Query
	{

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="maxResults",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __maxResults;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __maxResultsSpecified;
		
		[XmlIgnore]
		public ushort maxResults
		{ 
			get { return __maxResults; }
			set { __maxResults = value; __maxResultsSpecified = true; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type2 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type2 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="qosProbe",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __qosProbe;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __qosProbeSpecified;
		
		[XmlIgnore]
		public bool qosProbe
		{ 
			get { return __qosProbe; }
			set { __qosProbe = value; __qosProbeSpecified = true; }
		}

		[XmlAttribute(AttributeName="groupBy",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __groupBy;
		
		[XmlIgnore]
		public string groupBy
		{ 
			get { return __groupBy; }
			set { __groupBy = value; }
		}

		[XmlElement(Type=typeof(Parameters),ElementName="Parameters",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Parameters __Parameters;
		
		[XmlIgnore]
		public Parameters Parameters
		{
			get
			{
				if (__Parameters == null) __Parameters = new Parameters();		
				return __Parameters;
			}
			set {__Parameters = value;}
		}

		[XmlElement(Type=typeof(Filters),ElementName="Filters",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Filters __Filters;
		
		[XmlIgnore]
		public Filters Filters
		{
			get
			{
				if (__Filters == null) __Filters = new Filters();		
				return __Filters;
			}
			set {__Filters = value;}
		}

		[XmlElement(Type=typeof(SortOperations),ElementName="SortOperations",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SortOperations __SortOperations;
		
		[XmlIgnore]
		public SortOperations SortOperations
		{
			get
			{
				if (__SortOperations == null) __SortOperations = new SortOperations();		
				return __SortOperations;
			}
			set {__SortOperations = value;}
		}

		[XmlElement(Type=typeof(Returns),ElementName="Returns",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public Returns __Returns;
		
		[XmlIgnore]
		public Returns Returns
		{
			get
			{
				if (__Returns == null) __Returns = new Returns();		
				return __Returns;
			}
			set {__Returns = value;}
		}

		public Query()
		{
		}

		public void MakeSchemaCompliant()
		{
			Parameters.MakeSchemaCompliant();
			Filters.MakeSchemaCompliant();
			SortOperations.MakeSchemaCompliant();
			Returns.MakeSchemaCompliant();
		}
	}


	[XmlType(TypeName="Parameters",Namespace=Declarations.SchemaVersion),Serializable]
	public class Parameters
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ParameterCollection.GetEnumerator();
		}

		public Parameter Add(Parameter obj)
		{
			return ParameterCollection.Add(obj);
		}

		[XmlIgnore]
		public Parameter this[int index]
		{
			get { return (Parameter) ParameterCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ParameterCollection.Count; }
        }

        public void Clear()
		{
            ParameterCollection.Clear();
        }

		public Parameter Remove(int index) 
		{ 
            Parameter obj = ParameterCollection[index];
            ParameterCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ParameterCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Parameter),ElementName="Parameter",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ParameterCollection __ParameterCollection;
		
		[XmlIgnore]
		public ParameterCollection ParameterCollection
		{
			get
			{
				if (__ParameterCollection == null) __ParameterCollection = new ParameterCollection();
				return __ParameterCollection;
			}
			set {__ParameterCollection = value;}
		}

		public Parameters()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Parameter",Namespace=Declarations.SchemaVersion),Serializable]
	public class Parameter
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		public Parameter()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Filters",Namespace=Declarations.SchemaVersion),Serializable]
	public class Filters
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return FilterCollection.GetEnumerator();
		}

		public Filter Add(Filter obj)
		{
			return FilterCollection.Add(obj);
		}

		[XmlIgnore]
		public Filter this[int index]
		{
			get { return (Filter) FilterCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return FilterCollection.Count; }
        }

        public void Clear()
		{
            FilterCollection.Clear();
        }

		public Filter Remove(int index) 
		{ 
            Filter obj = FilterCollection[index];
            FilterCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            FilterCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Filter),ElementName="Filter",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public FilterCollection __FilterCollection;
		
		[XmlIgnore]
		public FilterCollection FilterCollection
		{
			get
			{
				if (__FilterCollection == null) __FilterCollection = new FilterCollection();
				return __FilterCollection;
			}
			set {__FilterCollection = value;}
		}

		public Filters()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Filter",Namespace=Declarations.SchemaVersion),Serializable]
	public class Filter
	{

		[XmlAttribute(AttributeName="left",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __left;
		
		[XmlIgnore]
		public string left
		{ 
			get { return __left; }
			set { __left = value; }
		}

		[XmlAttribute(AttributeName="leftType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType __leftType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __leftTypeSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType leftType
		{ 
			get { return __leftType; }
			set { __leftType = value; __leftTypeSpecified = true; }
		}

		[XmlAttribute(AttributeName="op",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __op;
		
		[XmlIgnore]
		public string op
		{ 
			get { return __op; }
			set { __op = value; }
		}

		[XmlAttribute(AttributeName="right",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __right;
		
		[XmlIgnore]
		public string right
		{ 
			get { return __right; }
			set { __right = value; }
		}

		[XmlAttribute(AttributeName="rightType")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType __rightType;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __rightTypeSpecified;
		
		[XmlIgnore]
		public ServerTestFramework.STFTools.ConfigFiles.MatchFilterItemType rightType
		{ 
			get { return __rightType; }
			set { __rightType = value; __rightTypeSpecified = true; }
		}

		public Filter()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="SortOperations",Namespace=Declarations.SchemaVersion),Serializable]
	public class SortOperations
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return SortOperationCollection.GetEnumerator();
		}

		public SortOperation Add(SortOperation obj)
		{
			return SortOperationCollection.Add(obj);
		}

		[XmlIgnore]
		public SortOperation this[int index]
		{
			get { return (SortOperation) SortOperationCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return SortOperationCollection.Count; }
        }

        public void Clear()
		{
            SortOperationCollection.Clear();
        }

		public SortOperation Remove(int index) 
		{ 
            SortOperation obj = SortOperationCollection[index];
            SortOperationCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            SortOperationCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(SortOperation),ElementName="SortOperation",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public SortOperationCollection __SortOperationCollection;
		
		[XmlIgnore]
		public SortOperationCollection SortOperationCollection
		{
			get
			{
				if (__SortOperationCollection == null) __SortOperationCollection = new SortOperationCollection();
				return __SortOperationCollection;
			}
			set {__SortOperationCollection = value;}
		}

		public SortOperations()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="SortOperation",Namespace=Declarations.SchemaVersion),Serializable]
	public class SortOperation
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type23 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type23 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="distanceid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __distanceid;
		
		[XmlIgnore]
		public string distanceid
		{ 
			get { return __distanceid; }
			set { __distanceid = value; }
		}

		public SortOperation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Returns",Namespace=Declarations.SchemaVersion),Serializable]
	public class Returns
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return ReturnCollection.GetEnumerator();
		}

		public @Return Add(@Return obj)
		{
			return ReturnCollection.Add(obj);
		}

		[XmlIgnore]
		public @Return this[int index]
		{
			get { return (@Return) ReturnCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return ReturnCollection.Count; }
        }

        public void Clear()
		{
            ReturnCollection.Clear();
        }

		public @Return Remove(int index) 
		{ 
            @Return obj = ReturnCollection[index];
            ReturnCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            ReturnCollection.Remove(obj);
        }

		[XmlElement(Type=typeof(Return),ElementName="Return",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ReturnCollection __ReturnCollection;
		
		[XmlIgnore]
		public ReturnCollection ReturnCollection
		{
			get
			{
				if (__ReturnCollection == null) __ReturnCollection = new ReturnCollection();
				return __ReturnCollection;
			}
			set {__ReturnCollection = value;}
		}

		public Returns()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Return",Namespace=Declarations.SchemaVersion),Serializable]
	public class @Return
	{

		[XmlAttribute(AttributeName="id",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __id;
		
		[XmlIgnore]
		public string id
		{ 
			get { return __id; }
			set { __id = value; }
		}

		[XmlAttribute(AttributeName="type")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public type234 __type;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __typeSpecified;
		
		[XmlIgnore]
		public type234 type
		{ 
			get { return __type; }
			set { __type = value; __typeSpecified = true; }
		}

		[XmlAttribute(AttributeName="ordinal",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __ordinal;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ordinalSpecified;
		
		[XmlIgnore]
		public ushort ordinal
		{ 
			get { return __ordinal; }
			set { __ordinal = value; __ordinalSpecified = true; }
		}

		public @Return()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="ProductInformation",Namespace=Declarations.SchemaVersion),Serializable]
	public class ProductInformation
	{

		[XmlAttribute(AttributeName="offlinePlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __offlinePlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __offlinePlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort offlinePlayersMax
		{ 
			get { return __offlinePlayersMax; }
			set { __offlinePlayersMax = value; __offlinePlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="systemLinkPlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __systemLinkPlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __systemLinkPlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort systemLinkPlayersMax
		{ 
			get { return __systemLinkPlayersMax; }
			set { __systemLinkPlayersMax = value; __systemLinkPlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="livePlayersMax",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __livePlayersMax;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __livePlayersMaxSpecified;
		
		[XmlIgnore]
		public ushort livePlayersMax
		{ 
			get { return __livePlayersMax; }
			set { __livePlayersMax = value; __livePlayersMaxSpecified = true; }
		}

		[XmlAttribute(AttributeName="shortDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __shortDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __shortDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort shortDescriptionStringId
		{ 
			get { return __shortDescriptionStringId; }
			set { __shortDescriptionStringId = value; __shortDescriptionStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="sellTextStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __sellTextStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __sellTextStringIdSpecified;
		
		[XmlIgnore]
		public ushort sellTextStringId
		{ 
			get { return __sellTextStringId; }
			set { __sellTextStringId = value; __sellTextStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="publisherStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __publisherStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __publisherStringIdSpecified;
		
		[XmlIgnore]
		public ushort publisherStringId
		{ 
			get { return __publisherStringId; }
			set { __publisherStringId = value; __publisherStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="developerStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __developerStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __developerStringIdSpecified;
		
		[XmlIgnore]
		public ushort developerStringId
		{ 
			get { return __developerStringId; }
			set { __developerStringId = value; __developerStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="genreTextStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __genreTextStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreTextStringIdSpecified;
		
		[XmlIgnore]
		public ushort genreTextStringId
		{ 
			get { return __genreTextStringId; }
			set { __genreTextStringId = value; __genreTextStringIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="arcadeDescriptionStringId",DataType="unsignedShort")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public ushort __arcadeDescriptionStringId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __arcadeDescriptionStringIdSpecified;
		
		[XmlIgnore]
		public ushort arcadeDescriptionStringId
		{ 
			get { return __arcadeDescriptionStringId; }
			set { __arcadeDescriptionStringId = value; __arcadeDescriptionStringIdSpecified = true; }
		}

		[XmlElement(Type=typeof(Rating),ElementName="Rating",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public RatingCollection __RatingCollection;
		
		[XmlIgnore]
		public RatingCollection RatingCollection
		{
			get
			{
				if (__RatingCollection == null) __RatingCollection = new RatingCollection();
				return __RatingCollection;
			}
			set {__RatingCollection = value;}
		}

		[XmlElement(Type=typeof(Genre),ElementName="Genre",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public GenreCollection __GenreCollection;
		
		[XmlIgnore]
		public GenreCollection GenreCollection
		{
			get
			{
				if (__GenreCollection == null) __GenreCollection = new GenreCollection();
				return __GenreCollection;
			}
			set {__GenreCollection = value;}
		}

		[XmlElement(Type=typeof(Feature),ElementName="Feature",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public FeatureCollection __FeatureCollection;
		
		[XmlIgnore]
		public FeatureCollection FeatureCollection
		{
			get
			{
				if (__FeatureCollection == null) __FeatureCollection = new FeatureCollection();
				return __FeatureCollection;
			}
			set {__FeatureCollection = value;}
		}

		[XmlElement(Type=typeof(Platform),ElementName="Platform",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PlatformCollection __PlatformCollection;
		
		[XmlIgnore]
		public PlatformCollection PlatformCollection
		{
			get
			{
				if (__PlatformCollection == null) __PlatformCollection = new PlatformCollection();
				return __PlatformCollection;
			}
			set {__PlatformCollection = value;}
		}

		public ProductInformation()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Rating",Namespace=Declarations.SchemaVersion),Serializable]
	public class Rating
	{

		[XmlAttribute(AttributeName="ratingSystemId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __ratingSystemId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ratingSystemIdSpecified;
		
		[XmlIgnore]
		public uint ratingSystemId
		{ 
			get { return __ratingSystemId; }
			set { __ratingSystemId = value; __ratingSystemIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="ratingId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __ratingId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __ratingIdSpecified;
		
		[XmlIgnore]
		public uint ratingId
		{ 
			get { return __ratingId; }
			set { __ratingId = value; __ratingIdSpecified = true; }
		}

		[XmlAttribute(AttributeName="imageId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __imageId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __imageIdSpecified;
		
		[XmlIgnore]
		public uint imageId
		{ 
			get { return __imageId; }
			set { __imageId = value; __imageIdSpecified = true; }
		}

		[XmlElement(ElementName="Description",IsNullable=false,Form=XmlSchemaForm.Qualified,DataType="string",Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __Description;
		
		[XmlIgnore]
		public string Description
		{ 
			get { return __Description; }
			set { __Description = value; }
		}

		public Rating()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Genre",Namespace=Declarations.SchemaVersion),Serializable]
	public class Genre
	{

		[XmlAttribute(AttributeName="genreId",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __genreId;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __genreIdSpecified;
		
		[XmlIgnore]
		public uint genreId
		{ 
			get { return __genreId; }
			set { __genreId = value; __genreIdSpecified = true; }
		}

		public Genre()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Feature",Namespace=Declarations.SchemaVersion),Serializable]
	public class Feature
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="enabled",DataType="boolean")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __enabled;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __enabledSpecified;
		
		[XmlIgnore]
		public bool enabled
		{ 
			get { return __enabled; }
			set { __enabled = value; __enabledSpecified = true; }
		}

		public Feature()
		{
			enabled = true;
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Platform",Namespace=Declarations.SchemaVersion),Serializable]
	public class Platform
	{

		[XmlAttribute(AttributeName="name",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __name;
		
		[XmlIgnore]
		public string name
		{ 
			get { return __name; }
			set { __name = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public Platform()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="GamerPictures",Namespace=Declarations.SchemaVersion),Serializable]
	public class GamerPictures
	{
		[System.Runtime.InteropServices.DispIdAttribute(-4)]
		public IEnumerator GetEnumerator() 
		{
			return PictureCollection.GetEnumerator();
		}

		public Picture Add(Picture obj)
		{
			return PictureCollection.Add(obj);
		}

		[XmlIgnore]
		public Picture this[int index]
		{
			get { return (Picture) PictureCollection[index]; }
		}

		[XmlIgnore]
        public int Count 
		{
            get { return PictureCollection.Count; }
        }

        public void Clear()
		{
            PictureCollection.Clear();
        }

		public Picture Remove(int index) 
		{ 
            Picture obj = PictureCollection[index];
            PictureCollection.Remove(obj);
			return obj;
        }

        public void Remove(object obj)
		{
            PictureCollection.Remove(obj);
        }

		[XmlAttribute(AttributeName="clsid",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __clsid;
		
		[XmlIgnore]
		public string clsid
		{ 
			get { return __clsid; }
			set { __clsid = value; }
		}

		[XmlElement(Type=typeof(Picture),ElementName="Picture",IsNullable=false,Form=XmlSchemaForm.Qualified,Namespace=Declarations.SchemaVersion)]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public PictureCollection __PictureCollection;
		
		[XmlIgnore]
		public PictureCollection PictureCollection
		{
			get
			{
				if (__PictureCollection == null) __PictureCollection = new PictureCollection();
				return __PictureCollection;
			}
			set {__PictureCollection = value;}
		}

		public GamerPictures()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}


	[XmlType(TypeName="Picture",Namespace=Declarations.SchemaVersion),Serializable]
	public class Picture
	{

		[XmlAttribute(AttributeName="friendlyName",DataType="string")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public string __friendlyName;
		
		[XmlIgnore]
		public string friendlyName
		{ 
			get { return __friendlyName; }
			set { __friendlyName = value; }
		}

		[XmlAttribute(AttributeName="id",DataType="unsignedInt")]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public uint __id;
		
		[XmlIgnore]
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		public bool __idSpecified;
		
		[XmlIgnore]
		public uint id
		{ 
			get { return __id; }
			set { __id = value; __idSpecified = true; }
		}

		public Picture()
		{
		}

		public void MakeSchemaCompliant()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPAC\SPACTestBase.cs ===
using System;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;

using ServerTestFramework;
using ServerTestFramework.STFTools;
//using ServerTestFramework.ClientTools.ConfigFiles;

//using xonline.common.config;

namespace SPACTest
{
	/// <summary>
	/// Summary description for SPACTestBase.
	/// </summary>
	public class SPACTestBase : TestBase
	{
        protected SPAC _spac;
        protected string _inputFilesPath;
        protected string _tempPath;        
	 protected string _unCompileOPPath;
	 

        protected class OverrideTestSetting
        {
            public string Name;
            public string Value;
            public SPACReturnCode ExpReturn;

            public OverrideTestSetting(string name, string val, SPACReturnCode expReturn)
            {
                Name = name;
                Value = val;
                ExpReturn = expReturn;
            }
        }

        public SPACTestBase()
        {
            _spac = new SPAC();

            // Query the Global object to get our test-specific data
            XmlNode SPACConfig = Global.Config.SelectSingleNode("descendant::SPACTest");
            if (SPACConfig != null)
            {
                foreach (XmlNode setting in SPACConfig.ChildNodes)
                {
                    if (String.Compare(setting.Name, "DefaultToolPath", true) == 0)
                    {
                        _spac.SpacPath = Path.Combine(
                            Path.GetFullPath(setting.InnerText), "spac.exe");
                    }
                    else if (String.Compare(setting.Name, "InputFilePath", true) == 0)
                    {
                        _inputFilesPath = Path.GetFullPath(setting.InnerText);
                    }
                    else if (String.Compare(setting.Name, "TempDirectoryPath", true) == 0)
                    {
                        _tempPath = Path.GetFullPath(setting.InnerText);
                        if (!Directory.Exists(_tempPath))
                        {
                            Directory.CreateDirectory(_tempPath);
                        }
                    }
                    else if (String.Compare(setting.Name, "UnCompileDirectoryPath", true) == 0)
                    {
                        _unCompileOPPath = Path.GetFullPath(setting.InnerText);
                        if (!Directory.Exists(_unCompileOPPath))
                        {
                            Directory.CreateDirectory(_unCompileOPPath);
                        }
                    }

                }
            }
            else
            {
                throw new StfException("Unable to read the SPACTest configuration settings.");
            }

            // Set the working directory for SPAC to be in the temporary files location
            _spac.WorkingDirectory = _tempPath;
        }

        protected override void Execute()
        {
            throw new StfException("Hey you! You forgot to override the Execute method!");
        }

        protected void BeginCase(string message)
        {
            Global.RO.Info("");
            Global.RO.Info(message);
        }

        protected void CopyInputFiles(uint titleId)
        {
            string [] files = Directory.GetFiles(_inputFilesPath, titleId.ToString("X8") + "*.*");

            foreach (string file in files)
            {
                File.Copy(file, Path.Combine(_tempPath, Path.GetFileName(file)), true);
            }

            // Copy all PNG files (only if they don't already exist)
            files = Directory.GetFiles(_inputFilesPath, "*.png");
            string destFile;
            foreach (string file in files)
            {
                destFile = Path.Combine(_tempPath, Path.GetFileName(file));
                if (!File.Exists(destFile))
                {
                    File.Copy(file, destFile);
                }
            }
        }

        protected void CleanTempFiles(uint titleId)
        {
            string[] files = Directory.GetFiles(_tempPath, titleId.ToString("X8") + "*.*");
            foreach (string file in files)
            {
                File.Delete(file);
            }
        }
		
        protected void CleanUnCompileTempFolder()
        {
        
            string[] files = Directory.GetFiles(_unCompileOPPath);
            foreach (string file in files)
            {
                File.Delete(file);
            }
        }

        protected void ReportSPACResult(SPACReturnCode returnCode, string output)
        {
            ReportSPACResult(returnCode, null, output);
        }

        protected void ReportSPACResult(SPACReturnCode returnCode, string msg, string output)
        {
            StringBuilder outputMsg = new StringBuilder();

            outputMsg.AppendFormat("SPAC returned {0} ({1})", (int)returnCode, returnCode.ToString());
            switch (returnCode)
            {
                case SPACReturnCode.Success:
                    Global.RO.Info("{0}{1}", outputMsg.ToString(), msg != null ? " : " + msg : "");
                    break;
                case SPACReturnCode.NonFatalError:
                    Global.RO.Warn("{0}{1}", outputMsg.ToString(), msg != null ? " : " + msg : "");
                    break;
                default:
                    Global.RO.Error("{0}{1}", outputMsg.ToString(), msg != null ? " : " + msg : "");
                    break;
            }

            // Write the SPAC output
            Global.RO.Info("SPAC Output:\r\n{0}\r\n", output);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPAC\SPACFunctionals.cs ===
using System;
using System.Collections;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.STFTools;
using ServerTestFramework.STFTools.ConfigFiles;

namespace SPACTest
{
	/// <summary>
	/// 
	/// </summary>
    [TestGroup]
    public class SPACPositiveFunctionalTests : TestNode
    {
        [TestCase]
        public class CompileBasicXLASTFile : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting NoSpaAndHeaderSwitch...");
                ResultCode = TEST_RESULTS.FAILED;

                uint titleId = 0xFFFFAB44;
                SPACReturnCode returnCode;

                CleanTempFiles(titleId);
                CopyInputFiles(titleId);

                // Compile the XLAST file into a SPA file and a header file
                _spac.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                returnCode = _spac.Compile();
                ReportSPACResult(returnCode, "Compiling a Full Title XLAST file with nospa and noheader switch", _spac.Output);

                if (returnCode == SPACReturnCode.Success || returnCode == SPACReturnCode.NonFatalError)
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    // Verify the existence of the SPA and SPA.H files
                    string outputFile = _spac.XlastPath.Replace(".xlast", ".spa");
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate output SPA file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    outputFile = _spac.XlastPath.Replace(".xlast", ".spa.h");
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate output Header file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                CleanTempFiles(titleId);
            }
        }

        [TestCase]
        public class CompileDemoXLASTFile : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting ConmpileDemoXLASTFile...");

                uint titleId = 0xFFFFAB40;
                SPACReturnCode retCode;

                ResultCode = TEST_RESULTS.PASSED;
                CleanTempFiles(titleId);
                CopyInputFiles(titleId);

                // Verify the XLAST file correctly compiles
                _spac.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                retCode = _spac.Compile();
                ReportSPACResult(retCode, "Compiling a Demo XLAST file", _spac.Output);
                if (retCode == SPACReturnCode.Success || retCode == SPACReturnCode.NonFatalError)
                {
                    string outputFile = _spac.XlastPath.Replace(".xlast", ".spa");
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate the output SPA file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    outputFile += ".h";
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate the output header file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                CleanTempFiles(titleId);
            }
        }

        [TestCase]
        public class CompileSystemXLASTFile : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting CompileSystemXLASTFile...");

                uint titleId = 0xFFFFAB41;
                SPACReturnCode retCode;

                ResultCode = TEST_RESULTS.PASSED;
                CleanTempFiles(titleId);
                CopyInputFiles(titleId);

                // Verify the XLAST file correctly compiles
                _spac.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                retCode = _spac.Compile();
                ReportSPACResult(retCode, "Compiling a System XLAST file", _spac.Output);
                if (retCode == SPACReturnCode.Success || retCode == SPACReturnCode.NonFatalError)
                {
                    string outputFile = _spac.XlastPath.Replace(".xlast", ".spa");
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate the output SPA file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    outputFile += ".h";
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate the output header file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }
                else
                {
                    ResultCode = TEST_RESULTS.FAILED;
                }

                CleanTempFiles(titleId);
            }
        }

        [TestCase]
        public class FullGameGenreTest : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting FullGameGenreTest...");
                ResultCode = TEST_RESULTS.PASSED;

                uint titleId = 0xFFFFAB44;
                SPACReturnCode retCode;

                CleanTempFiles(titleId);
                CopyInputFiles(titleId);

                _spac.NoHeader = true;
                _spac.NoSpa = true;
                _spac.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");

                // Remove all the Genres from the XLAST file
                XboxLiveSubmissionProject xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), _spac.XlastPath);
                xlast.GameConfigProject.ProductInformation.GenreCollection.Clear();
                ConfigFileSerializer.ToXml(_spac.XlastPath, xlast);

                // Schema version 1.00.0000.0 should pass
                Global.RO.Info("Compiling schema version 1.00.0000.0");
                retCode = _spac.Compile();
                if (retCode != SPACReturnCode.Success)
                {
                    Global.RO.Error("Full game title (1.00.0000.0) without genres failed SPAC's compilation.");
                    ReportSPACResult(retCode, _spac.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                // Change the SchemaVersion to 1.02.0000.0 and try to compile
                xlast.GameConfigProject.schemaVersion = "1.02.0000.0";
                ConfigFileSerializer.ToXml(_spac.XlastPath, xlast);
                Global.RO.Info("Compiling schema version 1.02.0000.0");
                retCode = _spac.Compile();
                if (retCode == SPACReturnCode.Success)
                {
                    Global.RO.Error("Full game title (1.02.0000.0) without genres passed SPAC's compilation.");
                    ReportSPACResult(retCode, _spac.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode == TEST_RESULTS.PASSED) CleanTempFiles(titleId);
            }
        }

        [TestCase]
        public class DemoGameGenreTest : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting DemoGameGenreTest...");

                uint titleId = 0xFFFFAB40;
                SPACReturnCode retCode;

                ResultCode = TEST_RESULTS.PASSED;
                CleanTempFiles(titleId);
                CopyInputFiles(titleId);
                _spac.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _spac.NoHeader = true;
                _spac.NoSpa = true;

                // Add a second genre to this demo title
                XboxLiveSubmissionProject xlast = (XboxLiveSubmissionProject)ConfigFileSerializer.FromXml
                    (typeof(XboxLiveSubmissionProject), _spac.XlastPath);
                Genre newGenre = xlast.GameConfigProject.ProductInformation.GenreCollection.Add();
                newGenre.genreId = (uint)XLASTGenre.Fighting;
                ConfigFileSerializer.ToXml(_spac.XlastPath, xlast);

                // Schema version 1.00.0000.0 should work
                Global.RO.Info("Compiling schema version 1.00.0000.0");
                retCode = _spac.Compile();
                if (retCode != SPACReturnCode.Success)
                {
                    Global.RO.Error("Demo title (1.00.0000.0) with multiple genres failed SPAC's compilation.");
                    ReportSPACResult(retCode, _spac.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                // Schema version 1.02.0000.0 should not work
                xlast.GameConfigProject.schemaVersion = "1.02.0000.0";
                ConfigFileSerializer.ToXml(_spac.XlastPath, xlast);
                Global.RO.Info("Compiling schema version 1.02.0000.0");
                retCode = _spac.Compile();
                if (retCode == SPACReturnCode.Success || retCode == SPACReturnCode.NonFatalError)
                {
                    Global.RO.Error("Demo title (1.02.0000.0) with multiple genres passed SPAC's compilation.");
                    ReportSPACResult(retCode, _spac.Output);
                    ResultCode = TEST_RESULTS.FAILED;
                }

                if (ResultCode == TEST_RESULTS.PASSED)
                {
                    // Remove all Genres and recompile (this should fail)
                    xlast.GameConfigProject.ProductInformation.GenreCollection.Clear();
                    ConfigFileSerializer.ToXml(_spac.XlastPath, xlast);
                    retCode = _spac.Compile();
                    if (retCode == SPACReturnCode.Success || retCode == SPACReturnCode.NonFatalError)
                    {
                        Global.RO.Error("Compiling a Demo with no Genres should not succeed.");
                        ReportSPACResult(retCode, _spac.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED) CleanTempFiles(titleId);
            }
        }


	 [TestCase]
        public class DownloadableXLASTFile : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting DownloadableXLASTFile...");
                ResultCode = TEST_RESULTS.FAILED;

                uint titleId = 0xFFFFAB46;
                SPACReturnCode returnCode;

                CleanTempFiles(titleId);
                CopyInputFiles(titleId);

                // Compile the XLAST file into a SPA file and a header file
                _spac.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
		        string arcadeFilePath = Path.Combine(_tempPath, "ArcadeInfo.xml");
                returnCode = _spac.Compile();
                ReportSPACResult(returnCode, "Compiling a Downloadable Title XLAST file.", _spac.Output);

                if (returnCode == SPACReturnCode.Success || returnCode == SPACReturnCode.NonFatalError)
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    // Verify the existence of the SPA and SPA.H files
                    string outputFile = _spac.XlastPath.Replace(".xlast", ".spa");
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate output SPA file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    outputFile = _spac.XlastPath.Replace(".xlast", ".spa.h");
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate output Header file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
					
		      if (!File.Exists(arcadeFilePath))
		      	{
	                 Global.RO.Error("Unable to locate ArcadeInfo.xml file");
                        ResultCode = TEST_RESULTS.FAILED;
		      	}
                }

                CleanTempFiles(titleId);
            }
        }


        [TestCase]
        public class TestOverrides : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting TestAchievementMaxOverrides...");
                ResultCode = TEST_RESULTS.PASSED;

                uint titleId = 0xFFFFAB44;
                SPACReturnCode returnCode;
                SPACOverrides overrides;
                OverrideTestSetting [] settingList;

                CleanTempFiles(titleId);
                CopyInputFiles(titleId);

                // Set the SPAC parameters
                
                _spac.NoSpa = true;
                _spac.NoHeader = true;
                _spac.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                _spac.ConfigOverrideFile = Path.Combine(_tempPath, titleId.ToString("X8") + "_Overrides.xml");
			
                // Create an override file
                overrides = new SPACOverrides();
                overrides.TitleConfigs.Add(new SPACTitleConfig(1));
                overrides.TitleConfigs[0].Settings.Add();

                // Walk the test settings list and apply each override to the XLAST file
                settingList = CreateTestSettingList();
                foreach (OverrideTestSetting setting in settingList)
                {
                    overrides.TitleConfigs[0].Settings[0].Name = setting.Name;
                    overrides.TitleConfigs[0].Settings[0].Value = setting.Value;
                    overrides.ToXml(_spac.ConfigOverrideFile);
                    Global.RO.Info("Testing override setting {0} = {1}", setting.Name, setting.Value);
                    returnCode = _spac.Compile();
                    if (returnCode != setting.ExpReturn)
                    {
                        ReportSPACResult(returnCode, "Unexpected return value when compiling the XLAST file.", _spac.Output);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                if (ResultCode == TEST_RESULTS.PASSED) CleanTempFiles(titleId);
            }

            protected OverrideTestSetting [] CreateTestSettingList()
            {
                OverrideTestSetting [] settingList =
                {
                    new OverrideTestSetting("",                         "",     SPACReturnCode.Success),
                    new OverrideTestSetting("maxTitleNameLength",       "10",   SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxAchNameLength",         "10",   SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxAchDescLength",         "10",   SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxAchHowToLength",        "10",   SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxAchievements",          "3",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxAchievementsWithCred",  "3",    SPACReturnCode.NonFatalError),
                    new OverrideTestSetting("minAchievements",          "10",   SPACReturnCode.FatalError),
                    new OverrideTestSetting("minAchievementsWithCred",  "10",   SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxCred",                  "800",  SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxCred",                  "1200", SPACReturnCode.Success),
                    new OverrideTestSetting("maxContextNameLen",        "10",   SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxContexts",              "1",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxContextValueNameLen",   "10",   SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxContextValues",         "2",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxGameModes",             "2",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxLeaderboards",          "1",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxLeaderboardColumns",    "1",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxGamerPictures",         "1",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxProperties",            "2",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("minRichPresenceModes",     "2",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxParamsPerRPMode",       "2",    SPACReturnCode.FatalError),
                    new OverrideTestSetting("maxUniqueAchImages",       "2",    SPACReturnCode.FatalError)
                };

                return settingList;
            }
        }


        [TestCase]
        public class NoSpaAndHeaderSwitch : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting CompileBasicXLASTFile...");
                ResultCode = TEST_RESULTS.FAILED;

                uint titleId = 0xFFFFAB44;
                SPACReturnCode returnCode;

                CleanTempFiles(titleId);
                CopyInputFiles(titleId);

                // Compile the XLAST file into a SPA file and a header file
                _spac.XlastPath = Path.Combine(_tempPath, titleId.ToString("X8") + ".xlast");
                returnCode = _spac.Compile(true, true, true, true);
			
                ReportSPACResult(returnCode, "Compiling a Full Title XLAST file.", _spac.Output);

                if (returnCode == SPACReturnCode.Success || returnCode == SPACReturnCode.NonFatalError)
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    // Verify the existence of the SPA and SPA.H files
                    string outputFile = _spac.XlastPath.Replace(".xlast", ".spa");
                    if (File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate output SPA file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }

                    outputFile = _spac.XlastPath.Replace(".xlast", ".spa.h");
                    if (File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate output Header file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                }

                CleanTempFiles(titleId);
            }
        }


        [TestCase]
        public class UncompileSPAFile : SPACTestBase
        {
            protected override void Execute()
            {
                BeginCase("Starting UncompileXLASTFile...");
                ResultCode = TEST_RESULTS.FAILED;

                uint titleId = 0xFFFFAB45;
                string pngFile = "\\serenity.png";
                SPACReturnCode returnCode;

                CleanTempFiles(titleId);
                CleanUnCompileTempFolder();
                CopyInputFiles(titleId);

                // UnCompile the SPA file to XLAST and PNGs         
                _spac.SpaFile = Path.Combine(_tempPath, titleId.ToString("X8") + ".spa");
                _spac.UncompileOutputFile = Path.Combine(_unCompileOPPath, titleId.ToString("X8") + ".txt");
                returnCode = _spac.UnCompile();
                ReportSPACResult(returnCode, "UnCompiling a SPA file.", _spac.Output);

                if (returnCode == SPACReturnCode.Success || returnCode == SPACReturnCode.NonFatalError)
                {
                    ResultCode = TEST_RESULTS.PASSED;

                    // Verify the existence of the XLAST and PNG files
                    string outputFile = _spac.UncompileOutputFile.Replace(".spa", ".original.xlast");
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Error("Unable to locate output XLAST file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("XLAST file found!");
                    }

                    outputFile = String.Concat(_unCompileOPPath, pngFile);
                    if (!File.Exists(outputFile))
                    {
                        Global.RO.Info("Unable to locate output png  file: {0}", outputFile);
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        Global.RO.Info("PNG file found!");
                    }
                }
                CleanTempFiles(titleId);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\SPUTSuite.cs ===
using System;
using ServerTestFramework;

namespace SPUTTest
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\PositiveTests.cs ===
using System;
using ServerTestFramework;
using System.IO;

namespace SPUTTest
{
    /// <summary>
    /// Summary description for PositiveTests.
    /// </summary>
    [TestGroup, Owner("jkonkle"), TestFrequency("Regression"), TestCasePriority(1)]
    public class PositiveTests : TestNode
    {
        [TestCase, DVT]
        class BasicCase : SPUTTestBase
        {
            
            protected override void Execute()
            {
                TestTitleIDOnDefault("4D530027");
                TestTitleIDOnDefault("4D53");
                TestTitleIDOnDefault("FFFFFFFF");
                TestTitleIDOnDefault("0");
            }
        }

        [TestCase, DVT]
        class FileTest : SPUTTestBase
        {
            protected override void Execute()
            {
                bool pass=false;
                ResultCode = TEST_RESULTS.FAILED;
                string testFile = MakeTestFile(10, "FFFE07C3");
                
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                // First check the inside of file...
                sputTool.RunSPUTFile(testFile);
                pass=CheckFileResults(testFile, "FFFE07C3");
                // Now override with new titleid
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                sputTool.RunSPUTFile(testFile, "FFFFFFFF");
                pass=CheckFileResults(testFile, "FFFFFFFF") && pass;
                // Now reset to 0... test and cleanup
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                sputTool.RunSPUTFile(testFile, "0");
                pass=CheckFileResults(testFile, "0") && pass;
                if (pass)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sputtest_none_12.4.56.0_none_c685632b72329929
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sputtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1.manifest
XP_MANIFEST_PATH=manifests\msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1.cat
XP_CATALOG_PATH=manifests\msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1.cat
XP_PAYLOAD_PATH=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sputtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\NegativeTests.cs ===
using System;
using ServerTestFramework;
using System.IO;

namespace SPUTTest
{
	/// <summary>
	/// Summary description for NegativeTests.
	/// </summary>
    [TestGroup, Owner("jkonkle"), TestFrequency("Regression"), TestCasePriority(2)]
	public class NegativeTests : TestNode
	{
        [TestCase]
        class InvalidSwitch : SPUTTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                sputTool.RunSPUT("/sometitle");
                // Should just show help
                if (sputTool.Output.StartsWith("Specific Update Tool Usage:"))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                sputTool = null;
            }
        }

        [TestCase]
        class OnlyDumpSwitch : SPUTTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                sputTool.RunSPUT("/dump");
                // Should just show help with message
                if (sputTool.Output.StartsWith("You must pass either /dump /serialnum, /titleid /serialnum, or /file."))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                sputTool = null;
            }
        }

        [TestCase]
        class OnlyFileSwitch : SPUTTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                sputTool.RunSPUT("/file");
                // Should just show help with message
                if (sputTool.Output.StartsWith("You must pass a valid file to /file."))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                sputTool = null;
            }
        }    

        [TestCase]
        class WrongSizeTitleID : SPUTTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                sputTool.ChangeTitleID(consoleID, "FFFE1");
                // Should just show help with message
                if (sputTool.Output.StartsWith("The ID must be either 1"))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                sputTool = null;
            }
        }    

        [TestCase]
        class BadSerialNum : SPUTTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                sputTool.ChangeTitleID("XE.BADBADBADBAD", "0");
                // Should just show help with message
                if (sputTool.Output.StartsWith("Serial number"))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                sputTool = null;
            }
        }
     
        [TestCase]
        class EmptyFile : SPUTTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                string testFile = Path.Combine(tempPath, "empty.txt");
                if (File.Exists(testFile))
                {
                    File.Delete(testFile);
                }
                StreamWriter writer = File.CreateText(testFile);
                writer.Flush();
                writer.Close();
                sputTool.RunSPUTFile(testFile);
                // Should just show help with message
                if (sputTool.Output.Length == 0)
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                sputTool = null;
            }
        } 

        [TestCase]
        class GarbageFile : SPUTTestBase
        {
            protected override void Execute()
            {
                ResultCode = TEST_RESULTS.FAILED;
                sputTool = new ServerTestFramework.STFTools.SPUT();
                sputTool.SPUTPath = toolPath;
                string testFile = Path.Combine(tempPath, "empty.txt");
                if (File.Exists(testFile))
                {
                    File.Delete(testFile);
                }
                StreamWriter writer = File.CreateText(testFile);
                writer.WriteLine("LKSDFKLDSFJLKLSDFJLKJSDFJSDLFLJSDF");
                writer.WriteLine("LKSJDFKLSDFIONVOISDFJISLDFJLDSFJI SLFDJKSFD");
                writer.WriteLine("KJIOIDFJOSDFJNEI DJFSOISDF JOSDFID");
                writer.Flush();
                writer.Close();
                sputTool.RunSPUTFile(testFile);
                // Should just show help with message
                if (sputTool.Output.StartsWith("Missing"))
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }
                sputTool = null;
            }
        } 
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_sputtest_none_12.4.56.0_none_c685632b72329929
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=sputtest
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1.manifest
XP_MANIFEST_PATH=manifests\msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1.cat
XP_CATALOG_PATH=manifests\msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1.cat
XP_PAYLOAD_PATH=msil_sputtest_no-public-key_12.4.56.0_x-ww_28be9ff1
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=sputtest,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StatsStress\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StatsStress\StressCoordinator.cs ===
using System;
using System.Collections;
using System.Xml;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService.Stats.Util;
using ServerTestFramework.LiveService.Stats.StatsDBSim;




namespace StatsStress
{
	/// <summary>
	/// Summary description for StressCoordinator.
	/// </summary>
	/// 

	public class unitHelper
	{
		public ulong puid1=0;
		public ulong puid2=0;
		public ulong puid3=0;
		public ulong puid4=0;
		public unitHelper(ulong p1,ulong p2)
		{
			puid1=p1;
			puid2=p2;
		}
	}

	
	public class BaseReqType
	{
		public int Lbid=0;
		public int NoOfAttribs;
	}

	public class GetRequestType :BaseReqType
	{
		public bool rating = false;
		public bool rank = false;
		public bool Attachment= false;
		public bool NickName= false;
	}

	public class PostRequestType :BaseReqType
	{
		public bool IsUnitLB=false;
		public bool IsTeam=false;
		public bool HasElo=false;
		public bool HasCondition=false;
		public bool HasReplace=false;
		public bool HasIncrement=false;
		public bool HasMin=false;
		public bool HasMax=false;
		public bool HasMuSigma=false;
		
		
	};

	public class ReqTemplate
	{
		public uint titleID=0;
	

	}
	public class CompTemplate:ReqTemplate
	{
		public uint Templateid=0;
	

	}
	public class UnitGetReqTemplate :ReqTemplate
	{
		public bool isteam=false;
		public ArrayList GetRequests = new ArrayList(); // contains  BaseReqType
	}

	public class UnitEnumReqTemplate :ReqTemplate
	{
		public int[] Lbids=null;
		public int Lbid=0;
		public int NoOfAttribs=0;
		public uint SortFlag=0;
		public int Size=0;
		public bool IsTeam=false;
	}

	public class EnumReqTemplate :ReqTemplate
	{
		public bool IsXenon=false;
		public int[] Lbids=null;
		public int Lbid=0;
		public int NoOfAttribs=0;
		public bool IsUserPivote=false;
		public bool IsRatingPivote=false;
		public int Size=0;
		public bool rating =false;
		public bool Attachment= false;
		public bool NickName= false;
	}
	public class SetReqTemplate :ReqTemplate
	{
		public bool HasAttachments= false;
		public int[] UsersRange=null;
		public int NoOfUsers=0;
		public ArrayList SetRequests = new ArrayList();
		
		
	}

	public class GetReqTemplate :ReqTemplate
	{
		public int[] UsersRange=null;
		public int NoOfUsers=0;
		public ArrayList GetRequests = new ArrayList();
		public bool IsXenon =false;
	}

	public class PostReqTemplate :ReqTemplate
	{
		public bool HasAttachments= false;
		public int Arb_Direct=0; 
		public int NoOFTeam=0;
		public int NoOFPlayerUnits=0;
		public int[] UsersRange=null;
		public int NoOfUsers=0;
		public int NoOfTeamUnits=0;
		public ArrayList PostRequests = new ArrayList();
			
		
	}

    public class GetRankForRatingTemplate : ReqTemplate
    {
        public int[] Lbids = null;
        public int NumberRatings = 0;
    }
	

    [StressInstantiate]
	public abstract class StatsStressBase :TestBase
	{
		public RandomEx statsRandGen = new RandomEx();
		ulong _Mask =0;
		// use the following APi to  get puids to write to stats.	
	/*	protected ulong[] GetNextTeamUnit(uint title)
		{
			StressUserManager UserManager = StatsStressSupport.GetUserManager(title);
			return UserManager.GetTeamUnitToWrite();
			
		}
		
		
		protected ulong[] GetNextUnit(uint title)
		{
			StressUserManager UserManager = StatsStressSupport.GetUserManager(title);
			return UserManager.GetUnitToWrite();
						
		}
		*/

		protected ulong GetNextTeamUserPuid(uint title)
		{
			StressUserManager UserManager = StatsStressSupport.GetUserManager(title);
			return UserManager.GetTeamUserToWrite();
						
		}


		protected ulong GetNextUserPuid(uint title)
		{
			StressUserManager UserManager = StatsStressSupport.GetUserManager(title);

			return UserManager.GetUserToWrite();
			
		}
		
		
		
		
		protected Title GetTitle()
		{
			int titleindex= statsRandGen.Next(0,_Settings.Titles.Count-1);
			return (Title)_Settings.Titles[titleindex];
		}
		public long GetRating(int title)
		{
			//return (long)Interlocked.Increment(ref StatsStressSupport.Rating)%100000;
			long rating =0;
			TitleRating trating = null;

			if(StatsStressSupport.TitleRating.Contains(title))
			{
				trating = (TitleRating)StatsStressSupport.TitleRating[title];
			}

			if(title ==-1 || trating==null)
				rating =statsRandGen.Next(100,100000);
			else
			{
				rating =statsRandGen.Next(trating._LoRating+1,trating._HiRating);
			}
			return rating;
		}
		protected XrlSubAttr[] GetStatsAsXRL(int count,int title)
		{
			//ushort id , int/long/double value;
			XrlSubAttr[] stats = new XrlSubAttr[count];

			// add rating first.
			stats[0]= new XrlSubAttr(SpecialAttrib.Rating,(ulong)GetRating(title));
			stats[1]= new XrlSubAttr(SpecialAttrib.Nickname,statsRandGen.GenerateRandomString(8));
			for(int i=2;i<count;i++)
			{
				
				if(i%2 == 0)
					stats[i]=new XrlSubAttr((ushort)(i+1),(long)statsRandGen.NextUlong());
				else
					stats[i]=new XrlSubAttr((ushort)(i+1),(double)statsRandGen.NextDouble());

			}
			
			return stats;

		}

		

		protected object[] GetStats(int count,int title)
		{
			//ushort id , int/long/double value;
			object[] stats = new object[count*2];

			// first one is rating ....
			int i=0;
			stats[i++]=(short)SpecialAttrib.Rating;
			stats[i++]=(long)GetRating(title);
			
			int id=1;
			for(;i<count*2;i+=2)
			{
				stats[i]=(short)(id++);
				if(i%2 == 0)
					stats[i+1]=(long)statsRandGen.NextUlong();
				else
					stats[i+1]=(double)statsRandGen.NextDouble();

			}
			return stats;

		}

		protected ushort[] GetStatIds(int count,bool rating,bool rank,bool attachment,bool NickName)
		{
			//ushort id , int/long/double value;
			int addtionalAttribs=0;
			if  (rating)
				addtionalAttribs++;
			if(rank)
				addtionalAttribs++;
			if(attachment)
				addtionalAttribs++;
			if(NickName)
				addtionalAttribs++;

			int total = count+addtionalAttribs;

			ushort[] stats = new ushort[total];
			int i=0;

			if  (rating)
				stats[i++]=SpecialAttrib.Rating;
			if(rank)
				stats[i++]=SpecialAttrib.Rank;
			if(attachment)
				stats[i++]=SpecialAttrib.AttachmentPathName;
			if(NickName)
				stats[i++]=SpecialAttrib.Nickname;

			for(;i<total;i++)
			{
				stats[i]=(ushort)(i+1);
				
			}
			return stats;

		}


		public StressSettings _Settings;

		public StatsStressBase()
		{
			_Settings =StatsStressSupport.GetSettings();
			_Mask =(ulong)(_Settings.UserMask);//-_Settings.UserRange);
			
		}


	}
	

	public class  Leaderboard
	{
		public bool ISCompTemplate=false;
		public int id=0;
		public int serverindex=0;
		public int Type=-1;
		// Below flags are ignored if Type is Unit or UnitTeam
		public bool Attachments=false;
		public bool Lightweight=false;
				
		public enum lbtype
		{
			Player=1,
			Unit =2,
			Team=3,
			UnitTeam=4,
			
		}
		
	}

	public class Title
	{
		public int ID=0;
		public Hashtable Leaderboards= Hashtable.Synchronized(new Hashtable());
		
		public Title(int title)
		{
			ID=title;
		}
		public void AddLeaderboard(Leaderboard lb)
		{
			Leaderboards.Add(lb.id,lb);
		}
		
		public Leaderboard GetLBINfo(int Lbid)
		{
			return (Leaderboard)Leaderboards[Lbid];
		}
	}

	public enum typeofProcs
	{
		Replace=1,
		Increment=2,
		Condition=3,
		Elo=4
	}

	public enum TypeofRequests
	{
		users=1,
		Teams =2,
		Units=3,
		UnitsTeam=4
	}

	public enum HowToMakeRequest
	{
		Direct=1,
		Arbitration =2,
		
	}


	public class StressUserManager
	{
		protected StressSettings _Settings;
		protected long RegularUserIdx=0;
		protected long RegularTeamIdx=0;
		protected ReaderWriterLock Userrwl = new ReaderWriterLock();
		protected ReaderWriterLock Teamrwl = new ReaderWriterLock();
		protected ulong _Mask;

		public StressUserManager(StressSettings Settings)
		{
			_Settings = Settings;
			_Mask =(ulong)(_Settings.UserMask);//-_Settings.UserRange);
			 
		}

		public ulong GetUserToRead(long randomNo)
		{
			long tmp;
			try
			{
				Userrwl.AcquireReaderLock(-1);
				tmp = RegularUserIdx;
			}
			finally
			{
				Userrwl.ReleaseReaderLock();
			}
			return _Mask+(ulong)_Settings.UserStartIndex+(ulong)(randomNo%tmp);
		}
		public ulong GetUserToWrite()
		{
			long tmp;
			try
			{
				Userrwl.AcquireWriterLock(-1);
				tmp = RegularUserIdx++;
			}
			finally
			{
				Userrwl.ReleaseWriterLock();
			}
			return _Mask+_Settings.UserStartIndex+((ulong)tmp %_Settings.UserCuncurrency);
		}

		public ulong GetTeamUserToRead(long randomNo)
		{
			long tmp;
			try
			{
				Teamrwl.AcquireReaderLock(-1);
				tmp = RegularTeamIdx;
			}
			finally
			{
				Teamrwl.ReleaseReaderLock();
			}
			return 0xFE00000000000000+_Settings.UserStartIndex+(ulong)(randomNo%tmp);;
		}
		public ulong GetTeamUserToWrite()
		{
			long tmp;
			try
			{
				Teamrwl.AcquireWriterLock(-1);
				tmp = RegularTeamIdx++;
			}
			finally
			{
				Teamrwl.ReleaseWriterLock();
			}
			return 0xFE00000000000000+_Settings.UserStartIndex+((ulong)tmp %_Settings.UserCuncurrency);;
		}

	}
	
	public class TitleRating
	{
		public int _LoRating=0;
		public int _HiRating=0;
		public TitleRating(int LowRating,int HiRating)
		{
			_LoRating = LowRating;
			_HiRating = HiRating;
		}

	}


	public class StatsStressSupport
	{
		static public bool ParseResponse=false;
		static public ulong UMask=0;
		static public StressCoordinator StressInit = new StressCoordinator();
		static public long UserCounter=0;
		static public long TeamCounter=0;
		static public long Rating=0;
		static public long count=0;
		static protected Hashtable SynctitleLbMap= new Hashtable();
		static protected Hashtable CompLbMap= Hashtable.Synchronized(new Hashtable());
		static protected Hashtable UsermanagerFortitles=new Hashtable();
		static public Hashtable TitleRating= new Hashtable();

		static public int GetCount()
		{
			return (int)Interlocked.Increment(ref count);
		}

		static public void Init()
		{
            StressInit.Init();
		    UMask =(ulong)(StressInit._Settings.UserMask); //-StressInit._Settings.UserRange);
		}

		static public System.Collections.Generic.List<TestNode> GetStressTestList()
		{
			return StressInit.Tests;
		}

		static public uint GetCompLB(uint title,uint templateid)
		{
			uint lbid=0;
			TitleLbKey key = new TitleLbKey(title,templateid);
			if(CompLbMap.Contains(key))
			{
				Queue lbQueue= (Queue)CompLbMap[key];
				if(lbQueue.Count>1)
					lbid = (uint) lbQueue.Dequeue();
				
			}
			return lbid;

		}
		static public void AddCompLB(uint title,uint templateid,uint lbid)
		{
			Queue lbQueue=null;
			TitleLbKey key = new TitleLbKey(title,templateid);
			if(CompLbMap.Contains(key))
			{
				lbQueue= (Queue)CompLbMap[key];
				
			}
			else
			{
				lbQueue =Queue.Synchronized(new Queue());
				CompLbMap.Add(key,lbQueue);
			}

			lbQueue.Enqueue(lbid);
			
			
		}

		
		static public StressSettings GetSettings()
		{
			return StressInit._Settings;
		}


		static public ReqTemplate GetReqTemplate(string name)
		{
			ReqTemplate template= (ReqTemplate)StressInit.HTStressCases[name];
			return template;
		}

		public static int  GetRecCount(uint title,uint Lbid)
		{
			int count=0;
			TitleLbKey key = new TitleLbKey(title,Lbid);
			if(SynctitleLbMap.Contains(key))
			{
				PuidMap tmp= (PuidMap)SynctitleLbMap[key];
				count= tmp.GetCount();
			}
			return count;
		}

		public static void  RefreshPuidList()
		{
			foreach(TitleLbKey key in SynctitleLbMap.Keys)
			{
				PuidMap tmp= (PuidMap)SynctitleLbMap[key];
				ulong startPuid =0;
				if(tmp.Isteam)
					startPuid= 0xFE00000000000000+StressInit._Settings.UserStartIndex+1;
				else
				{	//+StressInit._Settings.UnitUserRange
					startPuid= UMask+StressInit._Settings.UserStartIndex+1;
				}
			
				tmp.Clean(startPuid,(int)StressInit._Settings.NoOFUsersToRotatePerMin);
			}
		}

		public static ulong  GetPuid(uint title,uint Lbid,int randomNo)
		{
			ulong retpuid =0;
			TitleLbKey key = new TitleLbKey(title,Lbid);
					
			if(SynctitleLbMap.Contains(key))
			{
				PuidMap tmp= (PuidMap)SynctitleLbMap[key];
				retpuid =tmp.GetPuid(randomNo);
				
			}
			return retpuid;
		}
	
		public static void  SetPuid(uint title,uint Lbid,ulong puid,bool isteam)
		{
			TitleLbKey key = new TitleLbKey(title,Lbid);
			PuidMap tmp;
			
			if(!SynctitleLbMap.ContainsKey(key))
			{
				lock(SynctitleLbMap)
				{
					if(!SynctitleLbMap.ContainsKey(key))
					{
						tmp= new PuidMap();
						tmp.Isteam=isteam;
						SynctitleLbMap.Add(key,tmp);
					}
					else
						tmp= (PuidMap)SynctitleLbMap[key];
				}
			}
			else
				tmp= (PuidMap)SynctitleLbMap[key];

			tmp.AddPuid(puid);
		}



		//UsermanagerFortitles

		public static StressUserManager  GetUserManager(uint title)
		{
			
			StressUserManager tmp;
			
			if(!UsermanagerFortitles.ContainsKey(title))
			{
				lock(UsermanagerFortitles)
				{
					if(!UsermanagerFortitles.ContainsKey(title))
					{
						tmp= new StressUserManager(StressInit._Settings);
						UsermanagerFortitles.Add(title,tmp);
					}
					else
						tmp= (StressUserManager)UsermanagerFortitles[title];
				}
			}
			else
				tmp= (StressUserManager)UsermanagerFortitles[title];

			return tmp;
		}
		



	}

	
	public class PuidMap
	{
		protected int NoOfPuids =0;
		protected SortedList  puids = new  SortedList();
		protected ReaderWriterLock rwl = new ReaderWriterLock();
		public bool Isteam= false;

		public int GetCount()
		{
			return NoOfPuids;
		}

		public void AddPuid(ulong puid)
		{
			try
			{
				
				rwl.AcquireWriterLock(-1);
				if(!puids.Contains(puid))
				{
					puids.Add(puid,puid);
					NoOfPuids =puids.Count;
				}
			
				
			}
			catch(System.Exception e)
			{
				System.Console.WriteLine(e);
			}
			finally
			{
				rwl.ReleaseWriterLock();
			}
		}

		public ulong GetPuid(int randomNo)
		{
			ulong retpuid=0;
			int idx= (puids==null)?-1:randomNo%NoOfPuids;
			if(idx>=0)
			{
				try
				{
					rwl.AcquireReaderLock(-1);
					retpuid=(ulong) puids.GetByIndex(idx);
				}
				catch(System.Exception e)
				{
					System.Console.WriteLine(e);
				}
				finally
				{
					rwl.ReleaseReaderLock();
				}
			}
			
			return retpuid;
		}

		public void Clean(ulong StartP ,int NoOFUsersToRotatePerMin)
		{
			if(NoOfPuids>10000)
			{
				try
				{
					rwl.AcquireWriterLock(-1);
					if(puids ==null) return;
					int i=0;
					for ( ;i<puids.Count && i< NoOFUsersToRotatePerMin ;i++)
					{
						ulong tmp = (ulong)puids.GetByIndex(i);
						if(tmp <StartP)
							puids.Remove(tmp);
						else
							break;

					}
					NoOfPuids = puids.Count;
					System.Console.WriteLine( "Cleaned" +i+" Puids");
				}
				catch(System.Exception e)
				{
					System.Console.WriteLine(e);
				}
				finally
				{
					rwl.ReleaseWriterLock();
				}
			}
		}
	}

	
	

	public class StressSettings
	{
		public Hashtable Titles= Hashtable.Synchronized(new Hashtable()); // key titleid type int
		public bool RunVerifyThread= false;
		public ulong UserRange;
		//public ulong UnitUserRange;
		public ulong UserMask;
		public  ulong UserCuncurrency;
		public bool CreateLB=false;
		public  ulong UserStartIndex=0;
		public ulong NoOFUsersToRotatePerMin;
		
	}



	public class StressCoordinator
	{
		public StressSettings _Settings = new StressSettings();
		public Hashtable HTStressCases = new Hashtable();
		public System.Threading.Timer tmr;
		public bool complete=false;
		public System.Collections.Generic.List<TestNode> Tests = new System.Collections.Generic.List<TestNode>();

		public StressCoordinator()
		{
			tmr = new System.Threading.Timer(new TimerCallback(RotateUsers), null,60000, 60000);
		}

		void RotateUsers(Object state)
		{
			
			if(!complete)
			{
				ulong total = _Settings.UserStartIndex+_Settings.NoOFUsersToRotatePerMin;
				if(total <=(_Settings.UserRange-(_Settings.UserCuncurrency)))
				{
					lock(_Settings)
					{
						_Settings.UserStartIndex =_Settings.UserStartIndex+_Settings.NoOFUsersToRotatePerMin;
					}
				}
				else
				{
					lock(_Settings)
					{
						_Settings.UserStartIndex =0;
					}
				//	complete=true;

				}
			}

			StatsStressSupport.RefreshPuidList();

			System.Console.WriteLine("Rotating users current index = "+_Settings.UserStartIndex);
		}

		protected int getInt(string val)
		{
			return (int)Convert.ToUInt32(val);
		}
		protected int[] getLBs(string val)
		{
			int [] temp = null; 
			//the user will be in format '4-6' that ie the user count will be randomly chossen between 4 to 6
			string[] values =val.Split(new char[]{','});
			temp= new int[values.Length];
			for(int i=0;i<values.Length;i++)
				temp[i]= getInt(values[i]);
			

			return temp;
		}

		protected int[] getUsers(string val)
		{
			int [] temp = null; 
			//the user will be in format '4-6' that ie the user count will be randomly chossen between 4 to 6
			string[] values =val.Split(new char[]{'-'},2);
			if(values.Length==2)
			{
				temp= new int[2];
				temp[0]= getInt(values[0]);
				temp[1]= getInt(values[1]);
			}

			return temp;
		}

		protected long getLong(string val)
		{
			return Convert.ToInt64(val);
		}

		protected double getFloat(string val)
		{
			return Convert.ToDouble(val);
		}


        protected GetRankForRatingTemplate LoadGetRankForRatingTemplateConfig(XmlNode Case, Title title)
        {
            GetRankForRatingTemplate tmp = new GetRankForRatingTemplate();
            tmp.titleID = (uint)title.ID;

            tmp.Lbids = getLBs(Case.Attributes["LBID"].Value);
            //check if leaderboard exists 
            for (int i = 0; i < tmp.Lbids.Length; i++)
            {
                Leaderboard lb = (Leaderboard)title.Leaderboards[(int)tmp.Lbids[i]];
                if (lb == null)
                {
                    System.Console.WriteLine("Leaderboard id=" + tmp.Lbids[i] + " does not exist in title" + title.ID);
                }
            }


            tmp.NumberRatings = getInt(Case.Attributes["NumberRatings"].Value);



            return tmp;
        }

		protected EnumReqTemplate LoadWebEnumConfig(XmlNode Case,Title title)
			{
				EnumReqTemplate tmp= new EnumReqTemplate();
				tmp.titleID =(uint)title.ID;
			
				tmp.Lbids =getLBs(Case.Attributes["LBID"].Value);
				//check if leaderboard exists 
				for( int i=0;i<tmp.Lbids.Length;i++)
				{
					Leaderboard lb=	(Leaderboard) title.Leaderboards[(int)tmp.Lbids[i]];
					if(lb==null)
					{
						System.Console.WriteLine("Leaderboard id="+tmp.Lbid +" does not exist in title"+title.ID );
					}
				}
				if(tmp.Lbids.Length==1)
					tmp.Lbid= tmp.Lbids[0];
				
				if(Case.Attributes["Pivote"].Value=="User")
					tmp.IsUserPivote=true;

				tmp.Size =getInt(Case.Attributes["Size"].Value);

				
			
				return tmp;
			}

		

		protected EnumReqTemplate LoadUserEnumConfig(XmlNode Case,Title title,bool IsXenon)
		{
			EnumReqTemplate tmp= new EnumReqTemplate();
			tmp.IsXenon=IsXenon;
			tmp.titleID =(uint)title.ID;

			tmp.Lbids =getLBs(Case.Attributes["LBID"].Value);
			//check if leaderboard exists 
			for( int i=0;i<tmp.Lbids.Length;i++)
			{
				Leaderboard lb=	(Leaderboard) title.Leaderboards[(int)tmp.Lbids[i]];
				if(lb==null)
				{
					System.Console.WriteLine("Leaderboard id="+tmp.Lbids[i]+" does not exist in title"+title.ID );
				}
			
				if(tmp.Lbids.Length==1)
					tmp.Lbid= tmp.Lbids[0];
			
				tmp.NoOfAttribs =getInt(Case.Attributes["Stats"].Value);
				if(Case.Attributes["Pivote"].Value=="User")
					tmp.IsUserPivote=true;
				if(Case.Attributes["Pivote"].Value=="Rating")
					tmp.IsRatingPivote=true;

				tmp.Size =getInt(Case.Attributes["Size"].Value);

				if(Case.Attributes["Rating"].Value=="Y")
					tmp.rating=true;
				if(lb.Attachments)
					tmp.Attachment=true;

				if(Case.Attributes["NickName"]!=null&& Case.Attributes["NickName"].Value=="Y")
					tmp.NickName=true;
			}

			return tmp;
		}

		
		protected CompTemplate LoadCompetitionConfig(XmlNode Case,Title title)
		{
			CompTemplate temp= new CompTemplate();
			temp.titleID= (uint)title.ID;

			int TemplateID =getInt(Case.Attributes["TPID"].Value);
			temp.Templateid=(uint)TemplateID; 

			return temp;
		}

		/*
		protected UnitEnumReqTemplate LoadUnitEnumConfig(XmlNode Case,Title title)
		{
			UnitEnumReqTemplate tmp = new UnitEnumReqTemplate();

			tmp.titleID= (uint)title.ID;

			tmp.Lbids =getLBs(Case.Attributes["LBID"].Value);
			//int lbid =getInt(Case.Attributes["LBID"].Value);
			//check if leaderboard exists 
			for( int i=0;i<tmp.Lbids.Length;i++)
			{
				Leaderboard lb=	(Leaderboard) title.Leaderboards[(int)tmp.Lbids[i]];
				if(lb==null)
				{
					System.Console.WriteLine("Leaderboard id="+tmp.Lbids[i] +" does not exist in title"+title.ID );
				}
				if(tmp.Lbids.Length==1)
					tmp.Lbid= tmp.Lbids[0];
											
				tmp.NoOfAttribs = getInt(Case.Attributes["Stats"].Value);
				tmp.Size = getInt(Case.Attributes["Size"].Value);
				string sortflag= Case.Attributes["SortBy"].Value;
				if(sortflag=="Activity")
					tmp.SortFlag=UnitEnumFlags.SortActivity;
				else
					tmp.SortFlag=UnitEnumFlags.SortRating;
				if(lb.Type==(int)Leaderboard.lbtype.UnitTeam)
					tmp.IsTeam=true;
			}

			return tmp;

		}
		protected UnitGetReqTemplate LoadUnitGetConfig(XmlNode Case,Title title)
		{
			UnitGetReqTemplate tmp= new UnitGetReqTemplate();
			tmp.titleID= (uint)title.ID;

			if(Case.Attributes["IsTeam"].Value=="True")
				tmp.isteam =true;

			XmlNodeList Reads = Case.ChildNodes;
			for(int i=0 ; i< Reads.Count;i++)
			{
				
				if(Reads[i].Name=="LB")
				{
					int lbid =getInt(Reads[i].Attributes["LBID"].Value);
					//check if leaderboard exists 
					Leaderboard lb=	(Leaderboard) title.Leaderboards[lbid];
					if(lb==null)
					{
						System.Console.WriteLine("Leaderboard id="+lbid +" does not exist in title"+title.ID );
					}
					
					BaseReqType Req= new  BaseReqType();
					Req.Lbid=lbid;
							
					Req.NoOfAttribs = getInt(Reads[i].Attributes["Stats"].Value);

					tmp.GetRequests.Add(Req);
				

				}
				else
					System.Console.WriteLine("Invalid Tag");
			}
			return tmp;
		}

		*/
		protected GetReqTemplate LoadUserGetConfig(XmlNode Case,Title title,bool IsXenon)
		{
			GetReqTemplate tmp= new GetReqTemplate();
			tmp.IsXenon=IsXenon;
			tmp.titleID =(uint)title.ID;
			int[] uRange =getUsers(Case.Attributes["NoOfUsers"].Value);
			if(uRange==null)
				tmp.NoOfUsers= getInt(Case.Attributes["NoOfUsers"].Value);
			else
				tmp.UsersRange=uRange;
			XmlNodeList Reads = Case.ChildNodes;
			for(int i=0 ; i< Reads.Count;i++)
			{
				
				if(Reads[i].Name=="LB")
				{
					int lbid =getInt(Reads[i].Attributes["LBID"].Value);
					//check if leaderboard exists 
					Leaderboard lb=	(Leaderboard) title.Leaderboards[lbid];
					if(lb==null)
					{
						System.Console.WriteLine("Leaderboard id="+lbid +" does not exist in title"+title.ID );
					}

					GetRequestType Req= new  GetRequestType();
					Req.Lbid=lbid;

					if(lb.Attachments)
						Req.Attachment=true;
					
					if(Reads[i].Attributes["Rating"].Value=="Y")
						Req.rating=true;

					if(Reads[i].Attributes["Rank"].Value=="Y")
						Req.rank=true;

					if(Reads[i].Attributes["NickName"]!=null&& Reads[i].Attributes["NickName"].Value=="Y")
						Req.NickName=true;


					Req.NoOfAttribs = getInt(Reads[i].Attributes["Stats"].Value);

					tmp.GetRequests.Add(Req);
				

				}
				else
					System.Console.WriteLine("Invalid Tag");
			}
			return tmp;

		}
		

		protected SetReqTemplate LoadSetConfig(XmlNode Case,Title title)
		{
			SetReqTemplate tmp = new SetReqTemplate();
			
			tmp.titleID =(uint)title.ID;

			int[] uRange =getUsers(Case.Attributes["NoOfUsers"].Value);
			if(uRange==null)
				tmp.NoOfUsers= getInt(Case.Attributes["NoOfUsers"].Value);
			else
				tmp.UsersRange=uRange;

			
            XmlNodeList Writes = Case.ChildNodes;

			for(int i=0 ; i< Writes.Count;i++)
			{
				if(Writes[i].Name=="LB")
				{
					int lbid =getInt(Writes[i].Attributes["LBID"].Value);
					//check if leaderboard exists 
					Leaderboard lb=	(Leaderboard) title.Leaderboards[lbid];
					if(lb==null)
					{
						System.Console.WriteLine("Leaderboard id="+lbid +" does not exist in title"+title.ID );
					}
					BaseReqType Req = new  BaseReqType();
					Req.Lbid =lbid;
					if(lb.Attachments)
					{
						tmp.HasAttachments=true;
					}
					Req.NoOfAttribs = getInt(Writes[i].Attributes["Stats"].Value);
					tmp.SetRequests.Add(Req);
				}
				else
					System.Console.WriteLine("Invalid Tag expected <LBS>");
			}
			return tmp;

		}


		protected PostReqTemplate LoadPostConfig(XmlNode Case, Title title)
		{
			
			PostReqTemplate tmp= new PostReqTemplate();
			string sendtype =Case.Attributes["SendTpye"].Value;
			tmp.titleID =(uint)title.ID;

			if(sendtype=="A")
				tmp.Arb_Direct=(int)HowToMakeRequest.Arbitration;
			else if(sendtype=="D")
				tmp.Arb_Direct=(int)HowToMakeRequest.Direct;

			int[] uRange =getUsers(Case.Attributes["NoOfUsers"].Value);
			if(uRange==null)
				tmp.NoOfUsers= getInt(Case.Attributes["NoOfUsers"].Value);
			else
				tmp.UsersRange=uRange;

			tmp.NoOFTeam =getInt(Case.Attributes["NoOfTeams"].Value);
			tmp.NoOFPlayerUnits =getInt(Case.Attributes["NoOfPlayerUnits"].Value);
			tmp.NoOfTeamUnits =getInt(Case.Attributes["NoOfTeamUnits"].Value);

			XmlNodeList Procs = Case.ChildNodes;
			for(int i=0 ; i< Procs.Count;i++)
			{
				PostRequestType req = new PostRequestType();

				int lbid =getInt(Procs[i].Attributes["LBID"].Value);
				//check if leaderboard exists 
				Leaderboard lb=	(Leaderboard) title.Leaderboards[lbid];
				if(lb==null)
				{
					System.Console.WriteLine("Leaderboard id="+lbid +" does not exist in title"+title.ID );
				}
				req.Lbid =lb.id;

				if(lb.Type ==(int)Leaderboard.lbtype.Unit)
					req.IsUnitLB=true;
				else if(lb.Type ==(int)Leaderboard.lbtype.Team)
					req.IsTeam=true;
				else if(lb.Type ==(int)Leaderboard.lbtype.UnitTeam)
				{
					req.IsUnitLB=true;
					req.IsTeam=true;
				}
				
				if(lb.Attachments)
					tmp.HasAttachments=true;
				if(Procs[i].Name=="MuSigma" )
				{
					req.HasMuSigma=true;
				}
				else if(Procs[i].Name=="ELO" || Procs[i].Name=="Condition_ELO")
				{
					if(Procs[i].Name=="Replace")
					{
						req.HasElo=true;			
					}
					else
						req.HasCondition=true;	
					
				}
				else
				{
					req.NoOfAttribs =getInt(Procs[i].Attributes["Stats"].Value);
									
					if(Procs[i].Name=="Replace")
					{
						req.HasReplace=true;	
												
					}
					else if(Procs[i].Name=="Increment")
					{
						req.HasIncrement=true;
					}
					else if(Procs[i].Name=="MuSigma")
					{
						req.HasMuSigma=true;
					}
					else if(Procs[i].Name=="Min")
					{
						req.HasMin=true;
					}
					else if(Procs[i].Name=="Max")
					{
						req.HasMax=true;
					}
					else if(Procs[i].Name=="Condition_Replace")
					{
						req.HasCondition=true;
						req.HasReplace=true;	
					}
					else if(Procs[i].Name=="Condition_Increment")
					{
						req.HasCondition=true;
						req.HasIncrement=true;
					}
					else
					{
						System.Console.WriteLine("Error Unknown Node "+Procs[i].Name);
					}
					
				}
				
				tmp.PostRequests.Add(req);
			}
			return tmp;
		}
		
		protected void LoadStatsTestCase(XmlDocument config )
		{
			
			XmlNodeList StressCases = config.DocumentElement["StressCases"].ChildNodes;

			for(int i=0 ; i< StressCases.Count;i++)
			{
				//skip comments
				if(StressCases[i].Name == "#comment") {
					continue;
				}
				if(StressCases[i].Name == "StressCase")
				{
					bool IsXenon=false;
					ReqTemplate tmp= null;
					int titleid =getInt(StressCases[i].Attributes["Title"].Value);
					
					// check if title exists.
					Title _title= (Title)_Settings.Titles[titleid];
					string Name= StressCases[i].Attributes["Name"].Value;
					string Type = StressCases[i].Attributes["Type"].Value;
					string tmpflg= StressCases[i].Attributes["IsXenon"]!=null?StressCases[i].Attributes["IsXenon"].Value:"";
					if(tmpflg=="true")
						IsXenon=true;
					

					if(!HTStressCases.Contains(Name))
					{
						if( Type =="Post")
						{
							tmp = LoadPostConfig(StressCases[i],_title);
                            TestNode n=new StatsPost();
                            Tests.Add(n);
                            n.Name=Name;
						}
						else if(Type =="StatsSet")
						{
							tmp = LoadSetConfig(StressCases[i],_title);
                            TestNode n=new StatsSet();
                            Tests.Add(n);
                            n.Name=Name;
						}
						else if(Type =="StatsGet")
						{
							tmp = LoadUserGetConfig(StressCases[i],_title,IsXenon);
                            TestNode n=new StatsGet();
                            Tests.Add(n);
                            n.Name=Name;
						}
						else if(Type =="StatsEnum")
						{
							tmp = LoadUserEnumConfig(StressCases[i],_title,IsXenon);
                            TestNode n=new StatsEnum();
                            Tests.Add(n);
                            n.Name=Name;
						}
						else if(Type =="StatsWebEnum")
						{
							tmp = LoadWebEnumConfig(StressCases[i],_title);
                            TestNode n=new StatsWebEnum();
                            Tests.Add(n);
                            n.Name=Name;
						}
						else if(Type =="CreateCompLB")
						{
							tmp = LoadCompetitionConfig(StressCases[i],_title);
                            TestNode n=new StatsCompCreate();
                            Tests.Add(n);
                            n.Name=Name;
						}
						else if(Type =="DeleteCompLB")
						{
							tmp = LoadCompetitionConfig(StressCases[i],_title);
                            TestNode n=new StatsCompDelete();
                            Tests.Add(n);
                            n.Name=Name;
						}
                        else if (Type == "GetRankForRating")
                        {
                            tmp = LoadGetRankForRatingTemplateConfig(StressCases[i], _title);
                            TestNode n=new GetRankForRating();
                            Tests.Add(n);
                            n.Name=Name;
                        }
						
					}
					
					if(tmp!=null)
					{
						HTStressCases.Add(Name,tmp);
					}
					
				}
				else
					System.Console.WriteLine("unknown node "+StressCases[i].Name);
			}
			

		}

		
		public void LoadTitles(XmlDocument config)
		{
			XmlNodeList titles = config.DocumentElement["Titles"].ChildNodes;
			for(int i=0 ; i< titles.Count;i++)
			{
				//skip comments.
				if (titles[i].Name == "#comment") {
					continue;
				}
				if(titles[i].Name !="Title")
				{
					System.Console.WriteLine("Invalid node in titles group");
					continue;
				}
				Title temptitle = new Title(getInt(titles[i].Attributes["id"].Value));

				XmlNodeList LBs = titles[i].ChildNodes;

				for( int j=0;j< LBs.Count;j++)
				{
					if(LBs[j].Name =="LB" || LBs[j].Name =="CompTp")
					{
						//
						Leaderboard lb= new Leaderboard();
						if(LBs[j].Name =="CompTp")
						{
							lb.id= getInt(LBs[j].Attributes["Tpid"].Value);
							lb.ISCompTemplate=true;
						}
						else
							lb.id= getInt(LBs[j].Attributes["id"].Value);

						string type =LBs[j].Attributes["Type"].Value;
						if( type== "User" || type == "Team" )
						{
							if(type== "User")
								lb.Type = (int)Leaderboard.lbtype.Player;
							else if(type== "Team")
								lb.Type = (int)Leaderboard.lbtype.Team;

							if(LBs[j].Attributes["Attachments"].Value=="Y")
								lb.Attachments=true;
							if(LBs[j].Attributes["LightWT"].Value=="Y")
								lb.Lightweight=true;

							if(LBs[j].Name =="LB")
								lb.serverindex=getInt(LBs[j].Attributes["Partition"].Value);
								
						}
						else if(type== "Unit" || type == "UnitTeam" )
						{
							if(type== "Unit")
								lb.Type = (int)Leaderboard.lbtype.Unit;
							else if(type== "UnitTeam")
								lb.Type = (int)Leaderboard.lbtype.UnitTeam;
						}
						else
							System.Console.WriteLine("Unknown Leaderboard type ID"+lb.id);
						temptitle.AddLeaderboard(lb);
					}
					else if(LBs[j].Name =="Rating")
					{
						
						int low = getInt(LBs[j].Attributes["Low"].Value);
						int Hi = getInt(LBs[j].Attributes["Hi"].Value);
						TitleRating tmp = new TitleRating(low,Hi);
						lock(StatsStressSupport.TitleRating)
						{
							StatsStressSupport.TitleRating.Add(temptitle.ID,tmp);
						}

					}
					else
						System.Console.WriteLine("Unknown node in Title"+temptitle.ID+" expected LB node");
				}
				_Settings.Titles.Add(temptitle.ID,temptitle);
			}

		}

		public void Init()
		{
			XmlDocument config = new XmlDocument();
			config.Load("StatsStressConfig.xml");
			
			LoadTitles(config);

			LoadStatsTestCase(config);
			

			XmlNode Verify  = config.DocumentElement["RunVerifyThread"];
			if(Verify.Attributes["value"].Value=="true")
				_Settings.RunVerifyThread= true;

			XmlNode CreateLB  = config.DocumentElement["CreateLB"];
			if(CreateLB.Attributes["value"].Value=="true")
				_Settings.CreateLB= true;

			_Settings.UserRange =(ulong)getLong(config.DocumentElement["UserRange"].Attributes["val"].Value);
			//_Settings.UnitUserRange =(ulong)getLong(config.DocumentElement["UnitRange"].Attributes["val"].Value);
			_Settings.UserMask =(ulong)Convert.ToInt64(config.DocumentElement["BaseUserMask"].Attributes["val"].Value,16);
			_Settings.NoOFUsersToRotatePerMin =(ulong)getLong(config.DocumentElement["NoOFUsersToRotatePerMin"].Attributes["val"].Value);
			_Settings.UserCuncurrency =(ulong)getLong(config.DocumentElement["UserCuncurrency"].Attributes["val"].Value);

			
		
		}

		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\SPUTTest\SPUTTestBase.cs ===
using System;
using ServerTestFramework;
using System.Xml;
using System.Reflection;
using System.IO;
using System.Data.SqlClient;

using Microsoft.Webstore.WstClient;
using xonline.common.sql.webstore;
using xonline.common.config;


namespace SPUTTest
{
	/// <summary>
	/// Base class for SPUT Tests...
	/// </summary>
	abstract public class SPUTTestBase : TestBase
	{
        protected static string toolPath="";
        protected ServerTestFramework.STFTools.SPUT sputTool = null;

        /// <summary>Path to the input files</summary>
        protected string inputFilePath="";
        /// <summary>Temp file path</summary>
        protected string tempPath = "";
        /// <summary>Console ID that we will use to test.  Needs to be in t_machines in UODB already.  Should be prefexed with XE.</summary>
        protected string consoleID = "";
        

		public SPUTTestBase()
		{
            if (toolPath=="" || inputFilePath=="")
            {
                ReadConfig();
            }
            
		}

        /// <summary>
        /// Fills the variables with the values from the LiveMatchTest.xml
        /// </summary>
        protected void ReadConfig()
        {
            XmlNode config = Global.Config.SelectSingleNode("descendant::SPUTTest");

            if (config != null)
            {
                XmlNode node = config.SelectSingleNode("DefaultToolPath");
                if (node != null)
                {
                    toolPath=System.IO.Path.Combine(node.InnerText, "SPUT.exe"); 
                }
                node = config.SelectSingleNode("InputFilePath");
                if (node != null)
                {
                    inputFilePath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), node.InnerText);
                }
                node = config.SelectSingleNode("TempDirectoryPath");
                if (node != null)
                {
                    tempPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), node.InnerText);
                }
                node = config.SelectSingleNode("ConsoleID");
                if (node != null)
                {
                    consoleID =  node.InnerText;
                }
            }
        }

        protected TEST_RESULTS TestTitleIDOnDefault(string titleID)
        {
            string output;

            ResultCode = TEST_RESULTS.FAILED;
            Global.RO.Info(String.Format("Testing with TitleID: {0}", titleID));
            sputTool = new ServerTestFramework.STFTools.SPUT();
            sputTool.SPUTPath = toolPath;
            sputTool.ChangeTitleID(consoleID, titleID);
            Global.RO.Info(String.Format("Changed TitleID: {0}", titleID));
            output=sputTool.DumpTitleID(consoleID);
            Global.RO.Info(String.Format("Returned TitleID: {0}", output));
            titleID=string.Concat("0x", titleID.ToLower());
            if (output == titleID)
            {
                ResultCode = TEST_RESULTS.PASSED;
            }
            sputTool = null;
            return ResultCode;
        }

        /// <summary>
        /// Creates a file with Serial Nums from UODB
        /// </summary>
        /// <remarks>This function creates a file of serial numbers that exist in the UODB in t_machines.  
        /// The numEntries specifies how many are to be retrieved.  The titleID is what gets set in the file.
        /// Only rows that are null or 0 are returned so we don't over-write anything that exists already.
        /// </remarks>
        /// <param name="numEntries">Number of rows to grab from the database</param>
        /// <param name="titleID">TitleID to set in the result file.</param>
        /// <returns>Name and path of the created file.</returns>
        protected string MakeTestFile(int numEntries, string titleID)
        {
            string outStr;
            // Make sure our path is there...
            Directory.CreateDirectory(tempPath);
            // Set the file...
            string testFile = Path.Combine(tempPath,"TestFile.csv");
            // if it is there already, get rid of it...
            if (File.Exists(testFile))
            {
                File.Delete(testFile);
            }

            // Get the UODB and get the recordset from it...
            string sql = String.Format("Select top {0} vc_serial_num from t_machines where i_beta_title_id=0 or i_beta_title_id is null", numEntries);

		using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            	{
              	ws.PartitionType = WstPartitionType.Logical;
       	       ws.Partition = WstCommand.AnyPartition;
	              ws.CommandSql = sql;
			
		       StreamWriter writer = File.CreateText(testFile);
		   using (WstDataReader reader = ws.Execute())
                {
		       while (reader.Read())
		       {
		            if (titleID != "")
		            {
		                outStr = String.Format("{0}, {1}",reader.GetString(0), titleID);
		            }
		            else
		            {
		                outStr = reader.GetString(0);
		            }
		            writer.WriteLine(outStr);
		        }
	            reader.Close();
		   	}
		
            //Clean up
            writer.Flush();
            writer.Close();
		}
            return testFile;
        }

        protected bool CheckFileResults(string testFile, string titleID)
        {
            bool pass = false;
            string output;

            sputTool = new ServerTestFramework.STFTools.SPUT();
            sputTool.SPUTPath = toolPath;

            StreamReader reader = File.OpenText(testFile);
            string line;
            string consoleID;
            pass = true;
            while ((line=reader.ReadLine()) != null)
            {
                if (line.IndexOf(",") > 0)
                {
                    consoleID=line.Substring(0, line.IndexOf(","));
                }
                else
                {
                    consoleID=line;
                }
                output=sputTool.DumpTitleID(consoleID);
                Global.RO.Info(String.Format("Returned TitleID: {0}", output));
            
                pass = (output == string.Concat("0x", titleID.ToLower())) && pass;
            }
            sputTool = null;
            return pass;
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StatsStress\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_statsstress_none_12.4.56.0_none_3852f8a9b14ba550
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=statsstress
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276.manifest
XP_MANIFEST_PATH=manifests\msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276.cat
XP_CATALOG_PATH=manifests\msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276.cat
XP_PAYLOAD_PATH=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=statsstress,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StatsStress\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StatsStress\StatsStress.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.Stats;

[assembly: RootNode(typeof(StatsStress.StatsStress))]

namespace StatsStress
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
    public class StatsStress: TestNode
	{
        public StatsStress()
        {
            StatsStressSupport.Init();  //make sure we parse the xml before returning the
                                        //test list

            //add generated stress cases
            foreach (TestNode n in StatsStressSupport.GetStressTestList())
            {
                AddChild(n, false, true);
            }
        }

        public override void OneTimeSetup()
        {
			StressSettings settings =StatsStressSupport.GetSettings();

			if(settings.CreateLB)
			{
				DBHelper db = new DBHelper();
			
			
				foreach (int titleid in settings.Titles.Keys)
				{
					Title _title= (Title)settings.Titles[titleid];

					bool CompPartition=false;

					db.DeleteTitle(_title.ID);
				
					//db.ConfigureTitleForUnits(_title.ID,20,100,10);

					foreach ( int lbid  in _title.Leaderboards.Keys)
					{
						Leaderboard lb =(Leaderboard) _title.Leaderboards[lbid];

						if(lb.ISCompTemplate)
						{
							if(!CompPartition)
							{
								db.CreateCompetitionPartition((int)_title.ID,0,lb.serverindex);
								CompPartition=true;
							}

							if(lb.Type==(int)Leaderboard.lbtype.Team)
							{
								if(lb.Attachments)
									db.CreateCompetitionTemplate(_title.ID,(int)lb.id,0,999999,500,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",1,0,lb.serverindex);
								else
									db.CreateCompetitionTemplate(_title.ID,(int)lb.id,0,999999,500,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",1,0,lb.serverindex);
						
							}
							else
							{
								if(lb.Attachments)
									db.CreateCompetitionTemplate(_title.ID,(int)lb.id,0,999999,500,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",0,0,lb.serverindex);
								else
									db.CreateCompetitionTemplate(_title.ID,(int)lb.id,0,999999,500,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",0,0,lb.serverindex);
							}
						}
						else if(lb.Type==(int)Leaderboard.lbtype.Player)
						{
							if(lb.Attachments && !lb.Lightweight)
								db.CreateNewLeaderBoards(_title.ID,lb.id,0,999999,100,0,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",0,0,lb.serverindex);
							else if(lb.Lightweight && !lb.Attachments)
								db.CreateNewLeaderBoards(_title.ID,lb.id,0,0,0,100,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",0,0,lb.serverindex);
							else if(lb.Lightweight && lb.Attachments )
								db.CreateNewLeaderBoards(_title.ID,lb.id,0,100,500,100,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",0,0,lb.serverindex);
							else
								db.CreateNewLeaderBoards(_title.ID,lb.id,0,0,0,0,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",0,0,lb.serverindex);
						}
						else if(lb.Type==(int)Leaderboard.lbtype.Team)
						{
							if(lb.Attachments && !lb.Lightweight)
								db.CreateNewLeaderBoards(_title.ID,lb.id,0,999999,100,0,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",1,0,lb.serverindex);
							else if(lb.Lightweight && !lb.Attachments)
								db.CreateNewLeaderBoards(_title.ID,lb.id,0,0,0,100,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",1,0,lb.serverindex);
							else if(lb.Lightweight && lb.Attachments )
								db.CreateNewLeaderBoards(_title.ID,lb.id,0,100,500,100,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",1,0,lb.serverindex);
							else
								db.CreateNewLeaderBoards(_title.ID,lb.id,0,0,0,0,0,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",1,0,lb.serverindex);
						}
						/*else if (lb.Type==(int)Leaderboard.lbtype.Unit)
						{
							db.ConfigureUnitsLeaderboards(_title.ID,lb.id,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",0,0);
						}
						else if (lb.Type==(int)Leaderboard.lbtype.UnitTeam)
						{
							db.ConfigureUnitsLeaderboards(_title.ID,lb.id,"ELO_E=10;ELO_K=120;ELO_NEW=500;ELO_C=0:40,1000:20,1500:10",1,0);
						}
						*/


					}
				}
				db.reloadStatFDs();
			}
			

			
		}

	}

	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StatsStress\StressReqBuilder.cs ===
using System;
using System.IO;
using System.Text;
using System.Net;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Stats;
using ServerTestFramework.LiveService;
using xonline.common.config;


using ServerTestFramework.Utilities;

namespace StatsStress
{
	/// <summary>
	/// Summary description for StressStatsPostReqBuilder.
	/// </summary>
	///

	public class StatsCompDelete :StatsStressBase
	{
		protected CompTemplate ReqTemplate= null;

        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            ReqTemplate = (CompTemplate)StatsStressSupport.GetReqTemplate(Name);
        }

		override protected void	Execute()
		{
			uint lbid = StatsStressSupport.GetCompLB(ReqTemplate.titleID,ReqTemplate.Templateid);
			if(lbid !=0)
			{
				ReqCompDeleteLb Req= new ReqCompDeleteLb(ReqTemplate.titleID,lbid);
				try
				{
					Req.GetResponse();
					ResultCode=TEST_RESULTS.PASSED;
				}
				catch(Exception )
				{
					ResultCode=TEST_RESULTS.FAILED;
				}
			}
			else
				ResultCode=TEST_RESULTS.NOT_EXECUTED;


		}

	}


	public class StatsCompCreate :StatsStressBase
	{
		protected CompTemplate ReqTemplate= null;

        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            ReqTemplate = (CompTemplate)StatsStressSupport.GetReqTemplate(Name);
        }

		override protected void	Execute()
		{

			ReqCompCreateLb Req= new ReqCompCreateLb(ReqTemplate.titleID,ReqTemplate.Templateid);
			RepCompCreateLb resp = Req.GetResponse();


			if(resp!= null && resp._uiLbId !=0)
			{
				StatsStressSupport.AddCompLB(ReqTemplate.titleID,ReqTemplate.Templateid,resp._uiLbId);
				ResultCode=TEST_RESULTS.PASSED;

			}
			else
			{
				ResultCode=TEST_RESULTS.FAILED;

			}



		}

	}


	public class StatsWebEnum :StatsStressBase
	{
		protected EnumReqTemplate ReqTemplate= null;
		public StatsWebEnum()
		{}


        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
			ReqTemplate = (EnumReqTemplate) StatsStressSupport.GetReqTemplate(Name);
		}

		override protected void	Execute()
		{
			XRLWebEnumLB EnumReq= NextRequest();

			if(EnumReq==null)
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
			else
			{
				uint xerror =0;

				if(StatsStressSupport.ParseResponse)
				{
					XRLWebEnumLBResponse resp =EnumReq.Execute();
					xerror =resp.xResult;
				}
				else
					xerror = EnumReq.ExecuteStress();

				if(xerror==0)
				{
					ResultCode=TEST_RESULTS.PASSED;
				}
				else
				{
					ResultCode=TEST_RESULTS.FAILED;
				}
			}
		}
		public XRLWebEnumLB NextRequest()
		{
			XRLWebEnumLB req=null;
			uint currentlb=0;
			if(ReqTemplate.Lbids!=null && ReqTemplate.Lbids.Length>2)
			{
				int indx= statsRandGen.Next(0,ReqTemplate.Lbids.Length);
				currentlb =(uint)ReqTemplate.Lbids[indx];
			}
			else
				currentlb=(uint) ReqTemplate.Lbid;


			if(ReqTemplate.IsUserPivote)
			{
				ulong puid =StatsStressSupport.GetPuid((uint)ReqTemplate.titleID,(uint)currentlb,statsRandGen.Next());
				if( puid!=0)
				{
					req= new XRLWebEnumLB((uint)ReqTemplate.titleID,(uint)currentlb,puid,1,(uint)ReqTemplate.Size);
				}

			}
			else
			{
				int StartPos= statsRandGen.Next(0,StatsStressSupport.GetRecCount((uint)ReqTemplate.titleID,(uint)currentlb));
				if( StartPos>0)
					req= new XRLWebEnumLB((uint)ReqTemplate.titleID,(uint)currentlb,(ulong)StartPos,0,(uint)ReqTemplate.Size);
			}
			return req;
		}
	}

	public class StatsEnum :StatsStressBase
	{
		protected EnumReqTemplate ReqTemplate= null;
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            ReqTemplate = (EnumReqTemplate)StatsStressSupport.GetReqTemplate(Name);
		}

		override protected void	Execute()
		{
			if(ReqTemplate.IsXenon)
				XeEnum();
			else
				XboxEnum();

		}

		protected void XeEnum()
		{
			uint Xerror =0;
			 StatsEnumResponse resp= null;
			if(ReqTemplate.IsUserPivote==false && ReqTemplate.IsRatingPivote==false)
			{
				//enumbyrank.
				StatsEnumByRankRequest req =  NextEnumByRankRequest();
				
				if(req==null)
					ResultCode=TEST_RESULTS.NOT_EXECUTED;
				else
				{
					if(StatsStressSupport.ParseResponse)
					{
						resp =req.Execute();
						Xerror = resp.xResult;
					}
					else
						Xerror =req.ExecuteStress();
				}
			}
			if(ReqTemplate.IsUserPivote==true && ReqTemplate.IsRatingPivote==false)
			{
				//enumbyuser.
				StatsEnumByUserRequest req = NextEnumByUserRequest();
				if(req==null)
					ResultCode=TEST_RESULTS.NOT_EXECUTED;
				else
				{
					if(StatsStressSupport.ParseResponse)
					{
						resp =req.Execute();
						Xerror = resp.xResult;
					}
					else
						Xerror =req.ExecuteStress();
				}
			}
			if(ReqTemplate.IsRatingPivote==true)
			{
				//enumbyrating.
				StatsEnumByRatingRequest req =  NextEnumByRatingRequest();
				if(req==null)
					ResultCode=TEST_RESULTS.NOT_EXECUTED;
				else
				{
					if(StatsStressSupport.ParseResponse)
					{
						resp =req.Execute();
						Xerror = resp.xResult;
					}
					else
						Xerror =req.ExecuteStress();
				}
			}

			
			if(Xerror==0)
			{
				ResultCode=TEST_RESULTS.PASSED;

			}
			else 
				ResultCode=TEST_RESULTS.FAILED;

		}
		protected void XboxEnum()
		{
			uint xError=0;
			XRLEnumLBRequest EnumReq= NextRequest();

			if(EnumReq==null)
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
			else
			{
				if(StatsStressSupport.ParseResponse)
				{
					XRLEnumLBResponse resp =EnumReq.ExecuteEx();
					xError=resp.xResult;
				}
				else
					xError =EnumReq.ExecuteStress();

				if(xError==0)
				{
					ResultCode=TEST_RESULTS.PASSED;

				}
				else
				{
					ResultCode=TEST_RESULTS.FAILED;

				}
			}
		}
		public XRLEnumLBRequest NextRequest()
		{
			XRLEnumLBRequest req=null;

			uint currentlb=0;
			if(ReqTemplate.Lbids!=null && ReqTemplate.Lbids.Length>2)
			{
				int indx= statsRandGen.Next(0,ReqTemplate.Lbids.Length);
				currentlb =(uint)ReqTemplate.Lbids[indx];
			}
			else
				currentlb= (uint)ReqTemplate.Lbid;


			if(ReqTemplate.IsUserPivote)
			{
				ulong puid =StatsStressSupport.GetPuid((uint)ReqTemplate.titleID,(uint)currentlb,statsRandGen.Next());
				if( puid!=0)
				{
					req= new XRLEnumLBRequest((uint)ReqTemplate.titleID,(uint)currentlb,puid,1,(uint)ReqTemplate.Size,GetStatIds(ReqTemplate.NoOfAttribs,ReqTemplate.rating,false,ReqTemplate.Attachment,ReqTemplate.NickName));
				}

			}
			else
			{
				int lbSize =StatsStressSupport.GetRecCount((uint)ReqTemplate.titleID,(uint)currentlb);
					int StartPos=statsRandGen.Next(0,(lbSize<5000?lbSize:5000));
				if( StartPos>0)
					req= new XRLEnumLBRequest((uint)ReqTemplate.titleID,(uint)currentlb,(ulong)StartPos,0,(uint)ReqTemplate.Size,GetStatIds(ReqTemplate.NoOfAttribs,ReqTemplate.rating,false,ReqTemplate.Attachment,ReqTemplate.NickName));
			}
			return req;
		}
		public StatsEnumByRankRequest NextEnumByRankRequest()
		{
			StatsEnumByRankRequest req=null;

			StatsSpec[] specs= new StatsSpec[ReqTemplate.Lbids.Length];
			
			for(int i=0;i<ReqTemplate.Lbids.Length;i++)
			{
				specs[i]= new StatsSpec((uint)ReqTemplate.Lbids[i],GetStatIds(ReqTemplate.NoOfAttribs,ReqTemplate.rating,false,ReqTemplate.Attachment,ReqTemplate.NickName));
			}

			int lbSize =StatsStressSupport.GetRecCount((uint)ReqTemplate.titleID,(uint)ReqTemplate.Lbids[0]);
			int StartPos=statsRandGen.Next(0,(lbSize<5000?lbSize:5000));
			if( StartPos>0)
				req = new StatsEnumByRankRequest(ReqTemplate.titleID,(ulong)StartPos,(uint)(100/specs.Length),specs);

			
			return req;
		}
		public StatsEnumByUserRequest NextEnumByUserRequest()
		{
			StatsEnumByUserRequest req=null;

			

			StatsSpec[] specs= new StatsSpec[ReqTemplate.Lbids.Length];
			
			for(int i=0;i<ReqTemplate.Lbids.Length;i++)
			{
				specs[i]= new StatsSpec((uint)ReqTemplate.Lbids[i],GetStatIds(ReqTemplate.NoOfAttribs,ReqTemplate.rating,false,ReqTemplate.Attachment,ReqTemplate.NickName));
			}

			ulong puid =StatsStressSupport.GetPuid((uint)ReqTemplate.titleID,(uint)ReqTemplate.Lbids[0],statsRandGen.Next());
			if( puid!=0)
				req = new StatsEnumByUserRequest(ReqTemplate.titleID,(ulong)puid,(uint)(100/specs.Length),specs);

			
			return req;
		}


		public StatsEnumByRatingRequest NextEnumByRatingRequest()
		{
			StatsEnumByRatingRequest req=null;

			

			StatsSpec[] specs= new StatsSpec[ReqTemplate.Lbids.Length];
			
			for(int i=0;i<ReqTemplate.Lbids.Length;i++)
			{
				specs[i]= new StatsSpec((uint)ReqTemplate.Lbids[i],GetStatIds(ReqTemplate.NoOfAttribs,ReqTemplate.rating,false,ReqTemplate.Attachment,false));
			}

			ulong rating =(ulong)GetRating((int)ReqTemplate.titleID);
			if( rating!=0)
				req = new StatsEnumByRatingRequest(ReqTemplate.titleID,(ulong)rating,(uint)(100/specs.Length),specs);

			
			return req;
		}

		//GetRating
	}

    public class GetRankForRating : StatsStressBase
    {
       // protected EnumReqTemplate ReqTemplate = null;
        protected GetRankForRatingTemplate ReqTemplate = null;
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            ReqTemplate = (GetRankForRatingTemplate)StatsStressSupport.GetReqTemplate(Name);
        }

        override protected void Execute()
        {
             uint Xerror = 0;
             StatsEstimateRankForRatingsResponse resp = null;
             //enumbyrating.
             StatsEstimateRankForRatingsRequest req = NextRankForRatingsRequest();
               if (req == null)
                   ResultCode = TEST_RESULTS.NOT_EXECUTED;
               else
               {
                   if (StatsStressSupport.ParseResponse)
                   {
                       resp = req.Execute();
                       Xerror = resp.xResult;
                   }
                   else
                       Xerror = req.ExecuteStress();
               }
            


            if (Xerror == 0)
            {
                ResultCode = TEST_RESULTS.PASSED;

            }
            else
                ResultCode = TEST_RESULTS.FAILED;

        }

        public StatsEstimateRankForRatingsRequest NextRankForRatingsRequest()
        {
            StatsEstimateRankForRatingsRequest req = new StatsEstimateRankForRatingsRequest();
            int count = ReqTemplate.Lbids.Length * ReqTemplate.NumberRatings;

            req.m_nTitleId = (int)ReqTemplate.titleID;
            req.m_arrRatingStruct = new StatsEstimateRankRequestStruct[count];

            int c = 0;
            for (int i = 0; i < ReqTemplate.Lbids.Length; i++)
            {
                for (int j = 0; j < ReqTemplate.NumberRatings; j++)
                {
                    ulong rating = (ulong)GetRating((int)ReqTemplate.titleID);
                    req.m_arrRatingStruct[c++]=new StatsEstimateRankRequestStruct((int)ReqTemplate.Lbids[i], rating);
                   
                }
            }
                   

            return req;
        }

        //GetRating
    }

	/*
	public class StatsUnitEnum :StressReqHandler
	{
		protected UnitEnumReqTemplate  ReqTemplate= null;

        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
			ReqTemplate = (UnitEnumReqTemplate) StatsStressSupport.GetReqTemplate(Name);
		}
		public override string GetPath()
		{
			return "/xstats/statunitenum.ashx";
		}
		override protected void	Execute()
		{
			StatReqBase Request = NextRequest();

			if(Request!=null)
			{
				uint Xerror=0;
				PostTOStatsFD(Request,ref Xerror);
				if(Xerror ==0)
				{

					ResultCode=TEST_RESULTS.PASSED;
				}
				else
				{

					ResultCode=TEST_RESULTS.FAILED;
					//Global.RO.Warn(index+"Failed");
				}
			}
			else
			{
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
			}

		}
		public StatReqBase NextRequest()
		{
			UnitEnumRequestBuilder ReqBuilder=null;

			uint currentlb=0;
			if(ReqTemplate.Lbids!=null && ReqTemplate.Lbids.Length>=2)
			{
				int indx= statsRandGen.Next(0,ReqTemplate.Lbids.Length);
				currentlb =(uint)ReqTemplate.Lbids[indx];
			}
			else
				currentlb= (uint)ReqTemplate.Lbid;


			StressUserManager tmp = StatsStressSupport.GetUserManager((uint)ReqTemplate.titleID);
			if( (ulong)tmp.UnitUserCounter > _Settings.UnitUserRange/10)
			{

				ulong puid=0;
				if(ReqTemplate.IsTeam)
					puid =tmp.GetTeamUnitUserToEnum(statsRandGen.Next());
				else
					puid =tmp.GetUnitUserToEnum(statsRandGen.Next());

				ReqBuilder = new UnitEnumRequestBuilder((uint)ReqTemplate.titleID
					       ,(uint)currentlb,ReqTemplate.SortFlag,puid,(ushort)ReqTemplate.Size,GetStatIds(ReqTemplate.NoOfAttribs,false,false,false));
			}



			return ReqBuilder;
		}

	}
	public class StatsUnitGet :StressReqHandler
	{
		protected UnitGetReqTemplate  ReqTemplate= null;
        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
				ReqTemplate = (UnitGetReqTemplate) StatsStressSupport.GetReqTemplate(Name);
		}
		public override string GetPath()
		{
			return "/xstats/statunitget.ashx";
		}
		override protected void	Execute()
		{
			StatReqBase Request = NextRequest();

			if(Request!=null)
			{
				uint Xerror=0;
				PostTOStatsFD(Request,ref Xerror);
				if(Xerror ==0)
				{

					ResultCode=TEST_RESULTS.PASSED;
				}
				else
				{

					ResultCode=TEST_RESULTS.FAILED;
					//Global.RO.Warn(index+"Failed");
				}
			}
			else
			{
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
			}

		}
		public StatReqBase NextRequest()
		{
			UnitGetRequestBuilder ReqBuilder=null;

			ulong[] UnitMembers= StatsStressSupport.GetUnit((uint)ReqTemplate.titleID,ReqTemplate.isteam,statsRandGen.Next());
			if (UnitMembers !=null)
			{
				ReqBuilder= new UnitGetRequestBuilder((uint)ReqTemplate.titleID,UnitMembers[0],UnitMembers[1],0,0);

				for(int i=0;i< ReqTemplate.GetRequests.Count;i++)
				{
					BaseReqType req = (BaseReqType)ReqTemplate.GetRequests[i];
					ReqBuilder.AddLeaderboard((uint)req.Lbid,GetStatIds(req.NoOfAttribs,false,false,false));

				}
			}


			return ReqBuilder;
		}
	}

	*/
	public class StatsGet :StatsStressBase
	{
		protected GetReqTemplate ReqTemplate= null;

        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            ReqTemplate = (GetReqTemplate)StatsStressSupport.GetReqTemplate(Name);
		}

		override protected void	Execute()
		{
			if(ReqTemplate.IsXenon)
				XenonRead();
			else
				XboxGet();
		}

		public void XenonRead()
		{
			uint XError =0;
			StatsReadRequest ReadData = NextXeRequest();

			if(ReadData ==null)
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
			else
			{
				if(StatsStressSupport.ParseResponse)
				{
					StatsReadResponse resp= ReadData.Execute();
					XError= resp.xResult;
				}
				else
					XError = ReadData.ExecuteStress();


				if(XError==0)
				{
					ResultCode=TEST_RESULTS.PASSED;

				}
				else
				{
					ResultCode=TEST_RESULTS.FAILED;

				}
			}
		}

		public void XboxGet()
		{
			uint XError =0;
			XRLGetRequest GetData = NextRequest();

			if(GetData ==null)
				ResultCode=TEST_RESULTS.NOT_EXECUTED;
			else
			{
				if(StatsStressSupport.ParseResponse)
				{
					XRLGetResponse resp= GetData.Execute();
					XError = resp.xResult;
				}
				else
					XError = GetData.ExecuteStress();


				if(XError==0)
				{
					ResultCode=TEST_RESULTS.PASSED;

				}
				else
				{
					ResultCode=TEST_RESULTS.FAILED;

				}
			}

		}
		public XRLGetRequest NextRequest()
		{
			int NoOfUsers=0;

			if(ReqTemplate.UsersRange!=null && ReqTemplate.UsersRange.Length==2)
				NoOfUsers= statsRandGen.Next(ReqTemplate.UsersRange[0],ReqTemplate.UsersRange[1]);
			else
				NoOfUsers =ReqTemplate.NoOfUsers;

			uint totalreads = (uint)(ReqTemplate.GetRequests.Count*NoOfUsers);
			XRLGetRequest GetData = new XRLGetRequest(totalreads);
			bool fail= false;

			for( int i=0; i< NoOfUsers;i++)
			{

				for(int j=0;j<ReqTemplate.GetRequests.Count;j++)
				{
					GetRequestType req =(GetRequestType)ReqTemplate.GetRequests[j];
					int rand = statsRandGen.Next();
					ulong puid =StatsStressSupport.GetPuid((uint)ReqTemplate.titleID,(uint)req.Lbid,rand);

					if( puid==0)
					{
						fail= true;
						continue;
					}


					GetData.AddGetData((uint)ReqTemplate.titleID,puid,(uint)req.Lbid,GetStatIds(req.NoOfAttribs,req.rating,req.rank,req.Attachment,req.NickName));
				}
			}
			if(fail)
				return null;

			return GetData;

		}

		public StatsReadRequest NextXeRequest()
		{
			int NoOfUsers=0;
			bool fail=false;

			if(ReqTemplate.UsersRange!=null && ReqTemplate.UsersRange.Length==2)
				NoOfUsers= statsRandGen.Next(ReqTemplate.UsersRange[0],ReqTemplate.UsersRange[1]);
			else
				NoOfUsers =ReqTemplate.NoOfUsers;

	//		if(NoOfUsers==5)
			// System.Console.WriteLine( "users in get" +NoOfUsers);

			ulong[] puids = new ulong[NoOfUsers];
			StatsSpec[] specs= new StatsSpec[ReqTemplate.GetRequests.Count];

			for( int i=0; i< NoOfUsers;i++)
			{
				GetRequestType req =(GetRequestType)ReqTemplate.GetRequests[0];
				int rand = statsRandGen.Next();
				
				ulong puid =StatsStressSupport.GetPuid((uint)ReqTemplate.titleID,(uint)req.Lbid,rand);

				if( puid==0)
				{
					fail= true;
					continue;
				}
				puids[i]=puid;
			}

			for(int j=0;j<ReqTemplate.GetRequests.Count;j++)
			{
				GetRequestType req =(GetRequestType)ReqTemplate.GetRequests[j];
				specs[j]= new StatsSpec((uint)req.Lbid,GetStatIds(req.NoOfAttribs,req.rating,req.rank,req.Attachment,req.NickName));
			}

			if(fail)
				return null;

			StatsReadRequest readData = new StatsReadRequest(ReqTemplate.titleID,puids,specs);

			return readData;

		}

	}

	public class StatsSet :StatsStressBase
	{
		protected SetReqTemplate ReqTemplate= null;

        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            ReqTemplate = (SetReqTemplate)StatsStressSupport.GetReqTemplate(Name);
		}

		override protected void	Execute()
		{

			XRLSetRequest SetData = NextRequest();

			IPEndPoint temp = Global.XEnv.GetVirtualInterface(VirtualInterface.xstatsfd);
			XRLSetResponse resp = SetData.Execute(temp);


			if(!ReqTemplate.HasAttachments && resp.xResult==0)
			{
				ResultCode=TEST_RESULTS.PASSED;

			}
			else if(ReqTemplate.HasAttachments && resp.xResult==HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT)
			{
				// call commit ...

				XRLCommitAttachment CommitReq = new XRLCommitAttachment(SetData.titleId,50,50,resp.Token.PathNameLen,resp.Token.PathName,resp.SetRefLen,resp.SetRef);
				XRLResponse CommitResp = CommitReq.Execute();
				if(CommitResp!= null && CommitResp.xResult ==0)
				{
					ResultCode=TEST_RESULTS.PASSED;

				}
				else
				{
					ResultCode=TEST_RESULTS.FAILED;

				}
			}
			else
			{

				ResultCode=TEST_RESULTS.FAILED;
			}


		}
		public XRLSetRequest NextRequest()
		{
			int NoOfUsers=0;

			if(ReqTemplate.UsersRange!=null && ReqTemplate.UsersRange.Length==2)
				NoOfUsers= statsRandGen.Next(ReqTemplate.UsersRange[0],ReqTemplate.UsersRange[1]);
			else
				NoOfUsers=ReqTemplate.NoOfUsers;


			uint totalwrites = (uint)(ReqTemplate.SetRequests.Count*NoOfUsers);
			XRLSetRequest SetData = new XRLSetRequest((uint)ReqTemplate.titleID,totalwrites);


			for( int i=0; i< NoOfUsers;i++)
			{
				ulong puid =GetNextUserPuid((uint)ReqTemplate.titleID);
				for(int j=0;j<ReqTemplate.SetRequests.Count;j++)
				{
					BaseReqType req =(BaseReqType)ReqTemplate.SetRequests[j];
					StatsStressSupport.SetPuid((uint)ReqTemplate.titleID,(uint)req.Lbid,puid,false);
					SetData.AddSetData((uint)req.Lbid,puid,GetStatsAsXRL(req.NoOfAttribs,(int)ReqTemplate.titleID));

				}
			}



			return SetData;

		}

	}


	public abstract class StressReqHandler :StatsStressBase
	{

		protected FDTransaction xAct = new FDTransaction();
		public abstract string GetPath();
		public byte[]	GenerateHttpHeader(IPEndPoint Server, MemoryStream reqStream,BundledAuthData authData)
		{
			//			if (CrapHeader!=null)				return CrapHeader;
			StringBuilder sbURL;

			sbURL = new StringBuilder();
			sbURL.Append("POST ");
			sbURL.Append(GetPath());

			if(authData!=null)
				sbURL.Append( " HTTP/1.1\r\n" );
			else
				sbURL.Append( " HTTP/1.0\r\n" );

			//sbURL.Append( "Expect: 100-continue\r\n");
			sbURL.Append( "Relja: true\r\n");  // This header was requested by SLamb to differentiate tools/tests and real clients
			sbURL.Append( "Connection: Keep-Alive\r\n");
			sbURL.Append( "Host: "+Server.Address+"\r\n");


			sbURL.Append( "Content-Type: xon/" + ((int)XOService.Stats).ToString("x")+"\r\n");
			sbURL.Append( "User-Agent: "+((int)XOService.Stats).ToString("x")+"/0.10.4715\r\n");

			if(authData!=null)
				sbURL.Append(BundledAuthData.HTTP_HEADER_BUNDLED_AUTH_DATA+":"+authData.GetBase64EncodedString()+"\r\n");




			sbURL.Append( "Content-Length: " +  reqStream.Length+"\r\n\r\n");

			System.Text.ASCIIEncoding	AE=new System.Text.ASCIIEncoding();

			byte []CrapHeader=AE.GetBytes(sbURL.ToString());
			return CrapHeader;
		}


		//public Execute()
		/// this function executes the test case and verifyes.
		protected void  PopulateSlot(StatReqBase req,ref CSGInfo Slot)
		{

			Slot.machinePuid=0x0009400000000000;
			Slot.titleId= req.TitleID;
			Slot.titleVersion=1;

			if(!req.IsArbitrated)
			{
				Slot.userPuid0= (req.Users.Length>=1)?req.Users[0]:0;
				Slot.userPuid1=(req.Users.Length>=2)?req.Users[1]:0;
				Slot.userPuid2=(req.Users.Length>=3)?req.Users[2]:0;
				Slot.userPuid3=(req.Users.Length>=4)?req.Users[3]:0;
			}



		}


		// this function posts stats to actual stats FD
		public byte[] PostTOStatsFD(StatReqBase req,ref uint Xerr)
		{
			Xerr=0;
			MemoryStream reqStream = new MemoryStream( 512 );
			req.GetWireData().WriteStream(reqStream);

			byte[]	httpHeader;

			FDTransaction xAct = new FDTransaction();


			xAct.endPoint =Global.XEnv.GetVirtualInterface(VirtualInterface.xstatsfd);
			CSGInfo slot = GlobalFakeSG.FakeSG.GetSlot();

			if(req.IsArbitrated)
			{
				xAct.endPoint=Global.XEnv.GetVirtualInterface(VirtualInterface.xstatsfd_int);  // change it to 8080 later
				httpHeader=GenerateHttpHeader(xAct.endPoint,reqStream,req.authData);
				xAct.Execute(httpHeader, reqStream,ref slot,false);
				//Global.RO.Warn(index+"Sent A");
			}
			else
			{
				xAct.endPoint=Global.XEnv.GetVirtualInterface(VirtualInterface.xstatsfd);
				httpHeader=GenerateHttpHeader(xAct.endPoint,reqStream,null);
				PopulateSlot(req,ref slot);
				xAct.Execute(httpHeader, reqStream,ref slot,true);
				//Global.RO.Warn(index+"Sent X");
			}
			//Global.RO.Warn(xAct.endPoint.Port.ToString());

			if( (xAct.XErr != 0) )
			{
				Xerr = xAct.XErr;
			}


			return xAct.ResponseContents;


		}


	}
	public class StatsPost :StressReqHandler
	{

		protected PostReqTemplate ReqTemplate= null;
		public StatsPost()
		{
			index=StatsStressSupport.GetCount();
		}

        public override void OneTimeSetup()
        {
            base.OneTimeSetup();
            ReqTemplate = (PostReqTemplate)StatsStressSupport.GetReqTemplate(Name);

		}

		private int index=0;
		public override string GetPath()
		{
			return "/xstats/statpost.ashx";
		}

		override protected void	Execute()
		{
			byte[] PostResp= null;
			StatReqBase Request = NextRequest();
			uint Xerror=0;

			PostResp =PostTOStatsFD(Request,ref Xerror);

			if(!ReqTemplate.HasAttachments && Xerror==0)
			{

				ResultCode=TEST_RESULTS.PASSED;
			}
			else if(ReqTemplate.HasAttachments && Xerror == HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT)
			{
				XRLSetResponse resp = (XRLSetResponse)new XRLSetResponse().ReadBytes(HResult.XONLINE_S_STAT_CAN_UPLOAD_ATTACHMENT,PostResp);
				XRLCommitAttachment CommitReq = new XRLCommitAttachment(Request.TitleID,50,50,resp.Token.PathNameLen,resp.Token.PathName,resp.SetRefLen,resp.SetRef);
				XRLResponse CommitResp = CommitReq.Execute();
				if(CommitResp!= null && CommitResp.xResult ==0)
				{

					ResultCode=TEST_RESULTS.PASSED;
				}
				else
				{

					ResultCode=TEST_RESULTS.FAILED;
					//Global.RO.Warn(index+"Failed");
				}

			}
			else
			{

				ResultCode=TEST_RESULTS.FAILED;
				//Global.RO.Warn(index+"Failed");
			}

		}


		protected StatReqBase GetPostReq(bool IsArbitrated)
		{
			uint title =(uint) ReqTemplate.titleID;
			RequestBuilder PostReq = new RequestBuilder();
			int NoOfUsers=0;

			if(ReqTemplate.UsersRange!=null && ReqTemplate.UsersRange.Length==2)
				NoOfUsers= statsRandGen.Next(ReqTemplate.UsersRange[0],ReqTemplate.UsersRange[1]);
			else
				NoOfUsers=ReqTemplate.NoOfUsers;


			XUser[] Users = new XUser[NoOfUsers]; //{new XUser(501,new ulong[]{teammask+501})};

//****************Build  User list **************************************
			ulong[] puids = new ulong[NoOfUsers];
			for(int idx=0;idx<NoOfUsers;idx++)
			{
				puids[idx] = GetNextUserPuid(title);

			}

	//****************Build  Teams list **************************************
			int NoOFTeam = ReqTemplate.NoOFTeam;
			ulong[] teams = new ulong[NoOFTeam];
			for(int tuidx=0;tuidx<teams.Length;tuidx++)
			{
				teams[tuidx]=GetNextTeamUserPuid(title);
			}


//    build auth data for request...

			if( teams.Length <8)
			{
				for(int i=0;i<NoOfUsers;i++)
				{
					Users[i] = new XUser(puids[i],teams);

				}
			}
			else if ( teams.Length >=8)
			{
				int nteamtickets=((teams.Length%8)==0)?teams.Length/8:(teams.Length/8)+1;
				int ugroup= ((NoOfUsers%nteamtickets)==0)?NoOfUsers/nteamtickets:(NoOfUsers/nteamtickets)+1;
				int nu=0;
				for( int p=0;p<nteamtickets;p++)
				{
					ulong[] temp = new ulong[8];
					int jdx=0;
					for(int vdx=(p*8);vdx<teams.Length && vdx<((p+1)*8);vdx++)
					{
						temp[jdx++] = teams[vdx];
					}

					for(int i=(p*ugroup);i<NoOfUsers && i<((p+1)*ugroup);i++)
					{
						Users[nu++] = new XUser(puids[i],temp);

					}

				}

			}



			// build request....

			try
			{

				for(int reqidx=0; reqidx< ReqTemplate.PostRequests.Count ;reqidx++)
				{
					PostRequestType Request = (PostRequestType)ReqTemplate.PostRequests[reqidx];

					if(Request.HasMuSigma)
					{
						BuildMusigmaReq(puids,Request.Lbid,ref PostReq);
					}
					else if(Request.HasElo)
					{
						if(Request.IsTeam)
							BuildPlayerTeamElo(teams,Request.Lbid,ref PostReq);
						else
							BuildPlayerTeamElo(puids,Request.Lbid,ref PostReq);


					}
					else
					{
						if(Request.IsTeam)
						{
							for(int i=0;i<teams.Length;i++)
							{
								StatsStressSupport.SetPuid((uint)ReqTemplate.titleID,(uint)Request.Lbid, teams[i],true);
								BuildUserReq((int)ReqTemplate.titleID,teams[i],Request,ref PostReq);
							}
						}
						else
						{
							for(int i=0;i<puids.Length;i++)
							{
								StatsStressSupport.SetPuid((uint)ReqTemplate.titleID,(uint)Request.Lbid, puids[i],false);
								BuildUserReq((int)ReqTemplate.titleID,puids[i],Request,ref PostReq);
							}
						}

					}

				}
			}
			catch(Exception e)
			{
				System.Console.WriteLine(e);
			}


			if(ReqTemplate.NoOFTeam>0)
				PostReq.Builder((uint)ReqTemplate.titleID,Users,IsArbitrated,true);
			else
				PostReq.Builder((uint)ReqTemplate.titleID,puids,IsArbitrated,false);
			return PostReq.GetPostData();
		}

	/*	protected void BuildUnitElo(unitHelper[] units,int lbid,ref RequestBuilder reqB)
		{
			if(units.Length>=2)
			{
				for(int i=0;i<units.Length;i++)
				{
					for(int j=i+1;j<units.Length;j++)
					{
						StatsUnitElo elo= new StatsUnitElo(lbid,new ulong[4]{units[i].puid1,units[i].puid2,0,0},new ulong[4]{units[j].puid1,units[j].puid1,0,0},0,new object[]{(double)1,(double).5,(double).5});

						reqB.AddProcs(elo.Proc);
					}
				}
			}

		}
		*/

		protected void BuildMusigmaReq(ulong[] Puids,int lbid,ref RequestBuilder reqB)
		{
			if(Puids.Length>=2)
			{
				object[] data = new object[Puids.Length*3];
				for(int i=0, j=0;i<Puids.Length;i++,j=j+3)
				{
					data[j]=(ulong)Puids[i];
					data[j+1]=(int)i+1;
					data[j+2]=(int)i+1;

				}

					
				StatsMuSigma Musigma=new StatsMuSigma((uint)lbid,0,data);
				reqB.AddProcs(Musigma.Proc);
					
				
			}
		}


		protected void BuildPlayerTeamElo(ulong[] Puids,int lbid,ref RequestBuilder reqB)
		{
			if(Puids.Length>=2)
			{
				for(int i=0;i<Puids.Length;i++)
				{
					for(int j=i+1;j<Puids.Length;j++)
					{
						StatsPlayerElo elo=new StatsPlayerElo(lbid,Puids[i],Puids[j],new object[]{(double)1,(double).5,(double).5});
						reqB.AddProcs(elo.Proc);
					}
				}
			}
		}

		/*protected void BuildUnitReq(ulong userid1,ulong userid2 ,PostRequestType reqtype,ref RequestBuilder reqB)
		{
			//build units
			short procindex=0;
			if(reqtype.HasCondition )
			{
				ConditionalUnit cond= new ConditionalUnit(reqtype.Lbid,new ulong[]{userid1,userid2,0,0},StatContitions.NotEqual,10,(int)555);
				reqB.AddProcs(cond.Proc);
				procindex = (short)reqB.StatsProcs.Count;
			}
			if(reqtype.HasReplace )
			{
				StatsUnitReplace rep = new StatsUnitReplace(reqtype.Lbid,userid1,userid2,0,0,procindex,GetStats(reqtype.NoOfAttribs,-1));
				reqB.AddProcs(rep.Proc);
			}
			if(reqtype.HasIncrement)
			{
				StatsUnitAdd add= new StatsUnitAdd(reqtype.Lbid,userid1,userid2,0,0,procindex,GetStats(reqtype.NoOfAttribs,-1));
				reqB.AddProcs(add.Proc);
			}


		}
		*/

		protected void BuildUserReq(int title,ulong userid ,PostRequestType reqtype,ref RequestBuilder reqB)
		{
			short procindex=0;
			if(reqtype.HasCondition)
			{
				ConditionalPlayer con= new ConditionalPlayer(reqtype.Lbid,userid,StatContitions.NotEqual,5,(int)555);
				reqB.AddProcs(con.Proc);
				procindex = (short)reqB.StatsProcs.Count;
			}
			if(reqtype.HasReplace)
			{
				//nickname support.
				StatsPlayerReplace rep= new StatsPlayerReplace(reqtype.Lbid,userid,procindex,GetStats(reqtype.NoOfAttribs,title));
				reqB.AddProcs(rep.Proc);
			}
			if(reqtype.HasIncrement)
			{
				StatsPlayerAdd add= new StatsPlayerAdd(reqtype.Lbid,userid,procindex,GetStats(reqtype.NoOfAttribs,title));
				reqB.AddProcs(add.Proc);
			}
			if(reqtype.HasMin)
			{
				StatsPlayerMin min= new StatsPlayerMin(reqtype.Lbid,userid,procindex,GetStats(reqtype.NoOfAttribs,title));
				reqB.AddProcs(min.Proc);
			}
			if(reqtype.HasMax)
			{
				StatsPlayerMax Max= new StatsPlayerMax(reqtype.Lbid,userid,procindex,GetStats(reqtype.NoOfAttribs,title));
				reqB.AddProcs(Max.Proc);
			}
			

		}


		public StatReqBase NextRequest()
		{
			// get Request Template.

			if(ReqTemplate != null)
			{

				//chack which reques to build
				if(ReqTemplate.Arb_Direct==(int)HowToMakeRequest.Arbitration)
				{
					// build an Arbitration request
					//Global.RO.Warn(index+"ReqType A");
					 return GetPostReq(true);


				}
				else if(ReqTemplate.Arb_Direct==(int)HowToMakeRequest.Direct)
				{
					// build an Direct request
					//Global.RO.Warn(index +"ReqType X");
					return  GetPostReq(false);

				}
			}
			return null;

		}



	}


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StatsStress\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_statsstress_none_12.4.56.0_none_3852f8a9b14ba550
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=statsstress
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276.manifest
XP_MANIFEST_PATH=manifests\msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276.cat
XP_CATALOG_PATH=manifests\msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276.cat
XP_PAYLOAD_PATH=msil_statsstress_no-public-key_12.4.56.0_x-ww_8a622276
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=statsstress,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\ConsoleFeedbackFactory.cs ===
using System;
using System.Collections;
using ServerTestFramework.Utilities;

namespace STFConsole
{
    public class ConsoleFeedbackFactory : FeedbackHandleFactory
    {
        class ConsoleProgressFeedback : ProgressFeedbackHandle
        { 
            public override void SetProgress(uint currentValue, uint totalValue)
            {
            }

            public override void SetMessage(string message)
            {
            }

            public void Refresh()
            {
            }
        }

        ArrayList _ProgressHandles;

        public ConsoleFeedbackFactory()
        {
            _ProgressHandles = new ArrayList();
        }

        public override ProgressFeedbackHandle CreateProgressFeedback(string title)
		{
			ConsoleProgressFeedback progress = new ConsoleProgressFeedback();
			progress.SetMessage(title);

			_ProgressHandles.Insert(0, progress);
			UpdateProgressHandles();

			return progress;
		}

		public override void ReleaseProgressFeedback(ProgressFeedbackHandle handle)
		{
			_ProgressHandles.Remove(handle);
			UpdateProgressHandles();
		}

		// Only the top of the progress handle stack should be active
		private void UpdateProgressHandles()
		{
			if(_ProgressHandles.Count >  0)
			{
				ConsoleProgressFeedback top = _ProgressHandles[0] as ConsoleProgressFeedback;
                top.Refresh();
			}
		}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\CodeCoverageTestListener.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Net;

using System.ComponentModel;
using System.Diagnostics;

using System.Text.RegularExpressions;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.LiveService;

using xonline.common.config;

namespace STFConsole
{
    /// <summary>
    /// The main TestListener class that controls code coverage collection
    /// </summary>    
    class CodeCoverageTestListener : TestEventListener  
    {        
        CoverageManager coverageManager = null;
        bool useSqlCC = false;
        bool importResults = true;

        public CodeCoverageTestListener(bool useSqlCC, bool importResults)
        {
            this.useSqlCC = useSqlCC;
            this.importResults = importResults;
        }
        
        /// <summary>
        /// Handles the test events that are raised from the STF runner
        /// </summary>
        /// <param name="e"></param>
        public void OnTestEvent(TestEventArgs args)
        {
            // No code coverage actions on Retry, PreFail, PostFail
            switch(args.Action)
            {
                case TestAction.StartAll:
                    onTestPassStarting(args);
                    break;

                case TestAction.Start:
                    if (args.Node.ChildrenCount == 0)
                    {
                        onTestNodeStarting(args);
                    }
                    break;

                case TestAction.Pass:
                case TestAction.Fail:
                case TestAction.Ignore:
                    if (args.Node.ChildrenCount == 0)
                    {
                        onTestNodeFinished(args);
                    }
                    break;

                case TestAction.StopAll:
                    onTestPassFinished(args);
                    break;
            }
        }

        private void onTestPassStarting(TestEventArgs args)
        {
            coverageManager = new CoverageManager();
            ICoverageCollector magCC = MagellanCC.CreateCollector(this.importResults);

            if (magCC == null)
            {
                Global.RO.Warn("Cannot collect Magellan traces");
            }
            else
            {
                Global.RO.Info("Collecting Magellan traces...");
                coverageManager.AddCollector(magCC);
            }
            
            //// Disabling SQLCC till stability issues are solved
            if (useSqlCC)
            {
                ICoverageCollector[] sqlCollectors = 
                    SqlCC.CreateCollectors();
                
                if (sqlCollectors != null && 
                    sqlCollectors.Length > 0)
                {
                    Global.RO.Info("Collecting SQL Traces...");
                    coverageManager.AddCollectors(sqlCollectors);
                }
                else
                {
                    Global.RO.Warn("Cannot collect SQL Traces:");
                }
            }
            

            if (coverageManager.IsCollectionEnabled)
            {
                coverageManager.Initialize();
            }            
        }

        private void onTestNodeStarting(TestEventArgs args)
        {
            if (coverageManager.IsCollectionEnabled)
            {
                String traceName;

                // Mangle traceName so that sqlcc doesn't choke on names
                // with format _NNN
                traceName = args.Node.FullName + "_t";

                // Replace space in test nodes with _
                traceName = traceName.Replace(" ", "_");

                coverageManager.Start(traceName);
            }
        }

        private void onTestNodeFinished(TestEventArgs args)
        {
            if (coverageManager.IsCollectionEnabled && coverageManager.IsCollecting)
            {
                coverageManager.Close();
                coverageManager.Save();
            }
        }

        private void onTestPassFinished(TestEventArgs args)
        {
            if (coverageManager.IsCollectionEnabled)
            {
                Global.RO.Info("Finished Collecting Traces.");
                Global.RO.Info(String.Format("{0} Traces Saved.", 
                                      coverageManager.SavedTraceCount));

                // Upload saved traces
                Global.RO.Info("Importing Collected Traces...");
                
                coverageManager.Import();
            }
        }
    }

    internal static class SystemErrorCode
    {
        public const int FILE_NOT_FOUND = 9009;
    }

    internal class CoverageExecutionException : Exception
    {
        private string _args;
        private Dictionary<string, int> _errors;

        public CoverageExecutionException(string args)
            :this(args, new Dictionary<string,int>())
        { }

        public CoverageExecutionException(string args, string server, 
                                          int error)
        {
            _args = args;

            _errors = new Dictionary<string, int>();
            _errors[server] = error;
        }

        public CoverageExecutionException(string args, 
                                          Dictionary<string, int> errors)
        {
            _errors = errors;
            _args = args;
        }

        public override string Message
        {
            get
            {
                return String.Format(
                    "CoverCmd({0}) failed on the following server{1}:\n{2}"
                  , _args
                  , _errors.Count > 1 ? "s" : String.Empty
                  , ErrorsToString()
                );
            }
        }

        public Dictionary<string, int> Errors
        {
            get
            {
                return _errors;
            }
        }

        private string ErrorsToString()
        {
            StringBuilder sb = new StringBuilder();

            foreach (KeyValuePair<string, int> kvp in _errors)
            {
                sb.Append(String.Format("Server: {0}, ErrorCode 0x{1:X8} " +
                                        "({1})\n", kvp.Key, kvp.Value));
            }

            return sb.ToString();
        }
    }


    internal class DbInfo
    {
        public string Name;
        public string ServerUri;

        public static bool operator ==(DbInfo lhs, DbInfo rhs)
        {
            bool ret = Object.ReferenceEquals(lhs, rhs);

            if (!ret)
            {
                if ((object)rhs != null && (object)lhs != null)
                {
                    ret = (lhs.Name == rhs.Name && 
                           lhs.ServerUri == rhs.ServerUri);
                }
            }

            return ret;
        }

        public static bool operator !=(DbInfo lhs, DbInfo rhs)
        {
            return !(lhs == rhs);
        }

        public override int GetHashCode()
        {
            return this.ToString().GetHashCode();
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override string ToString()
        {
            return String.Format("{0} ({1})", Name, ServerUri);
        }
    }
    

    // ICode coverage interface. Implementation maybe Magellan, SQLCC
    // or something else
    internal interface ICoverageCollector
    {
        void Initialize(String runId);

        void Start(string traceName);

        void Close();

        void Reset();

        void Save();

        void Import();

        bool SupportsSaveToFile{get;}
        void SaveToFile(string fileName);
    }
    
    // Manage all code coverage collectors
    internal class CoverageManager
    {
        private List<ICoverageCollector> _collectors = 
        new List<ICoverageCollector>();
        
        public int CollectorCount
        {
            get
            {
                return _collectors.Count;
            }
        }

        public bool IsCollectionEnabled
        {
            get
            {
                return (_collectors.Count > 0);
            }
        }

        private int _savedTraceCount;
        public int SavedTraceCount
        {
            get
            {
                return _savedTraceCount;
            }
        }

        private bool _isSaved = false;
        private bool _isClosed = false;
        private bool _isCollecting = false;
        public bool IsCollecting
        {
            get
            {
                return _isCollecting;
            }
        }

        public CoverageManager()
        {
            ResetTraceCount();
        }

        public CoverageManager(ICoverageCollector[] collectors)
        {
            _collectors.AddRange(collectors);
            ResetTraceCount();
        }

        public void AddCollector(ICoverageCollector collector)
        {
            _collectors.Add(collector);
        }

        public void AddCollectors(params ICoverageCollector[] collectors)
        {
            _collectors.AddRange(collectors);
        }

        public void RemoveCollector(ICoverageCollector collector)
        {
            _collectors.Remove(collector);
        }

        public void ClearCollectors()
        {
            _collectors.Clear();
        }

        public void ResetTraceCount()
        {
            _savedTraceCount = 0;
        }

        public void Initialize()
        {
            Guid runId = Guid.NewGuid();           
            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Initialize(runId.ToString());
            }
        }
        
        public void Start(string traceName)
        {
            if (_isCollecting || _isClosed)
            {
                throw new InvalidOperationException();
            }

            _isCollecting = true;

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Start(traceName);
            }
            
        }

        public void Reset()
        {
            if (!_isCollecting)
            {
                throw new InvalidOperationException();
            }

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Reset();
            }
        }

        public void Close()
        {
            if (!_isCollecting)
            {
                throw new InvalidOperationException();
            }

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Close();
            }

            _isCollecting = false;
            _isClosed = true;
        }

        public void Save()
        {
            if (!_isClosed)
            {
                throw new InvalidOperationException();
            }

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Save();
            }

            _isClosed = false;
            _isSaved = true; 

            ++_savedTraceCount;
        }

        public void Import()
        {
            if (!_isSaved)
            {
                // It is possible it was not saved because the run can be initialized but all nodes can be skipped which causes failures
                return;
            }

            foreach (ICoverageCollector collector in _collectors)
            {
                collector.Import();
            }

            _isSaved = false;
        }
    }

    internal class MagellanCC : ICoverageCollector
    {
        public const String DEFAULT_DB_SERVER = "EDGE-SQL-01";
        public const String DEFAULT_DB_NAME = "Cov_Xonline";

        private static Report RO = new Report("Code Coverage > Magellan");

        private DbInfo _db;
        private List<string> _targets = new List<string>();
        private bool _importData;

        private string _traceName;

        /// <summary>
        /// Create the ICoverageCollector for Magellan on this Environment.
        /// Do not execute if there is no valid environment.
        /// </summary>
        /// <returns>Magellan ICoverageCollector</returns>
        static public ICoverageCollector CreateCollector(bool importData)
        {
            MagellanCC c = new MagellanCC(importData);
            if (c._targets.Count == 0)
            {
                c = null;
            }

            return c;
        }

        private MagellanCC(bool importData)
        {
            this._importData = importData;
            String output;
            
            if (SystemErrorCode.FILE_NOT_FOUND != 
                CCExecute(String.Empty, out output))
            {
                String dbServerUri = String.Empty;
                String dbName = String.Empty;

                try
                {
                    dbServerUri = Global.XEnv.GetSetting("magcc_db_server");
                }
                catch (Exception)
                {
                }

                if (dbServerUri == String.Empty)
                {
                    RO.Info("NPDB settings for Magellan Databse Server " +
                            "not found. Using default : " + DEFAULT_DB_SERVER);
                    dbServerUri = DEFAULT_DB_SERVER;
                }
                else
                {
                    RO.Info("Using NPDB settings for Magellan Database " + 
                            "Server: " + dbServerUri);
                }

                
                try
                {
                    dbName = Global.XEnv.GetSetting("magcc_db_name");
                }
                catch (Exception)
                {
                }
                
                if (dbName == String.Empty)
                {                    
                    RO.Info("NPDB settings for Magellan Database Name " +
                            "not found. Using default : " + DEFAULT_DB_NAME);
                    dbName = DEFAULT_DB_NAME;
                }
                else
                {
                    RO.Info("Using NPDB settings for Magellan Database Name: "+
                            dbName);
                }


                RO.Info(String.Format("Importing Data to Server {0} ", this._importData?"True":"False" ));

                DbInfo db = new DbInfo();
                
                db.ServerUri = dbServerUri;
                db.Name = dbName;
                
                _db = db;
                
                // Every server should have the xmgmtsrv running, 
                // so by executing the following command
                // we should get a list of every server in the Environment.
                string[] servers = 
                    Global.XEnv.GetServerListByInterface("xmgmtsrv");
                foreach (string server in servers)
                {
                    if (VerifyServiceForServer(server))
                    {
                        _targets.Add(server);
                    }
                    else
                    {
                        RO.Warn(String.Format(
                                    "Skipping Server: {0}, " + 
                                    "CC Service not running.", 
                                    server));
                    }
                }

                if (_targets.Count == 0)
                {
                    RO.Warn("CoverMon is not running on any servers " + 
                            "in the environment");
                    RO.Warn("OR CoverCmd is not installed on this client.");
                }
            }
            else
            {
                RO.Warn("CoverCmd not installed!");
            }
        }

        public bool IsInstalled
        {
            get
            {
                bool ret = true;

                String output;
                int ec = CCExecute("reset", out output);

                if (ec == 2)
                {
                    // Executable file wasn't found.
                    ret = false;
                }

                return ret;
            }
        }

        private bool VerifyServiceForServer(string server)
        {
            string exeArgs = String.Format(
                "/reset /machine:{0}"
              , server
            );

            // TODO: Refine this, perhaps some failure cases would 
            // still be 'success' ?
            String output;
            int ec = CCExecute(exeArgs, out output);
            return ec == 0 ? true : false;
        }

        #region Internal Methods

        private const string _exePath = "CoverCmd.exe";
        private static int CCExecute(string args, out String output)
        {
            int ec = 0;

            Process proc = new Process();
            output = String.Empty;
            
            try
            {
                proc.EnableRaisingEvents = false;

                proc.StartInfo.CreateNoWindow = true;
                proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                proc.StartInfo.FileName = _exePath;
                proc.StartInfo.Arguments = args;
                proc.StartInfo.RedirectStandardOutput = true;
                proc.StartInfo.UseShellExecute = false;

                proc.Start();
                
                output = proc.StandardOutput.ReadToEnd();
                                
                proc.WaitForExit();

                ec = proc.ExitCode;
            }
            catch (Win32Exception e)
            {
                ec = e.NativeErrorCode;
            }

            return ec;
        }

        private void ExecuteCoverCmd(string action)
        {
            ExecuteCoverCmd(action, String.Empty);
        }

        private void ExecuteCoverCmd(string action, string args)
        {
            Dictionary<string, int> missedTargets = 
                new Dictionary<string, int>();

            foreach (string targetUri in _targets)
            {
                string exeArgs = String.Format(
                    "/{0} /machine:{1} {2}"
                  , action
                  , targetUri
                  , args
                );

                ServerTestFramework.Global.RO.Debug(
                    String.Format(
                        "[Code Coverage]: *** > {0} {1}", _exePath, exeArgs));

                String output = String.Empty;
                int ec = CCExecute(exeArgs, out output);
                if (ec != 0)
                {
                    missedTargets[targetUri] = ec;
                }                
            }

            if (missedTargets.Count > 0)
            {
                throw new CoverageExecutionException(args, missedTargets);
            }
        }

        private String GetCoveragePath(String server)
        {
            // Get the path of the coverage data from the server
            String output;
            int ec = CCExecute("/Getpath /machine:" + server, out output);

            if (ec != 0)
            {
                return String.Empty;
            }

            String path = String.Empty;
            String[] lines = output.Split(new char[] { '\n' });
            foreach (String line in lines)
            {
                Match m = Regex.Match(line, @"^'([^']*)'");
                if (m.Success)
                {
                    path = m.Groups[1].Value;
                    break;
                }
            }

            return path;
        }       

       
        private String GetUNCPath(String server, String path)
        {
            // Convert the path to UNC share name if it's not already one
            if (!path.StartsWith("\\\\"))
            {
                return "\\\\" + server + "\\" + path[0] + "$" + 
                    path.Substring(2);
            }
            else
            {
                return path;
            }
        }

        private int ImportDataFrom(String server)
        {
            String path = GetCoveragePath(server);

            if (path == String.Empty)
            {
                RO.Warn(server + ": Could not get coverage data path");
                return SystemErrorCode.FILE_NOT_FOUND;
            }

            path = GetUNCPath(server, path);

            // Upload all data in the directory
            // Get all the sub-directories and upload data from all of them
            if (!Directory.Exists(path))
            {
                RO.Warn("Could not access : " + path);
                return SystemErrorCode.FILE_NOT_FOUND;
            }

            String[] binaryPaths = Directory.GetDirectories(path);
            bool failed = false;

            Guid guid = Guid.NewGuid();
            // Copy data to local machine
            string uniqueCovDataFolder = Path.Combine(Path.Combine("funcoutput", "covData"), guid.ToString());
            string coverageDir = Path.Combine(Directory.GetCurrentDirectory(), uniqueCovDataFolder);

            // If we are not going to be importing the data then create a unique directory for the files so that we
            // can save them off for later use.
            if (!_importData)
            {
                if (!Directory.Exists(coverageDir))
                {
                    Directory.CreateDirectory(coverageDir);
                }
            }
            foreach (String binaryPath in binaryPaths)
            {               
                String[] files = Directory.GetFiles(binaryPath, "*.covdata");

                foreach (String file in files)
                {
                    if (_importData)
                    {
                        // Execute covdata to import the data to the database
                        if (ExecuteCovData(file) != 0)
                        {
                            failed = true;
                        }
                    }
                    else
                    {
                        string destFile = Path.Combine(coverageDir, Path.GetFileName(file));
                        RO.Info(String.Format("Copy {0} to {1}", file, destFile));
                        File.Copy(file, destFile);
                    }
                }
            }

            if (failed)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }

        private int ExecuteCovData(String file)
        {
            int ec = 0;

            Process proc = new Process();
           
            try
            {
                proc.EnableRaisingEvents = false;

                proc.StartInfo.CreateNoWindow = true;
                proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                proc.StartInfo.FileName = "Covdata.exe";
                proc.StartInfo.Arguments = "/i \"" + file + "\" /db \"Server="+
                    _db.ServerUri + ";Database=" + _db.Name + "\"";
                proc.StartInfo.UseShellExecute = false;

                proc.Start();
                proc.WaitForExit();

                ec = proc.ExitCode;
            }
            catch (Win32Exception e)
            {
                ec = e.NativeErrorCode;
            }

            return ec;
        }        

        private void DeleteCoverageData(String server)
        {
            // Get the coverage path
            String path = GetCoveragePath(server);

            if (path == String.Empty)
            {
                return;
            }
            
            // Close coverage session before deleting just to be sure
            String args = "/close /machine:" + server;
            String output;
            CCExecute(args, out output);
            
            // Convert path to UNC path
            path = GetUNCPath(server, path);

            if (Directory.Exists(path))
            {
                Directory.Delete(path, true);
            }
        }

        private void SetRunId(String server, String runId)
        {
            String path = GetCoveragePath(server);

            if (path != String.Empty)
            {
                String[] components = path.Split(new char[] { '\\' });
                if ((components.Length > 1) && 
                    (components[components.Length - 1].ToLower() 
                     != "coverage"))
                {
                    String newPath = String.Empty;
                    for (int i = 0;i < components.Length - 1;i++)
                    {
                        newPath += components[i];

                        if (i != components.Length - 2)
                        {
                            newPath += "\\";
                        }
                    }

                    path = newPath;
                }


                path += "\\" + runId;

                String output;
                int ec = CCExecute("/Setpath \"" + path + "\" /machine:" + 
                                   server, out output);            
            }
        }

        #endregion // Internal Methods

        #region ICoverageCollector Members

        void ICoverageCollector.Initialize(String runId)
        {
            RO.Info("Using Run ID : " + runId);
            foreach (string targetServer in _targets)
            {
                SetRunId(targetServer, runId);
            }
        }

        void ICoverageCollector.Start(string traceName)
        {
            _traceName = traceName;

            ExecuteCoverCmd("reset");
        }

        void ICoverageCollector.Close()
        {
            ExecuteCoverCmd("close");
        }

        void ICoverageCollector.Reset()
        {
            ExecuteCoverCmd("reset");
        }

        void ICoverageCollector.Save()
        {
            ExecuteCoverCmd(
                "save",
                String.Format("/as \"{0}\"",
                              _traceName));
        }

        void ICoverageCollector.Import()
        {
            // Go through the targets
            // and import all the data in them
            foreach (string targetServer in _targets)
            {
                int ec = ImportDataFrom(targetServer);

                if (ec == 0)
                {
                    DeleteCoverageData(targetServer);
                }
                else
                {
                    RO.Error("Import failed from '" + targetServer + 
                             "'. Trace files collected at '" + 
                             GetUNCPath(targetServer, 
                                        GetCoveragePath(targetServer)));
                }
            }
        }

        bool ICoverageCollector.SupportsSaveToFile{get { return false; }}
        void ICoverageCollector.SaveToFile(string fileName)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        #endregion // ICoverageCollector Members
    }

    internal class SqlCC : ICoverageCollector
    {
        private static Report RO = new Report("Code Coverage > SQL");

        private string _configFilePath;

        private string _traceName;

        /// <summary>
        /// Creates ICoverageCollectors for all Sql Components
        /// </summary>
        /// <returns>An array of ICoverageCollectors</returns>
        public static ICoverageCollector[] CreateCollectors()
        {
            ICoverageCollector[] ret = null;

            if ((SystemErrorCode.FILE_NOT_FOUND != 
                 CCExecute(_exeCollectPath, String.Empty)) && 
                (SystemErrorCode.FILE_NOT_FOUND != 
                 CCExecute(_exeImportPath, String.Empty)))
            {
                List<ICoverageCollector> collectors = 
                    new List<ICoverageCollector>();

                // TODO : This works for Xblobs. Need to change this to target
                // specific DBs in expanded environments
                string[] servers = 
                    Global.XEnv.GetServerListByInterface("xmgmtsrv");
                int i = 0;
                foreach (string server in servers)
                {
                    // Replace the template with the server name
                    String configFilePath = CreateTemplateFile(server, i);

                    ICoverageCollector sqlCC = 
                        (ICoverageCollector) 
                        new SqlCC(configFilePath);
                    
                    collectors.Add(sqlCC);
                    i++;
                }

                if (collectors.Count > 0)
                {
                    ret = collectors.ToArray();
                }
                else
                {
                    RO.Warn("Could not find any SQL databases");
                }
            }
            else
            {
                RO.Warn("SqlCC tools not installed!");
            }

            return ret;           
        }

        private SqlCC(string configFilePath)
        {
            _configFilePath = configFilePath ?? "sqlcc-config.xml";
        }

        private static String GetVersion(String server)
        {
            String version;
            IInterfaceInfo tmp = Config.GetInterface(server, 
                                                     Interface.xmgmtsrv);

            String ip = tmp.IPAddress.ToString();
            ManagementConsole.Execute(new IPEndPoint(tmp.IPAddress, tmp.Port), 
                                      "e :xmgmtsrv getversion", 
                                      out version);
            version = version.Trim();
            return version;
        }

        private static String CreateTemplateFile(string server, int index)
        {
            // Get the current build version
            string version = GetVersion(server);

            // Open the template and replace server name and version
            String configFilePath = "sqlcc-config-" + index.ToString() + 
                ".xml";
            
            using (StreamReader r = File.OpenText("sqlcc-config-template.xml"))
            {
                using (StreamWriter w = File.CreateText(configFilePath))
                {
            
                    String line = r.ReadLine();
                    while (line != null)
                    {                                                
                        // Replace %VERSION% and %XBLOB%
                        line = line.Replace("%VERSION%", version);
                        line = line.Replace("%XBLOB%", server);
                        
                        w.WriteLine(line);

                        line = r.ReadLine();
                    }
                }
            }
            
            return configFilePath;
        }


        #region Internal Methods

        private const string _exeInstrumentPath = "sqlccinstrument.bat";
        private const string _exeCollectPath = "sqlcctrace.bat";
        private const string _exeImportPath  = "sqlccimport.bat";

        private static int CCExecute(string exe, string args)
        {
            int ec = 0;

            Process proc = new Process();
            try
            {
                proc.EnableRaisingEvents = false;

                proc.StartInfo.CreateNoWindow = true;
                proc.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                proc.StartInfo.FileName  = exe;
                proc.StartInfo.Arguments = args;
                proc.StartInfo.UseShellExecute = false;
                proc.StartInfo.RedirectStandardOutput = true;

                proc.Start();

                using (StreamReader r = proc.StandardOutput)
                {
                    String line = r.ReadLine();
                    while (line != null)
                    {
                        // RO.Info(line);
                        line = r.ReadLine();
                    }
                }

                proc.WaitForExit();

                ec = proc.ExitCode;
            }
            catch (Win32Exception e)
            {
                ec = e.NativeErrorCode;
            }

            return ec;
        }

        private enum CommandType
        {
            Instrument,
            Trace,
            Import
        }

        private void ExecuteCmd(CommandType commandType, string command)
        {
            ExecuteCmd(commandType, command, null);
        }

        private void ExecuteCmd(CommandType commandType, 
                                string command, 
                                string extra)
        {
            string exe = null;
            switch (commandType)
            {
                case CommandType.Instrument:
                    exe  = _exeInstrumentPath;
                    break;

                case CommandType.Trace:
                    exe  = _exeCollectPath;
                    break;

                case CommandType.Import:
                    exe  = _exeImportPath;
                    break;
            }
            
            string args = String.Format(
                "-c {0} {1} {2} {3}"
              , _configFilePath
              , command
              , _traceName
              , extra ?? String.Empty
            );

            ServerTestFramework.Global.RO.Debug(
                String.Format("[Code Coverage]: *** > {0} {1}", exe, args));

            int ec = CCExecute(exe, args);
            if (ec != 0)
            {
                // Ignore error code 2 in instrumentation
                // It just means DB is already instrumented
                if ((commandType != CommandType.Instrument) || (ec != 2))
                {
                    throw new CoverageExecutionException(args, "SqlCC", ec);
                }
            }
        }

        #endregion // Internal Methods

        #region ICoverageCollector Members

        void ICoverageCollector.Initialize(String runId)
        {
            // Instrument the SQL DBs
            _traceName = String.Empty;
            
            ExecuteCmd(CommandType.Instrument, "");
        }

        void ICoverageCollector.Start(string traceName)
        {
            _traceName = traceName;

            // Close to ensure that the trace file isn't being held-open by a 
            // previous command
            // Close will not throw even if the file DNE, so this is safe to do
            // Force-Create (overwrite any existing trace with the same name)
            ExecuteCmd( CommandType.Trace , "-Close"        );
            ExecuteCmd( CommandType.Trace , "-Create", "-f" );
            ExecuteCmd( CommandType.Trace , "-Start"        );
        }

        void ICoverageCollector.Close()
        {
            ExecuteCmd(CommandType.Trace, "-Close");
        }

        void ICoverageCollector.Reset()
        {
            ExecuteCmd(CommandType.Trace, "-Reset");
        }

        void ICoverageCollector.Save()
        {
            ExecuteCmd(CommandType.Import, "-i", "-as " + _traceName);
        }

        void ICoverageCollector.Import()
        {
            // empty
        }

        bool ICoverageCollector.SupportsSaveToFile
        {
            get { return false; }
        }

        void ICoverageCollector.SaveToFile(string fileName)
        {
            throw new Exception("The method or operation is not implemented.");
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildCore\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildCore\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\ConsoleTestEventListener.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using System.Collections;

namespace STFConsole
{
    class ConsoleTestEventListener : TestEventListener
    {
        ArrayList _Failures;
        private bool failures=false;

        public ConsoleTestEventListener()
        {
            _Failures = new ArrayList();
        }

        public void OnTestEvent(TestEventArgs e)
        {
            switch(e.Action)
            {
                case TestAction.StartAll:
                    _Failures.Clear();
                    break;
                case TestAction.Start:
                    break;
                case TestAction.Pass:
                    break;
                case TestAction.Fail: 
                case TestAction.PreFail: 
                case TestAction.PostFail: 
                case TestAction.Timeout:
                    _Failures.Add(e);
                    failures=true;
                    break;
                case TestAction.Ignore:
                    break;
            }
        }

        public void DumpFailures()
        {
            foreach(TestEventArgs e in _Failures)
            {
                Global.RO.Error("Test failed: {0}: {1}", e.Node.FullName, e.Details);
            }
        }

        public bool WereAnyFailures()
        {
            return failures;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildCore\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_stfconsolecore_none_12.4.56.0_none_7f3a2de6b884b5f7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=stfconsolecore
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7.manifest
XP_MANIFEST_PATH=manifests\x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7.cat
XP_CATALOG_PATH=manifests\x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7.cat
XP_PAYLOAD_PATH=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=stfconsolecore,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildCore\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildLive\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildCore\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_stfconsolecore_none_12.4.56.0_none_7f3a2de6b884b5f7
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=stfconsolecore
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7.manifest
XP_MANIFEST_PATH=manifests\x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7.cat
XP_CATALOG_PATH=manifests\x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7.cat
XP_PAYLOAD_PATH=x86_stfconsolecore_no-public-key_12.4.56.0_x-ww_0a85e5a7
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=stfconsolecore,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\XmlTestEventListener.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using System.Collections;
using System.Collections.Generic;
using System.Xml;

namespace STFConsole
{
    /// <summary>
    /// This class derives from the TestEventListener class and provides functionality for generating an xml results file for an STF run.
    /// </summary>
    class XmlTestEventListener : TestEventListener
    {
        const string SUITE_NODE = "test-suite";
        const string TESTCASE_NODE = "test-case";
        const string RESULTS_NODE = "results";
        const string FAILURE_NODE = "failure";
        const string REASON_NODE = "reason";
        const string STACK_NODE = "stack-trace";
        const string MESSAGE_NODE = "message";
        const string NAME_ATTR = "name";
        const string OWNER_ATTR = "owner";
        const string EXECUTED_ATTR = "executed";
        const string SUCCESS_ATTR = "success";
        const string TIME_ATTR = "time";
        const string KNOWN_BUG_DB_ATTR = "knownbug-database";
        const string KNOWN_BUG_NUM_ATTR = "knownbug-number";
        const string PRIORITY_ATTR = "priority";
        const string FREQUENCY_ATTR = "frequency";
        const string ENVREQ_ATTR = "envrequirements";
        const string FEATUREAREAS_ATTR = "featureareas";
        const string TIMEOUT_ATTR = "istimedout";

        // Member fields
        protected XmlDocument _results;
        protected string _filename;
        public Object _eventLock = new Object();

        // summary counters
        protected uint _totalcases = 0;
        protected uint _failures = 0;
        protected uint _notrun = 0;
        protected uint _timeout = 0;

        // Dictionary used to keep track of the time duration for each element
        protected Dictionary<string, DateTime> _startTimes;

        // Dictionary used to keep track of the dll that each node is contained in.
        protected Dictionary<string, string> _containingDlls;

        /// <summary>
        /// Creates a new instance of an XmlTestEventListener object that will save the xml results to the specified file
        /// </summary>
        /// <param name="filename"></param>
        public XmlTestEventListener(string filename, string[] dllnames)
        {
            _results = new XmlDocument();
            _filename = filename;
            _startTimes = new Dictionary<string, DateTime>();

            // Create the root element meta nodes
            CreateRoot();

            // Prepoulate all the test nodes and the containing dlls
            _containingDlls = new Dictionary<string, string>();
            LinkedList<TestNode> nodes = new LinkedList<TestNode>();
            foreach (string dll in dllnames)
            {
                nodes.AddLast(TestNode.GenerateNodeTree(dll));
                foreach (TestNode node in nodes)
                {
                    // Store the containing dll
                    AddContainingDll(node, dll);
                }
            }
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(UnhandledExceptionHandler);
        }

        /// <summary>
        /// Enumerates the test nodes and add the relevant entries in the _containingDlls dictionary
        /// </summary>
        private void AddContainingDll(TestNode node, string dll)
        {
            _containingDlls.Add(node.FullName, dll);
            foreach (TestNode child in node.Children)
                AddContainingDll(child, dll);

            // If the node was a test case, create an empty (ignored) case for it. This is so that we always have a test-case node for every test, even when a suite setup fails.'
            if (0 == node.ChildrenCount)
            {
                if(node.FunctionalData != null)
                {
                    CreateTestCaseNode(node.FullName, new TestEventArgs(node, "Default State-No Information", TestAction.Ignore));
                    ++_totalcases;
                    ++_notrun;
                }
            }
        }

        /// <summary>
        /// Handles the test events that are raised from the STF runner
        /// </summary>
        /// <param name="e"></param>
        public void OnTestEvent(TestEventArgs e)
        {
            lock (_eventLock)
            {
                // There are rare cases where a node is not added to the _containingDlls dictionary,
                // but gets run nonetheless. If that's the case, add it to the dictionary here and
                // increment the proper case counters
                if (e.Node != null && !_containingDlls.ContainsKey(e.Node.FullName))
                {
                    string dll = "";
                    if (e.Node.Parent != null && _containingDlls.ContainsKey(e.Node.Parent.FullName))
                    {
                        dll = _containingDlls[e.Node.Parent.FullName];
                    }
                    AddContainingDll(e.Node, dll);
                }

                // NOTE: Retry events are deliberately not handled here. Instead, 
                switch (e.Action)
                {
                    case TestAction.Start:
                        // Add the start time to the dictionary for tracking (if retry, there will already be an entry)
                        if (!_startTimes.ContainsKey(e.Node.FullName))
                            _startTimes.Add(e.Node.FullName, DateTime.Now);
                        else
                            _startTimes[e.Node.FullName] = DateTime.Now;
                        break;

                    case TestAction.PreFail:
                        // If it's a testcase, process the same as a Fail
                        if (0 == e.Node.ChildrenCount)
                        {
                            goto case TestAction.Fail;
                        }
                        else
                        {
                            // If it's a group setup failure, we need to recursively fail all the subnodes with a failure reason that the group setup failed.
                            string eventMessage;
                            string eventStack;
                            GetTestEventArgsErrorStrings(e, out eventMessage, out eventStack);

                            string failMsg = eventMessage;
                            if (eventStack.Length > 0)
                            {
                                failMsg += "\n";
                            }
                            failMsg += eventStack;

                            FailTestSuite(e.Node, failMsg);
                        }
                        break;

                    case TestAction.PostFail:
                        // If it's a testcase, ensure success = false and create failure node
                        if (0 == e.Node.ChildrenCount)
                        {
                            XmlNode caseNode = LocateTestCaseNode(e.Node.FullName);
                            caseNode.Attributes[SUCCESS_ATTR].Value = "false";
                            caseNode.AppendChild(CreateFailureNode(e));
                        }
                        else
                        {
                            // If it's a group cleanup failure, ensure success = false
                            XmlNode suiteNode = LocateTestSuiteNode(e.Node.FullName.Split('.'), e.Node.FullName);
                            suiteNode.Attributes[SUCCESS_ATTR].Value = "false";
                        }
                        break;
                    case TestAction.Timeout:
                        if (e.Node.ChildrenCount > 0)
                        {
                            AddTimeAttribute(CreateTestSuiteNode(e.Node.FullName.Split('.'), e.Node.FullName), e.Node.Name, null);
                            break;
                        }

                        // Nodes without a FunctionalData object are invalid and should not be counted (or reported)
                        if (null != e.Node.FunctionalData)
                        {
                            --_notrun;
                            ++_timeout;
                            CreateTestCaseNode(e.Node.FullName, e);
                        }
                        break;
                    case TestAction.Fail:
                        if (e.Node.ChildrenCount > 0)
                        {
                            AddTimeAttribute(CreateTestSuiteNode(e.Node.FullName.Split('.'), e.Node.FullName), e.Node.Name, null);
                            break;
                        }

                        // Nodes without a FunctionalData object are invalid and should not be counted (or reported)
                        if (null != e.Node.FunctionalData)
                        {
                            --_notrun;
                            ++_failures;
                            CreateTestCaseNode(e.Node.FullName, e);
                        }
                        break;

                    case TestAction.Ignore:
                        if (e.Node.ChildrenCount > 0)
                        {
                            AddTimeAttribute(CreateTestSuiteNode(e.Node.FullName.Split('.'), e.Node.FullName), e.Node.Name, null);
                            // If it's a group setup ignore, we need to recursively ignore all the subnodes with a reason.
                            string eventMessage;
                            string eventStack;
                            GetTestEventArgsErrorStrings(e, out eventMessage, out eventStack);

                            string ignoreMsg = eventMessage;
                            if (eventStack.Length > 0)
                            {
                                ignoreMsg += "\n";
                            }
                            ignoreMsg += eventStack;

                            IgnoreTestSuite(e.Node, ignoreMsg);
                            break;
                        }
                        CreateTestCaseNode(e.Node.FullName, e);
                        break;

                    case TestAction.Pass:
                        if (e.Node.ChildrenCount > 0)
                        {
                            AddTimeAttribute(CreateTestSuiteNode(e.Node.FullName.Split('.'), e.Node.FullName), e.Node.Name, null);
                            break;
                        }
                        --_notrun;
                        CreateTestCaseNode(e.Node.FullName, e);
                        break;

                    case TestAction.Retry:
                        // If a test is going to retry it will get re-added when a pass/fail event is received later
                        if (0 == e.Node.ChildrenCount)
                        {
                            // Update the counts as appropriate
                            ++_notrun;
                            if (e.Node.FunctionalData.SchedulerData.RunResult == TEST_RESULTS.FAILED)
                                --_failures;
                        }
                        break;

                    case TestAction.StopAll:
                        FinishProcessing();
                        break;
                }
            }
        }

        /// <summary>
        /// Creates the root element for the xml file when the test run starts.
        /// </summary>
        private void CreateRoot()
        {
            XmlElement testResults = _results.CreateElement("test-results");
            XmlAttribute dateAttr = _results.CreateAttribute("date");
            dateAttr.Value = DateTime.Now.ToString("yyyy-MM-dd");
            testResults.Attributes.Append(dateAttr);
            XmlAttribute timeAttr = _results.CreateAttribute("time");
            timeAttr.Value = DateTime.Now.ToString("HH:mm:ss");
            testResults.Attributes.Append(timeAttr);
            _results.AppendChild(testResults);
        }

        /// <summary>
        /// Creates the environment element for the xml file when the test run starts.
        /// </summary>
        private void CreateEnvElement()
        {
            XmlNode envNode = _results.CreateNode(XmlNodeType.Element, "environment", null);
            _results.FirstChild.InsertBefore(envNode, _results.FirstChild.FirstChild);

            XmlAttribute nunitVerAttr = _results.CreateAttribute("nunit-version");
            nunitVerAttr.Value = ""; // Not actually running in nunit so just leave this blank so the xls picks it up
            envNode.Attributes.Append(nunitVerAttr);

            XmlAttribute clrVerAttr = _results.CreateAttribute("clr-version");
            clrVerAttr.Value = Environment.Version.ToString(); 
            envNode.Attributes.Append(clrVerAttr);

            XmlAttribute osVerAttr = _results.CreateAttribute("os-version");
            osVerAttr.Value = Environment.OSVersion.ToString(); 
            envNode.Attributes.Append(osVerAttr);

            XmlAttribute platAttr = _results.CreateAttribute("platform");
            platAttr.Value = Environment.OSVersion.Platform.ToString(); 
            envNode.Attributes.Append(platAttr);

            XmlAttribute cwdAttr = _results.CreateAttribute("cwd");
            cwdAttr.Value = Environment.CurrentDirectory; 
            envNode.Attributes.Append(cwdAttr);

            XmlAttribute machineNameAttr = _results.CreateAttribute("machine-name");
            machineNameAttr.Value = Environment.MachineName; 
            envNode.Attributes.Append(machineNameAttr);

            XmlAttribute userNameAttr = _results.CreateAttribute("user");
            userNameAttr.Value = Environment.UserName; 
            envNode.Attributes.Append(userNameAttr);

            XmlAttribute userDomainAttr = _results.CreateAttribute("user-domain");
            userDomainAttr.Value = Environment.UserDomainName; 
            envNode.Attributes.Append(userDomainAttr);
        }

        /// <summary>
        /// Creates the culture element for the xml file when the test run starts.
        /// </summary>
        private void CreateCultureElement()
        {
            XmlNode cultureNode = _results.CreateNode(XmlNodeType.Element, "culture", null);
            _results.FirstChild.InsertBefore(cultureNode, _results.FirstChild.FirstChild);

            XmlAttribute currentCultureAttr = _results.CreateAttribute("current-culture");
            currentCultureAttr.Value = System.Globalization.CultureInfo.CurrentCulture.ToString(); 
            cultureNode.Attributes.Append(currentCultureAttr);

            XmlAttribute currentUICultureAttr = _results.CreateAttribute("current-uiculture");
            currentUICultureAttr.Value = System.Globalization.CultureInfo.CurrentUICulture.ToString(); 
            cultureNode.Attributes.Append(currentUICultureAttr);
        }


        /// <summary>
        /// Completes the processing for the xml file. Summary counts and 
        /// </summary>
        private void FinishProcessing()
        {
            // Roll up the success attribute value
            foreach (XmlNode suite in _results.FirstChild.ChildNodes)
                RollUpSuccess(suite);

            // We need to aggregate the total duration to each of the "dll" level suites (1 below test-results) as there are never any events for them.
            foreach (XmlNode suite in _results.FirstChild.ChildNodes)
            {
                double totalSeconds = 0.0;
                foreach (XmlNode child in suite.SelectSingleNode(RESULTS_NODE).ChildNodes)
                {
                    XmlNode timeAttribute = child.Attributes[TIME_ATTR];
                    if (timeAttribute != null)
                    {
                        totalSeconds += Double.Parse(child.Attributes[TIME_ATTR].Value);
                    }
                }
                AddTimeAttribute(suite, null, TimeSpan.FromSeconds(totalSeconds));
            }

            // Add the totals to the test-results node
            XmlAttribute totalAttr = _results.CreateAttribute("total");
            totalAttr.Value = (Math.Abs(_totalcases)).ToString();
            _results.FirstChild.Attributes.Append(totalAttr);
            XmlAttribute failuresAttr = _results.CreateAttribute("failures");
            failuresAttr.Value = _failures.ToString();
            _results.FirstChild.Attributes.Append(failuresAttr);
            XmlAttribute timeoutAttr = _results.CreateAttribute("timeouts");
            timeoutAttr.Value = _timeout.ToString();
            _results.FirstChild.Attributes.Append(timeoutAttr);
            XmlAttribute notRunAttr = _results.CreateAttribute("not-run");
            notRunAttr.Value = _notrun.ToString();
            _results.FirstChild.Attributes.Append(notRunAttr);
            XmlAttribute totalCasesAttr = _results.CreateAttribute("totalcases");
            totalCasesAttr.Value = _totalcases.ToString();
            _results.FirstChild.Attributes.Append(totalCasesAttr);

            // Insert the environment related nodes (stack style insertion so actual order in file is opposite to these calls)
            CreateCultureElement();
            CreateEnvElement();

            // All done, so serialise it to file
            string dirName = System.IO.Path.GetDirectoryName(_filename);
            if (String.Empty != dirName && !System.IO.Directory.Exists(dirName))
                System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(_filename));
            if( _totalcases > 0 )
            {
              _results.Save(_filename);
            }
        }

        /// <summary>
        /// Creates a test-case node for the specified test. We also create the suite nodes for the test case if required
        /// </summary>
        /// <param name="fullTestName">The fully qualified test name</param>
        /// <param name="e">The TestEventArgs specifying the action and relevant details</param>
        private void CreateTestCaseNode(string fullTestName, TestEventArgs e)
        {
            // We need to restrict this to only Pass/PreFail/PostFail/Fail/Ignore actions
            if (TestAction.Pass != e.Action && TestAction.PreFail != e.Action && TestAction.Fail != e.Action && TestAction.PostFail != e.Action && TestAction.Ignore != e.Action && TestAction.Timeout != e.Action)
                throw new ArgumentException("CreateTestCaseNode can only be called for actions Pass/Fail/Ignore/Timeout. It was called in error with action " + e.Action.ToString());

            // Make sure the appropriate test-suite nodes are created
            List<string> suiteTokens = new List<string>(fullTestName.Split('.'));
            suiteTokens.RemoveAt(suiteTokens.Count - 1); // Remove the last token here because the last one is the testcase name and not a suite name
            XmlNode suiteNode = CreateTestSuiteNode(suiteTokens.ToArray(), fullTestName);

            // Add the test-case node. If it already exists, replace the old one
            XmlNode testCase = LocateTestCaseNode(fullTestName);
            if (null != testCase)
                suiteNode.SelectSingleNode(RESULTS_NODE).RemoveChild(testCase);
            testCase = _results.CreateNode(XmlNodeType.Element, "test-case", null);
            suiteNode.SelectSingleNode(RESULTS_NODE).AppendChild(testCase);

            XmlAttribute nameAttr = _results.CreateAttribute(NAME_ATTR);
            nameAttr.Value = fullTestName;
            testCase.Attributes.Append(nameAttr);

#if UsingSTFLive
            XmlAttribute ownerAttr = _results.CreateAttribute(OWNER_ATTR);
            string owner = StringUtils.MakeDeliminatorSeparatedList(NodeTaggingLive.GetOwnerValues(e.Node), "|");
            ownerAttr.Value = owner;
            testCase.Attributes.Append(ownerAttr);

            XmlAttribute priorityAttr = _results.CreateAttribute(PRIORITY_ATTR);
            string priority = StringUtils.MakeDeliminatorSeparatedList(NodeTaggingLive.GetPriorityValues(e.Node), "|");
            priorityAttr.Value = priority;
            testCase.Attributes.Append(priorityAttr);

            XmlAttribute freqAttr = _results.CreateAttribute(FREQUENCY_ATTR);
            string frequency = StringUtils.MakeDeliminatorSeparatedList(NodeTaggingLive.GetFrequencyValues(e.Node), "|");
            freqAttr.Value = frequency;
            testCase.Attributes.Append(freqAttr);

            XmlAttribute envReqAttr = _results.CreateAttribute(ENVREQ_ATTR);
            string envReq = StringUtils.MakeDeliminatorSeparatedList(NodeTaggingLive.GetRequirementValues(e.Node), "|");
            envReqAttr.Value = envReq;
            testCase.Attributes.Append(envReqAttr);

            XmlAttribute featureAreasAttr = _results.CreateAttribute(FEATUREAREAS_ATTR);
            string featureAreas = StringUtils.MakeDeliminatorSeparatedList(NodeTaggingLive.GetFeatureAreaValues(e.Node), "|");
            featureAreasAttr.Value = featureAreas;
            testCase.Attributes.Append(featureAreasAttr);
#endif

            XmlAttribute executedAttr = _results.CreateAttribute(EXECUTED_ATTR);
            executedAttr.Value = (TestAction.Ignore == e.Action ? "False" : "True");
            testCase.Attributes.Append(executedAttr);
            if (TestAction.Ignore != e.Action)
            {
                XmlAttribute successAttr = _results.CreateAttribute(SUCCESS_ATTR);
                successAttr.Value = (TestAction.Pass == e.Action ? "True" : "False");
                testCase.Attributes.Append(successAttr);

                XmlAttribute timeoutAttr = _results.CreateAttribute(TIMEOUT_ATTR);
                timeoutAttr.Value = (TestAction.Timeout == e.Action ? "True" : "False");
                testCase.Attributes.Append(timeoutAttr);
            }

            AddTimeAttribute(testCase, e.Node.FullName, null);

            // If the test failed, create a <failure> element
            if (TestAction.Fail == e.Action || TestAction.PreFail == e.Action || TestAction.PostFail == e.Action || TestAction.Timeout == e.Action)
            {
                testCase.AppendChild(CreateFailureNode(e));

                // If it was a known failure, attribute it as such and add the BugID element. Bug ID's without a database name are not considered
                if (0 != e.BugID && null != e.BugDatabase)
                {
                    XmlAttribute kbAttr = _results.CreateAttribute(KNOWN_BUG_DB_ATTR);
                    kbAttr.Value = e.BugDatabase;
                    testCase.Attributes.Append(kbAttr);

                    kbAttr = _results.CreateAttribute(KNOWN_BUG_NUM_ATTR);
                    kbAttr.Value = e.BugID.ToString();
                    testCase.Attributes.Append(kbAttr);
                }
            }

            // If the test was ignored, output the reason if it was specified
            if (TestAction.Ignore == e.Action)
            {
                testCase.AppendChild(CreateIgnoreReasonNode(e));
            }
        }

        /// <summary>
        /// Creates all the test-suite nodes along the nested heirarchy using the tokens of the fully qualified name
        /// </summary>
        /// <param name="tokens">Tokens from the name that define the nesting heirarchy</param>
        /// <returns>The XmlNode for the results element of the lowest test-suite node in the heirarchy</returns>
        private XmlNode CreateTestSuiteNode(string[] tokens, string fullTestName)
        {
            // Prepend the containing dll name to the list of tokens
            List<string> qualifiedTokens = new List<string>(tokens.Length+1);
            qualifiedTokens.Add(_containingDlls[fullTestName]);
            qualifiedTokens.AddRange(tokens);

            XmlNode iterator = _results.FirstChild;
            bool create;
            foreach (string token in qualifiedTokens)
            {
                create = true;
                foreach (XmlNode child in iterator.ChildNodes)
                {
                    if (child!=null && child.Attributes[NAME_ATTR]!=null && child.Attributes[NAME_ATTR].Value.Equals(token))
                    {
                        iterator = child.SelectSingleNode(RESULTS_NODE);
                        create = false;
                        break;
                    }
                }
                if (create)
                {
                    XmlNode newNode = _results.CreateNode(XmlNodeType.Element, SUITE_NODE, null);
                    XmlAttribute nameAttr = _results.CreateAttribute(NAME_ATTR);
                    nameAttr.Value = token;
                    newNode.Attributes.Append(nameAttr);
                    XmlAttribute successAttr = _results.CreateAttribute(SUCCESS_ATTR);
                    successAttr.Value = "false";
                    newNode.Attributes.Append(successAttr);

                    XmlAttribute executedAttr = _results.CreateAttribute(EXECUTED_ATTR);
                    executedAttr.Value = "false";
                    newNode.Attributes.Append(executedAttr);
                    newNode.AppendChild(_results.CreateNode(XmlNodeType.Element, RESULTS_NODE, null));
                    iterator.AppendChild(newNode);
                    iterator = newNode.SelectSingleNode(RESULTS_NODE);
                }
            }

            // We have to return the parent node here so that we actually return the test-suite node
            return iterator.ParentNode;
        }

        /// <summary>
        /// Fails an entire test-suite. It marks the suite as failed and propogates the failure message down to all lower suites and test cases.
        /// </summary>
        private void FailTestSuite(TestNode node, string failMsg)
        {
            // We handle this situation by simply invoking the current logic that is in place by creating new Failure events for all the childcases.
            // If we have suite child nodes, well recursively call back to fail that entire suite etc.

            foreach (TestNode child in node.Children)
            {
                if (0 == child.ChildrenCount)
                    OnTestEvent(new TestEventArgs(child, failMsg, TestAction.Fail));
                else
                    FailTestSuite(child, failMsg);
            }
        }

        /// <summary>
        /// Ignore an entire test-suite. 
        /// </summary>
        private void IgnoreTestSuite(TestNode node, string failMsg)
        {
            // We handle this situation by simply invoking the current logic that is in place by creating new Ignore events for all the childcases.
            // If we have suite child nodes, well recursively call back to fail that entire suite etc.

            foreach (TestNode child in node.Children)
            {
                if (0 == child.ChildrenCount)
                    OnTestEvent(new TestEventArgs(child, failMsg, TestAction.Ignore));
                else
                    IgnoreTestSuite(child, failMsg);
            }
        }

        /// <summary>
        /// Rolls up the success of a case / suite to all the way up to the highest level test-suite nodes
        /// </summary>
        /// <param name="node">The node to derive the success value for</param>
        /// <returns>Aggregate success value for that node</returns>
        private bool RollUpSuccess(XmlNode node)
        {
            // Leaf nodes just return their success value
            if (node.Name.Equals(TESTCASE_NODE))
                // Pass up success for an ignored node
                if (null != node.Attributes[SUCCESS_ATTR])
                    return bool.Parse(node.Attributes[SUCCESS_ATTR].Value);
                else
                    return true;

            // Non-leaf nodes need to aggregate
            bool success = true;
            foreach (XmlNode child in node.SelectSingleNode(RESULTS_NODE).ChildNodes)
            {
                if (!RollUpSuccess(child))
                {
                    success = false;
                    // We must not break out here because we need to process all children
                }
            }

            // Special case here. If a group failed, it will be empty, so we report failure
            if (0 == node.SelectSingleNode(RESULTS_NODE).ChildNodes.Count)
                success = false;

            // Add the attribute
            XmlAttribute successAttr = _results.CreateAttribute(SUCCESS_ATTR);
            successAttr.Value = success.ToString();
            node.Attributes.Append(successAttr);

            return success;
        }

        /// <summary>
        /// Walks the test results tree to locate the test-case element based on the specified name
        /// </summary>
        /// <param name="fullTestName">The fully qualified name the specifies the test-case and relevant test-suite nesting</param>
        /// <returns>An XmlNode representing the test-case element</returns>
        private XmlNode LocateTestCaseNode(string fullTestName)
        {
            List<string> tokens = new List<string>(fullTestName.Split('.'));
            tokens.RemoveAt(tokens.Count - 1); // Remove the last token here because the last one is the testcase name and not a suite name
            XmlNode iterator = LocateTestSuiteNode(tokens.ToArray(), fullTestName);
            if (null == iterator)
                return null;
            else
                return iterator.SelectSingleNode(RESULTS_NODE + "/test-case[@name='" + System.Security.SecurityElement.Escape(fullTestName) + "']");
        }

        /// <summary>
        /// Walks the test results tree to locate the test-suite element based on the specified name
        /// </summary>
        /// <returns>An XmlNode representing the results element test-suite element corresponding to the last token in the input array</returns>
        private XmlNode LocateTestSuiteNode(string[] nameTokens, string fullTestName)
        {
            // Prepend the containing dll name to the list of tokens
            List<string> qualifiedTokens = new List<string>();
            qualifiedTokens.Add(_containingDlls[fullTestName]);
            qualifiedTokens.AddRange(nameTokens);

            XmlNode iterator = _results.FirstChild;
            for (int i = 0; i < qualifiedTokens.Count; i++)
                iterator = iterator.SelectSingleNode("test-suite[@name='" + qualifiedTokens[i] + "']/" + RESULTS_NODE);
            return iterator.ParentNode; // We return the last test-suite, not the nested results node
        }

        /// <summary>
        /// Creates a reason element with a text description of why a test was ignored (if available)
        /// </summary>
        /// <param name="e">The TestEventArgs object that contains the ignore reason</param>
        /// <returns>A XmlNode representing the new reason node</returns>
        private XmlNode CreateIgnoreReasonNode(TestEventArgs e)
        {
            XmlNode reasonNode = _results.CreateNode(XmlNodeType.Element, REASON_NODE, null);
            XmlNode messageNode = _results.CreateNode(XmlNodeType.Element, MESSAGE_NODE, null);
            XmlNode messageCdataNode = _results.CreateNode(XmlNodeType.CDATA, null, null);

            string messageString, stackString;
            GetTestEventArgsErrorStrings(e, out messageString, out stackString);
            messageCdataNode.InnerText=StripBadCharacters(messageString);

            messageNode.AppendChild(messageCdataNode);
            reasonNode.AppendChild(messageNode);

            return reasonNode;
        }

        /// <summary>
        /// Update a reason element with a text description of why a test was ignored (if available)
        /// </summary>
        /// <param name="e">The TestEventArgs object that contains the ignore reason</param>
        /// <returns>A XmlNode representing the new reason node</returns>
        private void UpdateIgnoreReasonNode(XmlNode node, TestEventArgs e)
        {
            XmlNode reasonNode = CreateIgnoreReasonNode(e);
            if( node.ChildNodes.Count == 1 && node.ChildNodes[0].Name == "reason")
            {
                node.ReplaceChild(reasonNode, node.ChildNodes[0]);
            }
            else
            {
                node.AppendChild(CreateIgnoreReasonNode(e));
            }
        }

        /// <summary>
        /// Creates a failure element with stack trace details
        /// </summary>
        /// <param name="e">The TestEventArgs object that contains the failure reason</param>
        /// <returns>A XmlNode representing the new failure node</returns>
        private XmlNode CreateFailureNode(TestEventArgs e)
        {
            XmlNode failureNode = _results.CreateNode(XmlNodeType.Element, FAILURE_NODE, null);
            XmlNode messageNode = _results.CreateNode(XmlNodeType.Element, MESSAGE_NODE, null);
            XmlNode messageCdataNode = _results.CreateNode(XmlNodeType.CDATA, null, null);
            XmlNode stackNode = _results.CreateNode(XmlNodeType.Element, STACK_NODE, null);
            XmlNode stackCdataNode = _results.CreateNode(XmlNodeType.CDATA, null, null);

            string messageString, stackString;
            GetTestEventArgsErrorStrings(e, out messageString, out stackString);
            messageCdataNode.InnerText=StripBadCharacters(messageString);
            stackCdataNode.InnerText=StripBadCharacters(stackString);

            messageNode.AppendChild(messageCdataNode);
            failureNode.AppendChild(messageNode);

            stackNode.AppendChild(stackCdataNode);
            failureNode.AppendChild(stackNode);

            return failureNode;
        }

        /// <summary> Retrieves an error string from a TestEventArgs, based on the messages and exception information stored in it. </summary>
        private void GetTestEventArgsErrorStrings(TestEventArgs e, out string messageString, out string stackString)
        {
            messageString="";
            stackString="";

            if (e.Details!=null && e.Details.Length>0)
            {
                messageString=e.Details;
            }

            if (e.Message!=null && e.Message.Length>0)
            {
                if (messageString.Length>0)
                {
                    messageString+="\n";
                }
                messageString+=e.Message;
            }

            if (e.Stack!=null && e.Stack.Length>0)
            {
                stackString=e.Stack;
            }
        }

        /// <summary>
        /// Adds the time= attribute to the specified in element
        /// </summary>
        /// <param name="element">The element to add the time attribute to</param>
        /// <param name="name">The name of the test case or test suite</param>
        private void AddTimeAttribute(XmlNode element, string name, TimeSpan? time)
        {
            TimeSpan duration = TimeSpan.Zero;

            // If no time passed in, calculate it from the events
            if (null == time)
            {
                if (_startTimes.ContainsKey(name)) // If there is no start time for this then we'll add duration 0 (typically just for ignored cases when group setup failed)
                    duration = DateTime.Now - _startTimes[name];
            }
            else
            {
                duration = (TimeSpan)time;
            }

            // Add the attribute
            XmlAttribute timeAttr = _results.CreateAttribute(TIME_ATTR);
            timeAttr.Value = duration.TotalSeconds.ToString("f3");
            element.Attributes.Append(timeAttr);
        }

        /// <summary> Strips any "illegal characters" out of a string so it can be placed into xml text. </summary>
        private static string StripBadCharacters(string str)
        {
            return str.Replace("\0", "");
        }

        /// <summary>
        /// Handle any unhandled exceptions
        /// </summary>
        /// <param name="sender">Sender</param>
        /// <param name="e">Event args</param>
        void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e)
        {
            FinishProcessing();
            AppDomain.CurrentDomain.UnhandledException -= new UnhandledExceptionEventHandler(UnhandledExceptionHandler);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\CsvNodeWriter.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace STFConsole
{
    /// <summary>
    /// Handles the generation of the CSV data file
    /// </summary>
    public class CSVFileGenerator
    {
        /// <summary>
        /// Holds the header for the data elements
        /// </summary>
        protected string[] _headers;

        /// <summary>
        /// Stores all the details for the report
        /// </summary>
        protected List<string[]> _details;

        /// <summary>
        /// Instantiates a new CSVFileGenerator object for the specified filename
        /// </summary>
        /// <param name="filename">The file to write the data to</param>
        public CSVFileGenerator()
        {
            _headers = null;
            _details = new List<string[]>();
        }

        /// <summary>
        /// Adds a new result to the report
        /// </summary>
        /// <param name="data">The data items for the </param>
        public void AddResult(string[] data)
        {
            if (null == _headers)
                throw new InvalidOperationException("Data cannot be added to the report until the data headers have been specified");
            if (data.Length != _headers.Length)
                throw new ArgumentException("The number of data elements (" + data.Length.ToString() + ") does not match the number of headers (" + _headers.Length.ToString() + ")");

            _details.Add(data);
        }

        /// <summary>
        /// Generates the report to the specified filename
        /// </summary>
        /// <param name="filename">The file to output the report to</param>
        public void GenerateReport(string filename)
        {
            try
            {
                if (File.Exists(filename))
                    File.Delete(filename);
            }
            catch (IOException)
            {
                Console.WriteLine("ERROR: Failed to generate output file. Most likely cause is that the file was locked by another application");
                return;
            }

            // Write all the data out to the file
            using (StreamWriter sw = new StreamWriter(filename))
            {
                WriteArray(_headers, sw);
                foreach (string[] item in _details)
                    WriteArray(item, sw);
            }
        }

        /// <summary>
        /// Writes a data array to the specified StreamWriter
        /// </summary>
        /// <param name="items">The string array to write</param>
        /// <param name="sw">The StreamWriter object to write to</param>
        private void WriteArray(string[] items, StreamWriter sw)
        {
            for (int i = 0; i < items.Length - 1; i++)
            {
                sw.Write(items[i].Trim());
                sw.Write(",");
            }
            sw.Write(items[items.Length - 1].Trim());
            sw.WriteLine();
        }

        /// <summary>
        /// Gets / Sets the data headers for the data. This is used to control the expected length of the data array passed to Addresult
        /// </summary>
        /// <param name="headers"></param>
        public string[] DataHeaders
        {
            get
            {
                return _headers;
            }
            set
            {
                _headers = value;
                _details = new List<string[]>();
            }
        }
    };


    public class CsvNodeWriter
    {
#if UsingSTFLive
        /// <summary>
        /// Walks back up the tree to look at all the parent nodes to find the most specific owner tag
        /// </summary>
        /// <param name="node">The node to start with and work back from</param>
        /// <returns>Owner</returns>
        private static string GetOwnerForNode(TestNode node)
        {
            NodeTaggingData.ValueSet values=NodeTaggingLive.GetOwnerValues(node);
            return StringUtils.MakeDeliminatorSeparatedList(values, " ");
        }

        /// <summary>
        /// Walks back up the tree to look at all the parent nodes to find the most specific FeatureArea tag
        /// </summary>
        /// <param name="node">The node to start with and work back from</param>
        /// <returns>Owner</returns>
        public static string GetFeatureArea(TestNode node)
        {
            NodeTaggingData.ValueSet values=NodeTaggingLive.GetFeatureAreaValues(node);
            return StringUtils.MakeDeliminatorSeparatedList(values, " ");
        }

        /// <summary>
        /// Walks back up the tree to look at all the parent nodes to find the most specific Test Frequency tag
        /// </summary>
        /// <param name="node">The node to start with and work back from</param>
        /// <returns>Test Frequency</returns>
        private static string GetTestFrequency(TestNode node)
        {
            NodeTaggingData.ValueSet values=NodeTaggingLive.GetFrequencyValues(node);
            return StringUtils.MakeDeliminatorSeparatedList(values, " ");
        }

        /// <summary>
        /// Walks back up the tree to look at all the parent nodes to find the most specific Priority tag
        /// </summary>
        /// <param name="node">The node to start with and work back from</param>
        /// <returns>Test Priority</returns>
        private static string GetTestCasePriority(TestNode node)
        {
            NodeTaggingData.ValueSet values=NodeTaggingLive.GetPriorityValues(node);
            return StringUtils.MakeDeliminatorSeparatedList(values, " ");
        }

        /// <summary>
        /// Walks back up the tree to look at all the parent nodes to find the most specific requirement tag
        /// </summary>
        /// <param name="node">The node to start with and work back from</param>
        /// <returns>Requirement</returns>
        private static string GetRequirement(TestNode node)
        {
            NodeTaggingData.ValueSet values=NodeTaggingLive.GetRequirementValues(node);
            return StringUtils.MakeDeliminatorSeparatedList(values, " ");
        }

        /// <summary>
        /// Gets generic tags on a node.
        /// </summary>
        /// <param name="node">The node to start with and work back from</param>
        /// <returns>Tags</returns>
        private static string GetGenericTags(TestNode node)
        {
            Dictionary<string, NodeTaggingData.ValueSet> tags=NodeTaggingLive.GetGenericNodeTags(node);
            string str="";
            foreach (string key in tags.Keys)
            {
                str+="{";
                str+=key;
                if (tags[key].Count>0)
                {
                    str+=":";
                    str+=StringUtils.MakeDeliminatorSeparatedList(tags[key], "|");
                }
                str+="}";
            }
            return str;
        }
#endif

        /// <summary> Walks through a tree of nodes and write out the details about every leaf node that has functional data.  If detailsFile is not null, then also writes csv out to that filename. </summary>
        public static void PrintLeafDetails(System.Collections.Generic.IEnumerable<TestNode> nodes, string detailsFile, bool includeFunctional, bool includeStress)
        {
            //prepare csv
            CSVFileGenerator csvDetailsReport=null;
            if (!String.IsNullOrEmpty(detailsFile))
            {
                csvDetailsReport=new CSVFileGenerator();
#if UsingSTFLive
                csvDetailsReport.DataHeaders = new string[] { "Test Dll", "Test Name", "Test FullName", "Owner", "EnvRequirements", "Frequency", "Priority", "Tags", "FeatureArea", "Description" };
#else
                csvDetailsReport.DataHeaders = new string[] { "Test Dll", "Test Name", "Test FullName", "Tags", "Description" };
#endif
            }

            //walk nodes
            PrintLeafDetailsRecurse(nodes, csvDetailsReport, includeFunctional, includeStress);

            //write result
            if (!String.IsNullOrEmpty(detailsFile))
            {
                try
                {
                    csvDetailsReport.GenerateReport(detailsFile);
                }
                catch (System.IO.IOException ioe)
                {
                    Global.RO.Fatal(String.Format("Could not generate details report. Exception thrown:\n{0}\n{1}", ioe.Message, ioe.StackTrace));
                }
            }
        }

        //used by PrintLeafDetails
        public static void PrintLeafDetailsRecurse(System.Collections.Generic.IEnumerable<TestNode> nodes, CSVFileGenerator csvDetailsReport, bool includeFunctional, bool includeStress)
        {
            foreach (TestNode node in nodes)
            {
                if ((includeFunctional && node.FunctionalData!=null) || (includeStress && node.StressData!=null))
                {
                    if (node.ChildrenCount>0) //group node
                    {
                        PrintLeafDetailsRecurse(node.Children, csvDetailsReport, includeFunctional, includeStress);
                    }
                    else //leaf node
                    {
#if UsingSTFLive
                        string[] details = new string[] { System.IO.Path.GetFileName(node.ContainingDll),
                                                        node.Name.Replace(',', ' '),
                                                        node.FullName.Replace(',', ' '),
                                                        GetOwnerForNode(node).Replace(',', ' ').ToLower(),
                                                        GetRequirement(node).Replace(',', ' ').ToLower(),
                                                        GetTestFrequency(node).Replace(',', ' ').ToLower(),
                                                        GetTestCasePriority(node).ToString().Replace(',', ' ').ToLower(),
                                                        GetGenericTags(node).ToString().Replace(',', ' '),
                                                        GetFeatureArea(node).ToString().Replace(',', ' ').ToLower(),
                                                        node.Desc.Replace(',', ' ') };

                        // Echo to the console
                        Global.RO.Info(String.Format("Test Details = Dll:{0}, Name:{1}, FullName:{2}, Owner:{3}, EnvReq:{4}, Frequency:{5}, Priority:{6}, Tag:{7}, FeatureArea:{8}, Description:{9}",
                                                        details[0],
                                                        details[1],
                                                        details[2],
                                                        details[3],
                                                        details[4],
                                                        details[5],
                                                        details[6],
                                                        details[7],
                                                        details[8],
                                                        details[9]));
#else
                        string[] details = new string[] { System.IO.Path.GetFileName(node.ContainingDll),
                                                        node.Name.Replace(',', ' '),
                                                        node.FullName.Replace(',', ' '),
                                                        node.TaggingData.GetNearestTrunkTags().ToString().Replace(',', ' '),
                                                        node.Desc.Replace(',', ' ') };

                        // Echo to the console
                        Global.RO.Info(String.Format("Test Details = Dll:{0}, Name:{1}, FullName:{2}, Tag:{3}, Description:{4}",
                                                        details[0],
                                                        details[1],
                                                        details[2],
                                                        details[3],
                                                        details[4]));
#endif
                        // Add the report to the csv file
                        if (csvDetailsReport!=null)
                            csvDetailsReport.AddResult(details);
                    }
                }
            }
        }
    }; //class CsvNodeWriter
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildLive\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildLive\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildLive\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_stfconsolelive_none_12.4.56.0_none_7f3e40fcb880ffcc
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=stfconsolelive
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4.manifest
XP_MANIFEST_PATH=manifests\x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4.cat
XP_CATALOG_PATH=manifests\x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4.cat
XP_PAYLOAD_PATH=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=stfconsolelive,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\STFConsole.cs ===
using System;
using System.Xml;
using System.Text.RegularExpressions;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;

#if UsingSTFLive
using ServerTestFramework.Reporting;
#endif

namespace STFConsole
{
#if !UsingSTFLive
    public class Global
    {
        public static Report RO = new Report("Console");
    }
#endif

    public class MainClass : BaseApp
    {
        enum Mode
        {
            Run,
            List
        }
        private Mode _Mode;

        //returns:
        public enum STFCONSOLE_RETURN
        {
            OK                  = 0,      // suites were run and all passed
            OK_TESTSFAILED      = 0x001,  // suites were run, but some tests failed
            BAD_PARAM           = 0x100,  // a bad param or config prevented the run
            OTHER_ERROR         = 0x200,  // some problem during run (such as a bad crash)

            UNKNOWN             = 0x300   //not initialized or something really weird... this should never be returned
        };
        static STFCONSOLE_RETURN ReturnValue = STFCONSOLE_RETURN.UNKNOWN;
        //
        public static int Main(string []args)
        {
            // Route all reports form the root to debug output and consoleX
            ServerTestFramework.Report.GetRoot().AddReportDestination(new DebugOutputReportDestination());
            ServerTestFramework.Report.GetRoot().AddReportDestination(new ConsoleReportDestination());

            // Register the feedback managemr
            FeedbackManager.Instance.SetFactory(new ConsoleFeedbackFactory());

            //run
            MainClass mc = new MainClass();
            mc.Run(args);
            if (ReturnValue==STFCONSOLE_RETURN.UNKNOWN && mc.RunCrashed) ReturnValue = STFCONSOLE_RETURN.OTHER_ERROR;

            return (int)ReturnValue;
        }

        protected void ShowError(string message)
        {
            ShowError("",message);
        }
        protected override void ShowError(string title, string message)
        {
            if(null != Global.RO)
            {
                Global.RO.Error(title + ": " + message);
            }
            else
            {
                ConsoleX.WriteLine(CC.RED, title + ": " + message);
            }
        }

        protected void ShowMessage(string message)
        {
            ShowMessage("",message);
        }
        protected override void ShowMessage(string title, string message)
        {
            if(null != Global.RO)
            {
                Global.RO.Info(title + ": " + message);
            }
            else
            {
                ConsoleX.WriteLine(CC.WHITE, title + ": " + message);
            }
        }

        protected override void ConfigureCommandLine()
        {
            _CommandLineParser.Usage = "Commandline format: [options] <test suites .dll> [test config files .xml]\n\nExample: STFConsole Suites\\KdcBvt.dll\n";
            _CommandLineParser.Notes = "";
            _CommandLineParser.AddSwitch("run", "Expression to match against tests to run (/run:*Alive*)", false);
            _CommandLineParser.AddSwitch("wait", "Wait until the user presses a key before exiting.", false);
            _CommandLineParser.AddSwitch("trycount", "Number of times to try to run a node (to retry failures only). (/trycount:3)", false);
            _CommandLineParser.AddSwitch("xmlfile", "Outputs an xml containing the results of the test run (/xmlfile:TestResults.xml)", false);
            _CommandLineParser.AddSwitch("trxfile", "Outputs an VsTest trx results file containing the results of the test run (/trxfile or /trxfile:TestResults.trx)", false);
            _CommandLineParser.AddSwitch("noasync", "Disables asynchronous test execution (/noasync)", false);
            _CommandLineParser.AddSwitch("detailsonly", "Loads the test suites, but only outputs the details for functional tests and doesn't execute them. Optionally takes a csv filename to echo to (/detailsonly[:csvfile]). Will ignore any filtering params", false);
            _CommandLineParser.AddSwitch("stressdetailsonly", "Loads the test suites, but only outputs the details for stress tests and doesn't execute them. Optionally takes a csv filename to echo to (/stressdetailsonly[:csvfile]). Will ignore any filtering params", false);
            _CommandLineParser.AddSwitch("dryrun", "Loads the test suites and runs them through the functional scheduler normally, except that no Run/PreRun/PostRun is actually called on the tests.  Instead the scheduler simply reports that the Run method passed. (/dryrun)", false);
            _CommandLineParser.AddSwitch("noprerun", "Prevent the scheduler from calling PreRun on any nodes. (/noprerun)", false);
            _CommandLineParser.AddSwitch("nopostrun", "Prevent the scheduler from calling PostRun on any nodes. (/nopostrun)", false);
            _CommandLineParser.AddSwitch("logdir", "Override the default logging directory(FuncOutput) with the given path. (/logdir:Dir)", false);
            _CommandLineParser.AddSwitch("plugparam", "Parameters to pass through to plugins that are loaded. (/plugparam:PluginFoo:Bar)", false);
            _CommandLineParser.AddSwitch("exprun", "Loads an expression from a file and enables only tests that match it (/exprun:expression.txt)", false);
            _CommandLineParser.AddSwitch("expignore", "Loads an expression from a file and ignores tests that match it (/expignore:expression.txt)", false);
#if UsingSTFLive
            _CommandLineParser.AddSwitch("regdb", "RegDB params for results reporting: build(must be XX.XX.XXXX), iteration. (/regdb:build=01.23.4567,iteration=3)", false);
            _CommandLineParser.AddSwitch("env", "Name of configdb environment to use (must be found in Stf.xml).  Defaults to the first in Stf.xml.", false);
            _CommandLineParser.AddSwitch("codecoverage", "Whether to use Magellan code coverage tools while running the tests with optional parameter 'sql' for SqlCC.(/codecoverage:sql to enable SqlCC code coverage as well, or /codecoverage:noimport to not import result to a DB . Otherwise just specify /codecoverage)", false);

            //DEPRECATED commands that will be removed once changes propegate to all branches
            _CommandLineParser.AddSwitch("freq", "Deprecated.  Use -exprun instead.");
            _CommandLineParser.AddSwitch("strictfreq", "Deprecated.  Use -exprun instead.");
            _CommandLineParser.AddSwitch("envreq", "Deprecated.  Use -exprun instead.");
            _CommandLineParser.AddSwitch("allowtag", "Deprecated.  Use -exprun instead.");
            _CommandLineParser.AddSwitch("ignoretag", "Deprecated.  Use -expignore instead.");
#endif
        }

        protected override void BeginApplication(StfXmlDoc config)
        {
            Global.RO.Debug(System.Environment.CommandLine);

            // Intitialize globals
            CoreGlobal.Initialize(config);

#if UsingSTFLive
            // Set the environment first and reload...
            string envName = null;
            CommandLine.Switch envNameSwitch = _CommandLine.Switches["env"] as CommandLine.Switch; //must happen before regdb
            if(null != envNameSwitch)
            {
                if (envNameSwitch.Params==null || envNameSwitch.Params.Length==0)
                {
                    ShowError("Parameter to the env parameter was specified incorrectly.");
                    ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                    return;
                }

                envName = envNameSwitch.Params[0];

                bool found = false;
                foreach (EnvironmentSetting envCheck in Global.EnvironmentList)
                {
                    if (envCheck.Environment.ToLower() == envName.ToLower())
                    {
                        Global.CurrentEnvironment = envCheck;
                        found = true;
                    }
                }
                if (!found)
                {
                    ShowError("Error - invalid environment '"+envName+"' specified (not in stf.xml?).");
                    ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                    return;
                }
            }

            if (envName==null || envName.Length==0)
            {
                foreach (EnvironmentSetting envCheck in Global.EnvironmentList)
                {
                    if (envCheck.Environment.ToLower() == "none")
                    {
                        envName="none";
                        Global.RO.Warn("No environment specified, so using None.");
                        Global.CurrentEnvironment=envCheck;
                        break;
                    }
                }

                if (envName==null || envName.Length==0)
                {
                    Global.RO.Warn("No environment specified and None is not defined, so not setting environment.");
                }
            }

            Global.ResetEnvironment();
#else
            CoreGlobal.Initialize(config);
#endif

            // load settings from file
            XmlDocument xmlSettings = new XmlDocument();
            try
            {
                xmlSettings.Load("STFConsole.xml");
            }
            catch
            {
                // it's ok if it fails, it's probably because it doesn't exist, so we will use defaults.
                xmlSettings.AppendChild(xmlSettings.CreateNode(XmlNodeType.Element, "STFConsole", ""));
            }

            // get command line parameters
            CommandLine.Switch pluginParams = _CommandLine.Switches["plugparam"] as CommandLine.Switch;

            // Create our PluginHandler
            ServerTestFramework.Plugins.PluginHandler pluginHandler = new ServerTestFramework.Plugins.PluginHandler(xmlSettings,
                (pluginParams == null ? new string[0] : pluginParams.Params));

            // loads the plugins per the xml file
            pluginHandler.LoadPluginFiles();

            // Wire the test event listener, manually load DLLs and search for auto loaded
            // suites using the XML configs
            string []fnames=GetFilesFromCommandLine("dll");

            LinkedList<TestNode> rootNodes=new LinkedList<TestNode>();

            foreach (string fname in fnames)
            {
                Global.RO.Info("Loading "+fname+"...");

                // load the assembly here first
                System.Reflection.Assembly asm = System.Reflection.Assembly.LoadFrom(fname);

                pluginHandler.NotifyModuleLoading(fname);

                TestNode newNode = TestNode.GenerateNodeTree(fname);
                rootNodes.AddLast(newNode);
                pluginHandler.NotifySuiteLoaded(newNode);

                pluginHandler.LoadAllPluginsInAssembly(asm);
            }

            if (rootNodes.Count==0)
            {
                ShowError("No suites loaded to run.");
                ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                return;
            }
            else if (rootNodes.Count==1) //if only one, we know where the output belongs for sure (for unknown threads)
            {
                ThreadTracker.DefaultFullName=rootNodes.First.Value.Name;
            }

            FileReportDestination fileOutputDest=null;

            // Enable specific tests or all suites that have been loaded
            string expr = null;
            CommandLine.Switch runSwitch;
            _Mode = Mode.Run;

            runSwitch = _CommandLine.Switches["run"] as CommandLine.Switch;
            if(null != runSwitch)
            {
                expr = runSwitch.Params[0];
            }

            //Check if we should just print out a list rather than actually running
            CommandLine.Switch detailsOnly = _CommandLine.Switches["detailsonly"] as CommandLine.Switch;
            string detailsFile=null;
            if (null != detailsOnly)
            {
                if (runSwitch!=null)
                {
                    Global.RO.Error("Run filter and DetailsOnly mode are mutually exclusive.");
                    ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                    return;
                }

                if (null != detailsOnly.Params)
                {
                    string[] values = detailsOnly.GetSubParams(0);
                    if (0 != values.Length)
                        detailsFile = values[0];
                }

                // We stomp any of the cmdline arguments that may cause filtering
                Global.RO.Warn("Running in DetailsOnly mode. All filtering params will be removed and only test details will be displayed");

                _Mode = Mode.List;
            }

            CommandLine.Switch stressDetailsOnly = _CommandLine.Switches["stressdetailsonly"] as CommandLine.Switch;
            if (null != stressDetailsOnly)
            {
                if (runSwitch!=null)
                {
                    Global.RO.Error("Run filter and StressDetailsOnly mode are mutually exclusive.");
                    ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                    return;
                }

                string stressDetailsFile=null;
                if (null != stressDetailsOnly.Params)
                {
                    string[] values = stressDetailsOnly.GetSubParams(0);
                    if (0 != values.Length)
                        stressDetailsFile = values[0];
                }

                if (detailsFile!=null)
                {
                    if (stressDetailsFile!=null && detailsFile.ToLower()!=stressDetailsFile.ToLower())
                    {
                        Global.RO.Error("If both DetailsOnly and StressDetailsOnly mode are used with a filename, they must specify the same file.");
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }
                }
                else //detailsFile not specified, stressDetailsFile might have been so use that
                {
                    detailsFile=stressDetailsFile;
                }

                // We stomp any of the cmdline arguments that may cause filtering
                Global.RO.Warn("Running in StressDetailsOnly mode. All filtering params will be removed and only test stress details will be displayed");

                _Mode = Mode.List;
            }

            if(null != expr)
            {
                EnableTests(rootNodes, expr);
            }
            else
            {
                // Add an auto-run entry for each suite
                EnableTests(rootNodes, "*");
            }

            //Parse args
            FunctionalSchedulerSettings settings=new FunctionalSchedulerSettings();

            // Do a dry run?
            CommandLine.Switch dryRunSwitch = _CommandLine.Switches["dryrun"] as CommandLine.Switch;
            if (null != dryRunSwitch)
                settings.DryRun = true;

            if(Mode.Run == _Mode)
            {
                MultiTestEventListener eventListeners = new MultiTestEventListener();
#if UsingSTFLive
                CommandLine.Switch regDBSwitch = _CommandLine.Switches["regdb"] as CommandLine.Switch;
                if (settings.DryRun && null!=regDBSwitch)
                {
                    Global.RO.Fatal("You cannot log a DryRun to RegDB.");
                }
                else if(null != regDBSwitch)
                {
                    //
                    int iteration=0;
                    string build=null;

                    //parse value overrides
                    string deferredErrStr="";
                    System.Collections.Generic.KeyValuePair<string,string> []paramPairs=regDBSwitch.GetSubParamPairs(0);
                    if (paramPairs!=null)
                    {
                        foreach (System.Collections.Generic.KeyValuePair<string,string> pair in paramPairs)
                        {
                            if (pair.Key=="build")
                            {
                                build=pair.Value;
                                if (build.Length!=10 || build[2]!='.' || build[5]!='.')
                                {
                                    ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                                    ShowError("build string to regdb is the wrong format");
                                    return;
                                }
                            }
                            else if (pair.Key=="iteration")
                            {
                                try
                                {
                                    iteration=int.Parse(pair.Value);
                                }
                                catch
                                {
                                    ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                                    ShowError("Error parsing regdb 'iteration' subparam.");
                                    return;
                                }
                            }
                            else //?
                            {
                                ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                                deferredErrStr+="Unknown subparam to regdb param: "+pair.Key;
                            }
                        }
                    }

                    //fill in defaults
                    if (build==null)
                    {
                        ShowError("build param to regdb is required.");
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }

                    eventListeners.Add(new RegDBTestEventListener(build, iteration));

                    if (deferredErrStr.Length>0)
                    {
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        ShowError(deferredErrStr);
                        return;
                    }
                }

                CommandLine.Switch codeCoverageSwitch = _CommandLine.Switches["codecoverage"] as CommandLine.Switch;
                if (null != codeCoverageSwitch)
                {
                    // Turn off async execution since 
                    // that won't go well with code coverage
                    settings.AllowAsync = false;

                    bool useSqlCC = false;
                    bool importResults = true;
                    if ((codeCoverageSwitch.Params != null) && 
                        (codeCoverageSwitch.Params.Length > 0))
                    {
                        for(int i=0; i<codeCoverageSwitch.Params.Length; i++)
                        {
                            if (codeCoverageSwitch.Params[i].ToLower() == "sql")
                            {
                                useSqlCC = true;
                            }

                            if (codeCoverageSwitch.Params[i].ToLower() == "noimport")
                            {
                                importResults = false;
                            }
                        }
                    }

                    CodeCoverageTestListener ccListener = 
                        new CodeCoverageTestListener(useSqlCC, importResults);

                    eventListeners.Add(ccListener);
                }

#endif

                //retryfailures switch
                CommandLine.Switch tryCountSwitch = _CommandLine.Switches["trycount"] as CommandLine.Switch;
                if (null!=tryCountSwitch)
                {
                    if (tryCountSwitch.Params==null || tryCountSwitch.Params.Length==0)
                    {
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        ShowError("trycount param has no value specified.");
                        return;
                    }
                    else
                    {
                        settings.TimesToTryRun=int.Parse(tryCountSwitch.Params[0]);
                    }
                }

                //prevent prerun
                CommandLine.Switch noPreRunSwitch=_CommandLine.Switches["noprerun"] as CommandLine.Switch;
                if (null!=noPreRunSwitch)
                {
                    settings.SkipPreRun=true;
                }

                //prevent postrun
                CommandLine.Switch noPostRunSwitch=_CommandLine.Switches["nopostrun"] as CommandLine.Switch;
                if (null!=noPostRunSwitch)
                {
                    settings.SkipPostRun=true;
                }

                // Should we create a xml results file?
                CommandLine.Switch xmlSwitch = _CommandLine.Switches["xmlfile"] as CommandLine.Switch;
                XmlTestEventListener xmlListener = null;
                string xmlFilename = String.Empty;
                if (null != xmlSwitch)
                {
                    xmlFilename = xmlSwitch.GetSubParams(0)[0];
                    xmlListener = new XmlTestEventListener(xmlFilename, fnames);
                    eventListeners.Add(xmlListener);
                }

                // Should we create a trx results file?
                CommandLine.Switch trxSwitch = _CommandLine.Switches["trxfile"] as CommandLine.Switch;
                VsTestResultTestEventListener trxListener = null;
                string trxFilename = String.Empty;
                if (null != trxSwitch)
                {
                    trxFilename = null;
                    if (trxSwitch.GetSubParams(0)!=null && trxSwitch.GetSubParams(0).Length>0)
                    {
                        trxFilename = trxSwitch.GetSubParams(0)[0];
                    }
                    trxListener = new VsTestResultTestEventListener(trxFilename);
                    trxListener.RunDescription=System.Environment.CommandLine;

                    eventListeners.Add(trxListener);
                }

                string logDirectory = "FuncOutput";
                CommandLine.Switch logDirSwitch = _CommandLine.Switches["logdir"] as CommandLine.Switch;
                if ((null != logDirSwitch) && (logDirSwitch.GetSubParams(0) != null))
                {
                    if (logDirSwitch.GetSubParams(0).Length > 1)
                    {
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        ShowError(string.Format("Multiple LogDirs are not supported."));
                        return;
                    }

                    string logDir = logDirSwitch.GetSubParams(0)[0];
                    if(!String.IsNullOrEmpty(logDir))
                    {
                        logDirectory = logDir;
                    }
                }

                // turn on filelogging always
                string baseLogFileName = "Log";
                if(xmlFilename.Length > 0 )
                {
                  baseLogFileName = System.IO.Path.GetFileNameWithoutExtension(xmlFilename);
                }
                fileOutputDest = new FileReportDestination(logDirectory, baseLogFileName, System.DateTime.Now);
                Report.GetRoot().AddReportDestination(fileOutputDest);

                // Just fire off a basic test run right here
                ConsoleTestEventListener consoleListener = new ConsoleTestEventListener();
                eventListeners.Add(consoleListener);

                // Disable async running?
                CommandLine.Switch noAsyncSwitch = _CommandLine.Switches["noasync"] as CommandLine.Switch;
                if (null != noAsyncSwitch)
                    settings.AllowAsync = false;

                CommandLine.Switch exprunSwitch=_CommandLine.Switches["exprun"] as CommandLine.Switch;
                if (null!=exprunSwitch)
                {
                    if (exprunSwitch.Params==null || exprunSwitch.Params.Length!=1)
                    {
                        Global.RO.Error("-exprun requires one parameter");
                        ReturnValue=STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }

                    NodeTaggingData.Expression exp=LoadExpressionFromFile(exprunSwitch.Params[0]);
                    if (exp==null)
                    {
                        ReturnValue=STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }

                    if (runSwitch==null) //start with nothing enabled unless they explicitely enabled a set with -run
                    {
                        foreach (TestNode node in rootNodes)
                        {
                            if (node.FunctionalData!=null)
                            {
                                node.FunctionalData.Enabled=false;
                            }
                        }
                    }

                    foreach (TestNode node in rootNodes)
                    {
                        EnableNodesWithExpression(node, exp);
                    }
                }

                CommandLine.Switch expignoreSwitch=_CommandLine.Switches["expignore"] as CommandLine.Switch;
                if (null!=expignoreSwitch)
                {
                    if (expignoreSwitch.Params==null || expignoreSwitch.Params.Length!=1)
                    {
                        Global.RO.Error("-expignore run requires one parameter");
                        ReturnValue=STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }

                    NodeTaggingData.Expression exp=LoadExpressionFromFile(expignoreSwitch.Params[0]);
                    if (exp==null)
                    {
                        ReturnValue=STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }

                    foreach (TestNode node in rootNodes)
                    {
                        IgnoreNodesWithExpression(node, exp);
                    }
                }

#if UsingSTFLive //TEMPORARY back-compat - handle the old parameters but convert them to expressions

                string tempAllowBackCompatExpression="";

                // Get the test frequency
                CommandLine.Switch freqSwitch = _CommandLine.Switches["freq"] as CommandLine.Switch;
                if ((null != freqSwitch) && (freqSwitch.GetSubParams(0) != null))
                {
                    Global.RO.Warn("-freq is deprecated.  Please use -exprun instead.");

                    if (freqSwitch.GetSubParams(0).Length > 1)
                    {
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        ShowError(string.Format("Multiple Test Frequencies are not supported."));
                        return;
                    }

                    string freq = freqSwitch.GetSubParams(0)[0];
                    if (freq != null)
                    {
                        freq = freq.ToLower();
                        if (
                          (freq.Equals("bvt")) || (freq.Equals("daily")) || (freq.Equals("regression")) || (freq.Equals("weekly")) || (freq.Equals("full")))
                        {
                            tempAllowBackCompatExpression="Frequency(Val("+freq+"))";
                        }
                        else
                        {
                            ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                            ShowError(string.Format("Invalid Test Frequency: {0}.  Valid values are bvt, daily, weekly, full and regression.", freq));
                            return;
                        }
                    }
                    else
                    {
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        ShowError("Invalid Test Frequency, value is null");
                        return;
                    }
                }

                CommandLine.Switch envReqSwitch = _CommandLine.Switches["envreq"] as CommandLine.Switch;
                if (null != envReqSwitch)
                {
                    Global.RO.Warn("-envreq is deprecated.  Please use -exprun instead.");

                    string[] values = envReqSwitch.GetSubParams(0);
                    if (tempAllowBackCompatExpression.Length>0)
                    {
                        tempAllowBackCompatExpression+=" && ";
                    }

                    string commaVals=string.Join(",", values);
                    tempAllowBackCompatExpression+="EnvRequirement(Val("+commaVals+"))";
                }

                CommandLine.Switch allowTagSwitch=_CommandLine.Switches["allowtag"] as CommandLine.Switch;
                if(null!=allowTagSwitch)
                {
                    Global.RO.Warn("-allowtag is deprecated.  Please use -exprun instead.");

                    for (int i=0; i<allowTagSwitch.Params.Length; ++i)
                    {
                        if (tempAllowBackCompatExpression.Length>0)
                        {
                            tempAllowBackCompatExpression+=" && ";
                        }

                        tempAllowBackCompatExpression+="TrunkHasTag(Tag("+allowTagSwitch.Params[i]+"))";
                    }
                }

                //note that use of the deprecated back-compat parameters supercedes everything else specified
                if (tempAllowBackCompatExpression.Length>0)
                {
                    Global.RO.Debug("Converted deprecated parameters to allow-expression: "+tempAllowBackCompatExpression);

                    NodeTaggingData.Expression exp=null;
                    try
                    {
                        exp=new NodeTaggingData.Expression(tempAllowBackCompatExpression);
                    }
                    catch (NodeTaggingData.InvalidExpressionException iee)
                    {
                        Global.RO.Error("Invalid Expression Exception:\n"+iee);
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }
                    catch (System.Exception e)
                    {
                        Global.RO.Fatal("Unexpected exception processing expression:\n"+e);
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }

                    //disable everything and enable the exact set
                    foreach (TestNode node in rootNodes)
                    {
                        if (node.FunctionalData!=null)
                        {
                            node.FunctionalData.Enabled=false;
                        }
                    }

                    foreach (TestNode node in rootNodes)
                    {
                        EnableNodesWithExpression(node, exp);
                    }
                }

                CommandLine.Switch ignoreTagSwitch=_CommandLine.Switches["ignoretag"] as CommandLine.Switch;
                if (null!=ignoreTagSwitch)
                {
                    Global.RO.Warn("-ignoretag is deprecated.  Please use -expignore instead.");

                    string tempIgnoreBackCompatExpression="";
                    for (int i=0; i<ignoreTagSwitch.Params.Length; ++i)
                    {
                        if (tempIgnoreBackCompatExpression.Length>0)
                        {
                            tempIgnoreBackCompatExpression+=" || ";
                        }

                        tempIgnoreBackCompatExpression+="TrunkHasTag(Tag("+ignoreTagSwitch.Params[i]+"))";
                    }

                    Global.RO.Debug("Converted deprecated parameters to ignore-expression: "+tempIgnoreBackCompatExpression);

                    NodeTaggingData.Expression exp=null;
                    try
                    {
                        exp=new NodeTaggingData.Expression(tempIgnoreBackCompatExpression);
                    }
                    catch (NodeTaggingData.InvalidExpressionException iee)
                    {
                        Global.RO.Error("Invalid Expression Exception:\n"+iee);
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }
                    catch (System.Exception e)
                    {
                        Global.RO.Fatal("Unexpected exception processing expression:\n"+e);
                        ReturnValue = STFCONSOLE_RETURN.BAD_PARAM;
                        return;
                    }

                    foreach (TestNode node in rootNodes)
                    {
                        IgnoreNodesWithExpression(node, exp);
                    }
                }

#endif //TEMPORARY back-compat - handle the old parameters but convert them to expressions

                //create the scheduler and run
                ServerTestFramework.Runner.FuncScheduler funcSched=new ServerTestFramework.Runner.FuncScheduler();

                ServerTestFramework.Runner.TestScheduler sched = funcSched;
                sched.Initialize(settings, eventListeners, rootNodes);

                sched.Run();

                if (consoleListener.WereAnyFailures())
                    ReturnValue = STFCONSOLE_RETURN.OK_TESTSFAILED;
                else
                    ReturnValue = STFCONSOLE_RETURN.OK;
            }
            else if (_Mode==Mode.List)
            {
                CsvNodeWriter.PrintLeafDetails(rootNodes, detailsFile, detailsOnly!=null, stressDetailsOnly!=null);
            }
            else
            {
                Global.RO.Fatal("Unknown STFConsole mode.");
            }

            //destroy all our nodes
            foreach (TestNode rn in rootNodes)
            {
                try
                {
                    pluginHandler.NotifySuiteUnloading(rn);
                    rn.Dispose();
                }
                catch (Exception e)
                {
                    Global.RO.Fatal("Exception trying to dispose TestNode "+rn.FullName+": "+e.Message+"\n"+e.StackTrace);
                }
            }

            pluginHandler.UnloadAllPlugins();

            Report.GetRoot().BlockUntilQueuedLinesAreProcessed();

            //cleanup file output
            if (fileOutputDest!=null)
            {
                Report.GetRoot().RemoveReportDestination(fileOutputDest);
                fileOutputDest.Close();
                fileOutputDest=null;
            }

            // Wait for user input if requested
            if (_CommandLine.HasSwitch("wait"))
            {
                ConsoleX.PressAnyKey();
            }
        }
        
        private string CleanupExpression(string expr)
        {
            if("*" == expr)
            {
                expr = ".*";
            }

            return expr;
        }

        private void EnableTests(IEnumerable<TestNode> rootTests, string expr)
        {
            if(0 == expr.Length)
            {
                throw new ArgumentException("EnableTests(): Expression cannot be zero length");
            }

            foreach(TestNode tnode in rootTests)
            {
                if (tnode.FunctionalData==null)
                {
                    continue;
                }

                if(Match(expr, tnode.Name) || Match(expr, tnode.FullName))
                {
                    tnode.FunctionalData.Enabled=true;
                }

                if (tnode.ChildrenCount>0)
                {
                    EnableTests(tnode.Children, expr);
                }
            }
        }

        private bool Match(string expr, string data)
        {
            if(expr.Length == 0 || data.Length == 0)
            {
                throw new ArgumentException("Data and expression must both be non-zero length");
            }

            char []exprChars = expr.ToLower().ToCharArray();
            char []dataChars = data.ToLower().ToCharArray();
            int iExpr = 0;
            int iExprEndGlom = -1;
            int cExpr = exprChars.Length;
            int iData = 0;
            int cData = dataChars.Length;


            while(iExpr < cExpr && iData < cData)
            {
                if('*' == exprChars[iExpr])
                {
                    // Find the end of the glom (handle multiple glom chars)
                    if(-1 == iExprEndGlom)
                    {
                        iExprEndGlom = iExpr + 1;
                        while(iExprEndGlom < cExpr && '*' == exprChars[iExprEndGlom])
                        {
                            ++iExprEndGlom;
                        }
                    }

                    // When we find a character after a glom we will try to advance
                    // and start matching explicitly but if this fails we fall back on the
                    // greedy glomming
                    if(iExprEndGlom < cExpr && exprChars[iExprEndGlom] == dataChars[iData])
                    {
                        // Search fowards for the subexpression
                        int iSubExpr = iExprEndGlom;
                        int iSubData = iData;
                        while(iSubExpr < cExpr && iSubData < cData && exprChars[iSubExpr] == dataChars[iSubData])
                        {
                            // End sub expression on another glom
                            if('*' == exprChars[iSubExpr])
                            {
                                break;
                            }

                            ++iSubExpr;
                            ++iSubData;

                        }

                        // If the whole expression was consumed on the data (stem match) or we
                        // consumed the whole subexpression and now have a new glom we will 
                        // mark the expression as being consumed and reset the end marker. Otherwise
                        // we will move to the next character in the data and try to match the subexpression
                        if((iSubExpr == cExpr && iSubData == cData) || (iSubExpr < cExpr && '*' == exprChars[iSubExpr]))
                        {
                            iExpr = iSubExpr;
                            iData = iSubData;
                            iExprEndGlom = -1;
                        }
                        else
                        {
                            // No partial match after testing subexpression, consume data
                            ++iData;
                        }
                    }
                    else
                    {
                        // No chance of partial match consume data
                        ++iData;
                    }
                }
                else if(exprChars[iExpr] == dataChars[iData])
                {
                    // Exact match
                    ++iExpr;
                    ++iData;
                }
                else
                {
                    // No match
                    break;
                }
            }

            // Consumed whole expression or terminated on last glom character (glom matches entire stem)
            return (iExpr == cExpr || ('*' == exprChars[iExpr] && iExpr == cExpr - 1));
        }

        public static NodeTaggingData.Expression LoadExpressionFromFile(string file)
        {
            string expressionText;
            try
            {
                expressionText=System.IO.File.ReadAllText(file);
                Global.RO.Debug("Read Tag Expression from "+file+": "+expressionText);
            }
            catch (System.Exception e)
            {
                Global.RO.Error(e.ToString());
                return null;
            }

            try
            {
                return new NodeTaggingData.Expression(expressionText);
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                Global.RO.Error("Invalid Expression Exception:\n"+iee);
            }
            catch (System.Exception e)
            {
                Global.RO.Fatal("Unexpected exception processing expression:\n"+e);
            }

            return null;
        }

        public static void EnableNodesWithExpression(TestNode node, NodeTaggingData.Expression exp)
        {
            //do me
            try
            {
                if (node.FunctionalData!=null)
                {
                    bool result=exp.EvaluateBool(node);

                    if (result)
                    {
                        node.FunctionalData.Enabled=true;
                    }
                }
            }
            catch (NodeTaggingData.ExpressionEvaluationException iee)
            {
                Global.RO.Error(iee.ToString());
            }
            catch (System.Exception e)
            {
                Global.RO.Error("Unexpected exception evaluating expression:\n"+e.ToString());
            }

            //do my children
            foreach (TestNode child in node.Children)
            {
                EnableNodesWithExpression(child, exp);
            }
        }

        public static void IgnoreNodesWithExpression(TestNode node, NodeTaggingData.Expression exp)
        {
            //do me
            try
            {
                if (node.FunctionalData!=null)
                {
                    bool result=exp.EvaluateBool(node);

                    if (result)
                    {
                        node.FunctionalData.Ignored=true;
                    }
                }
            }
            catch (NodeTaggingData.ExpressionEvaluationException iee)
            {
                Global.RO.Error(iee.ToString());
            }
            catch (System.Exception e)
            {
                Global.RO.Error("Unexpected exception evaluating expression:\n"+e.ToString());
            }

            //do my children
            foreach (TestNode child in node.Children)
            {
                IgnoreNodesWithExpression(child, exp);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFConsole\BuildLive\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_stfconsolelive_none_12.4.56.0_none_7f3e40fcb880ffcc
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=stfconsolelive
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4.manifest
XP_MANIFEST_PATH=manifests\x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4.cat
XP_CATALOG_PATH=manifests\x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4.cat
XP_PAYLOAD_PATH=x86_stfconsolelive_no-public-key_12.4.56.0_x-ww_f4a659d4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=stfconsolelive,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StfDoc\makefile.inc ===
!include $(INETROOT)\build\makefile.inc

doc\Documentation.chm:$(URTTARGET)
 $(EXTPATH)\NDoc\$(PROCESSOR_ARCHITECTURE)\$(MANAGED_COMPILER_VERSION)\nDocConsole.exe $(INETROOT)\private\test\StfTests\lib$(BUILD_ALT_DIR)\i386\serverTestFramework.dll,..\ServerTestFramework\$(O)\stfHelp.xml  -ReferencesPath=$(EXTPATH)\xonline-ext\stftest\
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\StfDoc\dumbFile.cs ===
using System;

namespace STFDoc
{
	public class STFDoc
	{
		static void Main(string []args)
		{
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\App\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\App\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\App\Main.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;

using ServerTestFramework;

namespace STFGui
{
    public class MainApp
    {
        [Flags]
        public enum STFGuiExitCode
        {
            OK               = 0, //we loaded ok
            LoadError        = 1, //errors loading a module specified on the commandline
            GuiParamError    = 2, //problem with a commandline parameter targetted at STFGui itself
            PluginParamError = 4  //problem with a commandline paramater targetted at a plugin (not currently set)
        }

        //entry point
        [STAThreadAttribute]
        static void Main(string[] args)
        {
            // Pretty it up :)  (down! This may break some ui formatting on vista, be careful)
            Application.EnableVisualStyles();

            //Look through parameters and sort them into their relevent buckets
            List<string> paramsForMainGui = new List<string>();
            List<string> paramsForPlugins = new List<string>();
            List<string> paramsToLoad = new List<string>();

            foreach (string param in args)
            {
                string paramLower = param.ToLower();

                if (paramLower.StartsWith("-plugparam:")) //parameter for a plugin
                {
                    paramsForPlugins.Add(param.Substring(11));
                }
                else if (!param.StartsWith("-") && param.EndsWith(".dll")) //module to load
                {
                    paramsToLoad.Add(param);
                }
                else if (!param.StartsWith("-") && param.EndsWith(".xml")) //TODO: Temporary special case here to ignore xml files... since since our old live-specific code still directly relies on parsing xml files from the commandline itself.  That needs updated someday.
                {
                    //ignoring it
                }
                else if (paramLower == "-breakonstart")
                {
                    System.Diagnostics.Debugger.Launch();
                    //System.Diagnostics.Debugger.Break();
                }
                else //parameter for stfgui itself
                {
                    paramsForMainGui.Add(param);
                }
            }

            //Create the main gui and set it up
            System.Environment.ExitCode = (int)STFGuiExitCode.OK; //default to good state
            STFGuiForm gui = new STFGuiForm();

            System.Environment.ExitCode |= (int)gui.Init(paramsForMainGui.ToArray(), paramsForPlugins.ToArray());

            //Load suites and plugins passed on the commandline
            foreach (string fname in paramsToLoad)
            {
                if (!gui.LoadModule(fname))
                {
                    System.Environment.ExitCode |= (int)STFGuiExitCode.LoadError;
                }
            }

            //Block here until the form is closed
            gui.ShowDialog();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\App\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\App\Main.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;

using ServerTestFramework;

namespace STFGui
{
    public class MainApp
    {
        [Flags]
        public enum STFGuiExitCode
        {
            OK               = 0, //we loaded ok
            LoadError        = 1, //errors loading a module specified on the commandline
            GuiParamError    = 2, //problem with a commandline parameter targetted at STFGui itself
            PluginParamError = 4  //problem with a commandline paramater targetted at a plugin (not currently set)
        }

        //entry point
        [STAThreadAttribute]
        static void Main(string[] args)
        {
            // Pretty it up :)  (down! This may break some ui formatting on vista, be careful)
            Application.EnableVisualStyles();

            //Look through parameters and sort them into their relevent buckets
            List<string> paramsForMainGui = new List<string>();
            List<string> paramsForPlugins = new List<string>();
            List<string> paramsToLoad = new List<string>();

            foreach (string param in args)
            {
                string paramLower = param.ToLower();

                if (paramLower.StartsWith("-plugparam:")) //parameter for a plugin
                {
                    paramsForPlugins.Add(param.Substring(11));
                }
                else if (!param.StartsWith("-") && param.EndsWith(".dll")) //module to load
                {
                    paramsToLoad.Add(param);
                }
                else if (!param.StartsWith("-") && param.EndsWith(".xml")) //TODO: Temporary special case here to ignore xml files... since since our old live-specific code still directly relies on parsing xml files from the commandline itself.  That needs updated someday.
                {
                    //ignoring it
                }
                else if (paramLower == "-breakonstart")
                {
                    System.Diagnostics.Debugger.Launch();
                    //System.Diagnostics.Debugger.Break();
                }
                else //parameter for stfgui itself
                {
                    paramsForMainGui.Add(param);
                }
            }

            //Create the main gui and set it up
            System.Environment.ExitCode = (int)STFGuiExitCode.OK; //default to good state
            STFGuiForm gui = new STFGuiForm();

            System.Environment.ExitCode |= (int)gui.Init(paramsForMainGui.ToArray(), paramsForPlugins.ToArray());

            //Load suites and plugins passed on the commandline
            foreach (string fname in paramsToLoad)
            {
                if (!gui.LoadModule(fname))
                {
                    System.Environment.ExitCode |= (int)STFGuiExitCode.LoadError;
                }
            }

            //Block here until the form is closed
            gui.ShowDialog();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\App\PluginHandler.cs ===
//#define DEBUG_PLUGIN_LOADING

using System;
using System.Reflection;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Utilities;

using STFGui.Plugins;

namespace STFGui
{
    public class GuiPluginHandler : PluginHandler
    {
        STFGuiForm gui;

        /// <summary>
        /// A wrapper around a pluggable item that allows you to find out 
        /// information about what type of item it is
        /// </summary>
        class GuiPluggableItem : PluginHandler.PluggableItem
        {
            /// <summary>
            /// Represents the instance of the actual item.  An instance of a 
            /// class that derives from something we're interested in like 
            /// Plugin, IPluginPreferences, etc. (defined in Plugins.cs)
            /// </summary>
            public override Object Item
            {
                get { return base.Item; }
                set
                {
                    base.Item = value;
                    AsIPluginGui = item as IPluginGui;
                    AsIPluginPreferences = item as IPluginPreferences;
                }
            }

            public bool IsIPluginGui { get { return AsIPluginGui != null; } }
            public bool IsIPluginPreferences { get { return AsIPluginPreferences != null; } }

            /// <summary>
            /// The item represented by this pluggable object as an IPluginGui
            /// </summary>
            public IPluginGui AsIPluginGui = null;
            /// <summary>
            /// The item respreseted by this pluggable object as an IPluginPreferences
            /// </summary>
            public IPluginPreferences AsIPluginPreferences = null;
        }

        //ctor
        public GuiPluginHandler (STFGuiForm mainGui, string[] parametersForPlugins) : base(mainGui.Settings, parametersForPlugins)
        {
            gui = mainGui;
        }

        /// <summary>
        /// Called when the main GUI is initially shown to the user.
        /// </summary>
        public void NotifyGuiShown()
        {
            foreach (GuiPluggableItem item in loadedItems)
            {
                if (item.IsIPluginGui)
                {
                    try
                    {
                        item.AsIPluginGui.OnGuiShown();
                    }
                    catch (Exception e)
                    {
                        ro.Fatal("Failed when calling "+item.FriendlyName+".OnGuiShown() "+e);
                    }
                }
            }
        }

        /// <summary>
        /// Called whenever the gui is wanting to close.
        /// </summary>
        public void NotifyGuiClosing()
        {
            UnloadAllPlugins();
        }

        //creates and sets up a new GuiHooker
        private GuiHooker CreateGuiHooker()
        {
            GuiHooker h=new GuiHooker(gui);
            return h;
        }

        protected override PluggableItem NewPluggableItem ()
        {
            return new GuiPluggableItem();
        }

        protected override IEnumerable<string> GetDefaultPluginsList ()
        {
            string[] files = System.IO.Directory.GetFiles(".", "STFGuiPlugin*.dll");
            foreach (string tryFileWithJunk in files)
            {
                string tryFile = tryFileWithJunk.Substring(2); //strip off ".\\"

                //if we can load the assembly, it's a candidate to search for plugins later
                try
                {
                    Assembly asm = Assembly.ReflectionOnlyLoadFrom(tryFile);
                }
                catch
                {
                    continue;
                }

                yield return tryFile;
            }
        }

        protected override void PreProcessPluggable (PluggableItem item)
        {
            GuiPluggableItem guiItem = (GuiPluggableItem)item;

            //expose data and hooks to the plugin
            if (guiItem.IsIPluginGui)
            {
                guiItem.AsIPluginGui.GuiHooks = CreateGuiHooker();
            }
        }

        protected override void PostSetupProcessPluggable (PluggableItem item)
        {
            GuiPluggableItem guiItem = (GuiPluggableItem)item;

            //setup any gui components it needs
            if (guiItem.IsIPluginGui)
            {
                //add tab page
                try
                {
                    TabPage newTab = guiItem.AsIPluginGui.GetNewTabPage();
                    if (newTab != null)
                    {
                        gui.Tabs.TabPages.Add(newTab);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception adding a tab for pluggable " + item.FriendlyName + ": " + e);
                }

                //add menu
                try
                {
                    MenuItem newMenu = guiItem.AsIPluginGui.GetNewMenu();
                    if (newMenu != null)
                    {
                        gui.Menu.MenuItems.Add(newMenu);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception adding a menu for pluggable " + item.FriendlyName + ": " + e);
                }
            }

            if (guiItem.IsIPluginPreferences)
            {
                Preferences.Current.PreferencePlugins.Add(guiItem.AsIPluginPreferences);
            }
        }
    }

    /// <summary>
    /// This implements the gui's hooks that a plugin can poke at.
    /// </summary>
    public class GuiHooker: MainGuiHooks
    {
        STFGuiForm gui;

        static Report ro=new Report("PluginHandlerHooker");

        public GuiHooker(STFGuiForm mainGui)
        {
            gui=mainGui;
            MainForm=gui;

            //hook into clear output
            bool hooked=false;
            foreach (MenuItem mmi in gui.Menu.MenuItems)
            {
                if (mmi.Text=="Output")
                {
                    foreach (MenuItem imi in mmi.MenuItems)
                    {
                        if (imi.Text=="Clear")
                        {
                            hooked=true;
                            imi.Click+=HandleClearOutput;
                        }
                    }
                }
            }

            if (!hooked)
            {
                ro.Warn("Failed to hook Output.Clear from main menu");
            }
        }

        public override void AddClearOutputHandler(ClearOutputDelegate handler)
        {
            clearOutputEvent+=handler;
        }

        public event ClearOutputDelegate clearOutputEvent;
        private void HandleClearOutput(object s, EventArgs ea)
        {
            if (clearOutputEvent!=null)
            {
                clearOutputEvent();
            }
        }

        public override void LimitOutput(int limit)
        {
            gui.OutputLimit = limit;
        }

        public bool LogToFile
        {
            get
            {
                return gui.LogToFile;
            }

            set
            {
                gui.LogToFile = value;
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\App\PluginHandler.cs ===
//#define DEBUG_PLUGIN_LOADING

using System;
using System.Reflection;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Utilities;

using STFGui.Plugins;

namespace STFGui
{
    public class GuiPluginHandler : PluginHandler
    {
        STFGuiForm gui;

        /// <summary>
        /// A wrapper around a pluggable item that allows you to find out 
        /// information about what type of item it is
        /// </summary>
        class GuiPluggableItem : PluginHandler.PluggableItem
        {
            /// <summary>
            /// Represents the instance of the actual item.  An instance of a 
            /// class that derives from something we're interested in like 
            /// Plugin, IPluginPreferences, etc. (defined in Plugins.cs)
            /// </summary>
            public override Object Item
            {
                get { return base.Item; }
                set
                {
                    base.Item = value;
                    AsIPluginGui = item as IPluginGui;
                    AsIPluginPreferences = item as IPluginPreferences;
                }
            }

            public bool IsIPluginGui { get { return AsIPluginGui != null; } }
            public bool IsIPluginPreferences { get { return AsIPluginPreferences != null; } }

            /// <summary>
            /// The item represented by this pluggable object as an IPluginGui
            /// </summary>
            public IPluginGui AsIPluginGui = null;
            /// <summary>
            /// The item respreseted by this pluggable object as an IPluginPreferences
            /// </summary>
            public IPluginPreferences AsIPluginPreferences = null;
        }

        //ctor
        public GuiPluginHandler (STFGuiForm mainGui, string[] parametersForPlugins) : base(mainGui.Settings, parametersForPlugins)
        {
            gui = mainGui;
        }

        /// <summary>
        /// Called when the main GUI is initially shown to the user.
        /// </summary>
        public void NotifyGuiShown()
        {
            foreach (GuiPluggableItem item in loadedItems)
            {
                if (item.IsIPluginGui)
                {
                    try
                    {
                        item.AsIPluginGui.OnGuiShown();
                    }
                    catch (Exception e)
                    {
                        ro.Fatal("Failed when calling "+item.FriendlyName+".OnGuiShown() "+e);
                    }
                }
            }
        }

        /// <summary>
        /// Called whenever the gui is wanting to close.
        /// </summary>
        public void NotifyGuiClosing()
        {
            UnloadAllPlugins();
        }

        //creates and sets up a new GuiHooker
        private GuiHooker CreateGuiHooker()
        {
            GuiHooker h=new GuiHooker(gui);
            return h;
        }

        protected override PluggableItem NewPluggableItem ()
        {
            return new GuiPluggableItem();
        }

        protected override IEnumerable<string> GetDefaultPluginsList ()
        {
            string[] files = System.IO.Directory.GetFiles(".", "STFGuiPlugin*.dll");
            foreach (string tryFileWithJunk in files)
            {
                string tryFile = tryFileWithJunk.Substring(2); //strip off ".\\"

                //if we can load the assembly, it's a candidate to search for plugins later
                try
                {
                    Assembly asm = Assembly.ReflectionOnlyLoadFrom(tryFile);
                }
                catch
                {
                    continue;
                }

                yield return tryFile;
            }
        }

        protected override void PreProcessPluggable (PluggableItem item)
        {
            GuiPluggableItem guiItem = (GuiPluggableItem)item;

            //expose data and hooks to the plugin
            if (guiItem.IsIPluginGui)
            {
                guiItem.AsIPluginGui.GuiHooks = CreateGuiHooker();
            }
        }

        protected override void PostSetupProcessPluggable (PluggableItem item)
        {
            GuiPluggableItem guiItem = (GuiPluggableItem)item;

            //setup any gui components it needs
            if (guiItem.IsIPluginGui)
            {
                //add tab page
                try
                {
                    TabPage newTab = guiItem.AsIPluginGui.GetNewTabPage();
                    if (newTab != null)
                    {
                        gui.Tabs.TabPages.Add(newTab);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception adding a tab for pluggable " + item.FriendlyName + ": " + e);
                }

                //add menu
                try
                {
                    MenuItem newMenu = guiItem.AsIPluginGui.GetNewMenu();
                    if (newMenu != null)
                    {
                        gui.Menu.MenuItems.Add(newMenu);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception adding a menu for pluggable " + item.FriendlyName + ": " + e);
                }
            }

            if (guiItem.IsIPluginPreferences)
            {
                Preferences.Current.PreferencePlugins.Add(guiItem.AsIPluginPreferences);
            }
        }
    }

    /// <summary>
    /// This implements the gui's hooks that a plugin can poke at.
    /// </summary>
    public class GuiHooker: MainGuiHooks
    {
        STFGuiForm gui;

        static Report ro=new Report("PluginHandlerHooker");

        public GuiHooker(STFGuiForm mainGui)
        {
            gui=mainGui;
            MainForm=gui;

            //hook into clear output
            bool hooked=false;
            foreach (MenuItem mmi in gui.Menu.MenuItems)
            {
                if (mmi.Text=="Output")
                {
                    foreach (MenuItem imi in mmi.MenuItems)
                    {
                        if (imi.Text=="Clear")
                        {
                            hooked=true;
                            imi.Click+=HandleClearOutput;
                        }
                    }
                }
            }

            if (!hooked)
            {
                ro.Warn("Failed to hook Output.Clear from main menu");
            }
        }

        public override void AddClearOutputHandler(ClearOutputDelegate handler)
        {
            clearOutputEvent+=handler;
        }

        public event ClearOutputDelegate clearOutputEvent;
        private void HandleClearOutput(object s, EventArgs ea)
        {
            if (clearOutputEvent!=null)
            {
                clearOutputEvent();
            }
        }

        public override void LimitOutput(int limit)
        {
            gui.OutputLimit = limit;
        }

        public bool LogToFile
        {
            get
            {
                return gui.LogToFile;
            }

            set
            {
                gui.LogToFile = value;
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\App\Preferences.Designer.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace STFGui
{
    public partial class Preferences : Form
    {
        private Button applyButton;
        private Button cancelButton;
        private TabControl preferencesTabControl;
        private Panel buttonsPanel;

        public void InitializeComponent()
        {
            this.buttonsPanel = new System.Windows.Forms.Panel();
            this.applyButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.preferencesTabControl = new System.Windows.Forms.TabControl();
            this.buttonsPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // buttonsPanel
            // 
            this.buttonsPanel.Controls.Add(this.applyButton);
            this.buttonsPanel.Controls.Add(this.cancelButton);
            this.buttonsPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.buttonsPanel.Location = new System.Drawing.Point(5, 368);
            this.buttonsPanel.Name = "buttonsPanel";
            this.buttonsPanel.Size = new System.Drawing.Size(581, 29);
            this.buttonsPanel.TabIndex = 0;
            // 
            // applyButton
            // 
            this.applyButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.applyButton.Location = new System.Drawing.Point(425, 6);
            this.applyButton.Name = "applyButton";
            this.applyButton.Size = new System.Drawing.Size(75, 23);
            this.applyButton.TabIndex = 1;
            this.applyButton.Text = "Apply";
            this.applyButton.UseVisualStyleBackColor = true;
            this.applyButton.Click += new System.EventHandler(this.applyButton_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(506, 6);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(75, 23);
            this.cancelButton.TabIndex = 0;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            // 
            // preferencesTabControl
            // 
            this.preferencesTabControl.Dock = System.Windows.Forms.DockStyle.Fill;
            this.preferencesTabControl.Location = new System.Drawing.Point(5, 5);
            this.preferencesTabControl.Name = "preferencesTabControl";
            this.preferencesTabControl.SelectedIndex = 0;
            this.preferencesTabControl.Size = new System.Drawing.Size(581, 363);
            this.preferencesTabControl.TabIndex = 1;
            // 
            // Preferences
            // 
            this.AcceptButton = this.applyButton;
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(591, 402);
            this.Controls.Add(this.preferencesTabControl);
            this.Controls.Add(this.buttonsPanel);
            this.Name = "Preferences";
            this.Padding = new System.Windows.Forms.Padding(5);
            this.Text = "Preferences";
            this.buttonsPanel.ResumeLayout(false);
            this.ResumeLayout(false);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\App\Preferences.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using STFGui.Plugins;

namespace STFGui
{
    public partial class Preferences : Form
    {
        private static object initLock = new object();

        private static Preferences current;
        public static Preferences Current
        {
            get
            {
                if (current == null || current.IsDisposed)
                {
                    lock (initLock)
                    {
                        if (current == null || current.IsDisposed)
                        {
                            current = new Preferences();
                        }
                    }
                }

                return current;
            }
        }

        public static void ShowPreferences()
        {
            Current.ShowPreferencesWindow();
        }

        public List<IPluginPreferences> PreferencePlugins = new List<IPluginPreferences>();

        public Preferences()
        {
            this.InitializeComponent();

            this.FormClosing += new FormClosingEventHandler(Preferences_FormClosing);
        }

        void Preferences_FormClosing(object sender, FormClosingEventArgs e)
        {
            // Prevent the user from closing the window, just hide it.
            if (e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                Form f = sender as Form;
                f.Hide();
            }
        }

        private void applyButton_Click(object sender, EventArgs e)
        {
            this.ApplyPreferences();
            this.Hide();
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            this.InitializePreferenceTabs();
            this.Hide();
        }

        public void AddTabForObject(String name, ICloneable preferencesObject)
        {
            PreferencesTab tab = null;
            if (this.preferencesTabControl.TabPages.ContainsKey(name))
            {
                tab = this.preferencesTabControl.TabPages[name] as PreferencesTab;
                tab.PreferencesObject = preferencesObject;
            }
            else
            {
                tab = new PreferencesTab(name, preferencesObject);
                this.preferencesTabControl.TabPages.Add(tab);

            }
        }


        private void ShowPreferencesWindow()
        {
            InitializePreferenceTabs();
            Show();
            Activate();
        }

        private void InitializePreferenceTabs()
        {
            foreach (IPluginPreferences prefPlugin in PreferencePlugins)
            {
                AddTabForObject(
                    prefPlugin.GetType().Name,
                    prefPlugin.PluginPreferences.Clone() as ICloneable);
            }
        }

        private void ApplyPreferences()
        {
            // Get all the preference objects and save them
            foreach (IPluginPreferences prefPlugin in PreferencePlugins)
            {
                String prefName = prefPlugin.GetType().Name;
                PreferencesTab tab = preferencesTabControl.TabPages[prefName] as PreferencesTab;

                prefPlugin.PluginPreferences = tab.PreferencesObject;
            }
        }
    }

    public class PreferencesTab : TabPage
    {
        private PropertyGrid tabPropertyGrid;

        public ICloneable PreferencesObject
        {
            get { return tabPropertyGrid.SelectedObject as ICloneable; }
            set { tabPropertyGrid.SelectedObject = value; }
        }

        public PreferencesTab()
        {
            tabPropertyGrid = new PropertyGrid();

            this.Padding = new Padding(5);
            this.Controls.Add(tabPropertyGrid);

            this.tabPropertyGrid.Dock = DockStyle.Fill;
        }

        public PreferencesTab(String preferencesName, Object preferencesObject)
            : this()
        {
            this.Text = preferencesObject.GetType().Name;
            this.Name = preferencesName;
            this.tabPropertyGrid.SelectedObject = preferencesObject;
        }

        public PreferencesTab(Object preferencesObject)
            : this(preferencesObject.GetType().Name, preferencesObject)
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\GuiCommon\GuiCommon.cs ===
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Collections.Generic;

using ServerTestFramework;

namespace STFGui
{
    /// <summary>
    /// Commonly used gui things.
    /// </summary>
    public class GuiCommon
    {
        /// <summary>
        /// Pops up a file selection window.
        /// </summary>
        /// <param name="isForSaving">Whether to show a save or load dialog.</param>
        /// <param name="typeList">The OpenFileDialog.Filter string. (for example: "Test Suites (*.dll)|*.dll")</param>
        /// <returns>The chosen file, or null if none.</returns>
        public static string ChooseFile(bool isForSaving, string filterString)
        {
            //store current directory: win32 common controls evilly alter the current directory, which can screw a lot of things up
            string curDir = System.Environment.CurrentDirectory;

            // Popup handler opens file dialog so user can manually load a test suite DLL.
            DialogResult res;
            string fname;
            if (isForSaving)
            {
                SaveFileDialog sfd = new SaveFileDialog();
                sfd.CheckFileExists = !isForSaving;
                sfd.CheckPathExists = true;
                sfd.Filter = filterString;
                res = sfd.ShowDialog();
                fname = sfd.FileName;
            }
            else
            {
                OpenFileDialog ofd = new OpenFileDialog();
                ofd.CheckFileExists = !isForSaving;
                ofd.CheckPathExists = true;
                ofd.Filter = filterString;
                res = ofd.ShowDialog();
                fname = ofd.FileName;
            }

            //fix back the current directory
            System.Environment.CurrentDirectory = curDir;

            if (res==DialogResult.OK)
            {
                return fname;
            }

            return null;
        }

        /// <summary>
        /// Retrieves a number from the user.
        /// </summary>
        public static int GetNumberFromUser(Form parentForm, string nameOfValue, int defaultValue)
        {
            while (true)
            {
                //make a box for this
                Form form=new Form();
                form.SetBounds(0,0,200,85,BoundsSpecified.Size);
                form.Text=nameOfValue;
                form.FormBorderStyle=FormBorderStyle.FixedDialog;
                form.MaximizeBox=false;

                Size expectedFormSize=new Size(192,58); //for funky windows ui styles, we need to adjust form size
                Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
                form.Size+=diffFormSize;

                //make controls
                TextBox input=new TextBox();
                input.Text=defaultValue.ToString();
                input.SetBounds(25,5,150,25);

                Button butOk=new Button();
                butOk.Text="Ok";
                butOk.SetBounds(15,30,75,25);
                butOk.DialogResult=DialogResult.OK;

                Button butCan=new Button();
                butCan.Text="Cancel";
                butCan.SetBounds(200-15-75,30,75,25);
                butCan.DialogResult=DialogResult.Cancel;

                //put it together and show it
                form.Controls.Add(input);
                form.Controls.Add(butOk);
                form.Controls.Add(butCan);

                form.AcceptButton=butOk;
                form.CancelButton=butCan;
                form.ShowDialog(parentForm);

                //handle result
                if (form.DialogResult==DialogResult.OK)
                {
                    try
                    {
                        return int.Parse(input.Text);
                    }
                    catch
                    {
                        MessageBox.Show(form, "Entered value is not a valid integer.");
                    }
                }
                else
                    return defaultValue;
            }
        }

        /// <summary>
        /// Retrieves a string from the user.
        /// </summary>
        public static string GetStringFromUser(Form parentForm, string nameOfValue, string defaultValue)
        {
            //make a box for this
            Form form=new Form();
            form.SetBounds(0,0,200,85,BoundsSpecified.Size);
            form.Text=nameOfValue;
            form.FormBorderStyle=FormBorderStyle.FixedDialog;
            form.MaximizeBox=false;

            Size expectedFormSize=new Size(192,58); //for funky windows ui styles, we need to adjust form size
            Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
            form.Size+=diffFormSize;

            //make controls
            TextBox input=new TextBox();
            input.Text=defaultValue;
            input.SetBounds(25,5,150,25);

            Button butOk=new Button();
            butOk.Text="Ok";
            butOk.SetBounds(15,30,75,25);
            butOk.DialogResult=DialogResult.OK;

            Button butCan=new Button();
            butCan.Text="Cancel";
            butCan.SetBounds(200-15-75,30,75,25);
            butCan.DialogResult=DialogResult.Cancel;

            //put it together and show it
            form.Controls.Add(input);
            form.Controls.Add(butOk);
            form.Controls.Add(butCan);

            form.AcceptButton=butOk;
            form.CancelButton=butCan;
            form.ShowDialog(parentForm);

            //handle result
            if (form.DialogResult==DialogResult.OK)
            {
                return input.Text;
            }
            else
            {
                return null;
            }
        }
    };

    /// <summary>
    /// Contol derived from a combo box and a checked list box.  Dropping down the control simply shows the list box instead.
    /// </summary>
    public class ComboDropBoxWithListOfChecks: ComboBox
    {
        //event for when a checkbox is changed
        public delegate void ChecksChangedDelegate(ComboDropBoxWithListOfChecks box, ItemCheckEventArgs itemChangeArgs);
        public event ChecksChangedDelegate ChecksChanged;

        //automatically set text based on checked boxes?
        public bool AutoBuildText=true;
        public string TextWhenNoneChecked
        {
            get { return textWhenNoneChecked; }
            set
            {
                textWhenNoneChecked=value;
                OnTextChanged(null);
            }
        }
        public string TextWhenNoOptions
        {
            get { return textWhenNoOptions; }
            set
            {
                textWhenNoOptions=value;
                OnTextChanged(null);
            }
        }

        public new bool Enabled //whether it "can" be enabled
        {
            get { return enabled; }
            set
            {
                enabled=value;
                if (controlEnabled && enabled)
                {
                    base.Enabled=true;
                }
                if (!controlEnabled || !enabled)
                {
                    base.Enabled=false;
                }
            }
        }
        public bool CurrentlyEnabled //whether the user currently sees it as enabled
        {
            get { return base.Enabled; }
        }

        //Add an item to the list
        public void AddItem(string name)
        {
            list.Items.Add(name);
            OnTextChanged(null);
        }

        //Remove an item from the list by index
        public void RemoveItem(int ind)
        {
            list.Items.Remove(ind);
        }

        //Retrieves a list of items (this should be considered read-only)
        public CheckedListBox.ObjectCollection GetItems()
        {
            return list.Items;
        }

        public void SetItemChecked(int itemIndex, bool isChecked)
        {
            list.SetItemChecked(itemIndex, isChecked);
            OnTextChanged(null);
        }

        public bool IsItemChecked(int itemIndex)
        {
            return list.GetItemChecked(itemIndex);
        }

        // -- implementation details

        //populate this list with anything you care about
        private CheckedListBox list=new CheckedListBox();

        private string textWhenNoneChecked="";
        private string textWhenNoOptions="";
        
        private bool enabled=true;
        private bool controlEnabled=true;

        //ctor
        public ComboDropBoxWithListOfChecks()
        {
            list.Visible=false;
            list.CheckOnClick=true;
            list.MouseLeave+=List_LostFocus;
            list.ItemCheck+=ItemCheckEventHandler;
            
            OnTextChanged(null);
        }

        //drop down event - only we do the magic
        protected override void OnDropDown(EventArgs ea)
        {
            if (Parent==null || list.Items.Count==0)
            {
                return;
            }

            //poof goes us
            DropDownHeight=1;
            SendToBack();
            DroppedDown=false;
            Visible=false;

            //move the List to where we are and show it
            TopLevelControl.Controls.Add(list);
            list.Location=GetTopLevelLocation();
            list.Size=Size;
            list.Visible=true;
            list.BringToFront();
            list.Height=list.GetPreferredSize(Size).Height;

        }

        //converts my location to the top level control's location
        Point GetTopLevelLocation()
        {
            Point p=new Point();
            Control c=this;
            while (c!=TopLevelControl)
            {
                p.X+=c.Location.X;
                p.Y+=c.Location.Y;

                c=c.Parent;
            }
            return p;
        }

        private void List_LostFocus(object sender, EventArgs args)
        {
            list.Visible=false;

            Visible=true;
            BringToFront();
            OnTextChanged(args);
        }

        public void ItemCheckEventHandler(object sender, ItemCheckEventArgs e)
        {
            if (AutoBuildText)
            {
                OnTextChanged(e);
            }

            if (ChecksChanged!=null)
            {
                ChecksChanged(this, e);
            }
        }

        protected override void OnClick(EventArgs args)
        {
            OnDropDown(args);
        }

        protected override void OnTextChanged(EventArgs args)
        {
            if (AutoBuildText)
            {
                //build our string from our associated checks
                string myStr="";
                foreach (int i in list.CheckedIndices)
                {
                    if (myStr.Length!=0) myStr+=",";
                    myStr+=list.Items[i];
                }

                //update the box now
                if (list.Items.Count==0)
                {
                    myStr=TextWhenNoOptions;
                    controlEnabled=false;
                }
                else
                {
                    controlEnabled=true;
                }
                Enabled=Enabled;

                if (myStr.Length==0)
                {
                    myStr=TextWhenNoneChecked;
                }

                if (Text!=myStr)
                {
                    Text=myStr;
                }
            }

            base.OnTextChanged(args);
        }
    };

    /// <summary>
    /// A tab control where the user may rearrange the tabs on their whim.
    /// Usable only for horizontally aligned tabs at the moment.
    /// </summary>
    public class RearrangeableTabControl: TabControl
    {
        /// <summary>
        /// Event is triggered whenever the user manually rearranges the tab pages.
        /// </summary>
        public event UserRearrangedPagesDelegate UserRearrangedPages;
        public delegate void UserRearrangedPagesDelegate(TabControl tc);

        // -- internals

        private bool allowDrag=false; //used to prevent other processes from dragging to us

        public RearrangeableTabControl()
        {
            AllowDrop=true;
            MouseDown+=Tabs_MouseDown;
            DragEnter+=Tabs_DragEnter;
            DragDrop+=Tabs_DragDrop;
            LostFocus+=Tabs_LostFocus;
        }

        private void Tabs_MouseDown(object sender, MouseEventArgs ea)
        {
            bool junk;
            int ind=FindTabPage((new Point(ea.X, ea.Y)), out junk);
            if (ind!=-1)
            {
                allowDrag=true;
                DoDragDrop(TabPages[ind], DragDropEffects.Move);
            }
        }

        private void Tabs_DragEnter(object sender, DragEventArgs ea)
        {
            if (!allowDrag)
            {
                ea.Effect=DragDropEffects.None;
                return;
            }

            //
            ea.Effect=DragDropEffects.Move;
        }

        private void Tabs_DragDrop(object sender, DragEventArgs ea)
        {
            allowDrag=false;

            if (ea.Effect!=DragDropEffects.None)
            {
                if(ea.Data.GetDataPresent(typeof(TabPage)))
                {
                    //get source index
                    TabPage sourcePage=(TabPage)ea.Data.GetData(typeof(TabPage));
                    int srcInd=-1;
                    for (int i=0; i<TabPages.Count; ++i)
                    {
                        if (TabPages[i]==sourcePage)
                        {
                            srcInd=i;
                        }
                    }

                    //get dest index
                    bool isLeftHalf;
                    int dstInd=FindTabPage(PointToClient(new Point(ea.X, ea.Y)), out isLeftHalf);
                    if (dstInd!=-1 && srcInd!=-1)
                    {
                        //see if the drop location would even move it
                        if (dstInd!=srcInd && (isLeftHalf?(dstInd-1!=srcInd):(dstInd+1!=srcInd)))
                        {
                            //build the rearranged list of tab pages
                            List<TabPage> newPages=new List<TabPage>();
                            for (int i=0; i<TabPages.Count; ++i)
                            {
                                if (dstInd<srcInd) //right to left
                                {
                                    if (i==dstInd)
                                    {
                                        newPages.Add(TabPages[srcInd]);
                                    }
                                    else
                                    {
                                        int ri=i;
                                        if (i>dstInd) --ri;
                                        if (ri>=srcInd) ++ri;
                                        newPages.Add(TabPages[ri]);
                                    }
                                }
                                else if (dstInd>srcInd) //left to right
                                {
                                    if (i==dstInd)
                                    {
                                        newPages.Add(TabPages[srcInd]);
                                    }
                                    else
                                    {
                                        int ri=i;
                                        if (i>=srcInd) ++ri;
                                        if (ri>dstInd) --ri;
                                        newPages.Add(TabPages[ri]);
                                    }
                                }
                            }

                            //replace original list
                            TabPage curTab=SelectedTab;
                            TabPages.Clear();
                            foreach (TabPage tp in newPages)
                            {
                                TabPages.Add(tp);
                            }
                            SelectedTab=curTab;

                            //trigger event
                            if (UserRearrangedPages!=null)
                            {
                                UserRearrangedPages(this);
                            }
                        }
                    }
                }
            }
        }

        private void Tabs_LostFocus(object sender, EventArgs e)
        {
            allowDrag=false;
        }

        //gets which tab page index a point is over (-1 if none), and which half it is
        private int FindTabPage(Point clientPoint, out bool isLeftHalf)
        {
            for(int i=0; i<TabPages.Count; ++i)
            {
                Rectangle rect=GetTabRect(i);
                if(rect.Contains(clientPoint))
                {
                    isLeftHalf=clientPoint.X<(rect.X+rect.Width/2);
                    return i;
                }
            }
            
            isLeftHalf=true;
            return -1;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\GuiCommon\Plugins.cs ===
using System.Xml;
using ServerTestFramework.Plugins;

/*
 You may implement one or more of the interfaces defined here to piece together
 the functionality you require.  Methods will be called in the following order
 over the life of the app:

while (app is running)
{
    IPluginSetup.Initialize (one time only)

    for (every newly loaded plugin)
    {
        IPluginGui.GetNew* (once only for any given Plugin)
    }

    for (every newly loaded extension)
    {
        IPluginExtension.PluginLoaded (once for each plugin that is extended)
    }

    for (every newly loaded suite)
    {
        IPluginSuiteLoadedNotification.SuiteLoaded (once for each suite)
    }
}

IPluginSetup.Shutdown (one time only)
*/

namespace STFGui.Plugins
{
    /// <summary>
    /// Implement this interface to provide an object that has properties that
    /// you would like to be able to change in the GUI.
    /// If there is no GUI (ex STFConsole), these methods will not be called.
    /// </summary>
    public interface IPluginPreferences : IPlugin
    {
        System.ICloneable PluginPreferences { get; set; }
    }

    /// <summary>
    /// Implement this interface for access to the GUI, if it is present.
    /// If there is no GUI (ex STFConsole), these methods will not be called.
    /// </summary>
    public interface IPluginGui : IPlugin
    {
        /// <summary>
        /// If a gui is present, this contains information and methods needed to
        /// hook into it.
        /// </summary>
        MainGuiHooks GuiHooks { get; set; }

        /// <summary>
        /// You implement this to return a new TabPage to add to the gui.
        /// Return null if you don't want a tab page.
        /// </summary>
        System.Windows.Forms.TabPage GetNewTabPage ();

        /// <summary>
        /// You implement this to return a new menu to add to the gui.
        /// Return null if you don't want a menu.
        /// </summary>
        System.Windows.Forms.MenuItem GetNewMenu ();

        /// <summary>
        /// This is called when the GUI is initialy shown to the user.  
        /// Implenent if this plugin needs to react to the Gui being shown to
        /// the user.
        /// </summary>
        void OnGuiShown ();
    }

    /// <summary>
    /// Information and methods for interacting with the main gui container.
    /// </summary>
    public abstract class MainGuiHooks
    {
        /// <summary> The main form of the app. </summary>
        public System.Windows.Forms.Form MainForm;

        //this event occurs when all output should be cleared
        public delegate void ClearOutputDelegate();
        public abstract void AddClearOutputHandler(ClearOutputDelegate handler);

        /// <summary>
        /// Limits the output to the main text box to the given size.
        /// </summary>
        /// <param name="limit">
        /// The max number of characters to allow, or 0 to disable the limit
        /// </param>
        public abstract void LimitOutput(int limit);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\App\Preferences.Designer.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace STFGui
{
    public partial class Preferences : Form
    {
        private Button applyButton;
        private Button cancelButton;
        private TabControl preferencesTabControl;
        private Panel buttonsPanel;

        public void InitializeComponent()
        {
            this.buttonsPanel = new System.Windows.Forms.Panel();
            this.applyButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.preferencesTabControl = new System.Windows.Forms.TabControl();
            this.buttonsPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // buttonsPanel
            // 
            this.buttonsPanel.Controls.Add(this.applyButton);
            this.buttonsPanel.Controls.Add(this.cancelButton);
            this.buttonsPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.buttonsPanel.Location = new System.Drawing.Point(5, 368);
            this.buttonsPanel.Name = "buttonsPanel";
            this.buttonsPanel.Size = new System.Drawing.Size(581, 29);
            this.buttonsPanel.TabIndex = 0;
            // 
            // applyButton
            // 
            this.applyButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.applyButton.Location = new System.Drawing.Point(425, 6);
            this.applyButton.Name = "applyButton";
            this.applyButton.Size = new System.Drawing.Size(75, 23);
            this.applyButton.TabIndex = 1;
            this.applyButton.Text = "Apply";
            this.applyButton.UseVisualStyleBackColor = true;
            this.applyButton.Click += new System.EventHandler(this.applyButton_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(506, 6);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(75, 23);
            this.cancelButton.TabIndex = 0;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            // 
            // preferencesTabControl
            // 
            this.preferencesTabControl.Dock = System.Windows.Forms.DockStyle.Fill;
            this.preferencesTabControl.Location = new System.Drawing.Point(5, 5);
            this.preferencesTabControl.Name = "preferencesTabControl";
            this.preferencesTabControl.SelectedIndex = 0;
            this.preferencesTabControl.Size = new System.Drawing.Size(581, 363);
            this.preferencesTabControl.TabIndex = 1;
            // 
            // Preferences
            // 
            this.AcceptButton = this.applyButton;
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(591, 402);
            this.Controls.Add(this.preferencesTabControl);
            this.Controls.Add(this.buttonsPanel);
            this.Name = "Preferences";
            this.Padding = new System.Windows.Forms.Padding(5);
            this.Text = "Preferences";
            this.buttonsPanel.ResumeLayout(false);
            this.ResumeLayout(false);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\App\Gui.cs ===
using System;
using System.Reflection;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace STFGui
{
    /// <summary>
    /// The main gui form that holds all other forms
    /// </summary>
    public class STFGuiForm: Form
    {
        //Public components
        public RearrangeableTabControl Tabs;
        public GuiPluginHandler Plugins;
        public LinkedList<TestNode> SuiteRoots=new LinkedList<TestNode>();
        public LinkedList<string> LoadedModules=new LinkedList<string>();
        public LinkedList<string> LoadedModuleFiles=new LinkedList<string>();
        public XmlDocument Settings;

        //Internal components
        private SplitContainer splitTabsAndOutput;
        private StfTextBox outputBox;

        MRUList MRUFileList;
        MenuItem ViewFilterDebug;
        MenuItem ViewFilterInfo;
        MenuItem ViewFilterWarn;
        MenuItem ViewFilterError;
        MenuItem ViewFilterFatal;
        MenuItem ViewFilterSuccess;
        MenuItem ViewFilterAll;
        MenuItem ViewFilterNone;
        MenuItem ViewOuputLimit;
        MenuItem LogOutputToFile;

        bool allowClose = false;
        bool isClosing = false;
        bool isFirstShown = true;
        bool logToFile = false;

        FileReportDestination fileOutputDest=null;

        public delegate void InvokeCode();
        static Report ro=new Report("Gui");

        List<string> userPrefferedTabOrder=new List<string>();
        List<string> titlebarAssemblyNames=new List<string>();

        public bool LogToFile
        {
            get
            {
                return this.logToFile; 
            }

            set
            {
                lock (this)
                {
                    if (this.logToFile == value)
                    {
                        return;
                    }

                    this.logToFile = value;

                    // Assign checked value to menu item in case this set is not from the event handler.
                    LogOutputToFile.Checked = value;

                    //scrap the old
                    if (fileOutputDest != null)
                    {
                        Report.GetRoot().RemoveReportDestination(fileOutputDest);
                        fileOutputDest.Close();
                        fileOutputDest = null;
                    }

                    if (this.logToFile)
                    {
                        fileOutputDest = new FileReportDestination("FuncOutput", "Log", System.DateTime.Now);
                        Report.GetRoot().AddReportDestination(fileOutputDest);
                    }
                }
            }
        }


        //ctor
        public STFGuiForm()
        {
            // This should prevent those totally crappy no info crashes
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);

            //load settings from file
            Settings=new XmlDocument();
            try
            {
                Settings.Load("STFGui.xml");
            }
            catch
            {
                //it's ok if it fails, it's probably because it doesn't exist, so we will use defaults.
            }

            //get or create our main settings node
            XmlNode mainNode=Settings.SelectSingleNode("STFGui");
            if (mainNode==null)
            {
                mainNode=Settings.CreateNode(XmlNodeType.Element, "STFGui", "");
                Settings.AppendChild(mainNode);
            }

            XmlNode groupNode=XmlUtil.GetGroupNode(mainNode, "BaseGui");

            //set up us and our events
            Text="STFGui";
            FormClosing+=Form_Closing;
            Shown+=Form_Shown;
            CoreGlobal.TestNodeTreeLoaded+=SuiteLoaded;
            CoreGlobal.TestNodeTreeUnloaded+=SuiteUnloaded;
            CoreGlobal.ReloadAllTestTrees+=ReloadSuites;

            //set up the main menu
            Menu=new MainMenu();

            //set up the file menu
            MenuItem menuFile=new MenuItem();
            menuFile.Text="File";
            this.Menu.MenuItems.Add(menuFile);

            MenuItem menuFileLoadSuite=new MenuItem();
            menuFileLoadSuite.Text="Load Suite or Plugin";
            menuFileLoadSuite.Click+=MenuChoice_File_LoadSuite;
            menuFileLoadSuite.Shortcut = Shortcut.CtrlO;
            menuFile.MenuItems.Add(menuFileLoadSuite);

            MenuItem menuFileReloadSuites=new MenuItem();
            menuFileReloadSuites.Text="Reload Suites";
            menuFileReloadSuites.Click+=MenuChoice_File_ReloadSuites;
            menuFileReloadSuites.Shortcut = Shortcut.CtrlF5;
            menuFile.MenuItems.Add(menuFileReloadSuites);

            menuFile.MenuItems.Add(new MenuItem("-"));

            MenuItem menuFileAttachDebugger = new MenuItem();
            menuFileAttachDebugger.Text = "Attach Debugger...";
            menuFileAttachDebugger.Click += MenuChoice_File_AttachDebugger;
            menuFileAttachDebugger.Shortcut = Shortcut.CtrlK;
            menuFile.MenuItems.Add(menuFileAttachDebugger);

            MenuItem menuFilePreferences = new MenuItem();
            menuFilePreferences.Text = "Preferences...";
            menuFilePreferences.Click += MenuChoice_File_Preferences;
            menuFilePreferences.Shortcut = Shortcut.CtrlShiftP;
            menuFile.MenuItems.Add(menuFilePreferences);

            menuFile.MenuItems.Add(new MenuItem("-"));

            //MRU File list.
            string paths = XmlUtil.GetChildNodeValue(groupNode, "MRUFileList", String.Empty);
            MRUFileList = new MRUList("Recently Loaded Suites/Plugins");
            MRUFileList.ClickChild += MenuChoice_MRU_ItemClick;
            MRUFileList.LoadCSVString(paths);
            menuFile.MenuItems.Add(MRUFileList);

            menuFile.MenuItems.Add(new MenuItem("-"));

            MenuItem menuFileExit=new MenuItem();
            menuFileExit.Text="Exit";
            menuFileExit.Click+=MenuChoice_File_Exit;
            menuFile.MenuItems.Add(menuFileExit);

            //splitter between the tab-specific area and the output box area
            splitTabsAndOutput=new SplitContainer();
            splitTabsAndOutput.Orientation=Orientation.Horizontal;
            splitTabsAndOutput.Size=new System.Drawing.Size(Width, XmlUtil.GetChildNodeValue(groupNode, "SplitterHeight", 600));
            splitTabsAndOutput.Dock=DockStyle.Fill;
            ++splitTabsAndOutput.SplitterWidth;
            this.Controls.Add(splitTabsAndOutput);
            splitTabsAndOutput.SplitterDistance=(int)(splitTabsAndOutput.Height*XmlUtil.GetChildNodeValue(groupNode, "SplitterBar", 0.5f));

            //the output box
            outputBox=new StfTextBox();
            outputBox.Dock=DockStyle.Fill;

            splitTabsAndOutput.Panel2.Controls.Add(outputBox);

            try
            {
                splitTabsAndOutput.Panel2.GetType().GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(splitTabsAndOutput.Panel2, true, null);
            }
            catch (Exception e)
            {
                ro.Warn("Error occured while trying to double buffer the output box:\n" + e.ToString());
            }

            //the tab list
            Tabs=new RearrangeableTabControl();
            Tabs.Dock=DockStyle.Fill;
            splitTabsAndOutput.Panel1.Controls.Add(Tabs);
            Tabs.UserRearrangedPages+=Tabs_Rearranged;

            //set up the view menu
            MenuItem menuView=new MenuItem();
            menuView.Text="Output";
            Menu.MenuItems.Add(menuView);

            MenuItem menuClearOutput=new MenuItem("Clear", MenuChoice_Output_ClearOutput);
            menuView.MenuItems.Add(menuClearOutput);

            ViewOuputLimit = new MenuItem("Limit Output");
            MenuItem tempLimitItem = new MenuItem("No Limit", MenuChoice_Output_Limit);
            tempLimitItem.Checked = true;
            tempLimitItem.Tag = 0;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("1K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 1000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("10K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 10000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("100K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 100000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("1M", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 1000000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("10M", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 10000000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            menuView.MenuItems.Add(ViewOuputLimit);

            MenuItem menuDiv=new MenuItem();
            menuDiv.Text="-";
            menuView.MenuItems.Add(menuDiv);

            ViewFilterAll=new MenuItem("Enable ALL",MenuChoice_Output_ChangeFilter);
            menuView.MenuItems.Add(ViewFilterAll);
            ViewFilterNone=new MenuItem("Enable NONE",MenuChoice_Output_ChangeFilter);
            menuView.MenuItems.Add(ViewFilterNone);
            ViewFilterDebug=new MenuItem("Debug",MenuChoice_Output_ChangeFilter);
            ViewFilterDebug.Checked=true;
            menuView.MenuItems.Add(ViewFilterDebug);
            ViewFilterInfo=new MenuItem("Info",MenuChoice_Output_ChangeFilter);
            ViewFilterInfo.Checked=true;
            menuView.MenuItems.Add(ViewFilterInfo);
            ViewFilterWarn=new MenuItem("Warn",MenuChoice_Output_ChangeFilter);
            ViewFilterWarn.Checked=true;
            menuView.MenuItems.Add(ViewFilterWarn);
            ViewFilterError=new MenuItem("Error",MenuChoice_Output_ChangeFilter);
            ViewFilterError.Checked=true;
            menuView.MenuItems.Add(ViewFilterError);
            ViewFilterFatal=new MenuItem("Fatal",MenuChoice_Output_ChangeFilter);
            ViewFilterFatal.Checked=true;
            menuView.MenuItems.Add(ViewFilterFatal);
            ViewFilterSuccess=new MenuItem("Success",MenuChoice_Output_ChangeFilter);
            ViewFilterSuccess.Checked=true;
            menuView.MenuItems.Add(ViewFilterSuccess);

            menuDiv=new MenuItem();
            menuDiv.Text="-";
            menuView.MenuItems.Add(menuDiv);

            MenuItem menuViewLogToFile=new MenuItem("Log To File", MenuChoice_Output_LogToFile);
            menuView.MenuItems.Add(menuViewLogToFile);
            menuViewLogToFile.Checked=!XmlUtil.GetChildNodeValue(groupNode, "OutputLogToFile", logToFile);
            MenuChoice_Output_LogToFile(menuViewLogToFile, null); //this toggles it
            LogOutputToFile = menuViewLogToFile;
        }

        //app crash handler
        void CurrentDomain_UnhandledException (object sender, UnhandledExceptionEventArgs e)
        {
            System.Text.StringBuilder builder = new System.Text.StringBuilder();

            // time
            builder.Append("At ");
            builder.AppendLine(DateTime.Now.ToString());

            // termination message
            if (e.IsTerminating)
            {
                builder.AppendLine("An unhandled exception in a thread is causing STFGui to terminate, please investigate.");
            }
            else
            {
                builder.AppendLine("An unhandled exception in a thread has caused this message, please investigate.");
                builder.AppendLine("STFGui SHOULD NOT be terminating.");
            }
            builder.AppendLine();

            // sender info
            AppDomain appdom = sender as AppDomain;
            if (appdom != null)
            {
                builder.Append("AppDomain: ");
                builder.AppendLine(appdom.FriendlyName);
            }
            else
            {
                builder.Append("Sender: ");
                builder.AppendLine(sender.ToString());
            }
            builder.AppendLine();

            // exception info
            Exception exc = e.ExceptionObject as Exception;
            if (exc != null)
            {
                builder.Append(exc.ToString());
            }
            else
            {
                builder.Append("Exception is null, yikes!");
            }

            string message = builder.ToString();

            try
            {
                System.IO.File.AppendAllText(System.IO.Path.GetFullPath(".\\STFGuiCrashInfo.txt"),
                    message + Environment.NewLine + Environment.NewLine);
            }
            catch { }

            try
            {
                MessageBox.Show(message);
            }
            catch { }
        }

        //Should be called after construction to init public members.  Returns flags that indicate the success of handling paramaters
        public MainApp.STFGuiExitCode Init(string []mainAppParameters, string []pluginParameters)
        {
            MainApp.STFGuiExitCode status=MainApp.STFGuiExitCode.OK;

            //hook console output to stf, and stf output up to our output box
            Report.GetRoot().AddReportDestination(outputBox);
            Console.SetError(new TextWriterReportBridge("STDERR"));
            Console.SetOut(new TextWriterReportBridge("STDOUT"));

            //handle parameters to the gui itself
            bool ignoreDefaultPlugins=false;
            if (!HandleCommandlineOptions(mainAppParameters, ref ignoreDefaultPlugins))
            {
                status|=MainApp.STFGuiExitCode.GuiParamError;
            }

            //spit out our version
            ro.Debug(Assembly.GetExecutingAssembly().GetName().Name+" is version "+Assembly.GetExecutingAssembly().GetName().Version);
            ro.Debug("STFCore is version "+CoreGlobal.GetCoreAssembly().GetName().Version);

            //load default plugins
            //TODO: figure out if any plugin parameters had errors and set status for that here
            Plugins=new GuiPluginHandler(this, pluginParameters);
            if (!ignoreDefaultPlugins)
            {
                Plugins.LoadPluginFiles();
            }

            //load tab arrangement
            XmlNode groupNode=Settings.DocumentElement.SelectSingleNode("BaseGui");

            XmlNode tabOrderGroupNode=XmlUtil.GetGroupNode(groupNode, "TabOrder");
            foreach(XmlNode n in tabOrderGroupNode.ChildNodes)
            {
                if (n.Name=="TabName")
                {
                    userPrefferedTabOrder.Add(n.InnerXml);
                }
            }

            string initialTabName=XmlUtil.GetChildNodeValue(groupNode, "OpenTab","Functional");
            ArrangeTabsAndSelectInitialTab(initialTabName);

            return status;
        }

        private void ArrangeTabsAndSelectInitialTab(string initialTabName)
        {
            RearrangeTabsForUser();

            //select the last plugin tab if possible
            foreach (TabPage tp in Tabs.TabPages)
            {
                if (tp.Text==initialTabName)
                {
                    Tabs.SelectTab(tp);
                    break;
                }
            }
        }

        //handles commandline options that are specifically targetted at STFGui itself.  returns false if there were any errors with the parameters
        private bool HandleCommandlineOptions(string []options, ref bool outIgnoreDefaultPlugins)
        {
            bool errors=false;
            foreach (string option in options)
            {
                string lowerOption=option.ToLower();

                try
                {
                    if (lowerOption.StartsWith("-logtofile")) //turn on/off logging to file
                    {
                        LogToFile=true;
                        if (lowerOption.StartsWith("-logtofile:")) //they can also specify true or false for the value
                        {
                            int sepInd=lowerOption.IndexOf(":");
                            string value=lowerOption.Substring(sepInd+1);
                            LogToFile=bool.Parse(value);
                        }
                        ro.Debug("STFGui option: LogToFile="+LogToFile);
                    }
                    else if (lowerOption=="-ignoredefaultplugins") //don't load any default plugins
                    {
                        outIgnoreDefaultPlugins=true;
                        ro.Debug("STFGui option: IgnoreDefaultPlugins="+outIgnoreDefaultPlugins);
                    }
                    else if (lowerOption.StartsWith("-outputfilter:")) //change initial output filter
                    {
                        //break the parameter list down
                        string valueListString=lowerOption.Substring(lowerOption.IndexOf(":")+1);
                        string []values=valueListString.Split(new char[]{','});

                        //turn all off, then only turn on the ones they specified, then refresh it
                        MenuChoice_Output_ChangeFilter(ViewFilterNone, null);

                        foreach (string value in values)
                        {
                            if (value=="debug")        ViewFilterDebug.Checked  =true;
                            else if (value=="info")    ViewFilterInfo.Checked   =true;
                            else if (value=="warn")    ViewFilterWarn.Checked   =true;
                            else if (value=="error")   ViewFilterError.Checked  =true;
                            else if (value=="fatal")   ViewFilterFatal.Checked  =true;
                            else if (value=="success") ViewFilterSuccess.Checked=true;
                            else
                            {
                                //no output is enabled now, so trying to give a text message here is fruitless
                                errors=true;
                            }
                        }

                        MenuChoice_Output_ChangeFilter(null, null);
                    }
                    else if (lowerOption=="help" || lowerOption=="--help" || lowerOption=="-help" || lowerOption=="-?" || lowerOption=="-h") //h[r]elp!
                    {
                        ro.Info("STFGui Commandline Options: STFGui.exe [Module(s).dll] [Options]");
                        ro.Info("Modules are DLL files should contain either test suite(s), or plugin(s).");
                        ro.Info("Options are:");
                        ro.Info(" -LogToFile[:value]                  Turn on or off file logging.  value may be: true or false");
                        ro.Info(" -IgnoreDefaultPlugins               Do not automatically load plugins listed in STFGui.xml");
                        ro.Info(" -OutputFilter:value0[,value1,etc]   Sets the initial output filter.  values may any of: Debug, Info, Warn, Error, Fatal, Success");
                        ro.Info(" -PlugParam:PluginClass:value        Passes a parameter to a specific plugin");
                        // Putting this here, but handled as early as possible in Main.cs
                        ro.Info(" -BreakOnStart                       Breaks into the debugger at startup");
                    }
                    else //woops
                    {
                        ro.Warn("Unknown STFGui commandline parameter: "+option);
                        errors=true;
                    }
                }
                catch (Exception e) //very woops
                {
                    ro.Fatal("Exception handling commandline parameter for STFGui.\nParameter was: "+option+"\nException was: "+e);
                    errors=true;
                }
            }

            return !errors;
        }

        /// <summary>
        /// Limits the output to the given size.  0 disables the limit.
        /// </summary>
        public int OutputLimit
        {
            get { return outputBox.LengthLimit; }
            set
            {
                foreach (MenuItem item in ViewOuputLimit.MenuItems)
                {
                    item.Checked = (value == (int)item.Tag);
                }
                outputBox.LengthLimit = value;
            }
        }

        #region Menu Options and Events

        private void Tabs_Rearranged(TabControl tc)
        {
            StoreUsersTabArrangement();
        }

        private void MenuChoice_File_Exit(object sender, EventArgs args)
        {
            Close();
        }

        private void MenuChoice_File_LoadSuite(object sender, EventArgs args)
        {
            string fname = GuiCommon.ChooseFile(false, "Test Suites or Plugins (*.dll)|*.dll");
            if (fname != null)
            {
                LoadModule(fname);
            }
        }

        private void MenuChoice_MRU_ItemClick(object sender, EventArgs args)
        {
            string fname = ((MenuItem)(sender)).Text;
            if (!String.IsNullOrEmpty(fname))
                LoadModule(fname);
        }

        private void MenuChoice_File_ReloadSuites(object sender, EventArgs args)
        {
            CoreGlobal.CallReloadAllTestTrees();
        }

        private void MenuChoice_File_AttachDebugger(object sender, EventArgs args)
        {
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                System.Diagnostics.Debugger.Launch();
            }
        }

        private void MenuChoice_File_Preferences(object sender, EventArgs e)
        {
            Preferences.ShowPreferences();
        }

        private void MenuChoice_Output_ChangeFilter(object sender, EventArgs args)
        {
            MenuItem mitem=(MenuItem)sender;
            if (mitem==ViewFilterAll)
            {
                ViewFilterDebug.Checked=true;
                ViewFilterInfo.Checked=true;
                ViewFilterWarn.Checked=true;
                ViewFilterError.Checked=true;
                ViewFilterFatal.Checked=true;
                ViewFilterSuccess.Checked=true;
            }
            else if (mitem==ViewFilterNone)
            {
                ViewFilterDebug.Checked=false;
                ViewFilterInfo.Checked=false;
                ViewFilterWarn.Checked=false;
                ViewFilterError.Checked=false;
                ViewFilterFatal.Checked=false;
                ViewFilterSuccess.Checked=false;
            }
            else //individual choice
            {
                if (sender!=null)
                {
                    mitem.Checked=!mitem.Checked;
                }
            }

            //rebuild Report filter
            uint currentFilter=0;
            currentFilter|=(!ViewFilterDebug.Checked?  0:Report.DEBUG);
            currentFilter|=(!ViewFilterInfo.Checked?   0:Report.INFO);
            currentFilter|=(!ViewFilterWarn.Checked?   0:Report.WARN);
            currentFilter|=(!ViewFilterError.Checked?  0:Report.ERROR);
            currentFilter|=(!ViewFilterFatal.Checked?  0:Report.FATAL);
            currentFilter|=(!ViewFilterSuccess.Checked?0:Report.SUCCESS);

            Report.GetRoot().SetLevelFilter(currentFilter);
        }

        private void MenuChoice_Output_ClearOutput(object sender, EventArgs args)
        {
            outputBox.Text="";
        }

        private void MenuChoice_Output_Limit(object sender, EventArgs args)
        {
            MenuItem mi = (MenuItem)sender;
            OutputLimit = (int)mi.Tag;
        }

        private void MenuChoice_Output_LogToFile(object sender, EventArgs args)
        {
            //toggle menu
            bool enabled=!((MenuItem)sender).Checked;

            try
            {
                this.LogToFile = ((MenuItem)sender).Checked = enabled;
            }
            catch (Exception e)
            {
                ro.Error("Exception adding file report destination: " + e);
                ((MenuItem)sender).Checked = false;
            }
        }

        private void Form_Shown(object sender, EventArgs e)
        {
            if (isFirstShown)
            {
                isFirstShown = false;

                XmlNode groupNode = XmlUtil.GetGroupNode(Settings.SelectSingleNode("STFGui"), "BaseGui");

                Width = XmlUtil.GetChildNodeValue(groupNode, "Width", 800);
                Height = XmlUtil.GetChildNodeValue(groupNode, "Height", 600);
                Left = XmlUtil.GetChildNodeValue(groupNode, "LeftPos", 50);
                Top = XmlUtil.GetChildNodeValue(groupNode, "TopPos", 50);
                if (!SystemInformation.VirtualScreen.IntersectsWith(this.Bounds))
                {
                    Left = 50;
                    Top = 50;
                }

                if (XmlUtil.GetChildNodeValue(groupNode, "IsMaxxed", false))
                {
                    WindowState = FormWindowState.Maximized;
                }

                Plugins.NotifyGuiShown();
            }
        }

        //event handler for a requets to close the form
        private void Form_Closing(object sender, FormClosingEventArgs e)
        {
            //if we haven't kicked off the close worker thread, do that.
            if (!isClosing)
            {
                isClosing=true;
                ThreadMaker.CreateThread(ThreadProcShutdown).Start();
            }

            //if we don't want to close yet, cancel it
            if (!allowClose)
            {
                e.Cancel=true;
                return;
            }

            //save our settings
            XmlNode groupNode=Settings.DocumentElement.SelectSingleNode("BaseGui");

            if (Height>50 && Width>50 && WindowState==FormWindowState.Normal) //don't save the form size if the form is max'd or min'd
            {
                XmlUtil.SetChildNodeValue(groupNode, "Width", Width);
                XmlUtil.SetChildNodeValue(groupNode, "Height", Height);
                XmlUtil.SetChildNodeValue(groupNode, "LeftPos", Left);
                XmlUtil.SetChildNodeValue(groupNode, "TopPos", Top);
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", false);
            }
            else if (WindowState==FormWindowState.Maximized)
            {
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", true);
            }

            if (splitTabsAndOutput.Height>50)
            {
                XmlUtil.SetChildNodeValue(groupNode, "SplitterHeight", splitTabsAndOutput.Height); //base bar off the control size not the form size
                XmlUtil.SetChildNodeValue(groupNode, "SplitterBar", (splitTabsAndOutput.SplitterDistance+0.5f)/splitTabsAndOutput.Height);
            }

            StoreUsersTabArrangement();
            if (userPrefferedTabOrder.Count>0)
            {
                XmlNode orderGroupNode=XmlUtil.GetGroupNode(groupNode, "TabOrder");
                orderGroupNode.RemoveAll();
                foreach (string s in userPrefferedTabOrder)
                {
                    XmlNode n=Settings.CreateNode(XmlNodeType.Element, "TabName", "");
                    n.InnerXml=s;
                    orderGroupNode.AppendChild(n);
                }
            }

            if (Tabs.SelectedTab!=null)
            {
                XmlUtil.SetChildNodeValue(groupNode, "OpenTab", Tabs.SelectedTab.Text);
            }

            XmlUtil.SetChildNodeValue(groupNode, "OutputLogToFile", fileOutputDest!=null);

            XmlUtil.SetChildNodeValue(groupNode, "MRUFileList", MRUFileList.GetCSVString());

            try
            {
                Settings.Save("STFGui.xml");
            }
            catch (System.Exception exception)
            {
                ro.Fatal("Exception trying to save STFGui.xml:\n"+exception);
            }
        }

        #endregion //Menu Options and Events

        //This handles shutting down all the gui components on it's own thread.  We won't actually close until it says to.
        private void ThreadProcShutdown()
        {
            //shut down plugin handler
            Plugins.NotifyGuiClosing();

            //destroy all our nodes
            foreach (TestNode n in SuiteRoots)
            {
                try
                {
                    n.Dispose();
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception trying to dispose TestNode "+n.FullName+": "+e);
                }
            }

            //now it's ok to close
            allowClose=true;
            this.Invoke(new InvokeCode(delegate
            {
                //remove our output box from outputs
                Report.GetRoot().RemoveReportDestination(outputBox);
                outputBox.IgnoreOutput=true;
                outputBox.Hide();
                outputBox.Dispose();

                //now poof us
                Close();
            }));
        }

        //Rebuilds the title bar text
        private void UpdateTitlebarText()
        {
            Text="STFGui";
            if (titlebarAssemblyNames.Count>0)
            {
                Text+=" - ";
                bool first=true;
                foreach (string asmName in titlebarAssemblyNames)
                {
                    if (!first)
                    {
                        Text+=", ";
                    }
                    Text+=asmName;
                    first=false;
                }
            }
        }

        /// <summary>
        /// Loads tests and plugins from a file that contains an assembly (usually .dll)
        /// Returns true only if something was loaded and everything in the assembly was loaded successfully, or if that assembly was already loaded.
        /// </summary>
        public bool LoadModule(string fname)
        {
            try
            {
                MRUFileList.AddItem(fname);
            }
            catch (Exception ex)
            {
                ro.Warn("Exception while trying to add an item to the recently used file list. Does not block functionality but probably a bug.");
                ro.Warn(ex.Message);
            }

            //load the assembly
            bool ok=true;
            bool loadedAnything=false;
            Assembly asm;
            try
            {
                asm=AssemblyUtils.LoadAssemblyUsingDefaultMethod(fname);

                //if it's already loaded, don't load it again
                foreach (string loadedName in LoadedModules)
                {
                    if (asm.FullName==loadedName)
                    {
                        ro.Debug(fname+" is already loaded.");
                        return true;
                    }
                }

                ro.Debug("Opened "+fname+" version "+asm.GetName().Version);
            }
            catch (Exception e)
            {
                ro.Fatal("Exception loading assembly "+fname+": "+e);
                return false;
            }

            //notify that we are about to load it
            Plugins.NotifyModuleLoading(fname);

            //load tests from it
            try
            {
                TestNode suite=TestNode.GenerateNodeTree(fname);
                if (suite.ChildrenCount==0)
                {
                    ro.Info("No TestNodes found in: "+fname);
                }
                else
                {
                    loadedAnything=true;
                    ro.Debug("TestNodes loaded successfully from: "+fname);

                    titlebarAssemblyNames.Add(asm.GetName().Name); //add to list to show in title bar
                    UpdateTitlebarText();
                }
            }
            catch (Exception e)
            {
                ro.Fatal("Exception trying to load nodes from "+fname+": "+e);
                ok=false;
            }

            //load plugins from it
            try
            {
                bool foundPlugs=Plugins.LoadAllPluginsInAssembly(asm);
                loadedAnything=loadedAnything||foundPlugs;
            }
            catch (Exception e)
            {
                ro.Fatal("Exception trying to load plugins from "+fname+": "+e);
                ok=false;
            }

            RearrangeTabsForUser();

            //
            LoadedModules.AddLast(asm.FullName);
            LoadedModuleFiles.AddLast(fname);
            return ok && loadedAnything;
        }

        private void SuiteLoaded(TestNode root)
        {
            SuiteRoots.AddLast(root);
            Plugins.NotifySuiteLoaded(root);
        }

        private void SuiteUnloaded(TestNode root)
        {
            SuiteRoots.Remove(root);
            Plugins.NotifySuiteUnloading(root);
        }

        private void ReloadSuites()
        {
            //unload old
            ro.Debug("Unloading suites...");
            while (SuiteRoots.Count!=0)
            {
                CoreGlobal.CallTestNodeTreeUnload(SuiteRoots.Last.Value);
            }

            //search all modules for nodes again
            ro.Debug("Reloading suites...");
            foreach (string fname in LoadedModuleFiles)
            {
                try
                {
                    TestNode suite=TestNode.GenerateNodeTree(fname);
                    if (suite.ChildrenCount==0)
                    {
                        ro.Info("No TestNode(s) found in: "+fname);
                    }
                    else
                    {
                        ro.Debug("TestNodes loaded successfully from: "+fname);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception trying to load nodes from "+fname+": "+e);
                }
            }
        }

        //rearranges the tabs to match the user's preferance
        private void RearrangeTabsForUser()
        {
            //current
            TabPage curTab=Tabs.SelectedTab;
            LinkedList<TabPage> currentPages=new LinkedList<TabPage>();
            foreach (TabPage p in Tabs.TabPages)
            {
                currentPages.AddLast(p);
            }

            //wipe old and rebuild as they like
            Tabs.TabPages.Clear();
            foreach (string s in userPrefferedTabOrder)
            {
                foreach (TabPage p in currentPages)
                {
                    if (p.Text==s)
                    {
                        Tabs.TabPages.Add(p);
                        currentPages.Remove(p);
                        break;
                    }
                }
            }

            //add extras to end
            foreach (TabPage p in currentPages)
            {
                Tabs.TabPages.Add(p);
            }

            Tabs.SelectedTab=curTab;
        }

        //saves the current tab arrangement as the users's preferance
        private void StoreUsersTabArrangement()
        {
            userPrefferedTabOrder.Clear();
            foreach (TabPage p in Tabs.TabPages)
            {
                userPrefferedTabOrder.Add(p.Text);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\App\Gui.cs ===
using System;
using System.Reflection;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace STFGui
{
    /// <summary>
    /// The main gui form that holds all other forms
    /// </summary>
    public class STFGuiForm: Form
    {
        //Public components
        public RearrangeableTabControl Tabs;
        public GuiPluginHandler Plugins;
        public LinkedList<TestNode> SuiteRoots=new LinkedList<TestNode>();
        public LinkedList<string> LoadedModules=new LinkedList<string>();
        public LinkedList<string> LoadedModuleFiles=new LinkedList<string>();
        public XmlDocument Settings;

        //Internal components
        private SplitContainer splitTabsAndOutput;
        private StfTextBox outputBox;

        MRUList MRUFileList;
        MenuItem ViewFilterDebug;
        MenuItem ViewFilterInfo;
        MenuItem ViewFilterWarn;
        MenuItem ViewFilterError;
        MenuItem ViewFilterFatal;
        MenuItem ViewFilterSuccess;
        MenuItem ViewFilterAll;
        MenuItem ViewFilterNone;
        MenuItem ViewOuputLimit;
        MenuItem LogOutputToFile;

        bool allowClose = false;
        bool isClosing = false;
        bool isFirstShown = true;
        bool logToFile = false;

        FileReportDestination fileOutputDest=null;

        public delegate void InvokeCode();
        static Report ro=new Report("Gui");

        List<string> userPrefferedTabOrder=new List<string>();
        List<string> titlebarAssemblyNames=new List<string>();

        public bool LogToFile
        {
            get
            {
                return this.logToFile; 
            }

            set
            {
                lock (this)
                {
                    if (this.logToFile == value)
                    {
                        return;
                    }

                    this.logToFile = value;

                    // Assign checked value to menu item in case this set is not from the event handler.
                    LogOutputToFile.Checked = value;

                    //scrap the old
                    if (fileOutputDest != null)
                    {
                        Report.GetRoot().RemoveReportDestination(fileOutputDest);
                        fileOutputDest.Close();
                        fileOutputDest = null;
                    }

                    if (this.logToFile)
                    {
                        fileOutputDest = new FileReportDestination("FuncOutput", "Log", System.DateTime.Now);
                        Report.GetRoot().AddReportDestination(fileOutputDest);
                    }
                }
            }
        }


        //ctor
        public STFGuiForm()
        {
            // This should prevent those totally crappy no info crashes
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);

            //load settings from file
            Settings=new XmlDocument();
            try
            {
                Settings.Load("STFGui.xml");
            }
            catch
            {
                //it's ok if it fails, it's probably because it doesn't exist, so we will use defaults.
            }

            //get or create our main settings node
            XmlNode mainNode=Settings.SelectSingleNode("STFGui");
            if (mainNode==null)
            {
                mainNode=Settings.CreateNode(XmlNodeType.Element, "STFGui", "");
                Settings.AppendChild(mainNode);
            }

            XmlNode groupNode=XmlUtil.GetGroupNode(mainNode, "BaseGui");

            //set up us and our events
            Text="STFGui";
            FormClosing+=Form_Closing;
            Shown+=Form_Shown;
            CoreGlobal.TestNodeTreeLoaded+=SuiteLoaded;
            CoreGlobal.TestNodeTreeUnloaded+=SuiteUnloaded;
            CoreGlobal.ReloadAllTestTrees+=ReloadSuites;

            //set up the main menu
            Menu=new MainMenu();

            //set up the file menu
            MenuItem menuFile=new MenuItem();
            menuFile.Text="File";
            this.Menu.MenuItems.Add(menuFile);

            MenuItem menuFileLoadSuite=new MenuItem();
            menuFileLoadSuite.Text="Load Suite or Plugin";
            menuFileLoadSuite.Click+=MenuChoice_File_LoadSuite;
            menuFileLoadSuite.Shortcut = Shortcut.CtrlO;
            menuFile.MenuItems.Add(menuFileLoadSuite);

            MenuItem menuFileReloadSuites=new MenuItem();
            menuFileReloadSuites.Text="Reload Suites";
            menuFileReloadSuites.Click+=MenuChoice_File_ReloadSuites;
            menuFileReloadSuites.Shortcut = Shortcut.CtrlF5;
            menuFile.MenuItems.Add(menuFileReloadSuites);

            menuFile.MenuItems.Add(new MenuItem("-"));

            MenuItem menuFileAttachDebugger = new MenuItem();
            menuFileAttachDebugger.Text = "Attach Debugger...";
            menuFileAttachDebugger.Click += MenuChoice_File_AttachDebugger;
            menuFileAttachDebugger.Shortcut = Shortcut.CtrlK;
            menuFile.MenuItems.Add(menuFileAttachDebugger);

            MenuItem menuFilePreferences = new MenuItem();
            menuFilePreferences.Text = "Preferences...";
            menuFilePreferences.Click += MenuChoice_File_Preferences;
            menuFilePreferences.Shortcut = Shortcut.CtrlShiftP;
            menuFile.MenuItems.Add(menuFilePreferences);

            menuFile.MenuItems.Add(new MenuItem("-"));

            //MRU File list.
            string paths = XmlUtil.GetChildNodeValue(groupNode, "MRUFileList", String.Empty);
            MRUFileList = new MRUList("Recently Loaded Suites/Plugins");
            MRUFileList.ClickChild += MenuChoice_MRU_ItemClick;
            MRUFileList.LoadCSVString(paths);
            menuFile.MenuItems.Add(MRUFileList);

            menuFile.MenuItems.Add(new MenuItem("-"));

            MenuItem menuFileExit=new MenuItem();
            menuFileExit.Text="Exit";
            menuFileExit.Click+=MenuChoice_File_Exit;
            menuFile.MenuItems.Add(menuFileExit);

            //splitter between the tab-specific area and the output box area
            splitTabsAndOutput=new SplitContainer();
            splitTabsAndOutput.Orientation=Orientation.Horizontal;
            splitTabsAndOutput.Size=new System.Drawing.Size(Width, XmlUtil.GetChildNodeValue(groupNode, "SplitterHeight", 600));
            splitTabsAndOutput.Dock=DockStyle.Fill;
            ++splitTabsAndOutput.SplitterWidth;
            this.Controls.Add(splitTabsAndOutput);
            splitTabsAndOutput.SplitterDistance=(int)(splitTabsAndOutput.Height*XmlUtil.GetChildNodeValue(groupNode, "SplitterBar", 0.5f));

            //the output box
            outputBox=new StfTextBox();
            outputBox.Dock=DockStyle.Fill;

            splitTabsAndOutput.Panel2.Controls.Add(outputBox);

            try
            {
                splitTabsAndOutput.Panel2.GetType().GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(splitTabsAndOutput.Panel2, true, null);
            }
            catch (Exception e)
            {
                ro.Warn("Error occured while trying to double buffer the output box:\n" + e.ToString());
            }

            //the tab list
            Tabs=new RearrangeableTabControl();
            Tabs.Dock=DockStyle.Fill;
            splitTabsAndOutput.Panel1.Controls.Add(Tabs);
            Tabs.UserRearrangedPages+=Tabs_Rearranged;

            //set up the view menu
            MenuItem menuView=new MenuItem();
            menuView.Text="Output";
            Menu.MenuItems.Add(menuView);

            MenuItem menuClearOutput=new MenuItem("Clear", MenuChoice_Output_ClearOutput);
            menuView.MenuItems.Add(menuClearOutput);

            ViewOuputLimit = new MenuItem("Limit Output");
            MenuItem tempLimitItem = new MenuItem("No Limit", MenuChoice_Output_Limit);
            tempLimitItem.Checked = true;
            tempLimitItem.Tag = 0;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("1K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 1000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("10K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 10000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("100K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 100000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("1M", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 1000000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("10M", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 10000000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            menuView.MenuItems.Add(ViewOuputLimit);

            MenuItem menuDiv=new MenuItem();
            menuDiv.Text="-";
            menuView.MenuItems.Add(menuDiv);

            ViewFilterAll=new MenuItem("Enable ALL",MenuChoice_Output_ChangeFilter);
            menuView.MenuItems.Add(ViewFilterAll);
            ViewFilterNone=new MenuItem("Enable NONE",MenuChoice_Output_ChangeFilter);
            menuView.MenuItems.Add(ViewFilterNone);
            ViewFilterDebug=new MenuItem("Debug",MenuChoice_Output_ChangeFilter);
            ViewFilterDebug.Checked=true;
            menuView.MenuItems.Add(ViewFilterDebug);
            ViewFilterInfo=new MenuItem("Info",MenuChoice_Output_ChangeFilter);
            ViewFilterInfo.Checked=true;
            menuView.MenuItems.Add(ViewFilterInfo);
            ViewFilterWarn=new MenuItem("Warn",MenuChoice_Output_ChangeFilter);
            ViewFilterWarn.Checked=true;
            menuView.MenuItems.Add(ViewFilterWarn);
            ViewFilterError=new MenuItem("Error",MenuChoice_Output_ChangeFilter);
            ViewFilterError.Checked=true;
            menuView.MenuItems.Add(ViewFilterError);
            ViewFilterFatal=new MenuItem("Fatal",MenuChoice_Output_ChangeFilter);
            ViewFilterFatal.Checked=true;
            menuView.MenuItems.Add(ViewFilterFatal);
            ViewFilterSuccess=new MenuItem("Success",MenuChoice_Output_ChangeFilter);
            ViewFilterSuccess.Checked=true;
            menuView.MenuItems.Add(ViewFilterSuccess);

            menuDiv=new MenuItem();
            menuDiv.Text="-";
            menuView.MenuItems.Add(menuDiv);

            MenuItem menuViewLogToFile=new MenuItem("Log To File", MenuChoice_Output_LogToFile);
            menuView.MenuItems.Add(menuViewLogToFile);
            menuViewLogToFile.Checked=!XmlUtil.GetChildNodeValue(groupNode, "OutputLogToFile", logToFile);
            MenuChoice_Output_LogToFile(menuViewLogToFile, null); //this toggles it
            LogOutputToFile = menuViewLogToFile;
        }

        //app crash handler
        void CurrentDomain_UnhandledException (object sender, UnhandledExceptionEventArgs e)
        {
            System.Text.StringBuilder builder = new System.Text.StringBuilder();

            // time
            builder.Append("At ");
            builder.AppendLine(DateTime.Now.ToString());

            // termination message
            if (e.IsTerminating)
            {
                builder.AppendLine("An unhandled exception in a thread is causing STFGui to terminate, please investigate.");
            }
            else
            {
                builder.AppendLine("An unhandled exception in a thread has caused this message, please investigate.");
                builder.AppendLine("STFGui SHOULD NOT be terminating.");
            }
            builder.AppendLine();

            // sender info
            AppDomain appdom = sender as AppDomain;
            if (appdom != null)
            {
                builder.Append("AppDomain: ");
                builder.AppendLine(appdom.FriendlyName);
            }
            else
            {
                builder.Append("Sender: ");
                builder.AppendLine(sender.ToString());
            }
            builder.AppendLine();

            // exception info
            Exception exc = e.ExceptionObject as Exception;
            if (exc != null)
            {
                builder.Append(exc.ToString());
            }
            else
            {
                builder.Append("Exception is null, yikes!");
            }

            string message = builder.ToString();

            try
            {
                System.IO.File.AppendAllText(System.IO.Path.GetFullPath(".\\STFGuiCrashInfo.txt"),
                    message + Environment.NewLine + Environment.NewLine);
            }
            catch { }

            try
            {
                MessageBox.Show(message);
            }
            catch { }
        }

        //Should be called after construction to init public members.  Returns flags that indicate the success of handling paramaters
        public MainApp.STFGuiExitCode Init(string []mainAppParameters, string []pluginParameters)
        {
            MainApp.STFGuiExitCode status=MainApp.STFGuiExitCode.OK;

            //hook console output to stf, and stf output up to our output box
            Report.GetRoot().AddReportDestination(outputBox);
            Console.SetError(new TextWriterReportBridge("STDERR"));
            Console.SetOut(new TextWriterReportBridge("STDOUT"));

            //handle parameters to the gui itself
            bool ignoreDefaultPlugins=false;
            if (!HandleCommandlineOptions(mainAppParameters, ref ignoreDefaultPlugins))
            {
                status|=MainApp.STFGuiExitCode.GuiParamError;
            }

            //spit out our version
            ro.Debug(Assembly.GetExecutingAssembly().GetName().Name+" is version "+Assembly.GetExecutingAssembly().GetName().Version);
            ro.Debug("STFCore is version "+CoreGlobal.GetCoreAssembly().GetName().Version);

            //load default plugins
            //TODO: figure out if any plugin parameters had errors and set status for that here
            Plugins=new GuiPluginHandler(this, pluginParameters);
            if (!ignoreDefaultPlugins)
            {
                Plugins.LoadPluginFiles();
            }

            //load tab arrangement
            XmlNode groupNode=Settings.DocumentElement.SelectSingleNode("BaseGui");

            XmlNode tabOrderGroupNode=XmlUtil.GetGroupNode(groupNode, "TabOrder");
            foreach(XmlNode n in tabOrderGroupNode.ChildNodes)
            {
                if (n.Name=="TabName")
                {
                    userPrefferedTabOrder.Add(n.InnerXml);
                }
            }

            string initialTabName=XmlUtil.GetChildNodeValue(groupNode, "OpenTab","Functional");
            ArrangeTabsAndSelectInitialTab(initialTabName);

            return status;
        }

        private void ArrangeTabsAndSelectInitialTab(string initialTabName)
        {
            RearrangeTabsForUser();

            //select the last plugin tab if possible
            foreach (TabPage tp in Tabs.TabPages)
            {
                if (tp.Text==initialTabName)
                {
                    Tabs.SelectTab(tp);
                    break;
                }
            }
        }

        //handles commandline options that are specifically targetted at STFGui itself.  returns false if there were any errors with the parameters
        private bool HandleCommandlineOptions(string []options, ref bool outIgnoreDefaultPlugins)
        {
            bool errors=false;
            foreach (string option in options)
            {
                string lowerOption=option.ToLower();

                try
                {
                    if (lowerOption.StartsWith("-logtofile")) //turn on/off logging to file
                    {
                        LogToFile=true;
                        if (lowerOption.StartsWith("-logtofile:")) //they can also specify true or false for the value
                        {
                            int sepInd=lowerOption.IndexOf(":");
                            string value=lowerOption.Substring(sepInd+1);
                            LogToFile=bool.Parse(value);
                        }
                        ro.Debug("STFGui option: LogToFile="+LogToFile);
                    }
                    else if (lowerOption=="-ignoredefaultplugins") //don't load any default plugins
                    {
                        outIgnoreDefaultPlugins=true;
                        ro.Debug("STFGui option: IgnoreDefaultPlugins="+outIgnoreDefaultPlugins);
                    }
                    else if (lowerOption.StartsWith("-outputfilter:")) //change initial output filter
                    {
                        //break the parameter list down
                        string valueListString=lowerOption.Substring(lowerOption.IndexOf(":")+1);
                        string []values=valueListString.Split(new char[]{','});

                        //turn all off, then only turn on the ones they specified, then refresh it
                        MenuChoice_Output_ChangeFilter(ViewFilterNone, null);

                        foreach (string value in values)
                        {
                            if (value=="debug")        ViewFilterDebug.Checked  =true;
                            else if (value=="info")    ViewFilterInfo.Checked   =true;
                            else if (value=="warn")    ViewFilterWarn.Checked   =true;
                            else if (value=="error")   ViewFilterError.Checked  =true;
                            else if (value=="fatal")   ViewFilterFatal.Checked  =true;
                            else if (value=="success") ViewFilterSuccess.Checked=true;
                            else
                            {
                                //no output is enabled now, so trying to give a text message here is fruitless
                                errors=true;
                            }
                        }

                        MenuChoice_Output_ChangeFilter(null, null);
                    }
                    else if (lowerOption=="help" || lowerOption=="--help" || lowerOption=="-help" || lowerOption=="-?" || lowerOption=="-h") //h[r]elp!
                    {
                        ro.Info("STFGui Commandline Options: STFGui.exe [Module(s).dll] [Options]");
                        ro.Info("Modules are DLL files should contain either test suite(s), or plugin(s).");
                        ro.Info("Options are:");
                        ro.Info(" -LogToFile[:value]                  Turn on or off file logging.  value may be: true or false");
                        ro.Info(" -IgnoreDefaultPlugins               Do not automatically load plugins listed in STFGui.xml");
                        ro.Info(" -OutputFilter:value0[,value1,etc]   Sets the initial output filter.  values may any of: Debug, Info, Warn, Error, Fatal, Success");
                        ro.Info(" -PlugParam:PluginClass:value        Passes a parameter to a specific plugin");
                        // Putting this here, but handled as early as possible in Main.cs
                        ro.Info(" -BreakOnStart                       Breaks into the debugger at startup");
                    }
                    else //woops
                    {
                        ro.Warn("Unknown STFGui commandline parameter: "+option);
                        errors=true;
                    }
                }
                catch (Exception e) //very woops
                {
                    ro.Fatal("Exception handling commandline parameter for STFGui.\nParameter was: "+option+"\nException was: "+e);
                    errors=true;
                }
            }

            return !errors;
        }

        /// <summary>
        /// Limits the output to the given size.  0 disables the limit.
        /// </summary>
        public int OutputLimit
        {
            get { return outputBox.LengthLimit; }
            set
            {
                foreach (MenuItem item in ViewOuputLimit.MenuItems)
                {
                    item.Checked = (value == (int)item.Tag);
                }
                outputBox.LengthLimit = value;
            }
        }

        #region Menu Options and Events

        private void Tabs_Rearranged(TabControl tc)
        {
            StoreUsersTabArrangement();
        }

        private void MenuChoice_File_Exit(object sender, EventArgs args)
        {
            Close();
        }

        private void MenuChoice_File_LoadSuite(object sender, EventArgs args)
        {
            string fname = GuiCommon.ChooseFile(false, "Test Suites or Plugins (*.dll)|*.dll");
            if (fname != null)
            {
                LoadModule(fname);
            }
        }

        private void MenuChoice_MRU_ItemClick(object sender, EventArgs args)
        {
            string fname = ((MenuItem)(sender)).Text;
            if (!String.IsNullOrEmpty(fname))
                LoadModule(fname);
        }

        private void MenuChoice_File_ReloadSuites(object sender, EventArgs args)
        {
            CoreGlobal.CallReloadAllTestTrees();
        }

        private void MenuChoice_File_AttachDebugger(object sender, EventArgs args)
        {
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                System.Diagnostics.Debugger.Launch();
            }
        }

        private void MenuChoice_File_Preferences(object sender, EventArgs e)
        {
            Preferences.ShowPreferences();
        }

        private void MenuChoice_Output_ChangeFilter(object sender, EventArgs args)
        {
            MenuItem mitem=(MenuItem)sender;
            if (mitem==ViewFilterAll)
            {
                ViewFilterDebug.Checked=true;
                ViewFilterInfo.Checked=true;
                ViewFilterWarn.Checked=true;
                ViewFilterError.Checked=true;
                ViewFilterFatal.Checked=true;
                ViewFilterSuccess.Checked=true;
            }
            else if (mitem==ViewFilterNone)
            {
                ViewFilterDebug.Checked=false;
                ViewFilterInfo.Checked=false;
                ViewFilterWarn.Checked=false;
                ViewFilterError.Checked=false;
                ViewFilterFatal.Checked=false;
                ViewFilterSuccess.Checked=false;
            }
            else //individual choice
            {
                if (sender!=null)
                {
                    mitem.Checked=!mitem.Checked;
                }
            }

            //rebuild Report filter
            uint currentFilter=0;
            currentFilter|=(!ViewFilterDebug.Checked?  0:Report.DEBUG);
            currentFilter|=(!ViewFilterInfo.Checked?   0:Report.INFO);
            currentFilter|=(!ViewFilterWarn.Checked?   0:Report.WARN);
            currentFilter|=(!ViewFilterError.Checked?  0:Report.ERROR);
            currentFilter|=(!ViewFilterFatal.Checked?  0:Report.FATAL);
            currentFilter|=(!ViewFilterSuccess.Checked?0:Report.SUCCESS);

            Report.GetRoot().SetLevelFilter(currentFilter);
        }

        private void MenuChoice_Output_ClearOutput(object sender, EventArgs args)
        {
            outputBox.Text="";
        }

        private void MenuChoice_Output_Limit(object sender, EventArgs args)
        {
            MenuItem mi = (MenuItem)sender;
            OutputLimit = (int)mi.Tag;
        }

        private void MenuChoice_Output_LogToFile(object sender, EventArgs args)
        {
            //toggle menu
            bool enabled=!((MenuItem)sender).Checked;

            try
            {
                this.LogToFile = ((MenuItem)sender).Checked = enabled;
            }
            catch (Exception e)
            {
                ro.Error("Exception adding file report destination: " + e);
                ((MenuItem)sender).Checked = false;
            }
        }

        private void Form_Shown(object sender, EventArgs e)
        {
            if (isFirstShown)
            {
                isFirstShown = false;

                XmlNode groupNode = XmlUtil.GetGroupNode(Settings.SelectSingleNode("STFGui"), "BaseGui");

                Width = XmlUtil.GetChildNodeValue(groupNode, "Width", 800);
                Height = XmlUtil.GetChildNodeValue(groupNode, "Height", 600);
                Left = XmlUtil.GetChildNodeValue(groupNode, "LeftPos", 50);
                Top = XmlUtil.GetChildNodeValue(groupNode, "TopPos", 50);
                if (!SystemInformation.VirtualScreen.IntersectsWith(this.Bounds))
                {
                    Left = 50;
                    Top = 50;
                }

                if (XmlUtil.GetChildNodeValue(groupNode, "IsMaxxed", false))
                {
                    WindowState = FormWindowState.Maximized;
                }

                Plugins.NotifyGuiShown();
            }
        }

        //event handler for a requets to close the form
        private void Form_Closing(object sender, FormClosingEventArgs e)
        {
            //if we haven't kicked off the close worker thread, do that.
            if (!isClosing)
            {
                isClosing=true;
                ThreadMaker.CreateThread(ThreadProcShutdown).Start();
            }

            //if we don't want to close yet, cancel it
            if (!allowClose)
            {
                e.Cancel=true;
                return;
            }

            //save our settings
            XmlNode groupNode=Settings.DocumentElement.SelectSingleNode("BaseGui");

            if (Height>50 && Width>50 && WindowState==FormWindowState.Normal) //don't save the form size if the form is max'd or min'd
            {
                XmlUtil.SetChildNodeValue(groupNode, "Width", Width);
                XmlUtil.SetChildNodeValue(groupNode, "Height", Height);
                XmlUtil.SetChildNodeValue(groupNode, "LeftPos", Left);
                XmlUtil.SetChildNodeValue(groupNode, "TopPos", Top);
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", false);
            }
            else if (WindowState==FormWindowState.Maximized)
            {
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", true);
            }

            if (splitTabsAndOutput.Height>50)
            {
                XmlUtil.SetChildNodeValue(groupNode, "SplitterHeight", splitTabsAndOutput.Height); //base bar off the control size not the form size
                XmlUtil.SetChildNodeValue(groupNode, "SplitterBar", (splitTabsAndOutput.SplitterDistance+0.5f)/splitTabsAndOutput.Height);
            }

            StoreUsersTabArrangement();
            if (userPrefferedTabOrder.Count>0)
            {
                XmlNode orderGroupNode=XmlUtil.GetGroupNode(groupNode, "TabOrder");
                orderGroupNode.RemoveAll();
                foreach (string s in userPrefferedTabOrder)
                {
                    XmlNode n=Settings.CreateNode(XmlNodeType.Element, "TabName", "");
                    n.InnerXml=s;
                    orderGroupNode.AppendChild(n);
                }
            }

            if (Tabs.SelectedTab!=null)
            {
                XmlUtil.SetChildNodeValue(groupNode, "OpenTab", Tabs.SelectedTab.Text);
            }

            XmlUtil.SetChildNodeValue(groupNode, "OutputLogToFile", fileOutputDest!=null);

            XmlUtil.SetChildNodeValue(groupNode, "MRUFileList", MRUFileList.GetCSVString());

            try
            {
                Settings.Save("STFGui.xml");
            }
            catch (System.Exception exception)
            {
                ro.Fatal("Exception trying to save STFGui.xml:\n"+exception);
            }
        }

        #endregion //Menu Options and Events

        //This handles shutting down all the gui components on it's own thread.  We won't actually close until it says to.
        private void ThreadProcShutdown()
        {
            //shut down plugin handler
            Plugins.NotifyGuiClosing();

            //destroy all our nodes
            foreach (TestNode n in SuiteRoots)
            {
                try
                {
                    n.Dispose();
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception trying to dispose TestNode "+n.FullName+": "+e);
                }
            }

            //now it's ok to close
            allowClose=true;
            this.Invoke(new InvokeCode(delegate
            {
                //remove our output box from outputs
                Report.GetRoot().RemoveReportDestination(outputBox);
                outputBox.IgnoreOutput=true;
                outputBox.Hide();
                outputBox.Dispose();

                //now poof us
                Close();
            }));
        }

        //Rebuilds the title bar text
        private void UpdateTitlebarText()
        {
            Text="STFGui";
            if (titlebarAssemblyNames.Count>0)
            {
                Text+=" - ";
                bool first=true;
                foreach (string asmName in titlebarAssemblyNames)
                {
                    if (!first)
                    {
                        Text+=", ";
                    }
                    Text+=asmName;
                    first=false;
                }
            }
        }

        /// <summary>
        /// Loads tests and plugins from a file that contains an assembly (usually .dll)
        /// Returns true only if something was loaded and everything in the assembly was loaded successfully, or if that assembly was already loaded.
        /// </summary>
        public bool LoadModule(string fname)
        {
            try
            {
                MRUFileList.AddItem(fname);
            }
            catch (Exception ex)
            {
                ro.Warn("Exception while trying to add an item to the recently used file list. Does not block functionality but probably a bug.");
                ro.Warn(ex.Message);
            }

            //load the assembly
            bool ok=true;
            bool loadedAnything=false;
            Assembly asm;
            try
            {
                asm=AssemblyUtils.LoadAssemblyUsingDefaultMethod(fname);

                //if it's already loaded, don't load it again
                foreach (string loadedName in LoadedModules)
                {
                    if (asm.FullName==loadedName)
                    {
                        ro.Debug(fname+" is already loaded.");
                        return true;
                    }
                }

                ro.Debug("Opened "+fname+" version "+asm.GetName().Version);
            }
            catch (Exception e)
            {
                ro.Fatal("Exception loading assembly "+fname+": "+e);
                return false;
            }

            //notify that we are about to load it
            Plugins.NotifyModuleLoading(fname);

            //load tests from it
            try
            {
                TestNode suite=TestNode.GenerateNodeTree(fname);
                if (suite.ChildrenCount==0)
                {
                    ro.Info("No TestNodes found in: "+fname);
                }
                else
                {
                    loadedAnything=true;
                    ro.Debug("TestNodes loaded successfully from: "+fname);

                    titlebarAssemblyNames.Add(asm.GetName().Name); //add to list to show in title bar
                    UpdateTitlebarText();
                }
            }
            catch (Exception e)
            {
                ro.Fatal("Exception trying to load nodes from "+fname+": "+e);
                ok=false;
            }

            //load plugins from it
            try
            {
                bool foundPlugs=Plugins.LoadAllPluginsInAssembly(asm);
                loadedAnything=loadedAnything||foundPlugs;
            }
            catch (Exception e)
            {
                ro.Fatal("Exception trying to load plugins from "+fname+": "+e);
                ok=false;
            }

            RearrangeTabsForUser();

            //
            LoadedModules.AddLast(asm.FullName);
            LoadedModuleFiles.AddLast(fname);
            return ok && loadedAnything;
        }

        private void SuiteLoaded(TestNode root)
        {
            SuiteRoots.AddLast(root);
            Plugins.NotifySuiteLoaded(root);
        }

        private void SuiteUnloaded(TestNode root)
        {
            SuiteRoots.Remove(root);
            Plugins.NotifySuiteUnloading(root);
        }

        private void ReloadSuites()
        {
            //unload old
            ro.Debug("Unloading suites...");
            while (SuiteRoots.Count!=0)
            {
                CoreGlobal.CallTestNodeTreeUnload(SuiteRoots.Last.Value);
            }

            //search all modules for nodes again
            ro.Debug("Reloading suites...");
            foreach (string fname in LoadedModuleFiles)
            {
                try
                {
                    TestNode suite=TestNode.GenerateNodeTree(fname);
                    if (suite.ChildrenCount==0)
                    {
                        ro.Info("No TestNode(s) found in: "+fname);
                    }
                    else
                    {
                        ro.Debug("TestNodes loaded successfully from: "+fname);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception trying to load nodes from "+fname+": "+e);
                }
            }
        }

        //rearranges the tabs to match the user's preferance
        private void RearrangeTabsForUser()
        {
            //current
            TabPage curTab=Tabs.SelectedTab;
            LinkedList<TabPage> currentPages=new LinkedList<TabPage>();
            foreach (TabPage p in Tabs.TabPages)
            {
                currentPages.AddLast(p);
            }

            //wipe old and rebuild as they like
            Tabs.TabPages.Clear();
            foreach (string s in userPrefferedTabOrder)
            {
                foreach (TabPage p in currentPages)
                {
                    if (p.Text==s)
                    {
                        Tabs.TabPages.Add(p);
                        currentPages.Remove(p);
                        break;
                    }
                }
            }

            //add extras to end
            foreach (TabPage p in currentPages)
            {
                Tabs.TabPages.Add(p);
            }

            Tabs.SelectedTab=curTab;
        }

        //saves the current tab arrangement as the users's preferance
        private void StoreUsersTabArrangement()
        {
            userPrefferedTabOrder.Clear();
            foreach (TabPage p in Tabs.TabPages)
            {
                userPrefferedTabOrder.Add(p.Text);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\App\Preferences.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using STFGui.Plugins;

namespace STFGui
{
    public partial class Preferences : Form
    {
        private static object initLock = new object();

        private static Preferences current;
        public static Preferences Current
        {
            get
            {
                if (current == null || current.IsDisposed)
                {
                    lock (initLock)
                    {
                        if (current == null || current.IsDisposed)
                        {
                            current = new Preferences();
                        }
                    }
                }

                return current;
            }
        }

        public static void ShowPreferences()
        {
            Current.ShowPreferencesWindow();
        }

        public List<IPluginPreferences> PreferencePlugins = new List<IPluginPreferences>();

        public Preferences()
        {
            this.InitializeComponent();

            this.FormClosing += new FormClosingEventHandler(Preferences_FormClosing);
        }

        void Preferences_FormClosing(object sender, FormClosingEventArgs e)
        {
            // Prevent the user from closing the window, just hide it.
            if (e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                Form f = sender as Form;
                f.Hide();
            }
        }

        private void applyButton_Click(object sender, EventArgs e)
        {
            this.ApplyPreferences();
            this.Hide();
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            this.InitializePreferenceTabs();
            this.Hide();
        }

        public void AddTabForObject(String name, ICloneable preferencesObject)
        {
            PreferencesTab tab = null;
            if (this.preferencesTabControl.TabPages.ContainsKey(name))
            {
                tab = this.preferencesTabControl.TabPages[name] as PreferencesTab;
                tab.PreferencesObject = preferencesObject;
            }
            else
            {
                tab = new PreferencesTab(name, preferencesObject);
                this.preferencesTabControl.TabPages.Add(tab);

            }
        }


        private void ShowPreferencesWindow()
        {
            InitializePreferenceTabs();
            Show();
            Activate();
        }

        private void InitializePreferenceTabs()
        {
            foreach (IPluginPreferences prefPlugin in PreferencePlugins)
            {
                AddTabForObject(
                    prefPlugin.GetType().Name,
                    prefPlugin.PluginPreferences.Clone() as ICloneable);
            }
        }

        private void ApplyPreferences()
        {
            // Get all the preference objects and save them
            foreach (IPluginPreferences prefPlugin in PreferencePlugins)
            {
                String prefName = prefPlugin.GetType().Name;
                PreferencesTab tab = preferencesTabControl.TabPages[prefName] as PreferencesTab;

                prefPlugin.PluginPreferences = tab.PreferencesObject;
            }
        }
    }

    public class PreferencesTab : TabPage
    {
        private PropertyGrid tabPropertyGrid;

        public ICloneable PreferencesObject
        {
            get { return tabPropertyGrid.SelectedObject as ICloneable; }
            set { tabPropertyGrid.SelectedObject = value; }
        }

        public PreferencesTab()
        {
            tabPropertyGrid = new PropertyGrid();

            this.Padding = new Padding(5);
            this.Controls.Add(tabPropertyGrid);

            this.tabPropertyGrid.Dock = DockStyle.Fill;
        }

        public PreferencesTab(String preferencesName, Object preferencesObject)
            : this()
        {
            this.Text = preferencesObject.GetType().Name;
            this.Name = preferencesName;
            this.tabPropertyGrid.SelectedObject = preferencesObject;
        }

        public PreferencesTab(Object preferencesObject)
            : this(preferencesObject.GetType().Name, preferencesObject)
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\GuiCommon\StfInputBox.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;

namespace STFGui
{
    public class FormInputBox : Form
    {

        public string data;

        public FormInputBox()
        {
            InitializeComponent();
            this.Close();
        }

        public FormInputBox(string titleText)
        {
            InitializeComponent();
            this.Text = titleText;
        }

        private void FormInputBox_Load(object sender, EventArgs e)
        {
            this.tbInput.Focus();
        }

        private void btnOk_Click(object sender, EventArgs e)
        {
            data = tbInput.Text;
            DialogResult = DialogResult.OK;
            this.Close();
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            this.Close();
        }

#region designer
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.tbInput = new System.Windows.Forms.TextBox();
            this.btnOk = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // tbInput
            // 
            this.tbInput.Location = new System.Drawing.Point(12, 12);
            this.tbInput.MaxLength = 500;
            this.tbInput.Name = "tbInput";
            this.tbInput.Size = new System.Drawing.Size(369, 20);
            this.tbInput.TabIndex = 0;
            // 
            // btnOk
            // 
            this.btnOk.Location = new System.Drawing.Point(44, 38);
            this.btnOk.Name = "btnOk";
            this.btnOk.Size = new System.Drawing.Size(75, 23);
            this.btnOk.TabIndex = 1;
            this.btnOk.Text = "OK";
            this.btnOk.UseVisualStyleBackColor = true;
            this.btnOk.Click += new System.EventHandler(this.btnOk_Click);
            // 
            // btnCancel
            // 
            this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.btnCancel.Location = new System.Drawing.Point(293, 38);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(75, 23);
            this.btnCancel.TabIndex = 2;
            this.btnCancel.Text = "Cancel";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // FormInputBox
            // 
            this.AcceptButton = this.btnOk;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.btnCancel;
            this.ClientSize = new System.Drawing.Size(395, 67);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnOk);
            this.Controls.Add(this.tbInput);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "FormInputBox";
            this.Text = "Enter your data";
            this.Load += new System.EventHandler(this.FormInputBox_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.TextBox tbInput;
        private System.Windows.Forms.Button btnOk;
        private System.Windows.Forms.Button btnCancel;
#endregion designer


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\GuiCommon\StfMRUList.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;

namespace STFGui
{
    /// <summary>
    /// Most recently used list of menu items. Click on something, and it goes back up to the top.
    /// </summary>
    public class MRUList : MenuItem
    {        
        int maxItems = 6;
        List<string> items;
        EventHandler clickChild;

        public EventHandler ClickChild
        {
            get
            {
                return clickChild;
            }
            set
            {
                clickChild = value;
            }
        }

        /// <summary>
        /// Constructor. Sets up click eventhandlers and initializes the items list. 
        /// </summary>
        /// <param name="text"></param>        
        public MRUList(string text)
            : base(text)
        {
            //Set up the BaseOnClick method which shuffles items around on every click.            
            this.clickChild = new EventHandler(BaseOnClick);                        
            items = new List<string>();
        }        

        public string[] Items
        {
            get
            {
                return items.ToArray();
            }
        }        

        //Gets called every time something changes. Meant to shift items around
        //automatically when clicked. 
        private void BaseOnClick(object sender, EventArgs e)
        {
            AddItem(((MenuItem)sender).Text);
        }       

        /// <summary>
        /// If an item is new, it gets added at the top. If it already exists, 
        /// it gets shifted up to the top. The bottom is trimmed if at max capacity. 
        /// </summary>
        /// <param name="text"></param>
        public void AddItem(string text)
        {
            if (!String.IsNullOrEmpty(text))
            {
                if (!items.Contains(text))
                {
                    if (items.Count >= maxItems)
                        items.RemoveAt(maxItems - 1);

                    items.Insert(0, text);
                }
                else
                {
                    items.RemoveAt(items.IndexOf(text));
                    items.Insert(0, text);
                }
                RefreshMenu();
            }
        }        

        /// <summary>
        /// Reloads the UI elements. 
        /// </summary>
        private void RefreshMenu()
        {
            //Lazy I know
            this.MenuItems.Clear();
            foreach (string s in items)
            {
                MenuItem newItem = new MenuItem(s, clickChild);                
                this.MenuItems.Add(newItem);
            }
        }

        /// <summary>
        /// Just loads a list of items in. Clears before starting.
        /// </summary>
        /// <param name="itemTexts"></param>
        public void LoadList(IEnumerable<string> itemTexts)
        {            
            if (itemTexts != null)
            {
                items.Clear();
                foreach (string s in itemTexts)
                {
                    AddItem(s);
                }
                RefreshMenu();
            }    
   
        }

        //Note - I kinda hate these. Should really do proper serialization. CSV stands for CHAR separated values, not ','!
        #region CSV methods. 
        
        
        const char defaultSeparator = '?';

        /// <summary>
        /// "separator" separated list of items in string form.
        /// </summary>
        /// <param name="separator"></param>
        /// <returns></returns>
        public string GetCSVString(char separator)
        {
            //Grab a local copy
            string[] localItems = items.ToArray();

            string outStr = string.Empty;
            for (int k = 0; k < localItems.Length; k++)
                outStr += separator + localItems[k];

            if (outStr.Length > 0)
                outStr = outStr.Substring(1); //Get rid of the first "?"

            return outStr;
        }

        /// <summary>
        /// Default version of GetCSVString, uses the "?" as a separator since it is not a valid file character.
        /// </summary>
        /// <returns></returns>
        public string GetCSVString()
        {
            return GetCSVString(defaultSeparator);
        }

        /// <summary>
        /// Loads the output of "GetCSVString". Reverses the result since it's a MRU list.
        /// </summary>
        /// <param name="separator"></param>
        /// <param name="str"></param>
        public void LoadCSVString(char separator, string str)
        {
            if (!String.IsNullOrEmpty(str))
            {
                string[] list = str.Split(separator);

                foreach (string s in list)
                {
                    AddItem(s);
                }
                //Reverse since loading in order stacks things up. 
                items.Reverse();

                RefreshMenu();
            }
        }
        /// <summary>
        /// Default version of GetCSVString. 
        /// </summary>
        /// <param name="str"></param>
        public void LoadCSVString(string str)
        {
            LoadCSVString(defaultSeparator, str);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\GuiCommon\StfTextBox.cs ===
using System;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Text;
using System.Collections.Generic;

using ServerTestFramework;

namespace STFGui
{
    public class User32
    {
        // Consts from WinUser.h
        public static readonly uint WM_SETREDRAW=0x000B;
        public static readonly uint EM_REPLACESEL = 0xC2;

        [DllImport("user32.dll")]
        public static extern bool PostMessage(IntPtr hWnd, uint Msg, uint wParam, uint lParam);

        [DllImport("user32.dll")]
        public static extern uint SendMessage(IntPtr hWnd, uint Msg, uint wParam, uint lParam);

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        public static extern uint SendMessage(IntPtr hWnd, uint Msg, uint wParam, string lParam);
    }

    /// <summary>
    /// A rich text box that can accept data from a report object.
    /// </summary>
    public class StfTextBox: RichTextBox, Report.BulkDestination
    {
        public delegate void InvokeCode();

        public bool IgnoreOutput = false;
        public Color DefaultColor = Color.LightGray;
        public Color DebugColor = Color.DarkGray;
        public Color WarnColor = Color.Gold;
        public Color ErrorColor = Color.Red;
        public Color FatalColor = Color.MediumPurple;
        public Color SuccessColor = Color.LightGreen;

        private LinkedList<Report.ReportLine> pendingLines = new LinkedList<Report.ReportLine>();

        /// <summary>
        /// Creates a new StfTextBox and setups some default values such as font and color
        /// </summary>
        public StfTextBox()
        {
            //Setup the box similarly colored to the old stf box
            BackColor=Color.Black;
            ForeColor=Color.LightGray;
            WordWrap=false;
            Font=new Font("Lucida Console", 8.25F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
            ReadOnly=true;
            Enabled=true;
            HideSelection=false;
            ShortcutsEnabled=true;

            //hookup events
            ContextMenu=new ContextMenu();
            ContextMenu.Popup += ContextHandler;
            HandleCreated += OnHandleCreated;
            LinkClicked += new LinkClickedEventHandler(StfTextBox_LinkClicked);
        }

        /// <summary>Backing for LengthLimit.</summary>
        private int _length_limit = 0;

        /// <summary>
        /// The text length should be limited to this value.
        /// However, it is only imposed once the length goes 12.5% beyond the limit and new lines are added.
        /// The value 0 disables the limit.
        /// </summary>
        public int LengthLimit
        {
            get { return _length_limit; }
            set { _length_limit = value; }
        }

        public Color GetLogLevelColor(UInt32 logLevel)
        {
            switch (logLevel)
            {
                case Report.DEBUG:
                    return DebugColor;
                case Report.WARN:
                    return WarnColor;
                case Report.ERROR:
                    return ErrorColor;
                case Report.FATAL:
                    return FatalColor;
                case Report.SUCCESS:
                    return SuccessColor;
                default:
                    return DefaultColor;
            }
        }

        /// <summary>
        /// Add a series of lines to the TextBox.  Must be called from the same thread as this was created
        /// </summary>
        /// <param name="lines">The data to be added to the TextBox</param>
        /// <remarks>.NET richtextbox has a funky way of doing this I don't like.. maybe look into direct rtf sometime.</remarks>
        private void AddLinesToBox(LinkedList<Report.ReportLine> lines)
        {
            int  topLeftChar = GetCharIndexFromPosition(new Point(DisplayRectangle.Left, DisplayRectangle.Top + 1));
            bool atEnd = GetCharIndexFromPosition(new Point(DisplayRectangle.Right, DisplayRectangle.Bottom)) >= Text.Length - 1;
            int selStart = SelectionStart;
            int selLen = SelectionLength;
            int textLength = TextLength;

            // stop updates to avoid flicker when adding lines
            bool pausedRedraw=false;
            if (textLength!=selStart)
            {
                pausedRedraw=true;
                User32.SendMessage(Handle, User32.WM_SETREDRAW, 0, 0);
            }

            try
            {
                int removedLength = 0;

                // limit is on, check it
                if (_length_limit > 0)
                {
                    if (textLength >= _length_limit + (_length_limit >> 3))
                    {
                        SelectionStart = 0;
                        removedLength = textLength - _length_limit;
                        SelectionLength = removedLength + 1;
                        SelectedText=Text.Substring(removedLength, 1);
                    }
                }

                // we will use textLength to track the length so that we don't need to do Text.Length
                textLength -= removedLength;

                foreach (Report.ReportLine line in lines)
                {
                    string lineMessage=line.Message.Replace("\0",""); //strip null terminators from output as they cause the box to cut off everything after it

                    //format the text and decide on the color
                    string formattedText=(textLength>0?"\n":"")+Report.FormatLogLine(line.Date, line.Level, line.Path, lineMessage);

                    Color color=GetLogLevelColor(line.Level);

                    //add it
                    this.SelectionStart=textLength;
                    this.SelectionColor=color;
                    User32.SendMessage(Handle, User32.EM_REPLACESEL, 0, formattedText); //We do this rather than calling AppendText because AppendText has some nasty side effects that bug out colors of already-selected text

                    // continue tracking textLength
                    textLength += formattedText.Length;
                }

                if (!atEnd)
                {
                    SelectionStart = Math.Max(topLeftChar - removedLength, 0);
                    ScrollToCaret();
                }

                if (selLen!=0)
                {
                    SelectionStart = Math.Max(selStart - removedLength, 0);
                    SelectionLength = selLen;
                }

                if (atEnd && removedLength!=0)
                {
                    SelectionStart=textLength;
                }
            }
            finally
            {
                //resume updates to the window
                if (pausedRedraw)
                {
                    User32.SendMessage(Handle, User32.WM_SETREDRAW, 1, 0);
                    Invalidate();
                }
            }
        }

        //Report data input
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            if (IgnoreOutput)
            {
                return;
            }
            else if (!IsHandleCreated)
            {
                lock (pendingLines)
                {
                    pendingLines.AddLast(new Report.ReportLine(level, path, message, testName, date));
                }
            }
            else
            {
                //add it.  this could come from any thread, so we have do mess with an evil invoke
                this.Invoke(new InvokeCode(delegate
                    {
                        LinkedList<Report.ReportLine> one = new LinkedList<Report.ReportLine>();
                        one.AddLast(new Report.ReportLine(level, path, message, testName, date));
                        AddLinesToBox(one);
                    })
                );
            }
        }

        //Report data input
        public void LogBulk(LinkedList<Report.ReportLine> lines)
        {
            if (IgnoreOutput)
            {
                return;
            }
            else if (!IsHandleCreated)
            {
                lock (pendingLines)
                {
                    foreach (Report.ReportLine line in lines)
                    {
                        pendingLines.AddLast(line);
                    }
                }
            }
            else
            {
                //add it.  this could come from any thread, so we have do mess with an evil invoke
                if (!this.IsDisposed)
                {
                    this.Invoke(new InvokeCode(delegate
                        {
                            AddLinesToBox(lines);
                        })
                    );
                }
            }
        }

        #region Events

        private void OnHandleCreated(object sender, EventArgs e)
        {
            lock (pendingLines)
            {
                if (pendingLines.Count != 0)
                {
                    AddLinesToBox(pendingLines);
                    pendingLines.Clear();
                }
            }
        }

        //context menu handler
        private void ContextHandler(object sender, EventArgs e)
        {
            //wipe out old options
            Menu.MenuItemCollection mi=ContextMenu.MenuItems;
            mi.Clear();

            //add the options
            mi.Add("Copy Selected", CtxMenu_CopySelected);
            mi.Add("Copy All", CtxMenu_CopyAll);
        }

        private void CtxMenu_CopyAll(object sender, EventArgs e)
        {
            int prevStart=SelectionStart;
            int prevLen=SelectionLength;
            SelectionStart=0;
            SelectionLength=Text.Length;
            Copy();
            SelectionStart=prevStart;
            SelectionLength=prevLen;
        }

        private void CtxMenu_CopySelected(object sender, EventArgs e)
        {
            Copy();
        }

        void StfTextBox_LinkClicked(object sender, LinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start(System.IO.Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), @"Internet Explorer\iexplore.exe"), e.LinkText);
        }
        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\Plugins\FunctionalRunner\Functional.cs ===
using System;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Serialization;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Utilities;

namespace STFGui.Plugins
{
    /// <summary>
    /// The functional runner gui plugin.
    /// </summary>
    public class FunctionalPlugin: IPluginSetup, IPluginModuleLoadNotification, IPluginGui, Report.Destination, TestEventListener
    {
        // ----- This section contains the public members that anything wanting to extent this plugin may use.

        /// <summary>
        /// Forces or Prevents the option to disable running in parallel from being enabled.
        /// Call with null to remove your override.
        /// </summary>
        public void OverrideNoParallelRunning(IPluginExtension<FunctionalPlugin> caller, Nullable<bool> disableParallel)
        {
            if (disableParallel.HasValue)
            {
                AddOverride(overrideParallel, caller, disableParallel.Value);
            }
            else
            {
                RemoveOverride(overrideParallel, caller);
            }

            UpdateOverrides();
        }

        /// <summary>
        /// Forces or Prevents the option to run in a loop being enabled.
        /// Call with null to remove your override.
        /// </summary>
        public void OverrideLoopedRunning(IPluginExtension<FunctionalPlugin> caller, Nullable<bool> allowLooping)
        {
            if (allowLooping.HasValue)
            {
                AddOverride(overrideLoop, caller, allowLooping.Value);
            }
            else
            {
                RemoveOverride(overrideLoop, caller);
            }

            UpdateOverrides();
        }

        /// <summary>
        /// Forces or Prevents a Dry Run from being enabled.
        /// Call with null to remove your override.
        /// </summary>
        public void OverrideDryRunning(IPluginExtension<FunctionalPlugin> caller, Nullable<bool> allowDryRun)
        {
            if (allowDryRun.HasValue)
            {
                AddOverride(overrideDryRun, caller, allowDryRun.Value);
            }
            else
            {
                RemoveOverride(overrideDryRun, caller);
            }

            UpdateOverrides();
        }

        /// <summary>
        /// The test event listener for all functional running.
        /// You may add your own event listeners to this.
        /// </summary>
        public MultiTestEventListener FunctionalEvents;

        /// <summary>
        /// Returns whether a functional run is currently in progress.
        /// Settings changes will not take effect on runs that are already in-progress.
        /// </summary>
        public bool IsRunning
        {
            get { return isRunning; }
        }

        /// <summary>
        /// Call this to add a check box to the options list.
        /// </summary>
        public CheckBox AddCheckBox(string text, EventHandler checkedChangedEvent, bool initialState, string toolTipText)
        {
            CheckBox newCheck=new CheckBox();
            newCheck.Location=new System.Drawing.Point(3, nextCheckboxOffset);
            newCheck.Size=new System.Drawing.Size(130, 17);
            newCheck.Text=text;
            if (checkedChangedEvent!=null)
            {
                newCheck.CheckedChanged+=checkedChangedEvent;
            }
            newCheck.Checked=initialState;
            if (toolTipText!=null && toolTipText.Length>0)
            {
                new ToolTip().SetToolTip(newCheck, toolTipText);
            }

            nextCheckboxOffset+=20;
            optionsCheckBoxes.AddLast(newCheck);
            ControlsPanel.Controls.Add(newCheck);
            return newCheck;
        }

        /// <summary>
        /// This event is called when a new set of context menu items for a node is being built.
        /// You may add your own items to the contextItemsToShow parameter.
        /// </summary>
        public event BuildContextMenuItemsDelegate BuildNodeContextMenuItemsEvent;
        public delegate void BuildContextMenuItemsDelegate(TestNode node, List<TestNodeContextMenuItem> contextItemsToShow);

        /// <summary>
        /// A context menu item for a test node. Used by BuildNodeContextMenuItemsEvent.
        /// </summary>
        public class TestNodeContextMenuItem
        {
            /// <summary>
            /// The text to show for the item ("-" gives you a divider bar)
            /// </summary>
            public string Text;

            /// <summary>
            /// This event is called if the menu item was chosen by the user.
            /// </summary>
            public event ItemClickDelegate Click;
            public delegate void ItemClickDelegate(TestNodeContextMenuItem sender, TestNode node);

            public TestNodeContextMenuItem() {}
            public TestNodeContextMenuItem(string text)
            {
                Text=text;
            }
            public TestNodeContextMenuItem(string text, ItemClickDelegate cd)
            {
                Text=text;
                Click+=cd;
            }

            //used internally
            internal void InvokeClick(TestNodeContextMenuItem sender, TestNode node)
            {
                Click(sender, node);
            }
        }

        // ----- Internals

        //setting overrides
        private class SettingOverride
        {
            public bool Value;
            public IPluginExtension<FunctionalPlugin> Owner;
        }

        private LinkedList<SettingOverride> overrideParallel=new LinkedList<SettingOverride>();
        private LinkedList<SettingOverride> overrideLoop=new LinkedList<SettingOverride>();
        private LinkedList<SettingOverride> overrideDryRun=new LinkedList<SettingOverride>();

        private bool checkAllForAutoRun = true;

        //gui pieces
        private TabPage tabPage;
        private MenuItem menuItemStart;
        private MenuItem menuItemPause;
        private MenuItem menuItemStop;

        private MenuItem menuItemSaveState;
        private MenuItem menuItemLoadState;
        private MenuItem menuItemLastKnownState;

        private MenuItem menuItemGenerateTrxOnRun;
        private MenuItem menuItemGenerateTrxNow;

        private SplitContainer splitTreeAndFiltering;
        private Panel FilteringPanel;
        private ComboBox comboTagViewOptions;
        private RichTextBox tbTagExpression;
        private Label labFilterCharacterPosition;

        public FuncTreeView TestTree;
        public Panel ControlsPanel;
        public FuncScheduler Scheduler;
        public FunctionalSchedulerSettings SchedulerSettings;

        private VsTestResultTestEventListener vsTestEventListener;

        bool StoreLoglines = true;
        public List<Report.ReportLine> LogLines=new List<Report.ReportLine>();

        XmlNode configNode;
        Button butStart;
        Button butStop;
        private bool isRunning=false;

        LinkedList<CheckBox> optionsCheckBoxes=new LinkedList<CheckBox>();

        Nullable<bool> runLoopedOverride=null;
        CheckBox cbRunLooped;
        Nullable<bool> disableParallelOverride=null;
        CheckBox cbDisableParallel;
        Nullable<bool> doDryRunOverride=null;
        CheckBox cbDoDryRun;
        CheckBox cbSkipPreRun;
        CheckBox cbSkipPostRun;
        CheckBox cbStickyColors;

        int nextCheckboxOffset = 50; //next y loc to place a check box

        LinkedList<TestNode> rootNodes=new LinkedList<TestNode>();
        Report ro=new Report("FuncPlugin");
        Report roExp=new Report("Expression");

        //autorun mode stuff
        enum AutorunState
        {
            None,
            Starting,
            Running
        };
        bool isInAutorunMode=false;
        bool saveAutorunMode=false; //must be set for autorun to save to the xml config
        AutorunState autorunState=AutorunState.None;
        int autorunCountDown=0;
        System.Timers.Timer autorunCountDownTimer;

        //The state of the tag visibility -- this MUST line up with the options added to comboTagVie397
        public enum TagVisibilityStates
        {
            Hide=0,
            Node,
            NodeParents,
            NodeChildren,
            NodeParentsChildren,
            NodeNearestParent
        };

        public TagVisibilityStates TagVisibilityState;

        //
        public delegate void InvokeCode();

        //used by the func tree view
        public void DoBuildNodeContextMenuItems(TestNode n, List<TestNodeContextMenuItem> items)
        {
            if (BuildNodeContextMenuItemsEvent!=null)
            {
                BuildNodeContextMenuItemsEvent(n, items);
            }
        }

        //
        private void AddOverride(LinkedList<SettingOverride> list, IPluginExtension<FunctionalPlugin> owner, bool value)
        {
            SettingOverride so=new SettingOverride();
            so.Value=value;
            so.Owner=owner;
            list.AddLast(so);
        }

        private void RemoveOverride(LinkedList<SettingOverride> list, IPluginExtension<FunctionalPlugin> owner)
        {
            bool changed=true;
            while (changed)
            {
                changed=false;

                foreach (SettingOverride so in list)
                {
                    if (so.Owner==owner)
                    {
                        changed=true;
                        list.Remove(so);
                        break;
                    }
                }
            }
        }

        private void UpdateOverrides()
        {
            bool ok=true;

            if (IsRunning)
            {
                ro.Warn("Override settings changed while a functional run is in progress.  The current run will not be affected by the changes.");
            }

            //update settings
            if (!VerifyOverrideListSanity(overrideParallel, "Parallel Run", out disableParallelOverride))
            {
                ok=false;
            }

            if (!VerifyOverrideListSanity(overrideLoop, "Looped Run", out runLoopedOverride))
            {
                ok=false;
            }

            if (!VerifyOverrideListSanity(overrideDryRun, "Dry Run", out doDryRunOverride))
            {
                ok=false;
            }

            UpdateOverrideControlsState();

            //disable us if something bad happened
            if (ok)
            {
                tabPage.Enabled=true;
                TestTree.Visible=true;
            }
            else
            {
                tabPage.Enabled=false;
                TestTree.Visible=false;
            }
        }

        private bool VerifyOverrideListSanity(LinkedList<SettingOverride> list, string name, out Nullable<bool> value)
        {
            bool badness=false;
            SettingOverride soFirst=null;
            foreach (SettingOverride o in list)
            {
                if (soFirst==null)
                {
                    soFirst=o;
                }
                else
                {
                    if (soFirst.Value!=o.Value) //uh oh
                    {
                        badness=true;
                        ro.Fatal("Conflict over setting override '"+name+"': "+soFirst.Owner.GetType().FullName+" wants value "+soFirst.Value+" but "+o.Owner.GetType().FullName+" wants value "+o.Value);
                    }
                }
            }

            if (badness)
            {
                value=null;
                return false;
            }
            else
            {
                if (soFirst==null)
                {
                    value=null;
                }
                else
                {
                    value=soFirst.Value;
                }
                return true;
            }
        }

        private void UpdateOverrideControlsState()
        {
            if (runLoopedOverride==null)
            {
                cbRunLooped.Enabled=true;
            }
            else
            {
                cbRunLooped.Enabled=false;
                cbRunLooped.Checked=runLoopedOverride.Value;
            }

            if (disableParallelOverride==null)
            {
                cbDisableParallel.Enabled=true;
            }
            else
            {
                cbDisableParallel.Enabled=false;
                cbDisableParallel.Checked=disableParallelOverride.Value;
            }

            if (doDryRunOverride==null)
            {
                cbDoDryRun.Enabled=true;
            }
            else
            {
                cbDoDryRun.Enabled=false;
                cbDoDryRun.Checked=doDryRunOverride.Value;
            }
        }

        //Returns the TabPage to add to the gui.
        public TabPage GetNewTabPage()
        {
            //the tab
            TabPage page=new TabPage();
            tabPage=page;
            page.Text="Functional";

            ToolTip ttip=new ToolTip();

            //add a splitter to divide the controls from the node tree
            SplitContainer splitControlsAndTree=new SplitContainer();
            splitControlsAndTree.Orientation=Orientation.Vertical;
            splitControlsAndTree.Dock=DockStyle.Fill;
            splitControlsAndTree.Location=new System.Drawing.Point(0, 0);
            splitControlsAndTree.Size=new System.Drawing.Size(3000, 3000);
            splitControlsAndTree.Panel1MinSize=130;
            splitControlsAndTree.SplitterDistance=130;
            splitControlsAndTree.IsSplitterFixed=true;
            page.Controls.Add(splitControlsAndTree);

            ControlsPanel=splitControlsAndTree.Panel1;

            //add a splitter to divide the controls from the node tree
            splitTreeAndFiltering=new SplitContainer();
            splitTreeAndFiltering.Orientation=Orientation.Vertical;
            splitTreeAndFiltering.Dock=DockStyle.Fill;
            splitTreeAndFiltering.Location=new System.Drawing.Point(0, 0);
            splitTreeAndFiltering.Size=new System.Drawing.Size(3000, 3000);
            splitTreeAndFiltering.Panel2MinSize=400;
            splitTreeAndFiltering.SplitterDistance=2600;
            splitTreeAndFiltering.IsSplitterFixed=true;
            splitTreeAndFiltering.Panel2Collapsed=XmlUtil.GetChildNodeValue(configNode, "TagFilterPanelCollapsed", true);
            splitTreeAndFiltering.Resize+=delegate(object sender, EventArgs e) {if (splitTreeAndFiltering.Width>400+splitTreeAndFiltering.Panel1MinSize) splitTreeAndFiltering.SplitterDistance=splitTreeAndFiltering.Width-400;};
            splitControlsAndTree.Panel2.Controls.Add(splitTreeAndFiltering);

            FilteringPanel=splitTreeAndFiltering.Panel2;

            //add start and stop buttons
            butStart=new Button();
            butStart.Location=new System.Drawing.Point(4, 4);
            butStart.Size=new System.Drawing.Size(60, 26);
            butStart.Text="Start";
            butStart.Click+=ButtonStart_Click;
            ControlsPanel.Controls.Add(butStart);

            butStop=new Button();
            butStop.Location=new System.Drawing.Point(67, 4);
            butStop.Size=new System.Drawing.Size(60, 26);
            butStop.Text="Stop";
            butStop.Enabled=false;
            butStop.Click+=ButtonStop_Click;
            ControlsPanel.Controls.Add(butStop);

            //run options
            Label labOpts=new Label();
            labOpts.Text="Run Options:";
            labOpts.Location=new System.Drawing.Point(31, 35);
            labOpts.Size=new System.Drawing.Size(70, 13);
            ControlsPanel.Controls.Add(labOpts);

            cbDisableParallel=AddCheckBox("Disable Parallel Run", OptionDisableParallel_Changed, false, "Forces nodes that are marked to run in parallel to run sequentially instead.");
            AddCheckBox("Retry Failures", OptionRetryFailures_Changed, false, "Retry failed test cases up to three time.");
            cbRunLooped=AddCheckBox("Run Looped", OptionRunLooped_Changed, false, "Run test cases in a loop until told to stop.");
            cbDoDryRun=AddCheckBox("Dry Run", OptionDryRun_Changed, false, "Run the tests through the functional scheduler, but do not actually execute them.");
            cbSkipPreRun=AddCheckBox("Skip PreRun", OptionSkipPreRun_Changed, false, "Prevents PreRun from being performed.");
            cbSkipPostRun=AddCheckBox("Skip PostRun", OptionSkipPostRun_Changed, false, "Prevents PostRun from being performed.");
            cbStickyColors = AddCheckBox("Sticky Colors", OptionStickyColors_Changed, false, "Will not clear individual test status colors when you kick off a new run.");

            //add button to show/hide filtering controls
            Button butTagFilterShow=new Button();
            butTagFilterShow.Location=new System.Drawing.Point(2950, 4);
            butTagFilterShow.Size=new System.Drawing.Size(160, 26);
            butTagFilterShow.Dock=DockStyle.Bottom;
            butTagFilterShow.Text="Toggle Tag Panel";
            butTagFilterShow.Click+=delegate(object sender, EventArgs e)
            {
                splitTreeAndFiltering.Panel2Collapsed=!splitTreeAndFiltering.Panel2Collapsed;
                //splitTreeAndFiltering.SplitterDistance=splitTreeAndFiltering.Width-400;
            };
            ControlsPanel.Controls.Add(butTagFilterShow);

            //Tag visibility control
            Label labTagView=new Label();
            labTagView.Text="Tag Visibility: ";
            labTagView.Location=new System.Drawing.Point(2, 5);
            labTagView.Size=new System.Drawing.Size(72, 13);
            FilteringPanel.Controls.Add(labTagView);

            comboTagViewOptions=new ComboBox();
            comboTagViewOptions.Items.Add("Hide all tags");
            comboTagViewOptions.Items.Add("Show tags from Node Only");
            comboTagViewOptions.Items.Add("Show tags from Node and from Parents");
            comboTagViewOptions.Items.Add("Show tags from Node and from Children");
            comboTagViewOptions.Items.Add("Show tags from Node, from Parents, and from Children");
            comboTagViewOptions.Items.Add("Show first occurance of tags from Node or Parents");
            comboTagViewOptions.DropDownStyle=ComboBoxStyle.DropDownList;
            comboTagViewOptions.SelectedIndexChanged+=TagFilter_Changed;
            comboTagViewOptions.SelectedIndex=XmlUtil.GetChildNodeValue(configNode, "TagFilterDisplayTagsOnNodeSetting", 1);
            comboTagViewOptions.Location=new System.Drawing.Point(75, 3);
            comboTagViewOptions.Size=new System.Drawing.Size(280, 13);
            FilteringPanel.Controls.Add(comboTagViewOptions);

            //edit box for filter expression
            Label labFilterExpression=new Label();
            labFilterExpression.Text="Tag Expression: ";
            labFilterExpression.Location=new System.Drawing.Point(150, 34);
            labFilterExpression.Size=new System.Drawing.Size(120, 13);
            FilteringPanel.Controls.Add(labFilterExpression);

            labFilterCharacterPosition=new Label();
            labFilterCharacterPosition.Text="Cursor Position: 0";
            labFilterCharacterPosition.Location=new System.Drawing.Point(7, 2932);
            labFilterCharacterPosition.Size=new System.Drawing.Size(140, 13);
            labFilterCharacterPosition.Anchor=AnchorStyles.Bottom|AnchorStyles.Left;
            FilteringPanel.Controls.Add(labFilterCharacterPosition);

            tbTagExpression=new RichTextBox();
            tbTagExpression.Multiline=true;
            tbTagExpression.DetectUrls=false;
            tbTagExpression.HideSelection=false;
            tbTagExpression.AutoWordSelection=false;
            tbTagExpression.Font=new System.Drawing.Font("Courier New", 9);
            tbTagExpression.ForeColor=System.Drawing.Color.Black;
            tbTagExpression.BackColor=System.Drawing.Color.White;
            tbTagExpression.Location=new System.Drawing.Point(2, 50);
            tbTagExpression.Size=new System.Drawing.Size(394, 2870);
            tbTagExpression.Anchor=AnchorStyles.Bottom|AnchorStyles.Top;
            tbTagExpression.Text=UnmakeStringSaneForXml(XmlUtil.GetChildNodeValue(configNode, "TagExpression", (string)null))??"Val(true)";
            tbTagExpression.TextChanged+=TagExpressionBox_Changed;
            tbTagExpression.SelectionChanged+=TagExpressionBox_Selection;
            tbTagExpression.MouseDown+=TagExpressionBox_MouseDown;
            tbTagExpression.MouseUp+=TagExpressionBox_MouseUp;
            FilteringPanel.Controls.Add(tbTagExpression);

            //add buttons to apply tag expression
            Button butTagApplyEnable=new Button();
            butTagApplyEnable.Location=new System.Drawing.Point(16, 2970);
            butTagApplyEnable.Size=new System.Drawing.Size(100, 25);
            butTagApplyEnable.Anchor=AnchorStyles.Bottom|AnchorStyles.Left;
            butTagApplyEnable.Text="Enable Nodes";
            butTagApplyEnable.Click+=ButtonEnableExpression_Click;
            FilteringPanel.Controls.Add(butTagApplyEnable);

            Button butTagApplyIgnore=new Button();
            butTagApplyIgnore.Location=new System.Drawing.Point(149, 2940);
            butTagApplyIgnore.Size=new System.Drawing.Size(100, 25);
            butTagApplyIgnore.Anchor=AnchorStyles.Bottom;
            butTagApplyIgnore.Text="Ignore Nodes";
            butTagApplyIgnore.Click+=ButtonIgnoreExpression_Click;
            FilteringPanel.Controls.Add(butTagApplyIgnore);

            Button butTagApplyUnignore=new Button();
            butTagApplyUnignore.Location=new System.Drawing.Point(149, 2970);
            butTagApplyUnignore.Size=new System.Drawing.Size(100, 25);
            butTagApplyUnignore.Anchor=AnchorStyles.Bottom;
            butTagApplyUnignore.Text="Unignore Nodes";
            butTagApplyUnignore.Click+=ButtonUnignoreExpression_Click;
            FilteringPanel.Controls.Add(butTagApplyUnignore);

            Button butTagApplyHighlight=new Button();
            butTagApplyHighlight.Location=new System.Drawing.Point(282, 2970);
            butTagApplyHighlight.Size=new System.Drawing.Size(100, 25);
            butTagApplyHighlight.Anchor=AnchorStyles.Bottom|AnchorStyles.Right;
            butTagApplyHighlight.Text="Highlight Nodes";
            butTagApplyHighlight.Click+=ButtonHighlightExpression_Click;
            FilteringPanel.Controls.Add(butTagApplyHighlight);

            Button butTagHelp=new Button();
            butTagHelp.Location=new System.Drawing.Point(360, 10);
            butTagHelp.Size=new System.Drawing.Size(35, 35);
            butTagHelp.Text="?";
            butTagHelp.Click+=ButtonExpressionHelp_Click;
            FilteringPanel.Controls.Add(butTagHelp);

            //create and add test tree
            TestTree=new FuncTreeView(GuiHooks.MainForm, this);
            FunctionalEvents.Add(TestTree);
            TestTree.Dock=DockStyle.Fill;
            splitTreeAndFiltering.Panel1.Controls.Add(TestTree);
            TestTree.CustomDoubleClick+=Tree_DoubleClick;

            //
            return page;
        }

        //Called to return our menu which should be added to the main gui.
        public MenuItem GetNewMenu()
        {
            MenuItem menuFunc=new MenuItem("Functional");

            //add save/loading for enabled tests
            menuFunc.MenuItems.Add(new MenuItem("Save Enabled Nodes", Menu_Func_Save));
            menuFunc.MenuItems.Add(new MenuItem("Load Enabled Nodes", Menu_Func_Load));

            //add our node toggling options
            menuFunc.MenuItems.Add(new MenuItem("-"));
            menuFunc.MenuItems.Add(new MenuItem("Select All Nodes", Menu_Func_SelectAll));
            menuFunc.MenuItems.Add(new MenuItem("Select No Nodes", Menu_Func_SelectNone));
            menuFunc.MenuItems.Add(new MenuItem("Select Failed Nodes", Menu_Func_SelectFailed));
            menuFunc.MenuItems.Add(new MenuItem("Find and Select Tests", Menu_Func_FindTest, Shortcut.CtrlF));

            //add node expansion options
            menuFunc.MenuItems.Add(new MenuItem("-"));
            menuFunc.MenuItems.Add(new MenuItem("Expand All Nodes", Menu_Func_ExpandAll));
            menuFunc.MenuItems.Add(new MenuItem("Collapse All Nodes", Menu_Func_CollapseAll));
            menuFunc.MenuItems.Add(new MenuItem("-"));

            //add serialization options
            menuItemLastKnownState=new MenuItem("Reload Last Known State", Menu_Func_ReloadLastKnownState);
            menuItemLoadState=new MenuItem("Load Result State", Menu_Func_LoadState);
            menuItemSaveState=new MenuItem("Save Result State", Menu_Func_SaveState);
            menuFunc.MenuItems.Add(menuItemSaveState);
            menuFunc.MenuItems.Add(menuItemLoadState);
            menuFunc.MenuItems.Add(menuItemLastKnownState);

            //add functional result file generation options
            menuFunc.MenuItems.Add(new MenuItem("-"));
            menuItemGenerateTrxOnRun=new MenuItem("Generate .trx (VsTest) file on run", Menu_Func_GenerateTrxOnRun);
            menuItemGenerateTrxNow=new MenuItem("Generate .trx (VsTest) file now", Menu_Func_GenerateTrxNow);
            menuFunc.MenuItems.Add(menuItemGenerateTrxOnRun);
            menuFunc.MenuItems.Add(menuItemGenerateTrxNow);

            //add running options
            menuFunc.MenuItems.Add(new MenuItem("-"));
            menuItemStart=new MenuItem("Start Test Run", ButtonStart_Click, Shortcut.F5);
            menuItemPause=new MenuItem("Pause Test Run", ButtonStop_Click, Shortcut.ShiftF5);
            menuItemStop=new MenuItem("Stop Test Run", ButtonStop_Click, Shortcut.CtrlF5);
            menuItemPause.Enabled=false;
            menuItemStop.Enabled=false;
            menuFunc.MenuItems.Add(menuItemStart);
            menuFunc.MenuItems.Add(menuItemPause);
            menuFunc.MenuItems.Add(menuItemStop);

            //hook the clear
            GuiHooks.AddClearOutputHandler(Menu_View_ClearOutput);

            //
            return menuFunc;
        }

        //called when a module is about to be loaded
        public void ModuleLoading(string fileName)
        {
        }

        //called when a suite is loaded
        public void SuiteLoaded(TestNode rootNode)
        {
            //reset autorun countdown
            if (isInAutorunMode)
            {
                autorunCountDownTimer.Stop();
                autorunCountDown=10;
                autorunState=AutorunState.Starting;
                ro.Info("Suite loaded, so restarting autorun countdown.");
            }

            //add to the gui tree
            TestTree.Invoke(new InvokeCode(delegate
                {
                    TestTree.AddTestTree(rootNode);
                }));

            //if we're running, stop
            if (butStop.Enabled)
            {
                ThreadMaker.CreateThread(ThreadProcStop).Start();
            }

            //save the current state, add the suite, reinit the scheduler, then load the enabled state from config
            SaveAllEnabledNodesState(configNode);

            rootNodes.AddLast(rootNode);
            Scheduler.Initialize(SchedulerSettings, FunctionalEvents, rootNodes);

            LoadEnabledState(configNode);

            //start autorun countdown again if needed
            if (isInAutorunMode)
            {
                autorunCountDownTimer.Start();
            }
        }

        //called when suite is being unloaded
        public void SuiteUnloading(TestNode rootNode)
        {
            //remove from the gui tree
            TestTree.RemoveTestTree(rootNode);

            //if we're running, stop
            if (butStop.Enabled)
            {
                ThreadMaker.CreateThread(ThreadProcStop).Start();
            }

            //save the current state, remove the suite, reinit the scheduler, then load the enabled state from config
            SaveAllEnabledNodesState(configNode);

            rootNodes.Remove(rootNode);
            Scheduler.Initialize(SchedulerSettings, FunctionalEvents, rootNodes);
        }

        //Enable any nodes that should be based on the config
        private void LoadEnabledState(XmlNode config)
        {
            foreach (TestNode root in rootNodes)
            {
                XmlNode groupNode=XmlUtil.GetGroupNode(config, MakeStringSaneForXml(root.Name));
                XmlNode enabledNode=XmlUtil.GetGroupNode(groupNode, "Enabled");
                foreach (XmlNode xnode in enabledNode.ChildNodes)
                {
                    string realName=UnmakeStringSaneForXml(xnode.Name);
                    TestNode tn=TestNode.FindNode(root, realName);
                    if (tn!=null && tn.FunctionalData!=null)
                    {
                        tn.FunctionalData.Enabled=true;
                    }
                }
            }

            TestTree.UpdateAllCheckBoxes();
        }

        private void LoadAutomationSettings(XmlNode config)
        {
            XmlNode automationNode = XmlUtil.GetGroupNode(config, "Automation");

            bool checkAll = true;

            if (XmlUtil.GetChildNodeValue(automationNode, "CheckAll", out checkAll) && !checkAll)
            {
                this.checkAllForAutoRun = false;
            }

            bool automationEnabled = false;

            if (XmlUtil.GetChildNodeValue(automationNode, "AutoRun", out automationEnabled) && automationEnabled)
            {
                saveAutorunMode=true;
                this.StartAutoRunCountDown();
            }
        }

        private void StartAutoRunCountDown()
        {
            isInAutorunMode = true;
            autorunCountDown = 10;
            autorunState = AutorunState.Starting;
            autorunCountDownTimer = new System.Timers.Timer();
            autorunCountDownTimer.Interval = 1000; //1s
            autorunCountDownTimer.Elapsed += AutorunCountDownTimerTick;
            autorunCountDownTimer.Start();
        }

        //Called to init
        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            //init
            configNode=pluginSettings;

            this.LoadAutomationSettings(configNode);

            vsTestEventListener=new VsTestResultTestEventListener();

            SchedulerSettings=new FunctionalSchedulerSettings();
            Scheduler=new FuncScheduler();
            FunctionalEvents=new MultiTestEventListener();
            FunctionalEvents.Add(this);
            Scheduler.Initialize(SchedulerSettings, FunctionalEvents, rootNodes);

            //check our commandline params for anything interesting
            foreach (string s in commandlineParameters)
            {
                if (s.ToLower() == "autorun")
                {
                    this.StartAutoRunCountDown();
                }
                else if (s.ToLower().StartsWith("autoruncheckall"))
                {
                    string[] keyValuePairs = s.ToLower().Split('=');
                    if (keyValuePairs.Length == 2)
                    {
                        bool.TryParse(keyValuePairs[1], out this.checkAllForAutoRun);
                    }
                }
                else if (s.ToLower().EndsWith(".func_xml"))
                {
                    try
                    {
                        XmlDocument doc = new XmlDocument();
                        doc.Load(s);

                        //go through every suite in the file
                        XmlNode fileSaved = XmlUtil.GetGroupNode(doc, "Saved");
                        foreach (XmlNode fileSuite in fileSaved.ChildNodes)
                        {
                            //clear our current enables
                            XmlNode configSuite = XmlUtil.GetGroupNode(configNode, MakeStringSaneForXml(fileSuite.Name));
                            XmlNode configEnabled = XmlUtil.GetGroupNode(configSuite, "Enabled");

                            configEnabled.RemoveAll();

                            //copy their enables in
                            XmlNode fileEnabled = XmlUtil.GetGroupNode(fileSuite, "Enabled");
                            foreach (XmlNode fileChild in fileEnabled.ChildNodes)
                            {
                                XmlNode impKid = configNode.OwnerDocument.ImportNode(fileChild, true);
                                configEnabled.AppendChild(impKid);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        ro.Error("Exception loading functional xml config: " + s + ": " + e);
                    }
                }
                else if (s.ToLower() == "help")
                {
                    ro.Info("Functional Plugin parameters:");
                    ro.Info("  autorun                          Automatically run suites then exit.");
                    ro.Info("  autoruncheckall=[true | false]   Turn on all suites before autorun.");
                    ro.Info("  filename.func_xml                load suites from specified file.");
                }
                else
                {
                    ro.Error("Bad parameter passed to functional runner plugin: " + s);
                    break;
                }
            }

            //hook us up to recieve loglines
            Report.GetRoot().AddReportDestination(this);
        }

        //Called when we're being shut down
        public void Shutdown(XmlNode pluginSettings)
        {
            //if we're running, stop
            if (butStop!=null && butStop.Enabled)
            {
                //we do it on this thread so that we block until it's done
                ThreadProcStop();
            }

            //save functional-suite-specific gui information
            SaveAllEnabledNodesState(pluginSettings);

            XmlUtil.SetChildNodeValue(pluginSettings, "TagFilterPanelCollapsed", splitTreeAndFiltering.Panel2Collapsed);
            XmlUtil.SetChildNodeValue(pluginSettings, "TagFilterDisplayTagsOnNodeSetting", comboTagViewOptions.SelectedIndex);
            XmlUtil.SetChildNodeValue(pluginSettings, "TagExpression", MakeStringSaneForXml(tbTagExpression.Text));
        }

        //Copies the enabled state of nodes from all loaded suites into an xml node
        private void SaveAllEnabledNodesState(XmlNode config)
        {
            foreach (TestNode suite in rootNodes)
            {
                //if this suite already has entries, wipe them
                XmlNode groupNode=XmlUtil.GetGroupNode(config, MakeStringSaneForXml(suite.Name));
                groupNode.RemoveAll();

                //save enabled tests list
                XmlNode enabledNode=XmlUtil.GetGroupNode(groupNode, "Enabled");
                SaveEnabledTree(enabledNode, suite);
            }

            this.SaveAutomationSettings(config);
        }

        private void SaveAutomationSettings(XmlNode config)
        {
            XmlNode automationNode = XmlUtil.GetGroupNode(config, "Automation");
            XmlUtil.SetChildNodeValue(automationNode, "AutoRun", this.isInAutorunMode && saveAutorunMode);
            XmlUtil.SetChildNodeValue(automationNode, "CheckAll", this.checkAllForAutoRun);
        }

        //Helper for saving a list of enabled nodes to config
        private void SaveEnabledTree(XmlNode config, TestNode node)
        {
            if (node.FunctionalData==null || node.FunctionalData.Enabled==false)
            {
                return;
            }

            //if I have no children, do my thing
            if (node.ChildrenCount==0)
            {
                XmlNode xn=config.OwnerDocument.CreateNode(XmlNodeType.Element, MakeStringSaneForXml(node.FullName), "");
                config.AppendChild(xn);
                return;
            }

            //if all my children that have functional data are fully enabled, just save my name
            if (IsWholeFunctionalTreeEnabled(node))
            {
                XmlNode xn=config.OwnerDocument.CreateNode(XmlNodeType.Element, MakeStringSaneForXml(node.FullName), "");
                config.AppendChild(xn);
                return;
            }

            //only some children may be enabled, so save each child
            foreach (TestNode child in node.Children)
            {
                SaveEnabledTree(config, child);
            }
        }

        //converts a string to a savable xml string
        private string MakeStringSaneForXml(string str)
        {
            string d="";
            foreach (char s in str)
            {
                if ((s>='a' && s<='z') || (s>='A' && s<='Z')) //normal letter
                {
                    d+=s;
                }
                else //don't trust anything else!
                {
                    d+="_"; //special marker
                    d+=string.Format("{0:D5}", (ushort)s);
                }
            }
            return d;
        }

        /// <summary>
        /// Loads a specific serialized run result file.
        /// </summary>
        /// <param name="path"></param>
        private void LoadState(string path)
        {
            FileStream resultsStream = File.Open(path, FileMode.Open, FileAccess.Read);
            try
            {

                List<FuncTreeNode> nodes = new List<FuncTreeNode>();
                TestTree.GetFlattenedSubtree(ref nodes);

                XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(SerializedRunResults));
                XmlTextReader rdr = new XmlTextReader(resultsStream);
                SerializedRunResults results = (SerializedRunResults)serializer.Deserialize(rdr);

                lock (LogLines)
                {
                    LogLines.Clear();
                    foreach (Report.ReportLine l in results.LogLines)
                    {
                        LogLines.Add(l);
                    }
                }

                foreach (FuncTreeNode n in TestTree.Nodes)
                    n.ResetRunState();

                foreach (SerializableDictionary<string, FunctionalSchedulerNodeData> data in results.SchedulerData)
                {
                    foreach (FuncTreeNode subNode in nodes)
                    {
                        if (data.ContainsKey(subNode.LinkedTestNode.FullName))
                        {
                            FunctionalSchedulerNodeData nd = (FunctionalSchedulerNodeData)data[subNode.LinkedTestNode.FullName];
                            subNode.PassCount = nd.NumberPassed;
                            subNode.TotalCount = nd.NumberTotal;
                            subNode.LinkedTestNode.FunctionalData.SchedulerData = nd;
                            subNode.UpdateNodeVisuals();
                        }
                    }
                }

            }
            catch (Exception ex)
            {
                ro.Error("Failed to load results state.");
                ro.Error(ex.Message);
            }
            finally
            {
                resultsStream.Close();
            }
        }

        //converts a string from a savable xml string
        private string UnmakeStringSaneForXml(string str)
        {
            if (str==null)
            {
                return null;
            }

            string d="";
            for (int ind=0; ind<str.Length; ++ind)
            {
                char s=str[ind];

                if ((s>='a' && s<='z') || (s>='A' && s<='Z')) //normal letter
                {
                    d+=s;
                }
                else if (s=='_') //special marker
                {
                    ++ind;

                    //pull the character number out
                    string cnumstr="";
                    for (int cn=0; cn<5 && ind<str.Length; ++cn,++ind)
                    {
                        if (str[ind]>='0' & str[ind]<='9')
                        {
                            cnumstr+=str[ind];
                        }
                    }
                    --ind; // outter loop will do

                    if (cnumstr.Length==5)
                    {
                        int num=int.Parse(cnumstr);
                        if (num>=0 && num<ushort.MaxValue)
                        {
                            d+=(char)((ushort)num);
                        }
                    }
                }
            }
            return d;
        }

        //used internally by SaveEnabledTree
        bool IsWholeFunctionalTreeEnabled(TestNode tree)
        {
            if (tree.FunctionalData==null || tree.FunctionalData.Enabled==false)
            {
                return false;
            }

            foreach (TestNode child in tree.Children)
            {
                if (child.FunctionalData!=null && child.FunctionalData.Enabled==false)
                {
                    return false;
                }

                if (!IsWholeFunctionalTreeEnabled(child))
                {
                    return false;
                }
            }

            return true;
        }

        #region Events

        private void ButtonStop_Click(object sender, EventArgs e)
        {
            if (butStop.Enabled)
            {
                bool isPause=false;
                if (sender==menuItemPause)
                {
                    isPause=true;
                }
                else if (sender==menuItemStop)
                {
                    isPause=false;
                }
                else //button
                {
                    if (butStop.Text=="Pause")
                    {
                        isPause=true;
                    }
                }

                if (isPause)
                {
                    Scheduler.Pause(); //this is instant so doesn't need a thread
                    SetControlsPaused();
                }
                else
                {
                    ThreadMaker.CreateThread(ThreadProcStop).Start();
                }
            }
        }

        private void ButtonStart_Click(object sender, EventArgs e)
        {
            if (butStart.Enabled)
            {
                if (butStart.Text=="Start")
                {
                    ThreadMaker.CreateThread(ThreadProcRun).Start();
                }
                else if (butStart.Text=="Resume")
                {
                    Scheduler.Resume(); //this is instant so doesn't need a thread
                    SetControlsRunning();
                }
            }
        }

        private void OptionDisableParallel_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.AllowAsync=!cb.Checked;
        }

        private void OptionRetryFailures_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.TimesToTryRun=(cb.Checked?3:1);
        }

        private void OptionRunLooped_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.RunLooped=cb.Checked;
        }

        private void OptionDryRun_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.DryRun=cb.Checked;
        }

        private void OptionSkipPreRun_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.SkipPreRun=cb.Checked;
        }

        private void OptionSkipPostRun_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.SkipPostRun=cb.Checked;
        }

        private void OptionStickyColors_Changed(object sender, EventArgs e)
        {
            CheckBox cb = (CheckBox)sender;
            this.TestTree.StickyColors = cb.Checked;            
        }

        private void Tree_DoubleClick()
        {
            ShowFilteredOutputBox((FuncTreeNode)TestTree.SelectedNode);
        }

        private void Menu_View_ClearOutput()
        {
            lock (LogLines)
            {
                LogLines.Clear();
            }
        }

        private void Menu_Func_SelectAll(object sender, EventArgs args)
        {
            foreach (TestNode suite in rootNodes)
            {
                if (suite.FunctionalData!=null)
                {
                    suite.FunctionalData.Enabled=true;
                }
            }
            TestTree.UpdateAllCheckBoxes();
        }

        private void Menu_Func_SelectNone(object sender, EventArgs args)
        {
            foreach (TestNode suite in rootNodes)
            {
                if (suite.FunctionalData!=null)
                {
                    suite.FunctionalData.Enabled=false;
                }
            }
            TestTree.UpdateAllCheckBoxes();
        }

        private void Menu_Func_SelectFailed(object sender, EventArgs args)
        {
            List<FuncTreeNode> leaves=new List<FuncTreeNode>();
            TestTree.GetLeafNodes(ref leaves);

            foreach (FuncTreeNode fn in leaves)
            {
                if (fn.RunState!=FuncTreeNode.VisualRunState.NotRun && fn.PassCount<fn.TotalCount)
                {
                    fn.LinkedTestNode.FunctionalData.Enabled=true;
                }
                else
                {
                    fn.LinkedTestNode.FunctionalData.Enabled=false;
                }
            }
            TestTree.UpdateAllCheckBoxes();
        }

        private void Menu_Func_ExpandAll(object sender, EventArgs args)
        {
            TestTree.ExpandAll();
        }

        private void Menu_Func_CollapseAll(object sender, EventArgs args)
        {
            TestTree.CollapseAll();
        }

        /// <summary>
        /// Serializes the current run's results.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void Menu_Func_SaveState(object sender, EventArgs args)
        {
            string path = GuiCommon.ChooseFile(true, "Serialized run results file name|*.serializedresult_xml");            
            if (!String.IsNullOrEmpty(path))
                Scheduler.SerializeRun(path);
        }

        /// <summary>
        /// Reloads the last known result, useful on STFGui restart.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void Menu_Func_ReloadLastKnownState(object sender, EventArgs args)
        {   
            string pattern = "*serializedresult_xml";
            if (rootNodes != null && rootNodes.First != null)
                pattern = "*" + rootNodes.First.Value.Name + pattern;
            if (Directory.Exists("FuncOutput\\SerializedRunResults"))
            {
                DirectoryInfo info = new DirectoryInfo("FuncOutput\\SerializedRunResults");
                FileInfo[] files = info.GetFiles(pattern);

                FileInfo max = null;
                if (files.Length > 0)
                {
                    max = files[0];
                    foreach (FileInfo f in files)
                    {
                        if (f.CreationTime > max.CreationTime)
                            max = f;
                    }
                    LoadState(max.FullName);
                }
            }
            else
                ro.Info("No results loaded - no FuncOutput\\SerializedRunResults folder found. (Probably no runs have been completed)");

        }

        /// <summary>
        /// Pops a file select UI to load a serialized result file.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void Menu_Func_LoadState(object sender, EventArgs args)
        {
            string path = GuiCommon.ChooseFile(false, "Serialized Results file (*.serializedresult_xml)|*.serializedresult_xml");
            if (File.Exists(path))
                LoadState(path);
        }

        private void Menu_Func_GenerateTrxOnRun(object sender, EventArgs args)
        {
            menuItemGenerateTrxOnRun.Checked=!menuItemGenerateTrxOnRun.Checked;

            if (menuItemGenerateTrxOnRun.Checked)
            {
                FunctionalEvents.Add(vsTestEventListener);
            }
            else
            {
                FunctionalEvents.Remove(vsTestEventListener);
            }
        }

        private void Menu_Func_GenerateTrxNow(object sender, EventArgs args)
        {
            //Create a temporary listener and generate the few events it cares about
            VsTestResultTestEventListener tempListener=new VsTestResultTestEventListener();
            TestEventArgs tea=new TestEventArgs(null, null, TestAction.StartAll);
            tempListener.OnTestEvent(tea);

            foreach (TestNode node in rootNodes)
            {
                tea=new TestEventArgs(node, null, TestAction.Start);
                tempListener.OnTestEvent(tea);
            }

            tea=new TestEventArgs(null, null, TestAction.StopAll);
            tempListener.OnTestEvent(tea);
        }

        /// <summary>
        /// Pops a window, asks for a regex or substring, and then searches for, expands and 
        /// selects any matching test cases.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void Menu_Func_FindTest(object sender, EventArgs args)
        {
            FormInputBox inputBox = new FormInputBox("Enter a regex or substring to match.");
            inputBox.StartPosition = FormStartPosition.CenterParent;
            DialogResult res = inputBox.ShowDialog(GuiHooks.MainForm);

            if (res == DialogResult.OK && !String.IsNullOrEmpty(inputBox.data))
            {
                string searchPattern = inputBox.data;
                searchPattern = String.Format(".*{0}.*", searchPattern);

                List<FuncTreeNode> nodes = new List<FuncTreeNode>();
                TestTree.GetLeafNodes(ref nodes);

                foreach (FuncTreeNode n in nodes)
                {
                    if (Regex.IsMatch(n.FullPath.ToLower(), searchPattern, RegexOptions.IgnoreCase))
                    {
                        n.EnsureVisible();
                        n.LinkedTestNode.FunctionalData.Enabled = true;
                    }
                }
                TestTree.UpdateAllCheckBoxes();
            }
        }

        private void Menu_Func_Save(object sender, EventArgs args)
        {
            if (rootNodes.Count==0)
            {
                return;
            }

            //update xml state to current
            SaveAllEnabledNodesState(configNode);

            //ask user for file
            string fname=GuiCommon.ChooseFile(true, "Functional Nodes State (*.func_xml)|*.func_xml");
            if (fname==null)
            {
                return;
            }

            //get info from loaded suites, then save it
            XmlDocument doc=new XmlDocument();
            XmlNode newRoot=XmlUtil.GetGroupNode(doc, "Saved");
            foreach (TestNode suite in rootNodes)
            {
                XmlNode suiteNode=XmlUtil.GetGroupNode(configNode, MakeStringSaneForXml(suite.Name));
                XmlNode impNode=doc.ImportNode(suiteNode, true);
                newRoot.AppendChild(impNode);
            }

            doc.Save(fname);
        }

        private void Menu_Func_Load(object sender, EventArgs args)
        {
            if (rootNodes.Count==0)
            {
                return;
            }

            //ask user for file and load it
            string fname=GuiCommon.ChooseFile(false, "Functional Nodes State (*.func_xml)|*.func_xml");
            if (fname==null)
            {
                return;
            }

            LoadXmlEnabledConfig(fname);
        }

        private bool TagExpressionBox_Changed_isProcessing=false;
        private void TagExpressionBox_Changed(object obj, EventArgs args)
        {
            if (TagExpressionBox_Changed_isProcessing || TagExpressionBox_MouseDragging)
            {
                return;
            }

            TagExpressionBox_Changed_isProcessing=true;
            tbTagExpression.SuspendLayout();

            //reset font/color/etc so pasting rich text doesn't make stuff weird.
            int curSel=tbTagExpression.SelectionStart;
            int curSelLen=tbTagExpression.SelectionLength;
            tbTagExpression.SelectionStart=0;
            tbTagExpression.SelectionLength=tbTagExpression.Text.Length+1;

            tbTagExpression.SelectionFont=tbTagExpression.Font;
            tbTagExpression.SelectionColor=tbTagExpression.ForeColor;
            tbTagExpression.SelectionBackColor=tbTagExpression.BackColor;
            tbTagExpression.Text=tbTagExpression.Text;

            //validate the current expression and highlight errors
            //new ToolTip().SetToolTip(tbTagExpression, "Expression is valid.");

            try
            {
                new NodeTaggingData.Expression(tbTagExpression.Text);
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                //new ToolTip().SetToolTip(tbTagExpression, iee.ToString());

                tbTagExpression.SelectionStart=iee.BadCharacterStart;
                tbTagExpression.SelectionLength=iee.BadCharacterEnd-iee.BadCharacterStart;
                if (tbTagExpression.SelectionLength==0) //we want to highlight "something"...
                {
                    if (tbTagExpression.SelectionStart==tbTagExpression.Text.Length && tbTagExpression.SelectionStart>0)
                    {
                        --tbTagExpression.SelectionStart;
                    }
                    ++tbTagExpression.SelectionLength;
                }
                tbTagExpression.SelectionBackColor=System.Drawing.Color.Red;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
            }

            //highlight associated parenthesis
            if (curSel<tbTagExpression.Text.Length)
            {
                if (tbTagExpression.Text[curSel]=='(')
                {
                    tbTagExpression.SelectionStart=curSel;
                    tbTagExpression.SelectionLength=1;
                    tbTagExpression.SelectionBackColor=System.Drawing.Color.LightGray;

                    int depth=1;
                    for (int pos=curSel+1; pos<tbTagExpression.Text.Length; ++pos)
                    {
                        if (tbTagExpression.Text[pos]=='(')
                        {
                            ++depth;
                        }
                        else if (tbTagExpression.Text[pos]==')')
                        {
                            --depth;
                            if (depth==0)
                            {
                                tbTagExpression.SelectionStart=pos;
                                tbTagExpression.SelectionLength=1;
                                tbTagExpression.SelectionBackColor=System.Drawing.Color.LightGray;
                                break;
                            }
                        }
                    }
                }
            }

            if (curSel>0)
            {
                if (tbTagExpression.Text[curSel-1]==')')
                {
                    tbTagExpression.SelectionStart=curSel-1;
                    tbTagExpression.SelectionLength=1;
                    tbTagExpression.SelectionBackColor=System.Drawing.Color.LightGray;

                    int depth=1;
                    for (int pos=curSel-1-1; pos>=0; --pos)
                    {
                        if (tbTagExpression.Text[pos]=='(')
                        {
                            --depth;
                            if (depth==0)
                            {
                                tbTagExpression.SelectionStart=pos;
                                tbTagExpression.SelectionLength=1;
                                tbTagExpression.SelectionBackColor=System.Drawing.Color.LightGray;
                                break;
                            }
                        }
                        else if (tbTagExpression.Text[pos]==')')
                        {
                            ++depth;
                        }
                    }
                }
            }

            //reset selection back to users' original
            tbTagExpression.SelectionStart=curSel;
            //tbTagExpression.SelectionBackColor=tbTagExpression.BackColor;
            tbTagExpression.SelectionLength=curSelLen;


            tbTagExpression.ResumeLayout();
            TagExpressionBox_Changed_isProcessing=false;
        }

        private bool TagExpressionBox_Selection_isProcessing=false;
        private void TagExpressionBox_Selection(object obj, EventArgs args)
        {
            if (TagExpressionBox_Selection_isProcessing || TagExpressionBox_Changed_isProcessing)
            {
                return;
            }
            TagExpressionBox_Selection_isProcessing=true;

            labFilterCharacterPosition.Text="Cursor Position: "+(tbTagExpression.SelectionStart+tbTagExpression.SelectionLength);
            TagExpressionBox_Changed(obj, args);

            TagExpressionBox_Selection_isProcessing=false;
        }

        private bool TagExpressionBox_MouseDragging=false;
        public void TagExpressionBox_MouseDown(Object sender, MouseEventArgs mea)
        {
            TagExpressionBox_MouseDragging=true;
        }

        public void TagExpressionBox_MouseUp(Object sender, MouseEventArgs mea)
        {
            TagExpressionBox_MouseDragging=false;
        }

        private void TagFilter_Changed(object ninja, EventArgs args)
        {
            TagVisibilityState=(TagVisibilityStates)comboTagViewOptions.SelectedIndex;
            if (TestTree!=null)
            {
                TestTree.RefreshAllNodeVisuals();
            }
        }

        private void ButtonHighlightExpression_Click(object sender, EventArgs ea)
        {
            //parse the expression
            NodeTaggingData.Expression expression=null;

            try
            {
                expression=new NodeTaggingData.Expression(tbTagExpression.Text);
                roExp.Success("Expression is valid");
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                roExp.Error(iee.ToString());
                return;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
                return;
            }

            //now apply the expression to the tree
            TestTree.HighlightExpression(expression);
        }

        private void ButtonEnableExpression_Click(object sender, EventArgs ea)
        {
            //parse the expression
            NodeTaggingData.Expression expression=null;

            try
            {
                expression=new NodeTaggingData.Expression(tbTagExpression.Text);
                roExp.Success("Expression is valid");
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                roExp.Error(iee.ToString());
                return;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
                return;
            }

            //now apply the expression to the tree
            TestTree.EnableExpression(expression);
        }

        private void ButtonIgnoreExpression_Click(object sender, EventArgs ea)
        {
            //parse the expression
            NodeTaggingData.Expression expression=null;

            try
            {
                expression=new NodeTaggingData.Expression(tbTagExpression.Text);
                roExp.Success("Expression is valid");
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                roExp.Error(iee.ToString());
                return;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
                return;
            }

            //now apply the expression to the tree
            TestTree.IgnoreExpression(expression);
        }

        private void ButtonUnignoreExpression_Click(object sender, EventArgs ea)
        {
            //parse the expression
            NodeTaggingData.Expression expression=null;

            try
            {
                expression=new NodeTaggingData.Expression(tbTagExpression.Text);
                roExp.Success("Expression is valid");
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                roExp.Error(iee.ToString());
                return;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
                return;
            }

            //now apply the expression to the tree
            TestTree.UnignoreExpression(expression);
        }

        public void ButtonExpressionHelp_Click(object sender, EventArgs ea)
        {
            //make a form
            Form form=new Form();
            form.SetBounds(0,0,800,600,BoundsSpecified.Size);
            form.Text="Expressions Help";
            form.FormBorderStyle=FormBorderStyle.Sizable;

            //add a text box to it
            TextBox box=new TextBox();
            box.Text=NodeTaggingData.Expression.GetHelpText().Replace("\n","\r\n");
            box.Dock=DockStyle.Fill;
            //box.BackColor=Color.Black;
            //box.ForeColor=Color.LightGray;
            box.WordWrap=false;
            //box.Font=new System.Drawing.Font("Lucida Console", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            box.ReadOnly=true;
            box.Enabled=true;
            box.HideSelection=false;
            box.ShortcutsEnabled=false;
            box.Multiline=true;
            box.ScrollBars=ScrollBars.Both;
            box.SelectionStart=0;
            box.SelectionLength=0;
            form.Controls.Add(box);
            form.Show(GuiHooks.MainForm);
        }

        private void AutorunCountDownTimerTick(object pirate, System.Timers.ElapsedEventArgs arr)
        {
            if (autorunState==AutorunState.Starting)
            {
                --autorunCountDown;
                ro.Info("Autorun starting in "+autorunCountDown+" seconds.");
                if (autorunCountDown<=0)
                {
                    autorunCountDownTimer.Stop();
                    autorunState=AutorunState.Running;

                    if (rootNodes.Count==0)
                    {
                        ro.Info("Autorun: No suites loaded, so exiting.");
                        GuiHooks.MainForm.Close();
                    }
                    else
                    {
                        if (this.checkAllForAutoRun)
                        {
                            Menu_Func_SelectAll(null, null);
                        }

                        ButtonStart_Click(null,null);
                    }
                }
            }
        }

        public void OnTestEvent(TestEventArgs tea)
        {
            if (isInAutorunMode) //in autorun mode, close when done
            {
                if (tea.Action==TestAction.StopAll)
                {
                    ro.Info("Autorun: Run finished, so exiting.");
                    GuiHooks.MainForm.Close();
                }
            }
        }

        #endregion

        //loads functional config from an xml file
        private void LoadXmlEnabledConfig(string file)
        {
            //load file
            XmlDocument doc=new XmlDocument();
            try
            {
                doc.Load(file);
            }
            catch (Exception e)
            {
                ro.Error("Error loading function xml config file: "+file+": "+e);
                return;
            }

            //clear out all old enables and set the correct nodes
            foreach (TestNode suite in rootNodes)
            {
                if (suite.FunctionalData!=null)
                {
                    suite.FunctionalData.Enabled=false;
                }
            }

            XmlNode xmlSaved=XmlUtil.GetGroupNode(doc, "Saved");
            foreach (TestNode suite in rootNodes)
            {
                XmlNode xmlSuite=XmlUtil.GetGroupNode(xmlSaved, MakeStringSaneForXml(suite.Name));
                XmlNode xmlEnabled=XmlUtil.GetGroupNode(xmlSuite, "Enabled");
                foreach (XmlNode xnode in xmlEnabled.ChildNodes)
                {
                    TestNode tn=TestNode.FindNode(suite, UnmakeStringSaneForXml(xnode.Name));
                    if (tn!=null && tn.FunctionalData!=null)
                    {
                        tn.FunctionalData.Enabled=true;
                    }
                }
            }

            if (TestTree!=null)
            {
                TestTree.UpdateAllCheckBoxes();
            }
        }

        //thread proc to start running
        void ThreadProcRun()
        {
            //update params then validate
            if (!Scheduler.ValidateParameters())
            {
                ro.Warn("Functional scheduler reports that it has invalid parameters.  Running anyways though.");
            }

            //run
            if (!isRunning)

            {
                SetControlsRunning();
                Scheduler.Run();
                SetControlsStopped();
            }
        }

        //thread proc to stop running
        void ThreadProcStop()
        {
            ControlsPanel.Invoke(new InvokeCode(delegate
            {
                butStart.Enabled=false;
                butStop.Enabled=false;
                menuItemStop.Enabled=false;
                butStop.Text="Stopping";
            }));

            if (rootNodes.Count>0)
            {
                Scheduler.Stop();
            }
            SetControlsStopped();
        }

        //sets the state of the controls to "running"
        private void SetControlsRunning()
        {
            isRunning=true;
            ControlsPanel.Invoke(new InvokeCode(delegate
            {
                butStart.Text="Start";
                butStart.Enabled=false;
                butStop.Text="Pause";
                butStop.Enabled=true;
                menuItemStart.Enabled=false;
                menuItemPause.Enabled=true;
                menuItemStop.Enabled=true;

                menuItemSaveState.Enabled=false;
                menuItemLastKnownState.Enabled=false;
                menuItemLoadState.Enabled=false;
                menuItemGenerateTrxOnRun.Enabled=false;

                foreach (CheckBox cb in optionsCheckBoxes)
                {
                    cb.Enabled=false;
                }
            }));
        }

        //sets the state of the controls to "paused"
        private void SetControlsPaused()
        {
            ControlsPanel.Invoke(new InvokeCode(delegate
            {
                butStart.Text="Resume";
                butStart.Enabled=true;
                butStop.Text="Stop";
                butStop.Enabled=true;
                menuItemStart.Enabled=true;
                menuItemPause.Enabled=false;
                menuItemStop.Enabled=true;
            }));
        }

        //sets the state of the controls to "stopped"
        private void SetControlsStopped()
        {
            ControlsPanel.Invoke(new InvokeCode(delegate
            {
                butStart.Text="Start";
                butStart.Enabled=true;
                butStop.Text="Stop";
                butStop.Enabled=false;
                menuItemStart.Enabled=true;
                menuItemPause.Enabled=false;
                menuItemStop.Enabled=false;

                menuItemSaveState.Enabled=true;
                menuItemLastKnownState.Enabled=true;
                menuItemLoadState.Enabled=true;
                menuItemGenerateTrxOnRun.Enabled=true;

                foreach (CheckBox cb in optionsCheckBoxes)
                {
                    cb.Enabled=true;
                }
                UpdateOverrideControlsState();
            }));
            isRunning=false;
        }

        //Pops up a window with output filtered from a specific node
        private void ShowFilteredOutputBox(FuncTreeNode ftn)
        {
            if (ftn==null)
            {
                return;
            }

            //make form
            Form form=new Form();
            form.SetBounds(0,0,650,400,BoundsSpecified.Size);
            form.Text=ftn.LinkedTestNode.FullName;
            form.FormBorderStyle=FormBorderStyle.Sizable;

            //add a "Loading..." label
            Label loading=new Label();
            loading.Text="Loading...";
            loading.Size=new System.Drawing.Size(60, 15);
            form.Controls.Add(loading);

            //add a stf output box to it
            StfTextBox box=new StfTextBox();
            box.Dock=DockStyle.Fill;
            form.Controls.Add(box);
            form.Show(GuiHooks.MainForm);

            //now populate that box with relevent loglines
            form.Refresh();
            box.SuspendLayout();

            LinkedList<Report.ReportLine> filteredLines=new LinkedList<Report.ReportLine>();

            lock (LogLines)
            {
                foreach (Report.ReportLine line in LogLines)
                {
                    if (FilterNodeNameFromNodeName(line.TestName, ftn.LinkedTestNode.FullName))
                    {
                        filteredLines.AddLast(line);
                    }
                }
            }

            box.LogBulk(filteredLines);

            box.ResumeLayout();
            loading.Visible=false;
        }

        //returns whether (Node Names) nameToFilter is a subset of filter.
        private bool FilterNodeNameFromNodeName(string nameToFilter, string filter)
        {
            if (nameToFilter==filter) //if they're the same, it is
            {
                return true;
            }

            if (nameToFilter.StartsWith(filter+".")) //if it is within the group, it is
            {
                return true;
            }

            return false;
        }

        //handles incoming loglines
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            if (!StoreLoglines || testName==ThreadTracker.DefaultFullName) //if not logging or it has no bucket (for example stress output)
            {
                return;
            }
            else //store it
            {
                Report.ReportLine line=new Report.ReportLine();
                line.Date=date;
                line.Level=level;
                line.Path=path;
                line.Message=message;
                line.TestName=testName;

                lock (LogLines)
                {
                    LogLines.Add(line);
                }
            }
        }

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup1\Main.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;

using ServerTestFramework;

namespace STFGui
{
    public class MainApp
    {
        [Flags]
        public enum STFGuiExitCode
        {
            OK               = 0, //we loaded ok
            LoadError        = 1, //errors loading a module specified on the commandline
            GuiParamError    = 2, //problem with a commandline parameter targetted at STFGui itself
            PluginParamError = 4  //problem with a commandline paramater targetted at a plugin (not currently set)
        }

        //entry point
        [STAThreadAttribute]
        static void Main(string[] args)
        {
            // Pretty it up :)  (down! This may break some ui formatting on vista, be careful)
            Application.EnableVisualStyles();

            //Look through parameters and sort them into their relevent buckets
            List<string> paramsForMainGui = new List<string>();
            List<string> paramsForPlugins = new List<string>();
            List<string> paramsToLoad = new List<string>();

            foreach (string param in args)
            {
                string paramLower = param.ToLower();

                if (paramLower.StartsWith("-plugparam:")) //parameter for a plugin
                {
                    paramsForPlugins.Add(param.Substring(11));
                }
                else if (!param.StartsWith("-") && param.EndsWith(".dll")) //module to load
                {
                    paramsToLoad.Add(param);
                }
                else if (!param.StartsWith("-") && param.EndsWith(".xml")) //TODO: Temporary special case here to ignore xml files... since since our old live-specific code still directly relies on parsing xml files from the commandline itself.  That needs updated someday.
                {
                    //ignoring it
                }
                else if (paramLower == "-breakonstart")
                {
                    System.Diagnostics.Debugger.Launch();
                    //System.Diagnostics.Debugger.Break();
                }
                else //parameter for stfgui itself
                {
                    paramsForMainGui.Add(param);
                }
            }

            //Create the main gui and set it up
            System.Environment.ExitCode = (int)STFGuiExitCode.OK; //default to good state
            STFGuiForm gui = new STFGuiForm();

            System.Environment.ExitCode |= (int)gui.Init(paramsForMainGui.ToArray(), paramsForPlugins.ToArray());

            //Load suites and plugins passed on the commandline
            foreach (string fname in paramsToLoad)
            {
                if (!gui.LoadModule(fname))
                {
                    System.Environment.ExitCode |= (int)STFGuiExitCode.LoadError;
                }
            }

            //Block here until the form is closed
            gui.ShowDialog();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\Plugins\LiveEnvironment\Environment.cs ===
using System;
using System.Threading;
using System.Windows.Forms;
using System.Drawing;
using System.Xml;
using System.Data.SqlClient;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Database;

namespace STFGui.Plugins
{
    public partial class EnvironmentPlugin: IPluginSetup, IPluginGui
    {
        // -- public stuff

        public string CurrentEnvironment="";

        /// <summary>
        /// Changes the environment chooser into "button mode" instead of "combobox mode".
        /// </summary>
        public void EnableButtonMode()
        {
            envCombo.Visible=false;
            foreach (Button b in envButtons.Values)
            {
                b.Visible=true;
            }
        }

        //these events are triggered when the environment is about to be changed and after it has been changed
        public event EnvironmentChangedDelegate EnvironmentChangeBeginEvent;
        public event EnvironmentChangedDelegate EnvironmentChangeFinishEvent;
        public delegate void EnvironmentChangedDelegate(string newEnvironmentName);

        // -- internals

        private static readonly String EnvListEditOption = "Edit...";
        private static readonly String EnvListNoneOption = "None";

        static Report ro=new Report("EnvPlugin");

        public Panel PanelEnvList;
        public Panel PanelTabList;
        public TabControl Tabs;
        Label curEnvText;
        TextBox curEnvIpText;
        Button refreshButton;

        Dictionary<string,Button> envButtons=new Dictionary<string,Button>();
        ComboBox envCombo;

        Thread resetThread=null;
        Thread refreshThread=null;
        Object refreshLockObj = new Object();
        XmlNode settings;

        public delegate void InvokeCode();

        //Returns the TabPage to add to the gui.
        public System.Windows.Forms.TabPage GetNewTabPage()
        {
            System.Windows.Forms.TabPage page=new System.Windows.Forms.TabPage();
            page.Text="Environment";

            //add a splitter to it, to divide the controls from the node tree
            SplitContainer splitEnvAndTabs=new SplitContainer();
            splitEnvAndTabs.Orientation=Orientation.Vertical;
            splitEnvAndTabs.Dock=DockStyle.Fill;
            splitEnvAndTabs.Location=new System.Drawing.Point(0, 0);
            splitEnvAndTabs.Size=new System.Drawing.Size(3000, 3000);
            splitEnvAndTabs.Panel1MinSize=105;
            splitEnvAndTabs.SplitterDistance=105;
            splitEnvAndTabs.IsSplitterFixed=true;
            page.Controls.Add(splitEnvAndTabs);

            PanelEnvList=splitEnvAndTabs.Panel1;
            PanelTabList=splitEnvAndTabs.Panel2;

            // -- setup env list
            int offset = 5;

            //add current environment text
            curEnvText=new Label();
            curEnvText.Text="Current: "+CurrentEnvironment;
            curEnvText.Location = new System.Drawing.Point(0, offset);
            curEnvText.Size=new System.Drawing.Size(350, 20);
            PanelEnvList.Controls.Add(curEnvText);

            offset += 20;
            Label curEnvIpLbl = new Label();
            curEnvIpLbl.Text = "IP:";
            curEnvIpLbl.Location = new System.Drawing.Point(0, offset);
            curEnvIpLbl.Size = new System.Drawing.Size(20, 20);
            PanelEnvList.Controls.Add(curEnvIpLbl);

            curEnvIpText = new TextBox();
            curEnvIpText.Text = (Global.CurrentEnvironment!=null?Global.CurrentEnvironment.NpdbIp:"?");
            curEnvIpText.Location = new System.Drawing.Point(18, offset - 2);
            curEnvIpText.Size = new System.Drawing.Size(85, 20);
            curEnvIpText.BorderStyle = BorderStyle.FixedSingle;
            curEnvIpText.LostFocus += EnvIpChange;
            curEnvIpText.KeyPress += EnvIpKeyPress;
            PanelEnvList.Controls.Add(curEnvIpText);
            curEnvIpText.BringToFront();

            //add env buttons and combo box
            offset += 20;
            envCombo=new ComboBox();
            envCombo.Location = new System.Drawing.Point(2, offset);
            envCombo.Size=new System.Drawing.Size(100, 22);
            envCombo.DropDownStyle=ComboBoxStyle.DropDownList;
            envCombo.DropDownHeight*=2;
            PanelEnvList.Controls.Add(envCombo);

            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                string name = npdbSetting.Environment;

                if (envButtons.ContainsKey(name))
                {
                    ro.Warn("Duplicate environment name: " + name);
                    continue;
                }

                Button but=new Button();
                but.Text=name;
                but.Location=new System.Drawing.Point(9, offset);
                but.Size=new System.Drawing.Size(83, 22);
                but.Click+=EnvButtonClick;
                PanelEnvList.Controls.Add(but);
                envButtons.Add(but.Text, but);
                but.Visible=false;

                envCombo.Items.Add(but.Text);

                offset+=24;
            }

            // add a special option
            envCombo.Items.Add(EnvListEditOption);

            int comboSelInd=envCombo.FindStringExact(CurrentEnvironment);
            if (comboSelInd==-1)
            {
                comboSelInd=envCombo.FindStringExact(EnvListNoneOption);
            }
            if (comboSelInd==-1)
            {
                comboSelInd=0;
            }
            envCombo.SelectedIndex=comboSelInd;
            envCombo.SelectedIndexChanged+=EnvComboChange;

            //refresh button
            refreshButton=new Button();
            refreshButton.Text="Populate Info Pages";
            refreshButton.Location=new System.Drawing.Point(0, 0);
            refreshButton.Size=new System.Drawing.Size(100, 35);
            refreshButton.Dock=DockStyle.Bottom;
            refreshButton.Click+=RefreshButton_Click;
            int refreshBgG=(int)refreshButton.BackColor.G+10;
            if (refreshBgG>255) refreshBgG=255;
            int refreshBgB=(int)refreshButton.BackColor.B+25;
            if (refreshBgB>255) refreshBgB=255;
            refreshButton.BackColor=Color.FromArgb(255, refreshButton.BackColor.R, refreshBgG, refreshBgB);

            PanelEnvList.Controls.Add(refreshButton);

            // -- setup info tabs

            Tabs=new TabControl();
            Tabs.Dock=DockStyle.Fill;
            PanelTabList.Controls.Add(Tabs);
            Tabs.Alignment=TabAlignment.Left;

            Tabs.TabPages.Add(MakeServerBrowserTabPage());
            Tabs.TabPages.Add(MakeSettingsBrowserTabPage());
            Tabs.TabPages.Add(MakeUODBTabPage());

            //select the last used tab if possible
            string initialTabName=XmlUtil.GetChildNodeValue(settings, "LastInfoTab","Servers");
            foreach (TabPage tp in Tabs.TabPages)
            {
                if (tp.Text==initialTabName)
                {
                    Tabs.SelectTab(tp);
                    break;
                }
            }

            //
            return page;
        }

        //Called to init
        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            //ro.Debug("STFLive is version "+Global.GetLiveAssembly().GetName().Version); //TODO: Get this back in the new world sometime.

            //check our commandline params for anything interesting
            CurrentEnvironment=null;
            foreach (string s in commandlineParameters)
            {
                if (s.ToLower().StartsWith("env:") && s.Length>=5) //set environment
                {
                    CurrentEnvironment=s.Substring(s.IndexOf(':')+1);
                }
                else if (s.ToLower()=="help")
                {
                    ro.Info("Environment Plugin parameters:");
                    ro.Info("  env:Name      Set the environment to Name.");
                }
                else
                {
                    ro.Error("Bad parameter passed to Environment plugin: "+s);
                }
            }

            //load plugin configuration
            settings=pluginSettings;
            if (CurrentEnvironment==null)
            {
                CurrentEnvironment=XmlUtil.GetChildNodeValue(pluginSettings, "LastEnvironment", EnvListNoneOption);
            }

            //load the base stflive config
            StfXmlDoc liveConfig=new StfXmlDoc();
            try
            {
                liveConfig.Load(Global.DefaultConfigFile);
            }
            catch(Exception) //the file is optional, swallow it
            {
            }

            //merge in any xmls from the commandline, and init it
            //TODO: This really should be using commandlines passed to the plugin... NOT directly trying to ingest the commandline itself...
            string []cmdParams=System.Environment.CommandLine.Split(new char[]{' '});
            foreach (string param in cmdParams)
            {
                if (param.ToLower().EndsWith(".xml"))
                {
                    ro.Debug("STFLive plugin handling paramater: "+param);
                    try
                    {
                        liveConfig.Merge(new StfXmlDoc(param), "/stf");
                    }
                    catch (Exception e)
                    {
                        ro.Warn("Failed to merge xml config file into STFLive's config: "+param+": "+e);
                    }
                }
            }

            CoreGlobal.Initialize(liveConfig);

            //kick off the environment reset in the background
            ResetEnvironment();
        }

        //Called when we're being shut down
        public void Shutdown(XmlNode pluginSettings)
        {
            //save plugin configuration
            XmlUtil.SetChildNodeValue(pluginSettings, "LastEnvironment", CurrentEnvironment);

            Tabs.Invoke(new InvokeCode(delegate
            {
                if (Tabs.SelectedTab!=null)
                {
                    XmlUtil.SetChildNodeValue(pluginSettings, "LastInfoTab", Tabs.SelectedTab.Text);
                }
            }));

            CurrentEnvironment=null;
            ThreadMaker.CreateThread(ResetEnvironment).Start(); //lets not block on it
        }

        //get the "name" of the current environment as npdb sees it
        public string GetCurrentEnvironmentName()
        {
            return Global.XEnv.GetEnv().ToLower();
        }

        // --

        //resets the environment, or if current is null, just stops and resets.
        private void ResetEnvironment()
        {
            if (resetThread!=null)
            {
                resetThread.Abort();
            }

            // Stop the refresh as it will restart when 
            // the environment setup is completed again
            if (refreshThread != null)
            {
                lock (refreshLockObj)
                {
                    if (refreshThread != null)
                    {
                        refreshThread.Abort();
                        refreshThread = null;
                    }
                }
            }

            if (CurrentEnvironment!=null)
            {
                resetThread=ThreadMaker.CreateThread(ThreadProcSetupEnvironment);
                resetThread.IsBackground=true;
                resetThread.Start();
            }
        }

        private void RefreshInfoPages()
        {
            lock (refreshLockObj)
            {
                // Kill the thread if it's running
                if (refreshThread != null)
                {
                    refreshThread.Abort();
                    refreshThread = null;
                }

                if (CurrentEnvironment != EnvListNoneOption)
                {
                    refreshThread = ThreadMaker.CreateThread(() =>
                    {
                        try
                        {
                            RefreshServers();
                            RefreshSettings();
                            RefreshUODB();
                        }
                        catch (ThreadAbortException)
                        {
                            Thread.ResetAbort();
                        }
                        finally
                        {
                            InvokeChangeText(refreshButton, "Populate Info Pages");
                        }
                    });

                    InvokeChangeText(refreshButton, "Populating...");
                    refreshThread.IsBackground = true;
                    refreshThread.Start();
                }
            }
        }

        private static void InvokeChangeText (Control lbl, string text)
        {
            if (lbl != null && lbl.IsHandleCreated)
            {
                lbl.Invoke(new InvokeCode(delegate
                {
                    lbl.Text = text;
                }));
            }
        }

        private void ThreadProcSetupEnvironment()
        {
            InvokeChangeText(curEnvText, "Current: ...");
            InvokeChangeText(curEnvIpText, "...");

            //if none is chosen, set it to the first in the list
            if (CurrentEnvironment.Length==0)
            {
                if (Global.EnvironmentList.Count==0)
                {
                    ro.Fatal("No valid STFLive environments in config (missing stf.xml?).");
                    return;
                }

                foreach (EnvironmentSetting envCheck in Global.EnvironmentList)
                {
                    CurrentEnvironment=envCheck.Environment;
                    break;
                }
            }

            //look for the environment from the list stflive exposes to us and choose it
            string envName=CurrentEnvironment.ToLower();
            bool found=false;
            foreach (EnvironmentSetting envCheck in Global.EnvironmentList)
            {
                if (envCheck.Environment.ToLower()==envName)
                {
                    Global.CurrentEnvironment=envCheck;
                    found=true;
                    break;
                }
            }

            if (!found)
            {
                ro.Fatal("Requested environment '"+CurrentEnvironment+"' is not in STFLive's config (stf.xml).");
                return;
            }

            //trigger the change begin event
            try
            {
                if (EnvironmentChangeBeginEvent!=null)
                {
                    EnvironmentChangeBeginEvent(CurrentEnvironment);
                }
            }
            catch (Exception e)
            {
                ro.Error("Exception calling begin reset environment event: "+e);
            }

            //now tell STFLive to reset it's environment
            Global.ResetEnvironment(true);
            ro.Info("Environment reset to "+CurrentEnvironment+".");

            InvokeChangeText(curEnvText, "Current: " + CurrentEnvironment);
            InvokeChangeText(curEnvIpText, Global.CurrentEnvironment.NpdbIp);

            // Start the environment info population
            RefreshInfoPages();

            //trigger the change end event
            try
            {
                if (EnvironmentChangeFinishEvent!=null)
                {
                    EnvironmentChangeFinishEvent(CurrentEnvironment);
                }
            }
            catch (Exception e)
            {
                ro.Error("Exception calling finish reset environment event: "+e);
            }

            resetThread=null;
        }

        #region Gui Events

        public void EnvButtonClick(object sender, EventArgs e)
        {
            Button but=(Button)sender;

            PanelServerInterfacesServers.Enabled=false;
            TreeInterfaces.Nodes.Clear();
            TreeServers.Nodes.Clear();
            ResetUodbTab();

            ClearSettingsInfo();

            CurrentEnvironment=but.Text;
            ResetEnvironment();
        }

        public void EnvComboChange(object sender, EventArgs e)
        {
            if (envCombo.SelectedIndex==-1)
            {
                return;
            }

            string newEnv=(string)envCombo.Items[envCombo.SelectedIndex];

            if (newEnv == EnvListEditOption)
            {
                System.Diagnostics.Process.Start("notepad", @".\stf.xml");
            }
            else if (newEnv!=CurrentEnvironment)
            {
                EnvButtonClick(envButtons[newEnv], e);
            }
        }

        public void EnvIpChange (object sender, EventArgs e)
        {
            string newIp = curEnvIpText.Text.Trim();

            if (newIp == Global.CurrentEnvironment.NpdbIp)
            {
                return;
            }

            Global.CurrentEnvironment.NpdbIp = newIp;
            // force the update via property
            Global.CurrentEnvironment = Global.CurrentEnvironment;

            ResetEnvironment();
        }

        public void EnvIpKeyPress (object sender, EventArgs e)
        {
            KeyPressEventArgs kpea = (KeyPressEventArgs)e;

            if (kpea.KeyChar == '\r')
            {
                kpea.Handled = true;
                EnvIpChange(null, null);
            }
        }

        private void RefreshButton_Click(Object sender, EventArgs args)
        {
            RefreshInfoPages();
        }

        #endregion

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public System.Windows.Forms.MenuItem GetNewMenu ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup1\PluginHandler.cs ===
//#define DEBUG_PLUGIN_LOADING

using System;
using System.Reflection;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Utilities;

using STFGui.Plugins;

namespace STFGui
{
    public class GuiPluginHandler : PluginHandler
    {
        STFGuiForm gui;

        /// <summary>
        /// A wrapper around a pluggable item that allows you to find out 
        /// information about what type of item it is
        /// </summary>
        class GuiPluggableItem : PluginHandler.PluggableItem
        {
            /// <summary>
            /// Represents the instance of the actual item.  An instance of a 
            /// class that derives from something we're interested in like 
            /// Plugin, IPluginPreferences, etc. (defined in Plugins.cs)
            /// </summary>
            public override Object Item
            {
                get { return base.Item; }
                set
                {
                    base.Item = value;
                    AsIPluginGui = item as IPluginGui;
                    AsIPluginPreferences = item as IPluginPreferences;
                }
            }

            public bool IsIPluginGui { get { return AsIPluginGui != null; } }
            public bool IsIPluginPreferences { get { return AsIPluginPreferences != null; } }

            /// <summary>
            /// The item represented by this pluggable object as an IPluginGui
            /// </summary>
            public IPluginGui AsIPluginGui = null;
            /// <summary>
            /// The item respreseted by this pluggable object as an IPluginPreferences
            /// </summary>
            public IPluginPreferences AsIPluginPreferences = null;
        }

        //ctor
        public GuiPluginHandler (STFGuiForm mainGui, string[] parametersForPlugins) : base(mainGui.Settings, parametersForPlugins)
        {
            gui = mainGui;
        }

        /// <summary>
        /// Called when the main GUI is initially shown to the user.
        /// </summary>
        public void NotifyGuiShown()
        {
            foreach (GuiPluggableItem item in loadedItems)
            {
                if (item.IsIPluginGui)
                {
                    try
                    {
                        item.AsIPluginGui.OnGuiShown();
                    }
                    catch (Exception e)
                    {
                        ro.Fatal("Failed when calling "+item.FriendlyName+".OnGuiShown() "+e);
                    }
                }
            }
        }

        /// <summary>
        /// Called whenever the gui is wanting to close.
        /// </summary>
        public void NotifyGuiClosing()
        {
            UnloadAllPlugins();
        }

        //creates and sets up a new GuiHooker
        private GuiHooker CreateGuiHooker()
        {
            GuiHooker h=new GuiHooker(gui);
            return h;
        }

        protected override PluggableItem NewPluggableItem ()
        {
            return new GuiPluggableItem();
        }

        protected override IEnumerable<string> GetDefaultPluginsList ()
        {
            string[] files = System.IO.Directory.GetFiles(".", "STFGuiPlugin*.dll");
            foreach (string tryFileWithJunk in files)
            {
                string tryFile = tryFileWithJunk.Substring(2); //strip off ".\\"

                //if we can load the assembly, it's a candidate to search for plugins later
                try
                {
                    Assembly asm = Assembly.ReflectionOnlyLoadFrom(tryFile);
                }
                catch
                {
                    continue;
                }

                yield return tryFile;
            }
        }

        protected override void PreProcessPluggable (PluggableItem item)
        {
            GuiPluggableItem guiItem = (GuiPluggableItem)item;

            //expose data and hooks to the plugin
            if (guiItem.IsIPluginGui)
            {
                guiItem.AsIPluginGui.GuiHooks = CreateGuiHooker();
            }
        }

        protected override void PostSetupProcessPluggable (PluggableItem item)
        {
            GuiPluggableItem guiItem = (GuiPluggableItem)item;

            //setup any gui components it needs
            if (guiItem.IsIPluginGui)
            {
                //add tab page
                try
                {
                    TabPage newTab = guiItem.AsIPluginGui.GetNewTabPage();
                    if (newTab != null)
                    {
                        gui.Tabs.TabPages.Add(newTab);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception adding a tab for pluggable " + item.FriendlyName + ": " + e);
                }

                //add menu
                try
                {
                    MenuItem newMenu = guiItem.AsIPluginGui.GetNewMenu();
                    if (newMenu != null)
                    {
                        gui.Menu.MenuItems.Add(newMenu);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception adding a menu for pluggable " + item.FriendlyName + ": " + e);
                }
            }

            if (guiItem.IsIPluginPreferences)
            {
                Preferences.Current.PreferencePlugins.Add(guiItem.AsIPluginPreferences);
            }
        }
    }

    /// <summary>
    /// This implements the gui's hooks that a plugin can poke at.
    /// </summary>
    public class GuiHooker: MainGuiHooks
    {
        STFGuiForm gui;

        static Report ro=new Report("PluginHandlerHooker");

        public GuiHooker(STFGuiForm mainGui)
        {
            gui=mainGui;
            MainForm=gui;

            //hook into clear output
            bool hooked=false;
            foreach (MenuItem mmi in gui.Menu.MenuItems)
            {
                if (mmi.Text=="Output")
                {
                    foreach (MenuItem imi in mmi.MenuItems)
                    {
                        if (imi.Text=="Clear")
                        {
                            hooked=true;
                            imi.Click+=HandleClearOutput;
                        }
                    }
                }
            }

            if (!hooked)
            {
                ro.Warn("Failed to hook Output.Clear from main menu");
            }
        }

        public override void AddClearOutputHandler(ClearOutputDelegate handler)
        {
            clearOutputEvent+=handler;
        }

        public event ClearOutputDelegate clearOutputEvent;
        private void HandleClearOutput(object s, EventArgs ea)
        {
            if (clearOutputEvent!=null)
            {
                clearOutputEvent();
            }
        }

        public override void LimitOutput(int limit)
        {
            gui.OutputLimit = limit;
        }

        public bool LogToFile
        {
            get
            {
                return gui.LogToFile;
            }

            set
            {
                gui.LogToFile = value;
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup1\Preferences.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using STFGui.Plugins;

namespace STFGui
{
    public partial class Preferences : Form
    {
        private static object initLock = new object();

        private static Preferences current;
        public static Preferences Current
        {
            get
            {
                if (current == null || current.IsDisposed)
                {
                    lock (initLock)
                    {
                        if (current == null || current.IsDisposed)
                        {
                            current = new Preferences();
                        }
                    }
                }

                return current;
            }
        }

        public static void ShowPreferences()
        {
            Current.ShowPreferencesWindow();
        }

        public List<IPluginPreferences> PreferencePlugins = new List<IPluginPreferences>();

        public Preferences()
        {
            this.InitializeComponent();

            this.FormClosing += new FormClosingEventHandler(Preferences_FormClosing);
        }

        void Preferences_FormClosing(object sender, FormClosingEventArgs e)
        {
            // Prevent the user from closing the window, just hide it.
            if (e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                Form f = sender as Form;
                f.Hide();
            }
        }

        private void applyButton_Click(object sender, EventArgs e)
        {
            this.ApplyPreferences();
            this.Hide();
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            this.InitializePreferenceTabs();
            this.Hide();
        }

        public void AddTabForObject(String name, ICloneable preferencesObject)
        {
            PreferencesTab tab = null;
            if (this.preferencesTabControl.TabPages.ContainsKey(name))
            {
                tab = this.preferencesTabControl.TabPages[name] as PreferencesTab;
                tab.PreferencesObject = preferencesObject;
            }
            else
            {
                tab = new PreferencesTab(name, preferencesObject);
                this.preferencesTabControl.TabPages.Add(tab);

            }
        }


        private void ShowPreferencesWindow()
        {
            InitializePreferenceTabs();
            Show();
            Activate();
        }

        private void InitializePreferenceTabs()
        {
            foreach (IPluginPreferences prefPlugin in PreferencePlugins)
            {
                AddTabForObject(
                    prefPlugin.GetType().Name,
                    prefPlugin.PluginPreferences.Clone() as ICloneable);
            }
        }

        private void ApplyPreferences()
        {
            // Get all the preference objects and save them
            foreach (IPluginPreferences prefPlugin in PreferencePlugins)
            {
                String prefName = prefPlugin.GetType().Name;
                PreferencesTab tab = preferencesTabControl.TabPages[prefName] as PreferencesTab;

                prefPlugin.PluginPreferences = tab.PreferencesObject;
            }
        }
    }

    public class PreferencesTab : TabPage
    {
        private PropertyGrid tabPropertyGrid;

        public ICloneable PreferencesObject
        {
            get { return tabPropertyGrid.SelectedObject as ICloneable; }
            set { tabPropertyGrid.SelectedObject = value; }
        }

        public PreferencesTab()
        {
            tabPropertyGrid = new PropertyGrid();

            this.Padding = new Padding(5);
            this.Controls.Add(tabPropertyGrid);

            this.tabPropertyGrid.Dock = DockStyle.Fill;
        }

        public PreferencesTab(String preferencesName, Object preferencesObject)
            : this()
        {
            this.Text = preferencesObject.GetType().Name;
            this.Name = preferencesName;
            this.tabPropertyGrid.SelectedObject = preferencesObject;
        }

        public PreferencesTab(Object preferencesObject)
            : this(preferencesObject.GetType().Name, preferencesObject)
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup1\Preferences.Designer.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace STFGui
{
    public partial class Preferences : Form
    {
        private Button applyButton;
        private Button cancelButton;
        private TabControl preferencesTabControl;
        private Panel buttonsPanel;

        public void InitializeComponent()
        {
            this.buttonsPanel = new System.Windows.Forms.Panel();
            this.applyButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.preferencesTabControl = new System.Windows.Forms.TabControl();
            this.buttonsPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // buttonsPanel
            // 
            this.buttonsPanel.Controls.Add(this.applyButton);
            this.buttonsPanel.Controls.Add(this.cancelButton);
            this.buttonsPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.buttonsPanel.Location = new System.Drawing.Point(5, 368);
            this.buttonsPanel.Name = "buttonsPanel";
            this.buttonsPanel.Size = new System.Drawing.Size(581, 29);
            this.buttonsPanel.TabIndex = 0;
            // 
            // applyButton
            // 
            this.applyButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.applyButton.Location = new System.Drawing.Point(425, 6);
            this.applyButton.Name = "applyButton";
            this.applyButton.Size = new System.Drawing.Size(75, 23);
            this.applyButton.TabIndex = 1;
            this.applyButton.Text = "Apply";
            this.applyButton.UseVisualStyleBackColor = true;
            this.applyButton.Click += new System.EventHandler(this.applyButton_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(506, 6);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(75, 23);
            this.cancelButton.TabIndex = 0;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            // 
            // preferencesTabControl
            // 
            this.preferencesTabControl.Dock = System.Windows.Forms.DockStyle.Fill;
            this.preferencesTabControl.Location = new System.Drawing.Point(5, 5);
            this.preferencesTabControl.Name = "preferencesTabControl";
            this.preferencesTabControl.SelectedIndex = 0;
            this.preferencesTabControl.Size = new System.Drawing.Size(581, 363);
            this.preferencesTabControl.TabIndex = 1;
            // 
            // Preferences
            // 
            this.AcceptButton = this.applyButton;
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(591, 402);
            this.Controls.Add(this.preferencesTabControl);
            this.Controls.Add(this.buttonsPanel);
            this.Name = "Preferences";
            this.Padding = new System.Windows.Forms.Padding(5);
            this.Text = "Preferences";
            this.buttonsPanel.ResumeLayout(false);
            this.ResumeLayout(false);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup2\Main.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;

using ServerTestFramework;

namespace STFGui
{
    public class MainApp
    {
        [Flags]
        public enum STFGuiExitCode
        {
            OK               = 0, //we loaded ok
            LoadError        = 1, //errors loading a module specified on the commandline
            GuiParamError    = 2, //problem with a commandline parameter targetted at STFGui itself
            PluginParamError = 4  //problem with a commandline paramater targetted at a plugin (not currently set)
        }

        //entry point
        [STAThreadAttribute]
        static void Main(string[] args)
        {
            // Pretty it up :)  (down! This may break some ui formatting on vista, be careful)
            Application.EnableVisualStyles();

            //Look through parameters and sort them into their relevent buckets
            List<string> paramsForMainGui = new List<string>();
            List<string> paramsForPlugins = new List<string>();
            List<string> paramsToLoad = new List<string>();

            foreach (string param in args)
            {
                string paramLower = param.ToLower();

                if (paramLower.StartsWith("-plugparam:")) //parameter for a plugin
                {
                    paramsForPlugins.Add(param.Substring(11));
                }
                else if (!param.StartsWith("-") && param.EndsWith(".dll")) //module to load
                {
                    paramsToLoad.Add(param);
                }
                else if (!param.StartsWith("-") && param.EndsWith(".xml")) //TODO: Temporary special case here to ignore xml files... since since our old live-specific code still directly relies on parsing xml files from the commandline itself.  That needs updated someday.
                {
                    //ignoring it
                }
                else if (paramLower == "-breakonstart")
                {
                    System.Diagnostics.Debugger.Launch();
                    //System.Diagnostics.Debugger.Break();
                }
                else //parameter for stfgui itself
                {
                    paramsForMainGui.Add(param);
                }
            }

            //Create the main gui and set it up
            System.Environment.ExitCode = (int)STFGuiExitCode.OK; //default to good state
            STFGuiForm gui = new STFGuiForm();

            System.Environment.ExitCode |= (int)gui.Init(paramsForMainGui.ToArray(), paramsForPlugins.ToArray());

            //Load suites and plugins passed on the commandline
            foreach (string fname in paramsToLoad)
            {
                if (!gui.LoadModule(fname))
                {
                    System.Environment.ExitCode |= (int)STFGuiExitCode.LoadError;
                }
            }

            //Block here until the form is closed
            gui.ShowDialog();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup2\PluginHandler.cs ===
//#define DEBUG_PLUGIN_LOADING

using System;
using System.Reflection;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Utilities;

using STFGui.Plugins;

namespace STFGui
{
    public class GuiPluginHandler : PluginHandler
    {
        STFGuiForm gui;

        /// <summary>
        /// A wrapper around a pluggable item that allows you to find out 
        /// information about what type of item it is
        /// </summary>
        class GuiPluggableItem : PluginHandler.PluggableItem
        {
            /// <summary>
            /// Represents the instance of the actual item.  An instance of a 
            /// class that derives from something we're interested in like 
            /// Plugin, IPluginPreferences, etc. (defined in Plugins.cs)
            /// </summary>
            public override Object Item
            {
                get { return base.Item; }
                set
                {
                    base.Item = value;
                    AsIPluginGui = item as IPluginGui;
                    AsIPluginPreferences = item as IPluginPreferences;
                }
            }

            public bool IsIPluginGui { get { return AsIPluginGui != null; } }
            public bool IsIPluginPreferences { get { return AsIPluginPreferences != null; } }

            /// <summary>
            /// The item represented by this pluggable object as an IPluginGui
            /// </summary>
            public IPluginGui AsIPluginGui = null;
            /// <summary>
            /// The item respreseted by this pluggable object as an IPluginPreferences
            /// </summary>
            public IPluginPreferences AsIPluginPreferences = null;
        }

        //ctor
        public GuiPluginHandler (STFGuiForm mainGui, string[] parametersForPlugins) : base(mainGui.Settings, parametersForPlugins)
        {
            gui = mainGui;
        }

        /// <summary>
        /// Called when the main GUI is initially shown to the user.
        /// </summary>
        public void NotifyGuiShown()
        {
            foreach (GuiPluggableItem item in loadedItems)
            {
                if (item.IsIPluginGui)
                {
                    try
                    {
                        item.AsIPluginGui.OnGuiShown();
                    }
                    catch (Exception e)
                    {
                        ro.Fatal("Failed when calling "+item.FriendlyName+".OnGuiShown() "+e);
                    }
                }
            }
        }

        /// <summary>
        /// Called whenever the gui is wanting to close.
        /// </summary>
        public void NotifyGuiClosing()
        {
            UnloadAllPlugins();
        }

        //creates and sets up a new GuiHooker
        private GuiHooker CreateGuiHooker()
        {
            GuiHooker h=new GuiHooker(gui);
            return h;
        }

        protected override PluggableItem NewPluggableItem ()
        {
            return new GuiPluggableItem();
        }

        protected override IEnumerable<string> GetDefaultPluginsList ()
        {
            string[] files = System.IO.Directory.GetFiles(".", "STFGuiPlugin*.dll");
            foreach (string tryFileWithJunk in files)
            {
                string tryFile = tryFileWithJunk.Substring(2); //strip off ".\\"

                //if we can load the assembly, it's a candidate to search for plugins later
                try
                {
                    Assembly asm = Assembly.ReflectionOnlyLoadFrom(tryFile);
                }
                catch
                {
                    continue;
                }

                yield return tryFile;
            }
        }

        protected override void PreProcessPluggable (PluggableItem item)
        {
            GuiPluggableItem guiItem = (GuiPluggableItem)item;

            //expose data and hooks to the plugin
            if (guiItem.IsIPluginGui)
            {
                guiItem.AsIPluginGui.GuiHooks = CreateGuiHooker();
            }
        }

        protected override void PostSetupProcessPluggable (PluggableItem item)
        {
            GuiPluggableItem guiItem = (GuiPluggableItem)item;

            //setup any gui components it needs
            if (guiItem.IsIPluginGui)
            {
                //add tab page
                try
                {
                    TabPage newTab = guiItem.AsIPluginGui.GetNewTabPage();
                    if (newTab != null)
                    {
                        gui.Tabs.TabPages.Add(newTab);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception adding a tab for pluggable " + item.FriendlyName + ": " + e);
                }

                //add menu
                try
                {
                    MenuItem newMenu = guiItem.AsIPluginGui.GetNewMenu();
                    if (newMenu != null)
                    {
                        gui.Menu.MenuItems.Add(newMenu);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception adding a menu for pluggable " + item.FriendlyName + ": " + e);
                }
            }

            if (guiItem.IsIPluginPreferences)
            {
                Preferences.Current.PreferencePlugins.Add(guiItem.AsIPluginPreferences);
            }
        }
    }

    /// <summary>
    /// This implements the gui's hooks that a plugin can poke at.
    /// </summary>
    public class GuiHooker: MainGuiHooks
    {
        STFGuiForm gui;

        static Report ro=new Report("PluginHandlerHooker");

        public GuiHooker(STFGuiForm mainGui)
        {
            gui=mainGui;
            MainForm=gui;

            //hook into clear output
            bool hooked=false;
            foreach (MenuItem mmi in gui.Menu.MenuItems)
            {
                if (mmi.Text=="Output")
                {
                    foreach (MenuItem imi in mmi.MenuItems)
                    {
                        if (imi.Text=="Clear")
                        {
                            hooked=true;
                            imi.Click+=HandleClearOutput;
                        }
                    }
                }
            }

            if (!hooked)
            {
                ro.Warn("Failed to hook Output.Clear from main menu");
            }
        }

        public override void AddClearOutputHandler(ClearOutputDelegate handler)
        {
            clearOutputEvent+=handler;
        }

        public event ClearOutputDelegate clearOutputEvent;
        private void HandleClearOutput(object s, EventArgs ea)
        {
            if (clearOutputEvent!=null)
            {
                clearOutputEvent();
            }
        }

        public override void LimitOutput(int limit)
        {
            gui.OutputLimit = limit;
        }

        public bool LogToFile
        {
            get
            {
                return gui.LogToFile;
            }

            set
            {
                gui.LogToFile = value;
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\Plugins\FunctionalRunner\FuncTree.cs ===
//#define DEBUG_NODE_DATA

using System;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Text;
using System.Collections.Generic;
using System.Security.Permissions;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;

namespace STFGui.Plugins
{
    /// <summary>
    /// A single functional node in the tree.
    /// All nodes added to this can be assumed to have functional data.
    /// </summary>
    public class FuncTreeNode: TreeNode
    {
        Report ro=null;

        //The TestNode that this node of the tree represents
        public TestNode LinkedTestNode
        {
            get {return testNode;}
        }
        TestNode testNode;

        private FunctionalPlugin functionalPlugin;

        //Extra run-time information about the node (such as exceptions it failed with)
        public string ExtraDescription="";

        //How the node's run state can be represented in the tree.
        public enum VisualRunState
        {
            NotRun,
            PreRunning,
            PostRunning,
            Running,
            Passed,
            PreFailed,
            Failed,
            PassedButPostFailed,
            Timeout
        }
        public VisualRunState RunState=VisualRunState.NotRun;
        public int PassCount=0;
        public int TotalCount=0;
        public int FailedWithBugCount=0;

        // --
        //ctor
        public FuncTreeNode(TestNode node, bool addChildren, FunctionalPlugin containedFunctionalPlugin, FuncTreeView treeViewContaining)
        {
            ro=treeViewContaining.ro;
            testNode=node;
            functionalPlugin=containedFunctionalPlugin;

            if (addChildren)
            {
                foreach (TestNode child in node.Children)
                {
                    if (child.FunctionalData!=null)
                    {
                        Nodes.Add(new FuncTreeNode(child, true, functionalPlugin, treeViewContaining));
                    }
                }
            }

            UpdateNodeVisuals();
        }

        /// <summary>
        /// Uses the scheduler data to set what the VisualRunState should be, as well as the values 
        /// of the PassCount and TotalCount fields.
        /// </summary>
        public void UpdateRunState()
        {
            FunctionalSchedulerNodeData schedulerData = this.LinkedTestNode.FunctionalData.SchedulerData;

            RunState = VisualRunState.NotRun;
            if (schedulerData != null)
            {
                if (schedulerData.NumberFailed >= 1 || schedulerData.RunResult == TEST_RESULTS.FAILED)
                {
                    RunState = VisualRunState.Failed;
                    FailedWithBugCount = schedulerData.NumberFailedWithBug;
                }

                if (schedulerData.NumberPreFailed >= 1)
                {
                    if (schedulerData.RunResult == TEST_RESULTS.FAILED && schedulerData.NumberTotal > 0 && LinkedTestNode.ChildrenCount > 0)
                        RunState = VisualRunState.Failed;
                    else
                        RunState = VisualRunState.PreFailed;
                }
                else if (schedulerData.NumberTimeOutFailed >= 1 && schedulerData.NumberFailed == 0)
                    RunState = VisualRunState.Timeout;
                else if (schedulerData.NumberPostFailed >= 1 && schedulerData.NumberFailed == 0)
                    RunState = VisualRunState.PassedButPostFailed;
                else if (schedulerData.IsPrerunning)
                    RunState = VisualRunState.PreRunning;
                else if (schedulerData.IsPostrunning)
                    RunState = VisualRunState.PostRunning;
                else if (schedulerData.InProgress == true && schedulerData.EndTime == DateTime.MaxValue)
                    RunState = VisualRunState.Running;
                else if (schedulerData.RunResult == TEST_RESULTS.PASSED)
                    RunState = VisualRunState.Passed;

                PassCount = schedulerData.NumberPassed;
                TotalCount = schedulerData.NumberTotal;
            }
        }

        //Rebuilds the Text and other visual properties of the node
        public void UpdateNodeVisuals()
        {
            UpdateRunState();

            //rebuild Text
            string newText="";
            if (testNode.ChildrenCount>0)
            {
                newText="["+PassCount+"/"+TotalCount+"] ";
            }
            newText+=testNode.Name;

            if (testNode.FunctionalData.AtomicGroup && testNode.ChildrenCount>0)
            {
                newText+="  (Atomic Branch)";
            }

            if (testNode.FunctionalData.BugID!=0)
            {
                newText += "  (BugID: " + 
                    (testNode.FunctionalData.BugDatabase == null ? "" : testNode.FunctionalData.BugDatabase + " ")
                    + testNode.FunctionalData.BugID + ")";
            }

            int ag=testNode.FunctionalData.AsyncGroup;
            if (ag!=0)
            {
                newText+="  (AsyncGroup: "+ag+")";
            }

            if (testNode.FunctionalData.Dependencies.Count!=0)
            {
                newText+="  (Depends: ";
                for (int i=0; i<testNode.FunctionalData.Dependencies.Count; ++i)
                {
                    if (i!=0) newText+=", ";
                    newText+=testNode.FunctionalData.Dependencies[i];
                }
                newText+=")";
            }

            //tags
            Dictionary<string, NodeTaggingData.ValueSet> tagList;
            if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.Node)
            {
                tagList=testNode.TaggingData.GetNodeTags();
            }
            else if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.NodeParents)
            {
                tagList=testNode.TaggingData.GetAllTrunkTags();
            }
            else if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.NodeChildren)
            {
                tagList=testNode.TaggingData.GetAllBranchTags();
            }
            else if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.NodeParentsChildren)
            {
                tagList=testNode.TaggingData.GetAllTreeTags();
            }
            else if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.NodeNearestParent)
            {
                tagList=testNode.TaggingData.GetNearestTrunkTags();
            }
            else //TagVisibilityStates.Hide
            {
                tagList=new Dictionary<string, NodeTaggingData.ValueSet>();
            }

            foreach (string tagName in tagList.Keys)
            {
                newText+="  ["+tagName;
                NodeTaggingData.ValueSet tagValues=tagList[tagName];
                if (tagValues.Count>0)
                {
                    newText+=": ";
                    newText+=ServerTestFramework.Utilities.StringUtils.MakeCommaSeparatedList(tagValues);
                }
                newText+="]";
            }

            if (testNode.ChildrenCount == 0 && testNode.FunctionalData.Timeout != System.Threading.Timeout.Infinite)
            {
                newText += " {Timeout: " + testNode.FunctionalData.Timeout + "}";
            }

            if (newText!=Text)
            {
                Text=newText;
            }

            //tooltip
            string newTipText = testNode.Desc ?? "";
            if (ExtraDescription.Length!=0)
            {
                if (newTipText.Length>0) newTipText+="\n";
                newTipText+=ExtraDescription;
            }

            if (newTipText.Length > 1024)
            {
                newTipText = newTipText.Substring(0, 1024) + "...";
            }

            if (newTipText!=ToolTipText)
            {
                ToolTipText=newTipText.Replace("\0", "");
            }

            //color of the text
            Color fgColor=(testNode.FunctionalData.Ignored?Color.Gray:Color.Black);

            if (ForeColor!=fgColor)
            {
                ForeColor=fgColor;
            }

            //bgcolor
            Color bgc=Color.White;
            if (RunState==VisualRunState.Running) bgc=Color.FromArgb(unchecked((int)0xffbbbbbb));
            else if (RunState==VisualRunState.PreRunning) bgc=Color.FromArgb(unchecked((int)0xffdddddd));
            else if (RunState==VisualRunState.PostRunning) bgc=Color.FromArgb(unchecked((int)0xff888888));
            else if (RunState==VisualRunState.Passed) bgc=Color.LightGreen;
            else if (RunState==VisualRunState.Failed)
            {
                if ((FailedWithBugCount!=0)&&(TotalCount-PassCount==FailedWithBugCount))
                {
                    bgc=Color.Yellow;
                }
                else
                {
                    bgc=Color.Red;
                }
            }
            else if (RunState==VisualRunState.PreFailed) bgc=Color.SandyBrown;
            else if (RunState==VisualRunState.PassedButPostFailed) bgc=Color.LightSeaGreen;
            else if (RunState == VisualRunState.Timeout) bgc = Color.Purple;

            FuncTreeView tvOwner = null;
            if (this.TreeView is FuncTreeView)
                tvOwner = ((FuncTreeView)this.TreeView);

            //Check if sticky colors is on, and if the case wasn't touched on this run. If both are true, keep the old color.
            bool keepColor = (tvOwner != null && tvOwner.StickyColors) && RunState == VisualRunState.NotRun;

            if (BackColor!=bgc && !keepColor)
            {
                BackColor=bgc;
            }

            //
            if (Checked!=testNode.FunctionalData.Enabled)
            {
                Checked=testNode.FunctionalData.Enabled;
            }
        }

        //update the visuals of this node and all children
        public void UpdateTreeVisuals()
        {
            UpdateNodeVisuals();

            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.UpdateTreeVisuals();
            }
        }

        //Updates my check box and my children's to reflect the current state of the tree
        public void UpdateCheckBoxes()
        {
            Checked=testNode.FunctionalData.Enabled;

            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.UpdateCheckBoxes();
            }
        }

        //resets the state of all nodes to "not run"
        public void ResetRunState()
        {
            FunctionalSchedulerNodeData schedulerData = null;
            if (LinkedTestNode.FunctionalData != null)
                schedulerData = this.LinkedTestNode.FunctionalData.SchedulerData;

            if (ExtraDescription!="" || PassCount!=0 || TotalCount!=0 || RunState!=VisualRunState.NotRun)
            {
                ExtraDescription="";
                PassCount=0;
                TotalCount=0;
                FailedWithBugCount=0;
                RunState=VisualRunState.NotRun;
                UpdateNodeVisuals();
            }

            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ResetRunState();
            }
        }

        public delegate void ApplyToNodeDelegate(FuncTreeNode ftn, bool result);

        public void ProcessExpression(NodeTaggingData.Expression expression, ApplyToNodeDelegate applyEffect)
        {
            //do me
            try
            {
                bool result=expression.EvaluateBool(LinkedTestNode);

                applyEffect(this, result);
            }
            catch (NodeTaggingData.ExpressionEvaluationException iee)
            {
                ToolTipText=iee.ToString();
                BackColor=Color.PaleVioletRed;
            }
            catch (System.Exception e)
            {
                ToolTipText="Unexpected exception evaluating expression:\n"+e.ToString();
                BackColor=Color.HotPink;
            }

            //do my children
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, applyEffect);
            }
        }

        //finds the node that should handle this event and handles it.  returns true if handled.
        //nameparts is the seperated node names for the target node
        public bool HandleTestEvent(TestEventArgs e, string []nameParts, int partsIndex)
        {
            //determine if this event is targetted at me
            if (testNode.Name==nameParts[partsIndex])
            {
                //if there's more parts to it after that, it's targetted at my children
                if (partsIndex<nameParts.Length-1)
                {
                    foreach (TreeNode tnbase in Nodes)
                    {
                        FuncTreeNode tn=(FuncTreeNode)tnbase;
                        if (tn.HandleTestEvent(e, nameParts, partsIndex+1))
                        {
                            return true;
                        }
                    }
                }
                else //targetted specifically at me
                {
                    bool useForToolTip=false;
                    switch(e.Action)
                    {
                    case TestAction.Ignore:
                    case TestAction.Pass:
                    case TestAction.PreFail:
                    case TestAction.Fail:
                    case TestAction.PostFail:
                    case TestAction.Timeout:
                        useForToolTip=true;
                        break;
                    }

                    for (FuncTreeNode pn=(FuncTreeNode)Parent; pn!=null; pn=(FuncTreeNode)pn.Parent)
                        pn.UpdateNodeVisuals();

                    //update tooltip text that holds the result
                    if (useForToolTip)
                    {
                        if (!String.IsNullOrEmpty(e.Details))
                            ExtraDescription +=  (!String.IsNullOrEmpty(ExtraDescription)) ? "\n" + e.Details : e.Details;

                        if (!String.IsNullOrEmpty(e.Message))
                            ExtraDescription += (!String.IsNullOrEmpty(ExtraDescription)) ? "\n" + e.Message : e.Message;

                        if (!String.IsNullOrEmpty(e.Stack))
                            ExtraDescription += (!String.IsNullOrEmpty(ExtraDescription)) ? "\n" + e.Stack : e.Stack;
                    }

                    UpdateNodeVisuals();

                    return true;
                }
            }

            return false;
        }

        //retrieves a flattened list of all leaf nodes
        public void GetLeafNodes(ref List<FuncTreeNode> leafNodes)
        {
            if (Nodes.Count==0)
            {
                leafNodes.Add(this);
            }
            else
            {
                foreach (TreeNode tnbase in Nodes)
                {
                    FuncTreeNode tn=(FuncTreeNode)tnbase;
                    tn.GetLeafNodes(ref leafNodes);
                }
            }
        }

        //retrieves a flattened list of all nodes
        public void GetFlattenedSubtree(ref List<FuncTreeNode> allNodes)
        {
            allNodes.Add(this);
            if (Nodes.Count != 0)
            {
                foreach (TreeNode tnbase in Nodes)
                {
                    FuncTreeNode tn = (FuncTreeNode)tnbase;
                    tn.GetFlattenedSubtree(ref allNodes);
                }
            }
        }
    };

    /// <summary>
    /// The functional test tree view.
    /// </summary>
    public class FuncTreeView: TreeView, TestEventListener
    {
        public Report ro=new Report("FuncPlugin");

        Form guiForm;
        FunctionalPlugin functionalPlugin;
        bool stickyColors = false;
        public delegate void InvokeCode();

        private System.Windows.Forms.Timer testEventUpdateTimer=new System.Windows.Forms.Timer();
        private volatile System.Collections.Generic.List<TestEventArgs> testEventQueuePending=new System.Collections.Generic.List<TestEventArgs>();
        private volatile System.Collections.Generic.List<TestEventArgs> testEventQueueProcessing=new System.Collections.Generic.List<TestEventArgs>();
        private object testEventQueueLock=new object();
        private object testEventProcessLock=new object();

        public bool StickyColors
        {
            get { return stickyColors; }
            set { stickyColors = value; }
        }

        //ctor
        public FuncTreeView(Form ownerForm, FunctionalPlugin ownerFuncPlugin): base()
        {
            //
            CheckBoxes=true;
            ShowNodeToolTips=true;
            guiForm=ownerForm;
            functionalPlugin=ownerFuncPlugin;

            //hook up events
            AfterCheck+=Event_AfterCheck;
            MouseDown+=Event_MouseDown;

            //add context menu
            ContextMenu=new ContextMenu();
            ContextMenu.Popup+=ContextHandler;

            //start the event process timer
            testEventUpdateTimer.Interval=50;
            testEventUpdateTimer.Tick+=new EventHandler(TestEventUpdateTimer);
            testEventUpdateTimer.Start();
        }

        //Adds a tree of TestNodes to the tree view.
        public void AddTestTree(TestNode root)
        {
            if (root.FunctionalData==null)
            {
                return;
            }

            BeginUpdate();
            FuncTreeNode newNode=new FuncTreeNode(root, true, functionalPlugin, this);
            Nodes.Add(newNode);
            newNode.Expand();
            UpdateAllCheckBoxes();
            EndUpdate();
        }

        //Remove a tree of TestNodes to the tree view.
        public void RemoveTestTree(TestNode root)
        {
            BeginUpdate();
            foreach (FuncTreeNode n in Nodes)
            {
                if (n.LinkedTestNode==root)
                {
                    Nodes.Remove(n);
                    break;
                }
            }
            EndUpdate();
        }

        //Called when a check box changes state
        private void Event_AfterCheck(object sender, TreeViewEventArgs e)
        {
            if(e.Action!=TreeViewAction.Unknown) //only if the user caused the change
            {
                //update the functional data
                FuncTreeNode node=(FuncTreeNode)e.Node;
                node.LinkedTestNode.FunctionalData.Enabled=node.Checked;

                UpdateAllCheckBoxes();
            }
        }

        //refresh the text of all nodes in the tree
        public void RefreshAllNodeVisuals()
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.UpdateTreeVisuals();
            }
            EndUpdate();
        }

        //update all check boxes in the tree to reflect the state of the nodes
        public void UpdateAllCheckBoxes()
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.UpdateCheckBoxes();
            }
            EndUpdate();
        }

        //resets the state of all nodes to "not run"
        public void ResetRunState()
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ResetRunState();
            }
            EndUpdate();
        }

        public void HighlightExpression(NodeTaggingData.Expression expression)
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, delegate(FuncTreeNode ftn, bool result){ftn.BackColor=(result?Color.Chartreuse:Color.Bisque);});
                //tree visuals will override the color change, so we don't do it in this case
            }
            EndUpdate();
        }

        public void EnableExpression(NodeTaggingData.Expression expression)
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, delegate(FuncTreeNode ftn, bool result){if (result && ftn.LinkedTestNode.FunctionalData!=null) {ftn.LinkedTestNode.FunctionalData.Enabled=true;}});
                tn.UpdateTreeVisuals();
            }
            EndUpdate();
        }

        public void IgnoreExpression(NodeTaggingData.Expression expression)
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, delegate(FuncTreeNode ftn, bool result){if (result && ftn.LinkedTestNode.FunctionalData!=null) {ftn.LinkedTestNode.FunctionalData.Ignored=true;}});
                tn.UpdateTreeVisuals();
            }
            EndUpdate();
        }

        public void UnignoreExpression(NodeTaggingData.Expression expression)
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, delegate(FuncTreeNode ftn, bool result){if (result && ftn.LinkedTestNode.FunctionalData!=null) {ftn.LinkedTestNode.FunctionalData.Ignored=false;}});
                tn.UpdateTreeVisuals();
            }
            EndUpdate();
        }

        //retrieves a flattened list of all leaf nodes
        public void GetLeafNodes(ref List<FuncTreeNode> leafNodes)
        {
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.GetLeafNodes(ref leafNodes);
            }
        }

        //retrieves a flattened list of all nodes
        public void GetFlattenedSubtree(ref List<FuncTreeNode> allNodes)
        {
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn = (FuncTreeNode)tnbase;
                tn.GetFlattenedSubtree(ref allNodes);
            }
        }

        //prevent expanding/collapsing by double click -- is there a better way?
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m)
        {
            if (m.Msg==515) //double click
            {
                if (CustomDoubleClick!=null)
                {
                    CustomDoubleClick();
                }
            }
            else
            {
                base.WndProc(ref m);
            }
        }
        public delegate void VoidCall();
        public event VoidCall CustomDoubleClick;

        #region Events

        public delegate void OnTestEventDelegate(TestEventArgs e);

        //called whenever test events occur
        public void OnTestEvent(TestEventArgs e)
        {
            //.NET has some horrible horrible rendering performance problems when ui elemnts are update sporatically in fast succession.
            //To work around that, we will queue the events up and process them in batches on a fast timer
            lock (testEventQueueLock)
            {
                testEventQueuePending.Add(e);
            }
        }

        //processes all queue'd test events
        private void TestEventUpdateTimer(object obj, EventArgs ignoredEa)
        {
            lock (testEventProcessLock) //don't think this is needed, but just in case
            {
                //swap the pending and processing buffers
                lock (testEventQueueLock)
                {
                    System.Collections.Generic.List<TestEventArgs> temp=testEventQueueProcessing;
                    testEventQueueProcessing=testEventQueuePending;
                    testEventQueuePending=temp;
                    testEventQueuePending.Clear();
                }

                //process the batch
                if (testEventQueueProcessing.Count>0)
                {
                    if (InvokeRequired)
                    {
                        this.Invoke(new InvokeCode(delegate
                        {
                            HandleTestEventBatch(testEventQueueProcessing);
                        }));
                    }
                    else
                    {
                        HandleTestEventBatch(testEventQueueProcessing);
                    }
                }
            }
        }

        private void HandleTestEventBatch(System.Collections.Generic.List<TestEventArgs> batchEvents)
        {
            BeginUpdate();

            foreach (TestEventArgs e in batchEvents)
            {
                if (e.Action==TestAction.StartAll)
                {
                    ResetRunState();
                }
                else
                {
                    if (e.Node!=null)
                    {
                        string[] nodeNameParts=e.Node.FullName.Split(new char[]{'.'});

                        foreach (TreeNode tnbase in Nodes)
                        {
                            FuncTreeNode tn=(FuncTreeNode)tnbase;
                            bool handled=tn.HandleTestEvent(e, nodeNameParts, 0);
                            if (handled)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            EndUpdate();
        }

        //context menu handler
        private void ContextHandler(object sender, EventArgs e)
        {
            //wipe out old options
            Menu.MenuItemCollection mi=ContextMenu.MenuItems;
            mi.Clear();

            //
            if (SelectedNode==null)
            {
                return;
            }
            FuncTreeNode node=(FuncTreeNode)SelectedNode;

            //add the options
            mi.Add("View Output", CtxMenu_ViewOutput);
            mi.Add("Toggle Ignored", CtxMenu_ToggleIgnore);
            mi.Add(new MenuItem("-"));
            mi.Add("Set AsyncGroup", CtxMenu_ChangeAsyncGroup);
            if (node.LinkedTestNode.ChildrenCount>0)
            {
                mi.Add("Set Children's Default AsyncGroup", CtxMenu_ChangeChildAsyncGroup);
            }

            //do callbacks for adding extra options and set those up
            List<FunctionalPlugin.TestNodeContextMenuItem> extraItems=new List<FunctionalPlugin.TestNodeContextMenuItem>();
            functionalPlugin.DoBuildNodeContextMenuItems(node.LinkedTestNode, extraItems);
            foreach (FunctionalPlugin.TestNodeContextMenuItem cmi in extraItems)
            {
                MenuItem realMi=new MenuItem();
                realMi.Text=cmi.Text;
                realMi.Tag=cmi;
                realMi.Click+=CtxMenu_Extras;
                mi.Add(realMi);
            }

#if DEBUG_NODE_DATA
            mi.Add(new MenuItem("-"));
            mi.Add("DEBUG - Print Scheduler Data", CtxMenu_DebugPrintSchedulerData);
#endif
        }

        //context menu handler
        private void CtxMenu_ViewOutput(object sender, EventArgs args)
        {
            if (CustomDoubleClick!=null)
            {
                CustomDoubleClick();
            }
        }

        //context menu handler
        private void CtxMenu_Extras(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;

            MenuItem wrapperMi=(MenuItem)sender;
            FunctionalPlugin.TestNodeContextMenuItem realMi=(FunctionalPlugin.TestNodeContextMenuItem)wrapperMi.Tag;

            realMi.InvokeClick(realMi, node.LinkedTestNode);
        }

        //context menu handler
        private void CtxMenu_ToggleIgnore(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;
            node.LinkedTestNode.FunctionalData.Ignored=!node.LinkedTestNode.FunctionalData.Ignored;
            node.UpdateNodeVisuals();
        }

        //context menu handler
        private void CtxMenu_ChangeAsyncGroup(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;

            int asyncVal=node.LinkedTestNode.FunctionalData.DirectAsyncGroup;
            asyncVal=GuiCommon.GetNumberFromUser(guiForm, "AsyncGroup", asyncVal);
            node.LinkedTestNode.FunctionalData.DirectAsyncGroup=asyncVal;

            node.UpdateNodeVisuals();
        }

        //context menu handler
        private void CtxMenu_ChangeChildAsyncGroup(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;

            int asyncVal=node.LinkedTestNode.FunctionalData.ChildrenAsyncGroupDefault;
            asyncVal=GuiCommon.GetNumberFromUser(guiForm, "Children's Default AsyncGroup", asyncVal);
            node.LinkedTestNode.FunctionalData.ChildrenAsyncGroupDefault=asyncVal;

            node.UpdateNodeVisuals();
            foreach (FuncTreeNode child in node.Nodes)
            {
                child.UpdateNodeVisuals();
            }
        }

#if DEBUG_NODE_DATA
        private void CtxMenu_DebugPrintSchedulerData(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;
            TestNode tn=node.LinkedTestNode;
            ro.Debug("Scheduler data for "+tn.FullName+":\n"+tn.FunctionalData.SchedulerData);
        }
#endif

        //change the selected node anytime they click on a node in any way
        private void Event_MouseDown(object sender, MouseEventArgs e)
        {
            FuncTreeNode node=(FuncTreeNode)this.GetNodeAt(e.X, e.Y);
            SelectedNode=node;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup2\Preferences.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using STFGui.Plugins;

namespace STFGui
{
    public partial class Preferences : Form
    {
        private static object initLock = new object();

        private static Preferences current;
        public static Preferences Current
        {
            get
            {
                if (current == null || current.IsDisposed)
                {
                    lock (initLock)
                    {
                        if (current == null || current.IsDisposed)
                        {
                            current = new Preferences();
                        }
                    }
                }

                return current;
            }
        }

        public static void ShowPreferences()
        {
            Current.ShowPreferencesWindow();
        }

        public List<IPluginPreferences> PreferencePlugins = new List<IPluginPreferences>();

        public Preferences()
        {
            this.InitializeComponent();

            this.FormClosing += new FormClosingEventHandler(Preferences_FormClosing);
        }

        void Preferences_FormClosing(object sender, FormClosingEventArgs e)
        {
            // Prevent the user from closing the window, just hide it.
            if (e.CloseReason == CloseReason.UserClosing)
            {
                e.Cancel = true;
                Form f = sender as Form;
                f.Hide();
            }
        }

        private void applyButton_Click(object sender, EventArgs e)
        {
            this.ApplyPreferences();
            this.Hide();
        }

        private void cancelButton_Click(object sender, EventArgs e)
        {
            this.InitializePreferenceTabs();
            this.Hide();
        }

        public void AddTabForObject(String name, ICloneable preferencesObject)
        {
            PreferencesTab tab = null;
            if (this.preferencesTabControl.TabPages.ContainsKey(name))
            {
                tab = this.preferencesTabControl.TabPages[name] as PreferencesTab;
                tab.PreferencesObject = preferencesObject;
            }
            else
            {
                tab = new PreferencesTab(name, preferencesObject);
                this.preferencesTabControl.TabPages.Add(tab);

            }
        }


        private void ShowPreferencesWindow()
        {
            InitializePreferenceTabs();
            Show();
            Activate();
        }

        private void InitializePreferenceTabs()
        {
            foreach (IPluginPreferences prefPlugin in PreferencePlugins)
            {
                AddTabForObject(
                    prefPlugin.GetType().Name,
                    prefPlugin.PluginPreferences.Clone() as ICloneable);
            }
        }

        private void ApplyPreferences()
        {
            // Get all the preference objects and save them
            foreach (IPluginPreferences prefPlugin in PreferencePlugins)
            {
                String prefName = prefPlugin.GetType().Name;
                PreferencesTab tab = preferencesTabControl.TabPages[prefName] as PreferencesTab;

                prefPlugin.PluginPreferences = tab.PreferencesObject;
            }
        }
    }

    public class PreferencesTab : TabPage
    {
        private PropertyGrid tabPropertyGrid;

        public ICloneable PreferencesObject
        {
            get { return tabPropertyGrid.SelectedObject as ICloneable; }
            set { tabPropertyGrid.SelectedObject = value; }
        }

        public PreferencesTab()
        {
            tabPropertyGrid = new PropertyGrid();

            this.Padding = new Padding(5);
            this.Controls.Add(tabPropertyGrid);

            this.tabPropertyGrid.Dock = DockStyle.Fill;
        }

        public PreferencesTab(String preferencesName, Object preferencesObject)
            : this()
        {
            this.Text = preferencesObject.GetType().Name;
            this.Name = preferencesName;
            this.tabPropertyGrid.SelectedObject = preferencesObject;
        }

        public PreferencesTab(Object preferencesObject)
            : this(preferencesObject.GetType().Name, preferencesObject)
        { }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup2\Preferences.Designer.cs ===
using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;

namespace STFGui
{
    public partial class Preferences : Form
    {
        private Button applyButton;
        private Button cancelButton;
        private TabControl preferencesTabControl;
        private Panel buttonsPanel;

        public void InitializeComponent()
        {
            this.buttonsPanel = new System.Windows.Forms.Panel();
            this.applyButton = new System.Windows.Forms.Button();
            this.cancelButton = new System.Windows.Forms.Button();
            this.preferencesTabControl = new System.Windows.Forms.TabControl();
            this.buttonsPanel.SuspendLayout();
            this.SuspendLayout();
            // 
            // buttonsPanel
            // 
            this.buttonsPanel.Controls.Add(this.applyButton);
            this.buttonsPanel.Controls.Add(this.cancelButton);
            this.buttonsPanel.Dock = System.Windows.Forms.DockStyle.Bottom;
            this.buttonsPanel.Location = new System.Drawing.Point(5, 368);
            this.buttonsPanel.Name = "buttonsPanel";
            this.buttonsPanel.Size = new System.Drawing.Size(581, 29);
            this.buttonsPanel.TabIndex = 0;
            // 
            // applyButton
            // 
            this.applyButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.applyButton.Location = new System.Drawing.Point(425, 6);
            this.applyButton.Name = "applyButton";
            this.applyButton.Size = new System.Drawing.Size(75, 23);
            this.applyButton.TabIndex = 1;
            this.applyButton.Text = "Apply";
            this.applyButton.UseVisualStyleBackColor = true;
            this.applyButton.Click += new System.EventHandler(this.applyButton_Click);
            // 
            // cancelButton
            // 
            this.cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.cancelButton.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.cancelButton.Location = new System.Drawing.Point(506, 6);
            this.cancelButton.Name = "cancelButton";
            this.cancelButton.Size = new System.Drawing.Size(75, 23);
            this.cancelButton.TabIndex = 0;
            this.cancelButton.Text = "Cancel";
            this.cancelButton.UseVisualStyleBackColor = true;
            this.cancelButton.Click += new System.EventHandler(this.cancelButton_Click);
            // 
            // preferencesTabControl
            // 
            this.preferencesTabControl.Dock = System.Windows.Forms.DockStyle.Fill;
            this.preferencesTabControl.Location = new System.Drawing.Point(5, 5);
            this.preferencesTabControl.Name = "preferencesTabControl";
            this.preferencesTabControl.SelectedIndex = 0;
            this.preferencesTabControl.Size = new System.Drawing.Size(581, 363);
            this.preferencesTabControl.TabIndex = 1;
            // 
            // Preferences
            // 
            this.AcceptButton = this.applyButton;
            this.CancelButton = this.cancelButton;
            this.ClientSize = new System.Drawing.Size(591, 402);
            this.Controls.Add(this.preferencesTabControl);
            this.Controls.Add(this.buttonsPanel);
            this.Name = "Preferences";
            this.Padding = new System.Windows.Forms.Padding(5);
            this.Text = "Preferences";
            this.buttonsPanel.ResumeLayout(false);
            this.ResumeLayout(false);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\GuiCommon\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\GuiCommon\Plugins.cs ===
using System.Xml;
using ServerTestFramework.Plugins;

/*
 You may implement one or more of the interfaces defined here to piece together
 the functionality you require.  Methods will be called in the following order
 over the life of the app:

while (app is running)
{
    IPluginSetup.Initialize (one time only)

    for (every newly loaded plugin)
    {
        IPluginGui.GetNew* (once only for any given Plugin)
    }

    for (every newly loaded extension)
    {
        IPluginExtension.PluginLoaded (once for each plugin that is extended)
    }

    for (every newly loaded suite)
    {
        IPluginSuiteLoadedNotification.SuiteLoaded (once for each suite)
    }
}

IPluginSetup.Shutdown (one time only)
*/

namespace STFGui.Plugins
{
    /// <summary>
    /// Implement this interface to provide an object that has properties that
    /// you would like to be able to change in the GUI.
    /// If there is no GUI (ex STFConsole), these methods will not be called.
    /// </summary>
    public interface IPluginPreferences : IPlugin
    {
        System.ICloneable PluginPreferences { get; set; }
    }

    /// <summary>
    /// Implement this interface for access to the GUI, if it is present.
    /// If there is no GUI (ex STFConsole), these methods will not be called.
    /// </summary>
    public interface IPluginGui : IPlugin
    {
        /// <summary>
        /// If a gui is present, this contains information and methods needed to
        /// hook into it.
        /// </summary>
        MainGuiHooks GuiHooks { get; set; }

        /// <summary>
        /// You implement this to return a new TabPage to add to the gui.
        /// Return null if you don't want a tab page.
        /// </summary>
        System.Windows.Forms.TabPage GetNewTabPage ();

        /// <summary>
        /// You implement this to return a new menu to add to the gui.
        /// Return null if you don't want a menu.
        /// </summary>
        System.Windows.Forms.MenuItem GetNewMenu ();

        /// <summary>
        /// This is called when the GUI is initialy shown to the user.  
        /// Implenent if this plugin needs to react to the Gui being shown to
        /// the user.
        /// </summary>
        void OnGuiShown ();
    }

    /// <summary>
    /// Information and methods for interacting with the main gui container.
    /// </summary>
    public abstract class MainGuiHooks
    {
        /// <summary> The main form of the app. </summary>
        public System.Windows.Forms.Form MainForm;

        //this event occurs when all output should be cleared
        public delegate void ClearOutputDelegate();
        public abstract void AddClearOutputHandler(ClearOutputDelegate handler);

        /// <summary>
        /// Limits the output to the main text box to the given size.
        /// </summary>
        /// <param name="limit">
        /// The max number of characters to allow, or 0 to disable the limit
        /// </param>
        public abstract void LimitOutput(int limit);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\GuiCommon\STFInputBox.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;

namespace STFGui
{
    public class FormInputBox : Form
    {

        public string data;

        public FormInputBox()
        {
            InitializeComponent();
            this.Close();
        }

        public FormInputBox(string titleText)
        {
            InitializeComponent();
            this.Text = titleText;
        }

        private void FormInputBox_Load(object sender, EventArgs e)
        {
            this.tbInput.Focus();
        }

        private void btnOk_Click(object sender, EventArgs e)
        {
            data = tbInput.Text;
            DialogResult = DialogResult.OK;
            this.Close();
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            this.Close();
        }

#region designer
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.tbInput = new System.Windows.Forms.TextBox();
            this.btnOk = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // tbInput
            // 
            this.tbInput.Location = new System.Drawing.Point(12, 12);
            this.tbInput.MaxLength = 500;
            this.tbInput.Name = "tbInput";
            this.tbInput.Size = new System.Drawing.Size(369, 20);
            this.tbInput.TabIndex = 0;
            // 
            // btnOk
            // 
            this.btnOk.Location = new System.Drawing.Point(44, 38);
            this.btnOk.Name = "btnOk";
            this.btnOk.Size = new System.Drawing.Size(75, 23);
            this.btnOk.TabIndex = 1;
            this.btnOk.Text = "OK";
            this.btnOk.UseVisualStyleBackColor = true;
            this.btnOk.Click += new System.EventHandler(this.btnOk_Click);
            // 
            // btnCancel
            // 
            this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.btnCancel.Location = new System.Drawing.Point(293, 38);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(75, 23);
            this.btnCancel.TabIndex = 2;
            this.btnCancel.Text = "Cancel";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // FormInputBox
            // 
            this.AcceptButton = this.btnOk;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.btnCancel;
            this.ClientSize = new System.Drawing.Size(395, 67);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnOk);
            this.Controls.Add(this.tbInput);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedToolWindow;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "FormInputBox";
            this.Text = "Enter your data";
            this.Load += new System.EventHandler(this.FormInputBox_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.TextBox tbInput;
        private System.Windows.Forms.Button btnOk;
        private System.Windows.Forms.Button btnCancel;
#endregion designer


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\GuiCommon\StfMRUList.cs ===
using System;
using System.Windows.Forms;
using System.Collections.Generic;

namespace STFGui
{
    /// <summary>
    /// Most recently used list of menu items. Click on something, and it goes back up to the top.
    /// </summary>
    public class MRUList : MenuItem
    {        
        int maxItems = 6;
        List<string> items;
        EventHandler clickChild;

        public EventHandler ClickChild
        {
            get
            {
                return clickChild;
            }
            set
            {
                clickChild = value;
            }
        }

        /// <summary>
        /// Constructor. Sets up click eventhandlers and initializes the items list. 
        /// </summary>
        /// <param name="text"></param>        
        public MRUList(string text)
            : base(text)
        {
            //Set up the BaseOnClick method which shuffles items around on every click.            
            this.clickChild = new EventHandler(BaseOnClick);                        
            items = new List<string>();
        }        

        public string[] Items
        {
            get
            {
                return items.ToArray();
            }
        }        

        //Gets called every time something changes. Meant to shift items around
        //automatically when clicked. 
        private void BaseOnClick(object sender, EventArgs e)
        {
            AddItem(((MenuItem)sender).Text);
        }       

        /// <summary>
        /// If an item is new, it gets added at the top. If it already exists, 
        /// it gets shifted up to the top. The bottom is trimmed if at max capacity. 
        /// </summary>
        /// <param name="text"></param>
        public void AddItem(string text)
        {
            if (!String.IsNullOrEmpty(text))
            {
                if (!items.Contains(text))
                {
                    if (items.Count >= maxItems)
                        items.RemoveAt(maxItems - 1);

                    items.Insert(0, text);
                }
                else
                {
                    items.RemoveAt(items.IndexOf(text));
                    items.Insert(0, text);
                }
                RefreshMenu();
            }
        }        

        /// <summary>
        /// Reloads the UI elements. 
        /// </summary>
        private void RefreshMenu()
        {
            //Lazy I know
            this.MenuItems.Clear();
            foreach (string s in items)
            {
                MenuItem newItem = new MenuItem(s, clickChild);                
                this.MenuItems.Add(newItem);
            }
        }

        /// <summary>
        /// Just loads a list of items in. Clears before starting.
        /// </summary>
        /// <param name="itemTexts"></param>
        public void LoadList(IEnumerable<string> itemTexts)
        {            
            if (itemTexts != null)
            {
                items.Clear();
                foreach (string s in itemTexts)
                {
                    AddItem(s);
                }
                RefreshMenu();
            }    
   
        }

        //Note - I kinda hate these. Should really do proper serialization. CSV stands for CHAR separated values, not ','!
        #region CSV methods. 
        
        
        const char defaultSeparator = '?';

        /// <summary>
        /// "separator" separated list of items in string form.
        /// </summary>
        /// <param name="separator"></param>
        /// <returns></returns>
        public string GetCSVString(char separator)
        {
            //Grab a local copy
            string[] localItems = items.ToArray();

            string outStr = string.Empty;
            for (int k = 0; k < localItems.Length; k++)
                outStr += separator + localItems[k];

            if (outStr.Length > 0)
                outStr = outStr.Substring(1); //Get rid of the first "?"

            return outStr;
        }

        /// <summary>
        /// Default version of GetCSVString, uses the "?" as a separator since it is not a valid file character.
        /// </summary>
        /// <returns></returns>
        public string GetCSVString()
        {
            return GetCSVString(defaultSeparator);
        }

        /// <summary>
        /// Loads the output of "GetCSVString". Reverses the result since it's a MRU list.
        /// </summary>
        /// <param name="separator"></param>
        /// <param name="str"></param>
        public void LoadCSVString(char separator, string str)
        {
            if (!String.IsNullOrEmpty(str))
            {
                string[] list = str.Split(separator);

                foreach (string s in list)
                {
                    AddItem(s);
                }
                //Reverse since loading in order stacks things up. 
                items.Reverse();

                RefreshMenu();
            }
        }
        /// <summary>
        /// Default version of GetCSVString. 
        /// </summary>
        /// <param name="str"></param>
        public void LoadCSVString(string str)
        {
            LoadCSVString(defaultSeparator, str);
        }
        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\Plugins\LiveEnvironment\SettingBrowser.cs ===
using System;
using System.Threading;
using System.Windows.Forms;
using System.Drawing;
using System.Xml;
using System.Data.SqlClient;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Database;
using xonline.common.config;

namespace STFGui.Plugins
{
    public partial class EnvironmentPlugin : IPluginSetup, IPluginGui
    {
        Panel panelSettingsListAndFilter;
        Panel panelSettingsFilter;
        Panel panelSettingsList;
        Panel panelSettingsInfoAndAlter;
        Panel panelSettingsInfo;
        Panel panelSettingsAlter;

        ListBox settingsListBox;
        TextBox settingsFilterBox;
        TextBox settingsDetailsBox;

        Button butAddBase;
        Button butChangeBase;
        Button butRemoveBase;
        Button butAddOverride;
        Button butChangeOverride;
        Button butRemoveOverride;
        Button butAddEnvTypeOverride;
        Button butChangeEnvTypeOverride;
        Button butRemoveEnvTypeOverride;

        string []settingsNames=new string[0]; //name of every known setting

        string curSetting="";
        bool curSettingMulti=false;

        //gets the tab page for the settings browser
        TabPage MakeSettingsBrowserTabPage()
        {
            TabPage tabSettings=new TabPage();
            tabSettings.Text="Settings";
            tabSettings.Size=new System.Drawing.Size(1000, 1000);

            //make a splitter between the list and the details
            SplitContainer splitListAndInfo=new SplitContainer();
            splitListAndInfo.Orientation=Orientation.Vertical;
            splitListAndInfo.Dock=DockStyle.Fill;
            splitListAndInfo.Location=new System.Drawing.Point(0, 0);
            splitListAndInfo.Size=new System.Drawing.Size(1000, 1000);
            splitListAndInfo.Panel2MinSize=100;
            splitListAndInfo.SplitterDistance=400;
            tabSettings.Controls.Add(splitListAndInfo);

            panelSettingsListAndFilter=splitListAndInfo.Panel1;
            panelSettingsInfoAndAlter=splitListAndInfo.Panel2;

            //make a splitter for the filter and list
            SplitContainer splitListAndFilter=new SplitContainer();
            splitListAndFilter.Orientation=Orientation.Horizontal;
            splitListAndFilter.Dock=DockStyle.Fill;
            splitListAndFilter.Location=new System.Drawing.Point(0, 0);
            splitListAndFilter.Size=new System.Drawing.Size(1000, 1000);
            splitListAndFilter.Panel1MinSize=21;
            splitListAndFilter.SplitterDistance=21;
            splitListAndFilter.IsSplitterFixed=true;
            panelSettingsListAndFilter.Controls.Add(splitListAndFilter);

            panelSettingsFilter=splitListAndFilter.Panel1;
            panelSettingsList=splitListAndFilter.Panel2;

            //make a splitter for the details and alteration
            SplitContainer splitInfoAndAlter=new SplitContainer();
            splitInfoAndAlter.Orientation=Orientation.Horizontal;
            splitInfoAndAlter.Dock=DockStyle.Fill;
            splitInfoAndAlter.Location=new System.Drawing.Point(0, 0);
            splitInfoAndAlter.Size=new System.Drawing.Size(1000, 1000);
            splitInfoAndAlter.Panel2MinSize=60;
            splitInfoAndAlter.SplitterDistance=940;
            splitInfoAndAlter.IsSplitterFixed=true;
            panelSettingsInfoAndAlter.Controls.Add(splitInfoAndAlter);

            panelSettingsInfo=splitInfoAndAlter.Panel1;
            panelSettingsAlter=splitInfoAndAlter.Panel2;

            //settings list
            settingsListBox=new ListBox();
            settingsListBox.Dock=DockStyle.Fill;
            settingsListBox.Sorted=true;
            settingsListBox.SelectedIndexChanged+=SettingsList_SelectionChanged;
            panelSettingsList.Controls.Add(settingsListBox);

            //settings filter
            panelSettingsFilter.Size=new System.Drawing.Size(1000, 22);

            Label lab=new Label();
            lab.Text="Filter:";
            lab.Location=new System.Drawing.Point(2, 4);
            lab.Size=new System.Drawing.Size(34, 20);
            panelSettingsFilter.Controls.Add(lab);

            settingsFilterBox=new TextBox();
            settingsFilterBox.Location=new System.Drawing.Point(37, 1);
            settingsFilterBox.Size=new System.Drawing.Size(361, 20);
            settingsFilterBox.Anchor=AnchorStyles.Right | AnchorStyles.Left;
            settingsFilterBox.TextChanged+=SettingFilterBox_Changed;
            panelSettingsFilter.Controls.Add(settingsFilterBox);

            //details box
            settingsDetailsBox=new TextBox();
            settingsDetailsBox.Dock=DockStyle.Fill;
            settingsDetailsBox.ReadOnly=true;
            settingsDetailsBox.Multiline=true;
            settingsDetailsBox.ScrollBars=ScrollBars.Both;
            settingsDetailsBox.WordWrap=false;
            panelSettingsInfo.Controls.Add(settingsDetailsBox);

            //settings alteration buttons
            butAddBase=new Button();
            butAddBase.Location=new System.Drawing.Point(0, 0);
            butAddBase.Size=new System.Drawing.Size(105, 20);
            butAddBase.Text="Add Base";
            butAddBase.Click+=Button_AddBase;
            panelSettingsAlter.Controls.Add(butAddBase);

            butChangeBase=new Button();
            butChangeBase.Location=new System.Drawing.Point(0, 20);
            butChangeBase.Size=new System.Drawing.Size(105, 20);
            butChangeBase.Text="Change Base";
            butChangeBase.Click+=Button_ChangeBase;
            panelSettingsAlter.Controls.Add(butChangeBase);

            butRemoveBase=new Button();
            butRemoveBase.Location=new System.Drawing.Point(0, 40);
            butRemoveBase.Size=new System.Drawing.Size(105, 20);
            butRemoveBase.Text="Remove Base";
            butRemoveBase.Click+=Button_RemoveBase;
            panelSettingsAlter.Controls.Add(butRemoveBase);

            butAddOverride=new Button();
            butAddOverride.Location=new System.Drawing.Point(490, 0);
            butAddOverride.Size=new System.Drawing.Size(105, 20);
            butAddOverride.Text="Add Override";
            butAddOverride.Anchor=AnchorStyles.Right;
            butAddOverride.Click+=Button_AddOverride;
            panelSettingsAlter.Controls.Add(butAddOverride);

            butChangeOverride=new Button();
            butChangeOverride.Location=new System.Drawing.Point(490, 20);
            butChangeOverride.Size=new System.Drawing.Size(105, 20);
            butChangeOverride.Text="Change Override";
            butChangeOverride.Anchor=AnchorStyles.Right;
            butChangeOverride.Click+=Button_ChangeOverride;
            panelSettingsAlter.Controls.Add(butChangeOverride);

            butRemoveOverride=new Button();
            butRemoveOverride.Location=new System.Drawing.Point(490, 40);
            butRemoveOverride.Size=new System.Drawing.Size(105, 20);
            butRemoveOverride.Anchor=AnchorStyles.Right;
            butRemoveOverride.Text="Remove Override";
            butRemoveOverride.Click+=Button_RemoveOverride;
            panelSettingsAlter.Controls.Add(butRemoveOverride);

            butAddEnvTypeOverride=new Button();
            butAddEnvTypeOverride.Location=new System.Drawing.Point(110, 0);
            butAddEnvTypeOverride.Size=new System.Drawing.Size(375, 20);
            butAddEnvTypeOverride.Anchor=AnchorStyles.Right | AnchorStyles.Left;
            butAddEnvTypeOverride.Text="Add EnvType Override";
            butAddEnvTypeOverride.Click+=Button_AddEnvTypeOverride;
            panelSettingsAlter.Controls.Add(butAddEnvTypeOverride);

            butChangeEnvTypeOverride=new Button();
            butChangeEnvTypeOverride.Location=new System.Drawing.Point(110, 20);
            butChangeEnvTypeOverride.Size=new System.Drawing.Size(375, 20);
            butChangeEnvTypeOverride.Anchor=AnchorStyles.Right | AnchorStyles.Left;
            butChangeEnvTypeOverride.Text="Change EnvType Override";
            butChangeEnvTypeOverride.Click+=Button_ChangeEnvTypeOverride;
            panelSettingsAlter.Controls.Add(butChangeEnvTypeOverride);

            butRemoveEnvTypeOverride=new Button();
            butRemoveEnvTypeOverride.Location=new System.Drawing.Point(110, 40);
            butRemoveEnvTypeOverride.Size=new System.Drawing.Size(375, 20);
            butRemoveEnvTypeOverride.Anchor=AnchorStyles.Right | AnchorStyles.Left;
            butRemoveEnvTypeOverride.Text="Remove EnvType Override";
            butRemoveEnvTypeOverride.Click+=Button_RemoveEnvTypeOverride;
            panelSettingsAlter.Controls.Add(butRemoveEnvTypeOverride);

            UpdateAlterationBox(false, false, false);

            //
            return tabSettings;
        }

        private void ClearSettingsInfo()
        {
            settingsNames=new string[0];
            settingsListBox.Items.Clear();

            curSetting="";
            curSettingMulti=false;

            PopulateInfoBox();
        }

        //gets setting names from npdb
        private void RefillSettingNames()
        {
            //pull all possible settings from npdb
            List<string> baseSettingsList=new List<string>();

            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                //retrieve all setting names
                SqlDataReader reader;
                npdb.ReadData("select vc_setting from t_settings", out reader);
                while (reader.Read())
                {
                    string name=(string)reader[0];
                    baseSettingsList.Add(name);
                }
                reader.Close();

                //retrieve all multisetting names
                npdb.ReadData("select vc_multisetting from t_multisetting_names", out reader);
                while (reader.Read())
                {
                    string name=(string)reader[0];
                    baseSettingsList.Add(name+"*");
                }
                reader.Close();

                npdb.Close();
            }
            catch(ThreadAbortException)
            {
                // We don't want to handle the thread abort exception
                // The thread abort will be automatically rethrown
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving settings list: "+e);
            }

            //store and rebuild the box
            settingsNames=baseSettingsList.ToArray();
            RebuildSettingsListBox();
        }

        //rebuilds the box of settings based on the current list and the filter
        private void RebuildSettingsListBox()
        {
            if (settingsListBox.InvokeRequired)
            {
                settingsListBox.Invoke((InvokeCode)RebuildSettingsListBox);
            }
            else
            {
                try
                {
                    settingsListBox.SuspendLayout();
                    settingsListBox.Items.Clear();

                    foreach (string name in settingsNames)
                    {
                        if (settingsFilterBox.Text.Length == 0 || name.ToLower().Contains(settingsFilterBox.Text.ToLower()))
                        {
                            settingsListBox.Items.Add(name);
                        }
                    }
                }
                finally
                {
                    settingsListBox.ResumeLayout(true);
                }
            }
        }

        //rebuilds the info box for a setting
        private void PopulateInfoBox()
        {
            string setting=SqlEscapize(curSetting);
            bool isMultiSetting=curSettingMulti;
            if (setting.Length==0)
            {
                settingsDetailsBox.Text="";
                UpdateAlterationBox(false, false, false);
                return;
            }

            bool baseExists=false;
            bool overrideExists=false;
            bool envOverrideExists=false;

            settingsDetailsBox.Text=" ----- "+curSetting+" ----- "+(isMultiSetting?"(multisetting)":"")+"\r\n\r\n";

            try
            {
                Config.DiscardCachedValues();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception flushing cached settings: "+e);
            }

            //the current value
            try
            {
                if (!isMultiSetting)
                {
                    settingsDetailsBox.Text+="current value: "+Global.XEnv.GetSetting(curSetting)+"\r\n\r\n";
                }
                else
                {
                    string []vals=Config.GetMultiSetting(curSetting);
                    foreach (string v in vals)
                    {
                        settingsDetailsBox.Text+="current value: "+v+"\r\n";
                    }

                    settingsDetailsBox.Text+="\r\n";
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception getting setting value: "+e);
            }

            //value derivation
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                //base value
                SqlDataReader reader;
                string query;
                if (!isMultiSetting)
                {
                    query="select vc_value from t_settings where vc_setting='"+setting+"'";
                }
                else
                {
                    query="select vc_value from t_multisettings where vc_multisetting='"+setting+"'";
                }
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    baseExists=true;
                    string val=(string)reader[0];
                    settingsDetailsBox.Text+="base value: "+val+"\r\n";
                }
                reader.Close();

                //env type overrides
                if (!isMultiSetting)
                {
                    query="select vc_environment_type,vc_value from t_environment_type_setting_overrides where vc_setting='"+setting+"'";
                }
                else
                {
                    query="select vc_environment_type,vc_value from t_environment_type_multisetting_overrides where vc_multisetting='"+setting+"'";
                }
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    envOverrideExists=true;
                    string etype=(string)reader[0];
                    string val=(string)reader[1];
                    settingsDetailsBox.Text+="env type override: "+etype+": "+val+"\r\n";
                }
                reader.Close();

                //direct overrides
                if (!isMultiSetting)
                {
                    query="select vc_component,vc_server,i_site_id,vc_value from t_setting_overrides where vc_setting='"+setting+"' and vc_environment='"+GetCurrentEnvironmentName()+"'";
                }
                else
                {
                    query="select vc_component,vc_server,i_site_id,vc_value from t_multisetting_overrides where vc_multisetting='"+setting+"' and vc_environment='"+GetCurrentEnvironmentName()+"'";
                }
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    overrideExists=true;
                    string comp=(string)reader[0];
                    string serv=(string)reader[1];
                    string site=reader[2].ToString();
                    string val=(string)reader[3];
                    settingsDetailsBox.Text+="override: component="+comp+" server="+serv+" site="+site+": "+val+"\r\n";
                }
                reader.Close();

                npdb.Close();

                if (!envOverrideExists && !overrideExists)
                {
                    settingsDetailsBox.Text+="no overrides\r\n";
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception getting setting overrides: "+e);
            }

            UpdateAlterationBox(baseExists, envOverrideExists, overrideExists);
        }

        //rebuilds the state of the edit settings buttons
        private void UpdateAlterationBox(bool baseExists, bool envOverrideExists, bool normOverrideExists)
        {
            if (curSettingMulti) //not supported yet
            {
                panelSettingsAlter.Visible=false;
                return;
            }
            else
            {
                panelSettingsAlter.Visible=true;
            }

            //change enableds and text based on vals
            butChangeBase.Enabled=true;
            butRemoveBase.Enabled=baseExists;
            butAddOverride.Enabled=true;
            butChangeOverride.Enabled=normOverrideExists;
            butRemoveOverride.Enabled=normOverrideExists;
            butAddEnvTypeOverride.Enabled=true;
            butChangeEnvTypeOverride.Enabled=envOverrideExists;
            butRemoveEnvTypeOverride.Enabled=envOverrideExists;

            //if we have no setting disable all (except for add base)
            if (curSetting.Length==0)
            {
                butChangeBase.Enabled=false;
                butRemoveBase.Enabled=false;
                butAddOverride.Enabled=false;
                butChangeOverride.Enabled=false;
                butRemoveOverride.Enabled=false;
                butAddEnvTypeOverride.Enabled=false;
                butChangeEnvTypeOverride.Enabled=false;
                butRemoveEnvTypeOverride.Enabled=false;
            }
        }

        //executes an sql non-query
        bool TryNpdbCommand(string query)
        {
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();
                npdb.IssueCommand(query);
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception executing query on npdb. query: "+query+"\nException: "+e);
                return false;
            }

            return true;
        }

        //gets a list of components
        string[] NpdbGetComponents()
        {
            List<string> list=new List<string>();

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData("select vc_component from t_components" , out reader);
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            npdb.Close();

            return list.ToArray();
        }

        //gets a list of server
        string[] NpdbGetServers()
        {
            List<string> list=new List<string>();

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData("select vc_server from t_servers where vc_environment='"+GetCurrentEnvironmentName()+"' order by vc_server" , out reader);
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            npdb.Close();

            return list.ToArray();
        }

        //gets a list of server
        string[] NpdbGetSites()
        {
            List<string> list=new List<string>();

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData("select distinct i_site_id from t_sites" , out reader);
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            npdb.Close();

            return list.ToArray();
        }

        //gets a list of environment types
        string[] NpdbGetEnvTypes()
        {
            List<string> list=new List<string>();

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData("select vc_environment_type from t_environment_types" , out reader);
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            npdb.Close();

            return list.ToArray();
        }

        string SqlEscapize(string s)
        {
            return s.Replace("'","''");
        }

        #region Events

        public void RefreshSettings()
        {
            RefillSettingNames();
        }

        public void SettingFilterBox_Changed(object sender, EventArgs ea)
        {
            RebuildSettingsListBox();
        }

        public void SettingsList_SelectionChanged(object sender, EventArgs ea)
        {
            if (settingsListBox.SelectedItem!=null)
            {
                string selName=(string)settingsListBox.SelectedItem;
                if (selName.EndsWith("*"))
                {
                    curSetting=selName.Substring(0, selName.Length-1);
                    curSettingMulti=true;
                }
                else
                {
                    curSetting=selName;
                    curSettingMulti=false;
                }

                PopulateInfoBox();
            }
        }

        public void Button_AddBase(object sender, EventArgs ea)
        {
            string newSet, newVal;
            ShowAddBaseSettingBox(out newSet, out newVal);
            if (newSet.Length==0)
            {
                Global.RO.Info("New setting not added.");
            }
            else
            {
                if (TryNpdbCommand("insert into t_settings (vc_setting,vc_value) values ('"+SqlEscapize(newSet)+"', '"+SqlEscapize(newVal)+"')"))
                {
                    RefillSettingNames();
                    curSetting=newSet;
                    curSettingMulti=false;
                    Global.RO.Info(newSet+" added.");
                }
            }

            PopulateInfoBox();
        }

        public void Button_ChangeBase(object sender, EventArgs ea)
        {
            string newVal=STFGui.GuiCommon.GetStringFromUser(GuiHooks.MainForm, curSetting, Global.XEnv.GetSetting(curSetting));
            if (newVal==null)
            {
                Global.RO.Info("Setting not changed.");
            }
            else
            {
                if (TryNpdbCommand("update t_settings set vc_value='"+SqlEscapize(newVal)+"' where vc_setting='"+SqlEscapize(curSetting)+"'"))
                {
                    Global.RO.Info(curSetting+" changed.");
                }
            }

            PopulateInfoBox();
        }

        public void Button_RemoveBase(object sender, EventArgs ea)
        {
            if (System.Windows.Forms.MessageBox.Show("Really delete base setting '"+curSetting+"'?", "Slay the Setting?", MessageBoxButtons.YesNo)==DialogResult.No)
            {
                Global.RO.Info("We left the poor setting alone.");
            }
            else
            {
                if (TryNpdbCommand("delete from t_settings where vc_setting='"+SqlEscapize(curSetting)+"'"))
                {
                    Global.RO.Info(curSetting+" obliterated.");
                    curSetting="";
                    RefillSettingNames();
                }
            }

            PopulateInfoBox();
        }

        public void Button_AddOverride(object sender, EventArgs ea)
        {
            //get the lists we need
            string []components=null;
            string []servers=null;
            string []sites=null;
            try
            {
                components=NpdbGetComponents();
                servers=NpdbGetServers();
                sites=NpdbGetSites();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving info from npdb: "+e);
                return;
            }

            //ask user and do it
            string newVal;
            string newComp, newServ, newSite;
            if (!ShowListBoxesWithOptionalValue("Add Override on "+curSetting,
                "Component:", components, "ALL", out newComp,
                "Server:", servers, "ALL", out newServ,
                "Site:", sites, "-1", out newSite,
                "Value:", null, out newVal))
            {
                Global.RO.Info("No override added.");
            }
            else
            {
                if (TryNpdbCommand("insert into t_setting_overrides (vc_environment,                     vc_component,               i_site_id,                  vc_server,                  vc_setting,                    vc_value) "+
                                                             "values('"+GetCurrentEnvironmentName()+"', '"+SqlEscapize(newComp)+"', '"+SqlEscapize(newSite)+"', '"+SqlEscapize(newServ)+"', '"+SqlEscapize(curSetting)+"', '"+SqlEscapize(newVal)+"')"))
                {
                    Global.RO.Info("Override added for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_ChangeOverride(object sender, EventArgs ea)
        {
            //build the where clauses for each individual override (minus setting name)
            List<string> wheres=new List<string>();
            string query="select vc_component,vc_server,i_site_id from t_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"' and vc_environment='"+GetCurrentEnvironmentName()+"'";
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    string w="vc_component='"+SqlEscapize(reader[0].ToString())+"' and vc_server='"+SqlEscapize(reader[1].ToString())+"' and i_site_id="+reader[2].ToString();
                    wheres.Add(w);
                }
                reader.Close();
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving overrides list: "+e);
                return;
            }

            //ask user and do it
            string whereToUse;
            string junk;
            string newVal;
            if (!ShowListBoxesWithOptionalValue("Change Override on "+curSetting,
                "Override:", wheres.ToArray(), null, out whereToUse,
                null, null, null, out junk,
                null, null, null, out junk,
                "New Value:", null, out newVal))
            {
                Global.RO.Info("No override changed.");
            }
            else
            {
                if (TryNpdbCommand("update t_setting_overrides set vc_value='"+SqlEscapize(newVal)+"' where vc_setting='"+SqlEscapize(curSetting)+"' and "+whereToUse))
                {
                    Global.RO.Info("Override updated for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_RemoveOverride(object sender, EventArgs ea)
        {
            //build the where clauses for each individual override (minus setting name)
            List<string> wheres=new List<string>();
            string query="select vc_component,vc_server,i_site_id from t_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"' and vc_environment='"+GetCurrentEnvironmentName()+"'";
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    string w="vc_component='"+SqlEscapize(reader[0].ToString())+"' and vc_server='"+SqlEscapize(reader[1].ToString())+"' and i_site_id="+reader[2].ToString();
                    wheres.Add(w);
                }
                reader.Close();
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving overrides list: "+e);
                return;
            }

            //ask user and do it
            string whereToUse;
            string junk;
            if (!ShowListBoxesWithOptionalValue("Remove Override on "+curSetting,
                "Override:", wheres.ToArray(), null, out whereToUse,
                null, null, null, out junk,
                null, null, null, out junk,
                null, null, out junk))
            {
                Global.RO.Info("No override removed.");
            }
            else
            {
                if (TryNpdbCommand("delete from t_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"' and "+whereToUse))
                {
                    Global.RO.Info("Override destroyed for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_AddEnvTypeOverride(object sender, EventArgs ea)
        {
            //get the lists we need
            string []envTypes=null;
            try
            {
                envTypes=NpdbGetEnvTypes();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving info from npdb: "+e);
                return;
            }

            //ask user and do it
            string newVal;
            string newEnvType;
            string junk;
            if (!ShowListBoxesWithOptionalValue("Add Env Type Override on "+curSetting,
                "Env Type:", envTypes, null, out newEnvType,
                null, null, null, out junk,
                null, null, null, out junk,
                "Value:", null, out newVal))
            {
                Global.RO.Info("No env type override added.");
            }
            else
            {
                if (TryNpdbCommand("insert into t_environment_type_setting_overrides (vc_environment_type,           vc_setting,                    vc_value)"+
                                                                            " values ('"+SqlEscapize(newEnvType)+"', '"+SqlEscapize(curSetting)+"', '"+SqlEscapize(newVal)+"')"))
                {
                    Global.RO.Info("Env type override added for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_ChangeEnvTypeOverride(object sender, EventArgs ea)
        {
            //get the current overides
            List<string> envs=new List<string>();
            string query="select vc_environment_type from t_environment_type_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"'";
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    envs.Add(reader[0].ToString());
                }
                reader.Close();
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving env type overrides list: "+e);
                return;
            }

            //ask user and do it
            string envToUse;
            string junk;
            string newVal;
            if (!ShowListBoxesWithOptionalValue("Change Env Type Override on "+curSetting,
                "Env Type:", envs.ToArray(), null, out envToUse,
                null, null, null, out junk,
                null, null, null, out junk,
                "New Value:", null, out newVal))
            {
                Global.RO.Info("No env type override changed.");
            }
            else
            {
                if (TryNpdbCommand("update t_environment_type_setting_overrides set vc_value='"+SqlEscapize(newVal)+"' where vc_setting='"+SqlEscapize(curSetting)+"' and vc_environment_type='"+SqlEscapize(envToUse)+"'"))
                {
                    Global.RO.Info("Env type override updated for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_RemoveEnvTypeOverride(object sender, EventArgs ea)
        {
            //get the current overides
            List<string> envs=new List<string>();
            string query="select vc_environment_type from t_environment_type_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"'";
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    envs.Add(reader[0].ToString());
                }
                reader.Close();
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving env type overrides list: "+e);
                return;
            }

            //ask user and do it
            string envToUse;
            string junk;
            if (!ShowListBoxesWithOptionalValue("Remove Env Type Override on "+curSetting,
                "Env Type:", envs.ToArray(), null, out envToUse,
                null, null, null, out junk,
                null, null, null, out junk,
                null, null, out junk))
            {
                Global.RO.Info("No env type override removed.");
            }
            else
            {
                if (TryNpdbCommand("delete from t_environment_type_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"' and vc_environment_type='"+SqlEscapize(envToUse)+"'"))
                {
                    Global.RO.Info("Env type override incapacitated for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        #endregion //Events

        #region ui helpers

        void ShowAddBaseSettingBox(out string settingName, out string settingValue)
        {
            settingName="";
            settingValue="";

            //make a box for this
            Form form=new Form();
            form.SetBounds(0,0,315,85,BoundsSpecified.Size);
            form.Text="Add Setting";
            form.FormBorderStyle=FormBorderStyle.FixedDialog;
            form.MaximizeBox=false;

            Size expectedFormSize=new Size(307,58); //for funky windows ui styles, we need to adjust form size
            Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
            form.Size+=diffFormSize;

            //make controls
            Label l1=new Label();
            l1.Text="Name:";
            l1.SetBounds(6,7,39,20);

            TextBox input1=new TextBox();
            input1.SetBounds(50,5,100,25);

            Label l2=new Label();
            l2.Text="Value:";
            l2.SetBounds(159,7,40,20);

            TextBox input2=new TextBox();
            input2.SetBounds(200,5,100,25);

            Button butOk=new Button();
            butOk.Text="Ok";
            butOk.SetBounds(15,30,75,25);
            butOk.DialogResult=DialogResult.OK;

            Button butCan=new Button();
            butCan.Text="Cancel";
            butCan.SetBounds(315-15-75,30,75,25);
            butCan.DialogResult=DialogResult.Cancel;

            //put it together and show it
            form.Controls.Add(l1);
            form.Controls.Add(input1);
            form.Controls.Add(l2);
            form.Controls.Add(input2);
            form.Controls.Add(butOk);
            form.Controls.Add(butCan);

            form.AcceptButton=butOk;
            form.CancelButton=butCan;
            form.ShowDialog(GuiHooks.MainForm);

            //handle result
            if (form.DialogResult==DialogResult.OK)
            {
                settingName=input1.Text;
                settingValue=input2.Text;
            }
        }

        //shows 1-3 combo boxes (name of null means don't show) and optionally a value box
        bool ShowListBoxesWithOptionalValue(string title,
                                            string name1, string []values1, string defValue1, out string outVal1,
                                            string name2, string []values2, string defValue2, out string outVal2,
                                            string name3, string []values3, string defValue3, out string outVal3,
                                            string textValueName, string defTextValue, out string outTextValue)
        {
            outVal1=null;
            outVal2=null;
            outVal3=null;
            outTextValue=null;

            //make a box for this
            int hei=75;
            if (name1!=null) hei+=25;
            if (name2!=null) hei+=25;
            if (name3!=null) hei+=25;
            if (textValueName!=null) hei+=25;

            Form form=new Form();
            form.SetBounds(0,0,515,hei,BoundsSpecified.Size);
            form.Text=title;
            form.FormBorderStyle=FormBorderStyle.FixedDialog;
            form.MaximizeBox=false;

            Size expectedFormSize=new Size(507,hei-(85-58)); //for funky windows ui styles, we need to adjust form size
            Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
            form.Size+=diffFormSize;

            //make controls
            int ypos=10;
            ComboBox combo1=null, combo2=null, combo3=null;
            if (name1!=null)
            {
                Label l=new Label();
                l.SetBounds(5,ypos+1, 75,20);
                l.Text=name1;
                form.Controls.Add(l);
                
                combo1=new ComboBox();
                combo1.DropDownStyle=ComboBoxStyle.DropDownList;
                combo1.SetBounds(90,ypos-1, 400,20);
                combo1.Items.AddRange(values1);
                if (defValue1!=null) combo1.SelectedItem=defValue1;
                else combo1.SelectedIndex=0;
                form.Controls.Add(combo1);
                
                ypos+=25;
            }
            if (name2!=null)
            {
                Label l=new Label();
                l.SetBounds(5,ypos+1, 75,20);
                l.Text=name2;
                form.Controls.Add(l);

                combo2=new ComboBox();
                combo2.DropDownStyle=ComboBoxStyle.DropDownList;
                combo2.SetBounds(90,ypos-1, 400,20);
                combo2.Items.AddRange(values2);
                if (defValue2!=null) combo2.SelectedItem=defValue2;
                else combo2.SelectedIndex=0;
                form.Controls.Add(combo2);

                ypos+=25;
            }
            if (name3!=null)
            {
                Label l=new Label();
                l.SetBounds(5,ypos+1, 75,20);
                l.Text=name3;
                form.Controls.Add(l);

                combo3=new ComboBox();
                combo3.DropDownStyle=ComboBoxStyle.DropDownList;
                combo3.SetBounds(90,ypos-1, 400,20);
                combo3.Items.AddRange(values3);
                if (defValue3!=null) combo3.SelectedItem=defValue3;
                else combo3.SelectedIndex=0;
                form.Controls.Add(combo3);

                ypos+=25;
            }
            TextBox boxOfText=null;
            if (textValueName!=null)
            {
                Label l=new Label();
                l.SetBounds(5,ypos+2, 75,20);
                l.Text=textValueName;
                form.Controls.Add(l);

                boxOfText=new TextBox();
                boxOfText.SetBounds(90,ypos-1, 400,20);
                if (defTextValue!=null) boxOfText.Text=defTextValue;
                form.Controls.Add(boxOfText);

                ypos+=25;
            }

            //buttons
            Button butOk=new Button();
            butOk.Text="Ok";
            butOk.SetBounds(15,hei-55,75,25);
            butOk.DialogResult=DialogResult.OK;

            Button butCan=new Button();
            butCan.Text="Cancel";
            butCan.SetBounds(515-15-75,hei-55,75,25);
            butCan.DialogResult=DialogResult.Cancel;

            //put it together and show it
            form.Controls.Add(butOk);
            form.Controls.Add(butCan);

            form.AcceptButton=butOk;
            form.CancelButton=butCan;
            form.ShowDialog(GuiHooks.MainForm);

            //handle result
            if (form.DialogResult==DialogResult.OK)
            {
                if (name1!=null) outVal1=(string)combo1.SelectedItem;
                if (name2!=null) outVal2=(string)combo2.SelectedItem;
                if (name3!=null) outVal3=(string)combo3.SelectedItem;
                if (textValueName!=null) outTextValue=boxOfText.Text;

                return true;
            }

            return false;
        }

        #endregion //ui helpers

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\GuiCommon\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\Plugins\LiveEnvironment\ServerBrowser.cs ===
using System;
using System.Threading;
using System.Windows.Forms;
using System.Drawing;
using System.Xml;
using System.Data.SqlClient;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Database;

namespace STFGui.Plugins
{
    public partial class EnvironmentPlugin : IPluginSetup, IPluginGui
    {
        public TreeView TreeInterfaces;
        public TreeView TreeServers;
        public Panel PanelServerInfo;
        public Panel PanelServerInterfacesServers;
        public TextBox TextServerInfo;

        public TextBox XmgmtCommandTextBox;
        public CheckBox XmgmtAllServersCheckBox;

        //private CheckBox filterEmptyInterfacesCheckbox;

        //gets the tab page for the server browser
        TabPage MakeServerBrowserTabPage()
        {
            TabPage tabServers=new TabPage();
            tabServers.Text="Servers";
            tabServers.Size=new System.Drawing.Size(1000, 1000);

            //make a splitter between the lists and the info
            SplitContainer splitServersAndInfo=new SplitContainer();
            splitServersAndInfo.Orientation=Orientation.Vertical;
            splitServersAndInfo.Dock=DockStyle.Fill;
            splitServersAndInfo.Location=new System.Drawing.Point(0, 0);
            splitServersAndInfo.Size=new System.Drawing.Size(5000, 3000);
            splitServersAndInfo.Panel2MinSize=100;
            splitServersAndInfo.SplitterDistance=2500;
            tabServers.Controls.Add(splitServersAndInfo);

            PanelServerInfo=splitServersAndInfo.Panel2;
            PanelServerInterfacesServers=splitServersAndInfo.Panel1;
            PanelServerInterfacesServers.Enabled=false;

            // Make the info box
            TextServerInfo = new TextBox
            {
                Dock = DockStyle.Fill,
                ReadOnly = true,
                Multiline = true,
                ScrollBars = ScrollBars.Both,
                WordWrap = false,
            };

            PanelServerInfo.Controls.Add(TextServerInfo);

            // And the Xmgmt Command Area
            GroupBox xmgmtGroupBox = new GroupBox
            {
                Text = "XManagement",
                Dock = DockStyle.Bottom,
                Height = 60,
                Padding = new Padding(3),
            };


            XmgmtAllServersCheckBox = new CheckBox
            {
                Dock = DockStyle.Bottom,
                Margin = new Padding(3),
                Text = "Run command on all servers"
            };
            xmgmtGroupBox.Controls.Add(XmgmtAllServersCheckBox);

            XmgmtCommandTextBox = new TextBox
            {
                Dock = DockStyle.Bottom,
                Multiline = false,
                ScrollBars = ScrollBars.None,
                Margin = new Padding(3),
            };
            XmgmtCommandTextBox.KeyDown += new KeyEventHandler(XmgmtCommandTextBox_KeyDown);
            xmgmtGroupBox.Controls.Add(XmgmtCommandTextBox);


            PanelServerInfo.Controls.Add(xmgmtGroupBox);
            //PanelServerInfo.Controls.Add(XmgmtCommandTextBox);
            

            //splitter between interfaces and servers
            SplitContainer splitInerfaceAndServerName=new SplitContainer();
            splitInerfaceAndServerName.Orientation=Orientation.Vertical;
            splitInerfaceAndServerName.Dock=DockStyle.Fill;
            splitInerfaceAndServerName.Location=new System.Drawing.Point(0, 0);
            splitInerfaceAndServerName.Size=new System.Drawing.Size(3000, 3000);
            splitInerfaceAndServerName.SplitterDistance=1500;
            PanelServerInterfacesServers.Controls.Add(splitInerfaceAndServerName);

            //interfaces
            TreeInterfaces=new TreeView();
            TreeInterfaces.Dock=DockStyle.Fill;
            TreeInterfaces.ShowLines=false;
            TreeInterfaces.ShowPlusMinus=false;
            TreeInterfaces.HideSelection=false;
            TreeInterfaces.AfterSelect+=TreeInterfaces_AfterSelect;

            splitInerfaceAndServerName.Panel1.Controls.Add(TreeInterfaces);

            //filterEmptyInterfacesCheckbox = new CheckBox
            //{
            //    Dock = DockStyle.Bottom,
            //    Text = "Filter Empty Interfaces",
            //};
            //filterEmptyInterfacesCheckbox.CheckedChanged += new EventHandler(filterEmptyInterfacesCheckbox_CheckedChanged);

            //splitInerfaceAndServerName.Panel1.Controls.Add(filterEmptyInterfacesCheckbox);

            //servers
            TreeServers=new TreeView();
            TreeServers.Dock=DockStyle.Fill;
            TreeServers.ShowLines=false;
            TreeServers.ShowPlusMinus=false;
            TreeServers.HideSelection=false;
            TreeServers.AfterSelect+=TreeServers_AfterSelect;
            TreeServers.ContextMenu = new ContextMenu();
            TreeServers.ContextMenu.MenuItems.Add(new MenuItem("Open &Event Viewer", this.TreeServers_OpenEventViewerClick, Shortcut.CtrlShiftE));
            TreeServers.ContextMenu.MenuItems.Add(new MenuItem("Open &LogRoot", this.TreeServers_OpenLogRootClick, Shortcut.CtrlShiftL));
            TreeServers.ContextMenu.MenuItems.Add(new MenuItem("Open &HealthCheck", this.TreeServers_OpenHealthcheckClick, Shortcut.CtrlShiftH));
            TreeServers.ContextMenu.MenuItems.Add(new MenuItem("Connect to Machine", this.TreeServers_ConnectToMachineClick, Shortcut.CtrlShiftR));

            splitInerfaceAndServerName.Panel2.Controls.Add(TreeServers);

            Button openEventViewerButton = new Button
            {
                Dock = DockStyle.Bottom,
                Text = "Open Event Viewer",
            };
            openEventViewerButton.Click += this.TreeServers_OpenEventViewerClick;

            Button openLogRootButton = new Button
            {
                Dock = DockStyle.Bottom,
                Text = "Open Log Root",
            };
            openLogRootButton.Click += this.TreeServers_OpenLogRootClick;

            Button openHealthcheckButton = new Button
            {
                Dock = DockStyle.Bottom,
                Text = "View Healthcheck",
            };
            openHealthcheckButton.Click += this.TreeServers_OpenHealthcheckClick;

            Button connectToMachineButton = new Button
            {
                Dock = DockStyle.Bottom,
                Text = "Connect with Remote Desktop",
            };
            connectToMachineButton.Click += this.TreeServers_ConnectToMachineClick;

            splitInerfaceAndServerName.Panel2.Controls.Add(openEventViewerButton);
            splitInerfaceAndServerName.Panel2.Controls.Add(openLogRootButton);
            splitInerfaceAndServerName.Panel2.Controls.Add(openHealthcheckButton);
            splitInerfaceAndServerName.Panel2.Controls.Add(connectToMachineButton);

            //
            return tabServers;
        }

        //rebuilds the server/interface info panel
        private void UpdateServerInfo()
        {
            TextServerInfo.Text="";

            if (TreeInterfaces.SelectedNode==null)
            {
                return;
            }

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();

            //interface info
            try
            {
                string interfaceName=(string)TreeInterfaces.SelectedNode.Tag;
                TextServerInfo.Text+="----- Interface: "+interfaceName+" -----\r\n";

                //get a list of all sites
                List<int> listSites=new List<int>();
                SqlDataReader reader;
                npdb.ReadData("select distinct i_site_id from t_sites where vc_environment='"+GetCurrentEnvironmentName()+"'", out reader);
                while (reader.Read())
                {
                    listSites.Add((int)reader[0]);
                }
                reader.Close();

                //get the virtual interface name that maps to the interface
                bool anyVipFound=false;
                object ret=npdb.ExecuteScalar("select vc_virtual_interface from t_virtual_interfaces where vc_interface='"+interfaceName+"'");
                if (ret!=null)
                {
                    string vipName=(string)ret;

                    //search all sites for that vip and spit out info
                    foreach (int siteID in listSites)
                    {
                        //vip
                        npdb.ReadData("exec p_config_get_virtual_interface '"+GetCurrentEnvironmentName()+"', "+siteID+", '"+vipName+"'", out reader);
                        while (reader.Read())
                        {
                            anyVipFound=true;

                            TextServerInfo.Text+="VIP site "+siteID+":";
                            TextServerInfo.Text+="  ip="+reader[3];
                            TextServerInfo.Text+="  port="+reader[4];
                            if (reader[5]!=System.DBNull.Value) TextServerInfo.Text+="-"+reader[5];
                            if (reader[15]!=System.DBNull.Value)
                            {
                                TextServerInfo.Text+="  internet_port="+reader[15];
                                if (reader[16]!=System.DBNull.Value) TextServerInfo.Text+="-"+reader[16];
                            }
                            TextServerInfo.Text+="  protocol="+reader[2];
                            TextServerInfo.Text+="\r\n";
                        }
                        reader.Close();

                        //vip override
                        npdb.ReadData("exec p_config_get_site_virtual_interface_overrides '"+GetCurrentEnvironmentName()+"', "+siteID+", '"+vipName+"'", out reader);
                        while (reader.Read())
                        {
                            anyVipFound=true;

                            TextServerInfo.Text+="VIP site "+siteID+" override:";
                            TextServerInfo.Text+="  port="+reader[0];
                            TextServerInfo.Text+="\r\n";
                        }
                        reader.Close();
                    }
                }

                if (!anyVipFound)
                {
                    TextServerInfo.Text+="No VIP\r\n";
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception getting interface info: "+e);
            }

            //server info
            if (TreeServers.SelectedNode==null)
            {
                npdb.Close();
                return;
            }

            try
            {
                string serverName=(string)TreeServers.SelectedNode.Tag;
                TextServerInfo.Text+="\r\n----- Server: "+serverName+" -----\r\n";

                //state
                SqlDataReader reader;
                npdb.ReadData("select vc_server_state from t_servers where vc_environment='"+GetCurrentEnvironmentName()+"' and vc_server='"+serverName+"'", out reader);
                while (reader.Read())
                {
                    TextServerInfo.Text+="State:  "+reader[0];
                    TextServerInfo.Text+="\r\n";
                }
                reader.Close();

                //nics
                npdb.ReadData("select vc_ip,vc_nic_role,vc_ip_default_gateway from t_server_nics where vc_environment='"+GetCurrentEnvironmentName()+"' and vc_server='"+serverName+"'", out reader);
                while (reader.Read())
                {
                    TextServerInfo.Text+="NIC:  ip="+reader[0];
                    TextServerInfo.Text+="  role="+reader[1];
                    if (reader[2] is string)
                    {
                        TextServerInfo.Text+="  gateway="+(string)reader[2];
                    }
                    TextServerInfo.Text+="\r\n";
                }
                reader.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception getting server info: "+e);
            }

            npdb.Close();
        }

        #region Events

        public void RefreshServers()
        {
            if (PanelServerInterfacesServers.InvokeRequired)
            {
                PanelServerInterfacesServers.Invoke((InvokeCode)RefreshServers);
            }
            else
            {
                //wipe old
                try
                {
                    // Stop updating the trees
                    TreeInterfaces.SuspendLayout();
                    TreeServers.SuspendLayout();

                    // Clear them out
                    TreeInterfaces.Nodes.Clear();
                    TreeServers.Nodes.Clear();

                    PanelServerInterfacesServers.Enabled = true;

                    try
                    {
                        Npdb npdb = new Npdb();
                        npdb.ConnectToServer();

                        // Retrieve all interfaces and load them into the tree
                        SqlDataReader reader;
                        npdb.ReadData("select vc_interface from t_interfaces", out reader);
                        while (reader.Read())
                        {
                            TreeNode n = new TreeNode();
                            n.Text = (string)reader[0];
                            n.Tag = (string)reader[0];

                            AddInterfaceNode(n);
                        }

                        reader.Close();
                        npdb.Close();
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error("Exception updating interfaces: " + e);
                    }

                    // This is used to ensure that the Server Info Pane is cleared out
                    UpdateServerInfo();
                }
                finally
                {
                    // Resume updating
                    TreeInterfaces.ResumeLayout();
                    TreeServers.ResumeLayout();
                }
            }
        }

        public void AddInterfaceNode(TreeNode node)
        {
            if (TreeInterfaces.InvokeRequired)
            {
                TreeInterfaces.Invoke(new Action<TreeNode>(AddInterfaceNode), node);
            }
            else
            {
                TreeInterfaces.Nodes.Add(node);
            }
        }

        private void TreeInterfaces_AfterSelect(object sender, TreeViewEventArgs tvea)
        {
            //wipe old
            TreeServers.Nodes.Clear();

            if (TreeInterfaces.SelectedNode!=null)
            {
                string interfaceName=(string)TreeInterfaces.SelectedNode.Tag;

                try
                {
                    Npdb npdb=new Npdb();
                    npdb.ConnectToServer();

                    //retrieve all servers
                    string uberQuery = String.Format(
                        @"select s.vc_server, s.vc_server_state
                            from t_servers s
                            inner join t_server_interfaces sti 
                                on s.vc_server = sti.vc_server 
                                and s.vc_environment = sti.vc_environment
                            inner join t_interfaces as i
                                on sti.vc_interface = i.vc_interface
                            inner join t_server_nics nic
                                on nic.vc_nic_role = i.vc_nic_role 
                                and nic.vc_environment = s.vc_environment 
                                and nic.vc_server = s.vc_server
                            where s.vc_environment = '{0}' and sti.vc_interface = '{1}'
                            order by s.vc_server",
                            GetCurrentEnvironmentName(), interfaceName);

                    SqlDataReader reader;
                    npdb.ReadData(uberQuery, out reader);
                    while (reader.Read())
                    {
                        //set us up the node
                        TreeNode n=new TreeNode();
                        n.Text=(string)reader[0];
                        n.Tag=(string)reader[0];

                        //add online/offline signifiers
                        bool online=(string)reader[1] == "online";
                        n.ForeColor=(online?Color.Green:Color.Red);
                        n.Text+=" ("+(string)reader[1]+")";

                        //
                        TreeServers.Nodes.Add(n);
                    }

                    reader.Close();
                    npdb.Close();
                }
                catch (Exception e)
                {
                    Global.RO.Error("Exception updating servers: "+e);
                }
            }

            UpdateServerInfo();
        }

        private void TreeServers_AfterSelect(object sender, TreeViewEventArgs tvea)
        {
            UpdateServerInfo();
        }

        private void TreeServers_OpenEventViewerClick(object sender, EventArgs e)
        {
            TreeNode selectedServer = TreeServers.SelectedNode;

            if (selectedServer == null)
            {
                return;
            }

            String server = (String)selectedServer.Tag;

            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo = new System.Diagnostics.ProcessStartInfo("eventvwr.exe", server);
            p.Start();
        }

        private void TreeServers_OpenLogRootClick(object sender, EventArgs e)
        {
            TreeNode selectedServer = TreeServers.SelectedNode;

            if (selectedServer == null)
            {
                return;
            }

            String server = (String)selectedServer.Tag;
            String logRootPath = Global.XEnv.GetSetting("setup_logroot").Trim();

            // If there's a colon, we need to create a network path
            if (logRootPath[1] == ':')
            {
                char driveLetter = logRootPath[0];
                String relativePath = logRootPath.Substring(3);
                logRootPath = String.Format(@"\\{0}\{1}$\{2}\", server, driveLetter, relativePath);
            }

            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo = new System.Diagnostics.ProcessStartInfo("explorer.exe", logRootPath);
            p.Start();
        }

        private void TreeServers_OpenHealthcheckClick(object sender, EventArgs e)
        {
            TreeNode selectedServer = TreeServers.SelectedNode;
            TreeNode selectedInterface = TreeInterfaces.SelectedNode;

            if (selectedInterface == null || selectedServer == null)
            {
                return;
            }

            String server = (String)selectedServer.Tag;
            String component = (String)selectedInterface.Tag;
            // Some components end in _int to indicate the internal interfaces
            // and we want to handle these properly so just trim it if it exists
            if (component.EndsWith("_int"))
            {
                component = component.Remove(component.Length - 4);
            }

            using (NpdbHealthchecks npdb = new NpdbHealthchecks())
            {
                npdb.ConnectToServer();

                List<String> healthchecks = npdb.GetServerHealthchecks(server, component);
                if (healthchecks.Count > 0)
                {
                    ro.Info("Opening {0} healthcheck on {1}: {2}", component, server, healthchecks[0]);
                    System.Diagnostics.Process p = new System.Diagnostics.Process();
                    p.StartInfo = new System.Diagnostics.ProcessStartInfo("iexplore.exe", healthchecks[0]);
                    p.Start();
                }
                else
                {
                    ro.Warn("Unable to find any healthcheck URLs for {0} on {1}", component, server);
                }
            }
        }

        private void TreeServers_ConnectToMachineClick(object sender, EventArgs e)
        {
            TreeNode selectedServer = TreeServers.SelectedNode;

            if (selectedServer == null)
            {
                return;
            }

            String server = (String)selectedServer.Tag;

            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo = new System.Diagnostics.ProcessStartInfo("mstsc.exe", String.Format("/v:{0}", server));
            p.Start();
        }

        void XmgmtCommandTextBox_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                String command = XmgmtCommandTextBox.Text;

                if (XmgmtAllServersCheckBox.Checked)
                {
                    if (TreeInterfaces.SelectedNode != null)
                    {
                        string interfaceName = (string)TreeInterfaces.SelectedNode.Tag;
                        Global.XEnv.ExecuteXmgmtCommand(interfaceName, command);
                        XmgmtCommandTextBox.Text = "";
                    }
                }
                else
                {
                    TreeNode selectedServer = TreeServers.SelectedNode;

                    if (selectedServer != null)
                    {
                        String server = (String)selectedServer.Tag;
                        Global.XEnv.ExecuteXmgmtCommandOneServer(server, command);
                        XmgmtCommandTextBox.Text = "";
                    }
                }
            }
        }

        #endregion //Events
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\GuiCommon\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup1\Gui.cs ===
using System;
using System.Reflection;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace STFGui
{
    /// <summary>
    /// The main gui form that holds all other forms
    /// </summary>
    public class STFGuiForm: Form
    {
        //Public components
        public RearrangeableTabControl Tabs;
        public GuiPluginHandler Plugins;
        public LinkedList<TestNode> SuiteRoots=new LinkedList<TestNode>();
        public LinkedList<string> LoadedModules=new LinkedList<string>();
        public LinkedList<string> LoadedModuleFiles=new LinkedList<string>();
        public XmlDocument Settings;

        //Internal components
        private SplitContainer splitTabsAndOutput;
        private StfTextBox outputBox;

        MRUList MRUFileList;
        MenuItem ViewFilterDebug;
        MenuItem ViewFilterInfo;
        MenuItem ViewFilterWarn;
        MenuItem ViewFilterError;
        MenuItem ViewFilterFatal;
        MenuItem ViewFilterSuccess;
        MenuItem ViewFilterAll;
        MenuItem ViewFilterNone;
        MenuItem ViewOuputLimit;
        MenuItem LogOutputToFile;

        bool allowClose = false;
        bool isClosing = false;
        bool isFirstShown = true;
        bool logToFile = false;

        FileReportDestination fileOutputDest=null;

        public delegate void InvokeCode();
        static Report ro=new Report("Gui");

        List<string> userPrefferedTabOrder=new List<string>();
        List<string> titlebarAssemblyNames=new List<string>();

        public bool LogToFile
        {
            get
            {
                return this.logToFile; 
            }

            set
            {
                lock (this)
                {
                    if (this.logToFile == value)
                    {
                        return;
                    }

                    this.logToFile = value;

                    // Assign checked value to menu item in case this set is not from the event handler.
                    LogOutputToFile.Checked = value;

                    //scrap the old
                    if (fileOutputDest != null)
                    {
                        Report.GetRoot().RemoveReportDestination(fileOutputDest);
                        fileOutputDest.Close();
                        fileOutputDest = null;
                    }

                    if (this.logToFile)
                    {
                        fileOutputDest = new FileReportDestination("FuncOutput", "Log", System.DateTime.Now);
                        Report.GetRoot().AddReportDestination(fileOutputDest);
                    }
                }
            }
        }


        //ctor
        public STFGuiForm()
        {
            // This should prevent those totally crappy no info crashes
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);

            //load settings from file
            Settings=new XmlDocument();
            try
            {
                Settings.Load("STFGui.xml");
            }
            catch
            {
                //it's ok if it fails, it's probably because it doesn't exist, so we will use defaults.
            }

            //get or create our main settings node
            XmlNode mainNode=Settings.SelectSingleNode("STFGui");
            if (mainNode==null)
            {
                mainNode=Settings.CreateNode(XmlNodeType.Element, "STFGui", "");
                Settings.AppendChild(mainNode);
            }

            XmlNode groupNode=XmlUtil.GetGroupNode(mainNode, "BaseGui");

            //set up us and our events
            Text="STFGui";
            FormClosing+=Form_Closing;
            Shown+=Form_Shown;
            CoreGlobal.TestNodeTreeLoaded+=SuiteLoaded;
            CoreGlobal.TestNodeTreeUnloaded+=SuiteUnloaded;
            CoreGlobal.ReloadAllTestTrees+=ReloadSuites;

            //set up the main menu
            Menu=new MainMenu();

            //set up the file menu
            MenuItem menuFile=new MenuItem();
            menuFile.Text="File";
            this.Menu.MenuItems.Add(menuFile);

            MenuItem menuFileLoadSuite=new MenuItem();
            menuFileLoadSuite.Text="Load Suite or Plugin";
            menuFileLoadSuite.Click+=MenuChoice_File_LoadSuite;
            menuFileLoadSuite.Shortcut = Shortcut.CtrlO;
            menuFile.MenuItems.Add(menuFileLoadSuite);

            MenuItem menuFileReloadSuites=new MenuItem();
            menuFileReloadSuites.Text="Reload Suites";
            menuFileReloadSuites.Click+=MenuChoice_File_ReloadSuites;
            menuFileReloadSuites.Shortcut = Shortcut.CtrlF5;
            menuFile.MenuItems.Add(menuFileReloadSuites);

            menuFile.MenuItems.Add(new MenuItem("-"));

            MenuItem menuFileAttachDebugger = new MenuItem();
            menuFileAttachDebugger.Text = "Attach Debugger...";
            menuFileAttachDebugger.Click += MenuChoice_File_AttachDebugger;
            menuFileAttachDebugger.Shortcut = Shortcut.CtrlK;
            menuFile.MenuItems.Add(menuFileAttachDebugger);

            MenuItem menuFilePreferences = new MenuItem();
            menuFilePreferences.Text = "Preferences...";
            menuFilePreferences.Click += MenuChoice_File_Preferences;
            menuFilePreferences.Shortcut = Shortcut.CtrlShiftP;
            menuFile.MenuItems.Add(menuFilePreferences);

            menuFile.MenuItems.Add(new MenuItem("-"));

            //MRU File list.
            string paths = XmlUtil.GetChildNodeValue(groupNode, "MRUFileList", String.Empty);
            MRUFileList = new MRUList("Recently Loaded Suites/Plugins");
            MRUFileList.ClickChild += MenuChoice_MRU_ItemClick;
            MRUFileList.LoadCSVString(paths);
            menuFile.MenuItems.Add(MRUFileList);

            menuFile.MenuItems.Add(new MenuItem("-"));

            MenuItem menuFileExit=new MenuItem();
            menuFileExit.Text="Exit";
            menuFileExit.Click+=MenuChoice_File_Exit;
            menuFile.MenuItems.Add(menuFileExit);

            //splitter between the tab-specific area and the output box area
            splitTabsAndOutput=new SplitContainer();
            splitTabsAndOutput.Orientation=Orientation.Horizontal;
            splitTabsAndOutput.Size=new System.Drawing.Size(Width, XmlUtil.GetChildNodeValue(groupNode, "SplitterHeight", 600));
            splitTabsAndOutput.Dock=DockStyle.Fill;
            ++splitTabsAndOutput.SplitterWidth;
            this.Controls.Add(splitTabsAndOutput);
            splitTabsAndOutput.SplitterDistance=(int)(splitTabsAndOutput.Height*XmlUtil.GetChildNodeValue(groupNode, "SplitterBar", 0.5f));

            //the output box
            outputBox=new StfTextBox();
            outputBox.Dock=DockStyle.Fill;

            splitTabsAndOutput.Panel2.Controls.Add(outputBox);

            try
            {
                splitTabsAndOutput.Panel2.GetType().GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(splitTabsAndOutput.Panel2, true, null);
            }
            catch (Exception e)
            {
                ro.Warn("Error occured while trying to double buffer the output box:\n" + e.ToString());
            }

            //the tab list
            Tabs=new RearrangeableTabControl();
            Tabs.Dock=DockStyle.Fill;
            splitTabsAndOutput.Panel1.Controls.Add(Tabs);
            Tabs.UserRearrangedPages+=Tabs_Rearranged;

            //set up the view menu
            MenuItem menuView=new MenuItem();
            menuView.Text="Output";
            Menu.MenuItems.Add(menuView);

            MenuItem menuClearOutput=new MenuItem("Clear", MenuChoice_Output_ClearOutput);
            menuView.MenuItems.Add(menuClearOutput);

            ViewOuputLimit = new MenuItem("Limit Output");
            MenuItem tempLimitItem = new MenuItem("No Limit", MenuChoice_Output_Limit);
            tempLimitItem.Checked = true;
            tempLimitItem.Tag = 0;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("1K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 1000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("10K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 10000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("100K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 100000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("1M", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 1000000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("10M", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 10000000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            menuView.MenuItems.Add(ViewOuputLimit);

            MenuItem menuDiv=new MenuItem();
            menuDiv.Text="-";
            menuView.MenuItems.Add(menuDiv);

            ViewFilterAll=new MenuItem("Enable ALL",MenuChoice_Output_ChangeFilter);
            menuView.MenuItems.Add(ViewFilterAll);
            ViewFilterNone=new MenuItem("Enable NONE",MenuChoice_Output_ChangeFilter);
            menuView.MenuItems.Add(ViewFilterNone);
            ViewFilterDebug=new MenuItem("Debug",MenuChoice_Output_ChangeFilter);
            ViewFilterDebug.Checked=true;
            menuView.MenuItems.Add(ViewFilterDebug);
            ViewFilterInfo=new MenuItem("Info",MenuChoice_Output_ChangeFilter);
            ViewFilterInfo.Checked=true;
            menuView.MenuItems.Add(ViewFilterInfo);
            ViewFilterWarn=new MenuItem("Warn",MenuChoice_Output_ChangeFilter);
            ViewFilterWarn.Checked=true;
            menuView.MenuItems.Add(ViewFilterWarn);
            ViewFilterError=new MenuItem("Error",MenuChoice_Output_ChangeFilter);
            ViewFilterError.Checked=true;
            menuView.MenuItems.Add(ViewFilterError);
            ViewFilterFatal=new MenuItem("Fatal",MenuChoice_Output_ChangeFilter);
            ViewFilterFatal.Checked=true;
            menuView.MenuItems.Add(ViewFilterFatal);
            ViewFilterSuccess=new MenuItem("Success",MenuChoice_Output_ChangeFilter);
            ViewFilterSuccess.Checked=true;
            menuView.MenuItems.Add(ViewFilterSuccess);

            menuDiv=new MenuItem();
            menuDiv.Text="-";
            menuView.MenuItems.Add(menuDiv);

            MenuItem menuViewLogToFile=new MenuItem("Log To File", MenuChoice_Output_LogToFile);
            menuView.MenuItems.Add(menuViewLogToFile);
            menuViewLogToFile.Checked=!XmlUtil.GetChildNodeValue(groupNode, "OutputLogToFile", logToFile);
            MenuChoice_Output_LogToFile(menuViewLogToFile, null); //this toggles it
            LogOutputToFile = menuViewLogToFile;
        }

        //app crash handler
        void CurrentDomain_UnhandledException (object sender, UnhandledExceptionEventArgs e)
        {
            System.Text.StringBuilder builder = new System.Text.StringBuilder();

            // time
            builder.Append("At ");
            builder.AppendLine(DateTime.Now.ToString());

            // termination message
            if (e.IsTerminating)
            {
                builder.AppendLine("An unhandled exception in a thread is causing STFGui to terminate, please investigate.");
            }
            else
            {
                builder.AppendLine("An unhandled exception in a thread has caused this message, please investigate.");
                builder.AppendLine("STFGui SHOULD NOT be terminating.");
            }
            builder.AppendLine();

            // sender info
            AppDomain appdom = sender as AppDomain;
            if (appdom != null)
            {
                builder.Append("AppDomain: ");
                builder.AppendLine(appdom.FriendlyName);
            }
            else
            {
                builder.Append("Sender: ");
                builder.AppendLine(sender.ToString());
            }
            builder.AppendLine();

            // exception info
            Exception exc = e.ExceptionObject as Exception;
            if (exc != null)
            {
                builder.Append(exc.ToString());
            }
            else
            {
                builder.Append("Exception is null, yikes!");
            }

            string message = builder.ToString();

            try
            {
                System.IO.File.AppendAllText(System.IO.Path.GetFullPath(".\\STFGuiCrashInfo.txt"),
                    message + Environment.NewLine + Environment.NewLine);
            }
            catch { }

            try
            {
                MessageBox.Show(message);
            }
            catch { }
        }

        //Should be called after construction to init public members.  Returns flags that indicate the success of handling paramaters
        public MainApp.STFGuiExitCode Init(string []mainAppParameters, string []pluginParameters)
        {
            MainApp.STFGuiExitCode status=MainApp.STFGuiExitCode.OK;

            //hook console output to stf, and stf output up to our output box
            Report.GetRoot().AddReportDestination(outputBox);
            Console.SetError(new TextWriterReportBridge("STDERR"));
            Console.SetOut(new TextWriterReportBridge("STDOUT"));

            //handle parameters to the gui itself
            bool ignoreDefaultPlugins=false;
            if (!HandleCommandlineOptions(mainAppParameters, ref ignoreDefaultPlugins))
            {
                status|=MainApp.STFGuiExitCode.GuiParamError;
            }

            //spit out our version
            ro.Debug(Assembly.GetExecutingAssembly().GetName().Name+" is version "+Assembly.GetExecutingAssembly().GetName().Version);
            ro.Debug("STFCore is version "+CoreGlobal.GetCoreAssembly().GetName().Version);

            //load default plugins
            //TODO: figure out if any plugin parameters had errors and set status for that here
            Plugins=new GuiPluginHandler(this, pluginParameters);
            if (!ignoreDefaultPlugins)
            {
                Plugins.LoadPluginFiles();
            }

            //load tab arrangement
            XmlNode groupNode=Settings.DocumentElement.SelectSingleNode("BaseGui");

            XmlNode tabOrderGroupNode=XmlUtil.GetGroupNode(groupNode, "TabOrder");
            foreach(XmlNode n in tabOrderGroupNode.ChildNodes)
            {
                if (n.Name=="TabName")
                {
                    userPrefferedTabOrder.Add(n.InnerXml);
                }
            }

            string initialTabName=XmlUtil.GetChildNodeValue(groupNode, "OpenTab","Functional");
            ArrangeTabsAndSelectInitialTab(initialTabName);

            return status;
        }

        private void ArrangeTabsAndSelectInitialTab(string initialTabName)
        {
            RearrangeTabsForUser();

            //select the last plugin tab if possible
            foreach (TabPage tp in Tabs.TabPages)
            {
                if (tp.Text==initialTabName)
                {
                    Tabs.SelectTab(tp);
                    break;
                }
            }
        }

        //handles commandline options that are specifically targetted at STFGui itself.  returns false if there were any errors with the parameters
        private bool HandleCommandlineOptions(string []options, ref bool outIgnoreDefaultPlugins)
        {
            bool errors=false;
            foreach (string option in options)
            {
                string lowerOption=option.ToLower();

                try
                {
                    if (lowerOption.StartsWith("-logtofile")) //turn on/off logging to file
                    {
                        LogToFile=true;
                        if (lowerOption.StartsWith("-logtofile:")) //they can also specify true or false for the value
                        {
                            int sepInd=lowerOption.IndexOf(":");
                            string value=lowerOption.Substring(sepInd+1);
                            LogToFile=bool.Parse(value);
                        }
                        ro.Debug("STFGui option: LogToFile="+LogToFile);
                    }
                    else if (lowerOption=="-ignoredefaultplugins") //don't load any default plugins
                    {
                        outIgnoreDefaultPlugins=true;
                        ro.Debug("STFGui option: IgnoreDefaultPlugins="+outIgnoreDefaultPlugins);
                    }
                    else if (lowerOption.StartsWith("-outputfilter:")) //change initial output filter
                    {
                        //break the parameter list down
                        string valueListString=lowerOption.Substring(lowerOption.IndexOf(":")+1);
                        string []values=valueListString.Split(new char[]{','});

                        //turn all off, then only turn on the ones they specified, then refresh it
                        MenuChoice_Output_ChangeFilter(ViewFilterNone, null);

                        foreach (string value in values)
                        {
                            if (value=="debug")        ViewFilterDebug.Checked  =true;
                            else if (value=="info")    ViewFilterInfo.Checked   =true;
                            else if (value=="warn")    ViewFilterWarn.Checked   =true;
                            else if (value=="error")   ViewFilterError.Checked  =true;
                            else if (value=="fatal")   ViewFilterFatal.Checked  =true;
                            else if (value=="success") ViewFilterSuccess.Checked=true;
                            else
                            {
                                //no output is enabled now, so trying to give a text message here is fruitless
                                errors=true;
                            }
                        }

                        MenuChoice_Output_ChangeFilter(null, null);
                    }
                    else if (lowerOption=="help" || lowerOption=="--help" || lowerOption=="-help" || lowerOption=="-?" || lowerOption=="-h") //h[r]elp!
                    {
                        ro.Info("STFGui Commandline Options: STFGui.exe [Module(s).dll] [Options]");
                        ro.Info("Modules are DLL files should contain either test suite(s), or plugin(s).");
                        ro.Info("Options are:");
                        ro.Info(" -LogToFile[:value]                  Turn on or off file logging.  value may be: true or false");
                        ro.Info(" -IgnoreDefaultPlugins               Do not automatically load plugins listed in STFGui.xml");
                        ro.Info(" -OutputFilter:value0[,value1,etc]   Sets the initial output filter.  values may any of: Debug, Info, Warn, Error, Fatal, Success");
                        ro.Info(" -PlugParam:PluginClass:value        Passes a parameter to a specific plugin");
                        // Putting this here, but handled as early as possible in Main.cs
                        ro.Info(" -BreakOnStart                       Breaks into the debugger at startup");
                    }
                    else //woops
                    {
                        ro.Warn("Unknown STFGui commandline parameter: "+option);
                        errors=true;
                    }
                }
                catch (Exception e) //very woops
                {
                    ro.Fatal("Exception handling commandline parameter for STFGui.\nParameter was: "+option+"\nException was: "+e);
                    errors=true;
                }
            }

            return !errors;
        }

        /// <summary>
        /// Limits the output to the given size.  0 disables the limit.
        /// </summary>
        public int OutputLimit
        {
            get { return outputBox.LengthLimit; }
            set
            {
                foreach (MenuItem item in ViewOuputLimit.MenuItems)
                {
                    item.Checked = (value == (int)item.Tag);
                }
                outputBox.LengthLimit = value;
            }
        }

        #region Menu Options and Events

        private void Tabs_Rearranged(TabControl tc)
        {
            StoreUsersTabArrangement();
        }

        private void MenuChoice_File_Exit(object sender, EventArgs args)
        {
            Close();
        }

        private void MenuChoice_File_LoadSuite(object sender, EventArgs args)
        {
            string fname = GuiCommon.ChooseFile(false, "Test Suites or Plugins (*.dll)|*.dll");
            if (fname != null)
            {
                LoadModule(fname);
            }
        }

        private void MenuChoice_MRU_ItemClick(object sender, EventArgs args)
        {
            string fname = ((MenuItem)(sender)).Text;
            if (!String.IsNullOrEmpty(fname))
                LoadModule(fname);
        }

        private void MenuChoice_File_ReloadSuites(object sender, EventArgs args)
        {
            CoreGlobal.CallReloadAllTestTrees();
        }

        private void MenuChoice_File_AttachDebugger(object sender, EventArgs args)
        {
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                System.Diagnostics.Debugger.Launch();
            }
        }

        private void MenuChoice_File_Preferences(object sender, EventArgs e)
        {
            Preferences.ShowPreferences();
        }

        private void MenuChoice_Output_ChangeFilter(object sender, EventArgs args)
        {
            MenuItem mitem=(MenuItem)sender;
            if (mitem==ViewFilterAll)
            {
                ViewFilterDebug.Checked=true;
                ViewFilterInfo.Checked=true;
                ViewFilterWarn.Checked=true;
                ViewFilterError.Checked=true;
                ViewFilterFatal.Checked=true;
                ViewFilterSuccess.Checked=true;
            }
            else if (mitem==ViewFilterNone)
            {
                ViewFilterDebug.Checked=false;
                ViewFilterInfo.Checked=false;
                ViewFilterWarn.Checked=false;
                ViewFilterError.Checked=false;
                ViewFilterFatal.Checked=false;
                ViewFilterSuccess.Checked=false;
            }
            else //individual choice
            {
                if (sender!=null)
                {
                    mitem.Checked=!mitem.Checked;
                }
            }

            //rebuild Report filter
            uint currentFilter=0;
            currentFilter|=(!ViewFilterDebug.Checked?  0:Report.DEBUG);
            currentFilter|=(!ViewFilterInfo.Checked?   0:Report.INFO);
            currentFilter|=(!ViewFilterWarn.Checked?   0:Report.WARN);
            currentFilter|=(!ViewFilterError.Checked?  0:Report.ERROR);
            currentFilter|=(!ViewFilterFatal.Checked?  0:Report.FATAL);
            currentFilter|=(!ViewFilterSuccess.Checked?0:Report.SUCCESS);

            Report.GetRoot().SetLevelFilter(currentFilter);
        }

        private void MenuChoice_Output_ClearOutput(object sender, EventArgs args)
        {
            outputBox.Text="";
        }

        private void MenuChoice_Output_Limit(object sender, EventArgs args)
        {
            MenuItem mi = (MenuItem)sender;
            OutputLimit = (int)mi.Tag;
        }

        private void MenuChoice_Output_LogToFile(object sender, EventArgs args)
        {
            //toggle menu
            bool enabled=!((MenuItem)sender).Checked;

            try
            {
                this.LogToFile = ((MenuItem)sender).Checked = enabled;
            }
            catch (Exception e)
            {
                ro.Error("Exception adding file report destination: " + e);
                ((MenuItem)sender).Checked = false;
            }
        }

        private void Form_Shown(object sender, EventArgs e)
        {
            if (isFirstShown)
            {
                isFirstShown = false;

                XmlNode groupNode = XmlUtil.GetGroupNode(Settings.SelectSingleNode("STFGui"), "BaseGui");

                Width = XmlUtil.GetChildNodeValue(groupNode, "Width", 800);
                Height = XmlUtil.GetChildNodeValue(groupNode, "Height", 600);
                Left = XmlUtil.GetChildNodeValue(groupNode, "LeftPos", 50);
                Top = XmlUtil.GetChildNodeValue(groupNode, "TopPos", 50);
                if (!SystemInformation.VirtualScreen.IntersectsWith(this.Bounds))
                {
                    Left = 50;
                    Top = 50;
                }

                if (XmlUtil.GetChildNodeValue(groupNode, "IsMaxxed", false))
                {
                    WindowState = FormWindowState.Maximized;
                }

                Plugins.NotifyGuiShown();
            }
        }

        //event handler for a requets to close the form
        private void Form_Closing(object sender, FormClosingEventArgs e)
        {
            //if we haven't kicked off the close worker thread, do that.
            if (!isClosing)
            {
                isClosing=true;
                ThreadMaker.CreateThread(ThreadProcShutdown).Start();
            }

            //if we don't want to close yet, cancel it
            if (!allowClose)
            {
                e.Cancel=true;
                return;
            }

            //save our settings
            XmlNode groupNode=Settings.DocumentElement.SelectSingleNode("BaseGui");

            if (Height>50 && Width>50 && WindowState==FormWindowState.Normal) //don't save the form size if the form is max'd or min'd
            {
                XmlUtil.SetChildNodeValue(groupNode, "Width", Width);
                XmlUtil.SetChildNodeValue(groupNode, "Height", Height);
                XmlUtil.SetChildNodeValue(groupNode, "LeftPos", Left);
                XmlUtil.SetChildNodeValue(groupNode, "TopPos", Top);
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", false);
            }
            else if (WindowState==FormWindowState.Maximized)
            {
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", true);
            }

            if (splitTabsAndOutput.Height>50)
            {
                XmlUtil.SetChildNodeValue(groupNode, "SplitterHeight", splitTabsAndOutput.Height); //base bar off the control size not the form size
                XmlUtil.SetChildNodeValue(groupNode, "SplitterBar", (splitTabsAndOutput.SplitterDistance+0.5f)/splitTabsAndOutput.Height);
            }

            StoreUsersTabArrangement();
            if (userPrefferedTabOrder.Count>0)
            {
                XmlNode orderGroupNode=XmlUtil.GetGroupNode(groupNode, "TabOrder");
                orderGroupNode.RemoveAll();
                foreach (string s in userPrefferedTabOrder)
                {
                    XmlNode n=Settings.CreateNode(XmlNodeType.Element, "TabName", "");
                    n.InnerXml=s;
                    orderGroupNode.AppendChild(n);
                }
            }

            if (Tabs.SelectedTab!=null)
            {
                XmlUtil.SetChildNodeValue(groupNode, "OpenTab", Tabs.SelectedTab.Text);
            }

            XmlUtil.SetChildNodeValue(groupNode, "OutputLogToFile", fileOutputDest!=null);

            XmlUtil.SetChildNodeValue(groupNode, "MRUFileList", MRUFileList.GetCSVString());

            try
            {
                Settings.Save("STFGui.xml");
            }
            catch (System.Exception exception)
            {
                ro.Fatal("Exception trying to save STFGui.xml:\n"+exception);
            }
        }

        #endregion //Menu Options and Events

        //This handles shutting down all the gui components on it's own thread.  We won't actually close until it says to.
        private void ThreadProcShutdown()
        {
            //shut down plugin handler
            Plugins.NotifyGuiClosing();

            //destroy all our nodes
            foreach (TestNode n in SuiteRoots)
            {
                try
                {
                    n.Dispose();
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception trying to dispose TestNode "+n.FullName+": "+e);
                }
            }

            //now it's ok to close
            allowClose=true;
            this.Invoke(new InvokeCode(delegate
            {
                //remove our output box from outputs
                Report.GetRoot().RemoveReportDestination(outputBox);
                outputBox.IgnoreOutput=true;
                outputBox.Hide();
                outputBox.Dispose();

                //now poof us
                Close();
            }));
        }

        //Rebuilds the title bar text
        private void UpdateTitlebarText()
        {
            Text="STFGui";
            if (titlebarAssemblyNames.Count>0)
            {
                Text+=" - ";
                bool first=true;
                foreach (string asmName in titlebarAssemblyNames)
                {
                    if (!first)
                    {
                        Text+=", ";
                    }
                    Text+=asmName;
                    first=false;
                }
            }
        }

        /// <summary>
        /// Loads tests and plugins from a file that contains an assembly (usually .dll)
        /// Returns true only if something was loaded and everything in the assembly was loaded successfully, or if that assembly was already loaded.
        /// </summary>
        public bool LoadModule(string fname)
        {
            try
            {
                MRUFileList.AddItem(fname);
            }
            catch (Exception ex)
            {
                ro.Warn("Exception while trying to add an item to the recently used file list. Does not block functionality but probably a bug.");
                ro.Warn(ex.Message);
            }

            //load the assembly
            bool ok=true;
            bool loadedAnything=false;
            Assembly asm;
            try
            {
                asm=AssemblyUtils.LoadAssemblyUsingDefaultMethod(fname);

                //if it's already loaded, don't load it again
                foreach (string loadedName in LoadedModules)
                {
                    if (asm.FullName==loadedName)
                    {
                        ro.Debug(fname+" is already loaded.");
                        return true;
                    }
                }

                ro.Debug("Opened "+fname+" version "+asm.GetName().Version);
            }
            catch (Exception e)
            {
                ro.Fatal("Exception loading assembly "+fname+": "+e);
                return false;
            }

            //notify that we are about to load it
            Plugins.NotifyModuleLoading(fname);

            //load tests from it
            try
            {
                TestNode suite=TestNode.GenerateNodeTree(fname);
                if (suite.ChildrenCount==0)
                {
                    ro.Info("No TestNodes found in: "+fname);
                }
                else
                {
                    loadedAnything=true;
                    ro.Debug("TestNodes loaded successfully from: "+fname);

                    titlebarAssemblyNames.Add(asm.GetName().Name); //add to list to show in title bar
                    UpdateTitlebarText();
                }
            }
            catch (Exception e)
            {
                ro.Fatal("Exception trying to load nodes from "+fname+": "+e);
                ok=false;
            }

            //load plugins from it
            try
            {
                bool foundPlugs=Plugins.LoadAllPluginsInAssembly(asm);
                loadedAnything=loadedAnything||foundPlugs;
            }
            catch (Exception e)
            {
                ro.Fatal("Exception trying to load plugins from "+fname+": "+e);
                ok=false;
            }

            RearrangeTabsForUser();

            //
            LoadedModules.AddLast(asm.FullName);
            LoadedModuleFiles.AddLast(fname);
            return ok && loadedAnything;
        }

        private void SuiteLoaded(TestNode root)
        {
            SuiteRoots.AddLast(root);
            Plugins.NotifySuiteLoaded(root);
        }

        private void SuiteUnloaded(TestNode root)
        {
            SuiteRoots.Remove(root);
            Plugins.NotifySuiteUnloading(root);
        }

        private void ReloadSuites()
        {
            //unload old
            ro.Debug("Unloading suites...");
            while (SuiteRoots.Count!=0)
            {
                CoreGlobal.CallTestNodeTreeUnload(SuiteRoots.Last.Value);
            }

            //search all modules for nodes again
            ro.Debug("Reloading suites...");
            foreach (string fname in LoadedModuleFiles)
            {
                try
                {
                    TestNode suite=TestNode.GenerateNodeTree(fname);
                    if (suite.ChildrenCount==0)
                    {
                        ro.Info("No TestNode(s) found in: "+fname);
                    }
                    else
                    {
                        ro.Debug("TestNodes loaded successfully from: "+fname);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception trying to load nodes from "+fname+": "+e);
                }
            }
        }

        //rearranges the tabs to match the user's preferance
        private void RearrangeTabsForUser()
        {
            //current
            TabPage curTab=Tabs.SelectedTab;
            LinkedList<TabPage> currentPages=new LinkedList<TabPage>();
            foreach (TabPage p in Tabs.TabPages)
            {
                currentPages.AddLast(p);
            }

            //wipe old and rebuild as they like
            Tabs.TabPages.Clear();
            foreach (string s in userPrefferedTabOrder)
            {
                foreach (TabPage p in currentPages)
                {
                    if (p.Text==s)
                    {
                        Tabs.TabPages.Add(p);
                        currentPages.Remove(p);
                        break;
                    }
                }
            }

            //add extras to end
            foreach (TabPage p in currentPages)
            {
                Tabs.TabPages.Add(p);
            }

            Tabs.SelectedTab=curTab;
        }

        //saves the current tab arrangement as the users's preferance
        private void StoreUsersTabArrangement()
        {
            userPrefferedTabOrder.Clear();
            foreach (TabPage p in Tabs.TabPages)
            {
                userPrefferedTabOrder.Add(p.Text);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\GuiCommon\GuiCommon.cs ===
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Collections.Generic;

using ServerTestFramework;

namespace STFGui
{
    /// <summary>
    /// Commonly used gui things.
    /// </summary>
    public class GuiCommon
    {
        /// <summary>
        /// Pops up a file selection window.
        /// </summary>
        /// <param name="isForSaving">Whether to show a save or load dialog.</param>
        /// <param name="typeList">The OpenFileDialog.Filter string. (for example: "Test Suites (*.dll)|*.dll")</param>
        /// <returns>The chosen file, or null if none.</returns>
        public static string ChooseFile(bool isForSaving, string filterString)
        {
            //store current directory: win32 common controls evilly alter the current directory, which can screw a lot of things up
            string curDir = System.Environment.CurrentDirectory;

            // Popup handler opens file dialog so user can manually load a test suite DLL.
            DialogResult res;
            string fname;
            if (isForSaving)
            {
                SaveFileDialog sfd = new SaveFileDialog();
                sfd.CheckFileExists = !isForSaving;
                sfd.CheckPathExists = true;
                sfd.Filter = filterString;
                res = sfd.ShowDialog();
                fname = sfd.FileName;
            }
            else
            {
                OpenFileDialog ofd = new OpenFileDialog();
                ofd.CheckFileExists = !isForSaving;
                ofd.CheckPathExists = true;
                ofd.Filter = filterString;
                res = ofd.ShowDialog();
                fname = ofd.FileName;
            }

            //fix back the current directory
            System.Environment.CurrentDirectory = curDir;

            if (res==DialogResult.OK)
            {
                return fname;
            }

            return null;
        }

        /// <summary>
        /// Retrieves a number from the user.
        /// </summary>
        public static int GetNumberFromUser(Form parentForm, string nameOfValue, int defaultValue)
        {
            while (true)
            {
                //make a box for this
                Form form=new Form();
                form.SetBounds(0,0,200,85,BoundsSpecified.Size);
                form.Text=nameOfValue;
                form.FormBorderStyle=FormBorderStyle.FixedDialog;
                form.MaximizeBox=false;

                Size expectedFormSize=new Size(192,58); //for funky windows ui styles, we need to adjust form size
                Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
                form.Size+=diffFormSize;

                //make controls
                TextBox input=new TextBox();
                input.Text=defaultValue.ToString();
                input.SetBounds(25,5,150,25);

                Button butOk=new Button();
                butOk.Text="Ok";
                butOk.SetBounds(15,30,75,25);
                butOk.DialogResult=DialogResult.OK;

                Button butCan=new Button();
                butCan.Text="Cancel";
                butCan.SetBounds(200-15-75,30,75,25);
                butCan.DialogResult=DialogResult.Cancel;

                //put it together and show it
                form.Controls.Add(input);
                form.Controls.Add(butOk);
                form.Controls.Add(butCan);

                form.AcceptButton=butOk;
                form.CancelButton=butCan;
                form.ShowDialog(parentForm);

                //handle result
                if (form.DialogResult==DialogResult.OK)
                {
                    try
                    {
                        return int.Parse(input.Text);
                    }
                    catch
                    {
                        MessageBox.Show(form, "Entered value is not a valid integer.");
                    }
                }
                else
                    return defaultValue;
            }
        }

        /// <summary>
        /// Retrieves a string from the user.
        /// </summary>
        public static string GetStringFromUser(Form parentForm, string nameOfValue, string defaultValue)
        {
            //make a box for this
            Form form=new Form();
            form.SetBounds(0,0,200,85,BoundsSpecified.Size);
            form.Text=nameOfValue;
            form.FormBorderStyle=FormBorderStyle.FixedDialog;
            form.MaximizeBox=false;

            Size expectedFormSize=new Size(192,58); //for funky windows ui styles, we need to adjust form size
            Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
            form.Size+=diffFormSize;

            //make controls
            TextBox input=new TextBox();
            input.Text=defaultValue;
            input.SetBounds(25,5,150,25);

            Button butOk=new Button();
            butOk.Text="Ok";
            butOk.SetBounds(15,30,75,25);
            butOk.DialogResult=DialogResult.OK;

            Button butCan=new Button();
            butCan.Text="Cancel";
            butCan.SetBounds(200-15-75,30,75,25);
            butCan.DialogResult=DialogResult.Cancel;

            //put it together and show it
            form.Controls.Add(input);
            form.Controls.Add(butOk);
            form.Controls.Add(butCan);

            form.AcceptButton=butOk;
            form.CancelButton=butCan;
            form.ShowDialog(parentForm);

            //handle result
            if (form.DialogResult==DialogResult.OK)
            {
                return input.Text;
            }
            else
            {
                return null;
            }
        }
    };

    /// <summary>
    /// Contol derived from a combo box and a checked list box.  Dropping down the control simply shows the list box instead.
    /// </summary>
    public class ComboDropBoxWithListOfChecks: ComboBox
    {
        //event for when a checkbox is changed
        public delegate void ChecksChangedDelegate(ComboDropBoxWithListOfChecks box, ItemCheckEventArgs itemChangeArgs);
        public event ChecksChangedDelegate ChecksChanged;

        //automatically set text based on checked boxes?
        public bool AutoBuildText=true;
        public string TextWhenNoneChecked
        {
            get { return textWhenNoneChecked; }
            set
            {
                textWhenNoneChecked=value;
                OnTextChanged(null);
            }
        }
        public string TextWhenNoOptions
        {
            get { return textWhenNoOptions; }
            set
            {
                textWhenNoOptions=value;
                OnTextChanged(null);
            }
        }

        public new bool Enabled //whether it "can" be enabled
        {
            get { return enabled; }
            set
            {
                enabled=value;
                if (controlEnabled && enabled)
                {
                    base.Enabled=true;
                }
                if (!controlEnabled || !enabled)
                {
                    base.Enabled=false;
                }
            }
        }
        public bool CurrentlyEnabled //whether the user currently sees it as enabled
        {
            get { return base.Enabled; }
        }

        //Add an item to the list
        public void AddItem(string name)
        {
            list.Items.Add(name);
            OnTextChanged(null);
        }

        //Remove an item from the list by index
        public void RemoveItem(int ind)
        {
            list.Items.Remove(ind);
        }

        //Retrieves a list of items (this should be considered read-only)
        public CheckedListBox.ObjectCollection GetItems()
        {
            return list.Items;
        }

        public void SetItemChecked(int itemIndex, bool isChecked)
        {
            list.SetItemChecked(itemIndex, isChecked);
            OnTextChanged(null);
        }

        public bool IsItemChecked(int itemIndex)
        {
            return list.GetItemChecked(itemIndex);
        }

        // -- implementation details

        //populate this list with anything you care about
        private CheckedListBox list=new CheckedListBox();

        private string textWhenNoneChecked="";
        private string textWhenNoOptions="";
        
        private bool enabled=true;
        private bool controlEnabled=true;

        //ctor
        public ComboDropBoxWithListOfChecks()
        {
            list.Visible=false;
            list.CheckOnClick=true;
            list.MouseLeave+=List_LostFocus;
            list.ItemCheck+=ItemCheckEventHandler;
            
            OnTextChanged(null);
        }

        //drop down event - only we do the magic
        protected override void OnDropDown(EventArgs ea)
        {
            if (Parent==null || list.Items.Count==0)
            {
                return;
            }

            //poof goes us
            DropDownHeight=1;
            SendToBack();
            DroppedDown=false;
            Visible=false;

            //move the List to where we are and show it
            TopLevelControl.Controls.Add(list);
            list.Location=GetTopLevelLocation();
            list.Size=Size;
            list.Visible=true;
            list.BringToFront();
            list.Height=list.GetPreferredSize(Size).Height;

        }

        //converts my location to the top level control's location
        Point GetTopLevelLocation()
        {
            Point p=new Point();
            Control c=this;
            while (c!=TopLevelControl)
            {
                p.X+=c.Location.X;
                p.Y+=c.Location.Y;

                c=c.Parent;
            }
            return p;
        }

        private void List_LostFocus(object sender, EventArgs args)
        {
            list.Visible=false;

            Visible=true;
            BringToFront();
            OnTextChanged(args);
        }

        public void ItemCheckEventHandler(object sender, ItemCheckEventArgs e)
        {
            if (AutoBuildText)
            {
                OnTextChanged(e);
            }

            if (ChecksChanged!=null)
            {
                ChecksChanged(this, e);
            }
        }

        protected override void OnClick(EventArgs args)
        {
            OnDropDown(args);
        }

        protected override void OnTextChanged(EventArgs args)
        {
            if (AutoBuildText)
            {
                //build our string from our associated checks
                string myStr="";
                foreach (int i in list.CheckedIndices)
                {
                    if (myStr.Length!=0) myStr+=",";
                    myStr+=list.Items[i];
                }

                //update the box now
                if (list.Items.Count==0)
                {
                    myStr=TextWhenNoOptions;
                    controlEnabled=false;
                }
                else
                {
                    controlEnabled=true;
                }
                Enabled=Enabled;

                if (myStr.Length==0)
                {
                    myStr=TextWhenNoneChecked;
                }

                if (Text!=myStr)
                {
                    Text=myStr;
                }
            }

            base.OnTextChanged(args);
        }
    };

    /// <summary>
    /// A tab control where the user may rearrange the tabs on their whim.
    /// Usable only for horizontally aligned tabs at the moment.
    /// </summary>
    public class RearrangeableTabControl: TabControl
    {
        /// <summary>
        /// Event is triggered whenever the user manually rearranges the tab pages.
        /// </summary>
        public event UserRearrangedPagesDelegate UserRearrangedPages;
        public delegate void UserRearrangedPagesDelegate(TabControl tc);

        // -- internals

        private bool allowDrag=false; //used to prevent other processes from dragging to us

        public RearrangeableTabControl()
        {
            AllowDrop=true;
            MouseDown+=Tabs_MouseDown;
            DragEnter+=Tabs_DragEnter;
            DragDrop+=Tabs_DragDrop;
            LostFocus+=Tabs_LostFocus;
        }

        private void Tabs_MouseDown(object sender, MouseEventArgs ea)
        {
            bool junk;
            int ind=FindTabPage((new Point(ea.X, ea.Y)), out junk);
            if (ind!=-1)
            {
                allowDrag=true;
                DoDragDrop(TabPages[ind], DragDropEffects.Move);
            }
        }

        private void Tabs_DragEnter(object sender, DragEventArgs ea)
        {
            if (!allowDrag)
            {
                ea.Effect=DragDropEffects.None;
                return;
            }

            //
            ea.Effect=DragDropEffects.Move;
        }

        private void Tabs_DragDrop(object sender, DragEventArgs ea)
        {
            allowDrag=false;

            if (ea.Effect!=DragDropEffects.None)
            {
                if(ea.Data.GetDataPresent(typeof(TabPage)))
                {
                    //get source index
                    TabPage sourcePage=(TabPage)ea.Data.GetData(typeof(TabPage));
                    int srcInd=-1;
                    for (int i=0; i<TabPages.Count; ++i)
                    {
                        if (TabPages[i]==sourcePage)
                        {
                            srcInd=i;
                        }
                    }

                    //get dest index
                    bool isLeftHalf;
                    int dstInd=FindTabPage(PointToClient(new Point(ea.X, ea.Y)), out isLeftHalf);
                    if (dstInd!=-1 && srcInd!=-1)
                    {
                        //see if the drop location would even move it
                        if (dstInd!=srcInd && (isLeftHalf?(dstInd-1!=srcInd):(dstInd+1!=srcInd)))
                        {
                            //build the rearranged list of tab pages
                            List<TabPage> newPages=new List<TabPage>();
                            for (int i=0; i<TabPages.Count; ++i)
                            {
                                if (dstInd<srcInd) //right to left
                                {
                                    if (i==dstInd)
                                    {
                                        newPages.Add(TabPages[srcInd]);
                                    }
                                    else
                                    {
                                        int ri=i;
                                        if (i>dstInd) --ri;
                                        if (ri>=srcInd) ++ri;
                                        newPages.Add(TabPages[ri]);
                                    }
                                }
                                else if (dstInd>srcInd) //left to right
                                {
                                    if (i==dstInd)
                                    {
                                        newPages.Add(TabPages[srcInd]);
                                    }
                                    else
                                    {
                                        int ri=i;
                                        if (i>=srcInd) ++ri;
                                        if (ri>dstInd) --ri;
                                        newPages.Add(TabPages[ri]);
                                    }
                                }
                            }

                            //replace original list
                            TabPage curTab=SelectedTab;
                            TabPages.Clear();
                            foreach (TabPage tp in newPages)
                            {
                                TabPages.Add(tp);
                            }
                            SelectedTab=curTab;

                            //trigger event
                            if (UserRearrangedPages!=null)
                            {
                                UserRearrangedPages(this);
                            }
                        }
                    }
                }
            }
        }

        private void Tabs_LostFocus(object sender, EventArgs e)
        {
            allowDrag=false;
        }

        //gets which tab page index a point is over (-1 if none), and which half it is
        private int FindTabPage(Point clientPoint, out bool isLeftHalf)
        {
            for(int i=0; i<TabPages.Count; ++i)
            {
                Rectangle rect=GetTabRect(i);
                if(rect.Contains(clientPoint))
                {
                    isLeftHalf=clientPoint.X<(rect.X+rect.Width/2);
                    return i;
                }
            }
            
            isLeftHalf=true;
            return -1;
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup\Plugins\LiveEnvironment\UODB.cs ===
using System;
using System.Threading;
using System.Windows.Forms;
using System.Drawing;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Plugins;
using ServerTestFramework.Database;

using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;

namespace STFGui.Plugins
{
    public partial class EnvironmentPlugin : IPluginSetup, IPluginGui
    {

        Panel panelUODBList;
        Panel panelUODBQuery;
        Panel panelUODBButtons;

        ListBox listboxPartitionList;
        TextBox textboxQuery;

        Button butUODBExecute;
        Button butUODBSelectAll;
        Button butUODBSelectPrimaries;
        Button butUODBSelectReplicas;
        Button butUODBSelectHash;

        //gets the tab page for the uodb stuff
        TabPage MakeUODBTabPage()
        {
            TabPage tabUODB=new TabPage();
            tabUODB.Text="UODB";
            tabUODB.Size=new System.Drawing.Size(1000, 1000);

            //make a splitter between the list and the query
            SplitContainer splitListAndQuery=new SplitContainer();
            splitListAndQuery.Orientation=Orientation.Vertical;
            splitListAndQuery.Dock=DockStyle.Fill;
            splitListAndQuery.Location=new System.Drawing.Point(0, 0);
            splitListAndQuery.Size=new System.Drawing.Size(1000, 1000);
            splitListAndQuery.Panel2MinSize=100;
            splitListAndQuery.Panel1MinSize=150;
            splitListAndQuery.SplitterDistance=250;
            splitListAndQuery.FixedPanel=FixedPanel.Panel1;
            splitListAndQuery.IsSplitterFixed=false;
            tabUODB.Controls.Add(splitListAndQuery);

            Panel panelUODBListAndButtons=splitListAndQuery.Panel1;
            panelUODBQuery=splitListAndQuery.Panel2;

            //make a splitter between the list and the buttons
            SplitContainer splitListAndButtons=new SplitContainer();
            splitListAndButtons.Orientation=Orientation.Horizontal;
            splitListAndButtons.Dock=DockStyle.Fill;
            splitListAndButtons.Location=new System.Drawing.Point(0, 0);
            splitListAndButtons.Size=new System.Drawing.Size(250, 1000);
            splitListAndButtons.Panel2MinSize=110;
            splitListAndButtons.Panel1MinSize=100;
            splitListAndButtons.SplitterDistance=890;
            splitListAndButtons.FixedPanel=FixedPanel.Panel2;
            splitListAndButtons.IsSplitterFixed=true;
            panelUODBListAndButtons.Controls.Add(splitListAndButtons);

            panelUODBList=splitListAndButtons.Panel1;
            panelUODBButtons=splitListAndButtons.Panel2;
            panelUODBButtons.Resize+=ButtonsPanelResize;

            //uodb list
            listboxPartitionList=new ListBox();
            listboxPartitionList.Dock=DockStyle.Fill;
            listboxPartitionList.Sorted=true;
            listboxPartitionList.SelectionMode=SelectionMode.MultiExtended;
            listboxPartitionList.SelectedIndexChanged+=PartitionListSelectionChanged;
            panelUODBList.Controls.Add(listboxPartitionList);

            Label labStar=new Label();
            labStar.Text="* = Primary Partition";
            labStar.TextAlign=ContentAlignment.TopLeft;
            labStar.Location=new System.Drawing.Point(0, 0);
            labStar.Size=new System.Drawing.Size(250, 15);
            labStar.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            panelUODBButtons.Controls.Add(labStar);

            //query box
            textboxQuery=new TextBox();
            textboxQuery.Dock=DockStyle.Fill;
            textboxQuery.Multiline=true;
            textboxQuery.ScrollBars=ScrollBars.Both;
            textboxQuery.WordWrap=false;
            textboxQuery.Text="--Query Box\r\nselect name from sysobjects where type='U' and name like 't_%' order by name;";
            textboxQuery.ShortcutsEnabled=true;
            textboxQuery.Font=new Font("Lucida Console", 8.25F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
            panelUODBQuery.Controls.Add(textboxQuery);

            //button group splitter
            Label labExecute=new Label();
            labExecute.Text="--";
            labExecute.TextAlign=ContentAlignment.TopCenter;
            labExecute.Location=new System.Drawing.Point(10, 70);
            labExecute.Size=new System.Drawing.Size(230, 15);
            labExecute.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            panelUODBButtons.Controls.Add(labExecute);

            //execute query button
            butUODBExecute=new Button();
            butUODBExecute.Text="Execute";
            butUODBExecute.Location=new System.Drawing.Point(10, 85);
            butUODBExecute.Size=new System.Drawing.Size(230, 25);
            butUODBExecute.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            butUODBExecute.Click+=ExecuteQueryClick;
            panelUODBButtons.Controls.Add(butUODBExecute);

            //select buttons
            Label labSelectPartitions=new Label();
            labSelectPartitions.Text="Select Partitions:";
            labSelectPartitions.TextAlign=ContentAlignment.TopCenter;
            labSelectPartitions.Location=new System.Drawing.Point(10, 15);
            labSelectPartitions.Size=new System.Drawing.Size(230, 15);
            labSelectPartitions.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            panelUODBButtons.Controls.Add(labSelectPartitions);

            butUODBSelectAll=new Button();
            butUODBSelectAll.Text="All";
            butUODBSelectAll.Location=new System.Drawing.Point(10, 30);
            butUODBSelectAll.Size=new System.Drawing.Size(110, 20);
            butUODBSelectAll.Anchor=AnchorStyles.Left;
            butUODBSelectAll.Click+=UodbSelectAllClick;
            panelUODBButtons.Controls.Add(butUODBSelectAll);

            butUODBSelectReplicas=new Button();
            butUODBSelectReplicas.Text="Replicas";
            butUODBSelectReplicas.Location=new System.Drawing.Point(10, 50);
            butUODBSelectReplicas.Size=new System.Drawing.Size(110, 20);
            butUODBSelectReplicas.Anchor=AnchorStyles.Left;
            butUODBSelectReplicas.Click+=UodbSelectReplicaClick;
            panelUODBButtons.Controls.Add(butUODBSelectReplicas);

            butUODBSelectPrimaries=new Button();
            butUODBSelectPrimaries.Text="Primaries";
            butUODBSelectPrimaries.Location=new System.Drawing.Point(130, 30);
            butUODBSelectPrimaries.Size=new System.Drawing.Size(110, 20);
            butUODBSelectPrimaries.Anchor=AnchorStyles.None;
            butUODBSelectPrimaries.Click+=UodbSelectPrimaryClick;
            panelUODBButtons.Controls.Add(butUODBSelectPrimaries);

            butUODBSelectHash=new Button();
            butUODBSelectHash.Text="Hash";
            butUODBSelectHash.Location=new System.Drawing.Point(130, 50);
            butUODBSelectHash.Size=new System.Drawing.Size(110, 20);
            butUODBSelectHash.Anchor=AnchorStyles.None;
            butUODBSelectHash.Click+=UodbSelectHashClick;
            panelUODBButtons.Controls.Add(butUODBSelectHash);

            ResetUodbTab();

            //
            return tabUODB;
        }

        //clears out environment-specific stuff and disables controls
        protected void ResetUodbTab()
        {
            butUODBExecute.Enabled=false;
            butUODBSelectAll.Enabled=false;
            butUODBSelectReplicas.Enabled=false;
            butUODBSelectHash.Enabled=false;
            butUODBSelectPrimaries.Enabled=false;
            listboxPartitionList.Items.Clear();
        }

        //gets a WstConnection set up for the current environment.  This does not call Open() though.
        private static WstConnection GetEnvironmentWstConnection()
        {
            string applicationName=WSClient.SiteName+ConfigUtil.UodbWebstoreApp;
            WstConnection con=new WstConnection(applicationName);
            return con;
        }

        //an entry on the partition list
        class PartitionEntry
        {
            public string Server;
            public string Partition;
            public bool IsPrimary;
            public string Status;

            public override string ToString()
            {
                return Partition+
                (IsPrimary?"* ":" ")+
                "("+Server+")"+
                " - "+Status;
            }
        };

        //gets a WstCommand for a specific partition on a connection
        private static WstCommand GetPartitionWstCommand(WstConnection con, PartitionEntry pe)
        {
            WstCommand cmd=con.CreateCommand();

            //find the webstore db for the partition
            WebstoreDatabase db=null;
            foreach (WebstoreSQLFss failSafeSet in con.SqlPartitions)
            {
                foreach (WebstoreDatabase wsdb in failSafeSet.Databases)
                {
                    if (pe.Server==wsdb.ServerName && pe.Partition==wsdb.Name)
                    {
                        db=wsdb;
                    }
                }
            }

            if (db==null)
            {
                throw new System.Exception("Webstore Partition not found to match the given PartitionEntry: "+pe);
            }

            //set up the command for the partition
            cmd.WstFailoverMode=WstFailoverMode.SpecificDatabase;
            cmd.Database=db;

            return cmd;
        }

        #region Events

        //refreshes partition list and state
        public void RefreshUODB()
        {
            listboxPartitionList.Items.Clear();

            try
            {
                //open a webstore connection
                WstConnection con=GetEnvironmentWstConnection();
                con.Open();

                //add all sql partitions
                foreach (WebstoreSQLFss failSafeSet in con.SqlPartitions)
                {
                    foreach (WebstoreDatabase wsdb in failSafeSet.Databases)
                    {
                        PartitionEntry pe=new PartitionEntry();
                        pe.Server=wsdb.ServerName;
                        pe.Partition=wsdb.Name;
                        pe.IsPrimary=(wsdb.Name==failSafeSet.DefaultPrimaryDB.Name);
                        pe.Status=wsdb.Status.ToString();

                        listboxPartitionList.Items.Add(pe);
                    }
                }

                //
                con.Close();
            }
            catch (ThreadAbortException)
            {
                // We don't want to handle the thread abort exception
                // The thread abort will be automatically rethrown
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception trying to populate webstore UODB list: "+e);
            }

            //select all primary partitions by default
            UodbSelectPrimaryClick(null, null);

            //enable stuff now that we have data
            butUODBSelectAll.Enabled=true;
            butUODBSelectPrimaries.Enabled=true;
            butUODBSelectReplicas.Enabled=true;
            butUODBSelectHash.Enabled=true;
        }

        //clicked the "select all partitions" button
        public void UodbSelectAllClick(object sender, EventArgs ea)
        {
            listboxPartitionList.SelectedItems.Clear();

            //copy the list out first, since .NET does some strange things internally with the lests that break using a regular enumerator
            List<PartitionEntry> allList=new List<PartitionEntry>();

            foreach (PartitionEntry pe in listboxPartitionList.Items)
            {
                allList.Add(pe);
            }

            //now add primaries to the selected list
            foreach (PartitionEntry pe in allList)
            {
                listboxPartitionList.SelectedItems.Add(pe);
            }
        }

        //clicked the "select all primary partitions" button
        public void UodbSelectPrimaryClick(object sender, EventArgs ea)
        {
            listboxPartitionList.SelectedItems.Clear();

            //copy the list out first, since .NET does some strange things internally with the lests that break using a regular enumerator
            List<PartitionEntry> primaryList=new List<PartitionEntry>();

            foreach (PartitionEntry pe in listboxPartitionList.Items)
            {
                if (pe.IsPrimary)
                {
                    primaryList.Add(pe);
                }
            }

            //now add primaries to the selected list
            foreach (PartitionEntry pe in primaryList)
            {
                listboxPartitionList.SelectedItems.Add(pe);
            }
        }

        //clicked the "select all replica partitions" button
        public void UodbSelectReplicaClick(object sender, EventArgs ea)
        {
            listboxPartitionList.SelectedItems.Clear();

            //copy the list out first, since .NET does some strange things internally with the lests that break using a regular enumerator
            List<PartitionEntry> replicaList=new List<PartitionEntry>();

            foreach (PartitionEntry pe in listboxPartitionList.Items)
            {
                if (!pe.IsPrimary)
                {
                    replicaList.Add(pe);
                }
            }

            //now add primaries to the selected list
            foreach (PartitionEntry pe in replicaList)
            {
                listboxPartitionList.SelectedItems.Add(pe);
            }
        }

        //clicked the "select partition from a hash" button
        public void UodbSelectHashClick(object sender, EventArgs ea)
        {
            MessageBox.Show("TODO: Implement hash functionality.");
        }

        //the selected partitions changed
        public void PartitionListSelectionChanged(object sender, EventArgs ea)
        {
            butUODBExecute.Enabled=(listboxPartitionList.SelectedItems.Count>0);
        }

        //called when the buttons panel is resized
        public void ButtonsPanelResize(object sender, EventArgs ea)
        {
            //resize the buttons
            int width=(panelUODBButtons.Width-30)/2;
            butUODBSelectAll.Width=width;
            butUODBSelectPrimaries.Width=width;
            butUODBSelectReplicas.Width=width;
            butUODBSelectHash.Width=width;

            //right-anchoring the right-side buttons fails to preserve the space on resize.. so manually adjust location for those
            System.Drawing.Point tmpLoc=butUODBSelectPrimaries.Location;
            tmpLoc.X=panelUODBButtons.Width-10-butUODBSelectPrimaries.Width;
            butUODBSelectPrimaries.Location=tmpLoc;

            tmpLoc=butUODBSelectHash.Location;
            tmpLoc.X=panelUODBButtons.Width-10-butUODBSelectHash.Width;
            butUODBSelectHash.Location=tmpLoc;
        }

        //clicked the button to execute the query
        public void ExecuteQueryClick(object sender, EventArgs ea)
        {
            butUODBExecute.Enabled=false;

            //collect info for the execution
            RunWebstoreCommand rwc=new RunWebstoreCommand();
            if (textboxQuery.SelectedText.Length>0)
            {
                rwc.Query=textboxQuery.SelectedText;
            }
            else
            {
                rwc.Query=textboxQuery.Text;
            }

            rwc.buttonToEnableWhenComplete=butUODBExecute;

            List<PartitionEntry> parts=new List<PartitionEntry>();
            foreach (PartitionEntry pe in listboxPartitionList.SelectedItems)
            {
                parts.Add(pe);
            }

            rwc.Partitions=parts.ToArray();

            //run it
            ThreadMaker.CreateThread(rwc.Run).Start();
        }

        #endregion //Events

        //runs a sql command on a specific set of partitions
        class RunWebstoreCommand
        {
            public string Query;
            public PartitionEntry []Partitions;

            public Button buttonToEnableWhenComplete;

            //
            public void Run()
            {
                if (Partitions.Length<=0)
                {
                    ro.Error("No partitions selected to run against.");
                }
                else if (Query.Length<=0)
                {
                    ro.Error("No query given to run.");
                }
                else //try running it
                {
                    ro.Info("Running query against "+Partitions.Length+" partitions:\n"+Query);

                    try
                    {
                        WstConnection con=GetEnvironmentWstConnection();
                        con.Open();

                        //Run on each partition
                        foreach (PartitionEntry pe in Partitions)
                        {
                            try
                            {
                                ro.Info("");
                                ro.Info(pe.ToString()+":");

                                WstCommand cmd=GetPartitionWstCommand(con, pe);
                                cmd.CommandText=Query;
                                cmd.CommandTimeout=0; //do not timeout

                                using (WstDataReader reader=cmd.ExecuteReader())
                                {
                                    if (reader.Read())
                                    {
                                        //print header
                                        string header="";
                                        for (int field=0; field<reader.FieldCount; ++field)
                                        {
                                            if (header.Length>0)
                                            {
                                                header+="\t";
                                            }

                                            header+="["+reader.GetName(field)+"]";
                                        }
                                        ro.Info(header);

                                        //print results
                                        do
                                        {
                                            string row="";
                                            for (int field=0; field<reader.FieldCount; ++field)
                                            {
                                                if (row.Length>0)
                                                {
                                                    row+="\t";
                                                }

                                                object value=reader[field];
                                                if (value is byte[]) //special case, print out bytes instead
                                                {
                                                    row+="0x"+Hexer.tohex(value as byte[]);
                                                }
                                                else //default ToString()
                                                {
                                                    row+=value.ToString();
                                                }
                                            }
                                            ro.Info(row);
                                        } while (reader.Read());
                                    }

                                    if (reader.RecordsAffected>0)
                                    {
                                        ro.Info("Rows affected: "+reader.RecordsAffected);
                                    }
                                }
                            }
                            catch (Exception e)
                            {
                                ro.Error("Exception executing webstore command against "+pe+": "+e);
                            }
                        }

                        con.Close();
                    }
                    catch (Exception e)
                    {
                        ro.Error("Exception running webstore: "+e);
                    }
                }

                //re-enable execute button
                buttonToEnableWhenComplete.Invoke(new InvokeCode(delegate
                {
                    buttonToEnableWhenComplete.Enabled=true;
                }));
            }
        };
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\FunctionalRunner\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\FunctionalRunner\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\FunctionalRunner\Functional.cs ===
using System;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Serialization;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Core.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Utilities;

namespace STFGui.Plugins
{
    /// <summary>
    /// The functional runner gui plugin.
    /// </summary>
    public class FunctionalPlugin: IPluginSetup, IPluginModuleLoadNotification, IPluginGui, Report.Destination, TestEventListener
    {
        // ----- This section contains the public members that anything wanting to extent this plugin may use.

        /// <summary>
        /// Forces or Prevents the option to disable running in parallel from being enabled.
        /// Call with null to remove your override.
        /// </summary>
        public void OverrideNoParallelRunning(IPluginExtension<FunctionalPlugin> caller, Nullable<bool> disableParallel)
        {
            if (disableParallel.HasValue)
            {
                AddOverride(overrideParallel, caller, disableParallel.Value);
            }
            else
            {
                RemoveOverride(overrideParallel, caller);
            }

            UpdateOverrides();
        }

        /// <summary>
        /// Forces or Prevents the option to run in a loop being enabled.
        /// Call with null to remove your override.
        /// </summary>
        public void OverrideLoopedRunning(IPluginExtension<FunctionalPlugin> caller, Nullable<bool> allowLooping)
        {
            if (allowLooping.HasValue)
            {
                AddOverride(overrideLoop, caller, allowLooping.Value);
            }
            else
            {
                RemoveOverride(overrideLoop, caller);
            }

            UpdateOverrides();
        }

        /// <summary>
        /// Forces or Prevents a Dry Run from being enabled.
        /// Call with null to remove your override.
        /// </summary>
        public void OverrideDryRunning(IPluginExtension<FunctionalPlugin> caller, Nullable<bool> allowDryRun)
        {
            if (allowDryRun.HasValue)
            {
                AddOverride(overrideDryRun, caller, allowDryRun.Value);
            }
            else
            {
                RemoveOverride(overrideDryRun, caller);
            }

            UpdateOverrides();
        }

        /// <summary>
        /// The test event listener for all functional running.
        /// You may add your own event listeners to this.
        /// </summary>
        public MultiTestEventListener FunctionalEvents;

        /// <summary>
        /// Returns whether a functional run is currently in progress.
        /// Settings changes will not take effect on runs that are already in-progress.
        /// </summary>
        public bool IsRunning
        {
            get { return isRunning; }
        }

        /// <summary>
        /// Call this to add a check box to the options list.
        /// </summary>
        public CheckBox AddCheckBox(string text, EventHandler checkedChangedEvent, bool initialState, string toolTipText)
        {
            CheckBox newCheck=new CheckBox();
            newCheck.Location=new System.Drawing.Point(3, nextCheckboxOffset);
            newCheck.Size=new System.Drawing.Size(130, 17);
            newCheck.Text=text;
            if (checkedChangedEvent!=null)
            {
                newCheck.CheckedChanged+=checkedChangedEvent;
            }
            newCheck.Checked=initialState;
            if (toolTipText!=null && toolTipText.Length>0)
            {
                new ToolTip().SetToolTip(newCheck, toolTipText);
            }

            nextCheckboxOffset+=20;
            optionsCheckBoxes.AddLast(newCheck);
            ControlsPanel.Controls.Add(newCheck);
            return newCheck;
        }

        /// <summary>
        /// This event is called when a new set of context menu items for a node is being built.
        /// You may add your own items to the contextItemsToShow parameter.
        /// </summary>
        public event BuildContextMenuItemsDelegate BuildNodeContextMenuItemsEvent;
        public delegate void BuildContextMenuItemsDelegate(TestNode node, List<TestNodeContextMenuItem> contextItemsToShow);

        /// <summary>
        /// A context menu item for a test node. Used by BuildNodeContextMenuItemsEvent.
        /// </summary>
        public class TestNodeContextMenuItem
        {
            /// <summary>
            /// The text to show for the item ("-" gives you a divider bar)
            /// </summary>
            public string Text;

            /// <summary>
            /// This event is called if the menu item was chosen by the user.
            /// </summary>
            public event ItemClickDelegate Click;
            public delegate void ItemClickDelegate(TestNodeContextMenuItem sender, TestNode node);

            public TestNodeContextMenuItem() {}
            public TestNodeContextMenuItem(string text)
            {
                Text=text;
            }
            public TestNodeContextMenuItem(string text, ItemClickDelegate cd)
            {
                Text=text;
                Click+=cd;
            }

            //used internally
            internal void InvokeClick(TestNodeContextMenuItem sender, TestNode node)
            {
                Click(sender, node);
            }
        }

        // ----- Internals

        //setting overrides
        private class SettingOverride
        {
            public bool Value;
            public IPluginExtension<FunctionalPlugin> Owner;
        }

        private LinkedList<SettingOverride> overrideParallel=new LinkedList<SettingOverride>();
        private LinkedList<SettingOverride> overrideLoop=new LinkedList<SettingOverride>();
        private LinkedList<SettingOverride> overrideDryRun=new LinkedList<SettingOverride>();

        private bool checkAllForAutoRun = true;

        //gui pieces
        private TabPage tabPage;
        private MenuItem menuItemStart;
        private MenuItem menuItemPause;
        private MenuItem menuItemStop;

        private MenuItem menuItemSaveState;
        private MenuItem menuItemLoadState;
        private MenuItem menuItemLastKnownState;

        private MenuItem menuItemGenerateTrxOnRun;
        private MenuItem menuItemGenerateTrxNow;

        private SplitContainer splitTreeAndFiltering;
        private Panel FilteringPanel;
        private ComboBox comboTagViewOptions;
        private RichTextBox tbTagExpression;
        private Label labFilterCharacterPosition;

        public FuncTreeView TestTree;
        public Panel ControlsPanel;
        public FuncScheduler Scheduler;
        public FunctionalSchedulerSettings SchedulerSettings;

        private VsTestResultTestEventListener vsTestEventListener;

        bool StoreLoglines = true;
        public List<Report.ReportLine> LogLines=new List<Report.ReportLine>();

        XmlNode configNode;
        Button butStart;
        Button butStop;
        private bool isRunning=false;

        LinkedList<CheckBox> optionsCheckBoxes=new LinkedList<CheckBox>();

        Nullable<bool> runLoopedOverride=null;
        CheckBox cbRunLooped;
        Nullable<bool> disableParallelOverride=null;
        CheckBox cbDisableParallel;
        Nullable<bool> doDryRunOverride=null;
        CheckBox cbDoDryRun;
        CheckBox cbSkipPreRun;
        CheckBox cbSkipPostRun;
        CheckBox cbStickyColors;

        int nextCheckboxOffset = 50; //next y loc to place a check box

        LinkedList<TestNode> rootNodes=new LinkedList<TestNode>();
        Report ro=new Report("FuncPlugin");
        Report roExp=new Report("Expression");

        //autorun mode stuff
        enum AutorunState
        {
            None,
            Starting,
            Running
        };
        bool isInAutorunMode=false;
        bool saveAutorunMode=false; //must be set for autorun to save to the xml config
        AutorunState autorunState=AutorunState.None;
        int autorunCountDown=0;
        System.Timers.Timer autorunCountDownTimer;

        //The state of the tag visibility -- this MUST line up with the options added to comboTagVie397
        public enum TagVisibilityStates
        {
            Hide=0,
            Node,
            NodeParents,
            NodeChildren,
            NodeParentsChildren,
            NodeNearestParent
        };

        public TagVisibilityStates TagVisibilityState;

        //
        public delegate void InvokeCode();

        //used by the func tree view
        public void DoBuildNodeContextMenuItems(TestNode n, List<TestNodeContextMenuItem> items)
        {
            if (BuildNodeContextMenuItemsEvent!=null)
            {
                BuildNodeContextMenuItemsEvent(n, items);
            }
        }

        //
        private void AddOverride(LinkedList<SettingOverride> list, IPluginExtension<FunctionalPlugin> owner, bool value)
        {
            SettingOverride so=new SettingOverride();
            so.Value=value;
            so.Owner=owner;
            list.AddLast(so);
        }

        private void RemoveOverride(LinkedList<SettingOverride> list, IPluginExtension<FunctionalPlugin> owner)
        {
            bool changed=true;
            while (changed)
            {
                changed=false;

                foreach (SettingOverride so in list)
                {
                    if (so.Owner==owner)
                    {
                        changed=true;
                        list.Remove(so);
                        break;
                    }
                }
            }
        }

        private void UpdateOverrides()
        {
            bool ok=true;

            if (IsRunning)
            {
                ro.Warn("Override settings changed while a functional run is in progress.  The current run will not be affected by the changes.");
            }

            //update settings
            if (!VerifyOverrideListSanity(overrideParallel, "Parallel Run", out disableParallelOverride))
            {
                ok=false;
            }

            if (!VerifyOverrideListSanity(overrideLoop, "Looped Run", out runLoopedOverride))
            {
                ok=false;
            }

            if (!VerifyOverrideListSanity(overrideDryRun, "Dry Run", out doDryRunOverride))
            {
                ok=false;
            }

            UpdateOverrideControlsState();

            //disable us if something bad happened
            if (ok)
            {
                tabPage.Enabled=true;
                TestTree.Visible=true;
            }
            else
            {
                tabPage.Enabled=false;
                TestTree.Visible=false;
            }
        }

        private bool VerifyOverrideListSanity(LinkedList<SettingOverride> list, string name, out Nullable<bool> value)
        {
            bool badness=false;
            SettingOverride soFirst=null;
            foreach (SettingOverride o in list)
            {
                if (soFirst==null)
                {
                    soFirst=o;
                }
                else
                {
                    if (soFirst.Value!=o.Value) //uh oh
                    {
                        badness=true;
                        ro.Fatal("Conflict over setting override '"+name+"': "+soFirst.Owner.GetType().FullName+" wants value "+soFirst.Value+" but "+o.Owner.GetType().FullName+" wants value "+o.Value);
                    }
                }
            }

            if (badness)
            {
                value=null;
                return false;
            }
            else
            {
                if (soFirst==null)
                {
                    value=null;
                }
                else
                {
                    value=soFirst.Value;
                }
                return true;
            }
        }

        private void UpdateOverrideControlsState()
        {
            if (runLoopedOverride==null)
            {
                cbRunLooped.Enabled=true;
            }
            else
            {
                cbRunLooped.Enabled=false;
                cbRunLooped.Checked=runLoopedOverride.Value;
            }

            if (disableParallelOverride==null)
            {
                cbDisableParallel.Enabled=true;
            }
            else
            {
                cbDisableParallel.Enabled=false;
                cbDisableParallel.Checked=disableParallelOverride.Value;
            }

            if (doDryRunOverride==null)
            {
                cbDoDryRun.Enabled=true;
            }
            else
            {
                cbDoDryRun.Enabled=false;
                cbDoDryRun.Checked=doDryRunOverride.Value;
            }
        }

        //Returns the TabPage to add to the gui.
        public TabPage GetNewTabPage()
        {
            //the tab
            TabPage page=new TabPage();
            tabPage=page;
            page.Text="Functional";

            ToolTip ttip=new ToolTip();

            //add a splitter to divide the controls from the node tree
            SplitContainer splitControlsAndTree=new SplitContainer();
            splitControlsAndTree.Orientation=Orientation.Vertical;
            splitControlsAndTree.Dock=DockStyle.Fill;
            splitControlsAndTree.Location=new System.Drawing.Point(0, 0);
            splitControlsAndTree.Size=new System.Drawing.Size(3000, 3000);
            splitControlsAndTree.Panel1MinSize=130;
            splitControlsAndTree.SplitterDistance=130;
            splitControlsAndTree.IsSplitterFixed=true;
            page.Controls.Add(splitControlsAndTree);

            ControlsPanel=splitControlsAndTree.Panel1;

            //add a splitter to divide the controls from the node tree
            splitTreeAndFiltering=new SplitContainer();
            splitTreeAndFiltering.Orientation=Orientation.Vertical;
            splitTreeAndFiltering.Dock=DockStyle.Fill;
            splitTreeAndFiltering.Location=new System.Drawing.Point(0, 0);
            splitTreeAndFiltering.Size=new System.Drawing.Size(3000, 3000);
            splitTreeAndFiltering.Panel2MinSize=400;
            splitTreeAndFiltering.SplitterDistance=2600;
            splitTreeAndFiltering.IsSplitterFixed=true;
            splitTreeAndFiltering.Panel2Collapsed=XmlUtil.GetChildNodeValue(configNode, "TagFilterPanelCollapsed", true);
            splitTreeAndFiltering.Resize+=delegate(object sender, EventArgs e) {if (splitTreeAndFiltering.Width>400+splitTreeAndFiltering.Panel1MinSize) splitTreeAndFiltering.SplitterDistance=splitTreeAndFiltering.Width-400;};
            splitControlsAndTree.Panel2.Controls.Add(splitTreeAndFiltering);

            FilteringPanel=splitTreeAndFiltering.Panel2;

            //add start and stop buttons
            butStart=new Button();
            butStart.Location=new System.Drawing.Point(4, 4);
            butStart.Size=new System.Drawing.Size(60, 26);
            butStart.Text="Start";
            butStart.Click+=ButtonStart_Click;
            ControlsPanel.Controls.Add(butStart);

            butStop=new Button();
            butStop.Location=new System.Drawing.Point(67, 4);
            butStop.Size=new System.Drawing.Size(60, 26);
            butStop.Text="Stop";
            butStop.Enabled=false;
            butStop.Click+=ButtonStop_Click;
            ControlsPanel.Controls.Add(butStop);

            //run options
            Label labOpts=new Label();
            labOpts.Text="Run Options:";
            labOpts.Location=new System.Drawing.Point(31, 35);
            labOpts.Size=new System.Drawing.Size(70, 13);
            ControlsPanel.Controls.Add(labOpts);

            cbDisableParallel=AddCheckBox("Disable Parallel Run", OptionDisableParallel_Changed, false, "Forces nodes that are marked to run in parallel to run sequentially instead.");
            AddCheckBox("Retry Failures", OptionRetryFailures_Changed, false, "Retry failed test cases up to three time.");
            cbRunLooped=AddCheckBox("Run Looped", OptionRunLooped_Changed, false, "Run test cases in a loop until told to stop.");
            cbDoDryRun=AddCheckBox("Dry Run", OptionDryRun_Changed, false, "Run the tests through the functional scheduler, but do not actually execute them.");
            cbSkipPreRun=AddCheckBox("Skip PreRun", OptionSkipPreRun_Changed, false, "Prevents PreRun from being performed.");
            cbSkipPostRun=AddCheckBox("Skip PostRun", OptionSkipPostRun_Changed, false, "Prevents PostRun from being performed.");
            cbStickyColors = AddCheckBox("Sticky Colors", OptionStickyColors_Changed, false, "Will not clear individual test status colors when you kick off a new run.");

            //add button to show/hide filtering controls
            Button butTagFilterShow=new Button();
            butTagFilterShow.Location=new System.Drawing.Point(2950, 4);
            butTagFilterShow.Size=new System.Drawing.Size(160, 26);
            butTagFilterShow.Dock=DockStyle.Bottom;
            butTagFilterShow.Text="Toggle Tag Panel";
            butTagFilterShow.Click+=delegate(object sender, EventArgs e)
            {
                splitTreeAndFiltering.Panel2Collapsed=!splitTreeAndFiltering.Panel2Collapsed;
                //splitTreeAndFiltering.SplitterDistance=splitTreeAndFiltering.Width-400;
            };
            ControlsPanel.Controls.Add(butTagFilterShow);

            //Tag visibility control
            Label labTagView=new Label();
            labTagView.Text="Tag Visibility: ";
            labTagView.Location=new System.Drawing.Point(2, 5);
            labTagView.Size=new System.Drawing.Size(72, 13);
            FilteringPanel.Controls.Add(labTagView);

            comboTagViewOptions=new ComboBox();
            comboTagViewOptions.Items.Add("Hide all tags");
            comboTagViewOptions.Items.Add("Show tags from Node Only");
            comboTagViewOptions.Items.Add("Show tags from Node and from Parents");
            comboTagViewOptions.Items.Add("Show tags from Node and from Children");
            comboTagViewOptions.Items.Add("Show tags from Node, from Parents, and from Children");
            comboTagViewOptions.Items.Add("Show first occurance of tags from Node or Parents");
            comboTagViewOptions.DropDownStyle=ComboBoxStyle.DropDownList;
            comboTagViewOptions.SelectedIndexChanged+=TagFilter_Changed;
            comboTagViewOptions.SelectedIndex=XmlUtil.GetChildNodeValue(configNode, "TagFilterDisplayTagsOnNodeSetting", 1);
            comboTagViewOptions.Location=new System.Drawing.Point(75, 3);
            comboTagViewOptions.Size=new System.Drawing.Size(280, 13);
            FilteringPanel.Controls.Add(comboTagViewOptions);

            //edit box for filter expression
            Label labFilterExpression=new Label();
            labFilterExpression.Text="Tag Expression: ";
            labFilterExpression.Location=new System.Drawing.Point(150, 34);
            labFilterExpression.Size=new System.Drawing.Size(120, 13);
            FilteringPanel.Controls.Add(labFilterExpression);

            labFilterCharacterPosition=new Label();
            labFilterCharacterPosition.Text="Cursor Position: 0";
            labFilterCharacterPosition.Location=new System.Drawing.Point(7, 2932);
            labFilterCharacterPosition.Size=new System.Drawing.Size(140, 13);
            labFilterCharacterPosition.Anchor=AnchorStyles.Bottom|AnchorStyles.Left;
            FilteringPanel.Controls.Add(labFilterCharacterPosition);

            tbTagExpression=new RichTextBox();
            tbTagExpression.Multiline=true;
            tbTagExpression.DetectUrls=false;
            tbTagExpression.HideSelection=false;
            tbTagExpression.AutoWordSelection=false;
            tbTagExpression.Font=new System.Drawing.Font("Courier New", 9);
            tbTagExpression.ForeColor=System.Drawing.Color.Black;
            tbTagExpression.BackColor=System.Drawing.Color.White;
            tbTagExpression.Location=new System.Drawing.Point(2, 50);
            tbTagExpression.Size=new System.Drawing.Size(394, 2870);
            tbTagExpression.Anchor=AnchorStyles.Bottom|AnchorStyles.Top;
            tbTagExpression.Text=UnmakeStringSaneForXml(XmlUtil.GetChildNodeValue(configNode, "TagExpression", (string)null))??"Val(true)";
            tbTagExpression.TextChanged+=TagExpressionBox_Changed;
            tbTagExpression.SelectionChanged+=TagExpressionBox_Selection;
            tbTagExpression.MouseDown+=TagExpressionBox_MouseDown;
            tbTagExpression.MouseUp+=TagExpressionBox_MouseUp;
            FilteringPanel.Controls.Add(tbTagExpression);

            //add buttons to apply tag expression
            Button butTagApplyEnable=new Button();
            butTagApplyEnable.Location=new System.Drawing.Point(16, 2970);
            butTagApplyEnable.Size=new System.Drawing.Size(100, 25);
            butTagApplyEnable.Anchor=AnchorStyles.Bottom|AnchorStyles.Left;
            butTagApplyEnable.Text="Enable Nodes";
            butTagApplyEnable.Click+=ButtonEnableExpression_Click;
            FilteringPanel.Controls.Add(butTagApplyEnable);

            Button butTagApplyIgnore=new Button();
            butTagApplyIgnore.Location=new System.Drawing.Point(149, 2940);
            butTagApplyIgnore.Size=new System.Drawing.Size(100, 25);
            butTagApplyIgnore.Anchor=AnchorStyles.Bottom;
            butTagApplyIgnore.Text="Ignore Nodes";
            butTagApplyIgnore.Click+=ButtonIgnoreExpression_Click;
            FilteringPanel.Controls.Add(butTagApplyIgnore);

            Button butTagApplyUnignore=new Button();
            butTagApplyUnignore.Location=new System.Drawing.Point(149, 2970);
            butTagApplyUnignore.Size=new System.Drawing.Size(100, 25);
            butTagApplyUnignore.Anchor=AnchorStyles.Bottom;
            butTagApplyUnignore.Text="Unignore Nodes";
            butTagApplyUnignore.Click+=ButtonUnignoreExpression_Click;
            FilteringPanel.Controls.Add(butTagApplyUnignore);

            Button butTagApplyHighlight=new Button();
            butTagApplyHighlight.Location=new System.Drawing.Point(282, 2970);
            butTagApplyHighlight.Size=new System.Drawing.Size(100, 25);
            butTagApplyHighlight.Anchor=AnchorStyles.Bottom|AnchorStyles.Right;
            butTagApplyHighlight.Text="Highlight Nodes";
            butTagApplyHighlight.Click+=ButtonHighlightExpression_Click;
            FilteringPanel.Controls.Add(butTagApplyHighlight);

            Button butTagHelp=new Button();
            butTagHelp.Location=new System.Drawing.Point(360, 10);
            butTagHelp.Size=new System.Drawing.Size(35, 35);
            butTagHelp.Text="?";
            butTagHelp.Click+=ButtonExpressionHelp_Click;
            FilteringPanel.Controls.Add(butTagHelp);

            //create and add test tree
            TestTree=new FuncTreeView(GuiHooks.MainForm, this);
            FunctionalEvents.Add(TestTree);
            TestTree.Dock=DockStyle.Fill;
            splitTreeAndFiltering.Panel1.Controls.Add(TestTree);
            TestTree.CustomDoubleClick+=Tree_DoubleClick;

            //
            return page;
        }

        //Called to return our menu which should be added to the main gui.
        public MenuItem GetNewMenu()
        {
            MenuItem menuFunc=new MenuItem("Functional");

            //add save/loading for enabled tests
            menuFunc.MenuItems.Add(new MenuItem("Save Enabled Nodes", Menu_Func_Save));
            menuFunc.MenuItems.Add(new MenuItem("Load Enabled Nodes", Menu_Func_Load));

            //add our node toggling options
            menuFunc.MenuItems.Add(new MenuItem("-"));
            menuFunc.MenuItems.Add(new MenuItem("Select All Nodes", Menu_Func_SelectAll));
            menuFunc.MenuItems.Add(new MenuItem("Select No Nodes", Menu_Func_SelectNone));
            menuFunc.MenuItems.Add(new MenuItem("Select Failed Nodes", Menu_Func_SelectFailed));
            menuFunc.MenuItems.Add(new MenuItem("Find and Select Tests", Menu_Func_FindTest, Shortcut.CtrlF));

            //add node expansion options
            menuFunc.MenuItems.Add(new MenuItem("-"));
            menuFunc.MenuItems.Add(new MenuItem("Expand All Nodes", Menu_Func_ExpandAll));
            menuFunc.MenuItems.Add(new MenuItem("Collapse All Nodes", Menu_Func_CollapseAll));
            menuFunc.MenuItems.Add(new MenuItem("-"));

            //add serialization options
            menuItemLastKnownState=new MenuItem("Reload Last Known State", Menu_Func_ReloadLastKnownState);
            menuItemLoadState=new MenuItem("Load Result State", Menu_Func_LoadState);
            menuItemSaveState=new MenuItem("Save Result State", Menu_Func_SaveState);
            menuFunc.MenuItems.Add(menuItemSaveState);
            menuFunc.MenuItems.Add(menuItemLoadState);
            menuFunc.MenuItems.Add(menuItemLastKnownState);

            //add functional result file generation options
            menuFunc.MenuItems.Add(new MenuItem("-"));
            menuItemGenerateTrxOnRun=new MenuItem("Generate .trx (VsTest) file on run", Menu_Func_GenerateTrxOnRun);
            menuItemGenerateTrxNow=new MenuItem("Generate .trx (VsTest) file now", Menu_Func_GenerateTrxNow);
            menuFunc.MenuItems.Add(menuItemGenerateTrxOnRun);
            menuFunc.MenuItems.Add(menuItemGenerateTrxNow);

            //add running options
            menuFunc.MenuItems.Add(new MenuItem("-"));
            menuItemStart=new MenuItem("Start Test Run", ButtonStart_Click, Shortcut.F5);
            menuItemPause=new MenuItem("Pause Test Run", ButtonStop_Click, Shortcut.ShiftF5);
            menuItemStop=new MenuItem("Stop Test Run", ButtonStop_Click, Shortcut.CtrlF5);
            menuItemPause.Enabled=false;
            menuItemStop.Enabled=false;
            menuFunc.MenuItems.Add(menuItemStart);
            menuFunc.MenuItems.Add(menuItemPause);
            menuFunc.MenuItems.Add(menuItemStop);

            //hook the clear
            GuiHooks.AddClearOutputHandler(Menu_View_ClearOutput);

            //
            return menuFunc;
        }

        //called when a module is about to be loaded
        public void ModuleLoading(string fileName)
        {
        }

        //called when a suite is loaded
        public void SuiteLoaded(TestNode rootNode)
        {
            //reset autorun countdown
            if (isInAutorunMode)
            {
                autorunCountDownTimer.Stop();
                autorunCountDown=10;
                autorunState=AutorunState.Starting;
                ro.Info("Suite loaded, so restarting autorun countdown.");
            }

            //add to the gui tree
            TestTree.Invoke(new InvokeCode(delegate
                {
                    TestTree.AddTestTree(rootNode);
                }));

            //if we're running, stop
            if (butStop.Enabled)
            {
                ThreadMaker.CreateThread(ThreadProcStop).Start();
            }

            //save the current state, add the suite, reinit the scheduler, then load the enabled state from config
            SaveAllEnabledNodesState(configNode);

            rootNodes.AddLast(rootNode);
            Scheduler.Initialize(SchedulerSettings, FunctionalEvents, rootNodes);

            LoadEnabledState(configNode);

            //start autorun countdown again if needed
            if (isInAutorunMode)
            {
                autorunCountDownTimer.Start();
            }
        }

        //called when suite is being unloaded
        public void SuiteUnloading(TestNode rootNode)
        {
            //remove from the gui tree
            TestTree.RemoveTestTree(rootNode);

            //if we're running, stop
            if (butStop.Enabled)
            {
                ThreadMaker.CreateThread(ThreadProcStop).Start();
            }

            //save the current state, remove the suite, reinit the scheduler, then load the enabled state from config
            SaveAllEnabledNodesState(configNode);

            rootNodes.Remove(rootNode);
            Scheduler.Initialize(SchedulerSettings, FunctionalEvents, rootNodes);
        }

        //Enable any nodes that should be based on the config
        private void LoadEnabledState(XmlNode config)
        {
            foreach (TestNode root in rootNodes)
            {
                XmlNode groupNode=XmlUtil.GetGroupNode(config, MakeStringSaneForXml(root.Name));
                XmlNode enabledNode=XmlUtil.GetGroupNode(groupNode, "Enabled");
                foreach (XmlNode xnode in enabledNode.ChildNodes)
                {
                    string realName=UnmakeStringSaneForXml(xnode.Name);
                    TestNode tn=TestNode.FindNode(root, realName);
                    if (tn!=null && tn.FunctionalData!=null)
                    {
                        tn.FunctionalData.Enabled=true;
                    }
                }
            }

            TestTree.UpdateAllCheckBoxes();
        }

        private void LoadAutomationSettings(XmlNode config)
        {
            XmlNode automationNode = XmlUtil.GetGroupNode(config, "Automation");

            bool checkAll = true;

            if (XmlUtil.GetChildNodeValue(automationNode, "CheckAll", out checkAll) && !checkAll)
            {
                this.checkAllForAutoRun = false;
            }

            bool automationEnabled = false;

            if (XmlUtil.GetChildNodeValue(automationNode, "AutoRun", out automationEnabled) && automationEnabled)
            {
                saveAutorunMode=true;
                this.StartAutoRunCountDown();
            }
        }

        private void StartAutoRunCountDown()
        {
            isInAutorunMode = true;
            autorunCountDown = 10;
            autorunState = AutorunState.Starting;
            autorunCountDownTimer = new System.Timers.Timer();
            autorunCountDownTimer.Interval = 1000; //1s
            autorunCountDownTimer.Elapsed += AutorunCountDownTimerTick;
            autorunCountDownTimer.Start();
        }

        //Called to init
        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            //init
            configNode=pluginSettings;

            this.LoadAutomationSettings(configNode);

            vsTestEventListener=new VsTestResultTestEventListener();

            SchedulerSettings=new FunctionalSchedulerSettings();
            Scheduler=new FuncScheduler();
            FunctionalEvents=new MultiTestEventListener();
            FunctionalEvents.Add(this);
            Scheduler.Initialize(SchedulerSettings, FunctionalEvents, rootNodes);

            //check our commandline params for anything interesting
            foreach (string s in commandlineParameters)
            {
                if (s.ToLower() == "autorun")
                {
                    this.StartAutoRunCountDown();
                }
                else if (s.ToLower().StartsWith("autoruncheckall"))
                {
                    string[] keyValuePairs = s.ToLower().Split('=');
                    if (keyValuePairs.Length == 2)
                    {
                        bool.TryParse(keyValuePairs[1], out this.checkAllForAutoRun);
                    }
                }
                else if (s.ToLower().EndsWith(".func_xml"))
                {
                    try
                    {
                        XmlDocument doc = new XmlDocument();
                        doc.Load(s);

                        //go through every suite in the file
                        XmlNode fileSaved = XmlUtil.GetGroupNode(doc, "Saved");
                        foreach (XmlNode fileSuite in fileSaved.ChildNodes)
                        {
                            //clear our current enables
                            XmlNode configSuite = XmlUtil.GetGroupNode(configNode, MakeStringSaneForXml(fileSuite.Name));
                            XmlNode configEnabled = XmlUtil.GetGroupNode(configSuite, "Enabled");

                            configEnabled.RemoveAll();

                            //copy their enables in
                            XmlNode fileEnabled = XmlUtil.GetGroupNode(fileSuite, "Enabled");
                            foreach (XmlNode fileChild in fileEnabled.ChildNodes)
                            {
                                XmlNode impKid = configNode.OwnerDocument.ImportNode(fileChild, true);
                                configEnabled.AppendChild(impKid);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        ro.Error("Exception loading functional xml config: " + s + ": " + e);
                    }
                }
                else if (s.ToLower() == "help")
                {
                    ro.Info("Functional Plugin parameters:");
                    ro.Info("  autorun                          Automatically run suites then exit.");
                    ro.Info("  autoruncheckall=[true | false]   Turn on all suites before autorun.");
                    ro.Info("  filename.func_xml                load suites from specified file.");
                }
                else
                {
                    ro.Error("Bad parameter passed to functional runner plugin: " + s);
                    break;
                }
            }

            //hook us up to recieve loglines
            Report.GetRoot().AddReportDestination(this);
        }

        //Called when we're being shut down
        public void Shutdown(XmlNode pluginSettings)
        {
            //if we're running, stop
            if (butStop!=null && butStop.Enabled)
            {
                //we do it on this thread so that we block until it's done
                ThreadProcStop();
            }

            //save functional-suite-specific gui information
            SaveAllEnabledNodesState(pluginSettings);

            XmlUtil.SetChildNodeValue(pluginSettings, "TagFilterPanelCollapsed", splitTreeAndFiltering.Panel2Collapsed);
            XmlUtil.SetChildNodeValue(pluginSettings, "TagFilterDisplayTagsOnNodeSetting", comboTagViewOptions.SelectedIndex);
            XmlUtil.SetChildNodeValue(pluginSettings, "TagExpression", MakeStringSaneForXml(tbTagExpression.Text));
        }

        //Copies the enabled state of nodes from all loaded suites into an xml node
        private void SaveAllEnabledNodesState(XmlNode config)
        {
            foreach (TestNode suite in rootNodes)
            {
                //if this suite already has entries, wipe them
                XmlNode groupNode=XmlUtil.GetGroupNode(config, MakeStringSaneForXml(suite.Name));
                groupNode.RemoveAll();

                //save enabled tests list
                XmlNode enabledNode=XmlUtil.GetGroupNode(groupNode, "Enabled");
                SaveEnabledTree(enabledNode, suite);
            }

            this.SaveAutomationSettings(config);
        }

        private void SaveAutomationSettings(XmlNode config)
        {
            XmlNode automationNode = XmlUtil.GetGroupNode(config, "Automation");
            XmlUtil.SetChildNodeValue(automationNode, "AutoRun", this.isInAutorunMode && saveAutorunMode);
            XmlUtil.SetChildNodeValue(automationNode, "CheckAll", this.checkAllForAutoRun);
        }

        //Helper for saving a list of enabled nodes to config
        private void SaveEnabledTree(XmlNode config, TestNode node)
        {
            if (node.FunctionalData==null || node.FunctionalData.Enabled==false)
            {
                return;
            }

            //if I have no children, do my thing
            if (node.ChildrenCount==0)
            {
                XmlNode xn=config.OwnerDocument.CreateNode(XmlNodeType.Element, MakeStringSaneForXml(node.FullName), "");
                config.AppendChild(xn);
                return;
            }

            //if all my children that have functional data are fully enabled, just save my name
            if (IsWholeFunctionalTreeEnabled(node))
            {
                XmlNode xn=config.OwnerDocument.CreateNode(XmlNodeType.Element, MakeStringSaneForXml(node.FullName), "");
                config.AppendChild(xn);
                return;
            }

            //only some children may be enabled, so save each child
            foreach (TestNode child in node.Children)
            {
                SaveEnabledTree(config, child);
            }
        }

        //converts a string to a savable xml string
        private string MakeStringSaneForXml(string str)
        {
            string d="";
            foreach (char s in str)
            {
                if ((s>='a' && s<='z') || (s>='A' && s<='Z')) //normal letter
                {
                    d+=s;
                }
                else //don't trust anything else!
                {
                    d+="_"; //special marker
                    d+=string.Format("{0:D5}", (ushort)s);
                }
            }
            return d;
        }

        /// <summary>
        /// Loads a specific serialized run result file.
        /// </summary>
        /// <param name="path"></param>
        private void LoadState(string path)
        {
            FileStream resultsStream = File.Open(path, FileMode.Open, FileAccess.Read);
            try
            {

                List<FuncTreeNode> nodes = new List<FuncTreeNode>();
                TestTree.GetFlattenedSubtree(ref nodes);

                XmlSerializer serializer = new System.Xml.Serialization.XmlSerializer(typeof(SerializedRunResults));
                XmlTextReader rdr = new XmlTextReader(resultsStream);
                SerializedRunResults results = (SerializedRunResults)serializer.Deserialize(rdr);

                lock (LogLines)
                {
                    LogLines.Clear();
                    foreach (Report.ReportLine l in results.LogLines)
                    {
                        LogLines.Add(l);
                    }
                }

                foreach (FuncTreeNode n in TestTree.Nodes)
                    n.ResetRunState();

                foreach (SerializableDictionary<string, FunctionalSchedulerNodeData> data in results.SchedulerData)
                {
                    foreach (FuncTreeNode subNode in nodes)
                    {
                        if (data.ContainsKey(subNode.LinkedTestNode.FullName))
                        {
                            FunctionalSchedulerNodeData nd = (FunctionalSchedulerNodeData)data[subNode.LinkedTestNode.FullName];
                            subNode.PassCount = nd.NumberPassed;
                            subNode.TotalCount = nd.NumberTotal;
                            subNode.LinkedTestNode.FunctionalData.SchedulerData = nd;
                            subNode.UpdateNodeVisuals();
                        }
                    }
                }

            }
            catch (Exception ex)
            {
                ro.Error("Failed to load results state.");
                ro.Error(ex.Message);
            }
            finally
            {
                resultsStream.Close();
            }
        }

        //converts a string from a savable xml string
        private string UnmakeStringSaneForXml(string str)
        {
            if (str==null)
            {
                return null;
            }

            string d="";
            for (int ind=0; ind<str.Length; ++ind)
            {
                char s=str[ind];

                if ((s>='a' && s<='z') || (s>='A' && s<='Z')) //normal letter
                {
                    d+=s;
                }
                else if (s=='_') //special marker
                {
                    ++ind;

                    //pull the character number out
                    string cnumstr="";
                    for (int cn=0; cn<5 && ind<str.Length; ++cn,++ind)
                    {
                        if (str[ind]>='0' & str[ind]<='9')
                        {
                            cnumstr+=str[ind];
                        }
                    }
                    --ind; // outter loop will do

                    if (cnumstr.Length==5)
                    {
                        int num=int.Parse(cnumstr);
                        if (num>=0 && num<ushort.MaxValue)
                        {
                            d+=(char)((ushort)num);
                        }
                    }
                }
            }
            return d;
        }

        //used internally by SaveEnabledTree
        bool IsWholeFunctionalTreeEnabled(TestNode tree)
        {
            if (tree.FunctionalData==null || tree.FunctionalData.Enabled==false)
            {
                return false;
            }

            foreach (TestNode child in tree.Children)
            {
                if (child.FunctionalData!=null && child.FunctionalData.Enabled==false)
                {
                    return false;
                }

                if (!IsWholeFunctionalTreeEnabled(child))
                {
                    return false;
                }
            }

            return true;
        }

        #region Events

        private void ButtonStop_Click(object sender, EventArgs e)
        {
            if (butStop.Enabled)
            {
                bool isPause=false;
                if (sender==menuItemPause)
                {
                    isPause=true;
                }
                else if (sender==menuItemStop)
                {
                    isPause=false;
                }
                else //button
                {
                    if (butStop.Text=="Pause")
                    {
                        isPause=true;
                    }
                }

                if (isPause)
                {
                    Scheduler.Pause(); //this is instant so doesn't need a thread
                    SetControlsPaused();
                }
                else
                {
                    ThreadMaker.CreateThread(ThreadProcStop).Start();
                }
            }
        }

        private void ButtonStart_Click(object sender, EventArgs e)
        {
            if (butStart.Enabled)
            {
                if (butStart.Text=="Start")
                {
                    ThreadMaker.CreateThread(ThreadProcRun).Start();
                }
                else if (butStart.Text=="Resume")
                {
                    Scheduler.Resume(); //this is instant so doesn't need a thread
                    SetControlsRunning();
                }
            }
        }

        private void OptionDisableParallel_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.AllowAsync=!cb.Checked;
        }

        private void OptionRetryFailures_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.TimesToTryRun=(cb.Checked?3:1);
        }

        private void OptionRunLooped_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.RunLooped=cb.Checked;
        }

        private void OptionDryRun_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.DryRun=cb.Checked;
        }

        private void OptionSkipPreRun_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.SkipPreRun=cb.Checked;
        }

        private void OptionSkipPostRun_Changed(object sender, EventArgs e)
        {
            CheckBox cb=(CheckBox)sender;
            SchedulerSettings.SkipPostRun=cb.Checked;
        }

        private void OptionStickyColors_Changed(object sender, EventArgs e)
        {
            CheckBox cb = (CheckBox)sender;
            this.TestTree.StickyColors = cb.Checked;            
        }

        private void Tree_DoubleClick()
        {
            ShowFilteredOutputBox((FuncTreeNode)TestTree.SelectedNode);
        }

        private void Menu_View_ClearOutput()
        {
            lock (LogLines)
            {
                LogLines.Clear();
            }
        }

        private void Menu_Func_SelectAll(object sender, EventArgs args)
        {
            foreach (TestNode suite in rootNodes)
            {
                if (suite.FunctionalData!=null)
                {
                    suite.FunctionalData.Enabled=true;
                }
            }
            TestTree.UpdateAllCheckBoxes();
        }

        private void Menu_Func_SelectNone(object sender, EventArgs args)
        {
            foreach (TestNode suite in rootNodes)
            {
                if (suite.FunctionalData!=null)
                {
                    suite.FunctionalData.Enabled=false;
                }
            }
            TestTree.UpdateAllCheckBoxes();
        }

        private void Menu_Func_SelectFailed(object sender, EventArgs args)
        {
            List<FuncTreeNode> leaves=new List<FuncTreeNode>();
            TestTree.GetLeafNodes(ref leaves);

            foreach (FuncTreeNode fn in leaves)
            {
                if (fn.RunState!=FuncTreeNode.VisualRunState.NotRun && fn.PassCount<fn.TotalCount)
                {
                    fn.LinkedTestNode.FunctionalData.Enabled=true;
                }
                else
                {
                    fn.LinkedTestNode.FunctionalData.Enabled=false;
                }
            }
            TestTree.UpdateAllCheckBoxes();
        }

        private void Menu_Func_ExpandAll(object sender, EventArgs args)
        {
            TestTree.ExpandAll();
        }

        private void Menu_Func_CollapseAll(object sender, EventArgs args)
        {
            TestTree.CollapseAll();
        }

        /// <summary>
        /// Serializes the current run's results.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void Menu_Func_SaveState(object sender, EventArgs args)
        {
            string path = GuiCommon.ChooseFile(true, "Serialized run results file name|*.serializedresult_xml");            
            if (!String.IsNullOrEmpty(path))
                Scheduler.SerializeRun(path);
        }

        /// <summary>
        /// Reloads the last known result, useful on STFGui restart.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void Menu_Func_ReloadLastKnownState(object sender, EventArgs args)
        {   
            string pattern = "*serializedresult_xml";
            if (rootNodes != null && rootNodes.First != null)
                pattern = "*" + rootNodes.First.Value.Name + pattern;
            if (Directory.Exists("FuncOutput\\SerializedRunResults"))
            {
                DirectoryInfo info = new DirectoryInfo("FuncOutput\\SerializedRunResults");
                FileInfo[] files = info.GetFiles(pattern);

                FileInfo max = null;
                if (files.Length > 0)
                {
                    max = files[0];
                    foreach (FileInfo f in files)
                    {
                        if (f.CreationTime > max.CreationTime)
                            max = f;
                    }
                    LoadState(max.FullName);
                }
            }
            else
                ro.Info("No results loaded - no FuncOutput\\SerializedRunResults folder found. (Probably no runs have been completed)");

        }

        /// <summary>
        /// Pops a file select UI to load a serialized result file.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void Menu_Func_LoadState(object sender, EventArgs args)
        {
            string path = GuiCommon.ChooseFile(false, "Serialized Results file (*.serializedresult_xml)|*.serializedresult_xml");
            if (File.Exists(path))
                LoadState(path);
        }

        private void Menu_Func_GenerateTrxOnRun(object sender, EventArgs args)
        {
            menuItemGenerateTrxOnRun.Checked=!menuItemGenerateTrxOnRun.Checked;

            if (menuItemGenerateTrxOnRun.Checked)
            {
                FunctionalEvents.Add(vsTestEventListener);
            }
            else
            {
                FunctionalEvents.Remove(vsTestEventListener);
            }
        }

        private void Menu_Func_GenerateTrxNow(object sender, EventArgs args)
        {
            //Create a temporary listener and generate the few events it cares about
            VsTestResultTestEventListener tempListener=new VsTestResultTestEventListener();
            TestEventArgs tea=new TestEventArgs(null, null, TestAction.StartAll);
            tempListener.OnTestEvent(tea);

            foreach (TestNode node in rootNodes)
            {
                tea=new TestEventArgs(node, null, TestAction.Start);
                tempListener.OnTestEvent(tea);
            }

            tea=new TestEventArgs(null, null, TestAction.StopAll);
            tempListener.OnTestEvent(tea);
        }

        /// <summary>
        /// Pops a window, asks for a regex or substring, and then searches for, expands and 
        /// selects any matching test cases.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="args"></param>
        private void Menu_Func_FindTest(object sender, EventArgs args)
        {
            FormInputBox inputBox = new FormInputBox("Enter a regex or substring to match.");
            inputBox.StartPosition = FormStartPosition.CenterParent;
            DialogResult res = inputBox.ShowDialog(GuiHooks.MainForm);

            if (res == DialogResult.OK && !String.IsNullOrEmpty(inputBox.data))
            {
                string searchPattern = inputBox.data;
                searchPattern = String.Format(".*{0}.*", searchPattern);

                List<FuncTreeNode> nodes = new List<FuncTreeNode>();
                TestTree.GetLeafNodes(ref nodes);

                foreach (FuncTreeNode n in nodes)
                {
                    if (Regex.IsMatch(n.FullPath.ToLower(), searchPattern, RegexOptions.IgnoreCase))
                    {
                        n.EnsureVisible();
                        n.LinkedTestNode.FunctionalData.Enabled = true;
                    }
                }
                TestTree.UpdateAllCheckBoxes();
            }
        }

        private void Menu_Func_Save(object sender, EventArgs args)
        {
            if (rootNodes.Count==0)
            {
                return;
            }

            //update xml state to current
            SaveAllEnabledNodesState(configNode);

            //ask user for file
            string fname=GuiCommon.ChooseFile(true, "Functional Nodes State (*.func_xml)|*.func_xml");
            if (fname==null)
            {
                return;
            }

            //get info from loaded suites, then save it
            XmlDocument doc=new XmlDocument();
            XmlNode newRoot=XmlUtil.GetGroupNode(doc, "Saved");
            foreach (TestNode suite in rootNodes)
            {
                XmlNode suiteNode=XmlUtil.GetGroupNode(configNode, MakeStringSaneForXml(suite.Name));
                XmlNode impNode=doc.ImportNode(suiteNode, true);
                newRoot.AppendChild(impNode);
            }

            doc.Save(fname);
        }

        private void Menu_Func_Load(object sender, EventArgs args)
        {
            if (rootNodes.Count==0)
            {
                return;
            }

            //ask user for file and load it
            string fname=GuiCommon.ChooseFile(false, "Functional Nodes State (*.func_xml)|*.func_xml");
            if (fname==null)
            {
                return;
            }

            LoadXmlEnabledConfig(fname);
        }

        private bool TagExpressionBox_Changed_isProcessing=false;
        private void TagExpressionBox_Changed(object obj, EventArgs args)
        {
            if (TagExpressionBox_Changed_isProcessing || TagExpressionBox_MouseDragging)
            {
                return;
            }

            TagExpressionBox_Changed_isProcessing=true;
            tbTagExpression.SuspendLayout();

            //reset font/color/etc so pasting rich text doesn't make stuff weird.
            int curSel=tbTagExpression.SelectionStart;
            int curSelLen=tbTagExpression.SelectionLength;
            tbTagExpression.SelectionStart=0;
            tbTagExpression.SelectionLength=tbTagExpression.Text.Length+1;

            tbTagExpression.SelectionFont=tbTagExpression.Font;
            tbTagExpression.SelectionColor=tbTagExpression.ForeColor;
            tbTagExpression.SelectionBackColor=tbTagExpression.BackColor;
            tbTagExpression.Text=tbTagExpression.Text;

            //validate the current expression and highlight errors
            //new ToolTip().SetToolTip(tbTagExpression, "Expression is valid.");

            try
            {
                new NodeTaggingData.Expression(tbTagExpression.Text);
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                //new ToolTip().SetToolTip(tbTagExpression, iee.ToString());

                tbTagExpression.SelectionStart=iee.BadCharacterStart;
                tbTagExpression.SelectionLength=iee.BadCharacterEnd-iee.BadCharacterStart;
                if (tbTagExpression.SelectionLength==0) //we want to highlight "something"...
                {
                    if (tbTagExpression.SelectionStart==tbTagExpression.Text.Length && tbTagExpression.SelectionStart>0)
                    {
                        --tbTagExpression.SelectionStart;
                    }
                    ++tbTagExpression.SelectionLength;
                }
                tbTagExpression.SelectionBackColor=System.Drawing.Color.Red;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
            }

            //highlight associated parenthesis
            if (curSel<tbTagExpression.Text.Length)
            {
                if (tbTagExpression.Text[curSel]=='(')
                {
                    tbTagExpression.SelectionStart=curSel;
                    tbTagExpression.SelectionLength=1;
                    tbTagExpression.SelectionBackColor=System.Drawing.Color.LightGray;

                    int depth=1;
                    for (int pos=curSel+1; pos<tbTagExpression.Text.Length; ++pos)
                    {
                        if (tbTagExpression.Text[pos]=='(')
                        {
                            ++depth;
                        }
                        else if (tbTagExpression.Text[pos]==')')
                        {
                            --depth;
                            if (depth==0)
                            {
                                tbTagExpression.SelectionStart=pos;
                                tbTagExpression.SelectionLength=1;
                                tbTagExpression.SelectionBackColor=System.Drawing.Color.LightGray;
                                break;
                            }
                        }
                    }
                }
            }

            if (curSel>0)
            {
                if (tbTagExpression.Text[curSel-1]==')')
                {
                    tbTagExpression.SelectionStart=curSel-1;
                    tbTagExpression.SelectionLength=1;
                    tbTagExpression.SelectionBackColor=System.Drawing.Color.LightGray;

                    int depth=1;
                    for (int pos=curSel-1-1; pos>=0; --pos)
                    {
                        if (tbTagExpression.Text[pos]=='(')
                        {
                            --depth;
                            if (depth==0)
                            {
                                tbTagExpression.SelectionStart=pos;
                                tbTagExpression.SelectionLength=1;
                                tbTagExpression.SelectionBackColor=System.Drawing.Color.LightGray;
                                break;
                            }
                        }
                        else if (tbTagExpression.Text[pos]==')')
                        {
                            ++depth;
                        }
                    }
                }
            }

            //reset selection back to users' original
            tbTagExpression.SelectionStart=curSel;
            //tbTagExpression.SelectionBackColor=tbTagExpression.BackColor;
            tbTagExpression.SelectionLength=curSelLen;


            tbTagExpression.ResumeLayout();
            TagExpressionBox_Changed_isProcessing=false;
        }

        private bool TagExpressionBox_Selection_isProcessing=false;
        private void TagExpressionBox_Selection(object obj, EventArgs args)
        {
            if (TagExpressionBox_Selection_isProcessing || TagExpressionBox_Changed_isProcessing)
            {
                return;
            }
            TagExpressionBox_Selection_isProcessing=true;

            labFilterCharacterPosition.Text="Cursor Position: "+(tbTagExpression.SelectionStart+tbTagExpression.SelectionLength);
            TagExpressionBox_Changed(obj, args);

            TagExpressionBox_Selection_isProcessing=false;
        }

        private bool TagExpressionBox_MouseDragging=false;
        public void TagExpressionBox_MouseDown(Object sender, MouseEventArgs mea)
        {
            TagExpressionBox_MouseDragging=true;
        }

        public void TagExpressionBox_MouseUp(Object sender, MouseEventArgs mea)
        {
            TagExpressionBox_MouseDragging=false;
        }

        private void TagFilter_Changed(object ninja, EventArgs args)
        {
            TagVisibilityState=(TagVisibilityStates)comboTagViewOptions.SelectedIndex;
            if (TestTree!=null)
            {
                TestTree.RefreshAllNodeVisuals();
            }
        }

        private void ButtonHighlightExpression_Click(object sender, EventArgs ea)
        {
            //parse the expression
            NodeTaggingData.Expression expression=null;

            try
            {
                expression=new NodeTaggingData.Expression(tbTagExpression.Text);
                roExp.Success("Expression is valid");
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                roExp.Error(iee.ToString());
                return;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
                return;
            }

            //now apply the expression to the tree
            TestTree.HighlightExpression(expression);
        }

        private void ButtonEnableExpression_Click(object sender, EventArgs ea)
        {
            //parse the expression
            NodeTaggingData.Expression expression=null;

            try
            {
                expression=new NodeTaggingData.Expression(tbTagExpression.Text);
                roExp.Success("Expression is valid");
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                roExp.Error(iee.ToString());
                return;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
                return;
            }

            //now apply the expression to the tree
            TestTree.EnableExpression(expression);
        }

        private void ButtonIgnoreExpression_Click(object sender, EventArgs ea)
        {
            //parse the expression
            NodeTaggingData.Expression expression=null;

            try
            {
                expression=new NodeTaggingData.Expression(tbTagExpression.Text);
                roExp.Success("Expression is valid");
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                roExp.Error(iee.ToString());
                return;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
                return;
            }

            //now apply the expression to the tree
            TestTree.IgnoreExpression(expression);
        }

        private void ButtonUnignoreExpression_Click(object sender, EventArgs ea)
        {
            //parse the expression
            NodeTaggingData.Expression expression=null;

            try
            {
                expression=new NodeTaggingData.Expression(tbTagExpression.Text);
                roExp.Success("Expression is valid");
            }
            catch (NodeTaggingData.InvalidExpressionException iee)
            {
                roExp.Error(iee.ToString());
                return;
            }
            catch (System.Exception e)
            {
                ro.Fatal("Unexpected exception processing expression:\n"+e);
                return;
            }

            //now apply the expression to the tree
            TestTree.UnignoreExpression(expression);
        }

        public void ButtonExpressionHelp_Click(object sender, EventArgs ea)
        {
            //make a form
            Form form=new Form();
            form.SetBounds(0,0,800,600,BoundsSpecified.Size);
            form.Text="Expressions Help";
            form.FormBorderStyle=FormBorderStyle.Sizable;

            //add a text box to it
            TextBox box=new TextBox();
            box.Text=NodeTaggingData.Expression.GetHelpText().Replace("\n","\r\n");
            box.Dock=DockStyle.Fill;
            //box.BackColor=Color.Black;
            //box.ForeColor=Color.LightGray;
            box.WordWrap=false;
            //box.Font=new System.Drawing.Font("Lucida Console", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            box.ReadOnly=true;
            box.Enabled=true;
            box.HideSelection=false;
            box.ShortcutsEnabled=false;
            box.Multiline=true;
            box.ScrollBars=ScrollBars.Both;
            box.SelectionStart=0;
            box.SelectionLength=0;
            form.Controls.Add(box);
            form.Show(GuiHooks.MainForm);
        }

        private void AutorunCountDownTimerTick(object pirate, System.Timers.ElapsedEventArgs arr)
        {
            if (autorunState==AutorunState.Starting)
            {
                --autorunCountDown;
                ro.Info("Autorun starting in "+autorunCountDown+" seconds.");
                if (autorunCountDown<=0)
                {
                    autorunCountDownTimer.Stop();
                    autorunState=AutorunState.Running;

                    if (rootNodes.Count==0)
                    {
                        ro.Info("Autorun: No suites loaded, so exiting.");
                        GuiHooks.MainForm.Close();
                    }
                    else
                    {
                        if (this.checkAllForAutoRun)
                        {
                            Menu_Func_SelectAll(null, null);
                        }

                        ButtonStart_Click(null,null);
                    }
                }
            }
        }

        public void OnTestEvent(TestEventArgs tea)
        {
            if (isInAutorunMode) //in autorun mode, close when done
            {
                if (tea.Action==TestAction.StopAll)
                {
                    ro.Info("Autorun: Run finished, so exiting.");
                    GuiHooks.MainForm.Close();
                }
            }
        }

        #endregion

        //loads functional config from an xml file
        private void LoadXmlEnabledConfig(string file)
        {
            //load file
            XmlDocument doc=new XmlDocument();
            try
            {
                doc.Load(file);
            }
            catch (Exception e)
            {
                ro.Error("Error loading function xml config file: "+file+": "+e);
                return;
            }

            //clear out all old enables and set the correct nodes
            foreach (TestNode suite in rootNodes)
            {
                if (suite.FunctionalData!=null)
                {
                    suite.FunctionalData.Enabled=false;
                }
            }

            XmlNode xmlSaved=XmlUtil.GetGroupNode(doc, "Saved");
            foreach (TestNode suite in rootNodes)
            {
                XmlNode xmlSuite=XmlUtil.GetGroupNode(xmlSaved, MakeStringSaneForXml(suite.Name));
                XmlNode xmlEnabled=XmlUtil.GetGroupNode(xmlSuite, "Enabled");
                foreach (XmlNode xnode in xmlEnabled.ChildNodes)
                {
                    TestNode tn=TestNode.FindNode(suite, UnmakeStringSaneForXml(xnode.Name));
                    if (tn!=null && tn.FunctionalData!=null)
                    {
                        tn.FunctionalData.Enabled=true;
                    }
                }
            }

            if (TestTree!=null)
            {
                TestTree.UpdateAllCheckBoxes();
            }
        }

        //thread proc to start running
        void ThreadProcRun()
        {
            //update params then validate
            if (!Scheduler.ValidateParameters())
            {
                ro.Warn("Functional scheduler reports that it has invalid parameters.  Running anyways though.");
            }

            //run
            if (!isRunning)

            {
                SetControlsRunning();
                Scheduler.Run();
                SetControlsStopped();
            }
        }

        //thread proc to stop running
        void ThreadProcStop()
        {
            ControlsPanel.Invoke(new InvokeCode(delegate
            {
                butStart.Enabled=false;
                butStop.Enabled=false;
                menuItemStop.Enabled=false;
                butStop.Text="Stopping";
            }));

            if (rootNodes.Count>0)
            {
                Scheduler.Stop();
            }
            SetControlsStopped();
        }

        //sets the state of the controls to "running"
        private void SetControlsRunning()
        {
            isRunning=true;
            ControlsPanel.Invoke(new InvokeCode(delegate
            {
                butStart.Text="Start";
                butStart.Enabled=false;
                butStop.Text="Pause";
                butStop.Enabled=true;
                menuItemStart.Enabled=false;
                menuItemPause.Enabled=true;
                menuItemStop.Enabled=true;

                menuItemSaveState.Enabled=false;
                menuItemLastKnownState.Enabled=false;
                menuItemLoadState.Enabled=false;
                menuItemGenerateTrxOnRun.Enabled=false;

                foreach (CheckBox cb in optionsCheckBoxes)
                {
                    cb.Enabled=false;
                }
            }));
        }

        //sets the state of the controls to "paused"
        private void SetControlsPaused()
        {
            ControlsPanel.Invoke(new InvokeCode(delegate
            {
                butStart.Text="Resume";
                butStart.Enabled=true;
                butStop.Text="Stop";
                butStop.Enabled=true;
                menuItemStart.Enabled=true;
                menuItemPause.Enabled=false;
                menuItemStop.Enabled=true;
            }));
        }

        //sets the state of the controls to "stopped"
        private void SetControlsStopped()
        {
            ControlsPanel.Invoke(new InvokeCode(delegate
            {
                butStart.Text="Start";
                butStart.Enabled=true;
                butStop.Text="Stop";
                butStop.Enabled=false;
                menuItemStart.Enabled=true;
                menuItemPause.Enabled=false;
                menuItemStop.Enabled=false;

                menuItemSaveState.Enabled=true;
                menuItemLastKnownState.Enabled=true;
                menuItemLoadState.Enabled=true;
                menuItemGenerateTrxOnRun.Enabled=true;

                foreach (CheckBox cb in optionsCheckBoxes)
                {
                    cb.Enabled=true;
                }
                UpdateOverrideControlsState();
            }));
            isRunning=false;
        }

        //Pops up a window with output filtered from a specific node
        private void ShowFilteredOutputBox(FuncTreeNode ftn)
        {
            if (ftn==null)
            {
                return;
            }

            //make form
            Form form=new Form();
            form.SetBounds(0,0,650,400,BoundsSpecified.Size);
            form.Text=ftn.LinkedTestNode.FullName;
            form.FormBorderStyle=FormBorderStyle.Sizable;

            //add a "Loading..." label
            Label loading=new Label();
            loading.Text="Loading...";
            loading.Size=new System.Drawing.Size(60, 15);
            form.Controls.Add(loading);

            //add a stf output box to it
            StfTextBox box=new StfTextBox();
            box.Dock=DockStyle.Fill;
            form.Controls.Add(box);
            form.Show(GuiHooks.MainForm);

            //now populate that box with relevent loglines
            form.Refresh();
            box.SuspendLayout();

            LinkedList<Report.ReportLine> filteredLines=new LinkedList<Report.ReportLine>();

            lock (LogLines)
            {
                foreach (Report.ReportLine line in LogLines)
                {
                    if (FilterNodeNameFromNodeName(line.TestName, ftn.LinkedTestNode.FullName))
                    {
                        filteredLines.AddLast(line);
                    }
                }
            }

            box.LogBulk(filteredLines);

            box.ResumeLayout();
            loading.Visible=false;
        }

        //returns whether (Node Names) nameToFilter is a subset of filter.
        private bool FilterNodeNameFromNodeName(string nameToFilter, string filter)
        {
            if (nameToFilter==filter) //if they're the same, it is
            {
                return true;
            }

            if (nameToFilter.StartsWith(filter+".")) //if it is within the group, it is
            {
                return true;
            }

            return false;
        }

        //handles incoming loglines
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            if (!StoreLoglines || testName==ThreadTracker.DefaultFullName) //if not logging or it has no bucket (for example stress output)
            {
                return;
            }
            else //store it
            {
                Report.ReportLine line=new Report.ReportLine();
                line.Date=date;
                line.Level=level;
                line.Path=path;
                line.Message=message;
                line.TestName=testName;

                lock (LogLines)
                {
                    LogLines.Add(line);
                }
            }
        }

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\FunctionalRunner\FuncTree.cs ===
//#define DEBUG_NODE_DATA

using System;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Text;
using System.Collections.Generic;
using System.Security.Permissions;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;

namespace STFGui.Plugins
{
    /// <summary>
    /// A single functional node in the tree.
    /// All nodes added to this can be assumed to have functional data.
    /// </summary>
    public class FuncTreeNode: TreeNode
    {
        Report ro=null;

        //The TestNode that this node of the tree represents
        public TestNode LinkedTestNode
        {
            get {return testNode;}
        }
        TestNode testNode;

        private FunctionalPlugin functionalPlugin;

        //Extra run-time information about the node (such as exceptions it failed with)
        public string ExtraDescription="";

        //How the node's run state can be represented in the tree.
        public enum VisualRunState
        {
            NotRun,
            PreRunning,
            PostRunning,
            Running,
            Passed,
            PreFailed,
            Failed,
            PassedButPostFailed,
            Timeout
        }
        public VisualRunState RunState=VisualRunState.NotRun;
        public int PassCount=0;
        public int TotalCount=0;
        public int FailedWithBugCount=0;

        // --
        //ctor
        public FuncTreeNode(TestNode node, bool addChildren, FunctionalPlugin containedFunctionalPlugin, FuncTreeView treeViewContaining)
        {
            ro=treeViewContaining.ro;
            testNode=node;
            functionalPlugin=containedFunctionalPlugin;

            if (addChildren)
            {
                foreach (TestNode child in node.Children)
                {
                    if (child.FunctionalData!=null)
                    {
                        Nodes.Add(new FuncTreeNode(child, true, functionalPlugin, treeViewContaining));
                    }
                }
            }

            UpdateNodeVisuals();
        }

        /// <summary>
        /// Uses the scheduler data to set what the VisualRunState should be, as well as the values 
        /// of the PassCount and TotalCount fields.
        /// </summary>
        public void UpdateRunState()
        {
            FunctionalSchedulerNodeData schedulerData = this.LinkedTestNode.FunctionalData.SchedulerData;

            RunState = VisualRunState.NotRun;
            if (schedulerData != null)
            {
                if (schedulerData.NumberFailed >= 1 || schedulerData.RunResult == TEST_RESULTS.FAILED)
                {
                    RunState = VisualRunState.Failed;
                    FailedWithBugCount = schedulerData.NumberFailedWithBug;
                }

                if (schedulerData.NumberPreFailed >= 1)
                {
                    if (schedulerData.RunResult == TEST_RESULTS.FAILED && schedulerData.NumberTotal > 0 && LinkedTestNode.ChildrenCount > 0)
                        RunState = VisualRunState.Failed;
                    else
                        RunState = VisualRunState.PreFailed;
                }
                else if (schedulerData.NumberTimeOutFailed >= 1 && schedulerData.NumberFailed == 0)
                    RunState = VisualRunState.Timeout;
                else if (schedulerData.NumberPostFailed >= 1 && schedulerData.NumberFailed == 0)
                    RunState = VisualRunState.PassedButPostFailed;
                else if (schedulerData.IsPrerunning)
                    RunState = VisualRunState.PreRunning;
                else if (schedulerData.IsPostrunning)
                    RunState = VisualRunState.PostRunning;
                else if (schedulerData.InProgress == true && schedulerData.EndTime == DateTime.MaxValue)
                    RunState = VisualRunState.Running;
                else if (schedulerData.RunResult == TEST_RESULTS.PASSED)
                    RunState = VisualRunState.Passed;

                PassCount = schedulerData.NumberPassed;
                TotalCount = schedulerData.NumberTotal;
            }
        }

        //Rebuilds the Text and other visual properties of the node
        public void UpdateNodeVisuals()
        {
            UpdateRunState();

            //rebuild Text
            string newText="";
            if (testNode.ChildrenCount>0)
            {
                newText="["+PassCount+"/"+TotalCount+"] ";
            }
            newText+=testNode.Name;

            if (testNode.FunctionalData.AtomicGroup && testNode.ChildrenCount>0)
            {
                newText+="  (Atomic Branch)";
            }

            if (testNode.FunctionalData.BugID!=0)
            {
                newText += "  (BugID: " + 
                    (testNode.FunctionalData.BugDatabase == null ? "" : testNode.FunctionalData.BugDatabase + " ")
                    + testNode.FunctionalData.BugID + ")";
            }

            int ag=testNode.FunctionalData.AsyncGroup;
            if (ag!=0)
            {
                newText+="  (AsyncGroup: "+ag+")";
            }

            if (testNode.FunctionalData.Dependencies.Count!=0)
            {
                newText+="  (Depends: ";
                for (int i=0; i<testNode.FunctionalData.Dependencies.Count; ++i)
                {
                    if (i!=0) newText+=", ";
                    newText+=testNode.FunctionalData.Dependencies[i];
                }
                newText+=")";
            }

            //tags
            Dictionary<string, NodeTaggingData.ValueSet> tagList;
            if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.Node)
            {
                tagList=testNode.TaggingData.GetNodeTags();
            }
            else if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.NodeParents)
            {
                tagList=testNode.TaggingData.GetAllTrunkTags();
            }
            else if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.NodeChildren)
            {
                tagList=testNode.TaggingData.GetAllBranchTags();
            }
            else if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.NodeParentsChildren)
            {
                tagList=testNode.TaggingData.GetAllTreeTags();
            }
            else if (functionalPlugin.TagVisibilityState==FunctionalPlugin.TagVisibilityStates.NodeNearestParent)
            {
                tagList=testNode.TaggingData.GetNearestTrunkTags();
            }
            else //TagVisibilityStates.Hide
            {
                tagList=new Dictionary<string, NodeTaggingData.ValueSet>();
            }

            foreach (string tagName in tagList.Keys)
            {
                newText+="  ["+tagName;
                NodeTaggingData.ValueSet tagValues=tagList[tagName];
                if (tagValues.Count>0)
                {
                    newText+=": ";
                    newText+=ServerTestFramework.Utilities.StringUtils.MakeCommaSeparatedList(tagValues);
                }
                newText+="]";
            }

            if (testNode.ChildrenCount == 0 && testNode.FunctionalData.Timeout != System.Threading.Timeout.Infinite)
            {
                newText += " {Timeout: " + testNode.FunctionalData.Timeout + "}";
            }

            if (newText!=Text)
            {
                Text=newText;
            }

            //tooltip
            string newTipText = testNode.Desc ?? "";
            if (ExtraDescription.Length!=0)
            {
                if (newTipText.Length>0) newTipText+="\n";
                newTipText+=ExtraDescription;
            }

            if (newTipText.Length > 1024)
            {
                newTipText = newTipText.Substring(0, 1024) + "...";
            }

            if (newTipText!=ToolTipText)
            {
                ToolTipText=newTipText.Replace("\0", "");
            }

            //color of the text
            Color fgColor=(testNode.FunctionalData.Ignored?Color.Gray:Color.Black);

            if (ForeColor!=fgColor)
            {
                ForeColor=fgColor;
            }

            //bgcolor
            Color bgc=Color.White;
            if (RunState==VisualRunState.Running) bgc=Color.FromArgb(unchecked((int)0xffbbbbbb));
            else if (RunState==VisualRunState.PreRunning) bgc=Color.FromArgb(unchecked((int)0xffdddddd));
            else if (RunState==VisualRunState.PostRunning) bgc=Color.FromArgb(unchecked((int)0xff888888));
            else if (RunState==VisualRunState.Passed) bgc=Color.LightGreen;
            else if (RunState==VisualRunState.Failed)
            {
                if ((FailedWithBugCount!=0)&&(TotalCount-PassCount==FailedWithBugCount))
                {
                    bgc=Color.Yellow;
                }
                else
                {
                    bgc=Color.Red;
                }
            }
            else if (RunState==VisualRunState.PreFailed) bgc=Color.SandyBrown;
            else if (RunState==VisualRunState.PassedButPostFailed) bgc=Color.LightSeaGreen;
            else if (RunState == VisualRunState.Timeout) bgc = Color.Purple;

            FuncTreeView tvOwner = null;
            if (this.TreeView is FuncTreeView)
                tvOwner = ((FuncTreeView)this.TreeView);

            //Check if sticky colors is on, and if the case wasn't touched on this run. If both are true, keep the old color.
            bool keepColor = (tvOwner != null && tvOwner.StickyColors) && RunState == VisualRunState.NotRun;

            if (BackColor!=bgc && !keepColor)
            {
                BackColor=bgc;
            }

            //
            if (Checked!=testNode.FunctionalData.Enabled)
            {
                Checked=testNode.FunctionalData.Enabled;
            }
        }

        //update the visuals of this node and all children
        public void UpdateTreeVisuals()
        {
            UpdateNodeVisuals();

            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.UpdateTreeVisuals();
            }
        }

        //Updates my check box and my children's to reflect the current state of the tree
        public void UpdateCheckBoxes()
        {
            Checked=testNode.FunctionalData.Enabled;

            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.UpdateCheckBoxes();
            }
        }

        //resets the state of all nodes to "not run"
        public void ResetRunState()
        {
            FunctionalSchedulerNodeData schedulerData = null;
            if (LinkedTestNode.FunctionalData != null)
                schedulerData = this.LinkedTestNode.FunctionalData.SchedulerData;

            if (ExtraDescription!="" || PassCount!=0 || TotalCount!=0 || RunState!=VisualRunState.NotRun)
            {
                ExtraDescription="";
                PassCount=0;
                TotalCount=0;
                FailedWithBugCount=0;
                RunState=VisualRunState.NotRun;
                UpdateNodeVisuals();
            }

            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ResetRunState();
            }
        }

        public delegate void ApplyToNodeDelegate(FuncTreeNode ftn, bool result);

        public void ProcessExpression(NodeTaggingData.Expression expression, ApplyToNodeDelegate applyEffect)
        {
            //do me
            try
            {
                bool result=expression.EvaluateBool(LinkedTestNode);

                applyEffect(this, result);
            }
            catch (NodeTaggingData.ExpressionEvaluationException iee)
            {
                ToolTipText=iee.ToString();
                BackColor=Color.PaleVioletRed;
            }
            catch (System.Exception e)
            {
                ToolTipText="Unexpected exception evaluating expression:\n"+e.ToString();
                BackColor=Color.HotPink;
            }

            //do my children
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, applyEffect);
            }
        }

        //finds the node that should handle this event and handles it.  returns true if handled.
        //nameparts is the seperated node names for the target node
        public bool HandleTestEvent(TestEventArgs e, string []nameParts, int partsIndex)
        {
            //determine if this event is targetted at me
            if (testNode.Name==nameParts[partsIndex])
            {
                //if there's more parts to it after that, it's targetted at my children
                if (partsIndex<nameParts.Length-1)
                {
                    foreach (TreeNode tnbase in Nodes)
                    {
                        FuncTreeNode tn=(FuncTreeNode)tnbase;
                        if (tn.HandleTestEvent(e, nameParts, partsIndex+1))
                        {
                            return true;
                        }
                    }
                }
                else //targetted specifically at me
                {
                    bool useForToolTip=false;
                    switch(e.Action)
                    {
                    case TestAction.Ignore:
                    case TestAction.Pass:
                    case TestAction.PreFail:
                    case TestAction.Fail:
                    case TestAction.PostFail:
                    case TestAction.Timeout:
                        useForToolTip=true;
                        break;
                    }

                    for (FuncTreeNode pn=(FuncTreeNode)Parent; pn!=null; pn=(FuncTreeNode)pn.Parent)
                        pn.UpdateNodeVisuals();

                    //update tooltip text that holds the result
                    if (useForToolTip)
                    {
                        if (!String.IsNullOrEmpty(e.Details))
                            ExtraDescription +=  (!String.IsNullOrEmpty(ExtraDescription)) ? "\n" + e.Details : e.Details;

                        if (!String.IsNullOrEmpty(e.Message))
                            ExtraDescription += (!String.IsNullOrEmpty(ExtraDescription)) ? "\n" + e.Message : e.Message;

                        if (!String.IsNullOrEmpty(e.Stack))
                            ExtraDescription += (!String.IsNullOrEmpty(ExtraDescription)) ? "\n" + e.Stack : e.Stack;
                    }

                    UpdateNodeVisuals();

                    return true;
                }
            }

            return false;
        }

        //retrieves a flattened list of all leaf nodes
        public void GetLeafNodes(ref List<FuncTreeNode> leafNodes)
        {
            if (Nodes.Count==0)
            {
                leafNodes.Add(this);
            }
            else
            {
                foreach (TreeNode tnbase in Nodes)
                {
                    FuncTreeNode tn=(FuncTreeNode)tnbase;
                    tn.GetLeafNodes(ref leafNodes);
                }
            }
        }

        //retrieves a flattened list of all nodes
        public void GetFlattenedSubtree(ref List<FuncTreeNode> allNodes)
        {
            allNodes.Add(this);
            if (Nodes.Count != 0)
            {
                foreach (TreeNode tnbase in Nodes)
                {
                    FuncTreeNode tn = (FuncTreeNode)tnbase;
                    tn.GetFlattenedSubtree(ref allNodes);
                }
            }
        }
    };

    /// <summary>
    /// The functional test tree view.
    /// </summary>
    public class FuncTreeView: TreeView, TestEventListener
    {
        public Report ro=new Report("FuncPlugin");

        Form guiForm;
        FunctionalPlugin functionalPlugin;
        bool stickyColors = false;
        public delegate void InvokeCode();

        private System.Windows.Forms.Timer testEventUpdateTimer=new System.Windows.Forms.Timer();
        private volatile System.Collections.Generic.List<TestEventArgs> testEventQueuePending=new System.Collections.Generic.List<TestEventArgs>();
        private volatile System.Collections.Generic.List<TestEventArgs> testEventQueueProcessing=new System.Collections.Generic.List<TestEventArgs>();
        private object testEventQueueLock=new object();
        private object testEventProcessLock=new object();

        public bool StickyColors
        {
            get { return stickyColors; }
            set { stickyColors = value; }
        }

        //ctor
        public FuncTreeView(Form ownerForm, FunctionalPlugin ownerFuncPlugin): base()
        {
            //
            CheckBoxes=true;
            ShowNodeToolTips=true;
            guiForm=ownerForm;
            functionalPlugin=ownerFuncPlugin;

            //hook up events
            AfterCheck+=Event_AfterCheck;
            MouseDown+=Event_MouseDown;

            //add context menu
            ContextMenu=new ContextMenu();
            ContextMenu.Popup+=ContextHandler;

            //start the event process timer
            testEventUpdateTimer.Interval=50;
            testEventUpdateTimer.Tick+=new EventHandler(TestEventUpdateTimer);
            testEventUpdateTimer.Start();
        }

        //Adds a tree of TestNodes to the tree view.
        public void AddTestTree(TestNode root)
        {
            if (root.FunctionalData==null)
            {
                return;
            }

            BeginUpdate();
            FuncTreeNode newNode=new FuncTreeNode(root, true, functionalPlugin, this);
            Nodes.Add(newNode);
            newNode.Expand();
            UpdateAllCheckBoxes();
            EndUpdate();
        }

        //Remove a tree of TestNodes to the tree view.
        public void RemoveTestTree(TestNode root)
        {
            BeginUpdate();
            foreach (FuncTreeNode n in Nodes)
            {
                if (n.LinkedTestNode==root)
                {
                    Nodes.Remove(n);
                    break;
                }
            }
            EndUpdate();
        }

        //Called when a check box changes state
        private void Event_AfterCheck(object sender, TreeViewEventArgs e)
        {
            if(e.Action!=TreeViewAction.Unknown) //only if the user caused the change
            {
                //update the functional data
                FuncTreeNode node=(FuncTreeNode)e.Node;
                node.LinkedTestNode.FunctionalData.Enabled=node.Checked;

                UpdateAllCheckBoxes();
            }
        }

        //refresh the text of all nodes in the tree
        public void RefreshAllNodeVisuals()
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.UpdateTreeVisuals();
            }
            EndUpdate();
        }

        //update all check boxes in the tree to reflect the state of the nodes
        public void UpdateAllCheckBoxes()
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.UpdateCheckBoxes();
            }
            EndUpdate();
        }

        //resets the state of all nodes to "not run"
        public void ResetRunState()
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ResetRunState();
            }
            EndUpdate();
        }

        public void HighlightExpression(NodeTaggingData.Expression expression)
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, delegate(FuncTreeNode ftn, bool result){ftn.BackColor=(result?Color.Chartreuse:Color.Bisque);});
                //tree visuals will override the color change, so we don't do it in this case
            }
            EndUpdate();
        }

        public void EnableExpression(NodeTaggingData.Expression expression)
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, delegate(FuncTreeNode ftn, bool result){if (result && ftn.LinkedTestNode.FunctionalData!=null) {ftn.LinkedTestNode.FunctionalData.Enabled=true;}});
                tn.UpdateTreeVisuals();
            }
            EndUpdate();
        }

        public void IgnoreExpression(NodeTaggingData.Expression expression)
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, delegate(FuncTreeNode ftn, bool result){if (result && ftn.LinkedTestNode.FunctionalData!=null) {ftn.LinkedTestNode.FunctionalData.Ignored=true;}});
                tn.UpdateTreeVisuals();
            }
            EndUpdate();
        }

        public void UnignoreExpression(NodeTaggingData.Expression expression)
        {
            BeginUpdate();
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.ProcessExpression(expression, delegate(FuncTreeNode ftn, bool result){if (result && ftn.LinkedTestNode.FunctionalData!=null) {ftn.LinkedTestNode.FunctionalData.Ignored=false;}});
                tn.UpdateTreeVisuals();
            }
            EndUpdate();
        }

        //retrieves a flattened list of all leaf nodes
        public void GetLeafNodes(ref List<FuncTreeNode> leafNodes)
        {
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn=(FuncTreeNode)tnbase;
                tn.GetLeafNodes(ref leafNodes);
            }
        }

        //retrieves a flattened list of all nodes
        public void GetFlattenedSubtree(ref List<FuncTreeNode> allNodes)
        {
            foreach (TreeNode tnbase in Nodes)
            {
                FuncTreeNode tn = (FuncTreeNode)tnbase;
                tn.GetFlattenedSubtree(ref allNodes);
            }
        }

        //prevent expanding/collapsing by double click -- is there a better way?
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m)
        {
            if (m.Msg==515) //double click
            {
                if (CustomDoubleClick!=null)
                {
                    CustomDoubleClick();
                }
            }
            else
            {
                base.WndProc(ref m);
            }
        }
        public delegate void VoidCall();
        public event VoidCall CustomDoubleClick;

        #region Events

        public delegate void OnTestEventDelegate(TestEventArgs e);

        //called whenever test events occur
        public void OnTestEvent(TestEventArgs e)
        {
            //.NET has some horrible horrible rendering performance problems when ui elemnts are update sporatically in fast succession.
            //To work around that, we will queue the events up and process them in batches on a fast timer
            lock (testEventQueueLock)
            {
                testEventQueuePending.Add(e);
            }
        }

        //processes all queue'd test events
        private void TestEventUpdateTimer(object obj, EventArgs ignoredEa)
        {
            lock (testEventProcessLock) //don't think this is needed, but just in case
            {
                //swap the pending and processing buffers
                lock (testEventQueueLock)
                {
                    System.Collections.Generic.List<TestEventArgs> temp=testEventQueueProcessing;
                    testEventQueueProcessing=testEventQueuePending;
                    testEventQueuePending=temp;
                    testEventQueuePending.Clear();
                }

                //process the batch
                if (testEventQueueProcessing.Count>0)
                {
                    if (InvokeRequired)
                    {
                        this.Invoke(new InvokeCode(delegate
                        {
                            HandleTestEventBatch(testEventQueueProcessing);
                        }));
                    }
                    else
                    {
                        HandleTestEventBatch(testEventQueueProcessing);
                    }
                }
            }
        }

        private void HandleTestEventBatch(System.Collections.Generic.List<TestEventArgs> batchEvents)
        {
            BeginUpdate();

            foreach (TestEventArgs e in batchEvents)
            {
                if (e.Action==TestAction.StartAll)
                {
                    ResetRunState();
                }
                else
                {
                    if (e.Node!=null)
                    {
                        string[] nodeNameParts=e.Node.FullName.Split(new char[]{'.'});

                        foreach (TreeNode tnbase in Nodes)
                        {
                            FuncTreeNode tn=(FuncTreeNode)tnbase;
                            bool handled=tn.HandleTestEvent(e, nodeNameParts, 0);
                            if (handled)
                            {
                                break;
                            }
                        }
                    }
                }
            }

            EndUpdate();
        }

        //context menu handler
        private void ContextHandler(object sender, EventArgs e)
        {
            //wipe out old options
            Menu.MenuItemCollection mi=ContextMenu.MenuItems;
            mi.Clear();

            //
            if (SelectedNode==null)
            {
                return;
            }
            FuncTreeNode node=(FuncTreeNode)SelectedNode;

            //add the options
            mi.Add("View Output", CtxMenu_ViewOutput);
            mi.Add("Toggle Ignored", CtxMenu_ToggleIgnore);
            mi.Add(new MenuItem("-"));
            mi.Add("Set AsyncGroup", CtxMenu_ChangeAsyncGroup);
            if (node.LinkedTestNode.ChildrenCount>0)
            {
                mi.Add("Set Children's Default AsyncGroup", CtxMenu_ChangeChildAsyncGroup);
            }

            //do callbacks for adding extra options and set those up
            List<FunctionalPlugin.TestNodeContextMenuItem> extraItems=new List<FunctionalPlugin.TestNodeContextMenuItem>();
            functionalPlugin.DoBuildNodeContextMenuItems(node.LinkedTestNode, extraItems);
            foreach (FunctionalPlugin.TestNodeContextMenuItem cmi in extraItems)
            {
                MenuItem realMi=new MenuItem();
                realMi.Text=cmi.Text;
                realMi.Tag=cmi;
                realMi.Click+=CtxMenu_Extras;
                mi.Add(realMi);
            }

#if DEBUG_NODE_DATA
            mi.Add(new MenuItem("-"));
            mi.Add("DEBUG - Print Scheduler Data", CtxMenu_DebugPrintSchedulerData);
#endif
        }

        //context menu handler
        private void CtxMenu_ViewOutput(object sender, EventArgs args)
        {
            if (CustomDoubleClick!=null)
            {
                CustomDoubleClick();
            }
        }

        //context menu handler
        private void CtxMenu_Extras(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;

            MenuItem wrapperMi=(MenuItem)sender;
            FunctionalPlugin.TestNodeContextMenuItem realMi=(FunctionalPlugin.TestNodeContextMenuItem)wrapperMi.Tag;

            realMi.InvokeClick(realMi, node.LinkedTestNode);
        }

        //context menu handler
        private void CtxMenu_ToggleIgnore(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;
            node.LinkedTestNode.FunctionalData.Ignored=!node.LinkedTestNode.FunctionalData.Ignored;
            node.UpdateNodeVisuals();
        }

        //context menu handler
        private void CtxMenu_ChangeAsyncGroup(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;

            int asyncVal=node.LinkedTestNode.FunctionalData.DirectAsyncGroup;
            asyncVal=GuiCommon.GetNumberFromUser(guiForm, "AsyncGroup", asyncVal);
            node.LinkedTestNode.FunctionalData.DirectAsyncGroup=asyncVal;

            node.UpdateNodeVisuals();
        }

        //context menu handler
        private void CtxMenu_ChangeChildAsyncGroup(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;

            int asyncVal=node.LinkedTestNode.FunctionalData.ChildrenAsyncGroupDefault;
            asyncVal=GuiCommon.GetNumberFromUser(guiForm, "Children's Default AsyncGroup", asyncVal);
            node.LinkedTestNode.FunctionalData.ChildrenAsyncGroupDefault=asyncVal;

            node.UpdateNodeVisuals();
            foreach (FuncTreeNode child in node.Nodes)
            {
                child.UpdateNodeVisuals();
            }
        }

#if DEBUG_NODE_DATA
        private void CtxMenu_DebugPrintSchedulerData(object sender, EventArgs args)
        {
            FuncTreeNode node=(FuncTreeNode)SelectedNode;
            TestNode tn=node.LinkedTestNode;
            ro.Debug("Scheduler data for "+tn.FullName+":\n"+tn.FunctionalData.SchedulerData);
        }
#endif

        //change the selected node anytime they click on a node in any way
        private void Event_MouseDown(object sender, MouseEventArgs e)
        {
            FuncTreeNode node=(FuncTreeNode)this.GetNodeAt(e.X, e.Y);
            SelectedNode=node;
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\GuiCommon\StfTextBox.cs ===
using System;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Text;
using System.Collections.Generic;

using ServerTestFramework;

namespace STFGui
{
    public class User32
    {
        // Consts from WinUser.h
        public static readonly uint WM_SETREDRAW=0x000B;
        public static readonly uint EM_REPLACESEL = 0xC2;

        [DllImport("user32.dll")]
        public static extern bool PostMessage(IntPtr hWnd, uint Msg, uint wParam, uint lParam);

        [DllImport("user32.dll")]
        public static extern uint SendMessage(IntPtr hWnd, uint Msg, uint wParam, uint lParam);

        [DllImport("user32.dll", CharSet = CharSet.Unicode)]
        public static extern uint SendMessage(IntPtr hWnd, uint Msg, uint wParam, string lParam);
    }

    /// <summary>
    /// A rich text box that can accept data from a report object.
    /// </summary>
    public class StfTextBox: RichTextBox, Report.BulkDestination
    {
        public delegate void InvokeCode();

        public bool IgnoreOutput = false;
        public Color DefaultColor = Color.LightGray;
        public Color DebugColor = Color.DarkGray;
        public Color WarnColor = Color.Gold;
        public Color ErrorColor = Color.Red;
        public Color FatalColor = Color.MediumPurple;
        public Color SuccessColor = Color.LightGreen;

        private LinkedList<Report.ReportLine> pendingLines = new LinkedList<Report.ReportLine>();

        /// <summary>
        /// Creates a new StfTextBox and setups some default values such as font and color
        /// </summary>
        public StfTextBox()
        {
            //Setup the box similarly colored to the old stf box
            BackColor=Color.Black;
            ForeColor=Color.LightGray;
            WordWrap=false;
            Font=new Font("Lucida Console", 8.25F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
            ReadOnly=true;
            Enabled=true;
            HideSelection=false;
            ShortcutsEnabled=true;

            //hookup events
            ContextMenu=new ContextMenu();
            ContextMenu.Popup += ContextHandler;
            HandleCreated += OnHandleCreated;
            LinkClicked += new LinkClickedEventHandler(StfTextBox_LinkClicked);
        }

        /// <summary>Backing for LengthLimit.</summary>
        private int _length_limit = 0;

        /// <summary>
        /// The text length should be limited to this value.
        /// However, it is only imposed once the length goes 12.5% beyond the limit and new lines are added.
        /// The value 0 disables the limit.
        /// </summary>
        public int LengthLimit
        {
            get { return _length_limit; }
            set { _length_limit = value; }
        }

        public Color GetLogLevelColor(UInt32 logLevel)
        {
            switch (logLevel)
            {
                case Report.DEBUG:
                    return DebugColor;
                case Report.WARN:
                    return WarnColor;
                case Report.ERROR:
                    return ErrorColor;
                case Report.FATAL:
                    return FatalColor;
                case Report.SUCCESS:
                    return SuccessColor;
                default:
                    return DefaultColor;
            }
        }

        /// <summary>
        /// Add a series of lines to the TextBox.  Must be called from the same thread as this was created
        /// </summary>
        /// <param name="lines">The data to be added to the TextBox</param>
        /// <remarks>.NET richtextbox has a funky way of doing this I don't like.. maybe look into direct rtf sometime.</remarks>
        private void AddLinesToBox(LinkedList<Report.ReportLine> lines)
        {
            int  topLeftChar = GetCharIndexFromPosition(new Point(DisplayRectangle.Left, DisplayRectangle.Top + 1));
            bool atEnd = GetCharIndexFromPosition(new Point(DisplayRectangle.Right, DisplayRectangle.Bottom)) >= Text.Length - 1;
            int selStart = SelectionStart;
            int selLen = SelectionLength;
            int textLength = TextLength;

            // stop updates to avoid flicker when adding lines
            bool pausedRedraw=false;
            if (textLength!=selStart)
            {
                pausedRedraw=true;
                User32.SendMessage(Handle, User32.WM_SETREDRAW, 0, 0);
            }

            try
            {
                int removedLength = 0;

                // limit is on, check it
                if (_length_limit > 0)
                {
                    if (textLength >= _length_limit + (_length_limit >> 3))
                    {
                        SelectionStart = 0;
                        removedLength = textLength - _length_limit;
                        SelectionLength = removedLength + 1;
                        SelectedText=Text.Substring(removedLength, 1);
                    }
                }

                // we will use textLength to track the length so that we don't need to do Text.Length
                textLength -= removedLength;

                foreach (Report.ReportLine line in lines)
                {
                    string lineMessage=line.Message.Replace("\0",""); //strip null terminators from output as they cause the box to cut off everything after it

                    //format the text and decide on the color
                    string formattedText=(textLength>0?"\n":"")+Report.FormatLogLine(line.Date, line.Level, line.Path, lineMessage);

                    Color color=GetLogLevelColor(line.Level);

                    //add it
                    this.SelectionStart=textLength;
                    this.SelectionColor=color;
                    User32.SendMessage(Handle, User32.EM_REPLACESEL, 0, formattedText); //We do this rather than calling AppendText because AppendText has some nasty side effects that bug out colors of already-selected text

                    // continue tracking textLength
                    textLength += formattedText.Length;
                }

                if (!atEnd)
                {
                    SelectionStart = Math.Max(topLeftChar - removedLength, 0);
                    ScrollToCaret();
                }

                if (selLen!=0)
                {
                    SelectionStart = Math.Max(selStart - removedLength, 0);
                    SelectionLength = selLen;
                }

                if (atEnd && removedLength!=0)
                {
                    SelectionStart=textLength;
                }
            }
            finally
            {
                //resume updates to the window
                if (pausedRedraw)
                {
                    User32.SendMessage(Handle, User32.WM_SETREDRAW, 1, 0);
                    Invalidate();
                }
            }
        }

        //Report data input
        public void Log(uint level, string path, string message, string testName, System.DateTime date)
        {
            if (IgnoreOutput)
            {
                return;
            }
            else if (!IsHandleCreated)
            {
                lock (pendingLines)
                {
                    pendingLines.AddLast(new Report.ReportLine(level, path, message, testName, date));
                }
            }
            else
            {
                //add it.  this could come from any thread, so we have do mess with an evil invoke
                this.Invoke(new InvokeCode(delegate
                    {
                        LinkedList<Report.ReportLine> one = new LinkedList<Report.ReportLine>();
                        one.AddLast(new Report.ReportLine(level, path, message, testName, date));
                        AddLinesToBox(one);
                    })
                );
            }
        }

        //Report data input
        public void LogBulk(LinkedList<Report.ReportLine> lines)
        {
            if (IgnoreOutput)
            {
                return;
            }
            else if (!IsHandleCreated)
            {
                lock (pendingLines)
                {
                    foreach (Report.ReportLine line in lines)
                    {
                        pendingLines.AddLast(line);
                    }
                }
            }
            else
            {
                //add it.  this could come from any thread, so we have do mess with an evil invoke
                if (!this.IsDisposed)
                {
                    this.Invoke(new InvokeCode(delegate
                        {
                            AddLinesToBox(lines);
                        })
                    );
                }
            }
        }

        #region Events

        private void OnHandleCreated(object sender, EventArgs e)
        {
            lock (pendingLines)
            {
                if (pendingLines.Count != 0)
                {
                    AddLinesToBox(pendingLines);
                    pendingLines.Clear();
                }
            }
        }

        //context menu handler
        private void ContextHandler(object sender, EventArgs e)
        {
            //wipe out old options
            Menu.MenuItemCollection mi=ContextMenu.MenuItems;
            mi.Clear();

            //add the options
            mi.Add("Copy Selected", CtxMenu_CopySelected);
            mi.Add("Copy All", CtxMenu_CopyAll);
        }

        private void CtxMenu_CopyAll(object sender, EventArgs e)
        {
            int prevStart=SelectionStart;
            int prevLen=SelectionLength;
            SelectionStart=0;
            SelectionLength=Text.Length;
            Copy();
            SelectionStart=prevStart;
            SelectionLength=prevLen;
        }

        private void CtxMenu_CopySelected(object sender, EventArgs e)
        {
            Copy();
        }

        void StfTextBox_LinkClicked(object sender, LinkClickedEventArgs e)
        {
            System.Diagnostics.Process.Start(System.IO.Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles), @"Internet Explorer\iexplore.exe"), e.LinkText);
        }
        #endregion
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Backup2\Gui.cs ===
using System;
using System.Reflection;
using System.Windows.Forms;
using System.Collections.Generic;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace STFGui
{
    /// <summary>
    /// The main gui form that holds all other forms
    /// </summary>
    public class STFGuiForm: Form
    {
        //Public components
        public RearrangeableTabControl Tabs;
        public GuiPluginHandler Plugins;
        public LinkedList<TestNode> SuiteRoots=new LinkedList<TestNode>();
        public LinkedList<string> LoadedModules=new LinkedList<string>();
        public LinkedList<string> LoadedModuleFiles=new LinkedList<string>();
        public XmlDocument Settings;

        //Internal components
        private SplitContainer splitTabsAndOutput;
        private StfTextBox outputBox;

        MRUList MRUFileList;
        MenuItem ViewFilterDebug;
        MenuItem ViewFilterInfo;
        MenuItem ViewFilterWarn;
        MenuItem ViewFilterError;
        MenuItem ViewFilterFatal;
        MenuItem ViewFilterSuccess;
        MenuItem ViewFilterAll;
        MenuItem ViewFilterNone;
        MenuItem ViewOuputLimit;
        MenuItem LogOutputToFile;

        bool allowClose = false;
        bool isClosing = false;
        bool isFirstShown = true;
        bool logToFile = false;

        FileReportDestination fileOutputDest=null;

        public delegate void InvokeCode();
        static Report ro=new Report("Gui");

        List<string> userPrefferedTabOrder=new List<string>();
        List<string> titlebarAssemblyNames=new List<string>();

        public bool LogToFile
        {
            get
            {
                return this.logToFile; 
            }

            set
            {
                lock (this)
                {
                    if (this.logToFile == value)
                    {
                        return;
                    }

                    this.logToFile = value;

                    // Assign checked value to menu item in case this set is not from the event handler.
                    LogOutputToFile.Checked = value;

                    //scrap the old
                    if (fileOutputDest != null)
                    {
                        Report.GetRoot().RemoveReportDestination(fileOutputDest);
                        fileOutputDest.Close();
                        fileOutputDest = null;
                    }

                    if (this.logToFile)
                    {
                        fileOutputDest = new FileReportDestination("FuncOutput", "Log", System.DateTime.Now);
                        Report.GetRoot().AddReportDestination(fileOutputDest);
                    }
                }
            }
        }


        //ctor
        public STFGuiForm()
        {
            // This should prevent those totally crappy no info crashes
            AppDomain.CurrentDomain.UnhandledException += new UnhandledExceptionEventHandler(CurrentDomain_UnhandledException);

            //load settings from file
            Settings=new XmlDocument();
            try
            {
                Settings.Load("STFGui.xml");
            }
            catch
            {
                //it's ok if it fails, it's probably because it doesn't exist, so we will use defaults.
            }

            //get or create our main settings node
            XmlNode mainNode=Settings.SelectSingleNode("STFGui");
            if (mainNode==null)
            {
                mainNode=Settings.CreateNode(XmlNodeType.Element, "STFGui", "");
                Settings.AppendChild(mainNode);
            }

            XmlNode groupNode=XmlUtil.GetGroupNode(mainNode, "BaseGui");

            //set up us and our events
            Text="STFGui";
            FormClosing+=Form_Closing;
            Shown+=Form_Shown;
            CoreGlobal.TestNodeTreeLoaded+=SuiteLoaded;
            CoreGlobal.TestNodeTreeUnloaded+=SuiteUnloaded;
            CoreGlobal.ReloadAllTestTrees+=ReloadSuites;

            //set up the main menu
            Menu=new MainMenu();

            //set up the file menu
            MenuItem menuFile=new MenuItem();
            menuFile.Text="File";
            this.Menu.MenuItems.Add(menuFile);

            MenuItem menuFileLoadSuite=new MenuItem();
            menuFileLoadSuite.Text="Load Suite or Plugin";
            menuFileLoadSuite.Click+=MenuChoice_File_LoadSuite;
            menuFileLoadSuite.Shortcut = Shortcut.CtrlO;
            menuFile.MenuItems.Add(menuFileLoadSuite);

            MenuItem menuFileReloadSuites=new MenuItem();
            menuFileReloadSuites.Text="Reload Suites";
            menuFileReloadSuites.Click+=MenuChoice_File_ReloadSuites;
            menuFileReloadSuites.Shortcut = Shortcut.CtrlF5;
            menuFile.MenuItems.Add(menuFileReloadSuites);

            menuFile.MenuItems.Add(new MenuItem("-"));

            MenuItem menuFileAttachDebugger = new MenuItem();
            menuFileAttachDebugger.Text = "Attach Debugger...";
            menuFileAttachDebugger.Click += MenuChoice_File_AttachDebugger;
            menuFileAttachDebugger.Shortcut = Shortcut.CtrlK;
            menuFile.MenuItems.Add(menuFileAttachDebugger);

            MenuItem menuFilePreferences = new MenuItem();
            menuFilePreferences.Text = "Preferences...";
            menuFilePreferences.Click += MenuChoice_File_Preferences;
            menuFilePreferences.Shortcut = Shortcut.CtrlShiftP;
            menuFile.MenuItems.Add(menuFilePreferences);

            menuFile.MenuItems.Add(new MenuItem("-"));

            //MRU File list.
            string paths = XmlUtil.GetChildNodeValue(groupNode, "MRUFileList", String.Empty);
            MRUFileList = new MRUList("Recently Loaded Suites/Plugins");
            MRUFileList.ClickChild += MenuChoice_MRU_ItemClick;
            MRUFileList.LoadCSVString(paths);
            menuFile.MenuItems.Add(MRUFileList);

            menuFile.MenuItems.Add(new MenuItem("-"));

            MenuItem menuFileExit=new MenuItem();
            menuFileExit.Text="Exit";
            menuFileExit.Click+=MenuChoice_File_Exit;
            menuFile.MenuItems.Add(menuFileExit);

            //splitter between the tab-specific area and the output box area
            splitTabsAndOutput=new SplitContainer();
            splitTabsAndOutput.Orientation=Orientation.Horizontal;
            splitTabsAndOutput.Size=new System.Drawing.Size(Width, XmlUtil.GetChildNodeValue(groupNode, "SplitterHeight", 600));
            splitTabsAndOutput.Dock=DockStyle.Fill;
            ++splitTabsAndOutput.SplitterWidth;
            this.Controls.Add(splitTabsAndOutput);
            splitTabsAndOutput.SplitterDistance=(int)(splitTabsAndOutput.Height*XmlUtil.GetChildNodeValue(groupNode, "SplitterBar", 0.5f));

            //the output box
            outputBox=new StfTextBox();
            outputBox.Dock=DockStyle.Fill;

            splitTabsAndOutput.Panel2.Controls.Add(outputBox);

            try
            {
                splitTabsAndOutput.Panel2.GetType().GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic).SetValue(splitTabsAndOutput.Panel2, true, null);
            }
            catch (Exception e)
            {
                ro.Warn("Error occured while trying to double buffer the output box:\n" + e.ToString());
            }

            //the tab list
            Tabs=new RearrangeableTabControl();
            Tabs.Dock=DockStyle.Fill;
            splitTabsAndOutput.Panel1.Controls.Add(Tabs);
            Tabs.UserRearrangedPages+=Tabs_Rearranged;

            //set up the view menu
            MenuItem menuView=new MenuItem();
            menuView.Text="Output";
            Menu.MenuItems.Add(menuView);

            MenuItem menuClearOutput=new MenuItem("Clear", MenuChoice_Output_ClearOutput);
            menuView.MenuItems.Add(menuClearOutput);

            ViewOuputLimit = new MenuItem("Limit Output");
            MenuItem tempLimitItem = new MenuItem("No Limit", MenuChoice_Output_Limit);
            tempLimitItem.Checked = true;
            tempLimitItem.Tag = 0;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("1K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 1000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("10K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 10000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("100K", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 100000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("1M", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 1000000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            tempLimitItem = new MenuItem("10M", MenuChoice_Output_Limit);
            tempLimitItem.Tag = 10000000;
            ViewOuputLimit.MenuItems.Add(tempLimitItem);
            menuView.MenuItems.Add(ViewOuputLimit);

            MenuItem menuDiv=new MenuItem();
            menuDiv.Text="-";
            menuView.MenuItems.Add(menuDiv);

            ViewFilterAll=new MenuItem("Enable ALL",MenuChoice_Output_ChangeFilter);
            menuView.MenuItems.Add(ViewFilterAll);
            ViewFilterNone=new MenuItem("Enable NONE",MenuChoice_Output_ChangeFilter);
            menuView.MenuItems.Add(ViewFilterNone);
            ViewFilterDebug=new MenuItem("Debug",MenuChoice_Output_ChangeFilter);
            ViewFilterDebug.Checked=true;
            menuView.MenuItems.Add(ViewFilterDebug);
            ViewFilterInfo=new MenuItem("Info",MenuChoice_Output_ChangeFilter);
            ViewFilterInfo.Checked=true;
            menuView.MenuItems.Add(ViewFilterInfo);
            ViewFilterWarn=new MenuItem("Warn",MenuChoice_Output_ChangeFilter);
            ViewFilterWarn.Checked=true;
            menuView.MenuItems.Add(ViewFilterWarn);
            ViewFilterError=new MenuItem("Error",MenuChoice_Output_ChangeFilter);
            ViewFilterError.Checked=true;
            menuView.MenuItems.Add(ViewFilterError);
            ViewFilterFatal=new MenuItem("Fatal",MenuChoice_Output_ChangeFilter);
            ViewFilterFatal.Checked=true;
            menuView.MenuItems.Add(ViewFilterFatal);
            ViewFilterSuccess=new MenuItem("Success",MenuChoice_Output_ChangeFilter);
            ViewFilterSuccess.Checked=true;
            menuView.MenuItems.Add(ViewFilterSuccess);

            menuDiv=new MenuItem();
            menuDiv.Text="-";
            menuView.MenuItems.Add(menuDiv);

            MenuItem menuViewLogToFile=new MenuItem("Log To File", MenuChoice_Output_LogToFile);
            menuView.MenuItems.Add(menuViewLogToFile);
            menuViewLogToFile.Checked=!XmlUtil.GetChildNodeValue(groupNode, "OutputLogToFile", logToFile);
            MenuChoice_Output_LogToFile(menuViewLogToFile, null); //this toggles it
            LogOutputToFile = menuViewLogToFile;
        }

        //app crash handler
        void CurrentDomain_UnhandledException (object sender, UnhandledExceptionEventArgs e)
        {
            System.Text.StringBuilder builder = new System.Text.StringBuilder();

            // time
            builder.Append("At ");
            builder.AppendLine(DateTime.Now.ToString());

            // termination message
            if (e.IsTerminating)
            {
                builder.AppendLine("An unhandled exception in a thread is causing STFGui to terminate, please investigate.");
            }
            else
            {
                builder.AppendLine("An unhandled exception in a thread has caused this message, please investigate.");
                builder.AppendLine("STFGui SHOULD NOT be terminating.");
            }
            builder.AppendLine();

            // sender info
            AppDomain appdom = sender as AppDomain;
            if (appdom != null)
            {
                builder.Append("AppDomain: ");
                builder.AppendLine(appdom.FriendlyName);
            }
            else
            {
                builder.Append("Sender: ");
                builder.AppendLine(sender.ToString());
            }
            builder.AppendLine();

            // exception info
            Exception exc = e.ExceptionObject as Exception;
            if (exc != null)
            {
                builder.Append(exc.ToString());
            }
            else
            {
                builder.Append("Exception is null, yikes!");
            }

            string message = builder.ToString();

            try
            {
                System.IO.File.AppendAllText(System.IO.Path.GetFullPath(".\\STFGuiCrashInfo.txt"),
                    message + Environment.NewLine + Environment.NewLine);
            }
            catch { }

            try
            {
                MessageBox.Show(message);
            }
            catch { }
        }

        //Should be called after construction to init public members.  Returns flags that indicate the success of handling paramaters
        public MainApp.STFGuiExitCode Init(string []mainAppParameters, string []pluginParameters)
        {
            MainApp.STFGuiExitCode status=MainApp.STFGuiExitCode.OK;

            //hook console output to stf, and stf output up to our output box
            Report.GetRoot().AddReportDestination(outputBox);
            Console.SetError(new TextWriterReportBridge("STDERR"));
            Console.SetOut(new TextWriterReportBridge("STDOUT"));

            //handle parameters to the gui itself
            bool ignoreDefaultPlugins=false;
            if (!HandleCommandlineOptions(mainAppParameters, ref ignoreDefaultPlugins))
            {
                status|=MainApp.STFGuiExitCode.GuiParamError;
            }

            //spit out our version
            ro.Debug(Assembly.GetExecutingAssembly().GetName().Name+" is version "+Assembly.GetExecutingAssembly().GetName().Version);
            ro.Debug("STFCore is version "+CoreGlobal.GetCoreAssembly().GetName().Version);

            //load default plugins
            //TODO: figure out if any plugin parameters had errors and set status for that here
            Plugins=new GuiPluginHandler(this, pluginParameters);
            if (!ignoreDefaultPlugins)
            {
                Plugins.LoadPluginFiles();
            }

            //load tab arrangement
            XmlNode groupNode=Settings.DocumentElement.SelectSingleNode("BaseGui");

            XmlNode tabOrderGroupNode=XmlUtil.GetGroupNode(groupNode, "TabOrder");
            foreach(XmlNode n in tabOrderGroupNode.ChildNodes)
            {
                if (n.Name=="TabName")
                {
                    userPrefferedTabOrder.Add(n.InnerXml);
                }
            }

            string initialTabName=XmlUtil.GetChildNodeValue(groupNode, "OpenTab","Functional");
            ArrangeTabsAndSelectInitialTab(initialTabName);

            return status;
        }

        private void ArrangeTabsAndSelectInitialTab(string initialTabName)
        {
            RearrangeTabsForUser();

            //select the last plugin tab if possible
            foreach (TabPage tp in Tabs.TabPages)
            {
                if (tp.Text==initialTabName)
                {
                    Tabs.SelectTab(tp);
                    break;
                }
            }
        }

        //handles commandline options that are specifically targetted at STFGui itself.  returns false if there were any errors with the parameters
        private bool HandleCommandlineOptions(string []options, ref bool outIgnoreDefaultPlugins)
        {
            bool errors=false;
            foreach (string option in options)
            {
                string lowerOption=option.ToLower();

                try
                {
                    if (lowerOption.StartsWith("-logtofile")) //turn on/off logging to file
                    {
                        LogToFile=true;
                        if (lowerOption.StartsWith("-logtofile:")) //they can also specify true or false for the value
                        {
                            int sepInd=lowerOption.IndexOf(":");
                            string value=lowerOption.Substring(sepInd+1);
                            LogToFile=bool.Parse(value);
                        }
                        ro.Debug("STFGui option: LogToFile="+LogToFile);
                    }
                    else if (lowerOption=="-ignoredefaultplugins") //don't load any default plugins
                    {
                        outIgnoreDefaultPlugins=true;
                        ro.Debug("STFGui option: IgnoreDefaultPlugins="+outIgnoreDefaultPlugins);
                    }
                    else if (lowerOption.StartsWith("-outputfilter:")) //change initial output filter
                    {
                        //break the parameter list down
                        string valueListString=lowerOption.Substring(lowerOption.IndexOf(":")+1);
                        string []values=valueListString.Split(new char[]{','});

                        //turn all off, then only turn on the ones they specified, then refresh it
                        MenuChoice_Output_ChangeFilter(ViewFilterNone, null);

                        foreach (string value in values)
                        {
                            if (value=="debug")        ViewFilterDebug.Checked  =true;
                            else if (value=="info")    ViewFilterInfo.Checked   =true;
                            else if (value=="warn")    ViewFilterWarn.Checked   =true;
                            else if (value=="error")   ViewFilterError.Checked  =true;
                            else if (value=="fatal")   ViewFilterFatal.Checked  =true;
                            else if (value=="success") ViewFilterSuccess.Checked=true;
                            else
                            {
                                //no output is enabled now, so trying to give a text message here is fruitless
                                errors=true;
                            }
                        }

                        MenuChoice_Output_ChangeFilter(null, null);
                    }
                    else if (lowerOption=="help" || lowerOption=="--help" || lowerOption=="-help" || lowerOption=="-?" || lowerOption=="-h") //h[r]elp!
                    {
                        ro.Info("STFGui Commandline Options: STFGui.exe [Module(s).dll] [Options]");
                        ro.Info("Modules are DLL files should contain either test suite(s), or plugin(s).");
                        ro.Info("Options are:");
                        ro.Info(" -LogToFile[:value]                  Turn on or off file logging.  value may be: true or false");
                        ro.Info(" -IgnoreDefaultPlugins               Do not automatically load plugins listed in STFGui.xml");
                        ro.Info(" -OutputFilter:value0[,value1,etc]   Sets the initial output filter.  values may any of: Debug, Info, Warn, Error, Fatal, Success");
                        ro.Info(" -PlugParam:PluginClass:value        Passes a parameter to a specific plugin");
                        // Putting this here, but handled as early as possible in Main.cs
                        ro.Info(" -BreakOnStart                       Breaks into the debugger at startup");
                    }
                    else //woops
                    {
                        ro.Warn("Unknown STFGui commandline parameter: "+option);
                        errors=true;
                    }
                }
                catch (Exception e) //very woops
                {
                    ro.Fatal("Exception handling commandline parameter for STFGui.\nParameter was: "+option+"\nException was: "+e);
                    errors=true;
                }
            }

            return !errors;
        }

        /// <summary>
        /// Limits the output to the given size.  0 disables the limit.
        /// </summary>
        public int OutputLimit
        {
            get { return outputBox.LengthLimit; }
            set
            {
                foreach (MenuItem item in ViewOuputLimit.MenuItems)
                {
                    item.Checked = (value == (int)item.Tag);
                }
                outputBox.LengthLimit = value;
            }
        }

        #region Menu Options and Events

        private void Tabs_Rearranged(TabControl tc)
        {
            StoreUsersTabArrangement();
        }

        private void MenuChoice_File_Exit(object sender, EventArgs args)
        {
            Close();
        }

        private void MenuChoice_File_LoadSuite(object sender, EventArgs args)
        {
            string fname = GuiCommon.ChooseFile(false, "Test Suites or Plugins (*.dll)|*.dll");
            if (fname != null)
            {
                LoadModule(fname);
            }
        }

        private void MenuChoice_MRU_ItemClick(object sender, EventArgs args)
        {
            string fname = ((MenuItem)(sender)).Text;
            if (!String.IsNullOrEmpty(fname))
                LoadModule(fname);
        }

        private void MenuChoice_File_ReloadSuites(object sender, EventArgs args)
        {
            CoreGlobal.CallReloadAllTestTrees();
        }

        private void MenuChoice_File_AttachDebugger(object sender, EventArgs args)
        {
            if (!System.Diagnostics.Debugger.IsAttached)
            {
                System.Diagnostics.Debugger.Launch();
            }
        }

        private void MenuChoice_File_Preferences(object sender, EventArgs e)
        {
            Preferences.ShowPreferences();
        }

        private void MenuChoice_Output_ChangeFilter(object sender, EventArgs args)
        {
            MenuItem mitem=(MenuItem)sender;
            if (mitem==ViewFilterAll)
            {
                ViewFilterDebug.Checked=true;
                ViewFilterInfo.Checked=true;
                ViewFilterWarn.Checked=true;
                ViewFilterError.Checked=true;
                ViewFilterFatal.Checked=true;
                ViewFilterSuccess.Checked=true;
            }
            else if (mitem==ViewFilterNone)
            {
                ViewFilterDebug.Checked=false;
                ViewFilterInfo.Checked=false;
                ViewFilterWarn.Checked=false;
                ViewFilterError.Checked=false;
                ViewFilterFatal.Checked=false;
                ViewFilterSuccess.Checked=false;
            }
            else //individual choice
            {
                if (sender!=null)
                {
                    mitem.Checked=!mitem.Checked;
                }
            }

            //rebuild Report filter
            uint currentFilter=0;
            currentFilter|=(!ViewFilterDebug.Checked?  0:Report.DEBUG);
            currentFilter|=(!ViewFilterInfo.Checked?   0:Report.INFO);
            currentFilter|=(!ViewFilterWarn.Checked?   0:Report.WARN);
            currentFilter|=(!ViewFilterError.Checked?  0:Report.ERROR);
            currentFilter|=(!ViewFilterFatal.Checked?  0:Report.FATAL);
            currentFilter|=(!ViewFilterSuccess.Checked?0:Report.SUCCESS);

            Report.GetRoot().SetLevelFilter(currentFilter);
        }

        private void MenuChoice_Output_ClearOutput(object sender, EventArgs args)
        {
            outputBox.Text="";
        }

        private void MenuChoice_Output_Limit(object sender, EventArgs args)
        {
            MenuItem mi = (MenuItem)sender;
            OutputLimit = (int)mi.Tag;
        }

        private void MenuChoice_Output_LogToFile(object sender, EventArgs args)
        {
            //toggle menu
            bool enabled=!((MenuItem)sender).Checked;

            try
            {
                this.LogToFile = ((MenuItem)sender).Checked = enabled;
            }
            catch (Exception e)
            {
                ro.Error("Exception adding file report destination: " + e);
                ((MenuItem)sender).Checked = false;
            }
        }

        private void Form_Shown(object sender, EventArgs e)
        {
            if (isFirstShown)
            {
                isFirstShown = false;

                XmlNode groupNode = XmlUtil.GetGroupNode(Settings.SelectSingleNode("STFGui"), "BaseGui");

                Width = XmlUtil.GetChildNodeValue(groupNode, "Width", 800);
                Height = XmlUtil.GetChildNodeValue(groupNode, "Height", 600);
                Left = XmlUtil.GetChildNodeValue(groupNode, "LeftPos", 50);
                Top = XmlUtil.GetChildNodeValue(groupNode, "TopPos", 50);
                if (!SystemInformation.VirtualScreen.IntersectsWith(this.Bounds))
                {
                    Left = 50;
                    Top = 50;
                }

                if (XmlUtil.GetChildNodeValue(groupNode, "IsMaxxed", false))
                {
                    WindowState = FormWindowState.Maximized;
                }

                Plugins.NotifyGuiShown();
            }
        }

        //event handler for a requets to close the form
        private void Form_Closing(object sender, FormClosingEventArgs e)
        {
            //if we haven't kicked off the close worker thread, do that.
            if (!isClosing)
            {
                isClosing=true;
                ThreadMaker.CreateThread(ThreadProcShutdown).Start();
            }

            //if we don't want to close yet, cancel it
            if (!allowClose)
            {
                e.Cancel=true;
                return;
            }

            //save our settings
            XmlNode groupNode=Settings.DocumentElement.SelectSingleNode("BaseGui");

            if (Height>50 && Width>50 && WindowState==FormWindowState.Normal) //don't save the form size if the form is max'd or min'd
            {
                XmlUtil.SetChildNodeValue(groupNode, "Width", Width);
                XmlUtil.SetChildNodeValue(groupNode, "Height", Height);
                XmlUtil.SetChildNodeValue(groupNode, "LeftPos", Left);
                XmlUtil.SetChildNodeValue(groupNode, "TopPos", Top);
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", false);
            }
            else if (WindowState==FormWindowState.Maximized)
            {
                XmlUtil.SetChildNodeValue(groupNode, "IsMaxxed", true);
            }

            if (splitTabsAndOutput.Height>50)
            {
                XmlUtil.SetChildNodeValue(groupNode, "SplitterHeight", splitTabsAndOutput.Height); //base bar off the control size not the form size
                XmlUtil.SetChildNodeValue(groupNode, "SplitterBar", (splitTabsAndOutput.SplitterDistance+0.5f)/splitTabsAndOutput.Height);
            }

            StoreUsersTabArrangement();
            if (userPrefferedTabOrder.Count>0)
            {
                XmlNode orderGroupNode=XmlUtil.GetGroupNode(groupNode, "TabOrder");
                orderGroupNode.RemoveAll();
                foreach (string s in userPrefferedTabOrder)
                {
                    XmlNode n=Settings.CreateNode(XmlNodeType.Element, "TabName", "");
                    n.InnerXml=s;
                    orderGroupNode.AppendChild(n);
                }
            }

            if (Tabs.SelectedTab!=null)
            {
                XmlUtil.SetChildNodeValue(groupNode, "OpenTab", Tabs.SelectedTab.Text);
            }

            XmlUtil.SetChildNodeValue(groupNode, "OutputLogToFile", fileOutputDest!=null);

            XmlUtil.SetChildNodeValue(groupNode, "MRUFileList", MRUFileList.GetCSVString());

            try
            {
                Settings.Save("STFGui.xml");
            }
            catch (System.Exception exception)
            {
                ro.Fatal("Exception trying to save STFGui.xml:\n"+exception);
            }
        }

        #endregion //Menu Options and Events

        //This handles shutting down all the gui components on it's own thread.  We won't actually close until it says to.
        private void ThreadProcShutdown()
        {
            //shut down plugin handler
            Plugins.NotifyGuiClosing();

            //destroy all our nodes
            foreach (TestNode n in SuiteRoots)
            {
                try
                {
                    n.Dispose();
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception trying to dispose TestNode "+n.FullName+": "+e);
                }
            }

            //now it's ok to close
            allowClose=true;
            this.Invoke(new InvokeCode(delegate
            {
                //remove our output box from outputs
                Report.GetRoot().RemoveReportDestination(outputBox);
                outputBox.IgnoreOutput=true;
                outputBox.Hide();
                outputBox.Dispose();

                //now poof us
                Close();
            }));
        }

        //Rebuilds the title bar text
        private void UpdateTitlebarText()
        {
            Text="STFGui";
            if (titlebarAssemblyNames.Count>0)
            {
                Text+=" - ";
                bool first=true;
                foreach (string asmName in titlebarAssemblyNames)
                {
                    if (!first)
                    {
                        Text+=", ";
                    }
                    Text+=asmName;
                    first=false;
                }
            }
        }

        /// <summary>
        /// Loads tests and plugins from a file that contains an assembly (usually .dll)
        /// Returns true only if something was loaded and everything in the assembly was loaded successfully, or if that assembly was already loaded.
        /// </summary>
        public bool LoadModule(string fname)
        {
            try
            {
                MRUFileList.AddItem(fname);
            }
            catch (Exception ex)
            {
                ro.Warn("Exception while trying to add an item to the recently used file list. Does not block functionality but probably a bug.");
                ro.Warn(ex.Message);
            }

            //load the assembly
            bool ok=true;
            bool loadedAnything=false;
            Assembly asm;
            try
            {
                asm=AssemblyUtils.LoadAssemblyUsingDefaultMethod(fname);

                //if it's already loaded, don't load it again
                foreach (string loadedName in LoadedModules)
                {
                    if (asm.FullName==loadedName)
                    {
                        ro.Debug(fname+" is already loaded.");
                        return true;
                    }
                }

                ro.Debug("Opened "+fname+" version "+asm.GetName().Version);
            }
            catch (Exception e)
            {
                ro.Fatal("Exception loading assembly "+fname+": "+e);
                return false;
            }

            //notify that we are about to load it
            Plugins.NotifyModuleLoading(fname);

            //load tests from it
            try
            {
                TestNode suite=TestNode.GenerateNodeTree(fname);
                if (suite.ChildrenCount==0)
                {
                    ro.Info("No TestNodes found in: "+fname);
                }
                else
                {
                    loadedAnything=true;
                    ro.Debug("TestNodes loaded successfully from: "+fname);

                    titlebarAssemblyNames.Add(asm.GetName().Name); //add to list to show in title bar
                    UpdateTitlebarText();
                }
            }
            catch (Exception e)
            {
                ro.Fatal("Exception trying to load nodes from "+fname+": "+e);
                ok=false;
            }

            //load plugins from it
            try
            {
                bool foundPlugs=Plugins.LoadAllPluginsInAssembly(asm);
                loadedAnything=loadedAnything||foundPlugs;
            }
            catch (Exception e)
            {
                ro.Fatal("Exception trying to load plugins from "+fname+": "+e);
                ok=false;
            }

            RearrangeTabsForUser();

            //
            LoadedModules.AddLast(asm.FullName);
            LoadedModuleFiles.AddLast(fname);
            return ok && loadedAnything;
        }

        private void SuiteLoaded(TestNode root)
        {
            SuiteRoots.AddLast(root);
            Plugins.NotifySuiteLoaded(root);
        }

        private void SuiteUnloaded(TestNode root)
        {
            SuiteRoots.Remove(root);
            Plugins.NotifySuiteUnloading(root);
        }

        private void ReloadSuites()
        {
            //unload old
            ro.Debug("Unloading suites...");
            while (SuiteRoots.Count!=0)
            {
                CoreGlobal.CallTestNodeTreeUnload(SuiteRoots.Last.Value);
            }

            //search all modules for nodes again
            ro.Debug("Reloading suites...");
            foreach (string fname in LoadedModuleFiles)
            {
                try
                {
                    TestNode suite=TestNode.GenerateNodeTree(fname);
                    if (suite.ChildrenCount==0)
                    {
                        ro.Info("No TestNode(s) found in: "+fname);
                    }
                    else
                    {
                        ro.Debug("TestNodes loaded successfully from: "+fname);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception trying to load nodes from "+fname+": "+e);
                }
            }
        }

        //rearranges the tabs to match the user's preferance
        private void RearrangeTabsForUser()
        {
            //current
            TabPage curTab=Tabs.SelectedTab;
            LinkedList<TabPage> currentPages=new LinkedList<TabPage>();
            foreach (TabPage p in Tabs.TabPages)
            {
                currentPages.AddLast(p);
            }

            //wipe old and rebuild as they like
            Tabs.TabPages.Clear();
            foreach (string s in userPrefferedTabOrder)
            {
                foreach (TabPage p in currentPages)
                {
                    if (p.Text==s)
                    {
                        Tabs.TabPages.Add(p);
                        currentPages.Remove(p);
                        break;
                    }
                }
            }

            //add extras to end
            foreach (TabPage p in currentPages)
            {
                Tabs.TabPages.Add(p);
            }

            Tabs.SelectedTab=curTab;
        }

        //saves the current tab arrangement as the users's preferance
        private void StoreUsersTabArrangement()
        {
            userPrefferedTabOrder.Clear();
            foreach (TabPage p in Tabs.TabPages)
            {
                userPrefferedTabOrder.Add(p.Text);
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\LiveEnvironment\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\LiveEnvironment\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\LiveEnvironment\Environment.cs ===
using System;
using System.Threading;
using System.Windows.Forms;
using System.Drawing;
using System.Xml;
using System.Data.SqlClient;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Database;

namespace STFGui.Plugins
{
    public partial class EnvironmentPlugin: IPluginSetup, IPluginGui
    {
        // -- public stuff

        public string CurrentEnvironment="";

        /// <summary>
        /// Changes the environment chooser into "button mode" instead of "combobox mode".
        /// </summary>
        public void EnableButtonMode()
        {
            envCombo.Visible=false;
            foreach (Button b in envButtons.Values)
            {
                b.Visible=true;
            }
        }

        //these events are triggered when the environment is about to be changed and after it has been changed
        public event EnvironmentChangedDelegate EnvironmentChangeBeginEvent;
        public event EnvironmentChangedDelegate EnvironmentChangeFinishEvent;
        public delegate void EnvironmentChangedDelegate(string newEnvironmentName);

        // -- internals

        private static readonly String EnvListEditOption = "Edit...";
        private static readonly String EnvListNoneOption = "None";

        static Report ro=new Report("EnvPlugin");

        public Panel PanelEnvList;
        public Panel PanelTabList;
        public TabControl Tabs;
        Label curEnvText;
        TextBox curEnvIpText;
        Button refreshButton;

        Dictionary<string,Button> envButtons=new Dictionary<string,Button>();
        ComboBox envCombo;

        Thread resetThread=null;
        Thread refreshThread=null;
        Object refreshLockObj = new Object();
        XmlNode settings;

        public delegate void InvokeCode();

        //Returns the TabPage to add to the gui.
        public System.Windows.Forms.TabPage GetNewTabPage()
        {
            System.Windows.Forms.TabPage page=new System.Windows.Forms.TabPage();
            page.Text="Environment";

            //add a splitter to it, to divide the controls from the node tree
            SplitContainer splitEnvAndTabs=new SplitContainer();
            splitEnvAndTabs.Orientation=Orientation.Vertical;
            splitEnvAndTabs.Dock=DockStyle.Fill;
            splitEnvAndTabs.Location=new System.Drawing.Point(0, 0);
            splitEnvAndTabs.Size=new System.Drawing.Size(3000, 3000);
            splitEnvAndTabs.Panel1MinSize=105;
            splitEnvAndTabs.SplitterDistance=105;
            splitEnvAndTabs.IsSplitterFixed=true;
            page.Controls.Add(splitEnvAndTabs);

            PanelEnvList=splitEnvAndTabs.Panel1;
            PanelTabList=splitEnvAndTabs.Panel2;

            // -- setup env list
            int offset = 5;

            //add current environment text
            curEnvText=new Label();
            curEnvText.Text="Current: "+CurrentEnvironment;
            curEnvText.Location = new System.Drawing.Point(0, offset);
            curEnvText.Size=new System.Drawing.Size(350, 20);
            PanelEnvList.Controls.Add(curEnvText);

            offset += 20;
            Label curEnvIpLbl = new Label();
            curEnvIpLbl.Text = "IP:";
            curEnvIpLbl.Location = new System.Drawing.Point(0, offset);
            curEnvIpLbl.Size = new System.Drawing.Size(20, 20);
            PanelEnvList.Controls.Add(curEnvIpLbl);

            curEnvIpText = new TextBox();
            curEnvIpText.Text = (Global.CurrentEnvironment!=null?Global.CurrentEnvironment.NpdbIp:"?");
            curEnvIpText.Location = new System.Drawing.Point(18, offset - 2);
            curEnvIpText.Size = new System.Drawing.Size(85, 20);
            curEnvIpText.BorderStyle = BorderStyle.FixedSingle;
            curEnvIpText.LostFocus += EnvIpChange;
            curEnvIpText.KeyPress += EnvIpKeyPress;
            PanelEnvList.Controls.Add(curEnvIpText);
            curEnvIpText.BringToFront();

            //add env buttons and combo box
            offset += 20;
            envCombo=new ComboBox();
            envCombo.Location = new System.Drawing.Point(2, offset);
            envCombo.Size=new System.Drawing.Size(100, 22);
            envCombo.DropDownStyle=ComboBoxStyle.DropDownList;
            envCombo.DropDownHeight*=2;
            PanelEnvList.Controls.Add(envCombo);

            foreach (EnvironmentSetting npdbSetting in Global.EnvironmentList)
            {
                string name = npdbSetting.Environment;

                if (envButtons.ContainsKey(name))
                {
                    ro.Warn("Duplicate environment name: " + name);
                    continue;
                }

                Button but=new Button();
                but.Text=name;
                but.Location=new System.Drawing.Point(9, offset);
                but.Size=new System.Drawing.Size(83, 22);
                but.Click+=EnvButtonClick;
                PanelEnvList.Controls.Add(but);
                envButtons.Add(but.Text, but);
                but.Visible=false;

                envCombo.Items.Add(but.Text);

                offset+=24;
            }

            // add a special option
            envCombo.Items.Add(EnvListEditOption);

            int comboSelInd=envCombo.FindStringExact(CurrentEnvironment);
            if (comboSelInd==-1)
            {
                comboSelInd=envCombo.FindStringExact(EnvListNoneOption);
            }
            if (comboSelInd==-1)
            {
                comboSelInd=0;
            }
            envCombo.SelectedIndex=comboSelInd;
            envCombo.SelectedIndexChanged+=EnvComboChange;

            //refresh button
            refreshButton=new Button();
            refreshButton.Text="Populate Info Pages";
            refreshButton.Location=new System.Drawing.Point(0, 0);
            refreshButton.Size=new System.Drawing.Size(100, 35);
            refreshButton.Dock=DockStyle.Bottom;
            refreshButton.Click+=RefreshButton_Click;
            int refreshBgG=(int)refreshButton.BackColor.G+10;
            if (refreshBgG>255) refreshBgG=255;
            int refreshBgB=(int)refreshButton.BackColor.B+25;
            if (refreshBgB>255) refreshBgB=255;
            refreshButton.BackColor=Color.FromArgb(255, refreshButton.BackColor.R, refreshBgG, refreshBgB);

            PanelEnvList.Controls.Add(refreshButton);

            // -- setup info tabs

            Tabs=new TabControl();
            Tabs.Dock=DockStyle.Fill;
            PanelTabList.Controls.Add(Tabs);
            Tabs.Alignment=TabAlignment.Left;

            Tabs.TabPages.Add(MakeServerBrowserTabPage());
            Tabs.TabPages.Add(MakeSettingsBrowserTabPage());
            Tabs.TabPages.Add(MakeUODBTabPage());

            //select the last used tab if possible
            string initialTabName=XmlUtil.GetChildNodeValue(settings, "LastInfoTab","Servers");
            foreach (TabPage tp in Tabs.TabPages)
            {
                if (tp.Text==initialTabName)
                {
                    Tabs.SelectTab(tp);
                    break;
                }
            }

            //
            return page;
        }

        //Called to init
        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            //ro.Debug("STFLive is version "+Global.GetLiveAssembly().GetName().Version); //TODO: Get this back in the new world sometime.

            //check our commandline params for anything interesting
            CurrentEnvironment=null;
            foreach (string s in commandlineParameters)
            {
                if (s.ToLower().StartsWith("env:") && s.Length>=5) //set environment
                {
                    CurrentEnvironment=s.Substring(s.IndexOf(':')+1);
                }
                else if (s.ToLower()=="help")
                {
                    ro.Info("Environment Plugin parameters:");
                    ro.Info("  env:Name      Set the environment to Name.");
                }
                else
                {
                    ro.Error("Bad parameter passed to Environment plugin: "+s);
                }
            }

            //load plugin configuration
            settings=pluginSettings;
            if (CurrentEnvironment==null)
            {
                CurrentEnvironment=XmlUtil.GetChildNodeValue(pluginSettings, "LastEnvironment", EnvListNoneOption);
            }

            //load the base stflive config
            StfXmlDoc liveConfig=new StfXmlDoc();
            try
            {
                liveConfig.Load(Global.DefaultConfigFile);
            }
            catch(Exception) //the file is optional, swallow it
            {
            }

            //merge in any xmls from the commandline, and init it
            //TODO: This really should be using commandlines passed to the plugin... NOT directly trying to ingest the commandline itself...
            string []cmdParams=System.Environment.CommandLine.Split(new char[]{' '});
            foreach (string param in cmdParams)
            {
                if (param.ToLower().EndsWith(".xml"))
                {
                    ro.Debug("STFLive plugin handling paramater: "+param);
                    try
                    {
                        liveConfig.Merge(new StfXmlDoc(param), "/stf");
                    }
                    catch (Exception e)
                    {
                        ro.Warn("Failed to merge xml config file into STFLive's config: "+param+": "+e);
                    }
                }
            }

            CoreGlobal.Initialize(liveConfig);

            //kick off the environment reset in the background
            ResetEnvironment();
        }

        //Called when we're being shut down
        public void Shutdown(XmlNode pluginSettings)
        {
            //save plugin configuration
            XmlUtil.SetChildNodeValue(pluginSettings, "LastEnvironment", CurrentEnvironment);

            Tabs.Invoke(new InvokeCode(delegate
            {
                if (Tabs.SelectedTab!=null)
                {
                    XmlUtil.SetChildNodeValue(pluginSettings, "LastInfoTab", Tabs.SelectedTab.Text);
                }
            }));

            CurrentEnvironment=null;
            ThreadMaker.CreateThread(ResetEnvironment).Start(); //lets not block on it
        }

        //get the "name" of the current environment as npdb sees it
        public string GetCurrentEnvironmentName()
        {
            return Global.XEnv.GetEnv().ToLower();
        }

        // --

        //resets the environment, or if current is null, just stops and resets.
        private void ResetEnvironment()
        {
            if (resetThread!=null)
            {
                resetThread.Abort();
            }

            // Stop the refresh as it will restart when 
            // the environment setup is completed again
            if (refreshThread != null)
            {
                lock (refreshLockObj)
                {
                    if (refreshThread != null)
                    {
                        refreshThread.Abort();
                        refreshThread = null;
                    }
                }
            }

            if (CurrentEnvironment!=null)
            {
                resetThread=ThreadMaker.CreateThread(ThreadProcSetupEnvironment);
                resetThread.IsBackground=true;
                resetThread.Start();
            }
        }

        private void RefreshInfoPages()
        {
            lock (refreshLockObj)
            {
                // Kill the thread if it's running
                if (refreshThread != null)
                {
                    refreshThread.Abort();
                    refreshThread = null;
                }

                if (CurrentEnvironment != EnvListNoneOption)
                {
                    refreshThread = ThreadMaker.CreateThread(() =>
                    {
                        try
                        {
                            RefreshServers();
                            RefreshSettings();
                            RefreshUODB();
                        }
                        catch (ThreadAbortException)
                        {
                            Thread.ResetAbort();
                        }
                        finally
                        {
                            InvokeChangeText(refreshButton, "Populate Info Pages");
                        }
                    });

                    InvokeChangeText(refreshButton, "Populating...");
                    refreshThread.IsBackground = true;
                    refreshThread.Start();
                }
            }
        }

        private static void InvokeChangeText (Control lbl, string text)
        {
            if (lbl != null && lbl.IsHandleCreated)
            {
                lbl.Invoke(new InvokeCode(delegate
                {
                    lbl.Text = text;
                }));
            }
        }

        private void ThreadProcSetupEnvironment()
        {
            InvokeChangeText(curEnvText, "Current: ...");
            InvokeChangeText(curEnvIpText, "...");

            //if none is chosen, set it to the first in the list
            if (CurrentEnvironment.Length==0)
            {
                if (Global.EnvironmentList.Count==0)
                {
                    ro.Fatal("No valid STFLive environments in config (missing stf.xml?).");
                    return;
                }

                foreach (EnvironmentSetting envCheck in Global.EnvironmentList)
                {
                    CurrentEnvironment=envCheck.Environment;
                    break;
                }
            }

            //look for the environment from the list stflive exposes to us and choose it
            string envName=CurrentEnvironment.ToLower();
            bool found=false;
            foreach (EnvironmentSetting envCheck in Global.EnvironmentList)
            {
                if (envCheck.Environment.ToLower()==envName)
                {
                    Global.CurrentEnvironment=envCheck;
                    found=true;
                    break;
                }
            }

            if (!found)
            {
                ro.Fatal("Requested environment '"+CurrentEnvironment+"' is not in STFLive's config (stf.xml).");
                return;
            }

            //trigger the change begin event
            try
            {
                if (EnvironmentChangeBeginEvent!=null)
                {
                    EnvironmentChangeBeginEvent(CurrentEnvironment);
                }
            }
            catch (Exception e)
            {
                ro.Error("Exception calling begin reset environment event: "+e);
            }

            //now tell STFLive to reset it's environment
            Global.ResetEnvironment(true);
            ro.Info("Environment reset to "+CurrentEnvironment+".");

            InvokeChangeText(curEnvText, "Current: " + CurrentEnvironment);
            InvokeChangeText(curEnvIpText, Global.CurrentEnvironment.NpdbIp);

            // Start the environment info population
            RefreshInfoPages();

            //trigger the change end event
            try
            {
                if (EnvironmentChangeFinishEvent!=null)
                {
                    EnvironmentChangeFinishEvent(CurrentEnvironment);
                }
            }
            catch (Exception e)
            {
                ro.Error("Exception calling finish reset environment event: "+e);
            }

            resetThread=null;
        }

        #region Gui Events

        public void EnvButtonClick(object sender, EventArgs e)
        {
            Button but=(Button)sender;

            PanelServerInterfacesServers.Enabled=false;
            TreeInterfaces.Nodes.Clear();
            TreeServers.Nodes.Clear();
            ResetUodbTab();

            ClearSettingsInfo();

            CurrentEnvironment=but.Text;
            ResetEnvironment();
        }

        public void EnvComboChange(object sender, EventArgs e)
        {
            if (envCombo.SelectedIndex==-1)
            {
                return;
            }

            string newEnv=(string)envCombo.Items[envCombo.SelectedIndex];

            if (newEnv == EnvListEditOption)
            {
                System.Diagnostics.Process.Start("notepad", @".\stf.xml");
            }
            else if (newEnv!=CurrentEnvironment)
            {
                EnvButtonClick(envButtons[newEnv], e);
            }
        }

        public void EnvIpChange (object sender, EventArgs e)
        {
            string newIp = curEnvIpText.Text.Trim();

            if (newIp == Global.CurrentEnvironment.NpdbIp)
            {
                return;
            }

            Global.CurrentEnvironment.NpdbIp = newIp;
            // force the update via property
            Global.CurrentEnvironment = Global.CurrentEnvironment;

            ResetEnvironment();
        }

        public void EnvIpKeyPress (object sender, EventArgs e)
        {
            KeyPressEventArgs kpea = (KeyPressEventArgs)e;

            if (kpea.KeyChar == '\r')
            {
                kpea.Handled = true;
                EnvIpChange(null, null);
            }
        }

        private void RefreshButton_Click(Object sender, EventArgs args)
        {
            RefreshInfoPages();
        }

        #endregion

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public System.Windows.Forms.MenuItem GetNewMenu ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\RegDB\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\RegDB\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\LiveEnvironment\ServerBrowser.cs ===
using System;
using System.Threading;
using System.Windows.Forms;
using System.Drawing;
using System.Xml;
using System.Data.SqlClient;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Database;

namespace STFGui.Plugins
{
    public partial class EnvironmentPlugin : IPluginSetup, IPluginGui
    {
        public TreeView TreeInterfaces;
        public TreeView TreeServers;
        public Panel PanelServerInfo;
        public Panel PanelServerInterfacesServers;
        public TextBox TextServerInfo;

        public TextBox XmgmtCommandTextBox;
        public CheckBox XmgmtAllServersCheckBox;

        //private CheckBox filterEmptyInterfacesCheckbox;

        //gets the tab page for the server browser
        TabPage MakeServerBrowserTabPage()
        {
            TabPage tabServers=new TabPage();
            tabServers.Text="Servers";
            tabServers.Size=new System.Drawing.Size(1000, 1000);

            //make a splitter between the lists and the info
            SplitContainer splitServersAndInfo=new SplitContainer();
            splitServersAndInfo.Orientation=Orientation.Vertical;
            splitServersAndInfo.Dock=DockStyle.Fill;
            splitServersAndInfo.Location=new System.Drawing.Point(0, 0);
            splitServersAndInfo.Size=new System.Drawing.Size(5000, 3000);
            splitServersAndInfo.Panel2MinSize=100;
            splitServersAndInfo.SplitterDistance=2500;
            tabServers.Controls.Add(splitServersAndInfo);

            PanelServerInfo=splitServersAndInfo.Panel2;
            PanelServerInterfacesServers=splitServersAndInfo.Panel1;
            PanelServerInterfacesServers.Enabled=false;

            // Make the info box
            TextServerInfo = new TextBox
            {
                Dock = DockStyle.Fill,
                ReadOnly = true,
                Multiline = true,
                ScrollBars = ScrollBars.Both,
                WordWrap = false,
            };

            PanelServerInfo.Controls.Add(TextServerInfo);

            // And the Xmgmt Command Area
            GroupBox xmgmtGroupBox = new GroupBox
            {
                Text = "XManagement",
                Dock = DockStyle.Bottom,
                Height = 60,
                Padding = new Padding(3),
            };


            XmgmtAllServersCheckBox = new CheckBox
            {
                Dock = DockStyle.Bottom,
                Margin = new Padding(3),
                Text = "Run command on all servers"
            };
            xmgmtGroupBox.Controls.Add(XmgmtAllServersCheckBox);

            XmgmtCommandTextBox = new TextBox
            {
                Dock = DockStyle.Bottom,
                Multiline = false,
                ScrollBars = ScrollBars.None,
                Margin = new Padding(3),
            };
            XmgmtCommandTextBox.KeyDown += new KeyEventHandler(XmgmtCommandTextBox_KeyDown);
            xmgmtGroupBox.Controls.Add(XmgmtCommandTextBox);


            PanelServerInfo.Controls.Add(xmgmtGroupBox);
            //PanelServerInfo.Controls.Add(XmgmtCommandTextBox);
            

            //splitter between interfaces and servers
            SplitContainer splitInerfaceAndServerName=new SplitContainer();
            splitInerfaceAndServerName.Orientation=Orientation.Vertical;
            splitInerfaceAndServerName.Dock=DockStyle.Fill;
            splitInerfaceAndServerName.Location=new System.Drawing.Point(0, 0);
            splitInerfaceAndServerName.Size=new System.Drawing.Size(3000, 3000);
            splitInerfaceAndServerName.SplitterDistance=1500;
            PanelServerInterfacesServers.Controls.Add(splitInerfaceAndServerName);

            //interfaces
            TreeInterfaces=new TreeView();
            TreeInterfaces.Dock=DockStyle.Fill;
            TreeInterfaces.ShowLines=false;
            TreeInterfaces.ShowPlusMinus=false;
            TreeInterfaces.HideSelection=false;
            TreeInterfaces.AfterSelect+=TreeInterfaces_AfterSelect;

            splitInerfaceAndServerName.Panel1.Controls.Add(TreeInterfaces);

            //filterEmptyInterfacesCheckbox = new CheckBox
            //{
            //    Dock = DockStyle.Bottom,
            //    Text = "Filter Empty Interfaces",
            //};
            //filterEmptyInterfacesCheckbox.CheckedChanged += new EventHandler(filterEmptyInterfacesCheckbox_CheckedChanged);

            //splitInerfaceAndServerName.Panel1.Controls.Add(filterEmptyInterfacesCheckbox);

            //servers
            TreeServers=new TreeView();
            TreeServers.Dock=DockStyle.Fill;
            TreeServers.ShowLines=false;
            TreeServers.ShowPlusMinus=false;
            TreeServers.HideSelection=false;
            TreeServers.AfterSelect+=TreeServers_AfterSelect;
            TreeServers.ContextMenu = new ContextMenu();
            TreeServers.ContextMenu.MenuItems.Add(new MenuItem("Open &Event Viewer", this.TreeServers_OpenEventViewerClick, Shortcut.CtrlShiftE));
            TreeServers.ContextMenu.MenuItems.Add(new MenuItem("Open &LogRoot", this.TreeServers_OpenLogRootClick, Shortcut.CtrlShiftL));
            TreeServers.ContextMenu.MenuItems.Add(new MenuItem("Open &HealthCheck", this.TreeServers_OpenHealthcheckClick, Shortcut.CtrlShiftH));
            TreeServers.ContextMenu.MenuItems.Add(new MenuItem("Connect to Machine", this.TreeServers_ConnectToMachineClick, Shortcut.CtrlShiftR));

            splitInerfaceAndServerName.Panel2.Controls.Add(TreeServers);

            Button openEventViewerButton = new Button
            {
                Dock = DockStyle.Bottom,
                Text = "Open Event Viewer",
            };
            openEventViewerButton.Click += this.TreeServers_OpenEventViewerClick;

            Button openLogRootButton = new Button
            {
                Dock = DockStyle.Bottom,
                Text = "Open Log Root",
            };
            openLogRootButton.Click += this.TreeServers_OpenLogRootClick;

            Button openHealthcheckButton = new Button
            {
                Dock = DockStyle.Bottom,
                Text = "View Healthcheck",
            };
            openHealthcheckButton.Click += this.TreeServers_OpenHealthcheckClick;

            Button connectToMachineButton = new Button
            {
                Dock = DockStyle.Bottom,
                Text = "Connect with Remote Desktop",
            };
            connectToMachineButton.Click += this.TreeServers_ConnectToMachineClick;

            splitInerfaceAndServerName.Panel2.Controls.Add(openEventViewerButton);
            splitInerfaceAndServerName.Panel2.Controls.Add(openLogRootButton);
            splitInerfaceAndServerName.Panel2.Controls.Add(openHealthcheckButton);
            splitInerfaceAndServerName.Panel2.Controls.Add(connectToMachineButton);

            //
            return tabServers;
        }

        //rebuilds the server/interface info panel
        private void UpdateServerInfo()
        {
            TextServerInfo.Text="";

            if (TreeInterfaces.SelectedNode==null)
            {
                return;
            }

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();

            //interface info
            try
            {
                string interfaceName=(string)TreeInterfaces.SelectedNode.Tag;
                TextServerInfo.Text+="----- Interface: "+interfaceName+" -----\r\n";

                //get a list of all sites
                List<int> listSites=new List<int>();
                SqlDataReader reader;
                npdb.ReadData("select distinct i_site_id from t_sites where vc_environment='"+GetCurrentEnvironmentName()+"'", out reader);
                while (reader.Read())
                {
                    listSites.Add((int)reader[0]);
                }
                reader.Close();

                //get the virtual interface name that maps to the interface
                bool anyVipFound=false;
                object ret=npdb.ExecuteScalar("select vc_virtual_interface from t_virtual_interfaces where vc_interface='"+interfaceName+"'");
                if (ret!=null)
                {
                    string vipName=(string)ret;

                    //search all sites for that vip and spit out info
                    foreach (int siteID in listSites)
                    {
                        //vip
                        npdb.ReadData("exec p_config_get_virtual_interface '"+GetCurrentEnvironmentName()+"', "+siteID+", '"+vipName+"'", out reader);
                        while (reader.Read())
                        {
                            anyVipFound=true;

                            TextServerInfo.Text+="VIP site "+siteID+":";
                            TextServerInfo.Text+="  ip="+reader[3];
                            TextServerInfo.Text+="  port="+reader[4];
                            if (reader[5]!=System.DBNull.Value) TextServerInfo.Text+="-"+reader[5];
                            if (reader[15]!=System.DBNull.Value)
                            {
                                TextServerInfo.Text+="  internet_port="+reader[15];
                                if (reader[16]!=System.DBNull.Value) TextServerInfo.Text+="-"+reader[16];
                            }
                            TextServerInfo.Text+="  protocol="+reader[2];
                            TextServerInfo.Text+="\r\n";
                        }
                        reader.Close();

                        //vip override
                        npdb.ReadData("exec p_config_get_site_virtual_interface_overrides '"+GetCurrentEnvironmentName()+"', "+siteID+", '"+vipName+"'", out reader);
                        while (reader.Read())
                        {
                            anyVipFound=true;

                            TextServerInfo.Text+="VIP site "+siteID+" override:";
                            TextServerInfo.Text+="  port="+reader[0];
                            TextServerInfo.Text+="\r\n";
                        }
                        reader.Close();
                    }
                }

                if (!anyVipFound)
                {
                    TextServerInfo.Text+="No VIP\r\n";
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception getting interface info: "+e);
            }

            //server info
            if (TreeServers.SelectedNode==null)
            {
                npdb.Close();
                return;
            }

            try
            {
                string serverName=(string)TreeServers.SelectedNode.Tag;
                TextServerInfo.Text+="\r\n----- Server: "+serverName+" -----\r\n";

                //state
                SqlDataReader reader;
                npdb.ReadData("select vc_server_state from t_servers where vc_environment='"+GetCurrentEnvironmentName()+"' and vc_server='"+serverName+"'", out reader);
                while (reader.Read())
                {
                    TextServerInfo.Text+="State:  "+reader[0];
                    TextServerInfo.Text+="\r\n";
                }
                reader.Close();

                //nics
                npdb.ReadData("select vc_ip,vc_nic_role,vc_ip_default_gateway from t_server_nics where vc_environment='"+GetCurrentEnvironmentName()+"' and vc_server='"+serverName+"'", out reader);
                while (reader.Read())
                {
                    TextServerInfo.Text+="NIC:  ip="+reader[0];
                    TextServerInfo.Text+="  role="+reader[1];
                    if (reader[2] is string)
                    {
                        TextServerInfo.Text+="  gateway="+(string)reader[2];
                    }
                    TextServerInfo.Text+="\r\n";
                }
                reader.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception getting server info: "+e);
            }

            npdb.Close();
        }

        #region Events

        public void RefreshServers()
        {
            if (PanelServerInterfacesServers.InvokeRequired)
            {
                PanelServerInterfacesServers.Invoke((InvokeCode)RefreshServers);
            }
            else
            {
                //wipe old
                try
                {
                    // Stop updating the trees
                    TreeInterfaces.SuspendLayout();
                    TreeServers.SuspendLayout();

                    // Clear them out
                    TreeInterfaces.Nodes.Clear();
                    TreeServers.Nodes.Clear();

                    PanelServerInterfacesServers.Enabled = true;

                    try
                    {
                        Npdb npdb = new Npdb();
                        npdb.ConnectToServer();

                        // Retrieve all interfaces and load them into the tree
                        SqlDataReader reader;
                        npdb.ReadData("select vc_interface from t_interfaces", out reader);
                        while (reader.Read())
                        {
                            TreeNode n = new TreeNode();
                            n.Text = (string)reader[0];
                            n.Tag = (string)reader[0];

                            AddInterfaceNode(n);
                        }

                        reader.Close();
                        npdb.Close();
                    }
                    catch (Exception e)
                    {
                        Global.RO.Error("Exception updating interfaces: " + e);
                    }

                    // This is used to ensure that the Server Info Pane is cleared out
                    UpdateServerInfo();
                }
                finally
                {
                    // Resume updating
                    TreeInterfaces.ResumeLayout();
                    TreeServers.ResumeLayout();
                }
            }
        }

        public void AddInterfaceNode(TreeNode node)
        {
            if (TreeInterfaces.InvokeRequired)
            {
                TreeInterfaces.Invoke(new Action<TreeNode>(AddInterfaceNode), node);
            }
            else
            {
                TreeInterfaces.Nodes.Add(node);
            }
        }

        private void TreeInterfaces_AfterSelect(object sender, TreeViewEventArgs tvea)
        {
            //wipe old
            TreeServers.Nodes.Clear();

            if (TreeInterfaces.SelectedNode!=null)
            {
                string interfaceName=(string)TreeInterfaces.SelectedNode.Tag;

                try
                {
                    Npdb npdb=new Npdb();
                    npdb.ConnectToServer();

                    //retrieve all servers
                    string uberQuery = String.Format(
                        @"select s.vc_server, s.vc_server_state
                            from t_servers s
                            inner join t_server_interfaces sti 
                                on s.vc_server = sti.vc_server 
                                and s.vc_environment = sti.vc_environment
                            inner join t_interfaces as i
                                on sti.vc_interface = i.vc_interface
                            inner join t_server_nics nic
                                on nic.vc_nic_role = i.vc_nic_role 
                                and nic.vc_environment = s.vc_environment 
                                and nic.vc_server = s.vc_server
                            where s.vc_environment = '{0}' and sti.vc_interface = '{1}'
                            order by s.vc_server",
                            GetCurrentEnvironmentName(), interfaceName);

                    SqlDataReader reader;
                    npdb.ReadData(uberQuery, out reader);
                    while (reader.Read())
                    {
                        //set us up the node
                        TreeNode n=new TreeNode();
                        n.Text=(string)reader[0];
                        n.Tag=(string)reader[0];

                        //add online/offline signifiers
                        bool online=(string)reader[1] == "online";
                        n.ForeColor=(online?Color.Green:Color.Red);
                        n.Text+=" ("+(string)reader[1]+")";

                        //
                        TreeServers.Nodes.Add(n);
                    }

                    reader.Close();
                    npdb.Close();
                }
                catch (Exception e)
                {
                    Global.RO.Error("Exception updating servers: "+e);
                }
            }

            UpdateServerInfo();
        }

        private void TreeServers_AfterSelect(object sender, TreeViewEventArgs tvea)
        {
            UpdateServerInfo();
        }

        private void TreeServers_OpenEventViewerClick(object sender, EventArgs e)
        {
            TreeNode selectedServer = TreeServers.SelectedNode;

            if (selectedServer == null)
            {
                return;
            }

            String server = (String)selectedServer.Tag;

            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo = new System.Diagnostics.ProcessStartInfo("eventvwr.exe", server);
            p.Start();
        }

        private void TreeServers_OpenLogRootClick(object sender, EventArgs e)
        {
            TreeNode selectedServer = TreeServers.SelectedNode;

            if (selectedServer == null)
            {
                return;
            }

            String server = (String)selectedServer.Tag;
            String logRootPath = Global.XEnv.GetSetting("setup_logroot").Trim();

            // If there's a colon, we need to create a network path
            if (logRootPath[1] == ':')
            {
                char driveLetter = logRootPath[0];
                String relativePath = logRootPath.Substring(3);
                logRootPath = String.Format(@"\\{0}\{1}$\{2}\", server, driveLetter, relativePath);
            }

            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo = new System.Diagnostics.ProcessStartInfo("explorer.exe", logRootPath);
            p.Start();
        }

        private void TreeServers_OpenHealthcheckClick(object sender, EventArgs e)
        {
            TreeNode selectedServer = TreeServers.SelectedNode;
            TreeNode selectedInterface = TreeInterfaces.SelectedNode;

            if (selectedInterface == null || selectedServer == null)
            {
                return;
            }

            String server = (String)selectedServer.Tag;
            String component = (String)selectedInterface.Tag;
            // Some components end in _int to indicate the internal interfaces
            // and we want to handle these properly so just trim it if it exists
            if (component.EndsWith("_int"))
            {
                component = component.Remove(component.Length - 4);
            }

            using (NpdbHealthchecks npdb = new NpdbHealthchecks())
            {
                npdb.ConnectToServer();

                List<String> healthchecks = npdb.GetServerHealthchecks(server, component);
                if (healthchecks.Count > 0)
                {
                    ro.Info("Opening {0} healthcheck on {1}: {2}", component, server, healthchecks[0]);
                    System.Diagnostics.Process p = new System.Diagnostics.Process();
                    p.StartInfo = new System.Diagnostics.ProcessStartInfo("iexplore.exe", healthchecks[0]);
                    p.Start();
                }
                else
                {
                    ro.Warn("Unable to find any healthcheck URLs for {0} on {1}", component, server);
                }
            }
        }

        private void TreeServers_ConnectToMachineClick(object sender, EventArgs e)
        {
            TreeNode selectedServer = TreeServers.SelectedNode;

            if (selectedServer == null)
            {
                return;
            }

            String server = (String)selectedServer.Tag;

            System.Diagnostics.Process p = new System.Diagnostics.Process();
            p.StartInfo = new System.Diagnostics.ProcessStartInfo("mstsc.exe", String.Format("/v:{0}", server));
            p.Start();
        }

        void XmgmtCommandTextBox_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.KeyCode == Keys.Enter)
            {
                String command = XmgmtCommandTextBox.Text;

                if (XmgmtAllServersCheckBox.Checked)
                {
                    if (TreeInterfaces.SelectedNode != null)
                    {
                        string interfaceName = (string)TreeInterfaces.SelectedNode.Tag;
                        Global.XEnv.ExecuteXmgmtCommand(interfaceName, command);
                        XmgmtCommandTextBox.Text = "";
                    }
                }
                else
                {
                    TreeNode selectedServer = TreeServers.SelectedNode;

                    if (selectedServer != null)
                    {
                        String server = (String)selectedServer.Tag;
                        Global.XEnv.ExecuteXmgmtCommandOneServer(server, command);
                        XmgmtCommandTextBox.Text = "";
                    }
                }
            }
        }

        #endregion //Events
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\LiveEnvironment\SettingBrowser.cs ===
using System;
using System.Threading;
using System.Windows.Forms;
using System.Drawing;
using System.Xml;
using System.Data.SqlClient;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Database;
using xonline.common.config;

namespace STFGui.Plugins
{
    public partial class EnvironmentPlugin : IPluginSetup, IPluginGui
    {
        Panel panelSettingsListAndFilter;
        Panel panelSettingsFilter;
        Panel panelSettingsList;
        Panel panelSettingsInfoAndAlter;
        Panel panelSettingsInfo;
        Panel panelSettingsAlter;

        ListBox settingsListBox;
        TextBox settingsFilterBox;
        TextBox settingsDetailsBox;

        Button butAddBase;
        Button butChangeBase;
        Button butRemoveBase;
        Button butAddOverride;
        Button butChangeOverride;
        Button butRemoveOverride;
        Button butAddEnvTypeOverride;
        Button butChangeEnvTypeOverride;
        Button butRemoveEnvTypeOverride;

        string []settingsNames=new string[0]; //name of every known setting

        string curSetting="";
        bool curSettingMulti=false;

        //gets the tab page for the settings browser
        TabPage MakeSettingsBrowserTabPage()
        {
            TabPage tabSettings=new TabPage();
            tabSettings.Text="Settings";
            tabSettings.Size=new System.Drawing.Size(1000, 1000);

            //make a splitter between the list and the details
            SplitContainer splitListAndInfo=new SplitContainer();
            splitListAndInfo.Orientation=Orientation.Vertical;
            splitListAndInfo.Dock=DockStyle.Fill;
            splitListAndInfo.Location=new System.Drawing.Point(0, 0);
            splitListAndInfo.Size=new System.Drawing.Size(1000, 1000);
            splitListAndInfo.Panel2MinSize=100;
            splitListAndInfo.SplitterDistance=400;
            tabSettings.Controls.Add(splitListAndInfo);

            panelSettingsListAndFilter=splitListAndInfo.Panel1;
            panelSettingsInfoAndAlter=splitListAndInfo.Panel2;

            //make a splitter for the filter and list
            SplitContainer splitListAndFilter=new SplitContainer();
            splitListAndFilter.Orientation=Orientation.Horizontal;
            splitListAndFilter.Dock=DockStyle.Fill;
            splitListAndFilter.Location=new System.Drawing.Point(0, 0);
            splitListAndFilter.Size=new System.Drawing.Size(1000, 1000);
            splitListAndFilter.Panel1MinSize=21;
            splitListAndFilter.SplitterDistance=21;
            splitListAndFilter.IsSplitterFixed=true;
            panelSettingsListAndFilter.Controls.Add(splitListAndFilter);

            panelSettingsFilter=splitListAndFilter.Panel1;
            panelSettingsList=splitListAndFilter.Panel2;

            //make a splitter for the details and alteration
            SplitContainer splitInfoAndAlter=new SplitContainer();
            splitInfoAndAlter.Orientation=Orientation.Horizontal;
            splitInfoAndAlter.Dock=DockStyle.Fill;
            splitInfoAndAlter.Location=new System.Drawing.Point(0, 0);
            splitInfoAndAlter.Size=new System.Drawing.Size(1000, 1000);
            splitInfoAndAlter.Panel2MinSize=60;
            splitInfoAndAlter.SplitterDistance=940;
            splitInfoAndAlter.IsSplitterFixed=true;
            panelSettingsInfoAndAlter.Controls.Add(splitInfoAndAlter);

            panelSettingsInfo=splitInfoAndAlter.Panel1;
            panelSettingsAlter=splitInfoAndAlter.Panel2;

            //settings list
            settingsListBox=new ListBox();
            settingsListBox.Dock=DockStyle.Fill;
            settingsListBox.Sorted=true;
            settingsListBox.SelectedIndexChanged+=SettingsList_SelectionChanged;
            panelSettingsList.Controls.Add(settingsListBox);

            //settings filter
            panelSettingsFilter.Size=new System.Drawing.Size(1000, 22);

            Label lab=new Label();
            lab.Text="Filter:";
            lab.Location=new System.Drawing.Point(2, 4);
            lab.Size=new System.Drawing.Size(34, 20);
            panelSettingsFilter.Controls.Add(lab);

            settingsFilterBox=new TextBox();
            settingsFilterBox.Location=new System.Drawing.Point(37, 1);
            settingsFilterBox.Size=new System.Drawing.Size(361, 20);
            settingsFilterBox.Anchor=AnchorStyles.Right | AnchorStyles.Left;
            settingsFilterBox.TextChanged+=SettingFilterBox_Changed;
            panelSettingsFilter.Controls.Add(settingsFilterBox);

            //details box
            settingsDetailsBox=new TextBox();
            settingsDetailsBox.Dock=DockStyle.Fill;
            settingsDetailsBox.ReadOnly=true;
            settingsDetailsBox.Multiline=true;
            settingsDetailsBox.ScrollBars=ScrollBars.Both;
            settingsDetailsBox.WordWrap=false;
            panelSettingsInfo.Controls.Add(settingsDetailsBox);

            //settings alteration buttons
            butAddBase=new Button();
            butAddBase.Location=new System.Drawing.Point(0, 0);
            butAddBase.Size=new System.Drawing.Size(105, 20);
            butAddBase.Text="Add Base";
            butAddBase.Click+=Button_AddBase;
            panelSettingsAlter.Controls.Add(butAddBase);

            butChangeBase=new Button();
            butChangeBase.Location=new System.Drawing.Point(0, 20);
            butChangeBase.Size=new System.Drawing.Size(105, 20);
            butChangeBase.Text="Change Base";
            butChangeBase.Click+=Button_ChangeBase;
            panelSettingsAlter.Controls.Add(butChangeBase);

            butRemoveBase=new Button();
            butRemoveBase.Location=new System.Drawing.Point(0, 40);
            butRemoveBase.Size=new System.Drawing.Size(105, 20);
            butRemoveBase.Text="Remove Base";
            butRemoveBase.Click+=Button_RemoveBase;
            panelSettingsAlter.Controls.Add(butRemoveBase);

            butAddOverride=new Button();
            butAddOverride.Location=new System.Drawing.Point(490, 0);
            butAddOverride.Size=new System.Drawing.Size(105, 20);
            butAddOverride.Text="Add Override";
            butAddOverride.Anchor=AnchorStyles.Right;
            butAddOverride.Click+=Button_AddOverride;
            panelSettingsAlter.Controls.Add(butAddOverride);

            butChangeOverride=new Button();
            butChangeOverride.Location=new System.Drawing.Point(490, 20);
            butChangeOverride.Size=new System.Drawing.Size(105, 20);
            butChangeOverride.Text="Change Override";
            butChangeOverride.Anchor=AnchorStyles.Right;
            butChangeOverride.Click+=Button_ChangeOverride;
            panelSettingsAlter.Controls.Add(butChangeOverride);

            butRemoveOverride=new Button();
            butRemoveOverride.Location=new System.Drawing.Point(490, 40);
            butRemoveOverride.Size=new System.Drawing.Size(105, 20);
            butRemoveOverride.Anchor=AnchorStyles.Right;
            butRemoveOverride.Text="Remove Override";
            butRemoveOverride.Click+=Button_RemoveOverride;
            panelSettingsAlter.Controls.Add(butRemoveOverride);

            butAddEnvTypeOverride=new Button();
            butAddEnvTypeOverride.Location=new System.Drawing.Point(110, 0);
            butAddEnvTypeOverride.Size=new System.Drawing.Size(375, 20);
            butAddEnvTypeOverride.Anchor=AnchorStyles.Right | AnchorStyles.Left;
            butAddEnvTypeOverride.Text="Add EnvType Override";
            butAddEnvTypeOverride.Click+=Button_AddEnvTypeOverride;
            panelSettingsAlter.Controls.Add(butAddEnvTypeOverride);

            butChangeEnvTypeOverride=new Button();
            butChangeEnvTypeOverride.Location=new System.Drawing.Point(110, 20);
            butChangeEnvTypeOverride.Size=new System.Drawing.Size(375, 20);
            butChangeEnvTypeOverride.Anchor=AnchorStyles.Right | AnchorStyles.Left;
            butChangeEnvTypeOverride.Text="Change EnvType Override";
            butChangeEnvTypeOverride.Click+=Button_ChangeEnvTypeOverride;
            panelSettingsAlter.Controls.Add(butChangeEnvTypeOverride);

            butRemoveEnvTypeOverride=new Button();
            butRemoveEnvTypeOverride.Location=new System.Drawing.Point(110, 40);
            butRemoveEnvTypeOverride.Size=new System.Drawing.Size(375, 20);
            butRemoveEnvTypeOverride.Anchor=AnchorStyles.Right | AnchorStyles.Left;
            butRemoveEnvTypeOverride.Text="Remove EnvType Override";
            butRemoveEnvTypeOverride.Click+=Button_RemoveEnvTypeOverride;
            panelSettingsAlter.Controls.Add(butRemoveEnvTypeOverride);

            UpdateAlterationBox(false, false, false);

            //
            return tabSettings;
        }

        private void ClearSettingsInfo()
        {
            settingsNames=new string[0];
            settingsListBox.Items.Clear();

            curSetting="";
            curSettingMulti=false;

            PopulateInfoBox();
        }

        //gets setting names from npdb
        private void RefillSettingNames()
        {
            //pull all possible settings from npdb
            List<string> baseSettingsList=new List<string>();

            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                //retrieve all setting names
                SqlDataReader reader;
                npdb.ReadData("select vc_setting from t_settings", out reader);
                while (reader.Read())
                {
                    string name=(string)reader[0];
                    baseSettingsList.Add(name);
                }
                reader.Close();

                //retrieve all multisetting names
                npdb.ReadData("select vc_multisetting from t_multisetting_names", out reader);
                while (reader.Read())
                {
                    string name=(string)reader[0];
                    baseSettingsList.Add(name+"*");
                }
                reader.Close();

                npdb.Close();
            }
            catch(ThreadAbortException)
            {
                // We don't want to handle the thread abort exception
                // The thread abort will be automatically rethrown
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving settings list: "+e);
            }

            //store and rebuild the box
            settingsNames=baseSettingsList.ToArray();
            RebuildSettingsListBox();
        }

        //rebuilds the box of settings based on the current list and the filter
        private void RebuildSettingsListBox()
        {
            if (settingsListBox.InvokeRequired)
            {
                settingsListBox.Invoke((InvokeCode)RebuildSettingsListBox);
            }
            else
            {
                try
                {
                    settingsListBox.SuspendLayout();
                    settingsListBox.Items.Clear();

                    foreach (string name in settingsNames)
                    {
                        if (settingsFilterBox.Text.Length == 0 || name.ToLower().Contains(settingsFilterBox.Text.ToLower()))
                        {
                            settingsListBox.Items.Add(name);
                        }
                    }
                }
                finally
                {
                    settingsListBox.ResumeLayout(true);
                }
            }
        }

        //rebuilds the info box for a setting
        private void PopulateInfoBox()
        {
            string setting=SqlEscapize(curSetting);
            bool isMultiSetting=curSettingMulti;
            if (setting.Length==0)
            {
                settingsDetailsBox.Text="";
                UpdateAlterationBox(false, false, false);
                return;
            }

            bool baseExists=false;
            bool overrideExists=false;
            bool envOverrideExists=false;

            settingsDetailsBox.Text=" ----- "+curSetting+" ----- "+(isMultiSetting?"(multisetting)":"")+"\r\n\r\n";

            try
            {
                Config.DiscardCachedValues();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception flushing cached settings: "+e);
            }

            //the current value
            try
            {
                if (!isMultiSetting)
                {
                    settingsDetailsBox.Text+="current value: "+Global.XEnv.GetSetting(curSetting)+"\r\n\r\n";
                }
                else
                {
                    string []vals=Config.GetMultiSetting(curSetting);
                    foreach (string v in vals)
                    {
                        settingsDetailsBox.Text+="current value: "+v+"\r\n";
                    }

                    settingsDetailsBox.Text+="\r\n";
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception getting setting value: "+e);
            }

            //value derivation
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                //base value
                SqlDataReader reader;
                string query;
                if (!isMultiSetting)
                {
                    query="select vc_value from t_settings where vc_setting='"+setting+"'";
                }
                else
                {
                    query="select vc_value from t_multisettings where vc_multisetting='"+setting+"'";
                }
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    baseExists=true;
                    string val=(string)reader[0];
                    settingsDetailsBox.Text+="base value: "+val+"\r\n";
                }
                reader.Close();

                //env type overrides
                if (!isMultiSetting)
                {
                    query="select vc_environment_type,vc_value from t_environment_type_setting_overrides where vc_setting='"+setting+"'";
                }
                else
                {
                    query="select vc_environment_type,vc_value from t_environment_type_multisetting_overrides where vc_multisetting='"+setting+"'";
                }
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    envOverrideExists=true;
                    string etype=(string)reader[0];
                    string val=(string)reader[1];
                    settingsDetailsBox.Text+="env type override: "+etype+": "+val+"\r\n";
                }
                reader.Close();

                //direct overrides
                if (!isMultiSetting)
                {
                    query="select vc_component,vc_server,i_site_id,vc_value from t_setting_overrides where vc_setting='"+setting+"' and vc_environment='"+GetCurrentEnvironmentName()+"'";
                }
                else
                {
                    query="select vc_component,vc_server,i_site_id,vc_value from t_multisetting_overrides where vc_multisetting='"+setting+"' and vc_environment='"+GetCurrentEnvironmentName()+"'";
                }
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    overrideExists=true;
                    string comp=(string)reader[0];
                    string serv=(string)reader[1];
                    string site=reader[2].ToString();
                    string val=(string)reader[3];
                    settingsDetailsBox.Text+="override: component="+comp+" server="+serv+" site="+site+": "+val+"\r\n";
                }
                reader.Close();

                npdb.Close();

                if (!envOverrideExists && !overrideExists)
                {
                    settingsDetailsBox.Text+="no overrides\r\n";
                }
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception getting setting overrides: "+e);
            }

            UpdateAlterationBox(baseExists, envOverrideExists, overrideExists);
        }

        //rebuilds the state of the edit settings buttons
        private void UpdateAlterationBox(bool baseExists, bool envOverrideExists, bool normOverrideExists)
        {
            if (curSettingMulti) //not supported yet
            {
                panelSettingsAlter.Visible=false;
                return;
            }
            else
            {
                panelSettingsAlter.Visible=true;
            }

            //change enableds and text based on vals
            butChangeBase.Enabled=true;
            butRemoveBase.Enabled=baseExists;
            butAddOverride.Enabled=true;
            butChangeOverride.Enabled=normOverrideExists;
            butRemoveOverride.Enabled=normOverrideExists;
            butAddEnvTypeOverride.Enabled=true;
            butChangeEnvTypeOverride.Enabled=envOverrideExists;
            butRemoveEnvTypeOverride.Enabled=envOverrideExists;

            //if we have no setting disable all (except for add base)
            if (curSetting.Length==0)
            {
                butChangeBase.Enabled=false;
                butRemoveBase.Enabled=false;
                butAddOverride.Enabled=false;
                butChangeOverride.Enabled=false;
                butRemoveOverride.Enabled=false;
                butAddEnvTypeOverride.Enabled=false;
                butChangeEnvTypeOverride.Enabled=false;
                butRemoveEnvTypeOverride.Enabled=false;
            }
        }

        //executes an sql non-query
        bool TryNpdbCommand(string query)
        {
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();
                npdb.IssueCommand(query);
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception executing query on npdb. query: "+query+"\nException: "+e);
                return false;
            }

            return true;
        }

        //gets a list of components
        string[] NpdbGetComponents()
        {
            List<string> list=new List<string>();

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData("select vc_component from t_components" , out reader);
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            npdb.Close();

            return list.ToArray();
        }

        //gets a list of server
        string[] NpdbGetServers()
        {
            List<string> list=new List<string>();

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData("select vc_server from t_servers where vc_environment='"+GetCurrentEnvironmentName()+"' order by vc_server" , out reader);
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            npdb.Close();

            return list.ToArray();
        }

        //gets a list of server
        string[] NpdbGetSites()
        {
            List<string> list=new List<string>();

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData("select distinct i_site_id from t_sites" , out reader);
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            npdb.Close();

            return list.ToArray();
        }

        //gets a list of environment types
        string[] NpdbGetEnvTypes()
        {
            List<string> list=new List<string>();

            Npdb npdb=new Npdb();
            npdb.ConnectToServer();
            SqlDataReader reader;
            npdb.ReadData("select vc_environment_type from t_environment_types" , out reader);
            while (reader.Read())
            {
                list.Add(reader[0].ToString());
            }
            reader.Close();
            npdb.Close();

            return list.ToArray();
        }

        string SqlEscapize(string s)
        {
            return s.Replace("'","''");
        }

        #region Events

        public void RefreshSettings()
        {
            RefillSettingNames();
        }

        public void SettingFilterBox_Changed(object sender, EventArgs ea)
        {
            RebuildSettingsListBox();
        }

        public void SettingsList_SelectionChanged(object sender, EventArgs ea)
        {
            if (settingsListBox.SelectedItem!=null)
            {
                string selName=(string)settingsListBox.SelectedItem;
                if (selName.EndsWith("*"))
                {
                    curSetting=selName.Substring(0, selName.Length-1);
                    curSettingMulti=true;
                }
                else
                {
                    curSetting=selName;
                    curSettingMulti=false;
                }

                PopulateInfoBox();
            }
        }

        public void Button_AddBase(object sender, EventArgs ea)
        {
            string newSet, newVal;
            ShowAddBaseSettingBox(out newSet, out newVal);
            if (newSet.Length==0)
            {
                Global.RO.Info("New setting not added.");
            }
            else
            {
                if (TryNpdbCommand("insert into t_settings (vc_setting,vc_value) values ('"+SqlEscapize(newSet)+"', '"+SqlEscapize(newVal)+"')"))
                {
                    RefillSettingNames();
                    curSetting=newSet;
                    curSettingMulti=false;
                    Global.RO.Info(newSet+" added.");
                }
            }

            PopulateInfoBox();
        }

        public void Button_ChangeBase(object sender, EventArgs ea)
        {
            string newVal=STFGui.GuiCommon.GetStringFromUser(GuiHooks.MainForm, curSetting, Global.XEnv.GetSetting(curSetting));
            if (newVal==null)
            {
                Global.RO.Info("Setting not changed.");
            }
            else
            {
                if (TryNpdbCommand("update t_settings set vc_value='"+SqlEscapize(newVal)+"' where vc_setting='"+SqlEscapize(curSetting)+"'"))
                {
                    Global.RO.Info(curSetting+" changed.");
                }
            }

            PopulateInfoBox();
        }

        public void Button_RemoveBase(object sender, EventArgs ea)
        {
            if (System.Windows.Forms.MessageBox.Show("Really delete base setting '"+curSetting+"'?", "Slay the Setting?", MessageBoxButtons.YesNo)==DialogResult.No)
            {
                Global.RO.Info("We left the poor setting alone.");
            }
            else
            {
                if (TryNpdbCommand("delete from t_settings where vc_setting='"+SqlEscapize(curSetting)+"'"))
                {
                    Global.RO.Info(curSetting+" obliterated.");
                    curSetting="";
                    RefillSettingNames();
                }
            }

            PopulateInfoBox();
        }

        public void Button_AddOverride(object sender, EventArgs ea)
        {
            //get the lists we need
            string []components=null;
            string []servers=null;
            string []sites=null;
            try
            {
                components=NpdbGetComponents();
                servers=NpdbGetServers();
                sites=NpdbGetSites();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving info from npdb: "+e);
                return;
            }

            //ask user and do it
            string newVal;
            string newComp, newServ, newSite;
            if (!ShowListBoxesWithOptionalValue("Add Override on "+curSetting,
                "Component:", components, "ALL", out newComp,
                "Server:", servers, "ALL", out newServ,
                "Site:", sites, "-1", out newSite,
                "Value:", null, out newVal))
            {
                Global.RO.Info("No override added.");
            }
            else
            {
                if (TryNpdbCommand("insert into t_setting_overrides (vc_environment,                     vc_component,               i_site_id,                  vc_server,                  vc_setting,                    vc_value) "+
                                                             "values('"+GetCurrentEnvironmentName()+"', '"+SqlEscapize(newComp)+"', '"+SqlEscapize(newSite)+"', '"+SqlEscapize(newServ)+"', '"+SqlEscapize(curSetting)+"', '"+SqlEscapize(newVal)+"')"))
                {
                    Global.RO.Info("Override added for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_ChangeOverride(object sender, EventArgs ea)
        {
            //build the where clauses for each individual override (minus setting name)
            List<string> wheres=new List<string>();
            string query="select vc_component,vc_server,i_site_id from t_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"' and vc_environment='"+GetCurrentEnvironmentName()+"'";
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    string w="vc_component='"+SqlEscapize(reader[0].ToString())+"' and vc_server='"+SqlEscapize(reader[1].ToString())+"' and i_site_id="+reader[2].ToString();
                    wheres.Add(w);
                }
                reader.Close();
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving overrides list: "+e);
                return;
            }

            //ask user and do it
            string whereToUse;
            string junk;
            string newVal;
            if (!ShowListBoxesWithOptionalValue("Change Override on "+curSetting,
                "Override:", wheres.ToArray(), null, out whereToUse,
                null, null, null, out junk,
                null, null, null, out junk,
                "New Value:", null, out newVal))
            {
                Global.RO.Info("No override changed.");
            }
            else
            {
                if (TryNpdbCommand("update t_setting_overrides set vc_value='"+SqlEscapize(newVal)+"' where vc_setting='"+SqlEscapize(curSetting)+"' and "+whereToUse))
                {
                    Global.RO.Info("Override updated for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_RemoveOverride(object sender, EventArgs ea)
        {
            //build the where clauses for each individual override (minus setting name)
            List<string> wheres=new List<string>();
            string query="select vc_component,vc_server,i_site_id from t_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"' and vc_environment='"+GetCurrentEnvironmentName()+"'";
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    string w="vc_component='"+SqlEscapize(reader[0].ToString())+"' and vc_server='"+SqlEscapize(reader[1].ToString())+"' and i_site_id="+reader[2].ToString();
                    wheres.Add(w);
                }
                reader.Close();
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving overrides list: "+e);
                return;
            }

            //ask user and do it
            string whereToUse;
            string junk;
            if (!ShowListBoxesWithOptionalValue("Remove Override on "+curSetting,
                "Override:", wheres.ToArray(), null, out whereToUse,
                null, null, null, out junk,
                null, null, null, out junk,
                null, null, out junk))
            {
                Global.RO.Info("No override removed.");
            }
            else
            {
                if (TryNpdbCommand("delete from t_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"' and "+whereToUse))
                {
                    Global.RO.Info("Override destroyed for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_AddEnvTypeOverride(object sender, EventArgs ea)
        {
            //get the lists we need
            string []envTypes=null;
            try
            {
                envTypes=NpdbGetEnvTypes();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving info from npdb: "+e);
                return;
            }

            //ask user and do it
            string newVal;
            string newEnvType;
            string junk;
            if (!ShowListBoxesWithOptionalValue("Add Env Type Override on "+curSetting,
                "Env Type:", envTypes, null, out newEnvType,
                null, null, null, out junk,
                null, null, null, out junk,
                "Value:", null, out newVal))
            {
                Global.RO.Info("No env type override added.");
            }
            else
            {
                if (TryNpdbCommand("insert into t_environment_type_setting_overrides (vc_environment_type,           vc_setting,                    vc_value)"+
                                                                            " values ('"+SqlEscapize(newEnvType)+"', '"+SqlEscapize(curSetting)+"', '"+SqlEscapize(newVal)+"')"))
                {
                    Global.RO.Info("Env type override added for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_ChangeEnvTypeOverride(object sender, EventArgs ea)
        {
            //get the current overides
            List<string> envs=new List<string>();
            string query="select vc_environment_type from t_environment_type_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"'";
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    envs.Add(reader[0].ToString());
                }
                reader.Close();
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving env type overrides list: "+e);
                return;
            }

            //ask user and do it
            string envToUse;
            string junk;
            string newVal;
            if (!ShowListBoxesWithOptionalValue("Change Env Type Override on "+curSetting,
                "Env Type:", envs.ToArray(), null, out envToUse,
                null, null, null, out junk,
                null, null, null, out junk,
                "New Value:", null, out newVal))
            {
                Global.RO.Info("No env type override changed.");
            }
            else
            {
                if (TryNpdbCommand("update t_environment_type_setting_overrides set vc_value='"+SqlEscapize(newVal)+"' where vc_setting='"+SqlEscapize(curSetting)+"' and vc_environment_type='"+SqlEscapize(envToUse)+"'"))
                {
                    Global.RO.Info("Env type override updated for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        public void Button_RemoveEnvTypeOverride(object sender, EventArgs ea)
        {
            //get the current overides
            List<string> envs=new List<string>();
            string query="select vc_environment_type from t_environment_type_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"'";
            try
            {
                Npdb npdb=new Npdb();
                npdb.ConnectToServer();

                SqlDataReader reader;
                npdb.ReadData(query, out reader);
                while (reader.Read())
                {
                    envs.Add(reader[0].ToString());
                }
                reader.Close();
                npdb.Close();
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception retrieving env type overrides list: "+e);
                return;
            }

            //ask user and do it
            string envToUse;
            string junk;
            if (!ShowListBoxesWithOptionalValue("Remove Env Type Override on "+curSetting,
                "Env Type:", envs.ToArray(), null, out envToUse,
                null, null, null, out junk,
                null, null, null, out junk,
                null, null, out junk))
            {
                Global.RO.Info("No env type override removed.");
            }
            else
            {
                if (TryNpdbCommand("delete from t_environment_type_setting_overrides where vc_setting='"+SqlEscapize(curSetting)+"' and vc_environment_type='"+SqlEscapize(envToUse)+"'"))
                {
                    Global.RO.Info("Env type override incapacitated for "+curSetting);
                }
            }

            PopulateInfoBox();
        }

        #endregion //Events

        #region ui helpers

        void ShowAddBaseSettingBox(out string settingName, out string settingValue)
        {
            settingName="";
            settingValue="";

            //make a box for this
            Form form=new Form();
            form.SetBounds(0,0,315,85,BoundsSpecified.Size);
            form.Text="Add Setting";
            form.FormBorderStyle=FormBorderStyle.FixedDialog;
            form.MaximizeBox=false;

            Size expectedFormSize=new Size(307,58); //for funky windows ui styles, we need to adjust form size
            Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
            form.Size+=diffFormSize;

            //make controls
            Label l1=new Label();
            l1.Text="Name:";
            l1.SetBounds(6,7,39,20);

            TextBox input1=new TextBox();
            input1.SetBounds(50,5,100,25);

            Label l2=new Label();
            l2.Text="Value:";
            l2.SetBounds(159,7,40,20);

            TextBox input2=new TextBox();
            input2.SetBounds(200,5,100,25);

            Button butOk=new Button();
            butOk.Text="Ok";
            butOk.SetBounds(15,30,75,25);
            butOk.DialogResult=DialogResult.OK;

            Button butCan=new Button();
            butCan.Text="Cancel";
            butCan.SetBounds(315-15-75,30,75,25);
            butCan.DialogResult=DialogResult.Cancel;

            //put it together and show it
            form.Controls.Add(l1);
            form.Controls.Add(input1);
            form.Controls.Add(l2);
            form.Controls.Add(input2);
            form.Controls.Add(butOk);
            form.Controls.Add(butCan);

            form.AcceptButton=butOk;
            form.CancelButton=butCan;
            form.ShowDialog(GuiHooks.MainForm);

            //handle result
            if (form.DialogResult==DialogResult.OK)
            {
                settingName=input1.Text;
                settingValue=input2.Text;
            }
        }

        //shows 1-3 combo boxes (name of null means don't show) and optionally a value box
        bool ShowListBoxesWithOptionalValue(string title,
                                            string name1, string []values1, string defValue1, out string outVal1,
                                            string name2, string []values2, string defValue2, out string outVal2,
                                            string name3, string []values3, string defValue3, out string outVal3,
                                            string textValueName, string defTextValue, out string outTextValue)
        {
            outVal1=null;
            outVal2=null;
            outVal3=null;
            outTextValue=null;

            //make a box for this
            int hei=75;
            if (name1!=null) hei+=25;
            if (name2!=null) hei+=25;
            if (name3!=null) hei+=25;
            if (textValueName!=null) hei+=25;

            Form form=new Form();
            form.SetBounds(0,0,515,hei,BoundsSpecified.Size);
            form.Text=title;
            form.FormBorderStyle=FormBorderStyle.FixedDialog;
            form.MaximizeBox=false;

            Size expectedFormSize=new Size(507,hei-(85-58)); //for funky windows ui styles, we need to adjust form size
            Size diffFormSize=expectedFormSize-form.ClientRectangle.Size;
            form.Size+=diffFormSize;

            //make controls
            int ypos=10;
            ComboBox combo1=null, combo2=null, combo3=null;
            if (name1!=null)
            {
                Label l=new Label();
                l.SetBounds(5,ypos+1, 75,20);
                l.Text=name1;
                form.Controls.Add(l);
                
                combo1=new ComboBox();
                combo1.DropDownStyle=ComboBoxStyle.DropDownList;
                combo1.SetBounds(90,ypos-1, 400,20);
                combo1.Items.AddRange(values1);
                if (defValue1!=null) combo1.SelectedItem=defValue1;
                else combo1.SelectedIndex=0;
                form.Controls.Add(combo1);
                
                ypos+=25;
            }
            if (name2!=null)
            {
                Label l=new Label();
                l.SetBounds(5,ypos+1, 75,20);
                l.Text=name2;
                form.Controls.Add(l);

                combo2=new ComboBox();
                combo2.DropDownStyle=ComboBoxStyle.DropDownList;
                combo2.SetBounds(90,ypos-1, 400,20);
                combo2.Items.AddRange(values2);
                if (defValue2!=null) combo2.SelectedItem=defValue2;
                else combo2.SelectedIndex=0;
                form.Controls.Add(combo2);

                ypos+=25;
            }
            if (name3!=null)
            {
                Label l=new Label();
                l.SetBounds(5,ypos+1, 75,20);
                l.Text=name3;
                form.Controls.Add(l);

                combo3=new ComboBox();
                combo3.DropDownStyle=ComboBoxStyle.DropDownList;
                combo3.SetBounds(90,ypos-1, 400,20);
                combo3.Items.AddRange(values3);
                if (defValue3!=null) combo3.SelectedItem=defValue3;
                else combo3.SelectedIndex=0;
                form.Controls.Add(combo3);

                ypos+=25;
            }
            TextBox boxOfText=null;
            if (textValueName!=null)
            {
                Label l=new Label();
                l.SetBounds(5,ypos+2, 75,20);
                l.Text=textValueName;
                form.Controls.Add(l);

                boxOfText=new TextBox();
                boxOfText.SetBounds(90,ypos-1, 400,20);
                if (defTextValue!=null) boxOfText.Text=defTextValue;
                form.Controls.Add(boxOfText);

                ypos+=25;
            }

            //buttons
            Button butOk=new Button();
            butOk.Text="Ok";
            butOk.SetBounds(15,hei-55,75,25);
            butOk.DialogResult=DialogResult.OK;

            Button butCan=new Button();
            butCan.Text="Cancel";
            butCan.SetBounds(515-15-75,hei-55,75,25);
            butCan.DialogResult=DialogResult.Cancel;

            //put it together and show it
            form.Controls.Add(butOk);
            form.Controls.Add(butCan);

            form.AcceptButton=butOk;
            form.CancelButton=butCan;
            form.ShowDialog(GuiHooks.MainForm);

            //handle result
            if (form.DialogResult==DialogResult.OK)
            {
                if (name1!=null) outVal1=(string)combo1.SelectedItem;
                if (name2!=null) outVal2=(string)combo2.SelectedItem;
                if (name3!=null) outVal3=(string)combo3.SelectedItem;
                if (textValueName!=null) outTextValue=boxOfText.Text;

                return true;
            }

            return false;
        }

        #endregion //ui helpers

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\SporkfireMonitor\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\SporkfireMonitor\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\RegDB\RegDB.cs ===
using System;
using System.Windows.Forms;
using System.Threading;
using System.Collections.Generic;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Runner;

using ServerTestFramework.Reporting;

namespace STFGui.Plugins
{
    /// <summary>
    /// RegDB plugin.
    /// This plugin relies of the functional plugin to hook events.
    /// </summary>
    public class RegDBPlugin: IPluginExtension<FunctionalPlugin>, IPluginModuleLoadNotification, IPluginSetup, STFGui.Plugins.IPluginGui
    {
        //public members
        public Panel LogPanel;
        public Panel ButtonPanel;
        public Panel SuitesPanel;
        public Panel BuildsPanel;
        public Panel TreePanel;

        public ListBox ListBoxSuites;
        public ListBox ListBoxBuilds;
        public RegTreeView Tree;

        public MultiTestEventListener FunctionalEvents; //hooked from the functional plugin

        //internals
        FunctionalPlugin funcPlugin;
        CheckBox boxEnableLogging;
        TextBox textVersion;
        Button butViewOutput;
        Button butReload;
        SplitContainer splitBuildsAndSuites;

        LinkedList<TestNode> rootNodes=new LinkedList<TestNode>(); //of actually loaded test suites
        string []suitesList=new string[0];  //1-1 index mapping to the list box
        string []environmentsList=new string[0];
        RegDBInfo.BuildRun []buildsList=new RegDBInfo.BuildRun[0];  //1-1 index mapping to the list box

        RegDBTestEventListener regDBLoggerListener;

        Report ro=new Report("RegDBPlugin");
        public delegate void InvokeCode();

        bool isRunningPassFailUpdate=false; //true while an update to pass/fail is going
        bool cancelRunningPassFailUpdate=false; //set to false to cancel

        string autoLogVersion=""; //for automatically logging to a specific version

        //Returns the TabPage to add to the gui.
        public TabPage GetNewTabPage()
        {
            //the tab
            TabPage page=new TabPage();
            page.Text="RegDB";

            //add a splitter to divide the tree from the the rest
            SplitContainer splitTreeAndRest=new SplitContainer();
            splitTreeAndRest.Orientation=Orientation.Vertical;
            splitTreeAndRest.Dock=DockStyle.Fill;
            splitTreeAndRest.Location=new System.Drawing.Point(0, 0);
            splitTreeAndRest.Size=new System.Drawing.Size(3000, 3000);
            splitTreeAndRest.Panel1MinSize=350;
            splitTreeAndRest.SplitterDistance=350;
            splitTreeAndRest.IsSplitterFixed=true;
            page.Controls.Add(splitTreeAndRest);

            TreePanel=splitTreeAndRest.Panel2;
            TreePanel.Enabled=false;

            //add a splitter to divide the log control from the suites/builds
            SplitContainer splitLogAndSuitesBuilds=new SplitContainer();
            splitLogAndSuitesBuilds.Orientation=Orientation.Horizontal;
            splitLogAndSuitesBuilds.Dock=DockStyle.Fill;
            splitLogAndSuitesBuilds.Location=new System.Drawing.Point(0, 0);
            splitLogAndSuitesBuilds.Size=new System.Drawing.Size(3000, 3000);
            splitLogAndSuitesBuilds.Panel1MinSize=50;
            splitLogAndSuitesBuilds.SplitterDistance=50;
            splitLogAndSuitesBuilds.IsSplitterFixed=true;
            splitTreeAndRest.Panel1.Controls.Add(splitLogAndSuitesBuilds);

            //add a splitter to divide the log controls from the view controls
            SplitContainer splitControls=new SplitContainer();
            splitControls.Orientation=Orientation.Vertical;
            splitControls.Dock=DockStyle.Fill;
            splitControls.Location=new System.Drawing.Point(0, 0);
            splitControls.Size=new System.Drawing.Size(3000, 3000);
            splitControls.Panel1MinSize=175;
            splitControls.SplitterDistance=175;
            splitControls.IsSplitterFixed=true;
            splitLogAndSuitesBuilds.Panel1.Controls.Add(splitControls);

            LogPanel=splitControls.Panel1;
            LogPanel.Enabled=false; //disable log controls until we find the functional plugin

            ButtonPanel=splitControls.Panel2;

            //add a splitter to divide the builds from the suites
            splitBuildsAndSuites=new SplitContainer();
            splitBuildsAndSuites.Orientation=Orientation.Vertical;
            splitBuildsAndSuites.Dock=DockStyle.Fill;
            splitBuildsAndSuites.Location=new System.Drawing.Point(0, 0);
            splitBuildsAndSuites.Size=new System.Drawing.Size(3000, 3000);
            splitBuildsAndSuites.Panel1MinSize=140;
            splitBuildsAndSuites.SplitterDistance=140;
            splitBuildsAndSuites.IsSplitterFixed=true;
            splitLogAndSuitesBuilds.Panel2.Controls.Add(splitBuildsAndSuites);

            SuitesPanel=splitBuildsAndSuites.Panel1;
            SuitesPanel.Enabled=false;
            BuildsPanel=splitBuildsAndSuites.Panel2;
            BuildsPanel.Enabled=false;

            //Set up the logging panel
            boxEnableLogging=new CheckBox();
            boxEnableLogging.Text="Enable logging to RegDB";
            boxEnableLogging.Location=new System.Drawing.Point(20, 4);
            boxEnableLogging.Size=new System.Drawing.Size(150, 18);
            boxEnableLogging.CheckedChanged+=EnableLogging_Changed;
            LogPanel.Controls.Add(boxEnableLogging);

            Label labBuild=new Label();
            labBuild.Text="Log version:";
            labBuild.Location=new System.Drawing.Point(11, 31);
            labBuild.Size=new System.Drawing.Size(67, 13);
            LogPanel.Controls.Add(labBuild);

            textVersion=new TextBox();
            textVersion.Location=new System.Drawing.Point(78, 28);
            textVersion.Size=new System.Drawing.Size(88, 13);
            textVersion.Text="00.00.0000.0000";
            textVersion.MaxLength=15;
            textVersion.TextChanged+=BuildBox_TextChanged;
            textVersion.LostFocus+=BuildBox_LostFocus;
            LogPanel.Controls.Add(textVersion);

            //Set up the suites panel
            ListBoxSuites=new ListBox();
            ListBoxSuites.Dock=DockStyle.Fill;
            ListBoxSuites.SelectedIndexChanged+=SuitesList_SelectionChanged;
            SuitesPanel.Controls.Add(ListBoxSuites);

            //Set up the builds panel
            ListBoxBuilds=new ListBox();
            ListBoxBuilds.Dock=DockStyle.Fill;
            ListBoxBuilds.SelectedIndexChanged+=BuildsList_SelectionChanged;
            BuildsPanel.Controls.Add(ListBoxBuilds);

            //Set up the tree panel
            Tree=new RegTreeView(GuiHooks.MainForm);
            Tree.Dock=DockStyle.Fill;
            TreePanel.Controls.Add(Tree);

            butReload=new Button();
            butReload.Text="Read Data From RegDB";
            //butReload.Location=new System.Drawing.Point(7, 2);
            //butReload.Size=new System.Drawing.Size(69, 48);
            butReload.Location=new System.Drawing.Point(40, 2);
            butReload.Size=new System.Drawing.Size(80, 48);
            butReload.Click+=ButtonReload_Click;
            ButtonPanel.Controls.Add(butReload);

            butViewOutput=new Button();
            butViewOutput.Text="View Node Output";
            butViewOutput.Location=new System.Drawing.Point(95, 2);
            butViewOutput.Size=new System.Drawing.Size(65, 48);
            butViewOutput.Enabled=false;
            butViewOutput.Visible=false; //don't now this button need I think
            butViewOutput.Click+=ButtonViewOutput_Click;
            ButtonPanel.Controls.Add(butViewOutput);

            //
            return page;
        }

        //called when the functional plugin is loaed
        public void PluginLoaded(FunctionalPlugin funcPlug)
        {
            LogPanel.Enabled=true;

            //grab the parts we care for
            funcPlugin=funcPlug;
            FunctionalEvents=funcPlugin.FunctionalEvents;

            //set up our own node context menu handler
            funcPlugin.BuildNodeContextMenuItemsEvent+=AddFuncContextItems;

            //autolog if we were asked to
            if (autoLogVersion.Length>0)
            {
                textVersion.Text=autoLogVersion;
                BuildBox_LostFocus(textVersion, null);
                boxEnableLogging.Checked=true;

                autoLogVersion=""; //done with autolog functionality
            }
        }

        //called when a module is about to be loaded
        public void ModuleLoading(string fileName)
        {
        }

        //called when a suite is loaded
        public void SuiteLoaded(TestNode rootNode)
        {
            CancelPassFailUpdate();
            lock (Tree)
            {
                rootNodes.AddLast(rootNode);
            }

            RebuildTree();
        }

        //called when suite is being unloaded
        public void SuiteUnloading(TestNode rootNode)
        {
            CancelPassFailUpdate();
            lock (Tree)
            {
                rootNodes.Remove(rootNode);
            }

            RebuildTree();
        }

        //called to init plugin
        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            //check our commandline params for anything interesting
            foreach (string s in commandlineParameters)
            {
                if (s.StartsWith("logversion:") && s.Length>=12 && s.Length<=11+15) //log to a specific version
                {
                    autoLogVersion=s.Substring(11);
                }
                else if (s.ToLower()=="help")
                {
                    ro.Info("RogDB Plugin parameters:");
                    ro.Info("  logversion:u.v.s.t      Log functional run as version u.v.s.t");
                }
                else
                {
                    ro.Error("Bad parameter passed to RegDB plugin: "+s);
                }
            }
        }

        //called when we're being shut down
        public void Shutdown(XmlNode pluginSettings)
        {
        }

        #region Events

        //called to add extra context menu items for a node if the user brought up that menu
        private void AddFuncContextItems(TestNode node, List<FunctionalPlugin.TestNodeContextMenuItem> contextItemsToShow)
        {
            contextItemsToShow.Add(new FunctionalPlugin.TestNodeContextMenuItem("-"));
            contextItemsToShow.Add(new FunctionalPlugin.TestNodeContextMenuItem("View RegDB History", Context_ViewRegDBHistory));
        }

        private void Context_ViewRegDBHistory(FunctionalPlugin.TestNodeContextMenuItem sender, TestNode node)
        {
            Tree.ShowHistoryBoxForNode(node.FullName);
        }

        //
        public void BuildBox_TextChanged(object sender, EventArgs e)
        {
           TextBox tb=(TextBox)sender;

            //only allow numbers
            string newstr="";
            foreach (char c in tb.Text)
            {
                if ((c>='0' && c <='9') || c=='.') newstr+=c;
            }

            if (newstr!=tb.Text)
            {
                tb.Text=newstr;
                tb.SelectionStart=tb.Text.Length;
            }
        }

        public void BuildBox_LostFocus(object sender, EventArgs e)
        {
            TextBox tb=(TextBox)sender;

            //reformat the string to be correct
            string []parts=new string[4];
            for (int i=0; i<4; ++i)
                parts[i]="";
            int dotCount=0;

            foreach (char c in tb.Text)
            {
                if (c=='.')
                {
                    ++dotCount;
                    if (dotCount>=4) //...
                    {
                        break;
                    }
                }
                else
                {
                    parts[dotCount]+=c;
                }
            }

            if (parts[0].Length>2) parts[0].Substring(parts[0].Length-2,2);
            parts[0]=parts[0].PadLeft(2,'0');

            if (parts[1].Length>2) parts[1].Substring(parts[1].Length-2,2);
            parts[1]=parts[1].PadLeft(2,'0');

            if (parts[2].Length>4) parts[2].Substring(parts[2].Length-4,4);
            parts[2]=parts[2].PadLeft(4,'0');

            if (parts[3].Length>4) parts[3].Substring(parts[3].Length-4,4);
            parts[3]=parts[3].PadLeft(4,'0');

            string newstr=parts[0]+"."+parts[1]+"."+parts[2]+"."+parts[3];

            //if we changed it, tell them
            if (newstr!=tb.Text)
            {
                tb.Text=newstr;

                if (autoLogVersion=="") //user-done so show a box
                {
                    MessageBox.Show("Version number was in the wrong format and has been altered.  Please verify that the altered version is correct.");
                }
                else //auto-done so just log message
                {
                    ro.Warn("Version number was in the wrong format and has been altered.  Please verify that the altered version is correct.");
                }
            }
        }

        private void EnableLogging_Changed(object sender, EventArgs evt)
        {
            CheckBox cb=(CheckBox)sender;

            if (cb.Checked) //start logging
            {
                //get the build to log with
                string []splitDots=textVersion.Text.Split(new char[]{'.'});

                string build=splitDots[0]+"."+splitDots[1]+"."+splitDots[2];
                int buildIter=int.Parse(splitDots[3]);

                //disable changing the build
                textVersion.Enabled=false;

                //start logging
                try
                {
                    ro.Info("Enabling RegDB logging... all functional events and all output will be recorded.");
                    regDBLoggerListener=new RegDBTestEventListener(build, buildIter);
                    FunctionalEvents.Add(regDBLoggerListener);
                }
                catch (Exception e)
                {
                    ro.Error("Exception enabling RegDB logging: "+e);
                    cb.Checked=false;
                }

                if (funcPlugin!=null)
                {
                    funcPlugin.OverrideLoopedRunning(this, false);
                    funcPlugin.OverrideDryRunning(this, false);
                }
            }
            else //turn off logging
            {
                if (regDBLoggerListener!=null)
                {
                    FunctionalEvents.Remove(regDBLoggerListener);
                    regDBLoggerListener=null;
                }

                ro.Info("RegDB logging stopped.");

                //re-enable changing the build
                textVersion.Enabled=true;

                if (funcPlugin!=null)
                {
                    funcPlugin.OverrideLoopedRunning(this, null);
                    funcPlugin.OverrideDryRunning(this, null);
                }
            }
        }

        private void ButtonViewOutput_Click(object sender, EventArgs e)
        {
        }

        private void ButtonReload_Click(object sender, EventArgs e)
        {
            //update gui state to disabled and "Loading..."
            if (sender!=null)
            {
                Button but=(Button)sender;

                but.Text="Reload";
                but.Enabled=false;
            }

            butViewOutput.Enabled=false;

            SuitesPanel.Enabled=false;
            ListBoxSuites.Items.Clear();
            ListBoxSuites.Items.Add("Loading...");

            BuildsPanel.Enabled=false;
            ListBoxBuilds.Items.Clear();
            ListBoxBuilds.Items.Add("Loading...");

            CancelPassFailUpdate();
            lock (Tree)
            {
                Tree.Nodes.Clear();
            }

            //kick off worker thread to do the work
            Thread thread=ThreadMaker.CreateThread(ThreadProcReload);
            thread.IsBackground=true;
            thread.Start();
        }

        private void SuitesList_SelectionChanged(object sender, EventArgs e)
        {
            if (ListBoxSuites.Enabled==false) return;

            Thread thread=ThreadMaker.CreateThread(ThreadProcPopulateBuildPassFail);
            thread.IsBackground=true;
            thread.Start();

            RebuildTree();
        }

        private void BuildsList_SelectionChanged(object sender, EventArgs e)
        {
            Tree.IterationID=-1;
            if (ListBoxBuilds.Enabled==false) return;

            if (ListBoxBuilds.SelectedIndex!=-1)
            {
                Tree.IterationID=buildsList[ListBoxBuilds.SelectedIndex].IterationID;
            }

            Thread thread=ThreadMaker.CreateThread(ThreadProcPopulateSuitePassFail);
            thread.IsBackground=true;
            thread.Start();

            //change the log version box too
            if (ListBoxBuilds.SelectedIndex>=0 && textVersion.Enabled)
            {
                textVersion.Text=buildsList[ListBoxBuilds.SelectedIndex].Build;
                BuildBox_LostFocus(textVersion, null);
            }

            //start updating tree pass/fail
            RecalcTreePassFail();
        }

        #endregion

        //reload all info panels
        private void ThreadProcReload()
        {
            ServerTestFramework.Reporting.RegDBInfo regDBInfo=new ServerTestFramework.Reporting.RegDBInfo();
            try
            {
                //load the list of suites
                suitesList=regDBInfo.GetAllSuites();

                ListBoxSuites.Invoke(new InvokeCode(delegate
                {
                    ListBoxSuites.Items.Clear();
                    foreach (string s in suitesList)
                    {
                        ListBoxSuites.Items.Add(s);
                    }
                }));

                //load the list of environments
                environmentsList=regDBInfo.GetAllEnvironments();

                //load the list of builds
                buildsList=regDBInfo.GetAllBuilds();

                ListBoxBuilds.Invoke(new InvokeCode(delegate
                {
                    ListBoxBuilds.Items.Clear();
                    foreach (RegDBInfo.BuildRun b in buildsList)
                    {
                        ListBoxBuilds.Items.Add(b.Build+" "+environmentsList[b.EnvironmentID]);
                    }
                }));

                //re-enable the ui parts
                TreePanel.Invoke(new InvokeCode(delegate
                {
                    TreePanel.Enabled=true;
                    BuildsPanel.Enabled=true;
                    SuitesPanel.Enabled=true;
                }));
            }
            catch (Exception e)
            {
                ro.Error("Exception trying to load RegDB info: "+e);
            }
            finally
            {
                //re-enabled the Reload button
                butReload.Invoke(new InvokeCode(delegate
                {
                    butReload.Enabled=true;
                }));

                regDBInfo.Close();
            }
        }

        //populates pass/fail for each suite for a specific build
        private void ThreadProcPopulateSuitePassFail()
        {
            //get the inital build index to populate for
            int buildInd=-1;
            ListBoxBuilds.Invoke(new InvokeCode(delegate
            {
                buildInd=ListBoxBuilds.SelectedIndex;

                butReload.Enabled=false;
                butReload.Text="Updating...";
                ListBoxSuites.Enabled=false;
            }));

            ServerTestFramework.Reporting.RegDBInfo regDBInfo=new ServerTestFramework.Reporting.RegDBInfo();
            try
            {
                //now retrieve information for each suite
                for (int i=0; i<suitesList.Length; ++i)
                {
                    string suite=suitesList[i];

                    int pass, total;
                    regDBInfo.GetSuitePassCountForBuild(suite, buildsList[buildInd].IterationID, out pass, out total);

                    //update the suite box.  if the selected index changed though, totally bail out.
                    ListBoxBuilds.Invoke(new InvokeCode(delegate
                    {
                        if (ListBoxBuilds.SelectedIndex!=buildInd)
                        {
                            return;
                        }

                        if (total>0)
                        {
                            ListBoxSuites.Items[i]="["+pass+"/"+total+"] "+suitesList[i];
                        }
                        else
                        {
                            ListBoxSuites.Items[i]="  "+suitesList[i];
                        }
                    }));
                }
            }
            finally
            {
                //re-enabled the Reload button
                butReload.Invoke(new InvokeCode(delegate
                {
                    butReload.Enabled=true;
                    ListBoxSuites.Enabled=true;
                    butReload.Text="Reload";
                }));

                regDBInfo.Close();
            }
        }

        //populates pass/fail for each suite for a specific build
        private void ThreadProcPopulateBuildPassFail()
        {
            //get the inital build index to populate for
            int suiteInd=-1;
            ListBoxSuites.Invoke(new InvokeCode(delegate
            {
                suiteInd=ListBoxSuites.SelectedIndex;

                butReload.Enabled=false;
                butReload.Text="Updating...";
                ListBoxBuilds.Enabled=false;
            }));

            ServerTestFramework.Reporting.RegDBInfo regDBInfo=new ServerTestFramework.Reporting.RegDBInfo();
            try
            {
                //now retrieve information for each suite
                for (int i=0; i<buildsList.Length; ++i)
                {
                    int buildIter=buildsList[i].IterationID;

                    int pass, total;
                    regDBInfo.GetSuitePassCountForBuild(suitesList[suiteInd], buildIter, out pass, out total);

                    //update the suite box.  if the selected index changed though, totally bail out.
                    ListBoxSuites.Invoke(new InvokeCode(delegate
                    {
                        if (ListBoxSuites.SelectedIndex!=suiteInd)
                        {
                            return;
                        }

                        string buildStr=buildsList[i].Build+" "+environmentsList[buildsList[i].EnvironmentID];
                        if (total>0)
                        {
                            ListBoxBuilds.Items[i]="["+pass+"/"+total+"] "+buildStr;
                        }
                        else
                        {
                            ListBoxBuilds.Items[i]="  "+buildStr;
                        }
                    }));
                }
            }
            finally
            {
                //re-enabled the Reload button
                butReload.Invoke(new InvokeCode(delegate
                {
                    butReload.Enabled=true;
                    ListBoxBuilds.Enabled=true;
                    butReload.Text="Reload";
                }));

                regDBInfo.Close();
            }
        }

        //rebuilds the Reg Tree
        private void RebuildTree()
        {
            CancelPassFailUpdate();
            lock (Tree)
            {
                //wipe out old tree
                Tree.Nodes.Clear();

                //if we have a suite loaded for the chosen suite add its nodes first
                if (ListBoxSuites.SelectedIndex<0)
                {
                    return;
                }

                string selectedSuite=suitesList[ListBoxSuites.SelectedIndex];

                foreach (TestNode root in rootNodes)
                {
                    if (root.Name==selectedSuite)
                    {
                        Tree.Nodes.Add(new RegTreeNode(root, true));
                        Tree.Nodes[0].Name=root.Name;
                    }
                }

                //now merge RegDB's tree into that
                RegDBTreeReader.Node regRoot=RegDBInfo.GetSuiteTree(selectedSuite);
                Tree.MergeRegTree(regRoot);

                if (Tree.Nodes.Count>0)
                {
                    Tree.Nodes[0].Expand();
                }
            }

            RecalcTreePassFail();
        }

        //recalculates pass/fail for the tree
        private void RecalcTreePassFail()
        {
            CancelPassFailUpdate();
            cancelRunningPassFailUpdate=false;

            lock (Tree)
            {
                Tree.ClearPassFail();
            }

            if (ListBoxBuilds.SelectedIndex<0)
            {
                return;
            }

            Thread thread=ThreadMaker.CreateThread(ThreadProcRecalcTreePassFail);
            thread.IsBackground=true;
            isRunningPassFailUpdate=true;
            thread.Start();
        }

        //cancels any in-progress update to pass/fail
        private void CancelPassFailUpdate()
        {
            cancelRunningPassFailUpdate=true;
            while (isRunningPassFailUpdate)
            {
                //TODO: use a blocking object and all nicer stuff
                System.Threading.Thread.Sleep(0);
            }
        }

        //
        private void ThreadProcRecalcTreePassFail()
        {
            if (!isRunningPassFailUpdate) return;

            //get all leaf nodes in the tree
            List<RegTreeNode> leafNodes=new List<RegTreeNode>();

            int buildInd=-1;
            if (cancelRunningPassFailUpdate) return;
            butReload.Invoke(new InvokeCode(delegate
            {
                lock (Tree)
                {
                    Tree.GetLeaves(ref leafNodes);
                }
                buildInd=ListBoxBuilds.SelectedIndex;
            }));

            if (buildInd<0)
            {
                ro.Warn("Tried to recalc tree pass/fail with no build.");
                return;
            }

            ServerTestFramework.Reporting.RegDBInfo regDBInfo=new ServerTestFramework.Reporting.RegDBInfo();
            try
            {
                foreach (RegTreeNode tn in leafNodes)
                {
                    if (cancelRunningPassFailUpdate) return;

                    if (tn.IsInRegDB)
                    {
                        int pass=0;
                        int total=0;
                        regDBInfo.GetLeafPassFail(tn.FullName, buildsList[buildInd].IterationID, out pass, out total);

                        if (total>0)
                        {
                            lock (Tree)
                            {
                                if (cancelRunningPassFailUpdate) return;
                                Tree.Invoke(new InvokeCode(delegate
                                {
                                    tn.AddPassTotal(pass,total);
                                }));
                            }
                        }
                    }
                }
            }
            finally
            {
                isRunningPassFailUpdate=false;
                cancelRunningPassFailUpdate=false;

                regDBInfo.Close();
            }
        }

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public MenuItem GetNewMenu ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\LiveEnvironment\UODB.cs ===
using System;
using System.Threading;
using System.Windows.Forms;
using System.Drawing;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Plugins;
using ServerTestFramework.Database;

using xonline.common.sql.webstore;
using xonline.common.config;
using Microsoft.Webstore.WstClient;
using Microsoft.Webstore.MetaData;

namespace STFGui.Plugins
{
    public partial class EnvironmentPlugin : IPluginSetup, IPluginGui
    {

        Panel panelUODBList;
        Panel panelUODBQuery;
        Panel panelUODBButtons;

        ListBox listboxPartitionList;
        TextBox textboxQuery;

        Button butUODBExecute;
        Button butUODBSelectAll;
        Button butUODBSelectPrimaries;
        Button butUODBSelectReplicas;
        Button butUODBSelectHash;

        //gets the tab page for the uodb stuff
        TabPage MakeUODBTabPage()
        {
            TabPage tabUODB=new TabPage();
            tabUODB.Text="UODB";
            tabUODB.Size=new System.Drawing.Size(1000, 1000);

            //make a splitter between the list and the query
            SplitContainer splitListAndQuery=new SplitContainer();
            splitListAndQuery.Orientation=Orientation.Vertical;
            splitListAndQuery.Dock=DockStyle.Fill;
            splitListAndQuery.Location=new System.Drawing.Point(0, 0);
            splitListAndQuery.Size=new System.Drawing.Size(1000, 1000);
            splitListAndQuery.Panel2MinSize=100;
            splitListAndQuery.Panel1MinSize=150;
            splitListAndQuery.SplitterDistance=250;
            splitListAndQuery.FixedPanel=FixedPanel.Panel1;
            splitListAndQuery.IsSplitterFixed=false;
            tabUODB.Controls.Add(splitListAndQuery);

            Panel panelUODBListAndButtons=splitListAndQuery.Panel1;
            panelUODBQuery=splitListAndQuery.Panel2;

            //make a splitter between the list and the buttons
            SplitContainer splitListAndButtons=new SplitContainer();
            splitListAndButtons.Orientation=Orientation.Horizontal;
            splitListAndButtons.Dock=DockStyle.Fill;
            splitListAndButtons.Location=new System.Drawing.Point(0, 0);
            splitListAndButtons.Size=new System.Drawing.Size(250, 1000);
            splitListAndButtons.Panel2MinSize=110;
            splitListAndButtons.Panel1MinSize=100;
            splitListAndButtons.SplitterDistance=890;
            splitListAndButtons.FixedPanel=FixedPanel.Panel2;
            splitListAndButtons.IsSplitterFixed=true;
            panelUODBListAndButtons.Controls.Add(splitListAndButtons);

            panelUODBList=splitListAndButtons.Panel1;
            panelUODBButtons=splitListAndButtons.Panel2;
            panelUODBButtons.Resize+=ButtonsPanelResize;

            //uodb list
            listboxPartitionList=new ListBox();
            listboxPartitionList.Dock=DockStyle.Fill;
            listboxPartitionList.Sorted=true;
            listboxPartitionList.SelectionMode=SelectionMode.MultiExtended;
            listboxPartitionList.SelectedIndexChanged+=PartitionListSelectionChanged;
            panelUODBList.Controls.Add(listboxPartitionList);

            Label labStar=new Label();
            labStar.Text="* = Primary Partition";
            labStar.TextAlign=ContentAlignment.TopLeft;
            labStar.Location=new System.Drawing.Point(0, 0);
            labStar.Size=new System.Drawing.Size(250, 15);
            labStar.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            panelUODBButtons.Controls.Add(labStar);

            //query box
            textboxQuery=new TextBox();
            textboxQuery.Dock=DockStyle.Fill;
            textboxQuery.Multiline=true;
            textboxQuery.ScrollBars=ScrollBars.Both;
            textboxQuery.WordWrap=false;
            textboxQuery.Text="--Query Box\r\nselect name from sysobjects where type='U' and name like 't_%' order by name;";
            textboxQuery.ShortcutsEnabled=true;
            textboxQuery.Font=new Font("Lucida Console", 8.25F, FontStyle.Regular, GraphicsUnit.Point, ((byte)(0)));
            panelUODBQuery.Controls.Add(textboxQuery);

            //button group splitter
            Label labExecute=new Label();
            labExecute.Text="--";
            labExecute.TextAlign=ContentAlignment.TopCenter;
            labExecute.Location=new System.Drawing.Point(10, 70);
            labExecute.Size=new System.Drawing.Size(230, 15);
            labExecute.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            panelUODBButtons.Controls.Add(labExecute);

            //execute query button
            butUODBExecute=new Button();
            butUODBExecute.Text="Execute";
            butUODBExecute.Location=new System.Drawing.Point(10, 85);
            butUODBExecute.Size=new System.Drawing.Size(230, 25);
            butUODBExecute.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            butUODBExecute.Click+=ExecuteQueryClick;
            panelUODBButtons.Controls.Add(butUODBExecute);

            //select buttons
            Label labSelectPartitions=new Label();
            labSelectPartitions.Text="Select Partitions:";
            labSelectPartitions.TextAlign=ContentAlignment.TopCenter;
            labSelectPartitions.Location=new System.Drawing.Point(10, 15);
            labSelectPartitions.Size=new System.Drawing.Size(230, 15);
            labSelectPartitions.Anchor=AnchorStyles.Left|AnchorStyles.Right;
            panelUODBButtons.Controls.Add(labSelectPartitions);

            butUODBSelectAll=new Button();
            butUODBSelectAll.Text="All";
            butUODBSelectAll.Location=new System.Drawing.Point(10, 30);
            butUODBSelectAll.Size=new System.Drawing.Size(110, 20);
            butUODBSelectAll.Anchor=AnchorStyles.Left;
            butUODBSelectAll.Click+=UodbSelectAllClick;
            panelUODBButtons.Controls.Add(butUODBSelectAll);

            butUODBSelectReplicas=new Button();
            butUODBSelectReplicas.Text="Replicas";
            butUODBSelectReplicas.Location=new System.Drawing.Point(10, 50);
            butUODBSelectReplicas.Size=new System.Drawing.Size(110, 20);
            butUODBSelectReplicas.Anchor=AnchorStyles.Left;
            butUODBSelectReplicas.Click+=UodbSelectReplicaClick;
            panelUODBButtons.Controls.Add(butUODBSelectReplicas);

            butUODBSelectPrimaries=new Button();
            butUODBSelectPrimaries.Text="Primaries";
            butUODBSelectPrimaries.Location=new System.Drawing.Point(130, 30);
            butUODBSelectPrimaries.Size=new System.Drawing.Size(110, 20);
            butUODBSelectPrimaries.Anchor=AnchorStyles.None;
            butUODBSelectPrimaries.Click+=UodbSelectPrimaryClick;
            panelUODBButtons.Controls.Add(butUODBSelectPrimaries);

            butUODBSelectHash=new Button();
            butUODBSelectHash.Text="Hash";
            butUODBSelectHash.Location=new System.Drawing.Point(130, 50);
            butUODBSelectHash.Size=new System.Drawing.Size(110, 20);
            butUODBSelectHash.Anchor=AnchorStyles.None;
            butUODBSelectHash.Click+=UodbSelectHashClick;
            panelUODBButtons.Controls.Add(butUODBSelectHash);

            ResetUodbTab();

            //
            return tabUODB;
        }

        //clears out environment-specific stuff and disables controls
        protected void ResetUodbTab()
        {
            butUODBExecute.Enabled=false;
            butUODBSelectAll.Enabled=false;
            butUODBSelectReplicas.Enabled=false;
            butUODBSelectHash.Enabled=false;
            butUODBSelectPrimaries.Enabled=false;
            listboxPartitionList.Items.Clear();
        }

        //gets a WstConnection set up for the current environment.  This does not call Open() though.
        private static WstConnection GetEnvironmentWstConnection()
        {
            string applicationName=WSClient.SiteName+ConfigUtil.UodbWebstoreApp;
            WstConnection con=new WstConnection(applicationName);
            return con;
        }

        //an entry on the partition list
        class PartitionEntry
        {
            public string Server;
            public string Partition;
            public bool IsPrimary;
            public string Status;

            public override string ToString()
            {
                return Partition+
                (IsPrimary?"* ":" ")+
                "("+Server+")"+
                " - "+Status;
            }
        };

        //gets a WstCommand for a specific partition on a connection
        private static WstCommand GetPartitionWstCommand(WstConnection con, PartitionEntry pe)
        {
            WstCommand cmd=con.CreateCommand();

            //find the webstore db for the partition
            WebstoreDatabase db=null;
            foreach (WebstoreSQLFss failSafeSet in con.SqlPartitions)
            {
                foreach (WebstoreDatabase wsdb in failSafeSet.Databases)
                {
                    if (pe.Server==wsdb.ServerName && pe.Partition==wsdb.Name)
                    {
                        db=wsdb;
                    }
                }
            }

            if (db==null)
            {
                throw new System.Exception("Webstore Partition not found to match the given PartitionEntry: "+pe);
            }

            //set up the command for the partition
            cmd.WstFailoverMode=WstFailoverMode.SpecificDatabase;
            cmd.Database=db;

            return cmd;
        }

        #region Events

        //refreshes partition list and state
        public void RefreshUODB()
        {
            listboxPartitionList.Items.Clear();

            try
            {
                //open a webstore connection
                WstConnection con=GetEnvironmentWstConnection();
                con.Open();

                //add all sql partitions
                foreach (WebstoreSQLFss failSafeSet in con.SqlPartitions)
                {
                    foreach (WebstoreDatabase wsdb in failSafeSet.Databases)
                    {
                        PartitionEntry pe=new PartitionEntry();
                        pe.Server=wsdb.ServerName;
                        pe.Partition=wsdb.Name;
                        pe.IsPrimary=(wsdb.Name==failSafeSet.DefaultPrimaryDB.Name);
                        pe.Status=wsdb.Status.ToString();

                        listboxPartitionList.Items.Add(pe);
                    }
                }

                //
                con.Close();
            }
            catch (ThreadAbortException)
            {
                // We don't want to handle the thread abort exception
                // The thread abort will be automatically rethrown
            }
            catch (Exception e)
            {
                Global.RO.Error("Exception trying to populate webstore UODB list: "+e);
            }

            //select all primary partitions by default
            UodbSelectPrimaryClick(null, null);

            //enable stuff now that we have data
            butUODBSelectAll.Enabled=true;
            butUODBSelectPrimaries.Enabled=true;
            butUODBSelectReplicas.Enabled=true;
            butUODBSelectHash.Enabled=true;
        }

        //clicked the "select all partitions" button
        public void UodbSelectAllClick(object sender, EventArgs ea)
        {
            listboxPartitionList.SelectedItems.Clear();

            //copy the list out first, since .NET does some strange things internally with the lests that break using a regular enumerator
            List<PartitionEntry> allList=new List<PartitionEntry>();

            foreach (PartitionEntry pe in listboxPartitionList.Items)
            {
                allList.Add(pe);
            }

            //now add primaries to the selected list
            foreach (PartitionEntry pe in allList)
            {
                listboxPartitionList.SelectedItems.Add(pe);
            }
        }

        //clicked the "select all primary partitions" button
        public void UodbSelectPrimaryClick(object sender, EventArgs ea)
        {
            listboxPartitionList.SelectedItems.Clear();

            //copy the list out first, since .NET does some strange things internally with the lests that break using a regular enumerator
            List<PartitionEntry> primaryList=new List<PartitionEntry>();

            foreach (PartitionEntry pe in listboxPartitionList.Items)
            {
                if (pe.IsPrimary)
                {
                    primaryList.Add(pe);
                }
            }

            //now add primaries to the selected list
            foreach (PartitionEntry pe in primaryList)
            {
                listboxPartitionList.SelectedItems.Add(pe);
            }
        }

        //clicked the "select all replica partitions" button
        public void UodbSelectReplicaClick(object sender, EventArgs ea)
        {
            listboxPartitionList.SelectedItems.Clear();

            //copy the list out first, since .NET does some strange things internally with the lests that break using a regular enumerator
            List<PartitionEntry> replicaList=new List<PartitionEntry>();

            foreach (PartitionEntry pe in listboxPartitionList.Items)
            {
                if (!pe.IsPrimary)
                {
                    replicaList.Add(pe);
                }
            }

            //now add primaries to the selected list
            foreach (PartitionEntry pe in replicaList)
            {
                listboxPartitionList.SelectedItems.Add(pe);
            }
        }

        //clicked the "select partition from a hash" button
        public void UodbSelectHashClick(object sender, EventArgs ea)
        {
            MessageBox.Show("TODO: Implement hash functionality.");
        }

        //the selected partitions changed
        public void PartitionListSelectionChanged(object sender, EventArgs ea)
        {
            butUODBExecute.Enabled=(listboxPartitionList.SelectedItems.Count>0);
        }

        //called when the buttons panel is resized
        public void ButtonsPanelResize(object sender, EventArgs ea)
        {
            //resize the buttons
            int width=(panelUODBButtons.Width-30)/2;
            butUODBSelectAll.Width=width;
            butUODBSelectPrimaries.Width=width;
            butUODBSelectReplicas.Width=width;
            butUODBSelectHash.Width=width;

            //right-anchoring the right-side buttons fails to preserve the space on resize.. so manually adjust location for those
            System.Drawing.Point tmpLoc=butUODBSelectPrimaries.Location;
            tmpLoc.X=panelUODBButtons.Width-10-butUODBSelectPrimaries.Width;
            butUODBSelectPrimaries.Location=tmpLoc;

            tmpLoc=butUODBSelectHash.Location;
            tmpLoc.X=panelUODBButtons.Width-10-butUODBSelectHash.Width;
            butUODBSelectHash.Location=tmpLoc;
        }

        //clicked the button to execute the query
        public void ExecuteQueryClick(object sender, EventArgs ea)
        {
            butUODBExecute.Enabled=false;

            //collect info for the execution
            RunWebstoreCommand rwc=new RunWebstoreCommand();
            if (textboxQuery.SelectedText.Length>0)
            {
                rwc.Query=textboxQuery.SelectedText;
            }
            else
            {
                rwc.Query=textboxQuery.Text;
            }

            rwc.buttonToEnableWhenComplete=butUODBExecute;

            List<PartitionEntry> parts=new List<PartitionEntry>();
            foreach (PartitionEntry pe in listboxPartitionList.SelectedItems)
            {
                parts.Add(pe);
            }

            rwc.Partitions=parts.ToArray();

            //run it
            ThreadMaker.CreateThread(rwc.Run).Start();
        }

        #endregion //Events

        //runs a sql command on a specific set of partitions
        class RunWebstoreCommand
        {
            public string Query;
            public PartitionEntry []Partitions;

            public Button buttonToEnableWhenComplete;

            //
            public void Run()
            {
                if (Partitions.Length<=0)
                {
                    ro.Error("No partitions selected to run against.");
                }
                else if (Query.Length<=0)
                {
                    ro.Error("No query given to run.");
                }
                else //try running it
                {
                    ro.Info("Running query against "+Partitions.Length+" partitions:\n"+Query);

                    try
                    {
                        WstConnection con=GetEnvironmentWstConnection();
                        con.Open();

                        //Run on each partition
                        foreach (PartitionEntry pe in Partitions)
                        {
                            try
                            {
                                ro.Info("");
                                ro.Info(pe.ToString()+":");

                                WstCommand cmd=GetPartitionWstCommand(con, pe);
                                cmd.CommandText=Query;
                                cmd.CommandTimeout=0; //do not timeout

                                using (WstDataReader reader=cmd.ExecuteReader())
                                {
                                    if (reader.Read())
                                    {
                                        //print header
                                        string header="";
                                        for (int field=0; field<reader.FieldCount; ++field)
                                        {
                                            if (header.Length>0)
                                            {
                                                header+="\t";
                                            }

                                            header+="["+reader.GetName(field)+"]";
                                        }
                                        ro.Info(header);

                                        //print results
                                        do
                                        {
                                            string row="";
                                            for (int field=0; field<reader.FieldCount; ++field)
                                            {
                                                if (row.Length>0)
                                                {
                                                    row+="\t";
                                                }

                                                object value=reader[field];
                                                if (value is byte[]) //special case, print out bytes instead
                                                {
                                                    row+="0x"+Hexer.tohex(value as byte[]);
                                                }
                                                else //default ToString()
                                                {
                                                    row+=value.ToString();
                                                }
                                            }
                                            ro.Info(row);
                                        } while (reader.Read());
                                    }

                                    if (reader.RecordsAffected>0)
                                    {
                                        ro.Info("Rows affected: "+reader.RecordsAffected);
                                    }
                                }
                            }
                            catch (Exception e)
                            {
                                ro.Error("Exception executing webstore command against "+pe+": "+e);
                            }
                        }

                        con.Close();
                    }
                    catch (Exception e)
                    {
                        ro.Error("Exception running webstore: "+e);
                    }
                }

                //re-enable execute button
                buttonToEnableWhenComplete.Invoke(new InvokeCode(delegate
                {
                    buttonToEnableWhenComplete.Enabled=true;
                }));
            }
        };
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\RegDB\RegTree.cs ===
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Text;
using System.Collections.Generic;
using System.Security.Permissions;

using ServerTestFramework;
using ServerTestFramework.Runner;

using ServerTestFramework.Reporting;

namespace STFGui.Plugins
{
    /// <summary>
    /// A single node in the regression tree.
    /// </summary>
    public class RegTreeNode: TreeNode
    {
        public string FullName
        {
            get
            {
                if (Parent==null)
                    return Name;
                else
                    return ((RegTreeNode)Parent).FullName+"."+Name;
            }
        }

        public int PassCount;
        public int TotalCount;
        public bool IsInLoadedSuite=false;
        public bool IsInRegDB=false;

        // --

        //ctor
        public RegTreeNode(TestNode node, bool addChildren)
        {
            Name=node.Name;
            IsInLoadedSuite=true;

            if (addChildren)
            {
                foreach (TestNode child in node.Children)
                {
                    if (child.FunctionalData!=null)
                    {
                        Nodes.Add(new RegTreeNode(child, true));
                    }
                }
            }

            UpdateNodeVisuals();
        }

        //ctor
        public RegTreeNode(string name)
        {
            Name=name;
        }

        //merge a node from the reg tree
        public void MergeRegNode(RegDBTreeReader.Node regRoot)
        {
            if (regRoot.Name!=Name)
            {
                return;
            }

            IsInRegDB=true;

            //merge children in
            foreach (RegDBTreeReader.Node regChild in regRoot.Children)
            {
                //see if I have a matching child
                RegTreeNode treeChild=null;
                foreach (RegTreeNode rtn in Nodes)
                {
                    if (rtn.Name==regChild.Name)
                    {
                        treeChild=rtn;
                        break;
                    }
                }

                //update that child
                if (treeChild==null) //no matching so add one
                {
                    RegTreeNode newChild=new RegTreeNode(regChild.Name);
                    Nodes.Add(newChild);
                    newChild.MergeRegNode(regChild);
                }
                else //update the matching child
                {
                    treeChild.MergeRegNode(regChild);
                }
            }

            UpdateNodeVisuals();
        }

        //Rebuilds the Text and other visual properties of the node
        public void UpdateNodeVisuals()
        {
            //rebuild Text
            Text="";
            if (TotalCount>0 && Nodes.Count>0)
            {
                Text="["+PassCount+"/"+TotalCount+"] ";
            }
            Text+=Name;

            //color of the text
            if (IsInLoadedSuite && IsInRegDB) ForeColor=Color.Black;
            else if (IsInLoadedSuite) ForeColor=Color.DarkBlue;
            else if (IsInRegDB) ForeColor=Color.DarkGray;
            else ForeColor=Color.Yellow; //should never happen

            //bgcolor
            if (TotalCount>0)
            {
                if (PassCount<TotalCount)
                    BackColor=Color.Red;
                else
                    BackColor=Color.LightGreen;
            }
            else
            {
                BackColor=Color.White;
            }
        }

        //crears the pass/fail numbers on the tree
        public void ClearPassFail()
        {
            PassCount=0;
            TotalCount=0;

            foreach (RegTreeNode n in Nodes)
            {
                n.ClearPassFail();
            }

            UpdateNodeVisuals();
        }

        //retrieves a flattened list of all leaf nodes
        public void GetLeaves(ref List<RegTreeNode> leafNodes)
        {
            if (Nodes.Count==0)
            {
                leafNodes.Add(this);
            }
            else
            {
                foreach (RegTreeNode tn in Nodes)
                {
                    tn.GetLeaves(ref leafNodes);
                }
            }
        }

        //adds pass/total count to me and parents
        public void AddPassTotal(int pass, int total)
        {
            PassCount+=pass;
            TotalCount+=total;
            UpdateNodeVisuals();

            if (Parent!=null)
            {
                ((RegTreeNode)Parent).AddPassTotal(pass, total);
            }
        }
    };

    /// <summary>
    /// The regression tree view.
    /// </summary>
    public class RegTreeView: TreeView
    {
        //public
        public int IterationID=-1; //set when the iteration ID changes

        //
        Form guiForm;

        public delegate void InvokeCode();

        //ctor
        public RegTreeView(Form ownerForm)
        {
            //
            CheckBoxes=false;
            ShowNodeToolTips=false;
            guiForm=ownerForm;

            //hook up events
            MouseDown+=Event_MouseDown;

            //add context menu
            ContextMenu=new ContextMenu();
            ContextMenu.Popup+=ContextHandler;
        }

        //merge a regdb tree into an already built tree
        public void MergeRegTree(RegDBTreeReader.Node regRoot)
        {
            //make the root if we don't have one
            if (Nodes.Count==0)
            {
                Nodes.Add(new RegTreeNode(regRoot.Name));
                Nodes[0].Name=regRoot.Name;
            }

            //now merge it in
            ((RegTreeNode)(Nodes[0])).MergeRegNode(regRoot);
        }

        //crears the pass/fail numbers on the tree
        public void ClearPassFail()
        {
            foreach (RegTreeNode n in Nodes)
            {
                n.ClearPassFail();
            }
        }

        //retrieves a flattened list of all leaf nodes
        public void GetLeaves(ref List<RegTreeNode> leafNodes)
        {
            foreach (RegTreeNode tn in Nodes)
            {
                tn.GetLeaves(ref leafNodes);
            }
        }

        #region Events

        //prevent expanding/collapsing by double click -- is there a better way?
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m)
        {
            if (m.Msg==515) //double click
            {
                if (CustomDoubleClick!=null)
                {
                    CustomDoubleClick();
                }
            }
            else
            {
                base.WndProc(ref m);
            }
        }
        public delegate void VoidCall();
        public event VoidCall CustomDoubleClick;

        //context menu handler
        private void ContextHandler(object sender, EventArgs e)
        {
            //wipe out old options
            Menu.MenuItemCollection mi=ContextMenu.MenuItems;
            mi.Clear();

            //
            if (SelectedNode==null)
            {
                return;
            }

            //add the options
            mi.Add("View Output", CtxMenu_ViewOutput);
            mi.Add("View History", CtxMenu_ViewHistory);
        }

        //context menu handler
        private void CtxMenu_ViewOutput(object sender, EventArgs args)
        {
            ShowOutputBox((RegTreeNode)SelectedNode);
        }

        private void CtxMenu_ViewHistory(object sender, EventArgs args)
        {
            ShowHistoryBox((RegTreeNode)SelectedNode);
        }

        //change the selected node anytime they click on a node in any way
        private void Event_MouseDown(object sender, MouseEventArgs e)
        {
            RegTreeNode node=(RegTreeNode)this.GetNodeAt(e.X, e.Y);
            SelectedNode=node;
        }

        #endregion

        //Pops up a window with output filtered from a specific node
        private void ShowOutputBox(RegTreeNode rtn)
        {
            if (rtn==null || IterationID==-1)
            {
                return;
            }

            //make form
            Form form=new Form();
            form.SetBounds(0,0,650,400,BoundsSpecified.Size);
            form.Text=rtn.FullName;
            form.FormBorderStyle=FormBorderStyle.Sizable;

            //add a "Loading..." label
            Label loading=new Label();
            loading.Text="Loading...";
            loading.Size=new System.Drawing.Size(60, 15);
            form.Controls.Add(loading);

            //add a stf output box to it
            StfTextBox box=new StfTextBox();
            box.Dock=DockStyle.Fill;
            form.Controls.Add(box);
            form.Show(guiForm);
            form.Refresh();

            //get the lines from RegDB and put them into the box
            try
            {
                RegDBInfo.GetNodeOutputToReportDestination(rtn.FullName, IterationID, box);
            }
            catch (Exception e)
            {
                box.Text+="\r\n\r\nException trying to retrieve history: "+e;
            }

            loading.Visible=false;
        }

        private void ShowHistoryBox(RegTreeNode rtn)
        {
            if (rtn==null)
            {
                return;
            }

            string name=rtn.FullName;
            ShowHistoryBoxForNode(name);
        }

        //Pops up a window with history for specific node
        public void ShowHistoryBoxForNode(string fullName)
        {
            //make form
            Form form=new Form();
            form.SetBounds(0,0,650,400,BoundsSpecified.Size);
            form.Text=fullName;
            form.FormBorderStyle=FormBorderStyle.Sizable;

            //add a "Loading..." label
            Label loading=new Label();
            loading.Text="Loading...";
            loading.Size=new System.Drawing.Size(60, 15);
            form.Controls.Add(loading);

            //add a stf output box to it
            StfTextBox box=new StfTextBox();
            box.Dock=DockStyle.Fill;
            form.Controls.Add(box);
            form.Show(guiForm);
            form.Refresh();

            //get the history
            RegDBInquirer.RegDBHistory[] history;
            try
            {
                history=RegDBInfo.GetNodeHistory(fullName);
            }
            catch (Exception e)
            {
                box.Text+="\r\n\r\nException trying to retrieve history: "+e;
                loading.Visible=false;
                return;
            }

            //format it out to the box
            if (history.Length==0)
            {
                box.Text="No History found for "+fullName;
            }
            else
            {
                box.Text="History for "+fullName+"\n\n";

                //heading
                box.Text+="Environment".PadRight(20);
                box.Text+="Build".PadRight(20);
                box.Text+="Pass/Total".PadRight(20);
                box.Text+="%Pass\n";

                box.Text+="-----------         "+"---------------     "+"-----------         "+"-----\n";

                //lines
                foreach (RegDBInquirer.RegDBHistory hist in history)
                {
                    box.Text+=hist.Environment.PadRight(20);

                    string build=hist.Build;
                    build+="."+hist.Iteration.ToString().PadLeft(4,'0');
                    box.Text+=build.PadRight(20);

                    box.Text+=(hist.Passed+"/"+(hist.Passed+hist.Failed)).PadRight(20);
                    if (hist.Passed+hist.Failed>0)
                    {
                        box.Text+=(100*hist.Passed/(hist.Passed+hist.Failed)).ToString()+"%\n";
                    }
                    else
                    {
                        box.Text+="\n";
                    }
                }
            }

            loading.Visible=false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\StressRunner\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\SporkfireMonitor\Monitor.cs ===
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;

namespace STFGui.Plugins
{
    public class MonitorPlugin : IPluginSetup, IPluginExtension<StressPlugin>
    {
        private Report Report = null;
        private StressPlugin StressPlugin = null;
        private bool Enabled = false;
        private string DataSource = "";
        private string InitialCatalog = "";
        private SqlConnection _MonitorConnection = null;
        private DateTime _last_connect_attempt = DateTime.MinValue;
        private double _reconnect_interval_in_secs = 60;
        private TimeSpan MonitorSpan = TimeSpan.Zero;
        private Timer MonitorTimer = null;
        private string MonitorInsertProc = "";
        private string SnapshotFile = "";
        private PerformanceCounter MonitorProcessorCounter = null;
        private PerformanceCounter MonitorMemoryCounter = null;

        private void StartMonitor()
        {
            SqlConnectionStringBuilder sqlsb = new SqlConnectionStringBuilder("Application Name=StfGui;Connect Timeout=15;Integrated Security=sspi;Connection Reset=false;Enlist=false;Min Pool Size=1;Max Pool Size=200;Pooling=True;MultipleActiveResultSets=true");
            sqlsb.DataSource = DataSource;
            sqlsb.InitialCatalog = InitialCatalog;
            MonitorConnection = new SqlConnection(sqlsb.ConnectionString);
            AttemptMonitorConnect();
            MonitorProcessorCounter = new System.Diagnostics.PerformanceCounter("Processor", "% Processor Time", "_Total", true);
            MonitorMemoryCounter = new System.Diagnostics.PerformanceCounter("Memory", "Available MBytes", true);
            MonitorTimer = new System.Threading.Timer(new System.Threading.TimerCallback(OnMonitor), null, TimeSpan.Zero, MonitorSpan);
        }

        /// <summary>
        /// A wrapper for _MonitorConnection that makes sure the connection is open before returning it.
        /// </summary>
        private SqlConnection MonitorConnection
        {
            get
            {
                if (_MonitorConnection != null)
                {
                    // MSDN:
                    // The connection to the data source is broken. This can occur only after the connection has been opened.
                    // A connection in this state may be closed and then re-opened.
                    if (_MonitorConnection.State == ConnectionState.Broken)
                    {
                        _MonitorConnection.Close();
                    }

                    if (_MonitorConnection.State == ConnectionState.Closed)
                    {
                        AttemptMonitorConnect();
                    }
                }

                return _MonitorConnection;
            }
            set
            {
                _MonitorConnection = value;
            }
        }

        private void AttemptMonitorConnect ()
        {
            DateTime now = DateTime.UtcNow;

            if (now.Subtract(_last_connect_attempt).TotalSeconds >= _reconnect_interval_in_secs)
            {
                _last_connect_attempt = now;

                try
                {
                    _MonitorConnection.Open();
                }
                catch (Exception e)
                {
                    Report.Debug("Error attempting to connect monitor to " + DataSource + ":\n" + e.ToString());
                }
            }
        }

        private void StopMonitor()
        {
            if (MonitorTimer != null)
            {
                // Kill the timer and wait until it has been properly disposed of
                System.Threading.WaitHandle wh = new System.Threading.AutoResetEvent(false);
                MonitorTimer.Dispose(wh);
                wh.WaitOne();
                MonitorTimer = null;
            }
            if (MonitorConnection != null)
            {
                // Send a message informing of the shutdown action
                SaveMonitorData("StfGui is shutting down...", false);

                // Now close the connection to the Sporkfire DB
                _MonitorConnection.Close();
                _MonitorConnection.Dispose();
                _MonitorConnection = null;
            }
            if (MonitorProcessorCounter != null)
            {
                MonitorProcessorCounter.Close();
                MonitorProcessorCounter.Dispose();
                MonitorProcessorCounter = null;
            }
            if (MonitorMemoryCounter != null)
            {
                MonitorMemoryCounter.Close();
                MonitorMemoryCounter.Dispose();
                MonitorMemoryCounter = null;
            }
        }

        private void OnMonitor(object state)
        {
            try
            {
                lock (MonitorTimer)
                {
                    SaveMonitorData(null, true);
                }
            }
            catch (Exception e)
            {
                 Report.Warn("{0} thrown while saving monitor data: {1}", e.GetType().FullName, e.Message);
            }
        }

        private void SaveMonitorData(string message, bool queryPlugins)
        {
            lock (this)
            {
                if (File.Exists(SnapshotFile))
                    File.Delete(SnapshotFile);

                using (FileStream stream = File.Open(SnapshotFile, FileMode.CreateNew, FileAccess.ReadWrite))
                {
                    XmlWriterSettings settings = new XmlWriterSettings();
                    settings.Indent = true;
                    XmlWriter writer = XmlWriter.Create(stream, settings);
                    writer.WriteStartElement("Monitor");
                    SaveMachineData(writer);
                    writer.WriteStartElement("StfGui");
                    if (queryPlugins)
                    {
                        SavePluginData(writer);
                    }
                    if (message != null)
                    {
                        writer.WriteElementString("Message", message);
                    }
                    writer.WriteEndElement(); // StfGui
                    writer.WriteEndElement(); // Monitor
                    writer.Flush();
                    // Save contents of stream to DB
                    stream.Seek(0, SeekOrigin.Begin);
                    using (StreamReader reader = new StreamReader(stream))
                    {
                        using (SqlCommand cmd = new SqlCommand())
                        {
                            cmd.Connection = MonitorConnection;
                            cmd.CommandText = MonitorInsertProc;
                            cmd.CommandType = CommandType.StoredProcedure;
                            cmd.Parameters.AddWithValue("@Machine", Environment.MachineName);
                            cmd.Parameters.AddWithValue("@Data", reader.ReadToEnd());
                            cmd.ExecuteNonQuery();
                        }
                    }
                }
            }
        }

        private void SaveMachineData(XmlWriter writer)
        {
            // Querying performance counters for process load and memory load.
            float cpuLoad = -1;
            float freeMemory = -1;
            try
            {
                cpuLoad = MonitorProcessorCounter.NextValue();
                freeMemory = MonitorMemoryCounter.NextValue();
            }
            catch (Exception e)
            {
                Report.Info("{0} thrown while querying performance counters for monitor data: {1}", e.GetType().FullName, e.Message);
            }
            // Writing machine-specific values to the XML.
            writer.WriteStartElement("Machine");
            writer.WriteElementString("Image", System.Diagnostics.Process.GetCurrentProcess().MainModule.FileName);
            writer.WriteElementString("StartTime", System.Diagnostics.Process.GetCurrentProcess().StartTime.ToString("G"));
            writer.WriteElementString("CPULoad", cpuLoad.ToString());
            writer.WriteElementString("FreeMemory", freeMemory.ToString());
            writer.WriteEndElement(); // Machine
        }

        private void SavePluginData(XmlWriter writer)
        {
            writer.WriteStartElement("Plugins");
            // Stress plugin
            if (StressPlugin != null)
            {
                writer.WriteStartElement("Plugin");
                writer.WriteAttributeString("Name", StressPlugin.GetType().FullName);
                StressPlugin.SaveMonitorData(writer);
                writer.WriteEndElement(); // Plugin
            }
            writer.WriteEndElement(); // Plugins
        }

        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            Report = new Report("Monitor");

            Enabled = XmlUtil.GetChildNodeValue(pluginSettings, "Enabled", false);
            MonitorSpan = TimeSpan.Parse(XmlUtil.GetChildNodeValue(pluginSettings, "Period", "00:00:05"));
            DataSource = XmlUtil.GetChildNodeValue(pluginSettings, "DataSource", "TSTLSWTTSQL001");
            InitialCatalog = XmlUtil.GetChildNodeValue(pluginSettings, "InitialCatalog", "Olympus.Server");
            MonitorInsertProc = XmlUtil.GetChildNodeValue(pluginSettings, "InsertProcName", "[dbo].[Microsoft.Xna.LiveServer.LS3i.OM.Machine.InsertOrUpdateData]");
            SnapshotFile = XmlUtil.GetChildNodeValue(pluginSettings, "SnapshotFile", "stress_snapshot.xml");

            if (Enabled)
            {
                StartMonitor();
            }
        }
        
        public void Shutdown(XmlNode pluginSettings)
        {
            XmlUtil.SetChildNodeValue(pluginSettings, "Enabled", Enabled);
            XmlUtil.SetChildNodeValue(pluginSettings, "Period", MonitorSpan.ToString());
            XmlUtil.SetChildNodeValue(pluginSettings, "DataSource", DataSource);
            XmlUtil.SetChildNodeValue(pluginSettings, "InitialCatalog", InitialCatalog);
            XmlUtil.SetChildNodeValue(pluginSettings, "InsertProcName", MonitorInsertProc);
            XmlUtil.SetChildNodeValue(pluginSettings, "SnapshotFile", SnapshotFile);

            if (Enabled)
            {
                StopMonitor();
            }
        }

        public void PluginLoaded(StressPlugin plugin)
        {
            StressPlugin = plugin;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\StressRunner\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\TestDB\makefile.inc ===
!INCLUDE $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\StressRunner\StressColumnChooser.Designer.cs ===
namespace STFGui.Plugins.StressRunner
{
    partial class StressColumnChooser
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.clbColumns = new System.Windows.Forms.CheckedListBox();
            this.btnCancel = new System.Windows.Forms.Button();
            this.btnOK = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // clbColumns
            // 
            this.clbColumns.CheckOnClick = true;
            this.clbColumns.FormattingEnabled = true;
            this.clbColumns.Location = new System.Drawing.Point(12, 12);
            this.clbColumns.Name = "clbColumns";
            this.clbColumns.Size = new System.Drawing.Size(215, 304);
            this.clbColumns.TabIndex = 0;
            this.clbColumns.ItemCheck += new System.Windows.Forms.ItemCheckEventHandler(this.clbColumns_ItemCheck);
            // 
            // btnCancel
            // 
            this.btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
            this.btnCancel.Location = new System.Drawing.Point(152, 330);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(75, 23);
            this.btnCancel.TabIndex = 2;
            this.btnCancel.Text = "Cancel";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            // 
            // btnOK
            // 
            this.btnOK.Location = new System.Drawing.Point(71, 330);
            this.btnOK.Name = "btnOK";
            this.btnOK.Size = new System.Drawing.Size(75, 23);
            this.btnOK.TabIndex = 1;
            this.btnOK.Text = "OK";
            this.btnOK.UseVisualStyleBackColor = true;
            this.btnOK.Click += new System.EventHandler(this.btnOK_Click);
            // 
            // StressColumnChooser
            // 
            this.AcceptButton = this.btnOK;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.CancelButton = this.btnCancel;
            this.ClientSize = new System.Drawing.Size(239, 365);
            this.Controls.Add(this.btnOK);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.clbColumns);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "StressColumnChooser";
            this.Text = "Choose Columns...";
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.CheckedListBox clbColumns;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.Button btnOK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\TestDB\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\StressRunner\Stress.cs ===
using System;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Plugins;
using ServerTestFramework.Utilities;

namespace STFGui.Plugins
{
    public class StressPlugin : IPluginSetup, IPluginModuleLoadNotification, IPluginGui
    {
        protected STFGui.Plugins.StressRunner.StressControl _stress_control = null;

        private bool _autostart = false;
        private string _autoconfig = null;
        private string _autoresults = null;
        private TimeSpan _autoruntime = TimeSpan.Zero;
        private TimeSpan _autocooldown = TimeSpan.Zero;
        private TimeSpan _autowarmup = TimeSpan.Zero;

        FileReportDestination _logDestination = null;
        XmlFileReportDestination _xmlDestination = null;

        // Not thread safe, but should be just fine.
        public STFGui.Plugins.StressRunner.StressControl StressControl
        {
            get
            {
                if (_stress_control == null)
                {
                    _stress_control = new STFGui.Plugins.StressRunner.StressControl(GuiHooks);
                }

                return _stress_control;
            }
        }

        public MainGuiHooks GuiHooks { get; set; }

        //Returns the TabPage to add to the gui.
        public TabPage GetNewTabPage()
        {
            TabPage page = new TabPage();

            page.Text="Stress";

            StressControl.Dock = DockStyle.Fill;
            page.Controls.Add(StressControl);

            return page;
        }

        public MenuItem GetNewMenu()
        {
            MenuItem menu = new MenuItem("Stress");

            MenuItem next = new MenuItem("Save Stress Settings...");
            next.Click += new EventHandler(saveClick);
            menu.MenuItems.Add(next);

            next = new MenuItem("Load Stress Settings...");
            next.Click += new EventHandler(loadClick);
            menu.MenuItems.Add(next);

            next = new MenuItem("-");
            menu.MenuItems.Add(next);

            next = new MenuItem("Zero All Stress Targets");
            next.Click += new EventHandler(zeroClick);
            menu.MenuItems.Add(next);

            next = new MenuItem("Reset All Stress Results");
            next.Click += new EventHandler(resetClick);
            menu.MenuItems.Add(next);

            next = new MenuItem("Enable Performance Counters");
            next.Click += new EventHandler(perfCountersClick);
            menu.MenuItems.Add(next);
            StressControl.PerfCounterMenuItem = next;

            next = new MenuItem("-");
            menu.MenuItems.Add(next);

            StressControl.miSkipPreRun=new MenuItem("Skip PreRun");
            StressControl.miSkipPreRun.Click+=new EventHandler(menuClickPrePost);
            menu.MenuItems.Add(StressControl.miSkipPreRun);

            StressControl.miSkipPostRun=new MenuItem("Skip PostRun");
            StressControl.miSkipPostRun.Click+=new EventHandler(menuClickPrePost);
            menu.MenuItems.Add(StressControl.miSkipPostRun);

            return menu;
        }

        public void OnGuiShown()
        {
            if (_autostart)
            {
                if (_autoconfig != null)
                {
                    loadSettingsFile(_autoconfig);
                }
                
                if (_autowarmup.TotalMilliseconds > 0)
                {
                    StressControl.Report.Info("Automated stress run will start in: {0}", _autowarmup);
                    System.Threading.Timer t = new System.Threading.Timer(new System.Threading.TimerCallback(StartAutomatedRun));
                    t.Change(_autowarmup, TimeSpan.Zero);
                }
                else
                {
                    StressControl.Report.Info("Starting automated stress run");
                    _stress_control.Start();
                }

                if (_autoruntime.TotalMilliseconds > 0)
                {
                    _autoruntime += _autowarmup;
                    System.Threading.Timer t = new System.Threading.Timer(new System.Threading.TimerCallback(EndAutomatedRun));
                    t.Change(_autoruntime, TimeSpan.Zero);
                }
            }
        }

        private void StartAutomatedRun(object state)
        {
            System.Threading.Timer t = (System.Threading.Timer)state;
            t.Dispose();

            StressControl.Report.Info("Starting automated stress run");
            _stress_control.Start();
        }

        private void EndAutomatedRun(object state)
        {
            System.Threading.Timer t = (System.Threading.Timer)state;
            t.Dispose();

            // If the user happened to manually stop the run and/or close the main window, don't do anything
            if (_stress_control != null && _stress_control.IsRunning)
            {
                _stress_control.Stop();

                if (_autocooldown.TotalMilliseconds > 0)
                {
                    System.Threading.Thread.Sleep(_autocooldown);
                }

                if (_autoresults != null)
                {
                    try
                    {
                        XmlWriterSettings settings = new XmlWriterSettings();
                        settings.CloseOutput = true;
                        settings.Encoding = System.Text.Encoding.UTF8;
                        settings.CheckCharacters = false;

                        XmlWriter writer = XmlWriter.Create(_autoresults, settings);
                        writer.WriteStartElement("StressResults");
                        _stress_control.WriteJobsResults(writer);
                        writer.WriteEndElement();

                        writer.Flush();
                        writer.Close();
                    }
                    catch (Exception e)
                    {
                        StressControl.Report.Fatal(
                            "Failed to save the results XML to {0}, exception {1} thrown. Details:\n{2}", 
                            _autoresults, 
                            e.GetType().FullName, 
                            e);
                    }
                }

                Application.Exit();
            }
        }

        public void SaveMonitorData(XmlWriter writer)
        {
            StressControl.SaveMonitorData(writer);
        }

        private void saveClick(object sender, EventArgs e)
        {
            try
            {
                string file = GuiCommon.ChooseFile(true, 
                    "Stress files (*.stress_xml)|*.stress_xml|All files (*.*)|*.*");

                if (file != null)
                {
                    XmlDocument doc = new XmlDocument();
                    doc.AppendChild(doc.CreateElement("StressSettings"));
                    StressControl.SaveStressSettings(doc.FirstChild);
                    doc.Save(file);
                }

                StressControl.Report.Info("Stress settings file '{0}' saved", file);
            }
            catch (Exception exc)
            {
                StressControl.Report.Error("Error saving stress settings file:\n" + exc.ToString());
            }
        }

        private void loadClick(object sender, EventArgs e)
        {
            try
            {
                string file = GuiCommon.ChooseFile(false, 
                    "Stress files (*.stress_xml)|*.stress_xml|All files (*.*)|*.*");

                if (file != null)
                {
                    loadSettingsFile(file);
                }
            }
            catch (Exception exc)
            {
                StressControl.Report.Error("Error loading stress settings file:\n" + exc.ToString());
            }
        }

        private void zeroClick(object sender, EventArgs e)
        {
            try
            {
                StressControl.ZeroStressTargets();
            }
            catch (Exception exc)
            {
                StressControl.Report.Error("Error zeroing stress targets:\n" + exc.ToString());
            }
        }

        private void resetClick(object sender, EventArgs e)
        {
            try
            {
                StressControl.ResetStressResults();
            }
            catch (Exception exc)
            {
                StressControl.Report.Error("Error reseting stress results:\n" + exc.ToString());
            }
        }

        private void perfCountersClick (object sender, EventArgs e)
        {
            try
            {
                StressControl.PerfCountersEnabled = !StressControl.PerfCountersEnabled;
            }
            catch (Exception exc)
            {
                StressControl.Report.Error("Error changing perf counter status:\n" + exc.ToString());
            }
        }

        private void menuClickPrePost (object sender, EventArgs e)
        {
            try
            {
                MenuItem mi=(MenuItem)sender;
                mi.Checked=!mi.Checked;

                StressControl.SyncSchedulerSettingsToUI();
            }
            catch (Exception exc)
            {
                StressControl.Report.Error("Error updating pre/post skip setting:\n"+exc);
            }
        }

        private void loadSettingsFile(string filename)
        {
            try
            {
                XmlDocument doc = new XmlDocument();
                doc.Load(filename);

                if (doc.FirstChild.Name != "StressSettings")
                {
                    StressControl.Report.Error("Root node of '{0}' is not 'StressSettings', not loading", filename);
                    return;
                }

                StressControl.LoadSettings(doc.FirstChild);

                StressControl.Report.Info("Stress settings file '{0}' loaded", filename);
            }
            catch (Exception exc)
            {
                StressControl.Report.Error("Error loading stress settings file:\n" + exc.ToString());
            }
        }

        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            StressControl.LoadSchedulers();
            StressControl.LoadSettings(pluginSettings);

            // load xml config from commandline
            string[] cmdParams = System.Environment.GetCommandLineArgs();
            for (int i = 1; i < cmdParams.Length; ++i)
            {
                string param = cmdParams[i];

                if (param.ToLower().EndsWith(".stress_xml"))
                {
                    loadSettingsFile(param);
                }
            }

            //commandline, if we ever want that
            if (commandlineParameters.Length>0)
            {
                StressControl.Report.Debug("Yo... ... I got no idea what you're talkin' about.  All "+commandlineParameters.Length+" of you.");
            }

            XmlNode automationNode = pluginSettings.SelectSingleNode("Automation");

            if (automationNode != null)
            {
                _autostart = XmlUtil.GetChildNodeValue(automationNode, "Enabled", false);

                if (_autostart)
                {
                    _autoruntime = TimeSpan.Parse(XmlUtil.GetChildNodeValue(automationNode, "RunTime", "00:00:00"));
                    _autowarmup = TimeSpan.Parse(XmlUtil.GetChildNodeValue(automationNode, "WarmUpTime", "00:00:05"));
                    _autocooldown = TimeSpan.Parse(XmlUtil.GetChildNodeValue(automationNode, "CoolDownTime", "00:00:00"));
                    _autoconfig = XmlUtil.GetChildNodeValue(automationNode, "ConfigurationFile", null);
                    _autoresults = XmlUtil.GetChildNodeValue(automationNode, "ResultsFile", null);
                    long resultsFileSizeLimit = XmlUtil.GetChildNodeValue(automationNode, "ResultsFileSizeLimit", (long)-1);

                    string logFile = XmlUtil.GetChildNodeValue(automationNode, "LogFile", null);
                    if (logFile != null)
                    {
                        try
                        {
                            _logDestination = new FileReportDestination(logFile);
                            _logDestination.OutputLimitInBytes = resultsFileSizeLimit;
                            Report.GetRoot().AddReportDestination(_logDestination);
                        }
                        catch (System.Exception e)
                        {
                            StressControl.Report.Fatal("Failed to add File Report Destination for stress automation: "+logFile+"\n"+e);
                        }
                    }

                    string xmlLogFile = XmlUtil.GetChildNodeValue(automationNode, "XmlLogFile", null);
                    if (xmlLogFile != null)
                    {
                        _xmlDestination = new XmlFileReportDestination(xmlLogFile);
                        Report.GetRoot().AddReportDestination(_xmlDestination);
                    }
                }
            }
        }

        public void Shutdown(XmlNode pluginSettings)
        {
            if (_logDestination != null)
            {
                Report.GetRoot().RemoveReportDestination(_logDestination);
                _logDestination.Close();
            }

            if (_xmlDestination != null)
            {
                _xmlDestination.FinishXml();
                Report.GetRoot().RemoveReportDestination(_xmlDestination);
                _xmlDestination.Close();
            }

            StressControl.Stop();
            StressControl.SaveMainSettings(pluginSettings);
        }

        //called when a module is about to be loaded
        public void ModuleLoading(string fileName)
        {
        }

        public void SuiteLoaded(TestNode rootNode)
        {
            StressControl.AddRootNode(rootNode);
        }

        //called when suite is being unloaded
        public void SuiteUnloading(TestNode rootNode)
        {
            StressControl.RemoveRootNode(rootNode);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\TestDB\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\StressRunner\StressColumnChooser.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;

using ServerTestFramework.Runner;

namespace STFGui.Plugins.StressRunner
{
    public partial class StressColumnChooser : Form
    {
        public StressColumnChooser()
        {
            InitializeComponent();
        }

        private IEnumerable<StressColumn> _columns = null;

        public IEnumerable<StressColumn> Columns
        {
            get { return _columns; }
            set
            {
                _columns = value;

                clbColumns.BeginUpdate();

                try
                {
                    clbColumns.Items.Clear();

                    foreach (StressColumn sc in value)
                    {
                        if (sc.Visible)
                        {
                            clbColumns.Items.Add(sc, true);
                        }
                    }

                    foreach (StressColumn sc in value)
                    {
                        if (!sc.Visible)
                        {
                            clbColumns.Items.Add(sc, false);
                        }
                    }
                }
                finally
                {
                    clbColumns.EndUpdate();
                }
            }
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            DialogResult = DialogResult.Cancel;
        }

        private void btnOK_Click(object sender, EventArgs e)
        {
            for (int i = 0; i < clbColumns.Items.Count; ++i)
            {
                ((StressColumn)clbColumns.Items[i]).Visible = clbColumns.GetItemChecked(i);
            }

            DialogResult = DialogResult.OK;
        }

        private void clbColumns_ItemCheck(object sender, ItemCheckEventArgs e)
        {
            StressColumn temp = (StressColumn)clbColumns.Items[e.Index];

            if (temp.Required && e.NewValue != CheckState.Checked)
            {
                e.NewValue = CheckState.Checked;
            }
        }
    }

    public class StressColumn
    {
        public delegate void UpdateItemDelegate(ListViewItem item, int subitem, StressJob job);

        public string Name;
        public bool Required, Visible, Special;
        public UpdateItemDelegate UpdateItem;

        public StressColumn(string name, bool required, bool visible, bool special, UpdateItemDelegate update)
        {
            Name = name;
            Required = required;
            Visible = visible;
            Special = special;
            UpdateItem = update;
        }

        private ColumnHeader _Header;
        public ColumnHeader Header
        {
            get
            {
                if (_Header == null)
                {
                    ColumnHeader temp = new ColumnHeader();
                    temp.Text = Name;
                    _Header = temp;
                }

                return _Header;
            }
        }

        public bool Updatable { get { return (UpdateItem != null); } }

        public override string ToString()
        {
            return Name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\StressRunner\StressControl.Designer.cs ===
namespace STFGui.Plugins.StressRunner
{
    partial class StressControl
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.Panel pnlDetails;
            System.Windows.Forms.GroupBox grpDetails;
            System.Windows.Forms.GroupBox groupBox3;
            System.Windows.Forms.Label label14;
            System.Windows.Forms.Label label13;
            System.Windows.Forms.Label label12;
            System.Windows.Forms.Label label11;
            System.Windows.Forms.Label label10;
            System.Windows.Forms.GroupBox groupBox2;
            System.Windows.Forms.Label label8;
            System.Windows.Forms.Label label7;
            System.Windows.Forms.GroupBox groupBox1;
            System.Windows.Forms.Label label9;
            System.Windows.Forms.Label label6;
            System.Windows.Forms.Label label5;
            System.Windows.Forms.Label label4;
            System.Windows.Forms.Label label3;
            System.Windows.Forms.Label label1;
            System.Windows.Forms.ToolStripMenuItem mniSizeAllToFit;
            System.Windows.Forms.ToolStripMenuItem mniMore;
            System.Windows.Forms.ToolStripSeparator cmsColumnsSep1;
            System.Windows.Forms.ToolStripSeparator cmsColumnsSep2;
            this.txtScale = new System.Windows.Forms.TextBox();
            this.lblTotalTPS = new System.Windows.Forms.Label();
            this.lblPrivateTPS = new System.Windows.Forms.Label();
            this.lblTPS_120 = new System.Windows.Forms.Label();
            this.lblTPS_20 = new System.Windows.Forms.Label();
            this.lblTPS_5 = new System.Windows.Forms.Label();
            this.lblThreads = new System.Windows.Forms.Label();
            this.lblInProgress = new System.Windows.Forms.Label();
            this.lblRate = new System.Windows.Forms.Label();
            this.lblFail = new System.Windows.Forms.Label();
            this.lblSkip = new System.Windows.Forms.Label();
            this.lblDeadlock = new System.Windows.Forms.Label();
            this.lblPass = new System.Windows.Forms.Label();
            this.lblDetailsScaleName = new System.Windows.Forms.Label();
            this.lblTests = new System.Windows.Forms.Label();
            this.grpScheduler = new System.Windows.Forms.GroupBox();
            this.cmbScheduler = new System.Windows.Forms.ComboBox();
            this.splMain = new System.Windows.Forms.SplitContainer();
            this.chkStopTime = new System.Windows.Forms.CheckBox();
            this.dtpStopTime = new System.Windows.Forms.DateTimePicker();
            this.btnStartStop = new System.Windows.Forms.Button();
            this.lstJobs = new System.Windows.Forms.ListView();
            this.cmsColumns = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.tmrTick = new System.Windows.Forms.Timer(this.components);
            this.tltMain = new System.Windows.Forms.ToolTip(this.components);
            pnlDetails = new System.Windows.Forms.Panel();
            grpDetails = new System.Windows.Forms.GroupBox();
            groupBox3 = new System.Windows.Forms.GroupBox();
            label14 = new System.Windows.Forms.Label();
            label13 = new System.Windows.Forms.Label();
            label12 = new System.Windows.Forms.Label();
            label11 = new System.Windows.Forms.Label();
            label10 = new System.Windows.Forms.Label();
            groupBox2 = new System.Windows.Forms.GroupBox();
            label8 = new System.Windows.Forms.Label();
            label7 = new System.Windows.Forms.Label();
            groupBox1 = new System.Windows.Forms.GroupBox();
            label9 = new System.Windows.Forms.Label();
            label6 = new System.Windows.Forms.Label();
            label5 = new System.Windows.Forms.Label();
            label4 = new System.Windows.Forms.Label();
            label3 = new System.Windows.Forms.Label();
            label1 = new System.Windows.Forms.Label();
            mniSizeAllToFit = new System.Windows.Forms.ToolStripMenuItem();
            mniMore = new System.Windows.Forms.ToolStripMenuItem();
            cmsColumnsSep1 = new System.Windows.Forms.ToolStripSeparator();
            cmsColumnsSep2 = new System.Windows.Forms.ToolStripSeparator();
            pnlDetails.SuspendLayout();
            grpDetails.SuspendLayout();
            groupBox3.SuspendLayout();
            groupBox2.SuspendLayout();
            groupBox1.SuspendLayout();
            this.splMain.Panel1.SuspendLayout();
            this.splMain.Panel2.SuspendLayout();
            this.splMain.SuspendLayout();
            this.cmsColumns.SuspendLayout();
            this.SuspendLayout();
            // 
            // pnlDetails
            // 
            pnlDetails.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Right)));
            pnlDetails.BackColor = System.Drawing.Color.LightGray;
            pnlDetails.Controls.Add(grpDetails);
            pnlDetails.Location = new System.Drawing.Point(415, 0);
            pnlDetails.Margin = new System.Windows.Forms.Padding(0);
            pnlDetails.Name = "pnlDetails";
            pnlDetails.Size = new System.Drawing.Size(153, 454);
            pnlDetails.TabIndex = 1;
            // 
            // grpDetails
            // 
            grpDetails.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            grpDetails.Controls.Add(this.txtScale);
            grpDetails.Controls.Add(groupBox3);
            grpDetails.Controls.Add(groupBox2);
            grpDetails.Controls.Add(groupBox1);
            grpDetails.Controls.Add(this.lblDetailsScaleName);
            grpDetails.Controls.Add(this.lblTests);
            grpDetails.Controls.Add(label1);
            grpDetails.Location = new System.Drawing.Point(3, 3);
            grpDetails.Name = "grpDetails";
            grpDetails.Size = new System.Drawing.Size(147, 446);
            grpDetails.TabIndex = 2;
            grpDetails.TabStop = false;
            grpDetails.Text = "Details";
            // 
            // txtScale
            // 
            this.txtScale.Enabled = false;
            this.txtScale.Location = new System.Drawing.Point(49, 64);
            this.txtScale.MaxLength = 20;
            this.txtScale.Name = "txtScale";
            this.txtScale.Size = new System.Drawing.Size(92, 20);
            this.txtScale.TabIndex = 18;
            this.txtScale.TextChanged += new System.EventHandler(this.txtScale_TextChanged);
            this.txtScale.KeyDown += new System.Windows.Forms.KeyEventHandler(this.txtScale_KeyDown);
            this.txtScale.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.txtScale_KeyPress);
            // 
            // groupBox3
            // 
            groupBox3.Controls.Add(this.lblTotalTPS);
            groupBox3.Controls.Add(this.lblPrivateTPS);
            groupBox3.Controls.Add(this.lblTPS_120);
            groupBox3.Controls.Add(this.lblTPS_20);
            groupBox3.Controls.Add(this.lblTPS_5);
            groupBox3.Controls.Add(label14);
            groupBox3.Controls.Add(label13);
            groupBox3.Controls.Add(label12);
            groupBox3.Controls.Add(label11);
            groupBox3.Controls.Add(label10);
            groupBox3.Location = new System.Drawing.Point(6, 266);
            groupBox3.Name = "groupBox3";
            groupBox3.Size = new System.Drawing.Size(135, 108);
            groupBox3.TabIndex = 17;
            groupBox3.TabStop = false;
            groupBox3.Text = "TPS";
            // 
            // lblTotalTPS
            // 
            this.lblTotalTPS.Location = new System.Drawing.Point(75, 88);
            this.lblTotalTPS.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblTotalTPS.Name = "lblTotalTPS";
            this.lblTotalTPS.Size = new System.Drawing.Size(54, 13);
            this.lblTotalTPS.TabIndex = 21;
            this.lblTotalTPS.Text = "-";
            // 
            // lblPrivateTPS
            // 
            this.lblPrivateTPS.Location = new System.Drawing.Point(75, 70);
            this.lblPrivateTPS.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblPrivateTPS.Name = "lblPrivateTPS";
            this.lblPrivateTPS.Size = new System.Drawing.Size(54, 13);
            this.lblPrivateTPS.TabIndex = 20;
            this.lblPrivateTPS.Text = "-";
            // 
            // lblTPS_120
            // 
            this.lblTPS_120.Location = new System.Drawing.Point(75, 52);
            this.lblTPS_120.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblTPS_120.Name = "lblTPS_120";
            this.lblTPS_120.Size = new System.Drawing.Size(54, 13);
            this.lblTPS_120.TabIndex = 19;
            this.lblTPS_120.Text = "-";
            // 
            // lblTPS_20
            // 
            this.lblTPS_20.Location = new System.Drawing.Point(75, 34);
            this.lblTPS_20.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblTPS_20.Name = "lblTPS_20";
            this.lblTPS_20.Size = new System.Drawing.Size(54, 13);
            this.lblTPS_20.TabIndex = 18;
            this.lblTPS_20.Text = "-";
            // 
            // lblTPS_5
            // 
            this.lblTPS_5.Location = new System.Drawing.Point(75, 16);
            this.lblTPS_5.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblTPS_5.Name = "lblTPS_5";
            this.lblTPS_5.Size = new System.Drawing.Size(54, 13);
            this.lblTPS_5.TabIndex = 17;
            this.lblTPS_5.Text = "-";
            // 
            // label14
            // 
            label14.AutoSize = true;
            label14.Location = new System.Drawing.Point(15, 88);
            label14.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label14.Name = "label14";
            label14.Size = new System.Drawing.Size(58, 13);
            label14.TabIndex = 16;
            label14.Text = "Total TPS:";
            this.tltMain.SetToolTip(label14, "The average TPS of the tests over the entire time that they have been running.");
            // 
            // label13
            // 
            label13.AutoSize = true;
            label13.Location = new System.Drawing.Point(6, 70);
            label13.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label13.Name = "label13";
            label13.Size = new System.Drawing.Size(67, 13);
            label13.TabIndex = 15;
            label13.Text = "Private TPS:";
            this.tltMain.SetToolTip(label13, "The average TPS over the last 20 seconds, including skipped tests.");
            // 
            // label12
            // 
            label12.AutoSize = true;
            label12.Location = new System.Drawing.Point(18, 52);
            label12.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label12.Name = "label12";
            label12.Size = new System.Drawing.Size(55, 13);
            label12.TabIndex = 14;
            label12.Text = "TPS(120):";
            this.tltMain.SetToolTip(label12, "The average TPS over the last 120 seconds.");
            // 
            // label11
            // 
            label11.AutoSize = true;
            label11.Location = new System.Drawing.Point(24, 34);
            label11.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label11.Name = "label11";
            label11.Size = new System.Drawing.Size(49, 13);
            label11.TabIndex = 13;
            label11.Text = "TPS(20):";
            this.tltMain.SetToolTip(label11, "The average TPS over the last 20 seconds.");
            // 
            // label10
            // 
            label10.AutoSize = true;
            label10.Location = new System.Drawing.Point(30, 16);
            label10.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label10.Name = "label10";
            label10.Size = new System.Drawing.Size(43, 13);
            label10.TabIndex = 12;
            label10.Text = "TPS(5):";
            this.tltMain.SetToolTip(label10, "The average TPS over the last 5 seconds.");
            // 
            // groupBox2
            // 
            groupBox2.Controls.Add(this.lblThreads);
            groupBox2.Controls.Add(this.lblInProgress);
            groupBox2.Controls.Add(label8);
            groupBox2.Controls.Add(label7);
            groupBox2.Location = new System.Drawing.Point(6, 205);
            groupBox2.Name = "groupBox2";
            groupBox2.Size = new System.Drawing.Size(135, 55);
            groupBox2.TabIndex = 11;
            groupBox2.TabStop = false;
            groupBox2.Text = "Threading";
            // 
            // lblThreads
            // 
            this.lblThreads.Location = new System.Drawing.Point(75, 34);
            this.lblThreads.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblThreads.Name = "lblThreads";
            this.lblThreads.Size = new System.Drawing.Size(54, 13);
            this.lblThreads.TabIndex = 11;
            this.lblThreads.Text = "-";
            // 
            // lblInProgress
            // 
            this.lblInProgress.Location = new System.Drawing.Point(75, 16);
            this.lblInProgress.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblInProgress.Name = "lblInProgress";
            this.lblInProgress.Size = new System.Drawing.Size(54, 13);
            this.lblInProgress.TabIndex = 10;
            this.lblInProgress.Text = "-";
            // 
            // label8
            // 
            label8.AutoSize = true;
            label8.Location = new System.Drawing.Point(20, 34);
            label8.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label8.Name = "label8";
            label8.Size = new System.Drawing.Size(49, 13);
            label8.TabIndex = 9;
            label8.Text = "Threads:";
            this.tltMain.SetToolTip(label8, "The number of threads managed by the scheduler in use by the tests.");
            // 
            // label7
            // 
            label7.AutoSize = true;
            label7.Location = new System.Drawing.Point(6, 16);
            label7.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label7.Name = "label7";
            label7.Size = new System.Drawing.Size(63, 13);
            label7.TabIndex = 8;
            label7.Text = "In Progress:";
            this.tltMain.SetToolTip(label7, "The total number of tests that are in progress.");
            // 
            // groupBox1
            // 
            groupBox1.Controls.Add(this.lblRate);
            groupBox1.Controls.Add(this.lblFail);
            groupBox1.Controls.Add(this.lblSkip);
            groupBox1.Controls.Add(this.lblDeadlock);
            groupBox1.Controls.Add(this.lblPass);
            groupBox1.Controls.Add(label9);
            groupBox1.Controls.Add(label6);
            groupBox1.Controls.Add(label5);
            groupBox1.Controls.Add(label4);
            groupBox1.Controls.Add(label3);
            groupBox1.Location = new System.Drawing.Point(6, 91);
            groupBox1.Name = "groupBox1";
            groupBox1.Size = new System.Drawing.Size(135, 108);
            groupBox1.TabIndex = 10;
            groupBox1.TabStop = false;
            groupBox1.Text = "Results";
            // 
            // lblRate
            // 
            this.lblRate.Location = new System.Drawing.Point(68, 88);
            this.lblRate.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblRate.Name = "lblRate";
            this.lblRate.Size = new System.Drawing.Size(61, 13);
            this.lblRate.TabIndex = 13;
            this.lblRate.Text = "-";
            // 
            // lblFail
            // 
            this.lblFail.Location = new System.Drawing.Point(68, 34);
            this.lblFail.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblFail.Name = "lblFail";
            this.lblFail.Size = new System.Drawing.Size(61, 13);
            this.lblFail.TabIndex = 12;
            this.lblFail.Text = "-";
            // 
            // lblSkip
            // 
            this.lblSkip.Location = new System.Drawing.Point(68, 70);
            this.lblSkip.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblSkip.Name = "lblSkip";
            this.lblSkip.Size = new System.Drawing.Size(61, 13);
            this.lblSkip.TabIndex = 11;
            this.lblSkip.Text = "-";
            // 
            // lblDeadlock
            // 
            this.lblDeadlock.Location = new System.Drawing.Point(68, 52);
            this.lblDeadlock.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblDeadlock.Name = "lblDeadlock";
            this.lblDeadlock.Size = new System.Drawing.Size(61, 13);
            this.lblDeadlock.TabIndex = 10;
            this.lblDeadlock.Text = "-";
            // 
            // lblPass
            // 
            this.lblPass.Location = new System.Drawing.Point(68, 16);
            this.lblPass.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            this.lblPass.Name = "lblPass";
            this.lblPass.Size = new System.Drawing.Size(61, 13);
            this.lblPass.TabIndex = 9;
            this.lblPass.Text = "-";
            // 
            // label9
            // 
            label9.AutoSize = true;
            label9.Location = new System.Drawing.Point(29, 88);
            label9.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label9.Name = "label9";
            label9.Size = new System.Drawing.Size(33, 13);
            label9.TabIndex = 8;
            label9.Text = "Rate:";
            this.tltMain.SetToolTip(label9, "The percentage rate at which tests have passed when compared to the total (not co" +
                    "unting skipped tests).");
            // 
            // label6
            // 
            label6.AutoSize = true;
            label6.Location = new System.Drawing.Point(31, 70);
            label6.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label6.Name = "label6";
            label6.Size = new System.Drawing.Size(31, 13);
            label6.TabIndex = 7;
            label6.Text = "Skip:";
            this.tltMain.SetToolTip(label6, "The number of tests that have run and reported \'Not Executed\'.");
            // 
            // label5
            // 
            label5.AutoSize = true;
            label5.Location = new System.Drawing.Point(6, 52);
            label5.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label5.Name = "label5";
            label5.Size = new System.Drawing.Size(56, 13);
            label5.TabIndex = 6;
            label5.Text = "Deadlock:";
            this.tltMain.SetToolTip(label5, "The number of tests that have been aborted due to a perceived deadlock.");
            // 
            // label4
            // 
            label4.AutoSize = true;
            label4.Location = new System.Drawing.Point(36, 34);
            label4.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label4.Name = "label4";
            label4.Size = new System.Drawing.Size(26, 13);
            label4.TabIndex = 5;
            label4.Text = "Fail:";
            this.tltMain.SetToolTip(label4, "The number of tests that have run and failed.");
            // 
            // label3
            // 
            label3.AutoSize = true;
            label3.Location = new System.Drawing.Point(29, 16);
            label3.Margin = new System.Windows.Forms.Padding(3, 0, 3, 5);
            label3.Name = "label3";
            label3.Size = new System.Drawing.Size(33, 13);
            label3.TabIndex = 4;
            label3.Text = "Pass:";
            this.tltMain.SetToolTip(label3, "The number of tests that have run and passed.");
            // 
            // lblDetailsScaleName
            // 
            this.lblDetailsScaleName.AutoSize = true;
            this.lblDetailsScaleName.Location = new System.Drawing.Point(6, 67);
            this.lblDetailsScaleName.Name = "lblDetailsScaleName";
            this.lblDetailsScaleName.Size = new System.Drawing.Size(37, 13);
            this.lblDetailsScaleName.TabIndex = 2;
            this.lblDetailsScaleName.Text = "Scale:";
            // 
            // lblTests
            // 
            this.lblTests.Location = new System.Drawing.Point(6, 33);
            this.lblTests.Name = "lblTests";
            this.lblTests.Size = new System.Drawing.Size(135, 27);
            this.lblTests.TabIndex = 1;
            this.lblTests.Text = "-";
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new System.Drawing.Point(6, 16);
            label1.Name = "label1";
            label1.Size = new System.Drawing.Size(42, 13);
            label1.TabIndex = 0;
            label1.Text = "Test(s):";
            // 
            // mniSizeAllToFit
            // 
            mniSizeAllToFit.Name = "mniSizeAllToFit";
            mniSizeAllToFit.Size = new System.Drawing.Size(192, 22);
            mniSizeAllToFit.Text = "Size All Columns to Fit";
            mniSizeAllToFit.Click += new System.EventHandler(this.mniSizeAllToFit_Click);
            // 
            // mniMore
            // 
            mniMore.Name = "mniMore";
            mniMore.Size = new System.Drawing.Size(192, 22);
            mniMore.Text = "More...";
            mniMore.Click += new System.EventHandler(this.mniMore_Click);
            // 
            // cmsColumnsSep1
            // 
            cmsColumnsSep1.Name = "cmsColumnsSep1";
            cmsColumnsSep1.Size = new System.Drawing.Size(189, 6);
            // 
            // cmsColumnsSep2
            // 
            cmsColumnsSep2.Name = "cmsColumnsSep2";
            cmsColumnsSep2.Size = new System.Drawing.Size(189, 6);
            // 
            // grpScheduler
            // 
            this.grpScheduler.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.grpScheduler.Location = new System.Drawing.Point(5, 78);
            this.grpScheduler.Margin = new System.Windows.Forms.Padding(5, 0, 5, 5);
            this.grpScheduler.Name = "grpScheduler";
            this.grpScheduler.Size = new System.Drawing.Size(184, 371);
            this.grpScheduler.TabIndex = 5;
            this.grpScheduler.TabStop = false;
            this.grpScheduler.Text = "Options";
            // 
            // cmbScheduler
            // 
            this.cmbScheduler.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.cmbScheduler.DisplayMember = "Name";
            this.cmbScheduler.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbScheduler.FormattingEnabled = true;
            this.cmbScheduler.Location = new System.Drawing.Point(5, 5);
            this.cmbScheduler.Name = "cmbScheduler";
            this.cmbScheduler.Size = new System.Drawing.Size(128, 21);
            this.cmbScheduler.TabIndex = 1;
            this.cmbScheduler.SelectedIndexChanged += new System.EventHandler(this.cmbScheduler_SelectedIndexChanged);
            // 
            // splMain
            // 
            this.splMain.Dock = System.Windows.Forms.DockStyle.Fill;
            this.splMain.Location = new System.Drawing.Point(0, 0);
            this.splMain.Name = "splMain";
            // 
            // splMain.Panel1
            // 
            this.splMain.Panel1.Controls.Add(this.chkStopTime);
            this.splMain.Panel1.Controls.Add(this.dtpStopTime);
            this.splMain.Panel1.Controls.Add(this.btnStartStop);
            this.splMain.Panel1.Controls.Add(this.cmbScheduler);
            this.splMain.Panel1.Controls.Add(this.grpScheduler);
            // 
            // splMain.Panel2
            // 
            this.splMain.Panel2.Controls.Add(pnlDetails);
            this.splMain.Panel2.Controls.Add(this.lstJobs);
            this.splMain.Size = new System.Drawing.Size(766, 454);
            this.splMain.SplitterDistance = 194;
            this.splMain.TabIndex = 2;
            // 
            // chkStopTime
            // 
            this.chkStopTime.AutoSize = true;
            this.chkStopTime.Location = new System.Drawing.Point(5, 32);
            this.chkStopTime.Name = "chkStopTime";
            this.chkStopTime.Size = new System.Drawing.Size(93, 17);
            this.chkStopTime.TabIndex = 3;
            this.chkStopTime.Text = "Stop stress at:";
            this.chkStopTime.UseVisualStyleBackColor = true;
            this.chkStopTime.CheckedChanged += new System.EventHandler(this.chkStopTime_CheckedChanged);
            // 
            // dtpStopTime
            // 
            this.dtpStopTime.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.dtpStopTime.CustomFormat = "ddd, MMM d  hh:mm:ss tt";
            this.dtpStopTime.Enabled = false;
            this.dtpStopTime.Format = System.Windows.Forms.DateTimePickerFormat.Custom;
            this.dtpStopTime.Location = new System.Drawing.Point(5, 55);
            this.dtpStopTime.Name = "dtpStopTime";
            this.dtpStopTime.Size = new System.Drawing.Size(184, 20);
            this.dtpStopTime.TabIndex = 4;
            // 
            // btnStartStop
            // 
            this.btnStartStop.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.btnStartStop.Location = new System.Drawing.Point(139, 4);
            this.btnStartStop.Name = "btnStartStop";
            this.btnStartStop.Size = new System.Drawing.Size(50, 23);
            this.btnStartStop.TabIndex = 2;
            this.btnStartStop.Text = "Start";
            this.btnStartStop.UseVisualStyleBackColor = true;
            this.btnStartStop.Click += new System.EventHandler(this.btnStartStop_Click);
            // 
            // lstJobs
            // 
            this.lstJobs.AllowColumnReorder = true;
            this.lstJobs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.lstJobs.BackColor = System.Drawing.Color.Silver;
            this.lstJobs.ContextMenuStrip = this.cmsColumns;
            this.lstJobs.Font = new System.Drawing.Font("Tahoma", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lstJobs.FullRowSelect = true;
            this.lstJobs.HideSelection = false;
            this.lstJobs.LabelWrap = false;
            this.lstJobs.Location = new System.Drawing.Point(0, 0);
            this.lstJobs.Margin = new System.Windows.Forms.Padding(0);
            this.lstJobs.Name = "lstJobs";
            this.lstJobs.Size = new System.Drawing.Size(415, 454);
            this.lstJobs.TabIndex = 0;
            this.lstJobs.UseCompatibleStateImageBehavior = false;
            this.lstJobs.View = System.Windows.Forms.View.Details;
            this.lstJobs.SelectedIndexChanged += new System.EventHandler(this.lstJobs_SelectedIndexChanged);
            this.lstJobs.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.lstJobs_KeyPress);
            // 
            // cmsColumns
            // 
            this.cmsColumns.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            mniSizeAllToFit,
            cmsColumnsSep1,
            cmsColumnsSep2,
            mniMore});
            this.cmsColumns.Name = "cmsColumns";
            this.cmsColumns.Size = new System.Drawing.Size(193, 60);
            // 
            // tmrTick
            // 
            this.tmrTick.Enabled = true;
            this.tmrTick.Interval = 1000;
            this.tmrTick.Tick += new System.EventHandler(this.tmrTick_Tick);
            // 
            // StressControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.Controls.Add(this.splMain);
            this.Name = "StressControl";
            this.Size = new System.Drawing.Size(766, 454);
            pnlDetails.ResumeLayout(false);
            grpDetails.ResumeLayout(false);
            grpDetails.PerformLayout();
            groupBox3.ResumeLayout(false);
            groupBox3.PerformLayout();
            groupBox2.ResumeLayout(false);
            groupBox2.PerformLayout();
            groupBox1.ResumeLayout(false);
            groupBox1.PerformLayout();
            this.splMain.Panel1.ResumeLayout(false);
            this.splMain.Panel1.PerformLayout();
            this.splMain.Panel2.ResumeLayout(false);
            this.splMain.ResumeLayout(false);
            this.cmsColumns.ResumeLayout(false);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.GroupBox grpScheduler;
        private System.Windows.Forms.ComboBox cmbScheduler;
        private System.Windows.Forms.SplitContainer splMain;
        private System.Windows.Forms.ListView lstJobs;
        private System.Windows.Forms.Button btnStartStop;
        private System.Windows.Forms.Timer tmrTick;
        private System.Windows.Forms.CheckBox chkStopTime;
        private System.Windows.Forms.DateTimePicker dtpStopTime;
        private System.Windows.Forms.Label lblTests;
        private System.Windows.Forms.ToolTip tltMain;
        private System.Windows.Forms.Label lblRate;
        private System.Windows.Forms.Label lblFail;
        private System.Windows.Forms.Label lblSkip;
        private System.Windows.Forms.Label lblDeadlock;
        private System.Windows.Forms.Label lblPass;
        private System.Windows.Forms.Label lblTotalTPS;
        private System.Windows.Forms.Label lblPrivateTPS;
        private System.Windows.Forms.Label lblTPS_120;
        private System.Windows.Forms.Label lblTPS_20;
        private System.Windows.Forms.Label lblTPS_5;
        private System.Windows.Forms.Label lblThreads;
        private System.Windows.Forms.Label lblInProgress;
        private System.Windows.Forms.TextBox txtScale;
        private System.Windows.Forms.Label lblDetailsScaleName;
        private System.Windows.Forms.ContextMenuStrip cmsColumns;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\WireDataFuzzer\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\TestDB\Tree.cs ===
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Text;
using System.Collections.Generic;
using System.Security.Permissions;

using ServerTestFramework;
using ServerTestFramework.Runner;

using ServerTestFramework.Reporting;

namespace STFGui.Plugins
{
    /// <summary>
    /// A single node in the regression tree.
    /// </summary>
    public class TestDBTreeNode: TreeNode
    {
        public string FullName
        {
            get
            {
                if (Parent==null)
                    return Name;
                else
                    return ((TestDBTreeNode)Parent).FullName+"."+Name;
            }
        }

        public int PassCount;
        public int TotalCount;
        public bool IsInLoadedSuite=false;
        public bool IsInRegDB=false;

        // --

        //ctor
        public TestDBTreeNode(TestNode node, bool addChildren)
        {
            Name=node.Name;
            IsInLoadedSuite=true;

            if (addChildren)
            {
                foreach (TestNode child in node.Children)
                {
                    if (child.FunctionalData!=null)
                    {
                        Nodes.Add(new TestDBTreeNode(child, true));
                    }
                }
            }

            UpdateNodeVisuals();
        }

        //ctor
        public TestDBTreeNode(string name)
        {
            Name=name;
        }

        //merge a node from the reg tree
        public void MergeRegNode(RegDBTreeReader.Node regRoot)
        {
            if (regRoot.Name!=Name)
            {
                return;
            }

            IsInRegDB=true;

            //merge children in
            foreach (RegDBTreeReader.Node regChild in regRoot.Children)
            {
                //see if I have a matching child
                TestDBTreeNode treeChild=null;
                foreach (TestDBTreeNode rtn in Nodes)
                {
                    if (rtn.Name==regChild.Name)
                    {
                        treeChild=rtn;
                        break;
                    }
                }

                //update that child
                if (treeChild==null) //no matching so add one
                {
                    TestDBTreeNode newChild=new TestDBTreeNode(regChild.Name);
                    Nodes.Add(newChild);
                    newChild.MergeRegNode(regChild);
                }
                else //update the matching child
                {
                    treeChild.MergeRegNode(regChild);
                }
            }

            UpdateNodeVisuals();
        }

        //Rebuilds the Text and other visual properties of the node
        public void UpdateNodeVisuals()
        {
            //rebuild Text
            Text="";
            if (TotalCount>0 && Nodes.Count>0)
            {
                Text="["+PassCount+"/"+TotalCount+"] ";
            }
            Text+=Name;

            //color of the text
            if (IsInLoadedSuite && IsInRegDB) ForeColor=Color.Black;
            else if (IsInLoadedSuite) ForeColor=Color.DarkBlue;
            else if (IsInRegDB) ForeColor=Color.DarkGray;
            else ForeColor=Color.Yellow; //should never happen

            //bgcolor
            if (TotalCount>0)
            {
                if (PassCount<TotalCount)
                    BackColor=Color.Red;
                else
                    BackColor=Color.LightGreen;
            }
            else
            {
                BackColor=Color.White;
            }
        }

        //crears the pass/fail numbers on the tree
        public void ClearPassFail()
        {
            PassCount=0;
            TotalCount=0;

            foreach (TestDBTreeNode n in Nodes)
            {
                n.ClearPassFail();
            }

            UpdateNodeVisuals();
        }

        //retrieves a flattened list of all leaf nodes
        public void GetLeaves(ref List<TestDBTreeNode> leafNodes)
        {
            if (Nodes.Count==0)
            {
                leafNodes.Add(this);
            }
            else
            {
                foreach (TestDBTreeNode tn in Nodes)
                {
                    tn.GetLeaves(ref leafNodes);
                }
            }
        }

        //adds pass/total count to me and parents
        public void AddPassTotal(int pass, int total)
        {
            PassCount+=pass;
            TotalCount+=total;
            UpdateNodeVisuals();

            if (Parent!=null)
            {
                ((TestDBTreeNode)Parent).AddPassTotal(pass, total);
            }
        }
    };

    /// <summary>
    /// The regression tree view.
    /// </summary>
    public class RegTreeView: TreeView
    {
        //public
        public int IterationID=-1; //set when the iteration ID changes

        //
        Form guiForm;

        public delegate void InvokeCode();

        //ctor
        public RegTreeView(Form ownerForm)
        {
            //
            CheckBoxes=false;
            ShowNodeToolTips=false;
            guiForm=ownerForm;

            //hook up events
            MouseDown+=Event_MouseDown;

            //add context menu
            ContextMenu=new ContextMenu();
            ContextMenu.Popup+=ContextHandler;
        }

        //merge a regdb tree into an already built tree
        public void MergeRegTree(RegDBTreeReader.Node regRoot)
        {
            //make the root if we don't have one
            if (Nodes.Count==0)
            {
                Nodes.Add(new TestDBTreeNode(regRoot.Name));
                Nodes[0].Name=regRoot.Name;
            }

            //now merge it in
            ((TestDBTreeNode)(Nodes[0])).MergeRegNode(regRoot);
        }

        //crears the pass/fail numbers on the tree
        public void ClearPassFail()
        {
            foreach (TestDBTreeNode n in Nodes)
            {
                n.ClearPassFail();
            }
        }

        //retrieves a flattened list of all leaf nodes
        public void GetLeaves(ref List<TestDBTreeNode> leafNodes)
        {
            foreach (TestDBTreeNode tn in Nodes)
            {
                tn.GetLeaves(ref leafNodes);
            }
        }

        #region Events

        //prevent expanding/collapsing by double click -- is there a better way?
        [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]
        protected override void WndProc(ref Message m)
        {
            if (m.Msg==515) //double click
            {
                if (CustomDoubleClick!=null)
                {
                    CustomDoubleClick();
                }
            }
            else
            {
                base.WndProc(ref m);
            }
        }
        public delegate void VoidCall();
        public event VoidCall CustomDoubleClick;

        //context menu handler
        private void ContextHandler(object sender, EventArgs e)
        {
            //wipe out old options
            Menu.MenuItemCollection mi=ContextMenu.MenuItems;
            mi.Clear();

            //
            if (SelectedNode==null)
            {
                return;
            }

            //add the options
            mi.Add("View Output", CtxMenu_ViewOutput);
            mi.Add("View History", CtxMenu_ViewHistory);
        }

        //context menu handler
        private void CtxMenu_ViewOutput(object sender, EventArgs args)
        {
            ShowOutputBox((TestDBTreeNode)SelectedNode);
        }

        private void CtxMenu_ViewHistory(object sender, EventArgs args)
        {
            ShowHistoryBox((TestDBTreeNode)SelectedNode);
        }

        //change the selected node anytime they click on a node in any way
        private void Event_MouseDown(object sender, MouseEventArgs e)
        {
            TestDBTreeNode node=(TestDBTreeNode)this.GetNodeAt(e.X, e.Y);
            SelectedNode=node;
        }

        #endregion

        //Pops up a window with output filtered from a specific node
        private void ShowOutputBox(TestDBTreeNode rtn)
        {
            if (rtn==null || IterationID==-1)
            {
                return;
            }

            //make form
            Form form=new Form();
            form.SetBounds(0,0,650,400,BoundsSpecified.Size);
            form.Text=rtn.FullName;
            form.FormBorderStyle=FormBorderStyle.Sizable;

            //add a "Loading..." label
            Label loading=new Label();
            loading.Text="Loading...";
            loading.Size=new System.Drawing.Size(60, 15);
            form.Controls.Add(loading);

            //add a stf output box to it
            StfTextBox box=new StfTextBox();
            box.Dock=DockStyle.Fill;
            form.Controls.Add(box);
            form.Show(guiForm);
            form.Refresh();

            //get the lines from RegDB and put them into the box
            try
            {
                RegDBInfo.GetNodeOutputToReportDestination(rtn.FullName, IterationID, box);
            }
            catch (Exception e)
            {
                box.Text+="\r\n\r\nException trying to retrieve history: "+e;
            }

            loading.Visible=false;
        }

        private void ShowHistoryBox(TestDBTreeNode rtn)
        {
            if (rtn==null)
            {
                return;
            }

            string name=rtn.FullName;
            ShowHistoryBoxForNode(name);
        }

        //Pops up a window with history for specific node
        public void ShowHistoryBoxForNode(string fullName)
        {
            //make form
            Form form=new Form();
            form.SetBounds(0,0,650,400,BoundsSpecified.Size);
            form.Text=fullName;
            form.FormBorderStyle=FormBorderStyle.Sizable;

            //add a "Loading..." label
            Label loading=new Label();
            loading.Text="Loading...";
            loading.Size=new System.Drawing.Size(60, 15);
            form.Controls.Add(loading);

            //add a stf output box to it
            StfTextBox box=new StfTextBox();
            box.Dock=DockStyle.Fill;
            form.Controls.Add(box);
            form.Show(guiForm);
            form.Refresh();

            //get the history
            RegDBInquirer.RegDBHistory[] history;
            try
            {
                history=RegDBInfo.GetNodeHistory(fullName);
            }
            catch (Exception e)
            {
                box.Text+="\r\n\r\nException trying to retrieve history: "+e;
                loading.Visible=false;
                return;
            }

            //format it out to the box
            if (history.Length==0)
            {
                box.Text="No History found for "+fullName;
            }
            else
            {
                box.Text="History for "+fullName+"\n\n";

                //heading
                box.Text+="Environment".PadRight(20);
                box.Text+="Build".PadRight(20);
                box.Text+="Pass/Total".PadRight(20);
                box.Text+="%Pass\n";

                box.Text+="-----------         "+"-----               "+"-----------         "+"-----\n";

                //lines
                foreach (RegDBInquirer.RegDBHistory hist in history)
                {
                    box.Text+=hist.Environment.PadRight(20);

                    string build=hist.Build;
                    build+=hist.Iteration.ToString().PadLeft(4,'0');
                    box.Text+=build.PadRight(20);

                    box.Text+=(hist.Passed+"/"+(hist.Passed+hist.Failed)).PadRight(20);
                    if (hist.Passed+hist.Failed>0)
                    {
                        box.Text+=(100*hist.Passed/(hist.Passed+hist.Failed)).ToString()+"%\n";
                    }
                    else
                    {
                        box.Text+="\n";
                    }
                }
            }

            loading.Visible=false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\TestDB\TestDBPlugin.cs ===
using System;
using System.Windows.Forms;
using System.Threading;
using System.Collections.Generic;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Plugins;
using ServerTestFramework.Runner;
using ServerTestFramework.TestDB;

namespace STFGui.Plugins
{
    /// <summary>
    /// TestDB plugin.
    /// This plugin relies of the functional plugin to hook events.
    /// </summary>
    public class TestDBPlugin: IPluginExtension<FunctionalPlugin>, IPluginModuleLoadNotification, IPluginSetup, STFGui.Plugins.IPluginGui
    {
        //public members
        public Panel LogPanel;
        public Panel ButtonPanel;
        public Panel SuitesPanel;
        public Panel BuildsPanel;
        public Panel TreePanel;

        public ListBox ListBoxSuites;
        public ListBox ListBoxBuilds;
        //public TestDBTreeView Tree;

        public MultiTestEventListener FunctionalEvents; //hooked from the functional plugin

        //internals
        FunctionalPlugin funcPlugin;
        CheckBox boxEnableLogging;
        TextBox textVersion;
        Button butViewOutput;
        Button butReload;
        SplitContainer splitBuildsAndSuites;

        LinkedList<TestNode> rootNodes=new LinkedList<TestNode>(); //of actually loaded test suites
        string []suitesList=new string[0];  //1-1 index mapping to the list box
        string []environmentsList=new string[0];
        //RegDBInfo.BuildRun []buildsList=new RegDBInfo.BuildRun[0];  //1-1 index mapping to the list box
        ServerTestFramework.TestDB.Version []versionList=new ServerTestFramework.TestDB.Version[0];  //1-1 index mapping to the list box

        //RegDBTestEventListener regDBLoggerListener;

        Report ro=new Report("TestDBPlugin");

        public delegate void InvokeCode();

        //bool isRunningPassFailUpdate=false; //true while an update to pass/fail is going
        //bool cancelRunningPassFailUpdate=false; //set to false to cancel

        string autoLogVersion=""; //for automatically logging to a specific version

        //Returns the TabPage to add to the gui.
        public TabPage GetNewTabPage()
        {
            //the tab
            TabPage page=new TabPage();
            page.Text="TestDB";

            //add a splitter to divide the tree from the the rest
            SplitContainer splitTreeAndRest=new SplitContainer();
            splitTreeAndRest.Orientation=Orientation.Vertical;
            splitTreeAndRest.Dock=DockStyle.Fill;
            splitTreeAndRest.Location=new System.Drawing.Point(0, 0);
            splitTreeAndRest.Size=new System.Drawing.Size(3000, 3000);
            splitTreeAndRest.Panel1MinSize=350;
            splitTreeAndRest.SplitterDistance=350;
            splitTreeAndRest.IsSplitterFixed=true;
            page.Controls.Add(splitTreeAndRest);

            TreePanel=splitTreeAndRest.Panel2;
            TreePanel.Enabled=false;

            //add a splitter to divide the log control from the suites/builds
            SplitContainer splitLogAndSuitesBuilds=new SplitContainer();
            splitLogAndSuitesBuilds.Orientation=Orientation.Horizontal;
            splitLogAndSuitesBuilds.Dock=DockStyle.Fill;
            splitLogAndSuitesBuilds.Location=new System.Drawing.Point(0, 0);
            splitLogAndSuitesBuilds.Size=new System.Drawing.Size(3000, 3000);
            splitLogAndSuitesBuilds.Panel1MinSize=50;
            splitLogAndSuitesBuilds.SplitterDistance=50;
            splitLogAndSuitesBuilds.IsSplitterFixed=true;
            splitTreeAndRest.Panel1.Controls.Add(splitLogAndSuitesBuilds);

            //add a splitter to divide the log controls from the view controls
            SplitContainer splitControls=new SplitContainer();
            splitControls.Orientation=Orientation.Vertical;
            splitControls.Dock=DockStyle.Fill;
            splitControls.Location=new System.Drawing.Point(0, 0);
            splitControls.Size=new System.Drawing.Size(3000, 3000);
            splitControls.Panel1MinSize=175;
            splitControls.SplitterDistance=175;
            splitControls.IsSplitterFixed=true;
            splitLogAndSuitesBuilds.Panel1.Controls.Add(splitControls);

            LogPanel=splitControls.Panel1;
            LogPanel.Enabled=false; //disable log controls until we find the functional plugin

            ButtonPanel=splitControls.Panel2;

            //add a splitter to divide the builds from the suites
            splitBuildsAndSuites=new SplitContainer();
            splitBuildsAndSuites.Orientation=Orientation.Vertical;
            splitBuildsAndSuites.Dock=DockStyle.Fill;
            splitBuildsAndSuites.Location=new System.Drawing.Point(0, 0);
            splitBuildsAndSuites.Size=new System.Drawing.Size(3000, 3000);
            splitBuildsAndSuites.Panel1MinSize=140;
            splitBuildsAndSuites.SplitterDistance=140;
            splitBuildsAndSuites.IsSplitterFixed=true;
            splitLogAndSuitesBuilds.Panel2.Controls.Add(splitBuildsAndSuites);

            SuitesPanel=splitBuildsAndSuites.Panel1;
            SuitesPanel.Enabled=false;
            BuildsPanel=splitBuildsAndSuites.Panel2;
            BuildsPanel.Enabled=false;

            //Set up the logging panel
            boxEnableLogging=new CheckBox();
            boxEnableLogging.Text="Enable logging to TestDB";
            boxEnableLogging.Location=new System.Drawing.Point(20, 4);
            boxEnableLogging.Size=new System.Drawing.Size(160, 18);
            boxEnableLogging.Checked=false;
            boxEnableLogging.Enabled=false; //temp
            boxEnableLogging.CheckedChanged+=EnableLogging_Changed;
            LogPanel.Controls.Add(boxEnableLogging);

            Label labBuild=new Label();
            labBuild.Text="Log version:";
            labBuild.Location=new System.Drawing.Point(11, 31);
            labBuild.Size=new System.Drawing.Size(67, 13);
            LogPanel.Controls.Add(labBuild);

            textVersion=new TextBox();
            textVersion.Location=new System.Drawing.Point(78, 28);
            textVersion.Size=new System.Drawing.Size(88, 13);
            textVersion.Text="00.00.0000.0000";
            textVersion.MaxLength=15;
            textVersion.TextChanged+=BuildBox_TextChanged;
            textVersion.LostFocus+=BuildBox_LostFocus;
            textVersion.Enabled=false; //temp
            LogPanel.Controls.Add(textVersion);

            //Set up the suites panel
            ListBoxSuites=new ListBox();
            ListBoxSuites.Dock=DockStyle.Fill;
            ListBoxSuites.SelectedIndexChanged+=SuitesList_SelectionChanged;
            SuitesPanel.Controls.Add(ListBoxSuites);

            //Set up the builds panel
            ListBoxBuilds=new ListBox();
            ListBoxBuilds.Dock=DockStyle.Fill;
            ListBoxBuilds.SelectedIndexChanged+=BuildsList_SelectionChanged;
            BuildsPanel.Controls.Add(ListBoxBuilds);

            //Set up the tree panel
            /*Tree=new RegTreeView(GuiHooks.MainForm);
            Tree.Dock=DockStyle.Fill;
            TreePanel.Controls.Add(Tree);*/

            //temp
            TextBox temptb=new TextBox();
            temptb.Text="TODO: This plugin is a work in progress still...";
            temptb.Enabled=false;
            temptb.Dock=DockStyle.Fill;
            TreePanel.Controls.Add(temptb);

            //Buttons
            butReload=new Button();
            butReload.Text="Read Data From TestDB";
            butReload.Location=new System.Drawing.Point(40, 2);
            butReload.Size=new System.Drawing.Size(80, 48);
            butReload.Click+=ButtonReload_Click;
            ButtonPanel.Controls.Add(butReload);

            butViewOutput=new Button();
            butViewOutput.Text="View Node Output";
            butViewOutput.Location=new System.Drawing.Point(95, 2);
            butViewOutput.Size=new System.Drawing.Size(65, 48);
            butViewOutput.Enabled=false;
            butViewOutput.Visible=false; //don't now this button need I think
            butViewOutput.Click+=ButtonViewOutput_Click;
            ButtonPanel.Controls.Add(butViewOutput);

            //
            return page;
        }

        //called when the functional plugin is loaed
        public void PluginLoaded(FunctionalPlugin funcPlug)
        {
            LogPanel.Enabled=true;

            //grab the parts we care for
            funcPlugin=funcPlug;
            FunctionalEvents=funcPlugin.FunctionalEvents;

            //set up our own node context menu handler
            funcPlugin.BuildNodeContextMenuItemsEvent+=AddFuncContextItems;

            //autolog if we were asked to
            if (autoLogVersion.Length>0)
            {
                textVersion.Text=autoLogVersion;
                BuildBox_LostFocus(textVersion, null);
                boxEnableLogging.Checked=true;

                autoLogVersion=""; //done with autolog functionality
            }
        }

        //called when a module is about to be loaded
        public void ModuleLoading(string fileName)
        {
        }

        //called when a suite is loaded
        public void SuiteLoaded(TestNode root)
        {
            CancelPassFailUpdate();
            //lock (Tree)
            {
                rootNodes.AddLast(root);
            }

            RebuildTree();
        }

        //called when suite is being unloaded
        public void SuiteUnloading(TestNode rootNode)
        {
            ro.Warn("TODO: Implement SuiteUnloading");
        }

        //called to init plugin
        public void Initialize(XmlNode pluginSettings, string []commandlineParameters)
        {
            //check our commandline params for anything interesting
            foreach (string s in commandlineParameters)
            {
                if (s.StartsWith("logversion:") && s.Length>=12 && s.Length<=11+15) //log to a specific version
                {
                    autoLogVersion=s.Substring(11);
                }
                else if (s.ToLower()=="help")
                {
                    TestDB.RO.Info("TestDB Plugin parameters:");
                    TestDB.RO.Info("  logversion:u.v.s.t      Log functional run as version u.v.s.t");
                }
                else
                {
                    TestDB.RO.Error("Bad parameter passed to TestDB plugin: "+s);
                }
            }
        }

        //called when we're being shut down
        public void Shutdown(XmlNode pluginSettings)
        {
        }

        #region Events

        //called to add extra context menu items for a node if the user brought up that menu
        private void AddFuncContextItems(TestNode node, List<FunctionalPlugin.TestNodeContextMenuItem> contextItemsToShow)
        {
            contextItemsToShow.Add(new FunctionalPlugin.TestNodeContextMenuItem("-"));
            contextItemsToShow.Add(new FunctionalPlugin.TestNodeContextMenuItem("View TestDB History", Context_ViewRegDBHistory));
        }

        private void Context_ViewRegDBHistory(FunctionalPlugin.TestNodeContextMenuItem sender, TestNode node)
        {
            //Tree.ShowHistoryBoxForNode(node.FullName);
        }

        //
        public void BuildBox_TextChanged(object sender, EventArgs e)
        {
           TextBox tb=(TextBox)sender;

            //only allow numbers
            string newstr="";
            foreach (char c in tb.Text)
            {
                if ((c>='0' && c <='9') || c=='.') newstr+=c;
            }

            if (newstr!=tb.Text)
            {
                tb.Text=newstr;
                tb.SelectionStart=tb.Text.Length;
            }
        }

        public void BuildBox_LostFocus(object sender, EventArgs e)
        {
            TextBox tb=(TextBox)sender;

            //reformat the string to be correct
            string []parts=new string[4];
            for (int i=0; i<4; ++i)
                parts[i]="";
            int dotCount=0;

            foreach (char c in tb.Text)
            {
                if (c=='.')
                {
                    ++dotCount;
                    if (dotCount>=4) //...
                    {
                        break;
                    }
                }
                else
                {
                    parts[dotCount]+=c;
                }
            }

            if (parts[0].Length>2) parts[0].Substring(parts[0].Length-2,2);
            parts[0]=parts[0].PadLeft(2,'0');

            if (parts[1].Length>2) parts[1].Substring(parts[1].Length-2,2);
            parts[1]=parts[1].PadLeft(2,'0');

            if (parts[2].Length>4) parts[2].Substring(parts[2].Length-4,4);
            parts[2]=parts[2].PadLeft(4,'0');

            if (parts[3].Length>4) parts[3].Substring(parts[3].Length-4,4);
            parts[3]=parts[3].PadLeft(4,'0');

            string newstr=parts[0]+"."+parts[1]+"."+parts[2]+"."+parts[3];

            //if we changed it, tell them
            if (newstr!=tb.Text)
            {
                tb.Text=newstr;

                if (autoLogVersion=="") //user-done so show a box
                {
                    MessageBox.Show("Version number was in the wrong format and has been altered.  Please verify that the altered version is correct.");
                }
                else //auto-done so just log message
                {
                    TestDB.RO.Warn("Version number was in the wrong format and has been altered.  Please verify that the altered version is correct.");
                }
            }
        }

        private void EnableLogging_Changed(object sender, EventArgs evt)
        {
            /*CheckBox cb=(CheckBox)sender;

            if (cb.Checked) //start logging
            {
                //get the build to log with
                string []splitDots=textVersion.Text.Split(new char[]{'.'});

                string build=splitDots[0]+"."+splitDots[1]+"."+splitDots[2];
                int buildIter=int.Parse(splitDots[3]);

                //disable changing the build
                textVersion.Enabled=false;

                //start logging
                try
                {
                    TestDB.RO.Info("Enabling TestDB logging... all functional events and all output will be recorded.");
                    regDBLoggerListener=new RegDBTestEventListener(build, buildIter);
                    FunctionalEvents.Add(regDBLoggerListener);
                }
                catch (Exception e)
                {
                    TestDB.RO.Error("Exception enabling TestDB logging: "+e);
                    cb.Checked=false;
                }

                if (funcPlugin!=null)
                {
                    funcPlugin.OverrideLoopedRunning(this, false);
                }
            }
            else //turn off logging
            {
                if (regDBLoggerListener!=null)
                {
                    FunctionalEvents.Remove(regDBLoggerListener);
                    regDBLoggerListener=null;
                }

                TestDB.RO.Info("TestDB logging stopped.");

                //re-enable changing the build
                textVersion.Enabled=true;

                if (funcPlugin!=null)
                {
                    funcPlugin.OverrideLoopedRunning(this, null);
                }
            }*/
        }

        private void ButtonViewOutput_Click(object sender, EventArgs e)
        {
        }

        private void ButtonReload_Click(object sender, EventArgs e)
        {
            //update gui state to disabled and "Loading..."
            if (sender!=null)
            {
                Button but=(Button)sender;

                but.Text="Reload";
                but.Enabled=false;
            }

            butViewOutput.Enabled=false;

            SuitesPanel.Enabled=false;
            ListBoxSuites.Items.Clear();
            ListBoxSuites.Items.Add("Loading...");

            BuildsPanel.Enabled=false;
            ListBoxBuilds.Items.Clear();
            ListBoxBuilds.Items.Add("Loading...");

            CancelPassFailUpdate();
            /*lock (Tree)
            {
                Tree.Nodes.Clear();
            }*/

            //clear cached data
            TestDBReader.ClearCache();

            //kick off worker thread to do the work
            Thread thread=ThreadMaker.CreateThread(ThreadProcReload);
            thread.IsBackground=true;
            thread.Start();
        }

        private void SuitesList_SelectionChanged(object sender, EventArgs e)
        {
            if (ListBoxSuites.Enabled==false) return;

            Thread thread=ThreadMaker.CreateThread(ThreadProcPopulateBuildPassFail);
            thread.IsBackground=true;
            thread.Start();

            RebuildTree();
        }

        private void BuildsList_SelectionChanged(object sender, EventArgs e)
        {
            /*Tree.IterationID=-1;
            if (ListBoxBuilds.Enabled==false) return;

            if (ListBoxBuilds.SelectedIndex!=-1)
            {
                Tree.IterationID=buildsList[ListBoxBuilds.SelectedIndex].IterationID;
            }

            Thread thread=ThreadMaker.CreateThread(ThreadProcPopulateSuitePassFail);
            thread.IsBackground=true;
            thread.Start();

            //change the log version box too
            if (ListBoxBuilds.SelectedIndex>=0 && textVersion.Enabled)
            {
                textVersion.Text=buildsList[ListBoxBuilds.SelectedIndex].Build;
                BuildBox_LostFocus(textVersion, null);
            }

            //start updating tree pass/fail
            RecalcTreePassFail();*/
        }

        #endregion

        //reload all info panels
        private void ThreadProcReload()
        {
            /*ServerTestFramework.Reporting.RegDBInfo regDBInfo=new ServerTestFramework.Reporting.RegDBInfo();
            try
            {
                //load the list of suites
                suitesList=regDBInfo.GetAllSuites();

                ListBoxSuites.Invoke(new InvokeCode(delegate
                {
                    ListBoxSuites.Items.Clear();
                    foreach (string s in suitesList)
                    {
                        ListBoxSuites.Items.Add(s);
                    }
                }));

                //load the list of environments
                environmentsList=regDBInfo.GetAllEnvironments();

                //load the list of builds
                buildsList=regDBInfo.GetAllBuilds();

                ListBoxBuilds.Invoke(new InvokeCode(delegate
                {
                    ListBoxBuilds.Items.Clear();
                    foreach (RegDBInfo.BuildRun b in buildsList)
                    {
                        ListBoxBuilds.Items.Add(b.Build+" "+environmentsList[b.EnvironmentID]);
                    }
                }));

                //re-enable the ui parts
                TreePanel.Invoke(new InvokeCode(delegate
                {
                    TreePanel.Enabled=true;
                    BuildsPanel.Enabled=true;
                    SuitesPanel.Enabled=true;
                }));
            }
            catch (Exception e)
            {
                TestDB.RO.Error("Exception trying to load TestDB info: "+e);
            }
            finally
            {
                //re-enabled the Reload button
                butReload.Invoke(new InvokeCode(delegate
                {
                    butReload.Enabled=true;
                }));

                regDBInfo.Close();
            }*/

            try
            {
                using (TestDBReader tdbReader=new TestDBReader())
                {
                    //load the list of suites
                    suitesList=tdbReader.GetRootNodeNames();
                    ListBoxSuites.Invoke(new InvokeCode(delegate
                    {
                        ListBoxSuites.Items.Clear();
                        foreach (string s in suitesList)
                        {
                            ListBoxSuites.Items.Add(s);
                        }
                    }));

                    //load the list of builds
                    versionList=tdbReader.GetVersionList();
                    ListBoxBuilds.Invoke(new InvokeCode(delegate
                    {
                        ListBoxBuilds.Items.Clear();
                        foreach (ServerTestFramework.TestDB.Version v in versionList)
                        {
                            ListBoxBuilds.Items.Add(v.Number.Major+"."+v.Number.Minor+"."+v.Number.Build+"."+v.Number.Qfe+" "+v.Environment.Name);
                        }
                    }));
                }

                //re-enable the ui parts
                TreePanel.Invoke(new InvokeCode(delegate
                {
                    TreePanel.Enabled=true;
                    BuildsPanel.Enabled=true;
                    SuitesPanel.Enabled=true;
                }));
            }
            finally
            {
                //re-enabled the Reload button
                butReload.Invoke(new InvokeCode(delegate
                {
                    butReload.Enabled=true;
                }));
            }
        }

        //populates pass/fail for each suite for a specific build
        private void ThreadProcPopulateSuitePassFail()
        {
            /*//get the inital build index to populate for
            int buildInd=-1;
            ListBoxBuilds.Invoke(new InvokeCode(delegate
            {
                buildInd=ListBoxBuilds.SelectedIndex;

                butReload.Enabled=false;
                butReload.Text="Updating...";
                ListBoxSuites.Enabled=false;
            }));

            ServerTestFramework.Reporting.RegDBInfo regDBInfo=new ServerTestFramework.Reporting.RegDBInfo();
            try
            {
                //now retrieve information for each suite
                for (int i=0; i<suitesList.Length; ++i)
                {
                    string suite=suitesList[i];

                    int pass, total;
                    regDBInfo.GetSuitePassCountForBuild(suite, buildsList[buildInd].IterationID, out pass, out total);

                    //update the suite box.  if the selected index changed though, totally bail out.
                    ListBoxBuilds.Invoke(new InvokeCode(delegate
                    {
                        if (ListBoxBuilds.SelectedIndex!=buildInd)
                        {
                            return;
                        }

                        if (total>0)
                        {
                            ListBoxSuites.Items[i]="["+pass+"/"+total+"] "+suitesList[i];
                        }
                        else
                        {
                            ListBoxSuites.Items[i]="  "+suitesList[i];
                        }
                    }));
                }
            }
            finally
            {
                //re-enabled the Reload button
                butReload.Invoke(new InvokeCode(delegate
                {
                    butReload.Enabled=true;
                    ListBoxSuites.Enabled=true;
                    butReload.Text="Reload";
                }));

                regDBInfo.Close();
            }*/
        }

        //populates pass/fail for each suite for a specific build
        private void ThreadProcPopulateBuildPassFail()
        {
            /*//get the inital build index to populate for
            int suiteInd=-1;
            ListBoxSuites.Invoke(new InvokeCode(delegate
            {
                suiteInd=ListBoxSuites.SelectedIndex;

                butReload.Enabled=false;
                butReload.Text="Updating...";
                ListBoxBuilds.Enabled=false;
            }));

            ServerTestFramework.Reporting.RegDBInfo regDBInfo=new ServerTestFramework.Reporting.RegDBInfo();
            try
            {
                //now retrieve information for each suite
                for (int i=0; i<buildsList.Length; ++i)
                {
                    int buildIter=buildsList[i].IterationID;

                    int pass, total;
                    regDBInfo.GetSuitePassCountForBuild(suitesList[suiteInd], buildIter, out pass, out total);

                    //update the suite box.  if the selected index changed though, totally bail out.
                    ListBoxSuites.Invoke(new InvokeCode(delegate
                    {
                        if (ListBoxSuites.SelectedIndex!=suiteInd)
                        {
                            return;
                        }

                        string buildStr=buildsList[i].Build+" "+environmentsList[buildsList[i].EnvironmentID];
                        if (total>0)
                        {
                            ListBoxBuilds.Items[i]="["+pass+"/"+total+"] "+buildStr;
                        }
                        else
                        {
                            ListBoxBuilds.Items[i]="  "+buildStr;
                        }
                    }));
                }
            }
            finally
            {
                //re-enabled the Reload button
                butReload.Invoke(new InvokeCode(delegate
                {
                    butReload.Enabled=true;
                    ListBoxBuilds.Enabled=true;
                    butReload.Text="Reload";
                }));

                regDBInfo.Close();
            }*/
        }

        //rebuilds the Reg Tree
        private void RebuildTree()
        {
            /*CancelPassFailUpdate();
            lock (Tree)
            {
                //wipe out old tree
                Tree.Nodes.Clear();

                //if we have a suite loaded for the chosen suite add its nodes first
                if (ListBoxSuites.SelectedIndex<0)
                {
                    return;
                }

                string selectedSuite=suitesList[ListBoxSuites.SelectedIndex];

                foreach (TestNode root in rootNodes)
                {
                    if (root.Name==selectedSuite)
                    {
                        Tree.Nodes.Add(new RegTreeNode(root, true));
                        Tree.Nodes[0].Name=root.Name;
                    }
                }

                //now merge RegDB's tree into that
                RegDBTreeReader.Node regRoot=RegDBInfo.GetSuiteTree(selectedSuite);
                Tree.MergeRegTree(regRoot);

                if (Tree.Nodes.Count>0)
                {
                    Tree.Nodes[0].Expand();
                }
            }

            RecalcTreePassFail();*/
        }

        //recalculates pass/fail for the tree
        private void RecalcTreePassFail()
        {
            /*CancelPassFailUpdate();
            cancelRunningPassFailUpdate=false;

            lock (Tree)
            {
                Tree.ClearPassFail();
            }

            if (ListBoxBuilds.SelectedIndex<0)
            {
                return;
            }

            Thread thread=ThreadMaker.CreateThread(ThreadProcRecalcTreePassFail);
            thread.IsBackground=true;
            isRunningPassFailUpdate=true;
            thread.Start();*/
        }

        //cancels any in-progress update to pass/fail
        private void CancelPassFailUpdate()
        {
            /*cancelRunningPassFailUpdate=true;
            while (isRunningPassFailUpdate)
            {
                //TODO: use a blocking object and all nicer stuff
                System.Threading.Thread.Sleep(0);
            }*/
        }

        //
        private void ThreadProcRecalcTreePassFail()
        {
           /* if (!isRunningPassFailUpdate) return;

            //get all leaf nodes in the tree
            List<RegTreeNode> leafNodes=new List<RegTreeNode>();

            int buildInd=-1;
            if (cancelRunningPassFailUpdate) return;
            butReload.Invoke(new InvokeCode(delegate
            {
                lock (Tree)
                {
                    Tree.GetLeaves(ref leafNodes);
                }
                buildInd=ListBoxBuilds.SelectedIndex;
            }));

            if (buildInd<0)
            {
                TestDB.RO.Warn("Tried to recalc tree pass/fail with no build.");
                return;
            }

            ServerTestFramework.Reporting.RegDBInfo regDBInfo=new ServerTestFramework.Reporting.RegDBInfo();
            try
            {
                foreach (RegTreeNode tn in leafNodes)
                {
                    if (cancelRunningPassFailUpdate) return;

                    if (tn.IsInRegDB)
                    {
                        int pass=0;
                        int total=0;
                        regDBInfo.GetLeafPassFail(tn.FullName, buildsList[buildInd].IterationID, out pass, out total);

                        if (total>0)
                        {
                            lock (Tree)
                            {
                                if (cancelRunningPassFailUpdate) return;
                                Tree.Invoke(new InvokeCode(delegate
                                {
                                    tn.AddPassTotal(pass,total);
                                }));
                            }
                        }
                    }
                }
            }
            finally
            {
                isRunningPassFailUpdate=false;
                cancelRunningPassFailUpdate=false;

                regDBInfo.Close();
            }*/
        }

        #region IPluginGui Members

        public MainGuiHooks GuiHooks
        {
            get;
            set;
        }

        public MenuItem GetNewMenu ()
        {
            return null;
        }

        public void OnGuiShown ()
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\STFGui\Plugins\StressRunner\StressControl.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using System.Xml;
using System.Diagnostics;

using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;

namespace STFGui.Plugins.StressRunner
{
    // This class needs to be organized a bit
    public partial class StressControl : UserControl
    {
        /// <summary>
        /// The actual scheduler object used to run stress.
        /// </summary>
        protected StressTestScheduler _scheduler = null;

        protected Report _report = null;
        public Report Report { get { return _report; } }

        protected bool _running = false;
        protected Thread _stress_thread = null;

        protected List<StressColumn> _columns = new List<StressColumn>();
        protected StressColumn _scale_column;
        protected ToolStripMenuItem _scale_menu;

        protected MainGuiHooks _gui_hooks;

        public MenuItem miSkipPreRun;
        public MenuItem miSkipPostRun;

        struct JobMetadata
        {
            public int MaxFailureTraces;
            public StressNodeData.ValidationData ValidationData;

            public JobMetadata(XmlNode job)
            {
                ValidationData = new StressNodeData.ValidationData(job);
                MaxFailureTraces = XmlUtil.GetAttributeValue(job, "MaxFailureTraces", 500);
            }
        }

        public StressControl(MainGuiHooks hooks)
        {
            InitializeComponent();

            _report = new Report("Stress");

            try
            {
                lstJobs.GetType().GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic).
                    SetValue(lstJobs, true, null);
            }
            catch (Exception e)
            {
                _report.Warn("Error occured while trying to double buffer the job list:\n" + e.ToString());
            }

            _gui_hooks = hooks;
            _oldcolor = txtScale.BackColor;
            dtpStopTime.Value = DateTime.Now.AddDays(3);

            PopulateDefaultColumns();
        }

        #region Public

        /// <summary>
        /// Searches all loaded assemblies for implementations of StressTestScheduler.
        /// </summary>
        public void LoadSchedulers ()
        {
            lock (cmbScheduler)
            {
                // get ready to reflect
                cmbScheduler.Items.Clear();
                cmbScheduler.Text = "Searching...";

                List<Type> schedulers = ReflectionUtils.GetDerivedTypes(typeof(StressTestScheduler));

                cmbScheduler.Items.Clear();

                if (schedulers.Count == 0)
                {
                    cmbScheduler.Text = "No StressTestScheduler found";
                }
                else
                {
                    foreach (Type t in schedulers)
                    {
                        cmbScheduler.Items.Add(t);
                    }

                    cmbScheduler.SelectedIndex = 0;
                }
            }
        }

        /// <summary>
        /// Called to add tests to the stress control.
        /// </summary>
        /// <param name="root"></param>
        public void AddRootNode(TestNode root)
        {
            lock (Roots)
            {
                Roots.Add(root);
                AddJobsToListView(root, JobList.AddNode(root));
            }
        }

        /// <summary>
        /// Called to remove tests to the stress control.
        /// </summary>
        /// <param name="root"></param>
        public void RemoveRootNode(TestNode root)
        {
            lock (Roots)
            {
                Roots.Remove(root);
                JobList.RemoveNode(root);
                RemoveJobsFromListView(root);
            }
        }

        public bool IsRunning
        {
            get { return _running; }
        }

        /// <summary>
        /// Stops running stress if it is running.
        /// </summary>
        public void Stop()
        {
            if (_running)
            {
                btnStartStop.Invoke(new EventHandler(btnStartStop_Click), new object[] { this, null });
            }
        }

        /// <summary>
        /// Starts running stress if it is not running.
        /// </summary>
        public void Start()
        {
            if (!_running)
            {
                btnStartStop.Invoke(new EventHandler(btnStartStop_Click), new object[] { this, null });
            }
        }

        public void SaveMonitorData(XmlWriter writer)
        {
            if (_scheduler != null)
            {
                writer.WriteElementString("Threads", _scheduler.ActiveThreads.ToString());
            }
            writer.WriteStartElement("Jobs");
            foreach (StressJob sj in JobList)
            {
                writer.WriteStartElement("Job");
                writer.WriteAttributeString("Name", sj.Name);
                writer.WriteAttributeString("RunningTPS", sj.Results.RunningTPS.ToString());
                writer.WriteAttributeString("Passed", sj.Results.Passed.ToString());
                writer.WriteAttributeString("Failed", sj.Results.Failed.ToString());
                writer.WriteAttributeString("InProgress", sj.Results.InProgress.ToString());
                writer.WriteAttributeString("DeadLocked", sj.Results.Deadlocked.ToString());
                writer.WriteAttributeString("Skipped", sj.Results.Skipped.ToString());
                writer.WriteEndElement();
            }
            writer.WriteEndElement();
        }

        public void WriteJobsResults(XmlWriter results)
        {
            results.WriteStartElement("Jobs");

            int cSucceeded = 0;
            int cFailed = 0;

            using (Microsoft.DistributedAutomation.Logger.TestLogger wttLog = new Microsoft.DistributedAutomation.Logger.TestLogger("$LogFile"))
            {
                foreach (StressJob sj in JobList)
                {
                    wttLog.StartTest(sj.Name);
                    results.WriteStartElement("Job");
                    bool succeeded = sj.Succeeded;
                    if (succeeded)
                    {
                        ++cSucceeded;
                    }
                    else
                    {
                        ++cFailed;
                    }

                    results.WriteAttributeString("Name", sj.Name);
                    results.WriteAttributeString("InProgress", sj.Results.InProgress.ToString());
                    results.WriteAttributeString("Passed", sj.Results.Passed.ToString());
                    results.WriteAttributeString("Failed", sj.Results.Failed.ToString());
                    results.WriteAttributeString("TotalTPS", sj.Results.TotalTPS.ToString());
                    results.WriteAttributeString("RunningTPS", sj.Results.RunningTPS.ToString());
                    results.WriteAttributeString("Deadlocked", sj.Results.Deadlocked.ToString());
                    results.WriteAttributeString("Skipped", sj.Results.Skipped.ToString());
                    results.WriteAttributeString("Succeeded", succeeded ? "1" : "0");

                    foreach(TestResult.FailureTrace trace in sj.Results.FailureTraces)
                    {
                        results.WriteStartElement("FailureTrace");
                        results.WriteAttributeString("StartTime", trace.StartTime.ToString());
                        results.WriteAttributeString("EndTime", trace.EndTime.ToString());
                        if (trace.Reason != null)
                            results.WriteAttributeString("Reason", trace.Reason.ToString());
                        results.WriteEndElement(); // FailureTrace
                    }

                    results.WriteEndElement(); // Job

                    wttLog.EndTest(
                        sj.Name, 
                        succeeded?
                            Microsoft.DistributedAutomation.Logger.TestResult.Pass:
                            Microsoft.DistributedAutomation.Logger.TestResult.Fail,
                        null
                        );
                }

                results.WriteStartElement("Totals");
                results.WriteAttributeString("Succeeded", cSucceeded.ToString());
                results.WriteAttributeString("Failed", cFailed.ToString());
                results.WriteEndElement(); // Totals
            }

            results.WriteEndElement(); // Jobs
        }

        /// <summary>
        /// Loads plugin settings from the given node.
        /// </summary>
        /// <param name="node">The node to load settings from.</param>
        public void LoadSettings(XmlNode node)
        {
            // main settings
            XmlNode main = XmlUtil.GetGroupNode(node, "MainSettings");

            string sched = XmlUtil.GetChildNodeValue(main, "Scheduler", "");

            foreach (object obj in cmbScheduler.Items)
            {
                if (((Type)obj).FullName == sched)
                {
                    cmbScheduler.SelectedItem = obj;
                    break;
                }
            }

            float temp_splitterperc = XmlUtil.GetChildNodeValue(main, "SplitterPerc", -1f);
            if (temp_splitterperc >= 0.0001f)
            {
                splMain.SplitterDistance = (int)(splMain.Width * temp_splitterperc);
            }

            // if the setting exists, update, otherwise leave it alone
            bool val;
            if (XmlUtil.GetChildNodeValue(main, "PerfCountersEnabled", out val))
            {
                PerfCountersEnabled = val;
            }

            XmlNode cols = XmlUtil.GetGroupNode(main, "Columns");
            XmlNodeList cols_list = cols.SelectNodes("Column");

            // n^2 over a few items isn't terrible...
            // if perf goes to crap here we can rejigger
            foreach (XmlNode col in cols_list)
            {
                string name = XmlUtil.GetAttributeValue(col, "Name", "");

                foreach (StressColumn sc in _columns)
                {
                    if (sc.Name == name && !sc.Required)
                    {
                        sc.Visible = XmlUtil.GetAttributeValue(col, "Visible", sc.Visible);
                    }
                }
            }

            SyncColumns();

            // n^2 over a few items isn't terrible...
            // if perf goes to crap here we can rejigger
            foreach (XmlNode col in cols_list)
            {
                string name = XmlUtil.GetAttributeValue(col, "Name", "");

                foreach (StressColumn sc in _columns)
                {
                    if (sc.Name == name)
                    {
                        if (sc.Visible)
                        {
                            sc.Header.DisplayIndex =
                                XmlUtil.GetAttributeValue(col, "DisplayIndex", sc.Header.DisplayIndex);
                        }

                        sc.Header.Width = XmlUtil.GetAttributeValue(col, "Width", sc.Header.Width);
                    }
                }
            }

            // stress settings
            XmlNode sched_sett = XmlUtil.GetGroupNode(node, "SchedulerSettings");
            _scheduler.LoadSettings(sched_sett);

            XmlNode jobs = XmlUtil.GetGroupNode(node, "Jobs");
            XmlNodeList jobs_list = jobs.SelectNodes("Job");

            Dictionary<string, JobMetadata> jobMetadata = 
                new Dictionary<string, JobMetadata>();

            foreach (XmlNode job in jobs_list)
            {
                string name = XmlUtil.GetAttributeValue(job, "Name", "");
                float scale = XmlUtil.GetAttributeValue(job, "Scale", -1f);

                if (name != "" && scale >= 0f)
                {
                    JobScaleSettings[name] = scale;
                    jobMetadata[name] = new JobMetadata(job);
                }
            }

            // for anything already loaded
            foreach (StressJob sj in JobList)
            {
                string temp = sj.BaseNode.FullName;

                if (JobScaleSettings.ContainsKey(temp))
                {
                    _scheduler.SetScaleValue(sj, JobScaleSettings[temp]);
                }

                JobMetadata metadata;
                if (jobMetadata.TryGetValue(temp, out metadata))
                {
                    sj.BaseNode.StressData.Validation = metadata.ValidationData;
                    sj.Results.MaxFailureTraces = metadata.MaxFailureTraces;
                }
            }

            // need to display the correct thing
            if (jobs_list.Count != 0 && lstJobs.Items.Count != 0)
            {
                foreach (ListViewItem item in lstJobs.Items)
                {
                    ReloadScaleColumnForItem(item);
                }

                UpdateDetailsPane();
            }
        }

        /// <summary>
        /// Saves the main plugin settings to the given node.
        /// </summary>
        /// <param name="node">The node to save the settings under.</param>
        public void SaveMainSettings(XmlNode node)
        {
            XmlNode main = XmlUtil.GetGroupNode(node, "MainSettings");

            XmlUtil.SetChildNodeValue(main, "Scheduler", ((Type)cmbScheduler.SelectedItem).FullName);
            XmlUtil.SetChildNodeValue(main, "SplitterPerc", ((float)splMain.SplitterDistance) / splMain.Width);
            XmlUtil.SetChildNodeValue(main, "PerfCountersEnabled", PerfCountersEnabled);

            XmlNode cols = XmlUtil.GetGroupNode(main, "Columns");
            cols.RemoveAll();

            foreach (StressColumn sc in _columns)
            {
                XmlNode col = cols.OwnerDocument.CreateNode(XmlNodeType.Element, "Column", "");
                cols.AppendChild(col);

                XmlUtil.SetAttributeValue(col, "Name", sc.Name);
                XmlUtil.SetAttributeValue(col, "Visible", sc.Visible);
                if (sc.Visible)
                {
                    XmlUtil.SetAttributeValue(col, "DisplayIndex", sc.Header.DisplayIndex);
                }
                XmlUtil.SetAttributeValue(col, "Width", sc.Header.Width);
            }
        }

        /// <summary>
        /// Saves the stress settings, such as the scheduler specific settings and the scale values of the tests.
        /// </summary>
        /// <param name="node">The node to save the settings under.</param>
        public void SaveStressSettings(XmlNode node)
        {
            XmlNode main = XmlUtil.GetGroupNode(node, "MainSettings");

            XmlUtil.SetChildNodeValue(main, "Scheduler", ((Type)cmbScheduler.SelectedItem).FullName);

            XmlNode sched_sett = XmlUtil.GetGroupNode(node, "SchedulerSettings");
            _scheduler.SaveSettings(sched_sett);

            XmlNode jobs = XmlUtil.GetGroupNode(node, "Jobs");

            foreach (StressJob sj in JobList)
            {
                XmlNode job = jobs.OwnerDocument.CreateNode(XmlNodeType.Element, "Job", "");
                jobs.AppendChild(job);

                XmlUtil.SetAttributeValue(job, "Name", sj.BaseNode.FullName);
                XmlUtil.SetAttributeValue(job, "Scale", _scheduler.GetScaleValue(sj));
            }
        }

        /// <summary>
        /// Changes all of the stress job targets to 0.
        /// </summary>
        public void ZeroStressTargets()
        {
            foreach (ListViewItem item in lstJobs.Items)
            {
                ChangeScale(item, 0f);
            }
        }

        /// <summary>
        /// Resets the stress results for all jobs.
        /// </summary>
        public void ResetStressResults()
        {
            foreach (StressJob sj in JobList)
            {
                sj.Results.Reset();
            }
        }

        /// <summary> Syncs a schedulers settings to the relevent ui settings </summary>
        public void SyncSchedulerSettingsToUI()
        {
            if (miSkipPreRun!=null)
            {
                _scheduler.GetSettings().SkipPreRun=miSkipPreRun.Checked;
                _scheduler.GetSettings().SkipPostRun=miSkipPostRun.Checked;
            }
        }

        /// <summary>Backing for PerfCounterMenuItem.</summary>
        private MenuItem _perf_counter_menu_item = null;

        /// <summary>
        /// The MenuItem that displays the status of perf counters.
        /// </summary>
        public MenuItem PerfCounterMenuItem
        {
            get { return _perf_counter_menu_item; }
            set
            {
                // only update the enabled setting if we already had
                // a menu item
                if (_perf_counter_menu_item != null)
                {
                    _perf_counters_enabled = value.Checked;
                }

                _perf_counter_menu_item = value;
            }
        }

        /// <summary>Backing for PerfCountersEnabled.</summary>
        private bool _perf_counters_enabled = false;

        /// <summary>
        /// True if perf counters are being used, false if not.
        /// </summary>
        public bool PerfCountersEnabled
        {
            get
            {
                // this way we will set the checked state eventually
                if (_perf_counter_menu_item != null && _perf_counter_menu_item.Checked != _perf_counters_enabled)
                {
                    _perf_counter_menu_item.Checked = _perf_counters_enabled;
                }
                return _perf_counters_enabled;
            }
            set
            {
                _perf_counters_enabled = value;
                if (_perf_counter_menu_item != null) { _perf_counter_menu_item.Checked = value; }
            }
        }

        #endregion

        #region UI Event Handlers

        // Time for a new scheduler.
        private void cmbScheduler_SelectedIndexChanged(object send