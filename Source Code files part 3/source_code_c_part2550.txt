; 7FBC62
iir2_H_Parametric_f00314_q15_Gain06_a2    set -0.49894226       ; C022A9

; IIR2: mode=Parametric fc=396.85 Q=15 gainDB=6 h=< 0.50066286 -0.99707204 0.49800510 0.99707204 -0.49866796 >,< 4015B8 805FF2 3FBEA1 7FA00E C02BA6 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q15_Gain06_b0    set 0.50066286       ; 4015B8
iir2_H_Parametric_f00396_q15_Gain06_b1    set -0.99707204       ; 805FF2
iir2_H_Parametric_f00396_q15_Gain06_b2    set 0.49800510       ; 3FBEA1
iir2_H_Parametric_f00396_q15_Gain06_a1    set 0.99707204       ; 7FA00E
iir2_H_Parametric_f00396_q15_Gain06_a2    set -0.49866796       ; C02BA6

; IIR2: mode=Parametric fc=500 Q=15 gainDB=6 h=< 0.50083461 -0.99579075 0.49748824 0.99579075 -0.49832284 >,< 401B59 8089EE 3FADB1 7F7612 C036F5 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q15_Gain06_b0    set 0.50083461       ; 401B59
iir2_H_Parametric_f00500_q15_Gain06_b1    set -0.99579075       ; 8089EE
iir2_H_Parametric_f00500_q15_Gain06_b2    set 0.49748824       ; 3FADB1
iir2_H_Parametric_f00500_q15_Gain06_a1    set 0.99579075       ; 7F7612
iir2_H_Parametric_f00500_q15_Gain06_a2    set -0.49832284       ; C036F5

; IIR2: mode=Parametric fc=629.961 Q=15 gainDB=6 h=< 0.50105056 -0.99387218 0.49683832 0.99387218 -0.49788888 >,< 40226C 80C8CC 3F9866 7F3734 C0452E >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q15_Gain06_b0    set 0.50105056       ; 40226C
iir2_H_Parametric_f00629_q15_Gain06_b1    set -0.99387218       ; 80C8CC
iir2_H_Parametric_f00629_q15_Gain06_b2    set 0.49683832       ; 3F9866
iir2_H_Parametric_f00629_q15_Gain06_a1    set 0.99387218       ; 7F3734
iir2_H_Parametric_f00629_q15_Gain06_a2    set -0.49788888       ; C0452E

; IIR2: mode=Parametric fc=793.701 Q=15 gainDB=6 h=< 0.50132185 -0.99097358 0.49602185 0.99097358 -0.49734371 >,< 402B50 8127C7 3F7DA5 7ED839 C0570B >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q15_Gain06_b0    set 0.50132185       ; 402B50
iir2_H_Parametric_f00793_q15_Gain06_b1    set -0.99097358       ; 8127C7
iir2_H_Parametric_f00793_q15_Gain06_b2    set 0.49602185       ; 3F7DA5
iir2_H_Parametric_f00793_q15_Gain06_a1    set 0.99097358       ; 7ED839
iir2_H_Parametric_f00793_q15_Gain06_a2    set -0.49734371       ; C0570B

; IIR2: mode=Parametric fc=1000 Q=15 gainDB=6 h=< 0.50166221 -0.98656108 0.49499756 0.98656108 -0.49665976 >,< 403677 81B85E 3F5C14 7E47A2 C06D74 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q15_Gain06_b0    set 0.50166221       ; 403677
iir2_H_Parametric_f01000_q15_Gain06_b1    set -0.98656108       ; 81B85E
iir2_H_Parametric_f01000_q15_Gain06_b2    set 0.49499756       ; 3F5C14
iir2_H_Parametric_f01000_q15_Gain06_a1    set 0.98656108       ; 7E47A2
iir2_H_Parametric_f01000_q15_Gain06_a2    set -0.49665976       ; C06D74

; IIR2: mode=Parametric fc=1259.92 Q=15 gainDB=6 h=< 0.50208829 -0.97980257 0.49371526 0.97980257 -0.49580355 >,< 40446E 8295D5 3F320F 7D6A2B C08983 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q15_Gain06_b0    set 0.50208829       ; 40446E
iir2_H_Parametric_f01259_q15_Gain06_b1    set -0.97980257       ; 8295D5
iir2_H_Parametric_f01259_q15_Gain06_b2    set 0.49371526       ; 3F320F
iir2_H_Parametric_f01259_q15_Gain06_a1    set 0.97980257       ; 7D6A2B
iir2_H_Parametric_f01259_q15_Gain06_a2    set -0.49580355       ; C08983

; IIR2: mode=Parametric fc=1587.4 Q=15 gainDB=6 h=< 0.50261995 -0.96940246 0.49211520 0.96940246 -0.49473515 >,< 4055DA 83EA9F 3EFDA1 7C1561 C0AC85 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q15_Gain06_b0    set 0.50261995       ; 4055DA
iir2_H_Parametric_f01587_q15_Gain06_b1    set -0.96940246       ; 83EA9F
iir2_H_Parametric_f01587_q15_Gain06_b2    set 0.49211520       ; 3EFDA1
iir2_H_Parametric_f01587_q15_Gain06_a1    set 0.96940246       ; 7C1561
iir2_H_Parametric_f01587_q15_Gain06_a2    set -0.49473515       ; C0AC85

; IIR2: mode=Parametric fc=2000 Q=15 gainDB=6 h=< 0.50327999 -0.95334981 0.49012880 0.95334981 -0.49340879 >,< 406B7A 85F8A2 3EBC8A 7A075E C0D7FB >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q15_Gain06_b0    set 0.50327999       ; 406B7A
iir2_H_Parametric_f02000_q15_Gain06_b1    set -0.95334981       ; 85F8A2
iir2_H_Parametric_f02000_q15_Gain06_b2    set 0.49012880       ; 3EBC8A
iir2_H_Parametric_f02000_q15_Gain06_a1    set 0.95334981       ; 7A075E
iir2_H_Parametric_f02000_q15_Gain06_a2    set -0.49340879       ; C0D7FB

; IIR2: mode=Parametric fc=2519.84 Q=15 gainDB=6 h=< 0.50409284 -0.92854251 0.48768252 0.92854251 -0.49177536 >,< 40861D 892585 3E6C61 76DA7B C10D82 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q15_Gain06_b0    set 0.50409284       ; 40861D
iir2_H_Parametric_f02519_q15_Gain06_b1    set -0.92854251       ; 892585
iir2_H_Parametric_f02519_q15_Gain06_b2    set 0.48768252       ; 3E6C61
iir2_H_Parametric_f02519_q15_Gain06_a1    set 0.92854251       ; 76DA7B
iir2_H_Parametric_f02519_q15_Gain06_a2    set -0.49177536       ; C10D82

; IIR2: mode=Parametric fc=3174.8 Q=15 gainDB=6 h=< 0.50508107 -0.89024638 0.48470841 0.89024638 -0.48978948 >,< 40A67F 8E0C68 3E0AEC 71F398 C14E94 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q15_Gain06_b0    set 0.50508107       ; 40A67F
iir2_H_Parametric_f03174_q15_Gain06_b1    set -0.89024638       ; 8E0C68
iir2_H_Parametric_f03174_q15_Gain06_b2    set 0.48470841       ; 3E0AEC
iir2_H_Parametric_f03174_q15_Gain06_a1    set 0.89024638       ; 71F398
iir2_H_Parametric_f03174_q15_Gain06_a2    set -0.48978948       ; C14E94

; IIR2: mode=Parametric fc=4000 Q=15 gainDB=6 h=< 0.50625754 -0.83136582 0.48116782 0.83136582 -0.48742535 >,< 40CD0C 9595CE 3D96E8 6A6A32 C19C0C >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q15_Gain06_b0    set 0.50625754       ; 40CD0C
iir2_H_Parametric_f04000_q15_Gain06_b1    set -0.83136582       ; 9595CE
iir2_H_Parametric_f04000_q15_Gain06_b2    set 0.48116782       ; 3D96E8
iir2_H_Parametric_f04000_q15_Gain06_a1    set 0.83136582       ; 6A6A32
iir2_H_Parametric_f04000_q15_Gain06_a2    set -0.48742535       ; C19C0C

; IIR2: mode=Parametric fc=5039.68 Q=15 gainDB=6 h=< 0.50760918 -0.74158555 0.47710002 0.74158555 -0.48470920 >,< 40F956 A113BA 3D119D 5EEC46 C1F50D >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q15_Gain06_b0    set 0.50760918       ; 40F956
iir2_H_Parametric_f05039_q15_Gain06_b1    set -0.74158555       ; A113BA
iir2_H_Parametric_f05039_q15_Gain06_b2    set 0.47710002       ; 3D119D
iir2_H_Parametric_f05039_q15_Gain06_a1    set 0.74158555       ; 5EEC46
iir2_H_Parametric_f05039_q15_Gain06_a2    set -0.48470920       ; C1F50D

; IIR2: mode=Parametric fc=6349.6 Q=15 gainDB=6 h=< 0.50906619 -0.60669054 0.47271512 0.60669054 -0.48178131 >,< 412914 B257F7 3C81ED 4DA809 C254FE >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q15_Gain06_b0    set 0.50906619       ; 412914
iir2_H_Parametric_f06349_q15_Gain06_b1    set -0.60669054       ; B257F7
iir2_H_Parametric_f06349_q15_Gain06_b2    set 0.47271512       ; 3C81ED
iir2_H_Parametric_f06349_q15_Gain06_a1    set 0.60669054       ; 4DA809
iir2_H_Parametric_f06349_q15_Gain06_a2    set -0.48178131       ; C254FE

; IIR2: mode=Parametric fc=8000 Q=15 gainDB=6 h=< 0.51044726 -0.40899934 0.46855877 0.40899934 -0.47900602 >,< 415656 CBA5E9 3BF9BB 345A17 C2AFEF >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q15_Gain06_b0    set 0.51044726       ; 415656
iir2_H_Parametric_f08000_q15_Gain06_b1    set -0.40899934       ; CBA5E9
iir2_H_Parametric_f08000_q15_Gain06_b2    set 0.46855877       ; 3BF9BB
iir2_H_Parametric_f08000_q15_Gain06_a1    set 0.40899934       ; 345A17
iir2_H_Parametric_f08000_q15_Gain06_a2    set -0.47900602       ; C2AFEF

; IIR2: mode=Parametric fc=10079.4 Q=15 gainDB=6 h=< 0.51137293 -0.13125261 0.46577293 0.13125261 -0.47714586 >,< 4174AB EF331E 3B9E72 10CCE2 C2ECE3 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q15_Gain06_b0    set 0.51137293       ; 4174AB
iir2_H_Parametric_f10079_q15_Gain06_b1    set -0.13125261       ; EF331E
iir2_H_Parametric_f10079_q15_Gain06_b2    set 0.46577293       ; 3B9E72
iir2_H_Parametric_f10079_q15_Gain06_a1    set 0.13125261       ; 10CCE2
iir2_H_Parametric_f10079_q15_Gain06_a2    set -0.47714586       ; C2ECE3

; IIR2: mode=Parametric fc=12699.2 Q=15 gainDB=6 h=< 0.51115693 0.23098128 0.46642299 -0.23098128 -0.47757992 >,< 416D97 1D90CB 3BB3BF E26F35 C2DEAA >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q15_Gain06_b0    set 0.51115693       ; 416D97
iir2_H_Parametric_f12699_q15_Gain06_b1    set 0.23098128       ; 1D90CB
iir2_H_Parametric_f12699_q15_Gain06_b2    set 0.46642299       ; 3BB3BF
iir2_H_Parametric_f12699_q15_Gain06_a1    set -0.23098128       ; E26F35
iir2_H_Parametric_f12699_q15_Gain06_a2    set -0.47757992       ; C2DEAA

; IIR2: mode=Parametric fc=16000 Q=15 gainDB=6 h=< 0.50875934 0.63947863 0.47363857 -0.63947863 -0.48239792 >,< 411F06 51DA6F 3CA030 AE2591 C240C9 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q15_Gain06_b0    set 0.50875934       ; 411F06
iir2_H_Parametric_f16000_q15_Gain06_b1    set 0.63947863       ; 51DA6F
iir2_H_Parametric_f16000_q15_Gain06_b2    set 0.47363857       ; 3CA030
iir2_H_Parametric_f16000_q15_Gain06_a1    set -0.63947863       ; AE2591
iir2_H_Parametric_f16000_q15_Gain06_a2    set -0.48239792       ; C240C9

; IIR2: mode=Parametric fc=20158.7 Q=15 gainDB=6 h=< 0.50310722 0.95789627 0.49064877 -0.95789627 -0.49375599 >,< 4065D1 7A9C58 3ECD94 8563A8 C0CC9B >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q15_Gain06_b0    set 0.50310722       ; 4065D1
iir2_H_Parametric_f20158_q15_Gain06_b1    set 0.95789627       ; 7A9C58
iir2_H_Parametric_f20158_q15_Gain06_b2    set 0.49064877       ; 3ECD94
iir2_H_Parametric_f20158_q15_Gain06_a1    set -0.95789627       ; 8563A8
iir2_H_Parametric_f20158_q15_Gain06_a2    set -0.49375599       ; C0CC9B

; IIR2: mode=Parametric fc=62.5 Q=1 gainDB=12 h=< 0.50345833 -0.99764025 0.49422148 0.99764025 -0.49767981 >,< 407152 804D53 3F42A6 7FB2AD C04C08 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q01_Gain12_b0    set 0.50345833       ; 407152
iir2_H_Parametric_f00062_q01_Gain12_b1    set -0.99764025       ; 804D53
iir2_H_Parametric_f00062_q01_Gain12_b2    set 0.49422148       ; 3F42A6
iir2_H_Parametric_f00062_q01_Gain12_a1    set 0.99764025       ; 7FB2AD
iir2_H_Parametric_f00062_q01_Gain12_a2    set -0.49767981       ; C04C08

; IIR2: mode=Parametric fc=78.7451 Q=1 gainDB=12 h=< 0.50435456 -0.99701577 0.49272396 0.99701577 -0.49707853 >,< 408EB0 8061CA 3F1194 7F9E36 C05FBB >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q01_Gain12_b0    set 0.50435456       ; 408EB0
iir2_H_Parametric_f00078_q01_Gain12_b1    set -0.99701577       ; 8061CA
iir2_H_Parametric_f00078_q01_Gain12_b2    set 0.49272396       ; 3F1194
iir2_H_Parametric_f00078_q01_Gain12_a1    set 0.99701577       ; 7F9E36
iir2_H_Parametric_f00078_q01_Gain12_a2    set -0.49707853       ; C05FBB

; IIR2: mode=Parametric fc=99.2126 Q=1 gainDB=12 h=< 0.50548217 -0.99622248 0.49083984 0.99622248 -0.49632201 >,< 40B3A4 807BC8 3ED3D7 7F8438 C07886 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q01_Gain12_b0    set 0.50548217       ; 40B3A4
iir2_H_Parametric_f00099_q01_Gain12_b1    set -0.99622248       ; 807BC8
iir2_H_Parametric_f00099_q01_Gain12_b2    set 0.49083984       ; 3ED3D7
iir2_H_Parametric_f00099_q01_Gain12_a1    set 0.99622248       ; 7F8438
iir2_H_Parametric_f00099_q01_Gain12_a2    set -0.49632201       ; C07886

; IIR2: mode=Parametric fc=125 Q=1 gainDB=12 h=< 0.50690038 -0.99521269 0.48847017 0.99521269 -0.49537054 >,< 40E21C 809CDF 3E8630 7F6321 C097B3 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q01_Gain12_b0    set 0.50690038       ; 40E21C
iir2_H_Parametric_f00125_q01_Gain12_b1    set -0.99521269       ; 809CDF
iir2_H_Parametric_f00125_q01_Gain12_b2    set 0.48847017       ; 3E8630
iir2_H_Parametric_f00125_q01_Gain12_a1    set 0.99521269       ; 7F6321
iir2_H_Parametric_f00125_q01_Gain12_a2    set -0.49537054       ; C097B3

; IIR2: mode=Parametric fc=157.49 Q=1 gainDB=12 h=< 0.50868321 -0.99392417 0.48549123 0.99392417 -0.49417444 >,< 411C88 80C718 3E2493 7F38E8 C0BEE5 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q01_Gain12_b0    set 0.50868321       ; 411C88
iir2_H_Parametric_f00157_q01_Gain12_b1    set -0.99392417       ; 80C718
iir2_H_Parametric_f00157_q01_Gain12_b2    set 0.48549123       ; 3E2493
iir2_H_Parametric_f00157_q01_Gain12_a1    set 0.99392417       ; 7F38E8
iir2_H_Parametric_f00157_q01_Gain12_a2    set -0.49417444       ; C0BEE5

; IIR2: mode=Parametric fc=198.425 Q=1 gainDB=12 h=< 0.51092309 -0.99227504 0.48174862 0.99227504 -0.49267171 >,< 4165ED 80FD22 3DA9F0 7F02DE C0F023 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q01_Gain12_b0    set 0.51092309       ; 4165ED
iir2_H_Parametric_f00198_q01_Gain12_b1    set -0.99227504       ; 80FD22
iir2_H_Parametric_f00198_q01_Gain12_b2    set 0.48174862       ; 3DA9F0
iir2_H_Parametric_f00198_q01_Gain12_a1    set 0.99227504       ; 7F02DE
iir2_H_Parametric_f00198_q01_Gain12_a2    set -0.49267171       ; C0F023

; IIR2: mode=Parametric fc=250 Q=1 gainDB=12 h=< 0.51373500 -0.99015675 0.47705020 0.99015675 -0.49078520 >,< 41C211 81428B 3D0FFB 7EBD75 C12DF4 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q01_Gain12_b0    set 0.51373500       ; 41C211
iir2_H_Parametric_f00250_q01_Gain12_b1    set -0.99015675       ; 81428B
iir2_H_Parametric_f00250_q01_Gain12_b2    set 0.47705020       ; 3D0FFB
iir2_H_Parametric_f00250_q01_Gain12_a1    set 0.99015675       ; 7EBD75
iir2_H_Parametric_f00250_q01_Gain12_a2    set -0.49078520       ; C12DF4

; IIR2: mode=Parametric fc=314.98 Q=1 gainDB=12 h=< 0.51726154 -0.98742409 0.47115769 0.98742409 -0.48841924 >,< 4235A0 819C17 3C4EE5 7E63E9 C17B7B >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q01_Gain12_b0    set 0.51726154       ; 4235A0
iir2_H_Parametric_f00314_q01_Gain12_b1    set -0.98742409       ; 819C17
iir2_H_Parametric_f00314_q01_Gain12_b2    set 0.47115769       ; 3C4EE5
iir2_H_Parametric_f00314_q01_Gain12_a1    set 0.98742409       ; 7E63E9
iir2_H_Parametric_f00314_q01_Gain12_a2    set -0.48841924       ; C17B7B

; IIR2: mode=Parametric fc=396.85 Q=1 gainDB=12 h=< 0.52167870 -0.98388096 0.46377707 0.98388096 -0.48545577 >,< 42C65E 821031 3B5D0C 7DEFCF C1DC96 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q01_Gain12_b0    set 0.52167870       ; 42C65E
iir2_H_Parametric_f00396_q01_Gain12_b1    set -0.98388096       ; 821031
iir2_H_Parametric_f00396_q01_Gain12_b2    set 0.46377707       ; 3B5D0C
iir2_H_Parametric_f00396_q01_Gain12_a1    set 0.98388096       ; 7DEFCF
iir2_H_Parametric_f00396_q01_Gain12_a2    set -0.48545577       ; C1DC96

; IIR2: mode=Parametric fc=500 Q=1 gainDB=12 h=< 0.52720222 -0.97925998 0.45454781 0.97925998 -0.48175004 >,< 437B5D 82A79C 3A2E9F 7D5864 C25604 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q01_Gain12_b0    set 0.52720222       ; 437B5D
iir2_H_Parametric_f00500_q01_Gain12_b1    set -0.97925998       ; 82A79C
iir2_H_Parametric_f00500_q01_Gain12_b2    set 0.45454781       ; 3A2E9F
iir2_H_Parametric_f00500_q01_Gain12_a1    set 0.97925998       ; 7D5864
iir2_H_Parametric_f00500_q01_Gain12_a2    set -0.48175004       ; C25604

; IIR2: mode=Parametric fc=629.961 Q=1 gainDB=12 h=< 0.53409428 -0.97319303 0.44303187 0.97319303 -0.47712616 >,< 445D33 836E69 38B544 7C9197 C2ED88 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q01_Gain12_b0    set 0.53409428       ; 445D33
iir2_H_Parametric_f00629_q01_Gain12_b1    set -0.97319303       ; 836E69
iir2_H_Parametric_f00629_q01_Gain12_b2    set 0.44303187       ; 38B544
iir2_H_Parametric_f00629_q01_Gain12_a1    set 0.97319303       ; 7C9197
iir2_H_Parametric_f00629_q01_Gain12_a2    set -0.47712616       ; C2ED88

; IIR2: mode=Parametric fc=793.701 Q=1 gainDB=12 h=< 0.54266950 -0.96516880 0.42870354 0.96516880 -0.47137305 >,< 457631 84755A 36DFC2 7B8AA6 C3AA0D >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q01_Gain12_b0    set 0.54266950       ; 457631
iir2_H_Parametric_f00793_q01_Gain12_b1    set -0.96516880       ; 84755A
iir2_H_Parametric_f00793_q01_Gain12_b2    set 0.42870354       ; 36DFC2
iir2_H_Parametric_f00793_q01_Gain12_a1    set 0.96516880       ; 7B8AA6
iir2_H_Parametric_f00793_q01_Gain12_a2    set -0.47137305       ; C3AA0D

; IIR2: mode=Parametric fc=1000 Q=1 gainDB=12 h=< 0.55329869 -0.95447172 0.41094323 0.95447172 -0.46424192 >,< 46D27E 85D3DF 3499C9 7A2C21 C493B9 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q01_Gain12_b0    set 0.55329869       ; 46D27E
iir2_H_Parametric_f01000_q01_Gain12_b1    set -0.95447172       ; 85D3DF
iir2_H_Parametric_f01000_q01_Gain12_b2    set 0.41094323       ; 3499C9
iir2_H_Parametric_f01000_q01_Gain12_a1    set 0.95447172       ; 7A2C21
iir2_H_Parametric_f01000_q01_Gain12_a2    set -0.46424192       ; C493B9

; IIR2: mode=Parametric fc=1259.92 Q=1 gainDB=12 h=< 0.56640733 -0.94009483 0.38904001 0.94009483 -0.45544734 >,< 488009 87AAF9 31CC10 785507 C5B3E7 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q01_Gain12_b0    set 0.56640733       ; 488009
iir2_H_Parametric_f01259_q01_Gain12_b1    set -0.94009483       ; 87AAF9
iir2_H_Parametric_f01259_q01_Gain12_b2    set 0.38904001       ; 31CC10
iir2_H_Parametric_f01259_q01_Gain12_a1    set 0.94009483       ; 785507
iir2_H_Parametric_f01259_q01_Gain12_a2    set -0.45544734       ; C5B3E7

; IIR2: mode=Parametric fc=1587.4 Q=1 gainDB=12 h=< 0.58246342 -0.92061749 0.36221191 0.92061749 -0.44467532 >,< 4A8E29 8A2935 2E5CF5 75D6CB C714E1 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q01_Gain12_b0    set 0.58246342       ; 4A8E29
iir2_H_Parametric_f01587_q01_Gain12_b1    set -0.92061749       ; 8A2935
iir2_H_Parametric_f01587_q01_Gain12_b2    set 0.36221191       ; 2E5CF5
iir2_H_Parametric_f01587_q01_Gain12_a1    set 0.92061749       ; 75D6CB
iir2_H_Parametric_f01587_q01_Gain12_a2    set -0.44467532       ; C714E1

; IIR2: mode=Parametric fc=2000 Q=1 gainDB=12 h=< 0.60194578 -0.89403787 0.32965884 0.89403787 -0.43160461 >,< 4D0C8F 8D902B 2A3242 726FD5 C8C12E >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q01_Gain12_b0    set 0.60194578       ; 4D0C8F
iir2_H_Parametric_f02000_q01_Gain12_b1    set -0.89403787       ; 8D902B
iir2_H_Parametric_f02000_q01_Gain12_b2    set 0.32965884       ; 2A3242
iir2_H_Parametric_f02000_q01_Gain12_a1    set 0.89403787       ; 726FD5
iir2_H_Parametric_f02000_q01_Gain12_a2    set -0.43160461       ; C8C12E

; IIR2: mode=Parametric fc=2519.84 Q=1 gainDB=12 h=< 0.62527843 -0.85755226 0.29067231 0.85755226 -0.41595074 >,< 50091F 923BBA 2534C0 6DC446 CAC221 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q01_Gain12_b0    set 0.62527843       ; 50091F
iir2_H_Parametric_f02519_q01_Gain12_b1    set -0.85755226       ; 923BBA
iir2_H_Parametric_f02519_q01_Gain12_b2    set 0.29067231       ; 2534C0
iir2_H_Parametric_f02519_q01_Gain12_a1    set 0.85755226       ; 6DC446
iir2_H_Parametric_f02519_q01_Gain12_a2    set -0.41595074       ; CAC221

; IIR2: mode=Parametric fc=3174.8 Q=1 gainDB=12 h=< 0.65270845 -0.80728158 0.24483951 0.80728158 -0.39754795 >,< 538BF3 98AAFF 1F56E6 675501 CD1D26 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q01_Gain12_b0    set 0.65270845       ; 538BF3
iir2_H_Parametric_f03174_q01_Gain12_b1    set -0.80728158       ; 98AAFF
iir2_H_Parametric_f03174_q01_Gain12_b2    set 0.24483951       ; 1F56E6
iir2_H_Parametric_f03174_q01_Gain12_a1    set 0.80728158       ; 675501
iir2_H_Parametric_f03174_q01_Gain12_a2    set -0.39754795       ; CD1D26

; IIR2: mode=Parametric fc=4000 Q=1 gainDB=12 h=< 0.68409397 -0.73796465 0.19239746 0.73796465 -0.37649142 >,< 579064 A18A60 18A07A 5E75A0 CFCF21 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q01_Gain12_b0    set 0.68409397       ; 579064
iir2_H_Parametric_f04000_q01_Gain12_b1    set -0.73796465       ; A18A60
iir2_H_Parametric_f04000_q01_Gain12_b2    set 0.19239746       ; 18A07A
iir2_H_Parametric_f04000_q01_Gain12_a1    set 0.73796465       ; 5E75A0
iir2_H_Parametric_f04000_q01_Gain12_a2    set -0.37649142       ; CFCF21

; IIR2: mode=Parametric fc=5039.68 Q=1 gainDB=12 h=< 0.71855503 -0.64267499 0.13481647 0.64267499 -0.35337150 >,< 5BF99C ADBCD4 1141AA 52432C D2C4B9 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q01_Gain12_b0    set 0.71855503       ; 5BF99C
iir2_H_Parametric_f05039_q01_Gain12_b1    set -0.64267499       ; ADBCD4
iir2_H_Parametric_f05039_q01_Gain12_b2    set 0.13481647       ; 1141AA
iir2_H_Parametric_f05039_q01_Gain12_a1    set 0.64267499       ; 52432C
iir2_H_Parametric_f05039_q01_Gain12_a2    set -0.35337150       ; D2C4B9

; IIR2: mode=Parametric fc=6349.6 Q=1 gainDB=12 h=< 0.75391915 -0.51267855 0.07572658 0.51267855 -0.32964573 >,< 60806C BE608D 09B168 419F73 D5CE2C >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q01_Gain12_b0    set 0.75391915       ; 60806C
iir2_H_Parametric_f06349_q01_Gain12_b1    set -0.51267855       ; BE608D
iir2_H_Parametric_f06349_q01_Gain12_b2    set 0.07572658       ; 09B168
iir2_H_Parametric_f06349_q01_Gain12_a1    set 0.51267855       ; 419F73
iir2_H_Parametric_f06349_q01_Gain12_a2    set -0.32964573       ; D5CE2C

; IIR2: mode=Parametric fc=8000 Q=1 gainDB=12 h=< 0.78585157 -0.33765101 0.02237070 0.33765101 -0.30822228 >,< 6496C9 D4C7DA 02DD0B 2B3826 D88C2D >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q01_Gain12_b0    set 0.78585157       ; 6496C9
iir2_H_Parametric_f08000_q01_Gain12_b1    set -0.33765101       ; D4C7DA
iir2_H_Parametric_f08000_q01_Gain12_b2    set 0.02237070       ; 02DD0B
iir2_H_Parametric_f08000_q01_Gain12_a1    set 0.33765101       ; 2B3826
iir2_H_Parametric_f08000_q01_Gain12_a2    set -0.30822228       ; D88C2D

; IIR2: mode=Parametric fc=10079.4 Q=1 gainDB=12 h=< 0.80644275 -0.10670677 -0.01203509 0.10670677 -0.29440766 >,< 673984 F2576F FE75A3 0DA891 DA50DA >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q01_Gain12_b0    set 0.80644275       ; 673984
iir2_H_Parametric_f10079_q01_Gain12_b1    set -0.10670677       ; F2576F
iir2_H_Parametric_f10079_q01_Gain12_b2    set -0.01203509       ; FE75A3
iir2_H_Parametric_f10079_q01_Gain12_a1    set 0.10670677       ; 0DA891
iir2_H_Parametric_f10079_q01_Gain12_a2    set -0.29440766       ; DA50DA

; IIR2: mode=Parametric fc=12699.2 Q=1 gainDB=12 h=< 0.80169412 0.18845433 -0.00410061 -0.18845433 -0.29759351 >,< 669DE9 181F45 FF79A2 E7E0BB D9E875 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q01_Gain12_b0    set 0.80169412       ; 669DE9
iir2_H_Parametric_f12699_q01_Gain12_b1    set 0.18845433       ; 181F45
iir2_H_Parametric_f12699_q01_Gain12_b2    set -0.00410061       ; FF79A2
iir2_H_Parametric_f12699_q01_Gain12_a1    set -0.18845433       ; E7E0BB
iir2_H_Parametric_f12699_q01_Gain12_a2    set -0.29759351       ; D9E875

; IIR2: mode=Parametric fc=16000 Q=1 gainDB=12 h=< 0.74661872 0.54323486 0.08792487 -0.54323486 -0.33454359 >,< 5F9133 4588B8 0B411F BA7748 D52DAD >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q01_Gain12_b0    set 0.74661872       ; 5F9133
iir2_H_Parametric_f16000_q01_Gain12_b1    set 0.54323486       ; 4588B8
iir2_H_Parametric_f16000_q01_Gain12_b2    set 0.08792487       ; 0B411F
iir2_H_Parametric_f16000_q01_Gain12_a1    set -0.54323486       ; BA7748
iir2_H_Parametric_f16000_q01_Gain12_a2    set -0.33454359       ; D52DAD

; IIR2: mode=Parametric fc=20158.7 Q=1 gainDB=12 h=< 0.59689324 0.90125505 0.33810112 -0.90125505 -0.43499436 >,< 4C66FF 735C53 2B46E5 8CA3AD C8521B >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q01_Gain12_b0    set 0.59689324       ; 4C66FF
iir2_H_Parametric_f20158_q01_Gain12_b1    set 0.90125505       ; 735C53
iir2_H_Parametric_f20158_q01_Gain12_b2    set 0.33810112       ; 2B46E5
iir2_H_Parametric_f20158_q01_Gain12_a1    set -0.90125505       ; 8CA3AD
iir2_H_Parametric_f20158_q01_Gain12_a2    set -0.43499436       ; C8521B

; IIR2: mode=Parametric fc=62.5 Q=6 gainDB=12 h=< 0.50055478 -0.99958817 0.49907303 0.99958817 -0.49962780 >,< 40122E 800D7F 3FE1A0 7FF281 C00C33 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q06_Gain12_b0    set 0.50055478       ; 40122E
iir2_H_Parametric_f00062_q06_Gain12_b1    set -0.99958817       ; 800D7F
iir2_H_Parametric_f00062_q06_Gain12_b2    set 0.49907303       ; 3FE1A0
iir2_H_Parametric_f00062_q06_Gain12_a1    set 0.99958817       ; 7FF281
iir2_H_Parametric_f00062_q06_Gain12_a2    set -0.49962780       ; C00C33

; IIR2: mode=Parametric fc=78.7451 Q=6 gainDB=12 h=< 0.50069890 -0.99946820 0.49883221 0.99946820 -0.49953111 >,< 4016E7 80116D 3FD9BB 7FEE93 C00F5E >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q06_Gain12_b0    set 0.50069890       ; 4016E7
iir2_H_Parametric_f00078_q06_Gain12_b1    set -0.99946820       ; 80116D
iir2_H_Parametric_f00078_q06_Gain12_b2    set 0.49883221       ; 3FD9BB
iir2_H_Parametric_f00078_q06_Gain12_a1    set 0.99946820       ; 7FEE93
iir2_H_Parametric_f00078_q06_Gain12_a2    set -0.49953111       ; C00F5E

; IIR2: mode=Parametric fc=99.2126 Q=6 gainDB=12 h=< 0.50088044 -0.99930947 0.49852887 0.99930947 -0.49940931 >,< 401CD9 8016A1 3FCFCB 7FE95F C0135B >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q06_Gain12_b0    set 0.50088044       ; 401CD9
iir2_H_Parametric_f00099_q06_Gain12_b1    set -0.99930947       ; 8016A1
iir2_H_Parametric_f00099_q06_Gain12_b2    set 0.49852887       ; 3FCFCB
iir2_H_Parametric_f00099_q06_Gain12_a1    set 0.99930947       ; 7FE95F
iir2_H_Parametric_f00099_q06_Gain12_a2    set -0.49940931       ; C0135B

; IIR2: mode=Parametric fc=125 Q=6 gainDB=12 h=< 0.50110910 -0.99909744 0.49814681 0.99909744 -0.49925591 >,< 402458 801D93 3FC346 7FE26D C01862 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q06_Gain12_b0    set 0.50110910       ; 402458
iir2_H_Parametric_f00125_q06_Gain12_b1    set -0.99909744       ; 801D93
iir2_H_Parametric_f00125_q06_Gain12_b2    set 0.49814681       ; 3FC346
iir2_H_Parametric_f00125_q06_Gain12_a1    set 0.99909744       ; 7FE26D
iir2_H_Parametric_f00125_q06_Gain12_a2    set -0.49925591       ; C01862

; IIR2: mode=Parametric fc=157.49 Q=6 gainDB=12 h=< 0.50139706 -0.99881122 0.49766566 0.99881122 -0.49906271 >,< 402DC7 8026F4 3FB382 7FD90C C01EB7 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q06_Gain12_b0    set 0.50139706       ; 402DC7
iir2_H_Parametric_f00157_q06_Gain12_b1    set -0.99881122       ; 8026F4
iir2_H_Parametric_f00157_q06_Gain12_b2    set 0.49766566       ; 3FB382
iir2_H_Parametric_f00157_q06_Gain12_a1    set 0.99881122       ; 7FD90C
iir2_H_Parametric_f00157_q06_Gain12_a2    set -0.49906271       ; C01EB7

; IIR2: mode=Parametric fc=198.425 Q=6 gainDB=12 h=< 0.50175967 -0.99842032 0.49705977 0.99842032 -0.49881944 >,< 4039A9 8033C4 3F9FA7 7FCC3C C026B0 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q06_Gain12_b0    set 0.50175967       ; 4039A9
iir2_H_Parametric_f00198_q06_Gain12_b1    set -0.99842032       ; 8033C4
iir2_H_Parametric_f00198_q06_Gain12_b2    set 0.49705977       ; 3F9FA7
iir2_H_Parametric_f00198_q06_Gain12_a1    set 0.99842032       ; 7FCC3C
iir2_H_Parametric_f00198_q06_Gain12_a2    set -0.49881944       ; C026B0

; IIR2: mode=Parametric fc=250 Q=6 gainDB=12 h=< 0.50221619 -0.99787981 0.49629697 0.99787981 -0.49851316 >,< 40489E 80457A 3F86A8 7FBA86 C030B9 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q06_Gain12_b0    set 0.50221619       ; 40489E
iir2_H_Parametric_f00250_q06_Gain12_b1    set -0.99787981       ; 80457A
iir2_H_Parametric_f00250_q06_Gain12_b2    set 0.49629697       ; 3F86A8
iir2_H_Parametric_f00250_q06_Gain12_a1    set 0.99787981       ; 7FBA86
iir2_H_Parametric_f00250_q06_Gain12_a2    set -0.49851316       ; C030B9

; IIR2: mode=Parametric fc=314.98 Q=6 gainDB=12 h=< 0.50279080 -0.99712273 0.49533685 0.99712273 -0.49812765 >,< 405B73 805E49 3F6732 7FA1B7 C03D5B >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q06_Gain12_b0    set 0.50279080       ; 405B73
iir2_H_Parametric_f00314_q06_Gain12_b1    set -0.99712273       ; 805E49
iir2_H_Parametric_f00314_q06_Gain12_b2    set 0.49533685       ; 3F6732
iir2_H_Parametric_f00314_q06_Gain12_a1    set 0.99712273       ; 7FA1B7
iir2_H_Parametric_f00314_q06_Gain12_a2    set -0.49812765       ; C03D5B

; IIR2: mode=Parametric fc=396.85 Q=6 gainDB=12 h=< 0.50351379 -0.99604832 0.49412882 0.99604832 -0.49764260 >,< 407324 80817D 3F3F9D 7F7E83 C04D40 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q06_Gain12_b0    set 0.50351379       ; 407324
iir2_H_Parametric_f00396_q06_Gain12_b1    set -0.99604832       ; 80817D
iir2_H_Parametric_f00396_q06_Gain12_b2    set 0.49412882       ; 3F3F9D
iir2_H_Parametric_f00396_q06_Gain12_a1    set 0.99604832       ; 7F7E83
iir2_H_Parametric_f00396_q06_Gain12_a2    set -0.49764260       ; C04D40

; IIR2: mode=Parametric fc=500 Q=6 gainDB=12 h=< 0.50442300 -0.99450379 0.49260961 0.99450379 -0.49703261 >,< 4090EF 80B41A 3F0DD5 7F4BE6 C0613D >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q06_Gain12_b0    set 0.50442300       ; 4090EF
iir2_H_Parametric_f00500_q06_Gain12_b1    set -0.99450379       ; 80B41A
iir2_H_Parametric_f00500_q06_Gain12_b2    set 0.49260961       ; 3F0DD5
iir2_H_Parametric_f00500_q06_Gain12_a1    set 0.99450379       ; 7F4BE6
iir2_H_Parametric_f00500_q06_Gain12_a2    set -0.49703261       ; C0613D

; IIR2: mode=Parametric fc=629.961 Q=6 gainDB=12 h=< 0.50556558 -0.99225588 0.49070047 0.99225588 -0.49626605 >,< 40B65F 80FDC3 3ECF46 7F023D C07A5B >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q06_Gain12_b0    set 0.50556558       ; 40B65F
iir2_H_Parametric_f00629_q06_Gain12_b1    set -0.99225588       ; 80FDC3
iir2_H_Parametric_f00629_q06_Gain12_b2    set 0.49070047       ; 3ECF46
iir2_H_Parametric_f00629_q06_Gain12_a1    set 0.99225588       ; 7F023D
iir2_H_Parametric_f00629_q06_Gain12_a2    set -0.49626605       ; C07A5B

; IIR2: mode=Parametric fc=793.701 Q=6 gainDB=12 h=< 0.50699989 -0.98894668 0.48830388 0.98894668 -0.49530378 >,< 40E55F 816A32 3E80BD 7E95CE C099E3 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q06_Gain12_b0    set 0.50699989       ; 40E55F
iir2_H_Parametric_f00793_q06_Gain12_b1    set -0.98894668       ; 816A32
iir2_H_Parametric_f00793_q06_Gain12_b2    set 0.48830388       ; 3E80BD
iir2_H_Parametric_f00793_q06_Gain12_a1    set 0.98894668       ; 7E95CE
iir2_H_Parametric_f00793_q06_Gain12_a2    set -0.49530378       ; C099E3

; IIR2: mode=Parametric fc=1000 Q=6 gainDB=12 h=< 0.50879759 -0.98402498 0.48530011 0.98402498 -0.49409770 >,< 412047 820B78 3E1E50 7DF488 C0C168 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q06_Gain12_b0    set 0.50879759       ; 412047
iir2_H_Parametric_f01000_q06_Gain12_b1    set -0.98402498       ; 820B78
iir2_H_Parametric_f01000_q06_Gain12_b2    set 0.48530011       ; 3E1E50
iir2_H_Parametric_f01000_q06_Gain12_a1    set 0.98402498       ; 7DF488
iir2_H_Parametric_f01000_q06_Gain12_a2    set -0.49409770       ; C0C168

; IIR2: mode=Parametric fc=1259.92 Q=6 gainDB=12 h=< 0.51104544 -0.97664029 0.48154417 0.97664029 -0.49258962 >,< 4169F0 82FD74 3DA33D 7D028C C0F2D3 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q06_Gain12_b0    set 0.51104544       ; 4169F0
iir2_H_Parametric_f01259_q06_Gain12_b1    set -0.97664029       ; 82FD74
iir2_H_Parametric_f01259_q06_Gain12_b2    set 0.48154417       ; 3DA33D
iir2_H_Parametric_f01259_q06_Gain12_a1    set 0.97664029       ; 7D028C
iir2_H_Parametric_f01259_q06_Gain12_a2    set -0.49258962       ; C0F2D3

; IIR2: mode=Parametric fc=1587.4 Q=6 gainDB=12 h=< 0.51384617 -0.96548041 0.47686444 0.96548041 -0.49071061 >,< 41C5B6 846B24 3D09E4 7B94DC C13065 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q06_Gain12_b0    set 0.51384617       ; 41C5B6
iir2_H_Parametric_f01587_q06_Gain12_b1    set -0.96548041       ; 846B24
iir2_H_Parametric_f01587_q06_Gain12_b2    set 0.47686444       ; 3D09E4
iir2_H_Parametric_f01587_q06_Gain12_a1    set 0.96548041       ; 7B94DC
iir2_H_Parametric_f01587_q06_Gain12_a2    set -0.49071061       ; C13065

; IIR2: mode=Parametric fc=2000 Q=6 gainDB=12 h=< 0.51731676 -0.94852590 0.47106543 0.94852590 -0.48838219 >,< 42376F 8696B4 3C4BDF 79694C C17CB2 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q06_Gain12_b0    set 0.51731676       ; 42376F
iir2_H_Parametric_f02000_q06_Gain12_b1    set -0.94852590       ; 8696B4
iir2_H_Parametric_f02000_q06_Gain12_b2    set 0.47106543       ; 3C4BDF
iir2_H_Parametric_f02000_q06_Gain12_a1    set 0.94852590       ; 79694C
iir2_H_Parametric_f02000_q06_Gain12_a2    set -0.48838219       ; C17CB2

; IIR2: mode=Parametric fc=2519.84 Q=6 gainDB=12 h=< 0.52158114 -0.92268712 0.46394009 0.92268712 -0.48552122 >,< 42C32B 89E564 3B6263 761A9C C1DA71 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q06_Gain12_b0    set 0.52158114       ; 42C32B
iir2_H_Parametric_f02519_q06_Gain12_b1    set -0.92268712       ; 89E564
iir2_H_Parametric_f02519_q06_Gain12_b2    set 0.46394009       ; 3B6263
iir2_H_Parametric_f02519_q06_Gain12_a1    set 0.92268712       ; 761A9C
iir2_H_Parametric_f02519_q06_Gain12_a2    set -0.48552122       ; C1DA71

; IIR2: mode=Parametric fc=3174.8 Q=6 gainDB=12 h=< 0.52675126 -0.88328759 0.45530133 0.88328759 -0.48205259 >,< 436C96 8EF06F 3A4750 710F91 C24C1A >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q06_Gain12_b0    set 0.52675126       ; 436C96
iir2_H_Parametric_f03174_q06_Gain12_b1    set -0.88328759       ; 8EF06F
iir2_H_Parametric_f03174_q06_Gain12_b2    set 0.45530133       ; 3A4750
iir2_H_Parametric_f03174_q06_Gain12_a1    set 0.88328759       ; 710F91
iir2_H_Parametric_f03174_q06_Gain12_a2    set -0.48205259       ; C24C1A

; IIR2: mode=Parametric fc=4000 Q=6 gainDB=12 h=< 0.53288569 -0.82337708 0.44505132 0.82337708 -0.47793700 >,< 443599 969B95 38F771 69646B C2D2F6 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q06_Gain12_b0    set 0.53288569       ; 443599
iir2_H_Parametric_f04000_q06_Gain12_b1    set -0.82337708       ; 969B95
iir2_H_Parametric_f04000_q06_Gain12_b2    set 0.44505132       ; 38F771
iir2_H_Parametric_f04000_q06_Gain12_a1    set 0.82337708       ; 69646B
iir2_H_Parametric_f04000_q06_Gain12_a2    set -0.47793700       ; C2D2F6

; IIR2: mode=Parametric fc=5039.68 Q=6 gainDB=12 h=< 0.53990625 -0.73293823 0.43332066 0.73293823 -0.47322691 >,< 451BA6 A22F15 37770D 5DD0EB C36D4D >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q06_Gain12_b0    set 0.53990625       ; 451BA6
iir2_H_Parametric_f05039_q06_Gain12_b1    set -0.73293823       ; A22F15
iir2_H_Parametric_f05039_q06_Gain12_b2    set 0.43332066       ; 37770D
iir2_H_Parametric_f05039_q06_Gain12_a1    set 0.73293823       ; 5DD0EB
iir2_H_Parametric_f05039_q06_Gain12_a2    set -0.47322691       ; C36D4D

; IIR2: mode=Parametric fc=6349.6 Q=6 gainDB=12 h=< 0.54744158 -0.59828035 0.42072987 0.59828035 -0.46817146 >,< 461291 B36B8D 35DA7A 4C9473 C412F6 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q06_Gain12_b0    set 0.54744158       ; 461291
iir2_H_Parametric_f06349_q06_Gain12_b1    set -0.59828035       ; B36B8D
iir2_H_Parametric_f06349_q06_Gain12_b2    set 0.42072987       ; 35DA7A
iir2_H_Parametric_f06349_q06_Gain12_a1    set 0.59828035       ; 4C9473
iir2_H_Parametric_f06349_q06_Gain12_a2    set -0.46817146       ; C412F6

; IIR2: mode=Parametric fc=8000 Q=6 gainDB=12 h=< 0.55455325 -0.40247971 0.40884699 0.40247971 -0.46340024 >,< 46FB9A CC7B8C 345519 338474 C4AF4D >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q06_Gain12_b0    set 0.55455325       ; 46FB9A
iir2_H_Parametric_f08000_q06_Gain12_b1    set -0.40247971       ; CC7B8C
iir2_H_Parametric_f08000_q06_Gain12_b2    set 0.40884699       ; 345519
iir2_H_Parametric_f08000_q06_Gain12_a1    set 0.40247971       ; 338474
iir2_H_Parametric_f08000_q06_Gain12_a2    set -0.46340024       ; C4AF4D

; IIR2: mode=Parametric fc=10079.4 Q=6 gainDB=12 h=< 0.55930317 -0.12897822 0.40091036 0.12897822 -0.46021353 >,< 47973F EF7DA5 335107 10825B C517BA >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q06_Gain12_b0    set 0.55930317       ; 47973F
iir2_H_Parametric_f10079_q06_Gain12_b1    set -0.12897822       ; EF7DA5
iir2_H_Parametric_f10079_q06_Gain12_b2    set 0.40091036       ; 335107
iir2_H_Parametric_f10079_q06_Gain12_a1    set 0.12897822       ; 10825B
iir2_H_Parametric_f10079_q06_Gain12_a2    set -0.46021353       ; C517BA

; IIR2: mode=Parametric fc=12699.2 Q=6 gainDB=12 h=< 0.55819598 0.22705348 0.40276035 -0.22705348 -0.46095633 >,< 4772F7 1D1016 338DA6 E2EFEA C4FF62 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q06_Gain12_b0    set 0.55819598       ; 4772F7
iir2_H_Parametric_f12699_q06_Gain12_b1    set 0.22705348       ; 1D1016
iir2_H_Parametric_f12699_q06_Gain12_b2    set 0.40276035       ; 338DA6
iir2_H_Parametric_f12699_q06_Gain12_a1    set -0.22705348       ; E2EFEA
iir2_H_Parametric_f12699_q06_Gain12_a2    set -0.46095633       ; C4FF62

; IIR2: mode=Parametric fc=16000 Q=6 gainDB=12 h=< 0.54585745 0.63090992 0.42337680 -0.63090992 -0.46923425 >,< 45DEA8 50C1A8 363136 AF3E58 C3F022 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q06_Gain12_b0    set 0.54585745       ; 45DEA8
iir2_H_Parametric_f16000_q06_Gain12_b1    set 0.63090992       ; 50C1A8
iir2_H_Parametric_f16000_q06_Gain12_b2    set 0.42337680       ; 363136
iir2_H_Parametric_f16000_q06_Gain12_a1    set -0.63090992       ; AF3E58
iir2_H_Parametric_f16000_q06_Gain12_a2    set -0.46923425       ; C3F022

; IIR2: mode=Parametric fc=20158.7 Q=6 gainDB=12 h=< 0.51640896 0.95330345 0.47258227 -0.95330345 -0.48899123 >,< 4219B0 7A05D9 3C7D93 85FA27 C168BD >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q06_Gain12_b0    set 0.51640896       ; 4219B0
iir2_H_Parametric_f20158_q06_Gain12_b1    set 0.95330345       ; 7A05D9
iir2_H_Parametric_f20158_q06_Gain12_b2    set 0.47258227       ; 3C7D93
iir2_H_Parametric_f20158_q06_Gain12_a1    set -0.95330345       ; 85FA27
iir2_H_Parametric_f20158_q06_Gain12_a2    set -0.48899123       ; C168BD

; IIR2: mode=Parametric fc=62.5 Q=15 gainDB=12 h=< 0.50022174 -0.99981159 0.49962949 0.99981159 -0.49985123 >,< 400744 80062D 3FF3DC 7FF9D3 C004E0 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q15_Gain12_b0    set 0.50022174       ; 400744
iir2_H_Parametric_f00062_q15_Gain12_b1    set -0.99981159       ; 80062D
iir2_H_Parametric_f00062_q15_Gain12_b2    set 0.49962949       ; 3FF3DC
iir2_H_Parametric_f00062_q15_Gain12_a1    set 0.99981159       ; 7FF9D3
iir2_H_Parametric_f00062_q15_Gain12_a2    set -0.49985123       ; C004E0

; IIR2: mode=Parametric fc=78.7451 Q=15 gainDB=12 h=< 0.50027937 -0.99974965 0.49953321 0.99974965 -0.49981257 >,< 400927 800834 3FF0B4 7FF7CC C00625 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q15_Gain12_b0    set 0.50027937       ; 400927
iir2_H_Parametric_f00078_q15_Gain12_b1    set -0.99974965       ; 800834
iir2_H_Parametric_f00078_q15_Gain12_b2    set 0.49953321       ; 3FF0B4
iir2_H_Parametric_f00078_q15_Gain12_a1    set 0.99974965       ; 7FF7CC
iir2_H_Parametric_f00078_q15_Gain12_a2    set -0.49981257       ; C00625

; IIR2: mode=Parametric fc=99.2126 Q=15 gainDB=12 h=< 0.50035196 -0.99966399 0.49941191 0.99966399 -0.49976387 >,< 400B88 800B03 3FECBA 7FF4FD C007BD >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q15_Gain12_b0    set 0.50035196       ; 400B88
iir2_H_Parametric_f00099_q15_Gain12_b1    set -0.99966399       ; 800B03
iir2_H_Parametric_f00099_q15_Gain12_b2    set 0.49941191       ; 3FECBA
iir2_H_Parametric_f00099_q15_Gain12_a1    set 0.99966399       ; 7FF4FD
iir2_H_Parametric_f00099_q15_Gain12_a2    set -0.49976387       ; C007BD

; IIR2: mode=Parametric fc=125 Q=15 gainDB=12 h=< 0.50044341 -0.99954398 0.49925911 0.99954398 -0.49970252 >,< 400E87 800EF2 3FE7B9 7FF10E C009C0 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q15_Gain12_b0    set 0.50044341       ; 400E87
iir2_H_Parametric_f00125_q15_Gain12_b1    set -0.99954398       ; 800EF2
iir2_H_Parametric_f00125_q15_Gain12_b2    set 0.49925911       ; 3FE7B9
iir2_H_Parametric_f00125_q15_Gain12_a1    set 0.99954398       ; 7FF10E
iir2_H_Parametric_f00125_q15_Gain12_a2    set -0.49970252       ; C009C0

; IIR2: mode=Parametric fc=157.49 Q=15 gainDB=12 h=< 0.50055859 -0.99937360 0.49906664 0.99937360 -0.49962524 >,< 40124E 801487 3FE16A 7FEB79 C00C48 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q15_Gain12_b0    set 0.50055859       ; 40124E
iir2_H_Parametric_f00157_q15_Gain12_b1    set -0.99937360       ; 801487
iir2_H_Parametric_f00157_q15_Gain12_b2    set 0.49906664       ; 3FE16A
iir2_H_Parametric_f00157_q15_Gain12_a1    set 0.99937360       ; 7FEB79
iir2_H_Parametric_f00157_q15_Gain12_a2    set -0.49962524       ; C00C48

; IIR2: mode=Parametric fc=198.425 Q=15 gainDB=12 h=< 0.50070368 -0.99912850 0.49882422 0.99912850 -0.49952790 >,< 40170F 801C8F 3FD978 7FE371 C00F79 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q15_Gain12_b0    set 0.50070368       ; 40170F
iir2_H_Parametric_f00198_q15_Gain12_b1    set -0.99912850       ; 801C8F
iir2_H_Parametric_f00198_q15_Gain12_b2    set 0.49882422       ; 3FD978
iir2_H_Parametric_f00198_q15_Gain12_a1    set 0.99912850       ; 7FE371
iir2_H_Parametric_f00198_q15_Gain12_a2    set -0.49952790       ; C00F79

; IIR2: mode=Parametric fc=250 Q=15 gainDB=12 h=< 0.50088641 -0.99877140 0.49851890 0.99877140 -0.49940531 >,< 401D0B 802842 3FCF77 7FD7BE C0137D >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q15_Gain12_b0    set 0.50088641       ; 401D0B
iir2_H_Parametric_f00250_q15_Gain12_b1    set -0.99877140       ; 802842
iir2_H_Parametric_f00250_q15_Gain12_b2    set 0.49851890       ; 3FCF77
iir2_H_Parametric_f00250_q15_Gain12_a1    set 0.99877140       ; 7FD7BE
iir2_H_Parametric_f00250_q15_Gain12_a2    set -0.49940531       ; C0137D

; IIR2: mode=Parametric fc=314.98 Q=15 gainDB=12 h=< 0.50111649 -0.99824489 0.49813446 0.99824489 -0.49925095 >,< 402496 803983 3FC2DE 7FC67D C0188C >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q15_Gain12_b0    set 0.50111649       ; 402496
iir2_H_Parametric_f00314_q15_Gain12_b1    set -0.99824489       ; 803983
iir2_H_Parametric_f00314_q15_Gain12_b2    set 0.49813446       ; 3FC2DE
iir2_H_Parametric_f00314_q15_Gain12_a1    set 0.99824489       ; 7FC67D
iir2_H_Parametric_f00314_q15_Gain12_a2    set -0.49925095       ; C0188C

; IIR2: mode=Parametric fc=396.85 Q=15 gainDB=12 h=< 0.50140614 -0.99746008 0.49765048 0.99746008 -0.49905662 >,< 402E13 80533B 3FB302 7FACC5 C01EEA >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q15_Gain12_b0    set 0.50140614       ; 402E13
iir2_H_Parametric_f00396_q15_Gain12_b1    set -0.99746008       ; 80533B
iir2_H_Parametric_f00396_q15_Gain12_b2    set 0.49765048       ; 3FB302
iir2_H_Parametric_f00396_q15_Gain12_a1    set 0.99746008       ; 7FACC5
iir2_H_Parametric_f00396_q15_Gain12_a2    set -0.49905662       ; C01EEA

; IIR2: mode=Parametric fc=500 Q=15 gainDB=12 h=< 0.50177064 -0.99627875 0.49704145 0.99627875 -0.49881208 >,< 403A05 8079F0 3F9F0D 7F8610 C026ED >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q15_Gain12_b0    set 0.50177064       ; 403A05
iir2_H_Parametric_f00500_q15_Gain12_b1    set -0.99627875       ; 8079F0
iir2_H_Parametric_f00500_q15_Gain12_b2    set 0.49704145       ; 3F9F0D
iir2_H_Parametric_f00500_q15_Gain12_a1    set 0.99627875       ; 7F8610
iir2_H_Parametric_f00500_q15_Gain12_a2    set -0.49881208       ; C026ED

; IIR2: mode=Parametric fc=629.961 Q=15 gainDB=12 h=< 0.50222907 -0.99448534 0.49627545 0.99448534 -0.49850452 >,< 40490B 80B4B5 3F85F4 7F4B4B C03101 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q15_Gain12_b0    set 0.50222907       ; 40490B
iir2_H_Parametric_f00629_q15_Gain12_b1    set -0.99448534       ; 80B4B5
iir2_H_Parametric_f00629_q15_Gain12_b2    set 0.49627545       ; 3F85F4
iir2_H_Parametric_f00629_q15_Gain12_a1    set 0.99448534       ; 7F4B4B
iir2_H_Parametric_f00629_q15_Gain12_a2    set -0.49850452       ; C03101

; IIR2: mode=Parametric fc=793.701 Q=15 gainDB=12 h=< 0.50280515 -0.99174296 0.49531288 0.99174296 -0.49811803 >,< 405BEB 810E91 3F6669 7EF16F C03DAB >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q15_Gain12_b0    set 0.50280515       ; 405BEB
iir2_H_Parametric_f00793_q15_Gain12_b1    set -0.99174296       ; 810E91
iir2_H_Parametric_f00793_q15_Gain12_b2    set 0.49531288       ; 3F6669
iir2_H_Parametric_f00793_q15_Gain12_a1    set 0.99174296       ; 7EF16F
iir2_H_Parametric_f00793_q15_Gain12_a2    set -0.49811803       ; C03DAB

; IIR2: mode=Parametric fc=1000 Q=15 gainDB=12 h=< 0.50352812 -0.98752444 0.49410487 0.98752444 -0.49763299 >,< 40739C 8198CD 3F3ED4 7E6733 C04D90 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q15_Gain12_b0    set 0.50352812       ; 40739C
iir2_H_Parametric_f01000_q15_Gain12_b1    set -0.98752444       ; 8198CD
iir2_H_Parametric_f01000_q15_Gain12_b2    set 0.49410487       ; 3F3ED4
iir2_H_Parametric_f01000_q15_Gain12_a1    set 0.98752444       ; 7E6733
iir2_H_Parametric_f01000_q15_Gain12_a2    set -0.49763299       ; C04D90

; IIR2: mode=Parametric fc=1259.92 Q=15 gainDB=12 h=< 0.50443361 -0.98100488 0.49259188 0.98100488 -0.49702549 >,< 409148 826E6F 3F0D40 7D9191 C06178 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q15_Gain12_b0    set 0.50443361       ; 409148
iir2_H_Parametric_f01259_q15_Gain12_b1    set -0.98100488       ; 826E6F
iir2_H_Parametric_f01259_q15_Gain12_b2    set 0.49259188       ; 3F0D40
iir2_H_Parametric_f01259_q15_Gain12_a1    set 0.98100488       ; 7D9191
iir2_H_Parametric_f01259_q15_Gain12_a2    set -0.49702549       ; C06178

; IIR2: mode=Parametric fc=1587.4 Q=15 gainDB=12 h=< 0.50556412 -0.97089533 0.49070291 0.97089533 -0.49626703 >,< 40B653 83B9B4 3ECF5A 7C464C C07A53 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q15_Gain12_b0    set 0.50556412       ; 40B653
iir2_H_Parametric_f01587_q15_Gain12_b1    set -0.97089533       ; 83B9B4
iir2_H_Parametric_f01587_q15_Gain12_b2    set 0.49070291       ; 3ECF5A
iir2_H_Parametric_f01587_q15_Gain12_a1    set 0.97089533       ; 7C464C
iir2_H_Parametric_f01587_q15_Gain12_a2    set -0.49626703       ; C07A53

; IIR2: mode=Parametric fc=2000 Q=15 gainDB=12 h=< 0.50696858 -0.95518854 0.48835620 0.95518854 -0.49532478 >,< 40E458 85BC62 3E8274 7A439E C09933 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q15_Gain12_b0    set 0.50696858       ; 40E458
iir2_H_Parametric_f02000_q15_Gain12_b1    set -0.95518854       ; 85BC62
iir2_H_Parametric_f02000_q15_Gain12_b2    set 0.48835620       ; 3E8274
iir2_H_Parametric_f02000_q15_Gain12_a1    set 0.95518854       ; 7A439E
iir2_H_Parametric_f02000_q15_Gain12_a2    set -0.49532478       ; C09933

; IIR2: mode=Parametric fc=2519.84 Q=15 gainDB=12 h=< 0.50869969 -0.93077828 0.48546368 0.93077828 -0.49416338 >,< 411D12 88DC42 3E23AC 7723BE C0BF42 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q15_Gain12_b0    set 0.50869969       ; 411D12
iir2_H_Parametric_f02519_q15_Gain12_b1    set -0.93077828       ; 88DC42
iir2_H_Parametric_f02519_q15_Gain12_b2    set 0.48546368       ; 3E23AC
iir2_H_Parametric_f02519_q15_Gain12_a1    set 0.93077828       ; 7723BE
iir2_H_Parametric_f02519_q15_Gain12_a2    set -0.49416338       ; C0BF42

; IIR2: mode=Parametric fc=3174.8 Q=15 gainDB=12 h=< 0.51080655 -0.89290906 0.48194333 0.89290906 -0.49274989 >,< 41621C 8DB528 3DB051 724AD8 C0ED93 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q15_Gain12_b0    set 0.51080655       ; 41621C
iir2_H_Parametric_f03174_q15_Gain12_b1    set -0.89290906       ; 8DB528
iir2_H_Parametric_f03174_q15_Gain12_b2    set 0.48194333       ; 3DB051
iir2_H_Parametric_f03174_q15_Gain12_a1    set 0.89290906       ; 724AD8
iir2_H_Parametric_f03174_q15_Gain12_a2    set -0.49274989       ; C0ED93

; IIR2: mode=Parametric fc=4000 Q=15 gainDB=12 h=< 0.51331791 -0.83443025 0.47774711 0.83443025 -0.49106502 >,< 41B466 953164 3D26D1 6ACE9C C124C8 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q15_Gain12_b0    set 0.51331791       ; 41B466
iir2_H_Parametric_f04000_q15_Gain12_b1    set -0.83443025       ; 953164
iir2_H_Parametric_f04000_q15_Gain12_b2    set 0.47774711       ; 3D26D1
iir2_H_Parametric_f04000_q15_Gain12_a1    set 0.83443025       ; 6ACE9C
iir2_H_Parametric_f04000_q15_Gain12_a2    set -0.49106502       ; C124C8

; IIR2: mode=Parametric fc=5039.68 Q=15 gainDB=12 h=< 0.51620752 -0.74491214 0.47291887 0.74491214 -0.48912638 >,< 421316 A0A6B8 3C889B 5F5948 C1644F >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q15_Gain12_b0    set 0.51620752       ; 421316
iir2_H_Parametric_f05039_q15_Gain12_b1    set -0.74491214       ; A0A6B8
iir2_H_Parametric_f05039_q15_Gain12_b2    set 0.47291887       ; 3C889B
iir2_H_Parametric_f05039_q15_Gain12_a1    set 0.74491214       ; 5F5948
iir2_H_Parametric_f05039_q15_Gain12_a2    set -0.48912638       ; C1644F

; IIR2: mode=Parametric fc=6349.6 Q=15 gainDB=12 h=< 0.51932754 -0.60993592 0.46770562 0.60993592 -0.48703316 >,< 427953 B1ED9F 3BDDC7 4E1261 C1A8E6 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q15_Gain12_b0    set 0.51932754       ; 427953
iir2_H_Parametric_f06349_q15_Gain12_b1    set -0.60993592       ; B1ED9F
iir2_H_Parametric_f06349_q15_Gain12_b2    set 0.46770562       ; 3BDDC7
iir2_H_Parametric_f06349_q15_Gain12_a1    set 0.60993592       ; 4E1261
iir2_H_Parametric_f06349_q15_Gain12_a2    set -0.48703316       ; C1A8E6

; IIR2: mode=Parametric fc=8000 Q=15 gainDB=12 h=< 0.52228990 -0.41152254 0.46275581 0.41152254 -0.48504571 >,< 42DA65 CB533B 3B3B95 34ACC5 C1EA06 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q15_Gain12_b0    set 0.52228990       ; 42DA65
iir2_H_Parametric_f08000_q15_Gain12_b1    set -0.41152254       ; CB533B
iir2_H_Parametric_f08000_q15_Gain12_b2    set 0.46275581       ; 3B3B95
iir2_H_Parametric_f08000_q15_Gain12_a1    set 0.41152254       ; 34ACC5
iir2_H_Parametric_f08000_q15_Gain12_a2    set -0.48504571       ; C1EA06

; IIR2: mode=Parametric fc=10079.4 Q=15 gainDB=12 h=< 0.52427816 -0.13213457 0.45943363 0.13213457 -0.48371179 >,< 431B8C EF1637 3ACEB8 10E9C9 C215BC >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q15_Gain12_b0    set 0.52427816       ; 431B8C
iir2_H_Parametric_f10079_q15_Gain12_b1    set -0.13213457       ; EF1637
iir2_H_Parametric_f10079_q15_Gain12_b2    set 0.45943363       ; 3ACEB8
iir2_H_Parametric_f10079_q15_Gain12_a1    set 0.13213457       ; 10E9C9
iir2_H_Parametric_f10079_q15_Gain12_a2    set -0.48371179       ; C215BC

; IIR2: mode=Parametric fc=12699.2 Q=15 gainDB=12 h=< 0.52381401 0.23250368 0.46020917 -0.23250368 -0.48402319 >,< 430C56 1DC2AE 3AE822 E23D52 C20B88 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q15_Gain12_b0    set 0.52381401       ; 430C56
iir2_H_Parametric_f12699_q15_Gain12_b1    set 0.23250368       ; 1DC2AE
iir2_H_Parametric_f12699_q15_Gain12_b2    set 0.46020917       ; 3AE822
iir2_H_Parametric_f12699_q15_Gain12_a1    set -0.23250368       ; E23D52
iir2_H_Parametric_f12699_q15_Gain12_a2    set -0.48402319       ; C20B88

; IIR2: mode=Parametric fc=16000 Q=15 gainDB=12 h=< 0.51867002 0.64278303 0.46880427 -0.64278303 -0.48747429 >,< 4263C7 5246B7 3C01C7 ADB949 C19A72 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q15_Gain12_b0    set 0.51867002       ; 4263C7
iir2_H_Parametric_f16000_q15_Gain12_b1    set 0.64278303       ; 5246B7
iir2_H_Parametric_f16000_q15_Gain12_b2    set 0.46880427       ; 3C01C7
iir2_H_Parametric_f16000_q15_Gain12_a1    set -0.64278303       ; ADB949
iir2_H_Parametric_f16000_q15_Gain12_a2    set -0.48747429       ; C19A72

; IIR2: mode=Parametric fc=20158.7 Q=15 gainDB=12 h=< 0.50660084 0.95964627 0.48897067 -0.95964627 -0.49557150 >,< 40D84C 7AD5B0 3E9697 852A50 C0911D >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q15_Gain12_b0    set 0.50660084       ; 40D84C
iir2_H_Parametric_f20158_q15_Gain12_b1    set 0.95964627       ; 7AD5B0
iir2_H_Parametric_f20158_q15_Gain12_b2    set 0.48897067       ; 3E9697
iir2_H_Parametric_f20158_q15_Gain12_a1    set -0.95964627       ; 852A50
iir2_H_Parametric_f20158_q15_Gain12_a2    set -0.49557150       ; C0911D

; IIR2: mode=Parametric fc=62.5 Q=1 gainDB=18 h=< 0.50570628 -0.99831673 0.49265004 0.99831673 -0.49835632 >,< 40BAFC 803729 3F0F28 7FC8D7 C035DD >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q01_Gain18_b0    set 0.50570628       ; 40BAFC
iir2_H_Parametric_f00062_q01_Gain18_b1    set -0.99831673       ; 803729
iir2_H_Parametric_f00062_q01_Gain18_b2    set 0.49265004       ; 3F0F28
iir2_H_Parametric_f00062_q01_Gain18_a1    set 0.99831673       ; 7FC8D7
iir2_H_Parametric_f00062_q01_Gain18_a2    set -0.49835632       ; C035DD

; IIR2: mode=Parametric fc=78.7451 Q=1 gainDB=18 h=< 0.50718634 -0.99786718 0.49074365 0.99786718 -0.49792999 >,< 40EB7B 8045E4 3ED0B0 7FBA1C C043D5 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q01_Gain18_b0    set 0.50718634       ; 40EB7B
iir2_H_Parametric_f00078_q01_Gain18_b1    set -0.99786718       ; 8045E4
iir2_H_Parametric_f00078_q01_Gain18_b2    set 0.49074365       ; 3ED0B0
iir2_H_Parametric_f00078_q01_Gain18_a1    set 0.99786718       ; 7FBA1C
iir2_H_Parametric_f00078_q01_Gain18_a2    set -0.49792999       ; C043D5

; IIR2: mode=Parametric fc=99.2126 Q=1 gainDB=18 h=< 0.50904924 -0.99729374 0.48834415 0.99729374 -0.49739338 >,< 412886 8058AE 3E820F 7FA752 C0556A >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q01_Gain18_b0    set 0.50904924       ; 412886
iir2_H_Parametric_f00099_q01_Gain18_b1    set -0.99729374       ; 8058AE
iir2_H_Parametric_f00099_q01_Gain18_b2    set 0.48834415       ; 3E820F
iir2_H_Parametric_f00099_q01_Gain18_a1    set 0.99729374       ; 7FA752
iir2_H_Parametric_f00099_q01_Gain18_a2    set -0.49739338       ; C0556A

; IIR2: mode=Parametric fc=125 Q=1 gainDB=18 h=< 0.51139338 -0.99656009 0.48532477 0.99656009 -0.49671816 >,< 417556 8070B8 3E1F1F 7F8F48 C06B8A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q01_Gain18_b0    set 0.51139338       ; 417556
iir2_H_Parametric_f00125_q01_Gain18_b1    set -0.99656009       ; 8070B8
iir2_H_Parametric_f00125_q01_Gain18_b2    set 0.48532477       ; 3E1F1F
iir2_H_Parametric_f00125_q01_Gain18_a1    set 0.99656009       ; 7F8F48
iir2_H_Parametric_f00125_q01_Gain18_a2    set -0.49671816       ; C06B8A

; IIR2: mode=Parametric fc=157.49 Q=1 gainDB=18 h=< 0.51434208 -0.99561809 0.48152670 0.99561809 -0.49586879 >,< 41D5F6 808F96 3DA2AA 7F706A C0875F >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q01_Gain18_b0    set 0.51434208       ; 41D5F6
iir2_H_Parametric_f00157_q01_Gain18_b1    set -0.99561809       ; 808F96
iir2_H_Parametric_f00157_q01_Gain18_b2    set 0.48152670       ; 3DA2AA
iir2_H_Parametric_f00157_q01_Gain18_a1    set 0.99561809       ; 7F706A
iir2_H_Parametric_f00157_q01_Gain18_a2    set -0.49586879       ; C0875F

; IIR2: mode=Parametric fc=198.425 Q=1 gainDB=18 h=< 0.51804963 -0.99440332 0.47675121 0.99440332 -0.49480084 >,< 424F73 80B765 3D062F 7F489B C0AA5E >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q01_Gain18_b0    set 0.51804963       ; 424F73
iir2_H_Parametric_f00198_q01_Gain18_b1    set -0.99440332       ; 80B765
iir2_H_Parametric_f00198_q01_Gain18_b2    set 0.47675121       ; 3D062F
iir2_H_Parametric_f00198_q01_Gain18_a1    set 0.99440332       ; 7F489B
iir2_H_Parametric_f00198_q01_Gain18_a2    set -0.49480084       ; C0AA5E

; IIR2: mode=Parametric fc=250 Q=1 gainDB=18 h=< 0.52270865 -0.99282868 0.47075016 0.99282868 -0.49345881 >,< 42E81E 80EAFE 3C418A 7F1502 C0D658 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q01_Gain18_b0    set 0.52270865       ; 42E81E
iir2_H_Parametric_f00250_q01_Gain18_b1    set -0.99282868       ; 80EAFE
iir2_H_Parametric_f00250_q01_Gain18_b2    set 0.47075016       ; 3C418A
iir2_H_Parametric_f00250_q01_Gain18_a1    set 0.99282868       ; 7F1502
iir2_H_Parametric_f00250_q01_Gain18_a2    set -0.49345881       ; C0D658

; IIR2: mode=Parametric fc=314.98 Q=1 gainDB=18 h=< 0.52855903 -0.99077510 0.46321460 0.99077510 -0.49177362 >,< 43A7D2 812E48 3B4A9D 7ED1B8 C10D90 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q01_Gain18_b0    set 0.52855903       ; 43A7D2
iir2_H_Parametric_f00314_q01_Gain18_b1    set -0.99077510       ; 812E48
iir2_H_Parametric_f00314_q01_Gain18_b2    set 0.46321460       ; 3B4A9D
iir2_H_Parametric_f00314_q01_Gain18_a1    set 0.99077510       ; 7ED1B8
iir2_H_Parametric_f00314_q01_Gain18_a2    set -0.49177362       ; C10D90

; IIR2: mode=Parametric fc=396.85 Q=1 gainDB=18 h=< 0.53589834 -0.98807802 0.45376121 0.98807802 -0.48965955 >,< 449851 8186A9 3A14D9 7E7957 C152D6 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q01_Gain18_b0    set 0.53589834       ; 449851
iir2_H_Parametric_f00396_q01_Gain18_b1    set -0.98807802       ; 8186A9
iir2_H_Parametric_f00396_q01_Gain18_b2    set 0.45376121       ; 3A14D9
iir2_H_Parametric_f00396_q01_Gain18_a1    set 0.98807802       ; 7E7957
iir2_H_Parametric_f00396_q01_Gain18_a2    set -0.48965955       ; C152D6

; IIR2: mode=Parametric fc=500 Q=1 gainDB=18 h=< 0.54509390 -0.98450738 0.44191689 0.98450738 -0.48701078 >,< 45C5A3 81FBAA 3890BB 7E0456 C1A9A2 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q01_Gain18_b0    set 0.54509390       ; 45C5A3
iir2_H_Parametric_f00500_q01_Gain18_b1    set -0.98450738       ; 81FBAA
iir2_H_Parametric_f00500_q01_Gain18_b2    set 0.44191689       ; 3890BB
iir2_H_Parametric_f00500_q01_Gain18_a1    set 0.98450738       ; 7E0456
iir2_H_Parametric_f00500_q01_Gain18_a2    set -0.48701078       ; C1A9A2

; IIR2: mode=Parametric fc=629.961 Q=1 gainDB=18 h=< 0.55659590 -0.97973807 0.42710175 0.97973807 -0.48369765 >,< 473E89 8297F2 36AB45 7D680E C21632 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q01_Gain18_b0    set 0.55659590       ; 473E89
iir2_H_Parametric_f00629_q01_Gain18_b1    set -0.97973807       ; 8297F2
iir2_H_Parametric_f00629_q01_Gain18_b2    set 0.42710175       ; 36AB45
iir2_H_Parametric_f00629_q01_Gain18_a1    set 0.97973807       ; 7D680E
iir2_H_Parametric_f00629_q01_Gain18_a2    set -0.48369765       ; C21632

; IIR2: mode=Parametric fc=793.701 Q=1 gainDB=18 h=< 0.57095062 -0.97330624 0.40861218 0.97330624 -0.47956280 >,< 4914E9 836AB4 344D67 7C954C C29DB0 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q01_Gain18_b0    set 0.57095062       ; 4914E9
iir2_H_Parametric_f00793_q01_Gain18_b1    set -0.97330624       ; 836AB4
iir2_H_Parametric_f00793_q01_Gain18_b2    set 0.40861218       ; 344D67
iir2_H_Parametric_f00793_q01_Gain18_a1    set 0.97330624       ; 7C954C
iir2_H_Parametric_f00793_q01_Gain18_a2    set -0.47956280       ; C29DB0

; IIR2: mode=Parametric fc=1000 Q=1 gainDB=18 h=< 0.58881131 -0.96454474 0.38560675 0.96454474 -0.47441806 >,< 4B5E2B 8489CC 315B8F 7B7634 C34645 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q01_Gain18_b0    set 0.58881131       ; 4B5E2B
iir2_H_Parametric_f01000_q01_Gain18_b1    set -0.96454474       ; 8489CC
iir2_H_Parametric_f01000_q01_Gain18_b2    set 0.38560675       ; 315B8F
iir2_H_Parametric_f01000_q01_Gain18_a1    set 0.96454474       ; 7B7634
iir2_H_Parametric_f01000_q01_Gain18_a2    set -0.47441806       ; C34645

; IIR2: mode=Parametric fc=1259.92 Q=1 gainDB=18 h=< 0.61094213 -0.95248841 0.35710119 0.95248841 -0.46804332 >,< 4E335A 8614DC 2DB57E 79EB24 C41728 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q01_Gain18_b0    set 0.61094213       ; 4E335A
iir2_H_Parametric_f01259_q01_Gain18_b1    set -0.95248841       ; 8614DC
iir2_H_Parametric_f01259_q01_Gain18_b2    set 0.35710119       ; 2DB57E
iir2_H_Parametric_f01259_q01_Gain18_a1    set 0.95248841       ; 79EB24
iir2_H_Parametric_f01259_q01_Gain18_a2    set -0.46804332       ; C41728

; IIR2: mode=Parametric fc=1587.4 Q=1 gainDB=18 h=< 0.63820644 -0.93573695 0.32198344 0.93573695 -0.46018988 >,< 51B0BF 8839C6 2936C1 77C63A C51880 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q01_Gain18_b0    set 0.63820644       ; 51B0BF
iir2_H_Parametric_f01587_q01_Gain18_b1    set -0.93573695       ; 8839C6
iir2_H_Parametric_f01587_q01_Gain18_b2    set 0.32198344       ; 2936C1
iir2_H_Parametric_f01587_q01_Gain18_a1    set 0.93573695       ; 77C63A
iir2_H_Parametric_f01587_q01_Gain18_a2    set -0.46018988       ; C51880

; IIR2: mode=Parametric fc=2000 Q=1 gainDB=18 h=< 0.67152386 -0.91226042 0.27906899 0.91226042 -0.45059286 >,< 55F47E 8B3B0D 23B888 74C4F3 C652FA >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q01_Gain18_b0    set 0.67152386       ; 55F47E
iir2_H_Parametric_f02000_q01_Gain18_b1    set -0.91226042       ; 8B3B0D
iir2_H_Parametric_f02000_q01_Gain18_b2    set 0.27906899       ; 23B888
iir2_H_Parametric_f02000_q01_Gain18_a1    set 0.91226042       ; 74C4F3
iir2_H_Parametric_f02000_q01_Gain18_a2    set -0.45059286       ; C652FA

; IIR2: mode=Parametric fc=2519.84 Q=1 gainDB=18 h=< 0.71176898 -0.87913227 0.22723135 0.87913227 -0.43900033 >,< 5B1B3F 8F7898 1D15EA 708768 C7CED7 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q01_Gain18_b0    set 0.71176898       ; 5B1B3F
iir2_H_Parametric_f02519_q01_Gain18_b1    set -0.87913227       ; 8F7898
iir2_H_Parametric_f02519_q01_Gain18_b2    set 0.22723135       ; 1D15EA
iir2_H_Parametric_f02519_q01_Gain18_a1    set 0.87913227       ; 708768
iir2_H_Parametric_f02519_q01_Gain18_a2    set -0.43900033       ; C7CED7

; IIR2: mode=Parametric fc=3174.8 Q=1 gainDB=18 h=< 0.75956648 -0.83218175 0.16566586 0.83218175 -0.42523234 >,< 613979 957B12 15348A 6A84EE C991FD >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q01_Gain18_b0    set 0.75956648       ; 613979
iir2_H_Parametric_f03174_q01_Gain18_b1    set -0.83218175       ; 957B12
iir2_H_Parametric_f03174_q01_Gain18_b2    set 0.16566586       ; 15348A
iir2_H_Parametric_f03174_q01_Gain18_a1    set 0.83218175       ; 6A84EE
iir2_H_Parametric_f03174_q01_Gain18_a2    set -0.42523234       ; C991FD

; IIR2: mode=Parametric fc=4000 Q=1 gainDB=18 h=< 0.81491040 -0.76558005 0.09438023 0.76558005 -0.40929063 >,< 684EFC 9E0179 0C14A6 61FE87 CB9C5E >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q01_Gain18_b0    set 0.81491040       ; 684EFC
iir2_H_Parametric_f04000_q01_Gain18_b1    set -0.76558005       ; 9E0179
iir2_H_Parametric_f04000_q01_Gain18_b2    set 0.09438023       ; 0C14A6
iir2_H_Parametric_f04000_q01_Gain18_a1    set 0.76558005       ; 61FE87
iir2_H_Parametric_f04000_q01_Gain18_a2    set -0.40929063       ; CB9C5E

; IIR2: mode=Parametric fc=5039.68 Q=1 gainDB=18 h=< 0.87649670 -0.67142786 0.01505411 0.67142786 -0.39155080 >,< 70310B AA0EA7 01ED4B 55F159 CDE1AA >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q01_Gain18_b0    set 0.87649670       ; 70310B
iir2_H_Parametric_f05039_q01_Gain18_b1    set -0.67142786       ; AA0EA7
iir2_H_Parametric_f05039_q01_Gain18_b2    set 0.01505411       ; 01ED4B
iir2_H_Parametric_f05039_q01_Gain18_a1    set 0.67142786       ; 55F159
iir2_H_Parametric_f05039_q01_Gain18_a2    set -0.39155080       ; CDE1AA

; IIR2: mode=Parametric fc=6349.6 Q=1 gainDB=18 h=< 0.94060681 -0.53952117 -0.06752281 0.53952117 -0.37308400 >,< 7865CE BAF0F9 F75B6A 450F07 D03EC9 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q01_Gain18_b0    set 0.94060681       ; 7865CE
iir2_H_Parametric_f06349_q01_Gain18_b1    set -0.53952117       ; BAF0F9
iir2_H_Parametric_f06349_q01_Gain18_b2    set -0.06752281       ; F75B6A
iir2_H_Parametric_f06349_q01_Gain18_a1    set 0.53952117       ; 450F07
iir2_H_Parametric_f06349_q01_Gain18_a2    set -0.37308400       ; D03EC9

; IIR2: mode=Parametric fc=8000 Q=1 gainDB=18 h=< 0.99930437 -0.35768475 -0.14312809 0.35768475 -0.35617628 >,< 7FE934 D23763 EDADFB 2DC89D D268D1 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q01_Gain18_b0    set 0.99930437       ; 7FE934
iir2_H_Parametric_f08000_q01_Gain18_b1    set -0.35768475       ; D23763
iir2_H_Parametric_f08000_q01_Gain18_b2    set -0.14312809       ; EDADFB
iir2_H_Parametric_f08000_q01_Gain18_a1    set 0.35768475       ; 2DC89D
iir2_H_Parametric_f08000_q01_Gain18_a2    set -0.35617628       ; D268D1

; IIR2: mode=Parametric fc=10079.4 Q=1 gainDB=18 h=< 1.03756908 -0.11352317 -0.19241489 0.11352317 -0.34515419 >,< 800000 F17813 E75EF3 0E87ED D3D1FD >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q01_Gain18_b0    set 1.03756908       ; 800000
iir2_H_Parametric_f10079_q01_Gain18_b1    set -0.11352317       ; F17813
iir2_H_Parametric_f10079_q01_Gain18_b2    set -0.19241489       ; E75EF3
iir2_H_Parametric_f10079_q01_Gain18_a1    set 0.11352317       ; 0E87ED
iir2_H_Parametric_f10079_q01_Gain18_a2    set -0.34515419       ; D3D1FD

; IIR2: mode=Parametric fc=12699.2 Q=1 gainDB=18 h=< 1.02871556 0.20029447 -0.18101113 -0.20029447 -0.34770443 >,< 800000 19A33F E8D4A1 E65CC1 D37E6C >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q01_Gain18_b0    set 1.02871556       ; 800000
iir2_H_Parametric_f12699_q01_Gain18_b1    set 0.20029447       ; 19A33F
iir2_H_Parametric_f12699_q01_Gain18_b2    set -0.18101113       ; E8D4A1
iir2_H_Parametric_f12699_q01_Gain18_a1    set -0.20029447       ; E65CC1
iir2_H_Parametric_f12699_q01_Gain18_a2    set -0.34770443       ; D37E6C

; IIR2: mode=Parametric fc=16000 Q=1 gainDB=18 h=< 0.92729569 0.57081807 -0.05037745 -0.57081807 -0.37691824 >,< 76B1A0 491091 F98D3C B6EF6F CFC125 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q01_Gain18_b0    set 0.92729569       ; 76B1A0
iir2_H_Parametric_f16000_q01_Gain18_b1    set 0.57081807       ; 491091
iir2_H_Parametric_f16000_q01_Gain18_b2    set -0.05037745       ; F98D3C
iir2_H_Parametric_f16000_q01_Gain18_a1    set -0.57081807       ; B6EF6F
iir2_H_Parametric_f16000_q01_Gain18_a2    set -0.37691824       ; CFC125

; IIR2: mode=Parametric fc=20158.7 Q=1 gainDB=18 h=< 0.66285846 0.91869667 0.29023046 -0.91869667 -0.45308891 >,< 54D88C 7597DA 252645 8A6826 C6012F >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q01_Gain18_b0    set 0.66285846       ; 54D88C
iir2_H_Parametric_f20158_q01_Gain18_b1    set 0.91869667       ; 7597DA
iir2_H_Parametric_f20158_q01_Gain18_b2    set 0.29023046       ; 252645
iir2_H_Parametric_f20158_q01_Gain18_a1    set -0.91869667       ; 8A6826
iir2_H_Parametric_f20158_q01_Gain18_a2    set -0.45308891       ; C6012F

; IIR2: mode=Parametric fc=62.5 Q=6 gainDB=18 h=< 0.50091487 -0.99969684 0.49882161 0.99969684 -0.49973647 >,< 401DFA 8009EF 3FD963 7FF611 C008A3 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q06_Gain18_b0    set 0.50091487       ; 401DFA
iir2_H_Parametric_f00062_q06_Gain18_b1    set -0.99969684       ; 8009EF
iir2_H_Parametric_f00062_q06_Gain18_b2    set 0.49882161       ; 3FD963
iir2_H_Parametric_f00062_q06_Gain18_a1    set 0.99969684       ; 7FF611
iir2_H_Parametric_f00062_q06_Gain18_a2    set -0.49973647       ; C008A3

; IIR2: mode=Parametric fc=78.7451 Q=6 gainDB=18 h=< 0.50115257 -0.99960509 0.49851543 0.99960509 -0.49966800 >,< 4025C4 800CF1 3FCF5A 7FF30F C00AE1 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q06_Gain18_b0    set 0.50115257       ; 4025C4
iir2_H_Parametric_f00078_q06_Gain18_b1    set -0.99960509       ; 800CF1
iir2_H_Parametric_f00078_q06_Gain18_b2    set 0.49851543       ; 3FCF5A
iir2_H_Parametric_f00078_q06_Gain18_a1    set 0.99960509       ; 7FF30F
iir2_H_Parametric_f00078_q06_Gain18_a2    set -0.49966800       ; C00AE1

; IIR2: mode=Parametric fc=99.2126 Q=6 gainDB=18 h=< 0.50145200 -0.99948189 0.49812975 0.99948189 -0.49958175 >,< 402F94 8010FA 3FC2B7 7FEF06 C00DB5 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q06_Gain18_b0    set 0.50145200       ; 402F94
iir2_H_Parametric_f00099_q06_Gain18_b1    set -0.99948189       ; 8010FA
iir2_H_Parametric_f00099_q06_Gain18_b2    set 0.49812975       ; 3FC2B7
iir2_H_Parametric_f00099_q06_Gain18_a1    set 0.99948189       ; 7FEF06
iir2_H_Parametric_f00099_q06_Gain18_a2    set -0.49958175       ; C00DB5

; IIR2: mode=Parametric fc=125 Q=6 gainDB=18 h=< 0.50182918 -0.99931461 0.49764393 0.99931461 -0.49947311 >,< 403BF0 801676 3FB2CC 7FE98A C01144 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q06_Gain18_b0    set 0.50182918       ; 403BF0
iir2_H_Parametric_f00125_q06_Gain18_b1    set -0.99931461       ; 801676
iir2_H_Parametric_f00125_q06_Gain18_b2    set 0.49764393       ; 3FB2CC
iir2_H_Parametric_f00125_q06_Gain18_a1    set 0.99931461       ; 7FE98A
iir2_H_Parametric_f00125_q06_Gain18_a2    set -0.49947311       ; C01144

; IIR2: mode=Parametric fc=157.49 Q=6 gainDB=18 h=< 0.50230423 -0.99908470 0.49703204 0.99908470 -0.49933627 >,< 404B81 801DFE 3F9EBF 7FE202 C015C0 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q06_Gain18_b0    set 0.50230423       ; 404B81
iir2_H_Parametric_f00157_q06_Gain18_b1    set -0.99908470       ; 801DFE
iir2_H_Parametric_f00157_q06_Gain18_b2    set 0.49703204       ; 3F9EBF
iir2_H_Parametric_f00157_q06_Gain18_a1    set 0.99908470       ; 7FE202
iir2_H_Parametric_f00157_q06_Gain18_a2    set -0.49933627       ; C015C0

; IIR2: mode=Parametric fc=198.425 Q=6 gainDB=18 h=< 0.50290251 -0.99876468 0.49626143 0.99876468 -0.49916394 >,< 405F1C 80287B 3F857E 7FD785 C01B66 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q06_Gain18_b0    set 0.50290251       ; 405F1C
iir2_H_Parametric_f00198_q06_Gain18_b1    set -0.99876468       ; 80287B
iir2_H_Parametric_f00198_q06_Gain18_b2    set 0.49626143       ; 3F857E
iir2_H_Parametric_f00198_q06_Gain18_a1    set 0.99876468       ; 7FD785
iir2_H_Parametric_f00198_q06_Gain18_a2    set -0.49916394       ; C01B66

; IIR2: mode=Parametric fc=250 Q=6 gainDB=18 h=< 0.50365585 -0.99831332 0.49529109 0.99831332 -0.49894694 >,< 4077CB 803745 3F65B2 7FC8BB C02282 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q06_Gain18_b0    set 0.50365585       ; 4077CB
iir2_H_Parametric_f00250_q06_Gain18_b1    set -0.99831332       ; 803745
iir2_H_Parametric_f00250_q06_Gain18_b2    set 0.49529109       ; 3F65B2
iir2_H_Parametric_f00250_q06_Gain18_a1    set 0.99831332       ; 7FC8BB
iir2_H_Parametric_f00250_q06_Gain18_a2    set -0.49894694       ; C02282

; IIR2: mode=Parametric fc=314.98 Q=6 gainDB=18 h=< 0.50460425 -0.99766828 0.49406951 0.99766828 -0.49867375 >,< 4096DF 804C68 3F3DAB 7FB398 C02B76 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q06_Gain18_b0    set 0.50460425       ; 4096DF
iir2_H_Parametric_f00314_q06_Gain18_b1    set -0.99766828       ; 804C68
iir2_H_Parametric_f00314_q06_Gain18_b2    set 0.49406951       ; 3F3DAB
iir2_H_Parametric_f00314_q06_Gain18_a1    set 0.99766828       ; 7FB398
iir2_H_Parametric_f00314_q06_Gain18_a2    set -0.49867375       ; C02B76

; IIR2: mode=Parametric fc=396.85 Q=6 gainDB=18 h=< 0.50579785 -0.99673456 0.49253209 0.99673456 -0.49832994 >,< 40BDFC 806B01 3F0B4A 7F94FF C036BA >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q06_Gain18_b0    set 0.50579785       ; 40BDFC
iir2_H_Parametric_f00396_q06_Gain18_b1    set -0.99673456       ; 806B01
iir2_H_Parametric_f00396_q06_Gain18_b2    set 0.49253209       ; 3F0B4A
iir2_H_Parametric_f00396_q06_Gain18_a1    set 0.99673456       ; 7F94FF
iir2_H_Parametric_f00396_q06_Gain18_a2    set -0.49832994       ; C036BA

; IIR2: mode=Parametric fc=500 Q=6 gainDB=18 h=< 0.50729938 -0.99536641 0.49059805 0.99536641 -0.49789743 >,< 40EF2F 8097D6 3ECBEA 7F682A C044E6 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q06_Gain18_b0    set 0.50729938       ; 40EF2F
iir2_H_Parametric_f00500_q06_Gain18_b1    set -0.99536641       ; 8097D6
iir2_H_Parametric_f00500_q06_Gain18_b2    set 0.49059805       ; 3ECBEA
iir2_H_Parametric_f00500_q06_Gain18_a1    set 0.99536641       ; 7F682A
iir2_H_Parametric_f00500_q06_Gain18_a2    set -0.49789743       ; C044E6

; IIR2: mode=Parametric fc=629.961 Q=6 gainDB=18 h=< 0.50918706 -0.99333913 0.48816662 0.99333913 -0.49735368 >,< 412D0A 80DA44 3E7C3E 7F25BC C056B7 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q06_Gain18_b0    set 0.50918706       ; 412D0A
iir2_H_Parametric_f00629_q06_Gain18_b1    set -0.99333913       ; 80DA44
iir2_H_Parametric_f00629_q06_Gain18_b2    set 0.48816662       ; 3E7C3E
iir2_H_Parametric_f00629_q06_Gain18_a1    set 0.99333913       ; 7F25BC
iir2_H_Parametric_f00629_q06_Gain18_a2    set -0.49735368       ; C056B7

; IIR2: mode=Parametric fc=793.701 Q=6 gainDB=18 h=< 0.51155792 -0.99030494 0.48511284 0.99030494 -0.49667076 >,< 417ABB 813DB0 3E182D 7EC250 C06D18 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q06_Gain18_b0    set 0.51155792       ; 417ABB
iir2_H_Parametric_f00793_q06_Gain18_b1    set -0.99030494       ; 813DB0
iir2_H_Parametric_f00793_q06_Gain18_b2    set 0.48511284       ; 3E182D
iir2_H_Parametric_f00793_q06_Gain18_a1    set 0.99030494       ; 7EC250
iir2_H_Parametric_f00793_q06_Gain18_a2    set -0.49667076       ; C06D18

; IIR2: mode=Parametric fc=1000 Q=6 gainDB=18 h=< 0.51453133 -0.98572416 0.48128294 0.98572416 -0.49581428 >,< 41DC29 81D3CB 3D9AAE 7E2C35 C08929 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q06_Gain18_b0    set 0.51453133       ; 41DC29
iir2_H_Parametric_f01000_q06_Gain18_b1    set -0.98572416       ; 81D3CB
iir2_H_Parametric_f01000_q06_Gain18_b2    set 0.48128294       ; 3D9AAE
iir2_H_Parametric_f01000_q06_Gain18_a1    set 0.98572416       ; 7E2C35
iir2_H_Parametric_f01000_q06_Gain18_a2    set -0.49581428       ; C08929

; IIR2: mode=Parametric fc=1259.92 Q=6 gainDB=18 h=< 0.51825225 -0.97875855 0.47649022 0.97875855 -0.49474247 >,< 425617 82B80A 3CFDA1 7D47F6 C0AC48 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q06_Gain18_b0    set 0.51825225       ; 425617
iir2_H_Parametric_f01259_q06_Gain18_b1    set -0.97875855       ; 82B80A
iir2_H_Parametric_f01259_q06_Gain18_b2    set 0.47649022       ; 3CFDA1
iir2_H_Parametric_f01259_q06_Gain18_a1    set 0.97875855       ; 7D47F6
iir2_H_Parametric_f01259_q06_Gain18_a2    set -0.49474247       ; C0AC48

; IIR2: mode=Parametric fc=1587.4 Q=6 gainDB=18 h=< 0.52289296 -0.96810689 0.47051276 0.96810689 -0.49340572 >,< 42EE28 841513 3C39C3 7BEAED C0D815 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q06_Gain18_b0    set 0.52289296       ; 42EE28
iir2_H_Parametric_f01587_q06_Gain18_b1    set -0.96810689       ; 841513
iir2_H_Parametric_f01587_q06_Gain18_b2    set 0.47051276       ; 3C39C3
iir2_H_Parametric_f01587_q06_Gain18_a1    set 0.96810689       ; 7BEAED
iir2_H_Parametric_f01587_q06_Gain18_a2    set -0.49340572       ; C0D815

; IIR2: mode=Parametric fc=2000 Q=6 gainDB=18 h=< 0.52865069 -0.95175524 0.46309653 0.95175524 -0.49174722 >,< 43AAD3 862CE3 3B46BF 79D31D C10E6E >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q06_Gain18_b0    set 0.52865069       ; 43AAD3
iir2_H_Parametric_f02000_q06_Gain18_b1    set -0.95175524       ; 862CE3
iir2_H_Parametric_f02000_q06_Gain18_b2    set 0.46309653       ; 3B46BF
iir2_H_Parametric_f02000_q06_Gain18_a1    set 0.95175524       ; 79D31D
iir2_H_Parametric_f02000_q06_Gain18_a2    set -0.49174722       ; C10E6E

; IIR2: mode=Parametric fc=2519.84 Q=6 gainDB=18 h=< 0.53573609 -0.92660536 0.45397019 0.92660536 -0.48970628 >,< 449300 8964FF 3A1BB2 769B01 C1514E >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q06_Gain18_b0    set 0.53573609       ; 449300
iir2_H_Parametric_f02519_q06_Gain18_b1    set -0.92660536       ; 8964FF
iir2_H_Parametric_f02519_q06_Gain18_b2    set 0.45397019       ; 3A1BB2
iir2_H_Parametric_f02519_q06_Gain18_a1    set 0.92660536       ; 769B01
iir2_H_Parametric_f02519_q06_Gain18_a2    set -0.48970628       ; C1514E

; IIR2: mode=Parametric fc=3174.8 Q=6 gainDB=18 h=< 0.54434239 -0.88794184 0.44288487 0.88794184 -0.48722726 >,< 45AD03 8E57EC 38B073 71A814 C1A28A >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q06_Gain18_b0    set 0.54434239       ; 45AD03
iir2_H_Parametric_f03174_q06_Gain18_b1    set -0.88794184       ; 8E57EC
iir2_H_Parametric_f03174_q06_Gain18_b2    set 0.44288487       ; 38B073
iir2_H_Parametric_f03174_q06_Gain18_a1    set 0.88794184       ; 71A814
iir2_H_Parametric_f03174_q06_Gain18_a2    set -0.48722726       ; C1A28A

; IIR2: mode=Parametric fc=4000 Q=6 gainDB=18 h=< 0.55457664 -0.82871699 0.42970266 0.82871699 -0.48427930 >,< 46FC5E 95EC9A 37007F 6A1366 C20323 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q06_Gain18_b0    set 0.55457664       ; 46FC5E
iir2_H_Parametric_f04000_q06_Gain18_b1    set -0.82871699       ; 95EC9A
iir2_H_Parametric_f04000_q06_Gain18_b2    set 0.42970266       ; 37007F
iir2_H_Parametric_f04000_q06_Gain18_a1    set 0.82871699       ; 6A1366
iir2_H_Parametric_f04000_q06_Gain18_a2    set -0.48427930       ; C20323

; IIR2: mode=Parametric fc=5039.68 Q=6 gainDB=18 h=< 0.56631969 -0.73871438 0.41457704 0.73871438 -0.48089673 >,< 487D2A A171CF 3510DC 5E8E31 C271FA >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q06_Gain18_b0    set 0.56631969       ; 487D2A
iir2_H_Parametric_f05039_q06_Gain18_b1    set -0.73871438       ; A171CF
iir2_H_Parametric_f05039_q06_Gain18_b2    set 0.41457704       ; 3510DC
iir2_H_Parametric_f05039_q06_Gain18_a1    set 0.73871438       ; 5E8E31
iir2_H_Parametric_f05039_q06_Gain18_a2    set -0.48089673       ; C271FA

; IIR2: mode=Parametric fc=6349.6 Q=6 gainDB=18 h=< 0.57896007 -0.60389394 0.39829562 0.60389394 -0.47725569 >,< 4A1B5D B2B39B 32FB59 4D4C65 C2E949 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q06_Gain18_b0    set 0.57896007       ; 4A1B5D
iir2_H_Parametric_f06349_q06_Gain18_b1    set -0.60389394       ; B2B39B
iir2_H_Parametric_f06349_q06_Gain18_b2    set 0.39829562       ; 32FB59
iir2_H_Parametric_f06349_q06_Gain18_a1    set 0.60389394       ; 4D4C65
iir2_H_Parametric_f06349_q06_Gain18_a2    set -0.47725569       ; C2E949

; IIR2: mode=Parametric fc=8000 Q=6 gainDB=18 h=< 0.59092436 -0.40682834 0.38288504 0.40682834 -0.47380940 >,< 4BA369 CBED0D 310260 3412F3 C35A37 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q06_Gain18_b0    set 0.59092436       ; 4BA369
iir2_H_Parametric_f08000_q06_Gain18_b1    set -0.40682834       ; CBED0D
iir2_H_Parametric_f08000_q06_Gain18_b2    set 0.38288504       ; 310260
iir2_H_Parametric_f08000_q06_Gain18_a1    set 0.40682834       ; 3412F3
iir2_H_Parametric_f08000_q06_Gain18_a2    set -0.47380940       ; C35A37

; IIR2: mode=Parametric fc=10079.4 Q=6 gainDB=18 h=< 0.59893416 -0.13049454 0.37256804 0.13049454 -0.47150219 >,< 4CA9E0 EF4BF5 2FB04F 10B40B C3A5D1 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q06_Gain18_b0    set 0.59893416       ; 4CA9E0
iir2_H_Parametric_f10079_q06_Gain18_b1    set -0.13049454       ; EF4BF5
iir2_H_Parametric_f10079_q06_Gain18_b2    set 0.37256804       ; 2FB04F
iir2_H_Parametric_f10079_q06_Gain18_a1    set 0.13049454       ; 10B40B
iir2_H_Parametric_f10079_q06_Gain18_a2    set -0.47150219       ; C3A5D1

; IIR2: mode=Parametric fc=12699.2 Q=6 gainDB=18 h=< 0.59706576 0.22967240 0.37497462 -0.22967240 -0.47204038 >,< 4C6CA6 1D65E7 2FFF2B E29A19 C3942F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q06_Gain18_b0    set 0.59706576       ; 4C6CA6
iir2_H_Parametric_f12699_q06_Gain18_b1    set 0.22967240       ; 1D65E7
iir2_H_Parametric_f12699_q06_Gain18_b2    set 0.37497462       ; 2FFF2B
iir2_H_Parametric_f12699_q06_Gain18_a1    set -0.22967240       ; E29A19
iir2_H_Parametric_f12699_q06_Gain18_a2    set -0.47204038       ; C3942F

; IIR2: mode=Parametric fc=16000 Q=6 gainDB=18 h=< 0.57629959 0.63663021 0.40172245 -0.63663021 -0.47802204 >,< 49C42F 517D19 336BA4 AE82E7 C2D02D >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q06_Gain18_b0    set 0.57629959       ; 49C42F
iir2_H_Parametric_f16000_q06_Gain18_b1    set 0.63663021       ; 517D19
iir2_H_Parametric_f16000_q06_Gain18_b2    set 0.40172245       ; 336BA4
iir2_H_Parametric_f16000_q06_Gain18_a1    set -0.63663021       ; AE82E7
iir2_H_Parametric_f16000_q06_Gain18_a2    set -0.47802204       ; C2D02D

; IIR2: mode=Parametric fc=20158.7 Q=6 gainDB=18 h=< 0.52714389 0.95637836 0.46503736 -0.95637836 -0.49218125 >,< 437973 7A6A9B 3B8658 859565 C10035 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q06_Gain18_b0    set 0.52714389       ; 437973
iir2_H_Parametric_f20158_q06_Gain18_b1    set 0.95637836       ; 7A6A9B
iir2_H_Parametric_f20158_q06_Gain18_b2    set 0.46503736       ; 3B8658
iir2_H_Parametric_f20158_q06_Gain18_a1    set -0.95637836       ; 859565
iir2_H_Parametric_f20158_q06_Gain18_a2    set -0.49218125       ; C10035

; IIR2: mode=Parametric fc=62.5 Q=15 gainDB=18 h=< 0.50036565 -0.99985503 0.49952903 0.99985503 -0.49989468 >,< 400BFB 8004C0 3FF091 7FFB40 C00374 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q15_Gain18_b0    set 0.50036565       ; 400BFB
iir2_H_Parametric_f00062_q15_Gain18_b1    set -0.99985503       ; 8004C0
iir2_H_Parametric_f00062_q15_Gain18_b2    set 0.49952903       ; 3FF091
iir2_H_Parametric_f00062_q15_Gain18_a1    set 0.99985503       ; 7FFB40
iir2_H_Parametric_f00062_q15_Gain18_a2    set -0.49989468       ; C00374

; IIR2: mode=Parametric fc=78.7451 Q=15 gainDB=18 h=< 0.50046067 -0.99980438 0.49940663 0.99980438 -0.49986730 >,< 400F18 800669 3FEC8E 7FF997 C0045A >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q15_Gain18_b0    set 0.50046067       ; 400F18
iir2_H_Parametric_f00078_q15_Gain18_b1    set -0.99980438       ; 800669
iir2_H_Parametric_f00078_q15_Gain18_b2    set 0.49940663       ; 3FEC8E
iir2_H_Parametric_f00078_q15_Gain18_a1    set 0.99980438       ; 7FF997
iir2_H_Parametric_f00078_q15_Gain18_a2    set -0.49986730       ; C0045A

; IIR2: mode=Parametric fc=99.2126 Q=15 gainDB=18 h=< 0.50058038 -0.99973294 0.49925244 0.99973294 -0.49983282 >,< 401304 8008C1 3FE781 7FF73F C0057B >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q15_Gain18_b0    set 0.50058038       ; 401304
iir2_H_Parametric_f00099_q15_Gain18_b1    set -0.99973294       ; 8008C1
iir2_H_Parametric_f00099_q15_Gain18_b2    set 0.49925244       ; 3FE781
iir2_H_Parametric_f00099_q15_Gain18_a1    set 0.99973294       ; 7FF73F
iir2_H_Parametric_f00099_q15_Gain18_a2    set -0.49983282       ; C0057B

; IIR2: mode=Parametric fc=125 Q=15 gainDB=18 h=< 0.50073119 -0.99963083 0.49905819 0.99963083 -0.49978938 >,< 4017F5 800C19 3FE123 7FF3E7 C006E7 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q15_Gain18_b0    set 0.50073119       ; 4017F5
iir2_H_Parametric_f00125_q15_Gain18_b1    set -0.99963083       ; 800C19
iir2_H_Parametric_f00125_q15_Gain18_b2    set 0.49905819       ; 3FE123
iir2_H_Parametric_f00125_q15_Gain18_a1    set 0.99963083       ; 7FF3E7
iir2_H_Parametric_f00125_q15_Gain18_a2    set -0.49978938       ; C006E7

; IIR2: mode=Parametric fc=157.49 Q=15 gainDB=18 h=< 0.50092116 -0.99948299 0.49881350 0.99948299 -0.49973466 >,< 401E2F 8010F1 3FD91F 7FEF0F C008B2 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q15_Gain18_b0    set 0.50092116       ; 401E2F
iir2_H_Parametric_f00157_q15_Gain18_b1    set -0.99948299       ; 8010F1
iir2_H_Parametric_f00157_q15_Gain18_b2    set 0.49881350       ; 3FD91F
iir2_H_Parametric_f00157_q15_Gain18_a1    set 0.99948299       ; 7FEF0F
iir2_H_Parametric_f00157_q15_Gain18_a2    set -0.49973466       ; C008B2

; IIR2: mode=Parametric fc=198.425 Q=15 gainDB=18 h=< 0.50116046 -0.99926627 0.49850528 0.99926627 -0.49966573 >,< 402606 80180B 3FCF05 7FE7F5 C00AF4 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q15_Gain18_b0    set 0.50116046       ; 402606
iir2_H_Parametric_f00198_q15_Gain18_b1    set -0.99926627       ; 80180B
iir2_H_Parametric_f00198_q15_Gain18_b2    set 0.49850528       ; 3FCF05
iir2_H_Parametric_f00198_q15_Gain18_a1    set 0.99926627       ; 7FE7F5
iir2_H_Parametric_f00198_q15_Gain18_a2    set -0.49966573       ; C00AF4

; IIR2: mode=Parametric fc=250 Q=15 gainDB=18 h=< 0.50146184 -0.99894490 0.49811708 0.99894490 -0.49957892 >,< 402FE7 802293 3FC24D 7FDD6D C00DCD >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q15_Gain18_b0    set 0.50146184       ; 402FE7
iir2_H_Parametric_f00250_q15_Gain18_b1    set -0.99894490       ; 802293
iir2_H_Parametric_f00250_q15_Gain18_b2    set 0.49811708       ; 3FC24D
iir2_H_Parametric_f00250_q15_Gain18_a1    set 0.99894490       ; 7FDD6D
iir2_H_Parametric_f00250_q15_Gain18_a2    set -0.49957892       ; C00DCD

; IIR2: mode=Parametric fc=314.98 Q=15 gainDB=18 h=< 0.50184138 -0.99846332 0.49762822 0.99846332 -0.49946960 >,< 403C56 80325B 3FB248 7FCDA5 C01162 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q15_Gain18_b0    set 0.50184138       ; 403C56
iir2_H_Parametric_f00314_q15_Gain18_b1    set -0.99846332       ; 80325B
iir2_H_Parametric_f00314_q15_Gain18_b2    set 0.49762822       ; 3FB248
iir2_H_Parametric_f00314_q15_Gain18_a1    set 0.99846332       ; 7FCDA5
iir2_H_Parametric_f00314_q15_Gain18_a2    set -0.49946960       ; C01162

; IIR2: mode=Parametric fc=396.85 Q=15 gainDB=18 h=< 0.50231921 -0.99773497 0.49701274 0.99773497 -0.49933196 >,< 404BFF 804A39 3F9E1D 7FB5C7 C015E4 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q15_Gain18_b0    set 0.50231921       ; 404BFF
iir2_H_Parametric_f00396_q15_Gain18_b1    set -0.99773497       ; 804A39
iir2_H_Parametric_f00396_q15_Gain18_b2    set 0.49701274       ; 3F9E1D
iir2_H_Parametric_f00396_q15_Gain18_a1    set 0.99773497       ; 7FB5C7
iir2_H_Parametric_f00396_q15_Gain18_a2    set -0.49933196       ; C015E4

; IIR2: mode=Parametric fc=500 Q=15 gainDB=18 h=< 0.50292060 -0.99662451 0.49623812 0.99662451 -0.49915873 >,< 405FB4 806E9C 3F84BB 7F9164 C01B91 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q15_Gain18_b0    set 0.50292060       ; 405FB4
iir2_H_Parametric_f00500_q15_Gain18_b1    set -0.99662451       ; 806E9C
iir2_H_Parametric_f00500_q15_Gain18_b2    set 0.49623812       ; 3F84BB
iir2_H_Parametric_f00500_q15_Gain18_a1    set 0.99662451       ; 7F9164
iir2_H_Parametric_f00500_q15_Gain18_a2    set -0.49915873       ; C01B91

; IIR2: mode=Parametric fc=629.961 Q=15 gainDB=18 h=< 0.50367710 -0.99491988 0.49526372 0.99491988 -0.49894082 >,< 40787D 80A677 3F64CD 7F5989 C022B5 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q15_Gain18_b0    set 0.50367710       ; 40787D
iir2_H_Parametric_f00629_q15_Gain18_b1    set -0.99491988       ; 80A677
iir2_H_Parametric_f00629_q15_Gain18_b2    set 0.49526372       ; 3F64CD
iir2_H_Parametric_f00629_q15_Gain18_a1    set 0.99491988       ; 7F5989
iir2_H_Parametric_f00629_q15_Gain18_a2    set -0.49894082       ; C022B5

; IIR2: mode=Parametric fc=793.701 Q=15 gainDB=18 h=< 0.50462793 -0.99228836 0.49403901 0.99228836 -0.49866693 >,< 4097A6 80FCB2 3F3CAB 7F034E C02BAF >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q15_Gain18_b0    set 0.50462793       ; 4097A6
iir2_H_Parametric_f00793_q15_Gain18_b1    set -0.99228836       ; 80FCB2
iir2_H_Parametric_f00793_q15_Gain18_b2    set 0.49403901       ; 3F3CAB
iir2_H_Parametric_f00793_q15_Gain18_a1    set 0.99228836       ; 7F034E
iir2_H_Parametric_f00793_q15_Gain18_a2    set -0.49866693       ; C02BAF

; IIR2: mode=Parametric fc=1000 Q=15 gainDB=18 h=< 0.50582152 -0.98820759 0.49250161 0.98820759 -0.49832312 >,< 40BEC2 81826A 3F0A4B 7E7D96 C036F3 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q15_Gain18_b0    set 0.50582152       ; 40BEC2
iir2_H_Parametric_f01000_q15_Gain18_b1    set -0.98820759       ; 81826A
iir2_H_Parametric_f01000_q15_Gain18_b2    set 0.49250161       ; 3F0A4B
iir2_H_Parametric_f01000_q15_Gain18_a1    set 0.98820759       ; 7E7D96
iir2_H_Parametric_f01000_q15_Gain18_a2    set -0.49832312       ; C036F3

; IIR2: mode=Parametric fc=1259.92 Q=15 gainDB=18 h=< 0.50731690 -0.98185784 0.49057547 0.98185784 -0.49789238 >,< 40EFC2 82527C 3ECB2D 7DAD84 C04510 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q15_Gain18_b0    set 0.50731690       ; 40EFC2
iir2_H_Parametric_f01259_q15_Gain18_b1    set -0.98185784       ; 82527C
iir2_H_Parametric_f01259_q15_Gain18_b2    set 0.49057547       ; 3ECB2D
iir2_H_Parametric_f01259_q15_Gain18_a1    set 0.98185784       ; 7DAD84
iir2_H_Parametric_f01259_q15_Gain18_a2    set -0.49789238       ; C04510

; IIR2: mode=Parametric fc=1587.4 Q=15 gainDB=18 h=< 0.50918465 -0.97195498 0.48816973 0.97195498 -0.49735438 >,< 412CF6 8396FB 3E7C58 7C6905 C056B1 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q15_Gain18_b0    set 0.50918465       ; 412CF6
iir2_H_Parametric_f01587_q15_Gain18_b1    set -0.97195498       ; 8396FB
iir2_H_Parametric_f01587_q15_Gain18_b2    set 0.48816973       ; 3E7C58
iir2_H_Parametric_f01587_q15_Gain18_a1    set 0.97195498       ; 7C6905
iir2_H_Parametric_f01587_q15_Gain18_a2    set -0.49735438       ; C056B1

; IIR2: mode=Parametric fc=2000 Q=15 gainDB=18 h=< 0.51150616 -0.95649455 0.48517952 0.95649455 -0.49668567 >,< 417908 859196 3E1A5C 7A6E6A C06C9B >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q15_Gain18_b0    set 0.51150616       ; 417908
iir2_H_Parametric_f02000_q15_Gain18_b1    set -0.95649455       ; 859196
iir2_H_Parametric_f02000_q15_Gain18_b2    set 0.48517952       ; 3E1A5C
iir2_H_Parametric_f02000_q15_Gain18_a1    set 0.95649455       ; 7A6E6A
iir2_H_Parametric_f02000_q15_Gain18_a2    set -0.49668567       ; C06C9B

; IIR2: mode=Parametric fc=2519.84 Q=15 gainDB=18 h=< 0.51436936 -0.93236760 0.48149158 0.93236760 -0.49586093 >,< 41D6DB 88A82E 3DA184 7757D2 C087A1 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q15_Gain18_b0    set 0.51436936       ; 41D6DB
iir2_H_Parametric_f02519_q15_Gain18_b1    set -0.93236760       ; 88A82E
iir2_H_Parametric_f02519_q15_Gain18_b2    set 0.48149158       ; 3DA184
iir2_H_Parametric_f02519_q15_Gain18_a1    set 0.93236760       ; 7757D2
iir2_H_Parametric_f02519_q15_Gain18_a2    set -0.49586093       ; C087A1

; IIR2: mode=Parametric fc=3174.8 Q=15 gainDB=18 h=< 0.51785666 -0.89480374 0.47699976 0.89480374 -0.49485642 >,< 424920 8D7712 3D0E54 7288EE C0A88C >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q15_Gain18_b0    set 0.51785666       ; 424920
iir2_H_Parametric_f03174_q15_Gain18_b1    set -0.89480374       ; 8D7712
iir2_H_Parametric_f03174_q15_Gain18_b2    set 0.47699976       ; 3D0E54
iir2_H_Parametric_f03174_q15_Gain18_a1    set 0.89480374       ; 7288EE
iir2_H_Parametric_f03174_q15_Gain18_a2    set -0.49485642       ; C0A88C

; IIR2: mode=Parametric fc=4000 Q=15 gainDB=18 h=< 0.52201726 -0.83661339 0.47164071 0.83661339 -0.49365797 >,< 42D176 94E9DA 3C5EB9 6B1626 C0CFD1 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q15_Gain18_b0    set 0.52201726       ; 42D176
iir2_H_Parametric_f04000_q15_Gain18_b1    set -0.83661339       ; 94E9DA
iir2_H_Parametric_f04000_q15_Gain18_b2    set 0.47164071       ; 3C5EB9
iir2_H_Parametric_f04000_q15_Gain18_a1    set 0.83661339       ; 6B1626
iir2_H_Parametric_f04000_q15_Gain18_a2    set -0.49365797       ; C0CFD1

; IIR2: mode=Parametric fc=5039.68 Q=15 gainDB=18 h=< 0.52680959 -0.74728528 0.46546795 0.74728528 -0.49227754 >,< 436E7F A058F5 3B9474 5FA70B C0FD0D >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q15_Gain18_b0    set 0.52680959       ; 436E7F
iir2_H_Parametric_f05039_q15_Gain18_b1    set -0.74728528       ; A058F5
iir2_H_Parametric_f05039_q15_Gain18_b2    set 0.46546795       ; 3B9474
iir2_H_Parametric_f05039_q15_Gain18_a1    set 0.74728528       ; 5FA70B
iir2_H_Parametric_f05039_q15_Gain18_a2    set -0.49227754       ; C0FD0D

; IIR2: mode=Parametric fc=6349.6 Q=15 gainDB=18 h=< 0.53199018 -0.61225454 0.45879510 0.61225454 -0.49078529 >,< 441841 B1A1A5 3AB9CC 4E5E5B C12DF3 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q15_Gain18_b0    set 0.53199018       ; 441841
iir2_H_Parametric_f06349_q15_Gain18_b1    set -0.61225454       ; B1A1A5
iir2_H_Parametric_f06349_q15_Gain18_b2    set 0.45879510       ; 3AB9CC
iir2_H_Parametric_f06349_q15_Gain18_a1    set 0.61225454       ; 4E5E5B
iir2_H_Parametric_f06349_q15_Gain18_a2    set -0.49078529       ; C12DF3

; IIR2: mode=Parametric fc=8000 Q=15 gainDB=18 h=< 0.53691488 -0.41332773 0.45245185 0.41332773 -0.48936673 >,< 44B9A0 CB1814 39E9F1 34E7EC C15C6F >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q15_Gain18_b0    set 0.53691488       ; 44B9A0
iir2_H_Parametric_f08000_q15_Gain18_b1    set -0.41332773       ; CB1814
iir2_H_Parametric_f08000_q15_Gain18_b2    set 0.45245185       ; 39E9F1
iir2_H_Parametric_f08000_q15_Gain18_a1    set 0.41332773       ; 34E7EC
iir2_H_Parametric_f08000_q15_Gain18_a2    set -0.48936673       ; C15C6F

; IIR2: mode=Parametric fc=10079.4 Q=15 gainDB=18 h=< 0.54022343 -0.13276614 0.44819028 0.13276614 -0.48841371 >,< 45260A EF0185 395E4C 10FE7B C17BA9 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q15_Gain18_b0    set 0.54022343       ; 45260A
iir2_H_Parametric_f10079_q15_Gain18_b1    set -0.13276614       ; EF0185
iir2_H_Parametric_f10079_q15_Gain18_b2    set 0.44819028       ; 395E4C
iir2_H_Parametric_f10079_q15_Gain18_a1    set 0.13276614       ; 10FE7B
iir2_H_Parametric_f10079_q15_Gain18_a2    set -0.48841371       ; C17BA9

; IIR2: mode=Parametric fc=12699.2 Q=15 gainDB=18 h=< 0.53945083 0.23359365 0.44918543 -0.23359365 -0.48863626 >,< 450CB9 1DE665 397EE8 E2199B C1745E >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q15_Gain18_b0    set 0.53945083       ; 450CB9
iir2_H_Parametric_f12699_q15_Gain18_b1    set 0.23359365       ; 1DE665
iir2_H_Parametric_f12699_q15_Gain18_b2    set 0.44918543       ; 397EE8
iir2_H_Parametric_f12699_q15_Gain18_a1    set -0.23359365       ; E2199B
iir2_H_Parametric_f12699_q15_Gain18_a2    set -0.48863626       ; C1745E

; IIR2: mode=Parametric fc=16000 Q=15 gainDB=18 h=< 0.53089789 0.64514308 0.46020203 -0.64514308 -0.49109992 >,< 43F476 52940C 3AE7E6 AD6BF4 C123A4 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q15_Gain18_b0    set 0.53089789       ; 43F476
iir2_H_Parametric_f16000_q15_Gain18_b1    set 0.64514308       ; 52940C
iir2_H_Parametric_f16000_q15_Gain18_b2    set 0.46020203       ; 3AE7E6
iir2_H_Parametric_f16000_q15_Gain18_a1    set -0.64514308       ; AD6BF4
iir2_H_Parametric_f16000_q15_Gain18_a2    set -0.49109992       ; C123A4

; IIR2: mode=Parametric fc=20158.7 Q=15 gainDB=18 h=< 0.51089817 0.96088905 0.48596264 -0.96088905 -0.49686080 >,< 41651C 7AFE69 3E3406 850197 C066DE >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q15_Gain18_b0    set 0.51089817       ; 41651C
iir2_H_Parametric_f20158_q15_Gain18_b1    set 0.96088905       ; 7AFE69
iir2_H_Parametric_f20158_q15_Gain18_b2    set 0.48596264       ; 3E3406
iir2_H_Parametric_f20158_q15_Gain18_a1    set -0.96088905       ; 850197
iir2_H_Parametric_f20158_q15_Gain18_a2    set -0.49686080       ; C066DE

; IIR2: mode=Parametric fc=62.5 Q=1 gainDB=6 h=< 0.50162936 -0.99668626 0.49509642 0.99668626 -0.49672578 >,< 403564 806C96 3F5F51 7F936A C06B4B >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q01_Gain06_b0    set 0.50162936       ; 403564
iir2_H_Parametric_f00062_q01_Gain06_b1    set -0.99668626       ; 806C96
iir2_H_Parametric_f00062_q01_Gain06_b2    set 0.49509642       ; 3F5F51
iir2_H_Parametric_f00062_q01_Gain06_a1    set 0.99668626       ; 7F936A
iir2_H_Parametric_f00062_q01_Gain06_a2    set -0.49672578       ; C06B4B

; IIR2: mode=Parametric fc=78.7451 Q=1 gainDB=6 h=< 0.50205110 -0.99581560 0.49382718 0.99581560 -0.49587828 >,< 404336 80891E 3F35BA 7F76E2 C08710 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q01_Gain06_b0    set 0.50205110       ; 404336
iir2_H_Parametric_f00078_q01_Gain06_b1    set -0.99581560       ; 80891E
iir2_H_Parametric_f00078_q01_Gain06_b2    set 0.49382718       ; 3F35BA
iir2_H_Parametric_f00078_q01_Gain06_a1    set 0.99581560       ; 7F76E2
iir2_H_Parametric_f00078_q01_Gain06_a2    set -0.49587828       ; C08710

; IIR2: mode=Parametric fc=99.2126 Q=1 gainDB=6 h=< 0.50258142 -0.99471319 0.49223115 0.99471319 -0.49481257 >,< 405496 80AD3D 3F016E 7F52C3 C0A9FC >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q01_Gain06_b0    set 0.50258142       ; 405496
iir2_H_Parametric_f00099_q01_Gain06_b1    set -0.99471319       ; 80AD3D
iir2_H_Parametric_f00099_q01_Gain06_b2    set 0.49223115       ; 3F016E
iir2_H_Parametric_f00099_q01_Gain06_a1    set 0.99471319       ; 7F52C3
iir2_H_Parametric_f00099_q01_Gain06_a2    set -0.49481257       ; C0A9FC

; IIR2: mode=Parametric fc=125 Q=1 gainDB=6 h=< 0.50324795 -0.99331563 0.49022523 0.99331563 -0.49347318 >,< 406A6E 80DB09 3EBFB3 7F24F7 C0D5DF >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q01_Gain06_b0    set 0.50324795       ; 406A6E
iir2_H_Parametric_f00125_q01_Gain06_b1    set -0.99331563       ; 80DB09
iir2_H_Parametric_f00125_q01_Gain06_b2    set 0.49022523       ; 3EBFB3
iir2_H_Parametric_f00125_q01_Gain06_a1    set 0.99331563       ; 7F24F7
iir2_H_Parametric_f00125_q01_Gain06_a2    set -0.49347318       ; C0D5DF

; IIR2: mode=Parametric fc=157.49 Q=1 gainDB=6 h=< 0.50408510 -0.99154123 0.48770580 0.99154123 -0.49179090 >,< 4085DC 81152E 3E6D24 7EEAD2 C10CFF >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q01_Gain06_b0    set 0.50408510       ; 4085DC
iir2_H_Parametric_f00157_q01_Gain06_b1    set -0.99154123       ; 81152E
iir2_H_Parametric_f00157_q01_Gain06_b2    set 0.48770580       ; 3E6D24
iir2_H_Parametric_f00157_q01_Gain06_a1    set 0.99154123       ; 7EEAD2
iir2_H_Parametric_f00157_q01_Gain06_a2    set -0.49179090       ; C10CFF

; IIR2: mode=Parametric fc=198.425 Q=1 gainDB=6 h=< 0.50513570 -0.98928424 0.48454401 0.98928424 -0.48967971 >,< 40A849 815F23 3E0589 7EA0DD C1522D >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q01_Gain06_b0    set 0.50513570       ; 40A849
iir2_H_Parametric_f00198_q01_Gain06_b1    set -0.98928424       ; 815F23
iir2_H_Parametric_f00198_q01_Gain06_b2    set 0.48454401       ; 3E0589
iir2_H_Parametric_f00198_q01_Gain06_a1    set 0.98928424       ; 7EA0DD
iir2_H_Parametric_f00198_q01_Gain06_a2    set -0.48967971       ; C1522D

; IIR2: mode=Parametric fc=250 Q=1 gainDB=6 h=< 0.50645277 -0.98640697 0.48058027 0.98640697 -0.48703304 >,< 40D371 81BD6B 3D83A7 7E4295 C1A8E7 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q01_Gain06_b0    set 0.50645277       ; 40D371
iir2_H_Parametric_f00250_q01_Gain06_b1    set -0.98640697       ; 81BD6B
iir2_H_Parametric_f00250_q01_Gain06_b2    set 0.48058027       ; 3D83A7
iir2_H_Parametric_f00250_q01_Gain06_a1    set 0.98640697       ; 7E4295
iir2_H_Parametric_f00250_q01_Gain06_a2    set -0.48703304       ; C1A8E7

; IIR2: mode=Parametric fc=314.98 Q=1 gainDB=6 h=< 0.50810168 -0.98272910 0.47561784 0.98272910 -0.48371952 >,< 41097A 8235EF 3CE10B 7DCA11 C2157B >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q01_Gain06_b0    set 0.50810168       ; 41097A
iir2_H_Parametric_f00314_q01_Gain06_b1    set -0.98272910       ; 8235EF
iir2_H_Parametric_f00314_q01_Gain06_b2    set 0.47561784       ; 3CE10B
iir2_H_Parametric_f00314_q01_Gain06_a1    set 0.98272910       ; 7DCA11
iir2_H_Parametric_f00314_q01_Gain06_a2    set -0.48371952       ; C2157B

; IIR2: mode=Parametric fc=396.85 Q=1 gainDB=6 h=< 0.51016250 -0.97801284 0.46941576 0.97801284 -0.47957826 >,< 414D01 82D07A 3C15D0 7D2F86 C29D2E >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q01_Gain06_b0    set 0.51016250       ; 414D01
iir2_H_Parametric_f00396_q01_Gain06_b1    set -0.97801284       ; 82D07A
iir2_H_Parametric_f00396_q01_Gain06_b2    set 0.46941576       ; 3C15D0
iir2_H_Parametric_f00396_q01_Gain06_a1    set 0.97801284       ; 7D2F86
iir2_H_Parametric_f00396_q01_Gain06_a2    set -0.47957826       ; C29D2E

; IIR2: mode=Parametric fc=500 Q=1 gainDB=6 h=< 0.51273245 -0.97194242 0.46168142 0.97194242 -0.47441388 >,< 41A137 839764 3B1860 7C689C C34668 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q01_Gain06_b0    set 0.51273245       ; 41A137
iir2_H_Parametric_f00500_q01_Gain06_b1    set -0.97194242       ; 839764
iir2_H_Parametric_f00500_q01_Gain06_b2    set 0.46168142       ; 3B1860
iir2_H_Parametric_f00500_q01_Gain06_a1    set 0.97194242       ; 7C689C
iir2_H_Parametric_f00500_q01_Gain06_a2    set -0.47441388       ; C34668

; IIR2: mode=Parametric fc=629.961 Q=1 gainDB=6 h=< 0.51592824 -0.96409551 0.45206363 0.96409551 -0.46799188 >,< 4209F0 849885 39DD38 7B677B C418D8 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q01_Gain06_b0    set 0.51592824       ; 4209F0
iir2_H_Parametric_f00629_q01_Gain06_b1    set -0.96409551       ; 849885
iir2_H_Parametric_f00629_q01_Gain06_b2    set 0.45206363       ; 39DD38
iir2_H_Parametric_f00629_q01_Gain06_a1    set 0.96409551       ; 7B677B
iir2_H_Parametric_f00629_q01_Gain06_a2    set -0.46799188       ; C418D8

; IIR2: mode=Parametric fc=793.701 Q=1 gainDB=6 h=< 0.51988767 -0.95390349 0.44014765 0.95390349 -0.46003532 >,< 428BAE 85E67E 3856C2 7A1982 C51D90 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q01_Gain06_b0    set 0.51988767       ; 428BAE
iir2_H_Parametric_f00793_q01_Gain06_b1    set -0.95390349       ; 85E67E
iir2_H_Parametric_f00793_q01_Gain06_b2    set 0.44014765       ; 3856C2
iir2_H_Parametric_f00793_q01_Gain06_a1    set 0.95390349       ; 7A1982
iir2_H_Parametric_f00793_q01_Gain06_a2    set -0.46003532       ; C51D90

; IIR2: mode=Parametric fc=1000 Q=1 gainDB=6 h=< 0.52476977 -0.94059646 0.42545487 0.94059646 -0.45022464 >,< 432BA8 879A89 36754E 786577 C65F0A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q01_Gain06_b0    set 0.52476977       ; 432BA8
iir2_H_Parametric_f01000_q01_Gain06_b1    set -0.94059646       ; 879A89
iir2_H_Parametric_f01000_q01_Gain06_b2    set 0.42545487       ; 36754E
iir2_H_Parametric_f01000_q01_Gain06_a1    set 0.94059646       ; 786577
iir2_H_Parametric_f01000_q01_Gain06_a2    set -0.45022464       ; C65F0A

; IIR2: mode=Parametric fc=1259.92 Q=1 gainDB=6 h=< 0.53075187 -0.92312806 0.40745163 0.92312806 -0.43820350 >,< 43EFAD 89D6F1 342760 76290F C7E8F3 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q01_Gain06_b0    set 0.53075187       ; 43EFAD
iir2_H_Parametric_f01259_q01_Gain06_b1    set -0.92312806       ; 89D6F1
iir2_H_Parametric_f01259_q01_Gain06_b2    set 0.40745163       ; 342760
iir2_H_Parametric_f01259_q01_Gain06_a1    set 0.92312806       ; 76290F
iir2_H_Parametric_f01259_q01_Gain06_a2    set -0.43820350       ; C7E8F3

; IIR2: mode=Parametric fc=1587.4 Q=1 gainDB=6 h=< 0.53802119 -0.90007463 0.38557444 0.90007463 -0.42359563 >,< 44DDE1 8CCA5B 315A80 7335A5 C9C79F >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q01_Gain06_b0    set 0.53802119       ; 44DDE1
iir2_H_Parametric_f01587_q01_Gain06_b1    set -0.90007463       ; 8CCA5B
iir2_H_Parametric_f01587_q01_Gain06_b2    set 0.38557444       ; 315A80
iir2_H_Parametric_f01587_q01_Gain06_a1    set 0.90007463       ; 7335A5
iir2_H_Parametric_f01587_q01_Gain06_a2    set -0.42359563       ; C9C79F

; IIR2: mode=Parametric fc=2000 Q=1 gainDB=6 h=< 0.54675738 -0.86950423 0.35928271 0.86950423 -0.40604009 >,< 45FC25 90B416 2DFCF9 6F4BEA CC06E1 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q01_Gain06_b0    set 0.54675738       ; 45FC25
iir2_H_Parametric_f02000_q01_Gain06_b1    set -0.86950423       ; 90B416
iir2_H_Parametric_f02000_q01_Gain06_b2    set 0.35928271       ; 2DFCF9
iir2_H_Parametric_f02000_q01_Gain06_a1    set 0.86950423       ; 6F4BEA
iir2_H_Parametric_f02000_q01_Gain06_a2    set -0.40604009       ; CC06E1

; IIR2: mode=Parametric fc=2519.84 Q=1 gainDB=6 h=< 0.55710027 -0.82881439 0.32815558 0.82881439 -0.38525585 >,< 474F10 95E969 2A0100 6A1697 CEAFF0 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q01_Gain06_b0    set 0.55710027       ; 474F10
iir2_H_Parametric_f02519_q01_Gain06_b1    set -0.82881439       ; 95E969
iir2_H_Parametric_f02519_q01_Gain06_b2    set 0.32815558       ; 2A0100
iir2_H_Parametric_f02519_q01_Gain06_a1    set 0.82881439       ; 6A1697
iir2_H_Parametric_f02519_q01_Gain06_a2    set -0.38525585       ; CEAFF0

; IIR2: mode=Parametric fc=3174.8 Q=1 gainDB=6 h=< 0.56909552 -0.77454519 0.29205561 0.77454519 -0.36115113 >,< 48D81F 9CDBB4 256214 63244C D1C5CD >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q01_Gain06_b0    set 0.56909552       ; 48D81F
iir2_H_Parametric_f03174_q01_Gain06_b1    set -0.77454519       ; 9CDBB4
iir2_H_Parametric_f03174_q01_Gain06_b2    set 0.29205561       ; 256214
iir2_H_Parametric_f03174_q01_Gain06_a1    set 0.77454519       ; 63244C
iir2_H_Parametric_f03174_q01_Gain06_a2    set -0.36115113       ; D1C5CD

; IIR2: mode=Parametric fc=4000 Q=1 gainDB=6 h=< 0.58260795 -0.70218688 0.25138969 0.70218688 -0.33399764 >,< 4A92E5 A61EBE 202D89 59E142 D53F91 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q01_Gain06_b0    set 0.58260795       ; 4A92E5
iir2_H_Parametric_f04000_q01_Gain06_b1    set -0.70218688       ; A61EBE
iir2_H_Parametric_f04000_q01_Gain06_b2    set 0.25138969       ; 202D89
iir2_H_Parametric_f04000_q01_Gain06_a1    set 0.70218688       ; 59E142
iir2_H_Parametric_f04000_q01_Gain06_a2    set -0.33399764       ; D53F91

; IIR2: mode=Parametric fc=5039.68 Q=1 gainDB=6 h=< 0.59718953 -0.60601716 0.20750613 0.60601716 -0.30469566 >,< 4C70B5 B26E08 1A8F8F 4D91F8 D8FFBC >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q01_Gain06_b0    set 0.59718953       ; 4C70B5
iir2_H_Parametric_f05039_q01_Gain06_b1    set -0.60601716       ; B26E08
iir2_H_Parametric_f05039_q01_Gain06_b2    set 0.20750613       ; 1A8F8F
iir2_H_Parametric_f05039_q01_Gain06_a1    set 0.60601716       ; 4D91F8
iir2_H_Parametric_f05039_q01_Gain06_a2    set -0.30469566       ; D8FFBC

; IIR2: mode=Parametric fc=6349.6 Q=1 gainDB=6 h=< 0.61188302 -0.47901458 0.16328576 0.47901458 -0.27516878 >,< 4E522F C2AFA7 14E68C 3D5059 DCC745 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q01_Gain06_b0    set 0.61188302       ; 4E522F
iir2_H_Parametric_f06349_q01_Gain06_b1    set -0.47901458       ; C2AFA7
iir2_H_Parametric_f06349_q01_Gain06_b2    set 0.16328576       ; 14E68C
iir2_H_Parametric_f06349_q01_Gain06_a1    set 0.47901458       ; 3D5059
iir2_H_Parametric_f06349_q01_Gain06_a2    set -0.27516878       ; DCC745

; IIR2: mode=Parametric fc=8000 Q=1 gainDB=6 h=< 0.62492167 -0.31289608 0.12404567 0.31289608 -0.24896734 >,< 4FFD6F D7F306 0FE0BA 280CFA E021D7 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q01_Gain06_b0    set 0.62492167       ; 4FFD6F
iir2_H_Parametric_f08000_q01_Gain06_b1    set -0.31289608       ; D7F306
iir2_H_Parametric_f08000_q01_Gain06_b2    set 0.12404567       ; 0FE0BA
iir2_H_Parametric_f08000_q01_Gain06_a1    set 0.31289608       ; 280CFA
iir2_H_Parametric_f08000_q01_Gain06_a2    set -0.24896734       ; E021D7

; IIR2: mode=Parametric fc=10079.4 Q=1 gainDB=6 h=< 0.63321680 -0.09836407 0.09908132 0.09836407 -0.23229812 >,< 510D3F F368CF 0CAEB2 0C9731 E2440F >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q01_Gain06_b0    set 0.63321680       ; 510D3F
iir2_H_Parametric_f10079_q01_Gain06_b1    set -0.09836407       ; F368CF
iir2_H_Parametric_f10079_q01_Gain06_b2    set 0.09908132       ; 0CAEB2
iir2_H_Parametric_f10079_q01_Gain06_a1    set 0.09836407       ; 0C9731
iir2_H_Parametric_f10079_q01_Gain06_a2    set -0.23229812       ; E2440F

; IIR2: mode=Parametric fc=12699.2 Q=1 gainDB=6 h=< 0.63131156 0.17393104 0.10481517 -0.17393104 -0.23612673 >,< 50CED1 16435F 0D6A95 E9BCA1 E1C69A >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q01_Gain06_b0    set 0.63131156       ; 50CED1
iir2_H_Parametric_f12699_q01_Gain06_b1    set 0.17393104       ; 16435F
iir2_H_Parametric_f12699_q01_Gain06_b2    set 0.10481517       ; 0D6A95
iir2_H_Parametric_f12699_q01_Gain06_a1    set -0.17393104       ; E9BCA1
iir2_H_Parametric_f12699_q01_Gain06_a2    set -0.23612673       ; E1C69A

; IIR2: mode=Parametric fc=16000 Q=1 gainDB=6 h=< 0.60887181 0.50852451 0.17234807 -0.50852451 -0.28121988 >,< 4DEF83 411755 160F80 BEE8AB DC00FD >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q01_Gain06_b0    set 0.60887181       ; 4DEF83
iir2_H_Parametric_f16000_q01_Gain06_b1    set 0.50852451       ; 411755
iir2_H_Parametric_f16000_q01_Gain06_b2    set 0.17234807       ; 160F80
iir2_H_Parametric_f16000_q01_Gain06_a1    set -0.50852451       ; BEE8AB
iir2_H_Parametric_f16000_q01_Gain06_a2    set -0.28121988       ; DC00FD

; IIR2: mode=Parametric fc=20158.7 Q=1 gainDB=6 h=< 0.54450056 0.87771708 0.36607466 -0.87771708 -0.41057522 >,< 45B231 705908 2EDB88 8FA6F8 CB7246 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q01_Gain06_b0    set 0.54450056       ; 45B231
iir2_H_Parametric_f20158_q01_Gain06_b1    set 0.87771708       ; 705908
iir2_H_Parametric_f20158_q01_Gain06_b2    set 0.36607466       ; 2EDB88
iir2_H_Parametric_f20158_q01_Gain06_a1    set -0.87771708       ; 8FA6F8
iir2_H_Parametric_f20158_q01_Gain06_a2    set -0.41057522       ; CB7246

; IIR2: mode=Parametric fc=62.5 Q=6 gainDB=6 h=< 0.50026159 -0.99943471 0.49921275 0.99943471 -0.49947434 >,< 400892 801286 3FE634 7FED7A C0113A >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q06_Gain06_b0    set 0.50026159       ; 400892
iir2_H_Parametric_f00062_q06_Gain06_b1    set -0.99943471       ; 801286
iir2_H_Parametric_f00062_q06_Gain06_b2    set 0.49921275       ; 3FE634
iir2_H_Parametric_f00062_q06_Gain06_a1    set 0.99943471       ; 7FED7A
iir2_H_Parametric_f00062_q06_Gain06_a2    set -0.49947434       ; C0113A

; IIR2: mode=Parametric fc=78.7451 Q=6 gainDB=6 h=< 0.50032953 -0.99927491 0.49900827 0.99927491 -0.49933780 >,< 400ACC 8017C3 3FDF80 7FE83D C015B3 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q06_Gain06_b0    set 0.50032953       ; 400ACC
iir2_H_Parametric_f00078_q06_Gain06_b1    set -0.99927491       ; 8017C3
iir2_H_Parametric_f00078_q06_Gain06_b2    set 0.49900827       ; 3FDF80
iir2_H_Parametric_f00078_q06_Gain06_a1    set 0.99927491       ; 7FE83D
iir2_H_Parametric_f00078_q06_Gain06_a2    set -0.49933780       ; C015B3

; IIR2: mode=Parametric fc=99.2126 Q=6 gainDB=6 h=< 0.50041511 -0.99906601 0.49875073 0.99906601 -0.49916583 >,< 400D9A 801E9B 3FD710 7FE165 C01B56 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q06_Gain06_b0    set 0.50041511       ; 400D9A
iir2_H_Parametric_f00099_q06_Gain06_b1    set -0.99906601       ; 801E9B
iir2_H_Parametric_f00099_q06_Gain06_b2    set 0.49875073       ; 3FD710
iir2_H_Parametric_f00099_q06_Gain06_a1    set 0.99906601       ; 7FE165
iir2_H_Parametric_f00099_q06_Gain06_a2    set -0.49916583       ; C01B56

; IIR2: mode=Parametric fc=125 Q=6 gainDB=6 h=< 0.50052288 -0.99879085 0.49842639 0.99879085 -0.49894927 >,< 401122 80279F 3FCC6F 7FD861 C0226F >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q06_Gain06_b0    set 0.50052288       ; 401122
iir2_H_Parametric_f00125_q06_Gain06_b1    set -0.99879085       ; 80279F
iir2_H_Parametric_f00125_q06_Gain06_b2    set 0.49842639       ; 3FCC6F
iir2_H_Parametric_f00125_q06_Gain06_a1    set 0.99879085       ; 7FD861
iir2_H_Parametric_f00125_q06_Gain06_a2    set -0.49894927       ; C0226F

; IIR2: mode=Parametric fc=157.49 Q=6 gainDB=6 h=< 0.50065859 -0.99842516 0.49801797 0.99842516 -0.49867656 >,< 401594 80339B 3FBF0D 7FCC65 C02B5E >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q06_Gain06_b0    set 0.50065859       ; 401594
iir2_H_Parametric_f00157_q06_Gain06_b1    set -0.99842516       ; 80339B
iir2_H_Parametric_f00157_q06_Gain06_b2    set 0.49801797       ; 3FBF0D
iir2_H_Parametric_f00157_q06_Gain06_a1    set 0.99842516       ; 7FCC65
iir2_H_Parametric_f00157_q06_Gain06_a2    set -0.49867656       ; C02B5E

; IIR2: mode=Parametric fc=198.425 Q=6 gainDB=6 h=< 0.50082944 -0.99793430 0.49750379 0.99793430 -0.49833323 >,< 401B2E 8043B1 3FAE34 7FBC4F C0369E >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q06_Gain06_b0    set 0.50082944       ; 401B2E
iir2_H_Parametric_f00198_q06_Gain06_b1    set -0.99793430       ; 8043B1
iir2_H_Parametric_f00198_q06_Gain06_b2    set 0.49750379       ; 3FAE34
iir2_H_Parametric_f00198_q06_Gain06_a1    set 0.99793430       ; 7FBC4F
iir2_H_Parametric_f00198_q06_Gain06_a2    set -0.49833323       ; C0369E

; IIR2: mode=Parametric fc=250 Q=6 gainDB=6 h=< 0.50104449 -0.99726811 0.49685658 0.99726811 -0.49790107 >,< 40223A 805985 3F98FF 7FA67B C044C7 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q06_Gain06_b0    set 0.50104449       ; 40223A
iir2_H_Parametric_f00250_q06_Gain06_b1    set -0.99726811       ; 805985
iir2_H_Parametric_f00250_q06_Gain06_b2    set 0.49685658       ; 3F98FF
iir2_H_Parametric_f00250_q06_Gain06_a1    set 0.99726811       ; 7FA67B
iir2_H_Parametric_f00250_q06_Gain06_a2    set -0.49790107       ; C044C7

; IIR2: mode=Parametric fc=314.98 Q=6 gainDB=6 h=< 0.50131510 -0.99635313 0.49604218 0.99635313 -0.49735728 >,< 402B18 807780 3F7E4F 7F8880 C05699 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q06_Gain06_b0    set 0.50131510       ; 402B18
iir2_H_Parametric_f00314_q06_Gain06_b1    set -0.99635313       ; 807780
iir2_H_Parametric_f00314_q06_Gain06_b2    set 0.49604218       ; 3F7E4F
iir2_H_Parametric_f00314_q06_Gain06_a1    set 0.99635313       ; 7F8880
iir2_H_Parametric_f00314_q06_Gain06_a2    set -0.49735728       ; C05699

; IIR2: mode=Parametric fc=396.85 Q=6 gainDB=6 h=< 0.50165546 -0.99508059 0.49501786 0.99508059 -0.49667332 >,< 40363F 80A133 3F5CBE 7F5ECD C06D03 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q06_Gain06_b0    set 0.50165546       ; 40363F
iir2_H_Parametric_f00396_q06_Gain06_b1    set -0.99508059       ; 80A133
iir2_H_Parametric_f00396_q06_Gain06_b2    set 0.49501786       ; 3F5CBE
iir2_H_Parametric_f00396_q06_Gain06_a1    set 0.99508059       ; 7F5ECD
iir2_H_Parametric_f00396_q06_Gain06_a2    set -0.49667332       ; C06D03

; IIR2: mode=Parametric fc=500 Q=6 gainDB=6 h=< 0.50208330 -0.99328785 0.49373028 0.99328785 -0.49581358 >,< 404444 80DBF2 3F328D 7F240E C0892F >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q06_Gain06_b0    set 0.50208330       ; 404444
iir2_H_Parametric_f00500_q06_Gain06_b1    set -0.99328785       ; 80DBF2
iir2_H_Parametric_f00500_q06_Gain06_b2    set 0.49373028       ; 3F328D
iir2_H_Parametric_f00500_q06_Gain06_a1    set 0.99328785       ; 7F240E
iir2_H_Parametric_f00500_q06_Gain06_a2    set -0.49581358       ; C0892F

; IIR2: mode=Parametric fc=629.961 Q=6 gainDB=6 h=< 0.50262064 -0.99072977 0.49211314 0.99072977 -0.49473377 >,< 4055DF 812FC5 3EFD90 7ED03B C0AC91 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q06_Gain06_b0    set 0.50262064       ; 4055DF
iir2_H_Parametric_f00629_q06_Gain06_b1    set -0.99072977       ; 812FC5
iir2_H_Parametric_f00629_q06_Gain06_b2    set 0.49211314       ; 3EFD90
iir2_H_Parametric_f00629_q06_Gain06_a1    set 0.99072977       ; 7ED03B
iir2_H_Parametric_f00629_q06_Gain06_a2    set -0.49473377       ; C0AC91

; IIR2: mode=Parametric fc=793.701 Q=6 gainDB=6 h=< 0.50329470 -0.98703443 0.49008453 0.98703443 -0.49337923 >,< 406BF6 81A8DB 3EBB17 7E5725 C0D8F3 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q06_Gain06_b0    set 0.50329470       ; 406BF6
iir2_H_Parametric_f00793_q06_Gain06_b1    set -0.98703443       ; 81A8DB
iir2_H_Parametric_f00793_q06_Gain06_b2    set 0.49008453       ; 3EBB17
iir2_H_Parametric_f00793_q06_Gain06_a1    set 0.98703443       ; 7E5725
iir2_H_Parametric_f00793_q06_Gain06_a2    set -0.49337923       ; C0D8F3

; IIR2: mode=Parametric fc=1000 Q=6 gainDB=6 h=< 0.50413878 -0.98163477 0.48754425 0.98163477 -0.49168303 >,< 40879E 8259CB 3E67D9 7DA635 C11088 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q06_Gain06_b0    set 0.50413878       ; 40879E
iir2_H_Parametric_f01000_q06_Gain06_b1    set -0.98163477       ; 8259CB
iir2_H_Parametric_f01000_q06_Gain06_b2    set 0.48754425       ; 3E67D9
iir2_H_Parametric_f01000_q06_Gain06_a1    set 0.98163477       ; 7DA635
iir2_H_Parametric_f01000_q06_Gain06_a2    set -0.49168303       ; C11088

; IIR2: mode=Parametric fc=1259.92 Q=6 gainDB=6 h=< 0.50519305 -0.97366374 0.48437140 0.97366374 -0.48956446 >,< 40AA2A 835EFD 3DFFE1 7CA103 C155F4 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q06_Gain06_b0    set 0.50519305       ; 40AA2A
iir2_H_Parametric_f01259_q06_Gain06_b1    set -0.97366374       ; 835EFD
iir2_H_Parametric_f01259_q06_Gain06_b2    set 0.48437140       ; 3DFFE1
iir2_H_Parametric_f01259_q06_Gain06_a1    set 0.97366374       ; 7CA103
iir2_H_Parametric_f01259_q06_Gain06_a2    set -0.48956446       ; C155F4

; IIR2: mode=Parametric fc=1587.4 Q=6 gainDB=6 h=< 0.50650480 -0.96179460 0.48042368 0.96179460 -0.48692848 >,< 40D526 84E3EA 3D7E86 7B1C16 C1AC54 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q06_Gain06_b0    set 0.50650480       ; 40D526
iir2_H_Parametric_f01587_q06_Gain06_b1    set -0.96179460       ; 84E3EA
iir2_H_Parametric_f01587_q06_Gain06_b2    set 0.48042368       ; 3D7E86
iir2_H_Parametric_f01587_q06_Gain06_a1    set 0.96179460       ; 7B1C16
iir2_H_Parametric_f01587_q06_Gain06_a2    set -0.48692848       ; C1AC54

; IIR2: mode=Parametric fc=2000 Q=6 gainDB=6 h=< 0.50812747 -0.94400151 0.47554022 0.94400151 -0.48366769 >,< 410A52 872AF6 3CDE80 78D50A C2172E >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q06_Gain06_b0    set 0.50812747       ; 410A52
iir2_H_Parametric_f02000_q06_Gain06_b1    set -0.94400151       ; 872AF6
iir2_H_Parametric_f02000_q06_Gain06_b2    set 0.47554022       ; 3CDE80
iir2_H_Parametric_f02000_q06_Gain06_a1    set 0.94400151       ; 78D50A
iir2_H_Parametric_f02000_q06_Gain06_a2    set -0.48366769       ; C2172E

; IIR2: mode=Parametric fc=2519.84 Q=6 gainDB=6 h=< 0.51011703 -0.91720860 0.46955259 0.91720860 -0.47966962 >,< 414B84 8A98E9 3C1A4C 756717 C29A30 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q06_Gain06_b0    set 0.51011703       ; 414B84
iir2_H_Parametric_f02519_q06_Gain06_b1    set -0.91720860       ; 8A98E9
iir2_H_Parametric_f02519_q06_Gain06_b2    set 0.46955259       ; 3C1A4C
iir2_H_Parametric_f02519_q06_Gain06_a1    set 0.91720860       ; 756717
iir2_H_Parametric_f02519_q06_Gain06_a2    set -0.47966962       ; C29A30

; IIR2: mode=Parametric fc=3174.8 Q=6 gainDB=6 h=< 0.51252292 -0.87679581 0.46231200 0.87679581 -0.47483493 >,< 419A5A 8FC528 3B2D0A 703AD8 C3389C >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q06_Gain06_b0    set 0.51252292       ; 419A5A
iir2_H_Parametric_f03174_q06_Gain06_b1    set -0.87679581       ; 8FC528
iir2_H_Parametric_f03174_q06_Gain06_b2    set 0.46231200       ; 3B2D0A
iir2_H_Parametric_f03174_q06_Gain06_a1    set 0.87679581       ; 703AD8
iir2_H_Parametric_f03174_q06_Gain06_a2    set -0.47483493       ; C3389C

; IIR2: mode=Parametric fc=4000 Q=6 gainDB=6 h=< 0.51536870 -0.81595045 0.45374759 0.81595045 -0.46911629 >,< 41F79A 978EF0 3A1466 687110 C3F400 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q06_Gain06_b0    set 0.51536870       ; 41F79A
iir2_H_Parametric_f04000_q06_Gain06_b1    set -0.81595045       ; 978EF0
iir2_H_Parametric_f04000_q06_Gain06_b2    set 0.45374759       ; 3A1466
iir2_H_Parametric_f04000_q06_Gain06_a1    set 0.81595045       ; 687110
iir2_H_Parametric_f04000_q06_Gain06_a2    set -0.46911629       ; C3F400

; IIR2: mode=Parametric fc=5039.68 Q=6 gainDB=6 h=< 0.51861382 -0.72493143 0.44398132 0.72493143 -0.46259514 >,< 4261F0 A33573 38D461 5CCA8D C4C9AF >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q06_Gain06_b0    set 0.51861382       ; 4261F0
iir2_H_Parametric_f05039_q06_Gain06_b1    set -0.72493143       ; A33573
iir2_H_Parametric_f05039_q06_Gain06_b2    set 0.44398132       ; 38D461
iir2_H_Parametric_f05039_q06_Gain06_a1    set 0.72493143       ; 5CCA8D
iir2_H_Parametric_f05039_q06_Gain06_a2    set -0.46259514       ; C4C9AF

; IIR2: mode=Parametric fc=6349.6 Q=6 gainDB=6 h=< 0.52208304 -0.59052646 0.43354063 0.59052646 -0.45562367 >,< 42D39E B469A1 377E42 4B965F C5AE20 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q06_Gain06_b0    set 0.52208304       ; 42D39E
iir2_H_Parametric_f06349_q06_Gain06_b1    set -0.59052646       ; B469A1
iir2_H_Parametric_f06349_q06_Gain06_b2    set 0.43354063       ; 377E42
iir2_H_Parametric_f06349_q06_Gain06_a1    set 0.59052646       ; 4B965F
iir2_H_Parametric_f06349_q06_Gain06_a2    set -0.45562367       ; C5AE20

; IIR2: mode=Parametric fc=8000 Q=6 gainDB=6 h=< 0.52534414 -0.39649315 0.42372630 0.39649315 -0.44907044 >,< 433E7A CD3FB7 363CA9 32C049 C684DC >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q06_Gain06_b0    set 0.52534414       ; 433E7A
iir2_H_Parametric_f08000_q06_Gain06_b1    set -0.39649315       ; CD3FB7
iir2_H_Parametric_f08000_q06_Gain06_b2    set 0.42372630       ; 363CA9
iir2_H_Parametric_f08000_q06_Gain06_a1    set 0.39649315       ; 32C049
iir2_H_Parametric_f08000_q06_Gain06_a2    set -0.44907044       ; C684DC

; IIR2: mode=Parametric fc=10079.4 Q=6 gainDB=6 h=< 0.52751520 -0.12689544 0.41719245 0.12689544 -0.44470765 >,< 43859E EFC1E4 356690 103E1C C713D2 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q06_Gain06_b0    set 0.52751520       ; 43859E
iir2_H_Parametric_f10079_q06_Gain06_b1    set -0.12689544       ; EFC1E4
iir2_H_Parametric_f10079_q06_Gain06_b2    set 0.41719245       ; 356690
iir2_H_Parametric_f10079_q06_Gain06_a1    set 0.12689544       ; 103E1C
iir2_H_Parametric_f10079_q06_Gain06_a2    set -0.44470765       ; C713D2

; IIR2: mode=Parametric fc=12699.2 Q=6 gainDB=6 h=< 0.52700964 0.22345430 0.41871395 -0.22345430 -0.44572358 >,< 43750D 1C9A26 35986B E365DA C6F288 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q06_Gain06_b0    set 0.52700964       ; 43750D
iir2_H_Parametric_f12699_q06_Gain06_b1    set 0.22345430       ; 1C9A26
iir2_H_Parametric_f12699_q06_Gain06_b2    set 0.41871395       ; 35986B
iir2_H_Parametric_f12699_q06_Gain06_a1    set -0.22345430       ; E365DA
iir2_H_Parametric_f12699_q06_Gain06_a2    set -0.44572358       ; C6F288

; IIR2: mode=Parametric fc=16000 Q=6 gainDB=6 h=< 0.52135490 0.62300276 0.43573198 -0.62300276 -0.45708688 >,< 42BBC2 4FBE8E 37C610 B04172 C57E2E >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q06_Gain06_b0    set 0.52135490       ; 42BBC2
iir2_H_Parametric_f16000_q06_Gain06_b1    set 0.62300276       ; 4FBE8E
iir2_H_Parametric_f16000_q06_Gain06_b2    set 0.43573198       ; 37C610
iir2_H_Parametric_f16000_q06_Gain06_a1    set -0.62300276       ; B04172
iir2_H_Parametric_f16000_q06_Gain06_a2    set -0.45708688       ; C57E2E

; IIR2: mode=Parametric fc=20158.7 Q=6 gainDB=6 h=< 0.50770333 0.94899357 0.47681668 -0.94899357 -0.48452001 >,< 40FC6C 79789F 3D0854 868761 C1FB40 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q06_Gain06_b0    set 0.50770333       ; 40FC6C
iir2_H_Parametric_f20158_q06_Gain06_b1    set 0.94899357       ; 79789F
iir2_H_Parametric_f20158_q06_Gain06_b2    set 0.47681668       ; 3D0854
iir2_H_Parametric_f20158_q06_Gain06_a1    set -0.94899357       ; 868761
iir2_H_Parametric_f20158_q06_Gain06_a2    set -0.48452001       ; C1FB40

; IIR2: mode=Parametric fc=62.5 Q=15 gainDB=6 h=< 0.50010457 -0.99975023 0.49968531 0.99975023 -0.49978987 >,< 40036D 80082F 3FF5B0 7FF7D1 C006E3 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q15_Gain06_b0    set 0.50010457       ; 40036D
iir2_H_Parametric_f00062_q15_Gain06_b1    set -0.99975023       ; 80082F
iir2_H_Parametric_f00062_q15_Gain06_b2    set 0.49968531       ; 3FF5B0
iir2_H_Parametric_f00062_q15_Gain06_a1    set 0.99975023       ; 7FF7D1
iir2_H_Parametric_f00062_q15_Gain06_a2    set -0.49978987       ; C006E3

; IIR2: mode=Parametric fc=78.7451 Q=15 gainDB=6 h=< 0.50013174 -0.99967235 0.49960354 0.99967235 -0.49973527 >,< 400451 800ABD 3FF302 7FF543 C008AD >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q15_Gain06_b0    set 0.50013174       ; 400451
iir2_H_Parametric_f00078_q15_Gain06_b1    set -0.99967235       ; 800ABD
iir2_H_Parametric_f00078_q15_Gain06_b2    set 0.49960354       ; 3FF302
iir2_H_Parametric_f00078_q15_Gain06_a1    set 0.99967235       ; 7FF543
iir2_H_Parametric_f00078_q15_Gain06_a2    set -0.49973527       ; C008AD

; IIR2: mode=Parametric fc=99.2126 Q=15 gainDB=6 h=< 0.50016596 -0.99956662 0.49950053 0.99956662 -0.49966649 >,< 400570 800E34 3FEFA2 7FF1CC C00AEE >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q15_Gain06_b0    set 0.50016596       ; 400570
iir2_H_Parametric_f00099_q15_Gain06_b1    set -0.99956662       ; 800E34
iir2_H_Parametric_f00099_q15_Gain06_b2    set 0.49950053       ; 3FEFA2
iir2_H_Parametric_f00099_q15_Gain06_a1    set 0.99956662       ; 7FF1CC
iir2_H_Parametric_f00099_q15_Gain06_a2    set -0.49966649       ; C00AEE

; IIR2: mode=Parametric fc=125 Q=15 gainDB=6 h=< 0.50020908 -0.99942133 0.49937077 0.99942133 -0.49957985 >,< 4006DA 8012F6 3FEB61 7FED0A C00DC5 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q15_Gain06_b0    set 0.50020908       ; 4006DA
iir2_H_Parametric_f00125_q15_Gain06_b1    set -0.99942133       ; 8012F6
iir2_H_Parametric_f00125_q15_Gain06_b2    set 0.49937077       ; 3FEB61
iir2_H_Parametric_f00125_q15_Gain06_a1    set 0.99942133       ; 7FED0A
iir2_H_Parametric_f00125_q15_Gain06_a2    set -0.49957985       ; C00DC5

; IIR2: mode=Parametric fc=157.49 Q=15 gainDB=6 h=< 0.50026339 -0.99921912 0.49920733 0.99921912 -0.49947072 >,< 4008A1 801997 3FE606 7FE669 C01158 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q15_Gain06_b0    set 0.50026339       ; 4008A1
iir2_H_Parametric_f00157_q15_Gain06_b1    set -0.99921912       ; 801997
iir2_H_Parametric_f00157_q15_Gain06_b2    set 0.49920733       ; 3FE606
iir2_H_Parametric_f00157_q15_Gain06_a1    set 0.99921912       ; 7FE669
iir2_H_Parametric_f00157_q15_Gain06_a2    set -0.49947072       ; C01158

; IIR2: mode=Parametric fc=198.425 Q=15 gainDB=6 h=< 0.50033179 -0.99893394 0.49900149 0.99893394 -0.49933327 >,< 400ADF 8022EF 3FDF47 7FDD11 C015D9 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q15_Gain06_b0    set 0.50033179       ; 400ADF
iir2_H_Parametric_f00198_q15_Gain06_b1    set -0.99893394       ; 8022EF
iir2_H_Parametric_f00198_q15_Gain06_b2    set 0.49900149       ; 3FDF47
iir2_H_Parametric_f00198_q15_Gain06_a1    set 0.99893394       ; 7FDD11
iir2_H_Parametric_f00198_q15_Gain06_a2    set -0.49933327       ; C015D9

; IIR2: mode=Parametric fc=250 Q=15 gainDB=6 h=< 0.50041792 -0.99852643 0.49874227 0.99852643 -0.49916018 >,< 400DB2 803049 3FD6C9 7FCFB7 C01B85 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q15_Gain06_b0    set 0.50041792       ; 400DB2
iir2_H_Parametric_f00250_q15_Gain06_b1    set -0.99852643       ; 803049
iir2_H_Parametric_f00250_q15_Gain06_b2    set 0.49874227       ; 3FD6C9
iir2_H_Parametric_f00250_q15_Gain06_a1    set 0.99852643       ; 7FCFB7
iir2_H_Parametric_f00250_q15_Gain06_a2    set -0.49916018       ; C01B85

; IIR2: mode=Parametric fc=314.98 Q=15 gainDB=6 h=< 0.50052636 -0.99793652 0.49841590 0.99793652 -0.49894226 >,< 40113F 80439E 3FCC17 7FBC62 C022A9 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q15_Gain06_b0    set 0.50052636       ; 40113F
iir2_H_Parametric_f00314_q15_Gain06_b1    set -0.99793652       ; 80439E
iir2_H_Parametric_f00314_q15_Gain06_b2    set 0.49841590       ; 3FCC17
iir2_H_Parametric_f00314_q15_Gain06_a1    set 0.99793652       ; 7FBC62
iir2_H_Parametric_f00314_q15_Gain06_a2    set -0.49894226       ; C022A9

; IIR2: mode=Parametric fc=396.85 Q=15 gainDB=6 h=< 0.50066286 -0.99707204 0.49800510 0.99707204 -0.49866796 >,< 4015B8 805FF2 3FBEA1 7FA00E C02BA6 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q15_Gain06_b0    set 0.50066286       ; 4015B8
iir2_H_Parametric_f00396_q15_Gain06_b1    set -0.99707204       ; 805FF2
iir2_H_Parametric_f00396_q15_Gain06_b2    set 0.49800510       ; 3FBEA1
iir2_H_Parametric_f00396_q15_Gain06_a1    set 0.99707204       ; 7FA00E
iir2_H_Parametric_f00396_q15_Gain06_a2    set -0.49866796       ; C02BA6

; IIR2: mode=Parametric fc=500 Q=15 gainDB=6 h=< 0.50083461 -0.99579075 0.49748824 0.99579075 -0.49832284 >,< 401B59 8089EE 3FADB1 7F7612 C036F5 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q15_Gain06_b0    set 0.50083461       ; 401B59
iir2_H_Parametric_f00500_q15_Gain06_b1    set -0.99579075       ; 8089EE
iir2_H_Parametric_f00500_q15_Gain06_b2    set 0.49748824       ; 3FADB1
iir2_H_Parametric_f00500_q15_Gain06_a1    set 0.99579075       ; 7F7612
iir2_H_Parametric_f00500_q15_Gain06_a2    set -0.49832284       ; C036F5

; IIR2: mode=Parametric fc=629.961 Q=15 gainDB=6 h=< 0.50105056 -0.99387218 0.49683832 0.99387218 -0.49788888 >,< 40226C 80C8CC 3F9866 7F3734 C0452E >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q15_Gain06_b0    set 0.50105056       ; 40226C
iir2_H_Parametric_f00629_q15_Gain06_b1    set -0.99387218       ; 80C8CC
iir2_H_Parametric_f00629_q15_Gain06_b2    set 0.49683832       ; 3F9866
iir2_H_Parametric_f00629_q15_Gain06_a1    set 0.99387218       ; 7F3734
iir2_H_Parametric_f00629_q15_Gain06_a2    set -0.49788888       ; C0452E

; IIR2: mode=Parametric fc=793.701 Q=15 gainDB=6 h=< 0.50132185 -0.99097358 0.49602185 0.99097358 -0.49734371 >,< 402B50 8127C7 3F7DA5 7ED839 C0570B >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q15_Gain06_b0    set 0.50132185       ; 402B50
iir2_H_Parametric_f00793_q15_Gain06_b1    set -0.99097358       ; 8127C7
iir2_H_Parametric_f00793_q15_Gain06_b2    set 0.49602185       ; 3F7DA5
iir2_H_Parametric_f00793_q15_Gain06_a1    set 0.99097358       ; 7ED839
iir2_H_Parametric_f00793_q15_Gain06_a2    set -0.49734371       ; C0570B

; IIR2: mode=Parametric fc=1000 Q=15 gainDB=6 h=< 0.50166221 -0.98656108 0.49499756 0.98656108 -0.49665976 >,< 403677 81B85E 3F5C14 7E47A2 C06D74 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q15_Gain06_b0    set 0.50166221       ; 403677
iir2_H_Parametric_f01000_q15_Gain06_b1    set -0.98656108       ; 81B85E
iir2_H_Parametric_f01000_q15_Gain06_b2    set 0.49499756       ; 3F5C14
iir2_H_Parametric_f01000_q15_Gain06_a1    set 0.98656108       ; 7E47A2
iir2_H_Parametric_f01000_q15_Gain06_a2    set -0.49665976       ; C06D74

; IIR2: mode=Parametric fc=1259.92 Q=15 gainDB=6 h=< 0.50208829 -0.97980257 0.49371526 0.97980257 -0.49580355 >,< 40446E 8295D5 3F320F 7D6A2B C08983 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q15_Gain06_b0    set 0.50208829       ; 40446E
iir2_H_Parametric_f01259_q15_Gain06_b1    set -0.97980257       ; 8295D5
iir2_H_Parametric_f01259_q15_Gain06_b2    set 0.49371526       ; 3F320F
iir2_H_Parametric_f01259_q15_Gain06_a1    set 0.97980257       ; 7D6A2B
iir2_H_Parametric_f01259_q15_Gain06_a2    set -0.49580355       ; C08983

; IIR2: mode=Parametric fc=1587.4 Q=15 gainDB=6 h=< 0.50261995 -0.96940246 0.49211520 0.96940246 -0.49473515 >,< 4055DA 83EA9F 3EFDA1 7C1561 C0AC85 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q15_Gain06_b0    set 0.50261995       ; 4055DA
iir2_H_Parametric_f01587_q15_Gain06_b1    set -0.96940246       ; 83EA9F
iir2_H_Parametric_f01587_q15_Gain06_b2    set 0.49211520       ; 3EFDA1
iir2_H_Parametric_f01587_q15_Gain06_a1    set 0.96940246       ; 7C1561
iir2_H_Parametric_f01587_q15_Gain06_a2    set -0.49473515       ; C0AC85

; IIR2: mode=Parametric fc=2000 Q=15 gainDB=6 h=< 0.50327999 -0.95334981 0.49012880 0.95334981 -0.49340879 >,< 406B7A 85F8A2 3EBC8A 7A075E C0D7FB >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q15_Gain06_b0    set 0.50327999       ; 406B7A
iir2_H_Parametric_f02000_q15_Gain06_b1    set -0.95334981       ; 85F8A2
iir2_H_Parametric_f02000_q15_Gain06_b2    set 0.49012880       ; 3EBC8A
iir2_H_Parametric_f02000_q15_Gain06_a1    set 0.95334981       ; 7A075E
iir2_H_Parametric_f02000_q15_Gain06_a2    set -0.49340879       ; C0D7FB

; IIR2: mode=Parametric fc=2519.84 Q=15 gainDB=6 h=< 0.50409284 -0.92854251 0.48768252 0.92854251 -0.49177536 >,< 40861D 892585 3E6C61 76DA7B C10D82 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q15_Gain06_b0    set 0.50409284       ; 40861D
iir2_H_Parametric_f02519_q15_Gain06_b1    set -0.92854251       ; 892585
iir2_H_Parametric_f02519_q15_Gain06_b2    set 0.48768252       ; 3E6C61
iir2_H_Parametric_f02519_q15_Gain06_a1    set 0.92854251       ; 76DA7B
iir2_H_Parametric_f02519_q15_Gain06_a2    set -0.49177536       ; C10D82

; IIR2: mode=Parametric fc=3174.8 Q=15 gainDB=6 h=< 0.50508107 -0.89024638 0.48470841 0.89024638 -0.48978948 >,< 40A67F 8E0C68 3E0AEC 71F398 C14E94 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q15_Gain06_b0    set 0.50508107       ; 40A67F
iir2_H_Parametric_f03174_q15_Gain06_b1    set -0.89024638       ; 8E0C68
iir2_H_Parametric_f03174_q15_Gain06_b2    set 0.48470841       ; 3E0AEC
iir2_H_Parametric_f03174_q15_Gain06_a1    set 0.89024638       ; 71F398
iir2_H_Parametric_f03174_q15_Gain06_a2    set -0.48978948       ; C14E94

; IIR2: mode=Parametric fc=4000 Q=15 gainDB=6 h=< 0.50625754 -0.83136582 0.48116782 0.83136582 -0.48742535 >,< 40CD0C 9595CE 3D96E8 6A6A32 C19C0C >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q15_Gain06_b0    set 0.50625754       ; 40CD0C
iir2_H_Parametric_f04000_q15_Gain06_b1    set -0.83136582       ; 9595CE
iir2_H_Parametric_f04000_q15_Gain06_b2    set 0.48116782       ; 3D96E8
iir2_H_Parametric_f04000_q15_Gain06_a1    set 0.83136582       ; 6A6A32
iir2_H_Parametric_f04000_q15_Gain06_a2    set -0.48742535       ; C19C0C

; IIR2: mode=Parametric fc=5039.68 Q=15 gainDB=6 h=< 0.50760918 -0.74158555 0.47710002 0.74158555 -0.48470920 >,< 40F956 A113BA 3D119D 5EEC46 C1F50D >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q15_Gain06_b0    set 0.50760918       ; 40F956
iir2_H_Parametric_f05039_q15_Gain06_b1    set -0.74158555       ; A113BA
iir2_H_Parametric_f05039_q15_Gain06_b2    set 0.47710002       ; 3D119D
iir2_H_Parametric_f05039_q15_Gain06_a1    set 0.74158555       ; 5EEC46
iir2_H_Parametric_f05039_q15_Gain06_a2    set -0.48470920       ; C1F50D

; IIR2: mode=Parametric fc=6349.6 Q=15 gainDB=6 h=< 0.50906619 -0.60669054 0.47271512 0.60669054 -0.48178131 >,< 412914 B257F7 3C81ED 4DA809 C254FE >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q15_Gain06_b0    set 0.50906619       ; 412914
iir2_H_Parametric_f06349_q15_Gain06_b1    set -0.60669054       ; B257F7
iir2_H_Parametric_f06349_q15_Gain06_b2    set 0.47271512       ; 3C81ED
iir2_H_Parametric_f06349_q15_Gain06_a1    set 0.60669054       ; 4DA809
iir2_H_Parametric_f06349_q15_Gain06_a2    set -0.48178131       ; C254FE

; IIR2: mode=Parametric fc=8000 Q=15 gainDB=6 h=< 0.51044726 -0.40899934 0.46855877 0.40899934 -0.47900602 >,< 415656 CBA5E9 3BF9BB 345A17 C2AFEF >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q15_Gain06_b0    set 0.51044726       ; 415656
iir2_H_Parametric_f08000_q15_Gain06_b1    set -0.40899934       ; CBA5E9
iir2_H_Parametric_f08000_q15_Gain06_b2    set 0.46855877       ; 3BF9BB
iir2_H_Parametric_f08000_q15_Gain06_a1    set 0.40899934       ; 345A17
iir2_H_Parametric_f08000_q15_Gain06_a2    set -0.47900602       ; C2AFEF

; IIR2: mode=Parametric fc=10079.4 Q=15 gainDB=6 h=< 0.51137293 -0.13125261 0.46577293 0.13125261 -0.47714586 >,< 4174AB EF331E 3B9E72 10CCE2 C2ECE3 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q15_Gain06_b0    set 0.51137293       ; 4174AB
iir2_H_Parametric_f10079_q15_Gain06_b1    set -0.13125261       ; EF331E
iir2_H_Parametric_f10079_q15_Gain06_b2    set 0.46577293       ; 3B9E72
iir2_H_Parametric_f10079_q15_Gain06_a1    set 0.13125261       ; 10CCE2
iir2_H_Parametric_f10079_q15_Gain06_a2    set -0.47714586       ; C2ECE3

; IIR2: mode=Parametric fc=12699.2 Q=15 gainDB=6 h=< 0.51115693 0.23098128 0.46642299 -0.23098128 -0.47757992 >,< 416D97 1D90CB 3BB3BF E26F35 C2DEAA >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q15_Gain06_b0    set 0.51115693       ; 416D97
iir2_H_Parametric_f12699_q15_Gain06_b1    set 0.23098128       ; 1D90CB
iir2_H_Parametric_f12699_q15_Gain06_b2    set 0.46642299       ; 3BB3BF
iir2_H_Parametric_f12699_q15_Gain06_a1    set -0.23098128       ; E26F35
iir2_H_Parametric_f12699_q15_Gain06_a2    set -0.47757992       ; C2DEAA

; IIR2: mode=Parametric fc=16000 Q=15 gainDB=6 h=< 0.50875934 0.63947863 0.47363857 -0.63947863 -0.48239792 >,< 411F06 51DA6F 3CA030 AE2591 C240C9 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q15_Gain06_b0    set 0.50875934       ; 411F06
iir2_H_Parametric_f16000_q15_Gain06_b1    set 0.63947863       ; 51DA6F
iir2_H_Parametric_f16000_q15_Gain06_b2    set 0.47363857       ; 3CA030
iir2_H_Parametric_f16000_q15_Gain06_a1    set -0.63947863       ; AE2591
iir2_H_Parametric_f16000_q15_Gain06_a2    set -0.48239792       ; C240C9

; IIR2: mode=Parametric fc=20158.7 Q=15 gainDB=6 h=< 0.50310722 0.95789627 0.49064877 -0.95789627 -0.49375599 >,< 4065D1 7A9C58 3ECD94 8563A8 C0CC9B >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q15_Gain06_b0    set 0.50310722       ; 4065D1
iir2_H_Parametric_f20158_q15_Gain06_b1    set 0.95789627       ; 7A9C58
iir2_H_Parametric_f20158_q15_Gain06_b2    set 0.49064877       ; 3ECD94
iir2_H_Parametric_f20158_q15_Gain06_a1    set -0.95789627       ; 8563A8
iir2_H_Parametric_f20158_q15_Gain06_a2    set -0.49375599       ; C0CC9B

; IIR2: mode=Parametric fc=62.5 Q=1 gainDB=12 h=< 0.50345833 -0.99764025 0.49422148 0.99764025 -0.49767981 >,< 407152 804D53 3F42A6 7FB2AD C04C08 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q01_Gain12_b0    set 0.50345833       ; 407152
iir2_H_Parametric_f00062_q01_Gain12_b1    set -0.99764025       ; 804D53
iir2_H_Parametric_f00062_q01_Gain12_b2    set 0.49422148       ; 3F42A6
iir2_H_Parametric_f00062_q01_Gain12_a1    set 0.99764025       ; 7FB2AD
iir2_H_Parametric_f00062_q01_Gain12_a2    set -0.49767981       ; C04C08

; IIR2: mode=Parametric fc=78.7451 Q=1 gainDB=12 h=< 0.50435456 -0.99701577 0.49272396 0.99701577 -0.49707853 >,< 408EB0 8061CA 3F1194 7F9E36 C05FBB >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q01_Gain12_b0    set 0.50435456       ; 408EB0
iir2_H_Parametric_f00078_q01_Gain12_b1    set -0.99701577       ; 8061CA
iir2_H_Parametric_f00078_q01_Gain12_b2    set 0.49272396       ; 3F1194
iir2_H_Parametric_f00078_q01_Gain12_a1    set 0.99701577       ; 7F9E36
iir2_H_Parametric_f00078_q01_Gain12_a2    set -0.49707853       ; C05FBB

; IIR2: mode=Parametric fc=99.2126 Q=1 gainDB=12 h=< 0.50548217 -0.99622248 0.49083984 0.99622248 -0.49632201 >,< 40B3A4 807BC8 3ED3D7 7F8438 C07886 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q01_Gain12_b0    set 0.50548217       ; 40B3A4
iir2_H_Parametric_f00099_q01_Gain12_b1    set -0.99622248       ; 807BC8
iir2_H_Parametric_f00099_q01_Gain12_b2    set 0.49083984       ; 3ED3D7
iir2_H_Parametric_f00099_q01_Gain12_a1    set 0.99622248       ; 7F8438
iir2_H_Parametric_f00099_q01_Gain12_a2    set -0.49632201       ; C07886

; IIR2: mode=Parametric fc=125 Q=1 gainDB=12 h=< 0.50690038 -0.99521269 0.48847017 0.99521269 -0.49537054 >,< 40E21C 809CDF 3E8630 7F6321 C097B3 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q01_Gain12_b0    set 0.50690038       ; 40E21C
iir2_H_Parametric_f00125_q01_Gain12_b1    set -0.99521269       ; 809CDF
iir2_H_Parametric_f00125_q01_Gain12_b2    set 0.48847017       ; 3E8630
iir2_H_Parametric_f00125_q01_Gain12_a1    set 0.99521269       ; 7F6321
iir2_H_Parametric_f00125_q01_Gain12_a2    set -0.49537054       ; C097B3

; IIR2: mode=Parametric fc=157.49 Q=1 gainDB=12 h=< 0.50868321 -0.99392417 0.48549123 0.99392417 -0.49417444 >,< 411C88 80C718 3E2493 7F38E8 C0BEE5 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q01_Gain12_b0    set 0.50868321       ; 411C88
iir2_H_Parametric_f00157_q01_Gain12_b1    set -0.99392417       ; 80C718
iir2_H_Parametric_f00157_q01_Gain12_b2    set 0.48549123       ; 3E2493
iir2_H_Parametric_f00157_q01_Gain12_a1    set 0.99392417       ; 7F38E8
iir2_H_Parametric_f00157_q01_Gain12_a2    set -0.49417444       ; C0BEE5

; IIR2: mode=Parametric fc=198.425 Q=1 gainDB=12 h=< 0.51092309 -0.99227504 0.48174862 0.99227504 -0.49267171 >,< 4165ED 80FD22 3DA9F0 7F02DE C0F023 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q01_Gain12_b0    set 0.51092309       ; 4165ED
iir2_H_Parametric_f00198_q01_Gain12_b1    set -0.99227504       ; 80FD22
iir2_H_Parametric_f00198_q01_Gain12_b2    set 0.48174862       ; 3DA9F0
iir2_H_Parametric_f00198_q01_Gain12_a1    set 0.99227504       ; 7F02DE
iir2_H_Parametric_f00198_q01_Gain12_a2    set -0.49267171       ; C0F023

; IIR2: mode=Parametric fc=250 Q=1 gainDB=12 h=< 0.51373500 -0.99015675 0.47705020 0.99015675 -0.49078520 >,< 41C211 81428B 3D0FFB 7EBD75 C12DF4 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q01_Gain12_b0    set 0.51373500       ; 41C211
iir2_H_Parametric_f00250_q01_Gain12_b1    set -0.99015675       ; 81428B
iir2_H_Parametric_f00250_q01_Gain12_b2    set 0.47705020       ; 3D0FFB
iir2_H_Parametric_f00250_q01_Gain12_a1    set 0.99015675       ; 7EBD75
iir2_H_Parametric_f00250_q01_Gain12_a2    set -0.49078520       ; C12DF4

; IIR2: mode=Parametric fc=314.98 Q=1 gainDB=12 h=< 0.51726154 -0.98742409 0.47115769 0.98742409 -0.48841924 >,< 4235A0 819C17 3C4EE5 7E63E9 C17B7B >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q01_Gain12_b0    set 0.51726154       ; 4235A0
iir2_H_Parametric_f00314_q01_Gain12_b1    set -0.98742409       ; 819C17
iir2_H_Parametric_f00314_q01_Gain12_b2    set 0.47115769       ; 3C4EE5
iir2_H_Parametric_f00314_q01_Gain12_a1    set 0.98742409       ; 7E63E9
iir2_H_Parametric_f00314_q01_Gain12_a2    set -0.48841924       ; C17B7B

; IIR2: mode=Parametric fc=396.85 Q=1 gainDB=12 h=< 0.52167870 -0.98388096 0.46377707 0.98388096 -0.48545577 >,< 42C65E 821031 3B5D0C 7DEFCF C1DC96 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q01_Gain12_b0    set 0.52167870       ; 42C65E
iir2_H_Parametric_f00396_q01_Gain12_b1    set -0.98388096       ; 821031
iir2_H_Parametric_f00396_q01_Gain12_b2    set 0.46377707       ; 3B5D0C
iir2_H_Parametric_f00396_q01_Gain12_a1    set 0.98388096       ; 7DEFCF
iir2_H_Parametric_f00396_q01_Gain12_a2    set -0.48545577       ; C1DC96

; IIR2: mode=Parametric fc=500 Q=1 gainDB=12 h=< 0.52720222 -0.97925998 0.45454781 0.97925998 -0.48175004 >,< 437B5D 82A79C 3A2E9F 7D5864 C25604 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q01_Gain12_b0    set 0.52720222       ; 437B5D
iir2_H_Parametric_f00500_q01_Gain12_b1    set -0.97925998       ; 82A79C
iir2_H_Parametric_f00500_q01_Gain12_b2    set 0.45454781       ; 3A2E9F
iir2_H_Parametric_f00500_q01_Gain12_a1    set 0.97925998       ; 7D5864
iir2_H_Parametric_f00500_q01_Gain12_a2    set -0.48175004       ; C25604

; IIR2: mode=Parametric fc=629.961 Q=1 gainDB=12 h=< 0.53409428 -0.97319303 0.44303187 0.97319303 -0.47712616 >,< 445D33 836E69 38B544 7C9197 C2ED88 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q01_Gain12_b0    set 0.53409428       ; 445D33
iir2_H_Parametric_f00629_q01_Gain12_b1    set -0.97319303       ; 836E69
iir2_H_Parametric_f00629_q01_Gain12_b2    set 0.44303187       ; 38B544
iir2_H_Parametric_f00629_q01_Gain12_a1    set 0.97319303       ; 7C9197
iir2_H_Parametric_f00629_q01_Gain12_a2    set -0.47712616       ; C2ED88

; IIR2: mode=Parametric fc=793.701 Q=1 gainDB=12 h=< 0.54266950 -0.96516880 0.42870354 0.96516880 -0.47137305 >,< 457631 84755A 36DFC2 7B8AA6 C3AA0D >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q01_Gain12_b0    set 0.54266950       ; 457631
iir2_H_Parametric_f00793_q01_Gain12_b1    set -0.96516880       ; 84755A
iir2_H_Parametric_f00793_q01_Gain12_b2    set 0.42870354       ; 36DFC2
iir2_H_Parametric_f00793_q01_Gain12_a1    set 0.96516880       ; 7B8AA6
iir2_H_Parametric_f00793_q01_Gain12_a2    set -0.47137305       ; C3AA0D

; IIR2: mode=Parametric fc=1000 Q=1 gainDB=12 h=< 0.55329869 -0.95447172 0.41094323 0.95447172 -0.46424192 >,< 46D27E 85D3DF 3499C9 7A2C21 C493B9 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q01_Gain12_b0    set 0.55329869       ; 46D27E
iir2_H_Parametric_f01000_q01_Gain12_b1    set -0.95447172       ; 85D3DF
iir2_H_Parametric_f01000_q01_Gain12_b2    set 0.41094323       ; 3499C9
iir2_H_Parametric_f01000_q01_Gain12_a1    set 0.95447172       ; 7A2C21
iir2_H_Parametric_f01000_q01_Gain12_a2    set -0.46424192       ; C493B9

; IIR2: mode=Parametric fc=1259.92 Q=1 gainDB=12 h=< 0.56640733 -0.94009483 0.38904001 0.94009483 -0.45544734 >,< 488009 87AAF9 31CC10 785507 C5B3E7 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q01_Gain12_b0    set 0.56640733       ; 488009
iir2_H_Parametric_f01259_q01_Gain12_b1    set -0.94009483       ; 87AAF9
iir2_H_Parametric_f01259_q01_Gain12_b2    set 0.38904001       ; 31CC10
iir2_H_Parametric_f01259_q01_Gain12_a1    set 0.94009483       ; 785507
iir2_H_Parametric_f01259_q01_Gain12_a2    set -0.45544734       ; C5B3E7

; IIR2: mode=Parametric fc=1587.4 Q=1 gainDB=12 h=< 0.58246342 -0.92061749 0.36221191 0.92061749 -0.44467532 >,< 4A8E29 8A2935 2E5CF5 75D6CB C714E1 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q01_Gain12_b0    set 0.58246342       ; 4A8E29
iir2_H_Parametric_f01587_q01_Gain12_b1    set -0.92061749       ; 8A2935
iir2_H_Parametric_f01587_q01_Gain12_b2    set 0.36221191       ; 2E5CF5
iir2_H_Parametric_f01587_q01_Gain12_a1    set 0.92061749       ; 75D6CB
iir2_H_Parametric_f01587_q01_Gain12_a2    set -0.44467532       ; C714E1

; IIR2: mode=Parametric fc=2000 Q=1 gainDB=12 h=< 0.60194578 -0.89403787 0.32965884 0.89403787 -0.43160461 >,< 4D0C8F 8D902B 2A3242 726FD5 C8C12E >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q01_Gain12_b0    set 0.60194578       ; 4D0C8F
iir2_H_Parametric_f02000_q01_Gain12_b1    set -0.89403787       ; 8D902B
iir2_H_Parametric_f02000_q01_Gain12_b2    set 0.32965884       ; 2A3242
iir2_H_Parametric_f02000_q01_Gain12_a1    set 0.89403787       ; 726FD5
iir2_H_Parametric_f02000_q01_Gain12_a2    set -0.43160461       ; C8C12E

; IIR2: mode=Parametric fc=2519.84 Q=1 gainDB=12 h=< 0.62527843 -0.85755226 0.29067231 0.85755226 -0.41595074 >,< 50091F 923BBA 2534C0 6DC446 CAC221 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q01_Gain12_b0    set 0.62527843       ; 50091F
iir2_H_Parametric_f02519_q01_Gain12_b1    set -0.85755226       ; 923BBA
iir2_H_Parametric_f02519_q01_Gain12_b2    set 0.29067231       ; 2534C0
iir2_H_Parametric_f02519_q01_Gain12_a1    set 0.85755226       ; 6DC446
iir2_H_Parametric_f02519_q01_Gain12_a2    set -0.41595074       ; CAC221

; IIR2: mode=Parametric fc=3174.8 Q=1 gainDB=12 h=< 0.65270845 -0.80728158 0.24483951 0.80728158 -0.39754795 >,< 538BF3 98AAFF 1F56E6 675501 CD1D26 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q01_Gain12_b0    set 0.65270845       ; 538BF3
iir2_H_Parametric_f03174_q01_Gain12_b1    set -0.80728158       ; 98AAFF
iir2_H_Parametric_f03174_q01_Gain12_b2    set 0.24483951       ; 1F56E6
iir2_H_Parametric_f03174_q01_Gain12_a1    set 0.80728158       ; 675501
iir2_H_Parametric_f03174_q01_Gain12_a2    set -0.39754795       ; CD1D26

; IIR2: mode=Parametric fc=4000 Q=1 gainDB=12 h=< 0.68409397 -0.73796465 0.19239746 0.73796465 -0.37649142 >,< 579064 A18A60 18A07A 5E75A0 CFCF21 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q01_Gain12_b0    set 0.68409397       ; 579064
iir2_H_Parametric_f04000_q01_Gain12_b1    set -0.73796465       ; A18A60
iir2_H_Parametric_f04000_q01_Gain12_b2    set 0.19239746       ; 18A07A
iir2_H_Parametric_f04000_q01_Gain12_a1    set 0.73796465       ; 5E75A0
iir2_H_Parametric_f04000_q01_Gain12_a2    set -0.37649142       ; CFCF21

; IIR2: mode=Parametric fc=5039.68 Q=1 gainDB=12 h=< 0.71855503 -0.64267499 0.13481647 0.64267499 -0.35337150 >,< 5BF99C ADBCD4 1141AA 52432C D2C4B9 >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q01_Gain12_b0    set 0.71855503       ; 5BF99C
iir2_H_Parametric_f05039_q01_Gain12_b1    set -0.64267499       ; ADBCD4
iir2_H_Parametric_f05039_q01_Gain12_b2    set 0.13481647       ; 1141AA
iir2_H_Parametric_f05039_q01_Gain12_a1    set 0.64267499       ; 52432C
iir2_H_Parametric_f05039_q01_Gain12_a2    set -0.35337150       ; D2C4B9

; IIR2: mode=Parametric fc=6349.6 Q=1 gainDB=12 h=< 0.75391915 -0.51267855 0.07572658 0.51267855 -0.32964573 >,< 60806C BE608D 09B168 419F73 D5CE2C >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q01_Gain12_b0    set 0.75391915       ; 60806C
iir2_H_Parametric_f06349_q01_Gain12_b1    set -0.51267855       ; BE608D
iir2_H_Parametric_f06349_q01_Gain12_b2    set 0.07572658       ; 09B168
iir2_H_Parametric_f06349_q01_Gain12_a1    set 0.51267855       ; 419F73
iir2_H_Parametric_f06349_q01_Gain12_a2    set -0.32964573       ; D5CE2C

; IIR2: mode=Parametric fc=8000 Q=1 gainDB=12 h=< 0.78585157 -0.33765101 0.02237070 0.33765101 -0.30822228 >,< 6496C9 D4C7DA 02DD0B 2B3826 D88C2D >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q01_Gain12_b0    set 0.78585157       ; 6496C9
iir2_H_Parametric_f08000_q01_Gain12_b1    set -0.33765101       ; D4C7DA
iir2_H_Parametric_f08000_q01_Gain12_b2    set 0.02237070       ; 02DD0B
iir2_H_Parametric_f08000_q01_Gain12_a1    set 0.33765101       ; 2B3826
iir2_H_Parametric_f08000_q01_Gain12_a2    set -0.30822228       ; D88C2D

; IIR2: mode=Parametric fc=10079.4 Q=1 gainDB=12 h=< 0.80644275 -0.10670677 -0.01203509 0.10670677 -0.29440766 >,< 673984 F2576F FE75A3 0DA891 DA50DA >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q01_Gain12_b0    set 0.80644275       ; 673984
iir2_H_Parametric_f10079_q01_Gain12_b1    set -0.10670677       ; F2576F
iir2_H_Parametric_f10079_q01_Gain12_b2    set -0.01203509       ; FE75A3
iir2_H_Parametric_f10079_q01_Gain12_a1    set 0.10670677       ; 0DA891
iir2_H_Parametric_f10079_q01_Gain12_a2    set -0.29440766       ; DA50DA

; IIR2: mode=Parametric fc=12699.2 Q=1 gainDB=12 h=< 0.80169412 0.18845433 -0.00410061 -0.18845433 -0.29759351 >,< 669DE9 181F45 FF79A2 E7E0BB D9E875 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q01_Gain12_b0    set 0.80169412       ; 669DE9
iir2_H_Parametric_f12699_q01_Gain12_b1    set 0.18845433       ; 181F45
iir2_H_Parametric_f12699_q01_Gain12_b2    set -0.00410061       ; FF79A2
iir2_H_Parametric_f12699_q01_Gain12_a1    set -0.18845433       ; E7E0BB
iir2_H_Parametric_f12699_q01_Gain12_a2    set -0.29759351       ; D9E875

; IIR2: mode=Parametric fc=16000 Q=1 gainDB=12 h=< 0.74661872 0.54323486 0.08792487 -0.54323486 -0.33454359 >,< 5F9133 4588B8 0B411F BA7748 D52DAD >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q01_Gain12_b0    set 0.74661872       ; 5F9133
iir2_H_Parametric_f16000_q01_Gain12_b1    set 0.54323486       ; 4588B8
iir2_H_Parametric_f16000_q01_Gain12_b2    set 0.08792487       ; 0B411F
iir2_H_Parametric_f16000_q01_Gain12_a1    set -0.54323486       ; BA7748
iir2_H_Parametric_f16000_q01_Gain12_a2    set -0.33454359       ; D52DAD

; IIR2: mode=Parametric fc=20158.7 Q=1 gainDB=12 h=< 0.59689324 0.90125505 0.33810112 -0.90125505 -0.43499436 >,< 4C66FF 735C53 2B46E5 8CA3AD C8521B >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q01_Gain12_b0    set 0.59689324       ; 4C66FF
iir2_H_Parametric_f20158_q01_Gain12_b1    set 0.90125505       ; 735C53
iir2_H_Parametric_f20158_q01_Gain12_b2    set 0.33810112       ; 2B46E5
iir2_H_Parametric_f20158_q01_Gain12_a1    set -0.90125505       ; 8CA3AD
iir2_H_Parametric_f20158_q01_Gain12_a2    set -0.43499436       ; C8521B

; IIR2: mode=Parametric fc=62.5 Q=6 gainDB=12 h=< 0.50055478 -0.99958817 0.49907303 0.99958817 -0.49962780 >,< 40122E 800D7F 3FE1A0 7FF281 C00C33 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q06_Gain12_b0    set 0.50055478       ; 40122E
iir2_H_Parametric_f00062_q06_Gain12_b1    set -0.99958817       ; 800D7F
iir2_H_Parametric_f00062_q06_Gain12_b2    set 0.49907303       ; 3FE1A0
iir2_H_Parametric_f00062_q06_Gain12_a1    set 0.99958817       ; 7FF281
iir2_H_Parametric_f00062_q06_Gain12_a2    set -0.49962780       ; C00C33

; IIR2: mode=Parametric fc=78.7451 Q=6 gainDB=12 h=< 0.50069890 -0.99946820 0.49883221 0.99946820 -0.49953111 >,< 4016E7 80116D 3FD9BB 7FEE93 C00F5E >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q06_Gain12_b0    set 0.50069890       ; 4016E7
iir2_H_Parametric_f00078_q06_Gain12_b1    set -0.99946820       ; 80116D
iir2_H_Parametric_f00078_q06_Gain12_b2    set 0.49883221       ; 3FD9BB
iir2_H_Parametric_f00078_q06_Gain12_a1    set 0.99946820       ; 7FEE93
iir2_H_Parametric_f00078_q06_Gain12_a2    set -0.49953111       ; C00F5E

; IIR2: mode=Parametric fc=99.2126 Q=6 gainDB=12 h=< 0.50088044 -0.99930947 0.49852887 0.99930947 -0.49940931 >,< 401CD9 8016A1 3FCFCB 7FE95F C0135B >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q06_Gain12_b0    set 0.50088044       ; 401CD9
iir2_H_Parametric_f00099_q06_Gain12_b1    set -0.99930947       ; 8016A1
iir2_H_Parametric_f00099_q06_Gain12_b2    set 0.49852887       ; 3FCFCB
iir2_H_Parametric_f00099_q06_Gain12_a1    set 0.99930947       ; 7FE95F
iir2_H_Parametric_f00099_q06_Gain12_a2    set -0.49940931       ; C0135B

; IIR2: mode=Parametric fc=125 Q=6 gainDB=12 h=< 0.50110910 -0.99909744 0.49814681 0.99909744 -0.49925591 >,< 402458 801D93 3FC346 7FE26D C01862 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q06_Gain12_b0    set 0.50110910       ; 402458
iir2_H_Parametric_f00125_q06_Gain12_b1    set -0.99909744       ; 801D93
iir2_H_Parametric_f00125_q06_Gain12_b2    set 0.49814681       ; 3FC346
iir2_H_Parametric_f00125_q06_Gain12_a1    set 0.99909744       ; 7FE26D
iir2_H_Parametric_f00125_q06_Gain12_a2    set -0.49925591       ; C01862

; IIR2: mode=Parametric fc=157.49 Q=6 gainDB=12 h=< 0.50139706 -0.99881122 0.49766566 0.99881122 -0.49906271 >,< 402DC7 8026F4 3FB382 7FD90C C01EB7 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q06_Gain12_b0    set 0.50139706       ; 402DC7
iir2_H_Parametric_f00157_q06_Gain12_b1    set -0.99881122       ; 8026F4
iir2_H_Parametric_f00157_q06_Gain12_b2    set 0.49766566       ; 3FB382
iir2_H_Parametric_f00157_q06_Gain12_a1    set 0.99881122       ; 7FD90C
iir2_H_Parametric_f00157_q06_Gain12_a2    set -0.49906271       ; C01EB7

; IIR2: mode=Parametric fc=198.425 Q=6 gainDB=12 h=< 0.50175967 -0.99842032 0.49705977 0.99842032 -0.49881944 >,< 4039A9 8033C4 3F9FA7 7FCC3C C026B0 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q06_Gain12_b0    set 0.50175967       ; 4039A9
iir2_H_Parametric_f00198_q06_Gain12_b1    set -0.99842032       ; 8033C4
iir2_H_Parametric_f00198_q06_Gain12_b2    set 0.49705977       ; 3F9FA7
iir2_H_Parametric_f00198_q06_Gain12_a1    set 0.99842032       ; 7FCC3C
iir2_H_Parametric_f00198_q06_Gain12_a2    set -0.49881944       ; C026B0

; IIR2: mode=Parametric fc=250 Q=6 gainDB=12 h=< 0.50221619 -0.99787981 0.49629697 0.99787981 -0.49851316 >,< 40489E 80457A 3F86A8 7FBA86 C030B9 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q06_Gain12_b0    set 0.50221619       ; 40489E
iir2_H_Parametric_f00250_q06_Gain12_b1    set -0.99787981       ; 80457A
iir2_H_Parametric_f00250_q06_Gain12_b2    set 0.49629697       ; 3F86A8
iir2_H_Parametric_f00250_q06_Gain12_a1    set 0.99787981       ; 7FBA86
iir2_H_Parametric_f00250_q06_Gain12_a2    set -0.49851316       ; C030B9

; IIR2: mode=Parametric fc=314.98 Q=6 gainDB=12 h=< 0.50279080 -0.99712273 0.49533685 0.99712273 -0.49812765 >,< 405B73 805E49 3F6732 7FA1B7 C03D5B >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q06_Gain12_b0    set 0.50279080       ; 405B73
iir2_H_Parametric_f00314_q06_Gain12_b1    set -0.99712273       ; 805E49
iir2_H_Parametric_f00314_q06_Gain12_b2    set 0.49533685       ; 3F6732
iir2_H_Parametric_f00314_q06_Gain12_a1    set 0.99712273       ; 7FA1B7
iir2_H_Parametric_f00314_q06_Gain12_a2    set -0.49812765       ; C03D5B

; IIR2: mode=Parametric fc=396.85 Q=6 gainDB=12 h=< 0.50351379 -0.99604832 0.49412882 0.99604832 -0.49764260 >,< 407324 80817D 3F3F9D 7F7E83 C04D40 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q06_Gain12_b0    set 0.50351379       ; 407324
iir2_H_Parametric_f00396_q06_Gain12_b1    set -0.99604832       ; 80817D
iir2_H_Parametric_f00396_q06_Gain12_b2    set 0.49412882       ; 3F3F9D
iir2_H_Parametric_f00396_q06_Gain12_a1    set 0.99604832       ; 7F7E83
iir2_H_Parametric_f00396_q06_Gain12_a2    set -0.49764260       ; C04D40

; IIR2: mode=Parametric fc=500 Q=6 gainDB=12 h=< 0.50442300 -0.99450379 0.49260961 0.99450379 -0.49703261 >,< 4090EF 80B41A 3F0DD5 7F4BE6 C0613D >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q06_Gain12_b0    set 0.50442300       ; 4090EF
iir2_H_Parametric_f00500_q06_Gain12_b1    set -0.99450379       ; 80B41A
iir2_H_Parametric_f00500_q06_Gain12_b2    set 0.49260961       ; 3F0DD5
iir2_H_Parametric_f00500_q06_Gain12_a1    set 0.99450379       ; 7F4BE6
iir2_H_Parametric_f00500_q06_Gain12_a2    set -0.49703261       ; C0613D

; IIR2: mode=Parametric fc=629.961 Q=6 gainDB=12 h=< 0.50556558 -0.99225588 0.49070047 0.99225588 -0.49626605 >,< 40B65F 80FDC3 3ECF46 7F023D C07A5B >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q06_Gain12_b0    set 0.50556558       ; 40B65F
iir2_H_Parametric_f00629_q06_Gain12_b1    set -0.99225588       ; 80FDC3
iir2_H_Parametric_f00629_q06_Gain12_b2    set 0.49070047       ; 3ECF46
iir2_H_Parametric_f00629_q06_Gain12_a1    set 0.99225588       ; 7F023D
iir2_H_Parametric_f00629_q06_Gain12_a2    set -0.49626605       ; C07A5B

; IIR2: mode=Parametric fc=793.701 Q=6 gainDB=12 h=< 0.50699989 -0.98894668 0.48830388 0.98894668 -0.49530378 >,< 40E55F 816A32 3E80BD 7E95CE C099E3 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q06_Gain12_b0    set 0.50699989       ; 40E55F
iir2_H_Parametric_f00793_q06_Gain12_b1    set -0.98894668       ; 816A32
iir2_H_Parametric_f00793_q06_Gain12_b2    set 0.48830388       ; 3E80BD
iir2_H_Parametric_f00793_q06_Gain12_a1    set 0.98894668       ; 7E95CE
iir2_H_Parametric_f00793_q06_Gain12_a2    set -0.49530378       ; C099E3

; IIR2: mode=Parametric fc=1000 Q=6 gainDB=12 h=< 0.50879759 -0.98402498 0.48530011 0.98402498 -0.49409770 >,< 412047 820B78 3E1E50 7DF488 C0C168 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q06_Gain12_b0    set 0.50879759       ; 412047
iir2_H_Parametric_f01000_q06_Gain12_b1    set -0.98402498       ; 820B78
iir2_H_Parametric_f01000_q06_Gain12_b2    set 0.48530011       ; 3E1E50
iir2_H_Parametric_f01000_q06_Gain12_a1    set 0.98402498       ; 7DF488
iir2_H_Parametric_f01000_q06_Gain12_a2    set -0.49409770       ; C0C168

; IIR2: mode=Parametric fc=1259.92 Q=6 gainDB=12 h=< 0.51104544 -0.97664029 0.48154417 0.97664029 -0.49258962 >,< 4169F0 82FD74 3DA33D 7D028C C0F2D3 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q06_Gain12_b0    set 0.51104544       ; 4169F0
iir2_H_Parametric_f01259_q06_Gain12_b1    set -0.97664029       ; 82FD74
iir2_H_Parametric_f01259_q06_Gain12_b2    set 0.48154417       ; 3DA33D
iir2_H_Parametric_f01259_q06_Gain12_a1    set 0.97664029       ; 7D028C
iir2_H_Parametric_f01259_q06_Gain12_a2    set -0.49258962       ; C0F2D3

; IIR2: mode=Parametric fc=1587.4 Q=6 gainDB=12 h=< 0.51384617 -0.96548041 0.47686444 0.96548041 -0.49071061 >,< 41C5B6 846B24 3D09E4 7B94DC C13065 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q06_Gain12_b0    set 0.51384617       ; 41C5B6
iir2_H_Parametric_f01587_q06_Gain12_b1    set -0.96548041       ; 846B24
iir2_H_Parametric_f01587_q06_Gain12_b2    set 0.47686444       ; 3D09E4
iir2_H_Parametric_f01587_q06_Gain12_a1    set 0.96548041       ; 7B94DC
iir2_H_Parametric_f01587_q06_Gain12_a2    set -0.49071061       ; C13065

; IIR2: mode=Parametric fc=2000 Q=6 gainDB=12 h=< 0.51731676 -0.94852590 0.47106543 0.94852590 -0.48838219 >,< 42376F 8696B4 3C4BDF 79694C C17CB2 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q06_Gain12_b0    set 0.51731676       ; 42376F
iir2_H_Parametric_f02000_q06_Gain12_b1    set -0.94852590       ; 8696B4
iir2_H_Parametric_f02000_q06_Gain12_b2    set 0.47106543       ; 3C4BDF
iir2_H_Parametric_f02000_q06_Gain12_a1    set 0.94852590       ; 79694C
iir2_H_Parametric_f02000_q06_Gain12_a2    set -0.48838219       ; C17CB2

; IIR2: mode=Parametric fc=2519.84 Q=6 gainDB=12 h=< 0.52158114 -0.92268712 0.46394009 0.92268712 -0.48552122 >,< 42C32B 89E564 3B6263 761A9C C1DA71 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q06_Gain12_b0    set 0.52158114       ; 42C32B
iir2_H_Parametric_f02519_q06_Gain12_b1    set -0.92268712       ; 89E564
iir2_H_Parametric_f02519_q06_Gain12_b2    set 0.46394009       ; 3B6263
iir2_H_Parametric_f02519_q06_Gain12_a1    set 0.92268712       ; 761A9C
iir2_H_Parametric_f02519_q06_Gain12_a2    set -0.48552122       ; C1DA71

; IIR2: mode=Parametric fc=3174.8 Q=6 gainDB=12 h=< 0.52675126 -0.88328759 0.45530133 0.88328759 -0.48205259 >,< 436C96 8EF06F 3A4750 710F91 C24C1A >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q06_Gain12_b0    set 0.52675126       ; 436C96
iir2_H_Parametric_f03174_q06_Gain12_b1    set -0.88328759       ; 8EF06F
iir2_H_Parametric_f03174_q06_Gain12_b2    set 0.45530133       ; 3A4750
iir2_H_Parametric_f03174_q06_Gain12_a1    set 0.88328759       ; 710F91
iir2_H_Parametric_f03174_q06_Gain12_a2    set -0.48205259       ; C24C1A

; IIR2: mode=Parametric fc=4000 Q=6 gainDB=12 h=< 0.53288569 -0.82337708 0.44505132 0.82337708 -0.47793700 >,< 443599 969B95 38F771 69646B C2D2F6 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q06_Gain12_b0    set 0.53288569       ; 443599
iir2_H_Parametric_f04000_q06_Gain12_b1    set -0.82337708       ; 969B95
iir2_H_Parametric_f04000_q06_Gain12_b2    set 0.44505132       ; 38F771
iir2_H_Parametric_f04000_q06_Gain12_a1    set 0.82337708       ; 69646B
iir2_H_Parametric_f04000_q06_Gain12_a2    set -0.47793700       ; C2D2F6

; IIR2: mode=Parametric fc=5039.68 Q=6 gainDB=12 h=< 0.53990625 -0.73293823 0.43332066 0.73293823 -0.47322691 >,< 451BA6 A22F15 37770D 5DD0EB C36D4D >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q06_Gain12_b0    set 0.53990625       ; 451BA6
iir2_H_Parametric_f05039_q06_Gain12_b1    set -0.73293823       ; A22F15
iir2_H_Parametric_f05039_q06_Gain12_b2    set 0.43332066       ; 37770D
iir2_H_Parametric_f05039_q06_Gain12_a1    set 0.73293823       ; 5DD0EB
iir2_H_Parametric_f05039_q06_Gain12_a2    set -0.47322691       ; C36D4D

; IIR2: mode=Parametric fc=6349.6 Q=6 gainDB=12 h=< 0.54744158 -0.59828035 0.42072987 0.59828035 -0.46817146 >,< 461291 B36B8D 35DA7A 4C9473 C412F6 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q06_Gain12_b0    set 0.54744158       ; 461291
iir2_H_Parametric_f06349_q06_Gain12_b1    set -0.59828035       ; B36B8D
iir2_H_Parametric_f06349_q06_Gain12_b2    set 0.42072987       ; 35DA7A
iir2_H_Parametric_f06349_q06_Gain12_a1    set 0.59828035       ; 4C9473
iir2_H_Parametric_f06349_q06_Gain12_a2    set -0.46817146       ; C412F6

; IIR2: mode=Parametric fc=8000 Q=6 gainDB=12 h=< 0.55455325 -0.40247971 0.40884699 0.40247971 -0.46340024 >,< 46FB9A CC7B8C 345519 338474 C4AF4D >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q06_Gain12_b0    set 0.55455325       ; 46FB9A
iir2_H_Parametric_f08000_q06_Gain12_b1    set -0.40247971       ; CC7B8C
iir2_H_Parametric_f08000_q06_Gain12_b2    set 0.40884699       ; 345519
iir2_H_Parametric_f08000_q06_Gain12_a1    set 0.40247971       ; 338474
iir2_H_Parametric_f08000_q06_Gain12_a2    set -0.46340024       ; C4AF4D

; IIR2: mode=Parametric fc=10079.4 Q=6 gainDB=12 h=< 0.55930317 -0.12897822 0.40091036 0.12897822 -0.46021353 >,< 47973F EF7DA5 335107 10825B C517BA >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q06_Gain12_b0    set 0.55930317       ; 47973F
iir2_H_Parametric_f10079_q06_Gain12_b1    set -0.12897822       ; EF7DA5
iir2_H_Parametric_f10079_q06_Gain12_b2    set 0.40091036       ; 335107
iir2_H_Parametric_f10079_q06_Gain12_a1    set 0.12897822       ; 10825B
iir2_H_Parametric_f10079_q06_Gain12_a2    set -0.46021353       ; C517BA

; IIR2: mode=Parametric fc=12699.2 Q=6 gainDB=12 h=< 0.55819598 0.22705348 0.40276035 -0.22705348 -0.46095633 >,< 4772F7 1D1016 338DA6 E2EFEA C4FF62 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q06_Gain12_b0    set 0.55819598       ; 4772F7
iir2_H_Parametric_f12699_q06_Gain12_b1    set 0.22705348       ; 1D1016
iir2_H_Parametric_f12699_q06_Gain12_b2    set 0.40276035       ; 338DA6
iir2_H_Parametric_f12699_q06_Gain12_a1    set -0.22705348       ; E2EFEA
iir2_H_Parametric_f12699_q06_Gain12_a2    set -0.46095633       ; C4FF62

; IIR2: mode=Parametric fc=16000 Q=6 gainDB=12 h=< 0.54585745 0.63090992 0.42337680 -0.63090992 -0.46923425 >,< 45DEA8 50C1A8 363136 AF3E58 C3F022 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q06_Gain12_b0    set 0.54585745       ; 45DEA8
iir2_H_Parametric_f16000_q06_Gain12_b1    set 0.63090992       ; 50C1A8
iir2_H_Parametric_f16000_q06_Gain12_b2    set 0.42337680       ; 363136
iir2_H_Parametric_f16000_q06_Gain12_a1    set -0.63090992       ; AF3E58
iir2_H_Parametric_f16000_q06_Gain12_a2    set -0.46923425       ; C3F022

; IIR2: mode=Parametric fc=20158.7 Q=6 gainDB=12 h=< 0.51640896 0.95330345 0.47258227 -0.95330345 -0.48899123 >,< 4219B0 7A05D9 3C7D93 85FA27 C168BD >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q06_Gain12_b0    set 0.51640896       ; 4219B0
iir2_H_Parametric_f20158_q06_Gain12_b1    set 0.95330345       ; 7A05D9
iir2_H_Parametric_f20158_q06_Gain12_b2    set 0.47258227       ; 3C7D93
iir2_H_Parametric_f20158_q06_Gain12_a1    set -0.95330345       ; 85FA27
iir2_H_Parametric_f20158_q06_Gain12_a2    set -0.48899123       ; C168BD

; IIR2: mode=Parametric fc=62.5 Q=15 gainDB=12 h=< 0.50022174 -0.99981159 0.49962949 0.99981159 -0.49985123 >,< 400744 80062D 3FF3DC 7FF9D3 C004E0 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q15_Gain12_b0    set 0.50022174       ; 400744
iir2_H_Parametric_f00062_q15_Gain12_b1    set -0.99981159       ; 80062D
iir2_H_Parametric_f00062_q15_Gain12_b2    set 0.49962949       ; 3FF3DC
iir2_H_Parametric_f00062_q15_Gain12_a1    set 0.99981159       ; 7FF9D3
iir2_H_Parametric_f00062_q15_Gain12_a2    set -0.49985123       ; C004E0

; IIR2: mode=Parametric fc=78.7451 Q=15 gainDB=12 h=< 0.50027937 -0.99974965 0.49953321 0.99974965 -0.49981257 >,< 400927 800834 3FF0B4 7FF7CC C00625 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q15_Gain12_b0    set 0.50027937       ; 400927
iir2_H_Parametric_f00078_q15_Gain12_b1    set -0.99974965       ; 800834
iir2_H_Parametric_f00078_q15_Gain12_b2    set 0.49953321       ; 3FF0B4
iir2_H_Parametric_f00078_q15_Gain12_a1    set 0.99974965       ; 7FF7CC
iir2_H_Parametric_f00078_q15_Gain12_a2    set -0.49981257       ; C00625

; IIR2: mode=Parametric fc=99.2126 Q=15 gainDB=12 h=< 0.50035196 -0.99966399 0.49941191 0.99966399 -0.49976387 >,< 400B88 800B03 3FECBA 7FF4FD C007BD >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q15_Gain12_b0    set 0.50035196       ; 400B88
iir2_H_Parametric_f00099_q15_Gain12_b1    set -0.99966399       ; 800B03
iir2_H_Parametric_f00099_q15_Gain12_b2    set 0.49941191       ; 3FECBA
iir2_H_Parametric_f00099_q15_Gain12_a1    set 0.99966399       ; 7FF4FD
iir2_H_Parametric_f00099_q15_Gain12_a2    set -0.49976387       ; C007BD

; IIR2: mode=Parametric fc=125 Q=15 gainDB=12 h=< 0.50044341 -0.99954398 0.49925911 0.99954398 -0.49970252 >,< 400E87 800EF2 3FE7B9 7FF10E C009C0 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q15_Gain12_b0    set 0.50044341       ; 400E87
iir2_H_Parametric_f00125_q15_Gain12_b1    set -0.99954398       ; 800EF2
iir2_H_Parametric_f00125_q15_Gain12_b2    set 0.49925911       ; 3FE7B9
iir2_H_Parametric_f00125_q15_Gain12_a1    set 0.99954398       ; 7FF10E
iir2_H_Parametric_f00125_q15_Gain12_a2    set -0.49970252       ; C009C0

; IIR2: mode=Parametric fc=157.49 Q=15 gainDB=12 h=< 0.50055859 -0.99937360 0.49906664 0.99937360 -0.49962524 >,< 40124E 801487 3FE16A 7FEB79 C00C48 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q15_Gain12_b0    set 0.50055859       ; 40124E
iir2_H_Parametric_f00157_q15_Gain12_b1    set -0.99937360       ; 801487
iir2_H_Parametric_f00157_q15_Gain12_b2    set 0.49906664       ; 3FE16A
iir2_H_Parametric_f00157_q15_Gain12_a1    set 0.99937360       ; 7FEB79
iir2_H_Parametric_f00157_q15_Gain12_a2    set -0.49962524       ; C00C48

; IIR2: mode=Parametric fc=198.425 Q=15 gainDB=12 h=< 0.50070368 -0.99912850 0.49882422 0.99912850 -0.49952790 >,< 40170F 801C8F 3FD978 7FE371 C00F79 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q15_Gain12_b0    set 0.50070368       ; 40170F
iir2_H_Parametric_f00198_q15_Gain12_b1    set -0.99912850       ; 801C8F
iir2_H_Parametric_f00198_q15_Gain12_b2    set 0.49882422       ; 3FD978
iir2_H_Parametric_f00198_q15_Gain12_a1    set 0.99912850       ; 7FE371
iir2_H_Parametric_f00198_q15_Gain12_a2    set -0.49952790       ; C00F79

; IIR2: mode=Parametric fc=250 Q=15 gainDB=12 h=< 0.50088641 -0.99877140 0.49851890 0.99877140 -0.49940531 >,< 401D0B 802842 3FCF77 7FD7BE C0137D >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q15_Gain12_b0    set 0.50088641       ; 401D0B
iir2_H_Parametric_f00250_q15_Gain12_b1    set -0.99877140       ; 802842
iir2_H_Parametric_f00250_q15_Gain12_b2    set 0.49851890       ; 3FCF77
iir2_H_Parametric_f00250_q15_Gain12_a1    set 0.99877140       ; 7FD7BE
iir2_H_Parametric_f00250_q15_Gain12_a2    set -0.49940531       ; C0137D

; IIR2: mode=Parametric fc=314.98 Q=15 gainDB=12 h=< 0.50111649 -0.99824489 0.49813446 0.99824489 -0.49925095 >,< 402496 803983 3FC2DE 7FC67D C0188C >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q15_Gain12_b0    set 0.50111649       ; 402496
iir2_H_Parametric_f00314_q15_Gain12_b1    set -0.99824489       ; 803983
iir2_H_Parametric_f00314_q15_Gain12_b2    set 0.49813446       ; 3FC2DE
iir2_H_Parametric_f00314_q15_Gain12_a1    set 0.99824489       ; 7FC67D
iir2_H_Parametric_f00314_q15_Gain12_a2    set -0.49925095       ; C0188C

; IIR2: mode=Parametric fc=396.85 Q=15 gainDB=12 h=< 0.50140614 -0.99746008 0.49765048 0.99746008 -0.49905662 >,< 402E13 80533B 3FB302 7FACC5 C01EEA >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q15_Gain12_b0    set 0.50140614       ; 402E13
iir2_H_Parametric_f00396_q15_Gain12_b1    set -0.99746008       ; 80533B
iir2_H_Parametric_f00396_q15_Gain12_b2    set 0.49765048       ; 3FB302
iir2_H_Parametric_f00396_q15_Gain12_a1    set 0.99746008       ; 7FACC5
iir2_H_Parametric_f00396_q15_Gain12_a2    set -0.49905662       ; C01EEA

; IIR2: mode=Parametric fc=500 Q=15 gainDB=12 h=< 0.50177064 -0.99627875 0.49704145 0.99627875 -0.49881208 >,< 403A05 8079F0 3F9F0D 7F8610 C026ED >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q15_Gain12_b0    set 0.50177064       ; 403A05
iir2_H_Parametric_f00500_q15_Gain12_b1    set -0.99627875       ; 8079F0
iir2_H_Parametric_f00500_q15_Gain12_b2    set 0.49704145       ; 3F9F0D
iir2_H_Parametric_f00500_q15_Gain12_a1    set 0.99627875       ; 7F8610
iir2_H_Parametric_f00500_q15_Gain12_a2    set -0.49881208       ; C026ED

; IIR2: mode=Parametric fc=629.961 Q=15 gainDB=12 h=< 0.50222907 -0.99448534 0.49627545 0.99448534 -0.49850452 >,< 40490B 80B4B5 3F85F4 7F4B4B C03101 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q15_Gain12_b0    set 0.50222907       ; 40490B
iir2_H_Parametric_f00629_q15_Gain12_b1    set -0.99448534       ; 80B4B5
iir2_H_Parametric_f00629_q15_Gain12_b2    set 0.49627545       ; 3F85F4
iir2_H_Parametric_f00629_q15_Gain12_a1    set 0.99448534       ; 7F4B4B
iir2_H_Parametric_f00629_q15_Gain12_a2    set -0.49850452       ; C03101

; IIR2: mode=Parametric fc=793.701 Q=15 gainDB=12 h=< 0.50280515 -0.99174296 0.49531288 0.99174296 -0.49811803 >,< 405BEB 810E91 3F6669 7EF16F C03DAB >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q15_Gain12_b0    set 0.50280515       ; 405BEB
iir2_H_Parametric_f00793_q15_Gain12_b1    set -0.99174296       ; 810E91
iir2_H_Parametric_f00793_q15_Gain12_b2    set 0.49531288       ; 3F6669
iir2_H_Parametric_f00793_q15_Gain12_a1    set 0.99174296       ; 7EF16F
iir2_H_Parametric_f00793_q15_Gain12_a2    set -0.49811803       ; C03DAB

; IIR2: mode=Parametric fc=1000 Q=15 gainDB=12 h=< 0.50352812 -0.98752444 0.49410487 0.98752444 -0.49763299 >,< 40739C 8198CD 3F3ED4 7E6733 C04D90 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q15_Gain12_b0    set 0.50352812       ; 40739C
iir2_H_Parametric_f01000_q15_Gain12_b1    set -0.98752444       ; 8198CD
iir2_H_Parametric_f01000_q15_Gain12_b2    set 0.49410487       ; 3F3ED4
iir2_H_Parametric_f01000_q15_Gain12_a1    set 0.98752444       ; 7E6733
iir2_H_Parametric_f01000_q15_Gain12_a2    set -0.49763299       ; C04D90

; IIR2: mode=Parametric fc=1259.92 Q=15 gainDB=12 h=< 0.50443361 -0.98100488 0.49259188 0.98100488 -0.49702549 >,< 409148 826E6F 3F0D40 7D9191 C06178 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q15_Gain12_b0    set 0.50443361       ; 409148
iir2_H_Parametric_f01259_q15_Gain12_b1    set -0.98100488       ; 826E6F
iir2_H_Parametric_f01259_q15_Gain12_b2    set 0.49259188       ; 3F0D40
iir2_H_Parametric_f01259_q15_Gain12_a1    set 0.98100488       ; 7D9191
iir2_H_Parametric_f01259_q15_Gain12_a2    set -0.49702549       ; C06178

; IIR2: mode=Parametric fc=1587.4 Q=15 gainDB=12 h=< 0.50556412 -0.97089533 0.49070291 0.97089533 -0.49626703 >,< 40B653 83B9B4 3ECF5A 7C464C C07A53 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q15_Gain12_b0    set 0.50556412       ; 40B653
iir2_H_Parametric_f01587_q15_Gain12_b1    set -0.97089533       ; 83B9B4
iir2_H_Parametric_f01587_q15_Gain12_b2    set 0.49070291       ; 3ECF5A
iir2_H_Parametric_f01587_q15_Gain12_a1    set 0.97089533       ; 7C464C
iir2_H_Parametric_f01587_q15_Gain12_a2    set -0.49626703       ; C07A53

; IIR2: mode=Parametric fc=2000 Q=15 gainDB=12 h=< 0.50696858 -0.95518854 0.48835620 0.95518854 -0.49532478 >,< 40E458 85BC62 3E8274 7A439E C09933 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q15_Gain12_b0    set 0.50696858       ; 40E458
iir2_H_Parametric_f02000_q15_Gain12_b1    set -0.95518854       ; 85BC62
iir2_H_Parametric_f02000_q15_Gain12_b2    set 0.48835620       ; 3E8274
iir2_H_Parametric_f02000_q15_Gain12_a1    set 0.95518854       ; 7A439E
iir2_H_Parametric_f02000_q15_Gain12_a2    set -0.49532478       ; C09933

; IIR2: mode=Parametric fc=2519.84 Q=15 gainDB=12 h=< 0.50869969 -0.93077828 0.48546368 0.93077828 -0.49416338 >,< 411D12 88DC42 3E23AC 7723BE C0BF42 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q15_Gain12_b0    set 0.50869969       ; 411D12
iir2_H_Parametric_f02519_q15_Gain12_b1    set -0.93077828       ; 88DC42
iir2_H_Parametric_f02519_q15_Gain12_b2    set 0.48546368       ; 3E23AC
iir2_H_Parametric_f02519_q15_Gain12_a1    set 0.93077828       ; 7723BE
iir2_H_Parametric_f02519_q15_Gain12_a2    set -0.49416338       ; C0BF42

; IIR2: mode=Parametric fc=3174.8 Q=15 gainDB=12 h=< 0.51080655 -0.89290906 0.48194333 0.89290906 -0.49274989 >,< 41621C 8DB528 3DB051 724AD8 C0ED93 >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q15_Gain12_b0    set 0.51080655       ; 41621C
iir2_H_Parametric_f03174_q15_Gain12_b1    set -0.89290906       ; 8DB528
iir2_H_Parametric_f03174_q15_Gain12_b2    set 0.48194333       ; 3DB051
iir2_H_Parametric_f03174_q15_Gain12_a1    set 0.89290906       ; 724AD8
iir2_H_Parametric_f03174_q15_Gain12_a2    set -0.49274989       ; C0ED93

; IIR2: mode=Parametric fc=4000 Q=15 gainDB=12 h=< 0.51331791 -0.83443025 0.47774711 0.83443025 -0.49106502 >,< 41B466 953164 3D26D1 6ACE9C C124C8 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q15_Gain12_b0    set 0.51331791       ; 41B466
iir2_H_Parametric_f04000_q15_Gain12_b1    set -0.83443025       ; 953164
iir2_H_Parametric_f04000_q15_Gain12_b2    set 0.47774711       ; 3D26D1
iir2_H_Parametric_f04000_q15_Gain12_a1    set 0.83443025       ; 6ACE9C
iir2_H_Parametric_f04000_q15_Gain12_a2    set -0.49106502       ; C124C8

; IIR2: mode=Parametric fc=5039.68 Q=15 gainDB=12 h=< 0.51620752 -0.74491214 0.47291887 0.74491214 -0.48912638 >,< 421316 A0A6B8 3C889B 5F5948 C1644F >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q15_Gain12_b0    set 0.51620752       ; 421316
iir2_H_Parametric_f05039_q15_Gain12_b1    set -0.74491214       ; A0A6B8
iir2_H_Parametric_f05039_q15_Gain12_b2    set 0.47291887       ; 3C889B
iir2_H_Parametric_f05039_q15_Gain12_a1    set 0.74491214       ; 5F5948
iir2_H_Parametric_f05039_q15_Gain12_a2    set -0.48912638       ; C1644F

; IIR2: mode=Parametric fc=6349.6 Q=15 gainDB=12 h=< 0.51932754 -0.60993592 0.46770562 0.60993592 -0.48703316 >,< 427953 B1ED9F 3BDDC7 4E1261 C1A8E6 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q15_Gain12_b0    set 0.51932754       ; 427953
iir2_H_Parametric_f06349_q15_Gain12_b1    set -0.60993592       ; B1ED9F
iir2_H_Parametric_f06349_q15_Gain12_b2    set 0.46770562       ; 3BDDC7
iir2_H_Parametric_f06349_q15_Gain12_a1    set 0.60993592       ; 4E1261
iir2_H_Parametric_f06349_q15_Gain12_a2    set -0.48703316       ; C1A8E6

; IIR2: mode=Parametric fc=8000 Q=15 gainDB=12 h=< 0.52228990 -0.41152254 0.46275581 0.41152254 -0.48504571 >,< 42DA65 CB533B 3B3B95 34ACC5 C1EA06 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q15_Gain12_b0    set 0.52228990       ; 42DA65
iir2_H_Parametric_f08000_q15_Gain12_b1    set -0.41152254       ; CB533B
iir2_H_Parametric_f08000_q15_Gain12_b2    set 0.46275581       ; 3B3B95
iir2_H_Parametric_f08000_q15_Gain12_a1    set 0.41152254       ; 34ACC5
iir2_H_Parametric_f08000_q15_Gain12_a2    set -0.48504571       ; C1EA06

; IIR2: mode=Parametric fc=10079.4 Q=15 gainDB=12 h=< 0.52427816 -0.13213457 0.45943363 0.13213457 -0.48371179 >,< 431B8C EF1637 3ACEB8 10E9C9 C215BC >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q15_Gain12_b0    set 0.52427816       ; 431B8C
iir2_H_Parametric_f10079_q15_Gain12_b1    set -0.13213457       ; EF1637
iir2_H_Parametric_f10079_q15_Gain12_b2    set 0.45943363       ; 3ACEB8
iir2_H_Parametric_f10079_q15_Gain12_a1    set 0.13213457       ; 10E9C9
iir2_H_Parametric_f10079_q15_Gain12_a2    set -0.48371179       ; C215BC

; IIR2: mode=Parametric fc=12699.2 Q=15 gainDB=12 h=< 0.52381401 0.23250368 0.46020917 -0.23250368 -0.48402319 >,< 430C56 1DC2AE 3AE822 E23D52 C20B88 >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q15_Gain12_b0    set 0.52381401       ; 430C56
iir2_H_Parametric_f12699_q15_Gain12_b1    set 0.23250368       ; 1DC2AE
iir2_H_Parametric_f12699_q15_Gain12_b2    set 0.46020917       ; 3AE822
iir2_H_Parametric_f12699_q15_Gain12_a1    set -0.23250368       ; E23D52
iir2_H_Parametric_f12699_q15_Gain12_a2    set -0.48402319       ; C20B88

; IIR2: mode=Parametric fc=16000 Q=15 gainDB=12 h=< 0.51867002 0.64278303 0.46880427 -0.64278303 -0.48747429 >,< 4263C7 5246B7 3C01C7 ADB949 C19A72 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q15_Gain12_b0    set 0.51867002       ; 4263C7
iir2_H_Parametric_f16000_q15_Gain12_b1    set 0.64278303       ; 5246B7
iir2_H_Parametric_f16000_q15_Gain12_b2    set 0.46880427       ; 3C01C7
iir2_H_Parametric_f16000_q15_Gain12_a1    set -0.64278303       ; ADB949
iir2_H_Parametric_f16000_q15_Gain12_a2    set -0.48747429       ; C19A72

; IIR2: mode=Parametric fc=20158.7 Q=15 gainDB=12 h=< 0.50660084 0.95964627 0.48897067 -0.95964627 -0.49557150 >,< 40D84C 7AD5B0 3E9697 852A50 C0911D >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q15_Gain12_b0    set 0.50660084       ; 40D84C
iir2_H_Parametric_f20158_q15_Gain12_b1    set 0.95964627       ; 7AD5B0
iir2_H_Parametric_f20158_q15_Gain12_b2    set 0.48897067       ; 3E9697
iir2_H_Parametric_f20158_q15_Gain12_a1    set -0.95964627       ; 852A50
iir2_H_Parametric_f20158_q15_Gain12_a2    set -0.49557150       ; C0911D

; IIR2: mode=Parametric fc=62.5 Q=1 gainDB=18 h=< 0.50570628 -0.99831673 0.49265004 0.99831673 -0.49835632 >,< 40BAFC 803729 3F0F28 7FC8D7 C035DD >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q01_Gain18_b0    set 0.50570628       ; 40BAFC
iir2_H_Parametric_f00062_q01_Gain18_b1    set -0.99831673       ; 803729
iir2_H_Parametric_f00062_q01_Gain18_b2    set 0.49265004       ; 3F0F28
iir2_H_Parametric_f00062_q01_Gain18_a1    set 0.99831673       ; 7FC8D7
iir2_H_Parametric_f00062_q01_Gain18_a2    set -0.49835632       ; C035DD

; IIR2: mode=Parametric fc=78.7451 Q=1 gainDB=18 h=< 0.50718634 -0.99786718 0.49074365 0.99786718 -0.49792999 >,< 40EB7B 8045E4 3ED0B0 7FBA1C C043D5 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q01_Gain18_b0    set 0.50718634       ; 40EB7B
iir2_H_Parametric_f00078_q01_Gain18_b1    set -0.99786718       ; 8045E4
iir2_H_Parametric_f00078_q01_Gain18_b2    set 0.49074365       ; 3ED0B0
iir2_H_Parametric_f00078_q01_Gain18_a1    set 0.99786718       ; 7FBA1C
iir2_H_Parametric_f00078_q01_Gain18_a2    set -0.49792999       ; C043D5

; IIR2: mode=Parametric fc=99.2126 Q=1 gainDB=18 h=< 0.50904924 -0.99729374 0.48834415 0.99729374 -0.49739338 >,< 412886 8058AE 3E820F 7FA752 C0556A >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q01_Gain18_b0    set 0.50904924       ; 412886
iir2_H_Parametric_f00099_q01_Gain18_b1    set -0.99729374       ; 8058AE
iir2_H_Parametric_f00099_q01_Gain18_b2    set 0.48834415       ; 3E820F
iir2_H_Parametric_f00099_q01_Gain18_a1    set 0.99729374       ; 7FA752
iir2_H_Parametric_f00099_q01_Gain18_a2    set -0.49739338       ; C0556A

; IIR2: mode=Parametric fc=125 Q=1 gainDB=18 h=< 0.51139338 -0.99656009 0.48532477 0.99656009 -0.49671816 >,< 417556 8070B8 3E1F1F 7F8F48 C06B8A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q01_Gain18_b0    set 0.51139338       ; 417556
iir2_H_Parametric_f00125_q01_Gain18_b1    set -0.99656009       ; 8070B8
iir2_H_Parametric_f00125_q01_Gain18_b2    set 0.48532477       ; 3E1F1F
iir2_H_Parametric_f00125_q01_Gain18_a1    set 0.99656009       ; 7F8F48
iir2_H_Parametric_f00125_q01_Gain18_a2    set -0.49671816       ; C06B8A

; IIR2: mode=Parametric fc=157.49 Q=1 gainDB=18 h=< 0.51434208 -0.99561809 0.48152670 0.99561809 -0.49586879 >,< 41D5F6 808F96 3DA2AA 7F706A C0875F >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q01_Gain18_b0    set 0.51434208       ; 41D5F6
iir2_H_Parametric_f00157_q01_Gain18_b1    set -0.99561809       ; 808F96
iir2_H_Parametric_f00157_q01_Gain18_b2    set 0.48152670       ; 3DA2AA
iir2_H_Parametric_f00157_q01_Gain18_a1    set 0.99561809       ; 7F706A
iir2_H_Parametric_f00157_q01_Gain18_a2    set -0.49586879       ; C0875F

; IIR2: mode=Parametric fc=198.425 Q=1 gainDB=18 h=< 0.51804963 -0.99440332 0.47675121 0.99440332 -0.49480084 >,< 424F73 80B765 3D062F 7F489B C0AA5E >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q01_Gain18_b0    set 0.51804963       ; 424F73
iir2_H_Parametric_f00198_q01_Gain18_b1    set -0.99440332       ; 80B765
iir2_H_Parametric_f00198_q01_Gain18_b2    set 0.47675121       ; 3D062F
iir2_H_Parametric_f00198_q01_Gain18_a1    set 0.99440332       ; 7F489B
iir2_H_Parametric_f00198_q01_Gain18_a2    set -0.49480084       ; C0AA5E

; IIR2: mode=Parametric fc=250 Q=1 gainDB=18 h=< 0.52270865 -0.99282868 0.47075016 0.99282868 -0.49345881 >,< 42E81E 80EAFE 3C418A 7F1502 C0D658 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q01_Gain18_b0    set 0.52270865       ; 42E81E
iir2_H_Parametric_f00250_q01_Gain18_b1    set -0.99282868       ; 80EAFE
iir2_H_Parametric_f00250_q01_Gain18_b2    set 0.47075016       ; 3C418A
iir2_H_Parametric_f00250_q01_Gain18_a1    set 0.99282868       ; 7F1502
iir2_H_Parametric_f00250_q01_Gain18_a2    set -0.49345881       ; C0D658

; IIR2: mode=Parametric fc=314.98 Q=1 gainDB=18 h=< 0.52855903 -0.99077510 0.46321460 0.99077510 -0.49177362 >,< 43A7D2 812E48 3B4A9D 7ED1B8 C10D90 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q01_Gain18_b0    set 0.52855903       ; 43A7D2
iir2_H_Parametric_f00314_q01_Gain18_b1    set -0.99077510       ; 812E48
iir2_H_Parametric_f00314_q01_Gain18_b2    set 0.46321460       ; 3B4A9D
iir2_H_Parametric_f00314_q01_Gain18_a1    set 0.99077510       ; 7ED1B8
iir2_H_Parametric_f00314_q01_Gain18_a2    set -0.49177362       ; C10D90

; IIR2: mode=Parametric fc=396.85 Q=1 gainDB=18 h=< 0.53589834 -0.98807802 0.45376121 0.98807802 -0.48965955 >,< 449851 8186A9 3A14D9 7E7957 C152D6 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q01_Gain18_b0    set 0.53589834       ; 449851
iir2_H_Parametric_f00396_q01_Gain18_b1    set -0.98807802       ; 8186A9
iir2_H_Parametric_f00396_q01_Gain18_b2    set 0.45376121       ; 3A14D9
iir2_H_Parametric_f00396_q01_Gain18_a1    set 0.98807802       ; 7E7957
iir2_H_Parametric_f00396_q01_Gain18_a2    set -0.48965955       ; C152D6

; IIR2: mode=Parametric fc=500 Q=1 gainDB=18 h=< 0.54509390 -0.98450738 0.44191689 0.98450738 -0.48701078 >,< 45C5A3 81FBAA 3890BB 7E0456 C1A9A2 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q01_Gain18_b0    set 0.54509390       ; 45C5A3
iir2_H_Parametric_f00500_q01_Gain18_b1    set -0.98450738       ; 81FBAA
iir2_H_Parametric_f00500_q01_Gain18_b2    set 0.44191689       ; 3890BB
iir2_H_Parametric_f00500_q01_Gain18_a1    set 0.98450738       ; 7E0456
iir2_H_Parametric_f00500_q01_Gain18_a2    set -0.48701078       ; C1A9A2

; IIR2: mode=Parametric fc=629.961 Q=1 gainDB=18 h=< 0.55659590 -0.97973807 0.42710175 0.97973807 -0.48369765 >,< 473E89 8297F2 36AB45 7D680E C21632 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q01_Gain18_b0    set 0.55659590       ; 473E89
iir2_H_Parametric_f00629_q01_Gain18_b1    set -0.97973807       ; 8297F2
iir2_H_Parametric_f00629_q01_Gain18_b2    set 0.42710175       ; 36AB45
iir2_H_Parametric_f00629_q01_Gain18_a1    set 0.97973807       ; 7D680E
iir2_H_Parametric_f00629_q01_Gain18_a2    set -0.48369765       ; C21632

; IIR2: mode=Parametric fc=793.701 Q=1 gainDB=18 h=< 0.57095062 -0.97330624 0.40861218 0.97330624 -0.47956280 >,< 4914E9 836AB4 344D67 7C954C C29DB0 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q01_Gain18_b0    set 0.57095062       ; 4914E9
iir2_H_Parametric_f00793_q01_Gain18_b1    set -0.97330624       ; 836AB4
iir2_H_Parametric_f00793_q01_Gain18_b2    set 0.40861218       ; 344D67
iir2_H_Parametric_f00793_q01_Gain18_a1    set 0.97330624       ; 7C954C
iir2_H_Parametric_f00793_q01_Gain18_a2    set -0.47956280       ; C29DB0

; IIR2: mode=Parametric fc=1000 Q=1 gainDB=18 h=< 0.58881131 -0.96454474 0.38560675 0.96454474 -0.47441806 >,< 4B5E2B 8489CC 315B8F 7B7634 C34645 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q01_Gain18_b0    set 0.58881131       ; 4B5E2B
iir2_H_Parametric_f01000_q01_Gain18_b1    set -0.96454474       ; 8489CC
iir2_H_Parametric_f01000_q01_Gain18_b2    set 0.38560675       ; 315B8F
iir2_H_Parametric_f01000_q01_Gain18_a1    set 0.96454474       ; 7B7634
iir2_H_Parametric_f01000_q01_Gain18_a2    set -0.47441806       ; C34645

; IIR2: mode=Parametric fc=1259.92 Q=1 gainDB=18 h=< 0.61094213 -0.95248841 0.35710119 0.95248841 -0.46804332 >,< 4E335A 8614DC 2DB57E 79EB24 C41728 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q01_Gain18_b0    set 0.61094213       ; 4E335A
iir2_H_Parametric_f01259_q01_Gain18_b1    set -0.95248841       ; 8614DC
iir2_H_Parametric_f01259_q01_Gain18_b2    set 0.35710119       ; 2DB57E
iir2_H_Parametric_f01259_q01_Gain18_a1    set 0.95248841       ; 79EB24
iir2_H_Parametric_f01259_q01_Gain18_a2    set -0.46804332       ; C41728

; IIR2: mode=Parametric fc=1587.4 Q=1 gainDB=18 h=< 0.63820644 -0.93573695 0.32198344 0.93573695 -0.46018988 >,< 51B0BF 8839C6 2936C1 77C63A C51880 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q01_Gain18_b0    set 0.63820644       ; 51B0BF
iir2_H_Parametric_f01587_q01_Gain18_b1    set -0.93573695       ; 8839C6
iir2_H_Parametric_f01587_q01_Gain18_b2    set 0.32198344       ; 2936C1
iir2_H_Parametric_f01587_q01_Gain18_a1    set 0.93573695       ; 77C63A
iir2_H_Parametric_f01587_q01_Gain18_a2    set -0.46018988       ; C51880

; IIR2: mode=Parametric fc=2000 Q=1 gainDB=18 h=< 0.67152386 -0.91226042 0.27906899 0.91226042 -0.45059286 >,< 55F47E 8B3B0D 23B888 74C4F3 C652FA >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q01_Gain18_b0    set 0.67152386       ; 55F47E
iir2_H_Parametric_f02000_q01_Gain18_b1    set -0.91226042       ; 8B3B0D
iir2_H_Parametric_f02000_q01_Gain18_b2    set 0.27906899       ; 23B888
iir2_H_Parametric_f02000_q01_Gain18_a1    set 0.91226042       ; 74C4F3
iir2_H_Parametric_f02000_q01_Gain18_a2    set -0.45059286       ; C652FA

; IIR2: mode=Parametric fc=2519.84 Q=1 gainDB=18 h=< 0.71176898 -0.87913227 0.22723135 0.87913227 -0.43900033 >,< 5B1B3F 8F7898 1D15EA 708768 C7CED7 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q01_Gain18_b0    set 0.71176898       ; 5B1B3F
iir2_H_Parametric_f02519_q01_Gain18_b1    set -0.87913227       ; 8F7898
iir2_H_Parametric_f02519_q01_Gain18_b2    set 0.22723135       ; 1D15EA
iir2_H_Parametric_f02519_q01_Gain18_a1    set 0.87913227       ; 708768
iir2_H_Parametric_f02519_q01_Gain18_a2    set -0.43900033       ; C7CED7

; IIR2: mode=Parametric fc=3174.8 Q=1 gainDB=18 h=< 0.75956648 -0.83218175 0.16566586 0.83218175 -0.42523234 >,< 613979 957B12 15348A 6A84EE C991FD >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q01_Gain18_b0    set 0.75956648       ; 613979
iir2_H_Parametric_f03174_q01_Gain18_b1    set -0.83218175       ; 957B12
iir2_H_Parametric_f03174_q01_Gain18_b2    set 0.16566586       ; 15348A
iir2_H_Parametric_f03174_q01_Gain18_a1    set 0.83218175       ; 6A84EE
iir2_H_Parametric_f03174_q01_Gain18_a2    set -0.42523234       ; C991FD

; IIR2: mode=Parametric fc=4000 Q=1 gainDB=18 h=< 0.81491040 -0.76558005 0.09438023 0.76558005 -0.40929063 >,< 684EFC 9E0179 0C14A6 61FE87 CB9C5E >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q01_Gain18_b0    set 0.81491040       ; 684EFC
iir2_H_Parametric_f04000_q01_Gain18_b1    set -0.76558005       ; 9E0179
iir2_H_Parametric_f04000_q01_Gain18_b2    set 0.09438023       ; 0C14A6
iir2_H_Parametric_f04000_q01_Gain18_a1    set 0.76558005       ; 61FE87
iir2_H_Parametric_f04000_q01_Gain18_a2    set -0.40929063       ; CB9C5E

; IIR2: mode=Parametric fc=5039.68 Q=1 gainDB=18 h=< 0.87649670 -0.67142786 0.01505411 0.67142786 -0.39155080 >,< 70310B AA0EA7 01ED4B 55F159 CDE1AA >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q01_Gain18_b0    set 0.87649670       ; 70310B
iir2_H_Parametric_f05039_q01_Gain18_b1    set -0.67142786       ; AA0EA7
iir2_H_Parametric_f05039_q01_Gain18_b2    set 0.01505411       ; 01ED4B
iir2_H_Parametric_f05039_q01_Gain18_a1    set 0.67142786       ; 55F159
iir2_H_Parametric_f05039_q01_Gain18_a2    set -0.39155080       ; CDE1AA

; IIR2: mode=Parametric fc=6349.6 Q=1 gainDB=18 h=< 0.94060681 -0.53952117 -0.06752281 0.53952117 -0.37308400 >,< 7865CE BAF0F9 F75B6A 450F07 D03EC9 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q01_Gain18_b0    set 0.94060681       ; 7865CE
iir2_H_Parametric_f06349_q01_Gain18_b1    set -0.53952117       ; BAF0F9
iir2_H_Parametric_f06349_q01_Gain18_b2    set -0.06752281       ; F75B6A
iir2_H_Parametric_f06349_q01_Gain18_a1    set 0.53952117       ; 450F07
iir2_H_Parametric_f06349_q01_Gain18_a2    set -0.37308400       ; D03EC9

; IIR2: mode=Parametric fc=8000 Q=1 gainDB=18 h=< 0.99930437 -0.35768475 -0.14312809 0.35768475 -0.35617628 >,< 7FE934 D23763 EDADFB 2DC89D D268D1 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q01_Gain18_b0    set 0.99930437       ; 7FE934
iir2_H_Parametric_f08000_q01_Gain18_b1    set -0.35768475       ; D23763
iir2_H_Parametric_f08000_q01_Gain18_b2    set -0.14312809       ; EDADFB
iir2_H_Parametric_f08000_q01_Gain18_a1    set 0.35768475       ; 2DC89D
iir2_H_Parametric_f08000_q01_Gain18_a2    set -0.35617628       ; D268D1

; IIR2: mode=Parametric fc=10079.4 Q=1 gainDB=18 h=< 1.03756908 -0.11352317 -0.19241489 0.11352317 -0.34515419 >,< 800000 F17813 E75EF3 0E87ED D3D1FD >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q01_Gain18_b0    set 1.03756908       ; 800000
iir2_H_Parametric_f10079_q01_Gain18_b1    set -0.11352317       ; F17813
iir2_H_Parametric_f10079_q01_Gain18_b2    set -0.19241489       ; E75EF3
iir2_H_Parametric_f10079_q01_Gain18_a1    set 0.11352317       ; 0E87ED
iir2_H_Parametric_f10079_q01_Gain18_a2    set -0.34515419       ; D3D1FD

; IIR2: mode=Parametric fc=12699.2 Q=1 gainDB=18 h=< 1.02871556 0.20029447 -0.18101113 -0.20029447 -0.34770443 >,< 800000 19A33F E8D4A1 E65CC1 D37E6C >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q01_Gain18_b0    set 1.02871556       ; 800000
iir2_H_Parametric_f12699_q01_Gain18_b1    set 0.20029447       ; 19A33F
iir2_H_Parametric_f12699_q01_Gain18_b2    set -0.18101113       ; E8D4A1
iir2_H_Parametric_f12699_q01_Gain18_a1    set -0.20029447       ; E65CC1
iir2_H_Parametric_f12699_q01_Gain18_a2    set -0.34770443       ; D37E6C

; IIR2: mode=Parametric fc=16000 Q=1 gainDB=18 h=< 0.92729569 0.57081807 -0.05037745 -0.57081807 -0.37691824 >,< 76B1A0 491091 F98D3C B6EF6F CFC125 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q01_Gain18_b0    set 0.92729569       ; 76B1A0
iir2_H_Parametric_f16000_q01_Gain18_b1    set 0.57081807       ; 491091
iir2_H_Parametric_f16000_q01_Gain18_b2    set -0.05037745       ; F98D3C
iir2_H_Parametric_f16000_q01_Gain18_a1    set -0.57081807       ; B6EF6F
iir2_H_Parametric_f16000_q01_Gain18_a2    set -0.37691824       ; CFC125

; IIR2: mode=Parametric fc=20158.7 Q=1 gainDB=18 h=< 0.66285846 0.91869667 0.29023046 -0.91869667 -0.45308891 >,< 54D88C 7597DA 252645 8A6826 C6012F >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q01_Gain18_b0    set 0.66285846       ; 54D88C
iir2_H_Parametric_f20158_q01_Gain18_b1    set 0.91869667       ; 7597DA
iir2_H_Parametric_f20158_q01_Gain18_b2    set 0.29023046       ; 252645
iir2_H_Parametric_f20158_q01_Gain18_a1    set -0.91869667       ; 8A6826
iir2_H_Parametric_f20158_q01_Gain18_a2    set -0.45308891       ; C6012F

; IIR2: mode=Parametric fc=62.5 Q=6 gainDB=18 h=< 0.50091487 -0.99969684 0.49882161 0.99969684 -0.49973647 >,< 401DFA 8009EF 3FD963 7FF611 C008A3 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q06_Gain18_b0    set 0.50091487       ; 401DFA
iir2_H_Parametric_f00062_q06_Gain18_b1    set -0.99969684       ; 8009EF
iir2_H_Parametric_f00062_q06_Gain18_b2    set 0.49882161       ; 3FD963
iir2_H_Parametric_f00062_q06_Gain18_a1    set 0.99969684       ; 7FF611
iir2_H_Parametric_f00062_q06_Gain18_a2    set -0.49973647       ; C008A3

; IIR2: mode=Parametric fc=78.7451 Q=6 gainDB=18 h=< 0.50115257 -0.99960509 0.49851543 0.99960509 -0.49966800 >,< 4025C4 800CF1 3FCF5A 7FF30F C00AE1 >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q06_Gain18_b0    set 0.50115257       ; 4025C4
iir2_H_Parametric_f00078_q06_Gain18_b1    set -0.99960509       ; 800CF1
iir2_H_Parametric_f00078_q06_Gain18_b2    set 0.49851543       ; 3FCF5A
iir2_H_Parametric_f00078_q06_Gain18_a1    set 0.99960509       ; 7FF30F
iir2_H_Parametric_f00078_q06_Gain18_a2    set -0.49966800       ; C00AE1

; IIR2: mode=Parametric fc=99.2126 Q=6 gainDB=18 h=< 0.50145200 -0.99948189 0.49812975 0.99948189 -0.49958175 >,< 402F94 8010FA 3FC2B7 7FEF06 C00DB5 >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q06_Gain18_b0    set 0.50145200       ; 402F94
iir2_H_Parametric_f00099_q06_Gain18_b1    set -0.99948189       ; 8010FA
iir2_H_Parametric_f00099_q06_Gain18_b2    set 0.49812975       ; 3FC2B7
iir2_H_Parametric_f00099_q06_Gain18_a1    set 0.99948189       ; 7FEF06
iir2_H_Parametric_f00099_q06_Gain18_a2    set -0.49958175       ; C00DB5

; IIR2: mode=Parametric fc=125 Q=6 gainDB=18 h=< 0.50182918 -0.99931461 0.49764393 0.99931461 -0.49947311 >,< 403BF0 801676 3FB2CC 7FE98A C01144 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q06_Gain18_b0    set 0.50182918       ; 403BF0
iir2_H_Parametric_f00125_q06_Gain18_b1    set -0.99931461       ; 801676
iir2_H_Parametric_f00125_q06_Gain18_b2    set 0.49764393       ; 3FB2CC
iir2_H_Parametric_f00125_q06_Gain18_a1    set 0.99931461       ; 7FE98A
iir2_H_Parametric_f00125_q06_Gain18_a2    set -0.49947311       ; C01144

; IIR2: mode=Parametric fc=157.49 Q=6 gainDB=18 h=< 0.50230423 -0.99908470 0.49703204 0.99908470 -0.49933627 >,< 404B81 801DFE 3F9EBF 7FE202 C015C0 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q06_Gain18_b0    set 0.50230423       ; 404B81
iir2_H_Parametric_f00157_q06_Gain18_b1    set -0.99908470       ; 801DFE
iir2_H_Parametric_f00157_q06_Gain18_b2    set 0.49703204       ; 3F9EBF
iir2_H_Parametric_f00157_q06_Gain18_a1    set 0.99908470       ; 7FE202
iir2_H_Parametric_f00157_q06_Gain18_a2    set -0.49933627       ; C015C0

; IIR2: mode=Parametric fc=198.425 Q=6 gainDB=18 h=< 0.50290251 -0.99876468 0.49626143 0.99876468 -0.49916394 >,< 405F1C 80287B 3F857E 7FD785 C01B66 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q06_Gain18_b0    set 0.50290251       ; 405F1C
iir2_H_Parametric_f00198_q06_Gain18_b1    set -0.99876468       ; 80287B
iir2_H_Parametric_f00198_q06_Gain18_b2    set 0.49626143       ; 3F857E
iir2_H_Parametric_f00198_q06_Gain18_a1    set 0.99876468       ; 7FD785
iir2_H_Parametric_f00198_q06_Gain18_a2    set -0.49916394       ; C01B66

; IIR2: mode=Parametric fc=250 Q=6 gainDB=18 h=< 0.50365585 -0.99831332 0.49529109 0.99831332 -0.49894694 >,< 4077CB 803745 3F65B2 7FC8BB C02282 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q06_Gain18_b0    set 0.50365585       ; 4077CB
iir2_H_Parametric_f00250_q06_Gain18_b1    set -0.99831332       ; 803745
iir2_H_Parametric_f00250_q06_Gain18_b2    set 0.49529109       ; 3F65B2
iir2_H_Parametric_f00250_q06_Gain18_a1    set 0.99831332       ; 7FC8BB
iir2_H_Parametric_f00250_q06_Gain18_a2    set -0.49894694       ; C02282

; IIR2: mode=Parametric fc=314.98 Q=6 gainDB=18 h=< 0.50460425 -0.99766828 0.49406951 0.99766828 -0.49867375 >,< 4096DF 804C68 3F3DAB 7FB398 C02B76 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q06_Gain18_b0    set 0.50460425       ; 4096DF
iir2_H_Parametric_f00314_q06_Gain18_b1    set -0.99766828       ; 804C68
iir2_H_Parametric_f00314_q06_Gain18_b2    set 0.49406951       ; 3F3DAB
iir2_H_Parametric_f00314_q06_Gain18_a1    set 0.99766828       ; 7FB398
iir2_H_Parametric_f00314_q06_Gain18_a2    set -0.49867375       ; C02B76

; IIR2: mode=Parametric fc=396.85 Q=6 gainDB=18 h=< 0.50579785 -0.99673456 0.49253209 0.99673456 -0.49832994 >,< 40BDFC 806B01 3F0B4A 7F94FF C036BA >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q06_Gain18_b0    set 0.50579785       ; 40BDFC
iir2_H_Parametric_f00396_q06_Gain18_b1    set -0.99673456       ; 806B01
iir2_H_Parametric_f00396_q06_Gain18_b2    set 0.49253209       ; 3F0B4A
iir2_H_Parametric_f00396_q06_Gain18_a1    set 0.99673456       ; 7F94FF
iir2_H_Parametric_f00396_q06_Gain18_a2    set -0.49832994       ; C036BA

; IIR2: mode=Parametric fc=500 Q=6 gainDB=18 h=< 0.50729938 -0.99536641 0.49059805 0.99536641 -0.49789743 >,< 40EF2F 8097D6 3ECBEA 7F682A C044E6 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q06_Gain18_b0    set 0.50729938       ; 40EF2F
iir2_H_Parametric_f00500_q06_Gain18_b1    set -0.99536641       ; 8097D6
iir2_H_Parametric_f00500_q06_Gain18_b2    set 0.49059805       ; 3ECBEA
iir2_H_Parametric_f00500_q06_Gain18_a1    set 0.99536641       ; 7F682A
iir2_H_Parametric_f00500_q06_Gain18_a2    set -0.49789743       ; C044E6

; IIR2: mode=Parametric fc=629.961 Q=6 gainDB=18 h=< 0.50918706 -0.99333913 0.48816662 0.99333913 -0.49735368 >,< 412D0A 80DA44 3E7C3E 7F25BC C056B7 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q06_Gain18_b0    set 0.50918706       ; 412D0A
iir2_H_Parametric_f00629_q06_Gain18_b1    set -0.99333913       ; 80DA44
iir2_H_Parametric_f00629_q06_Gain18_b2    set 0.48816662       ; 3E7C3E
iir2_H_Parametric_f00629_q06_Gain18_a1    set 0.99333913       ; 7F25BC
iir2_H_Parametric_f00629_q06_Gain18_a2    set -0.49735368       ; C056B7

; IIR2: mode=Parametric fc=793.701 Q=6 gainDB=18 h=< 0.51155792 -0.99030494 0.48511284 0.99030494 -0.49667076 >,< 417ABB 813DB0 3E182D 7EC250 C06D18 >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q06_Gain18_b0    set 0.51155792       ; 417ABB
iir2_H_Parametric_f00793_q06_Gain18_b1    set -0.99030494       ; 813DB0
iir2_H_Parametric_f00793_q06_Gain18_b2    set 0.48511284       ; 3E182D
iir2_H_Parametric_f00793_q06_Gain18_a1    set 0.99030494       ; 7EC250
iir2_H_Parametric_f00793_q06_Gain18_a2    set -0.49667076       ; C06D18

; IIR2: mode=Parametric fc=1000 Q=6 gainDB=18 h=< 0.51453133 -0.98572416 0.48128294 0.98572416 -0.49581428 >,< 41DC29 81D3CB 3D9AAE 7E2C35 C08929 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q06_Gain18_b0    set 0.51453133       ; 41DC29
iir2_H_Parametric_f01000_q06_Gain18_b1    set -0.98572416       ; 81D3CB
iir2_H_Parametric_f01000_q06_Gain18_b2    set 0.48128294       ; 3D9AAE
iir2_H_Parametric_f01000_q06_Gain18_a1    set 0.98572416       ; 7E2C35
iir2_H_Parametric_f01000_q06_Gain18_a2    set -0.49581428       ; C08929

; IIR2: mode=Parametric fc=1259.92 Q=6 gainDB=18 h=< 0.51825225 -0.97875855 0.47649022 0.97875855 -0.49474247 >,< 425617 82B80A 3CFDA1 7D47F6 C0AC48 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q06_Gain18_b0    set 0.51825225       ; 425617
iir2_H_Parametric_f01259_q06_Gain18_b1    set -0.97875855       ; 82B80A
iir2_H_Parametric_f01259_q06_Gain18_b2    set 0.47649022       ; 3CFDA1
iir2_H_Parametric_f01259_q06_Gain18_a1    set 0.97875855       ; 7D47F6
iir2_H_Parametric_f01259_q06_Gain18_a2    set -0.49474247       ; C0AC48

; IIR2: mode=Parametric fc=1587.4 Q=6 gainDB=18 h=< 0.52289296 -0.96810689 0.47051276 0.96810689 -0.49340572 >,< 42EE28 841513 3C39C3 7BEAED C0D815 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q06_Gain18_b0    set 0.52289296       ; 42EE28
iir2_H_Parametric_f01587_q06_Gain18_b1    set -0.96810689       ; 841513
iir2_H_Parametric_f01587_q06_Gain18_b2    set 0.47051276       ; 3C39C3
iir2_H_Parametric_f01587_q06_Gain18_a1    set 0.96810689       ; 7BEAED
iir2_H_Parametric_f01587_q06_Gain18_a2    set -0.49340572       ; C0D815

; IIR2: mode=Parametric fc=2000 Q=6 gainDB=18 h=< 0.52865069 -0.95175524 0.46309653 0.95175524 -0.49174722 >,< 43AAD3 862CE3 3B46BF 79D31D C10E6E >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q06_Gain18_b0    set 0.52865069       ; 43AAD3
iir2_H_Parametric_f02000_q06_Gain18_b1    set -0.95175524       ; 862CE3
iir2_H_Parametric_f02000_q06_Gain18_b2    set 0.46309653       ; 3B46BF
iir2_H_Parametric_f02000_q06_Gain18_a1    set 0.95175524       ; 79D31D
iir2_H_Parametric_f02000_q06_Gain18_a2    set -0.49174722       ; C10E6E

; IIR2: mode=Parametric fc=2519.84 Q=6 gainDB=18 h=< 0.53573609 -0.92660536 0.45397019 0.92660536 -0.48970628 >,< 449300 8964FF 3A1BB2 769B01 C1514E >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q06_Gain18_b0    set 0.53573609       ; 449300
iir2_H_Parametric_f02519_q06_Gain18_b1    set -0.92660536       ; 8964FF
iir2_H_Parametric_f02519_q06_Gain18_b2    set 0.45397019       ; 3A1BB2
iir2_H_Parametric_f02519_q06_Gain18_a1    set 0.92660536       ; 769B01
iir2_H_Parametric_f02519_q06_Gain18_a2    set -0.48970628       ; C1514E

; IIR2: mode=Parametric fc=3174.8 Q=6 gainDB=18 h=< 0.54434239 -0.88794184 0.44288487 0.88794184 -0.48722726 >,< 45AD03 8E57EC 38B073 71A814 C1A28A >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q06_Gain18_b0    set 0.54434239       ; 45AD03
iir2_H_Parametric_f03174_q06_Gain18_b1    set -0.88794184       ; 8E57EC
iir2_H_Parametric_f03174_q06_Gain18_b2    set 0.44288487       ; 38B073
iir2_H_Parametric_f03174_q06_Gain18_a1    set 0.88794184       ; 71A814
iir2_H_Parametric_f03174_q06_Gain18_a2    set -0.48722726       ; C1A28A

; IIR2: mode=Parametric fc=4000 Q=6 gainDB=18 h=< 0.55457664 -0.82871699 0.42970266 0.82871699 -0.48427930 >,< 46FC5E 95EC9A 37007F 6A1366 C20323 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q06_Gain18_b0    set 0.55457664       ; 46FC5E
iir2_H_Parametric_f04000_q06_Gain18_b1    set -0.82871699       ; 95EC9A
iir2_H_Parametric_f04000_q06_Gain18_b2    set 0.42970266       ; 37007F
iir2_H_Parametric_f04000_q06_Gain18_a1    set 0.82871699       ; 6A1366
iir2_H_Parametric_f04000_q06_Gain18_a2    set -0.48427930       ; C20323

; IIR2: mode=Parametric fc=5039.68 Q=6 gainDB=18 h=< 0.56631969 -0.73871438 0.41457704 0.73871438 -0.48089673 >,< 487D2A A171CF 3510DC 5E8E31 C271FA >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q06_Gain18_b0    set 0.56631969       ; 487D2A
iir2_H_Parametric_f05039_q06_Gain18_b1    set -0.73871438       ; A171CF
iir2_H_Parametric_f05039_q06_Gain18_b2    set 0.41457704       ; 3510DC
iir2_H_Parametric_f05039_q06_Gain18_a1    set 0.73871438       ; 5E8E31
iir2_H_Parametric_f05039_q06_Gain18_a2    set -0.48089673       ; C271FA

; IIR2: mode=Parametric fc=6349.6 Q=6 gainDB=18 h=< 0.57896007 -0.60389394 0.39829562 0.60389394 -0.47725569 >,< 4A1B5D B2B39B 32FB59 4D4C65 C2E949 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q06_Gain18_b0    set 0.57896007       ; 4A1B5D
iir2_H_Parametric_f06349_q06_Gain18_b1    set -0.60389394       ; B2B39B
iir2_H_Parametric_f06349_q06_Gain18_b2    set 0.39829562       ; 32FB59
iir2_H_Parametric_f06349_q06_Gain18_a1    set 0.60389394       ; 4D4C65
iir2_H_Parametric_f06349_q06_Gain18_a2    set -0.47725569       ; C2E949

; IIR2: mode=Parametric fc=8000 Q=6 gainDB=18 h=< 0.59092436 -0.40682834 0.38288504 0.40682834 -0.47380940 >,< 4BA369 CBED0D 310260 3412F3 C35A37 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q06_Gain18_b0    set 0.59092436       ; 4BA369
iir2_H_Parametric_f08000_q06_Gain18_b1    set -0.40682834       ; CBED0D
iir2_H_Parametric_f08000_q06_Gain18_b2    set 0.38288504       ; 310260
iir2_H_Parametric_f08000_q06_Gain18_a1    set 0.40682834       ; 3412F3
iir2_H_Parametric_f08000_q06_Gain18_a2    set -0.47380940       ; C35A37

; IIR2: mode=Parametric fc=10079.4 Q=6 gainDB=18 h=< 0.59893416 -0.13049454 0.37256804 0.13049454 -0.47150219 >,< 4CA9E0 EF4BF5 2FB04F 10B40B C3A5D1 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q06_Gain18_b0    set 0.59893416       ; 4CA9E0
iir2_H_Parametric_f10079_q06_Gain18_b1    set -0.13049454       ; EF4BF5
iir2_H_Parametric_f10079_q06_Gain18_b2    set 0.37256804       ; 2FB04F
iir2_H_Parametric_f10079_q06_Gain18_a1    set 0.13049454       ; 10B40B
iir2_H_Parametric_f10079_q06_Gain18_a2    set -0.47150219       ; C3A5D1

; IIR2: mode=Parametric fc=12699.2 Q=6 gainDB=18 h=< 0.59706576 0.22967240 0.37497462 -0.22967240 -0.47204038 >,< 4C6CA6 1D65E7 2FFF2B E29A19 C3942F >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q06_Gain18_b0    set 0.59706576       ; 4C6CA6
iir2_H_Parametric_f12699_q06_Gain18_b1    set 0.22967240       ; 1D65E7
iir2_H_Parametric_f12699_q06_Gain18_b2    set 0.37497462       ; 2FFF2B
iir2_H_Parametric_f12699_q06_Gain18_a1    set -0.22967240       ; E29A19
iir2_H_Parametric_f12699_q06_Gain18_a2    set -0.47204038       ; C3942F

; IIR2: mode=Parametric fc=16000 Q=6 gainDB=18 h=< 0.57629959 0.63663021 0.40172245 -0.63663021 -0.47802204 >,< 49C42F 517D19 336BA4 AE82E7 C2D02D >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q06_Gain18_b0    set 0.57629959       ; 49C42F
iir2_H_Parametric_f16000_q06_Gain18_b1    set 0.63663021       ; 517D19
iir2_H_Parametric_f16000_q06_Gain18_b2    set 0.40172245       ; 336BA4
iir2_H_Parametric_f16000_q06_Gain18_a1    set -0.63663021       ; AE82E7
iir2_H_Parametric_f16000_q06_Gain18_a2    set -0.47802204       ; C2D02D

; IIR2: mode=Parametric fc=20158.7 Q=6 gainDB=18 h=< 0.52714389 0.95637836 0.46503736 -0.95637836 -0.49218125 >,< 437973 7A6A9B 3B8658 859565 C10035 >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q06_Gain18_b0    set 0.52714389       ; 437973
iir2_H_Parametric_f20158_q06_Gain18_b1    set 0.95637836       ; 7A6A9B
iir2_H_Parametric_f20158_q06_Gain18_b2    set 0.46503736       ; 3B8658
iir2_H_Parametric_f20158_q06_Gain18_a1    set -0.95637836       ; 859565
iir2_H_Parametric_f20158_q06_Gain18_a2    set -0.49218125       ; C10035

; IIR2: mode=Parametric fc=62.5 Q=15 gainDB=18 h=< 0.50036565 -0.99985503 0.49952903 0.99985503 -0.49989468 >,< 400BFB 8004C0 3FF091 7FFB40 C00374 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_Parametric_f00062_q15_Gain18_b0    set 0.50036565       ; 400BFB
iir2_H_Parametric_f00062_q15_Gain18_b1    set -0.99985503       ; 8004C0
iir2_H_Parametric_f00062_q15_Gain18_b2    set 0.49952903       ; 3FF091
iir2_H_Parametric_f00062_q15_Gain18_a1    set 0.99985503       ; 7FFB40
iir2_H_Parametric_f00062_q15_Gain18_a2    set -0.49989468       ; C00374

; IIR2: mode=Parametric fc=78.7451 Q=15 gainDB=18 h=< 0.50046067 -0.99980438 0.49940663 0.99980438 -0.49986730 >,< 400F18 800669 3FEC8E 7FF997 C0045A >
; Fc/Fs=0.0017856 Wc/Fs=0.0112193 (016FA2) coefficientScale=0.5
iir2_H_Parametric_f00078_q15_Gain18_b0    set 0.50046067       ; 400F18
iir2_H_Parametric_f00078_q15_Gain18_b1    set -0.99980438       ; 800669
iir2_H_Parametric_f00078_q15_Gain18_b2    set 0.49940663       ; 3FEC8E
iir2_H_Parametric_f00078_q15_Gain18_a1    set 0.99980438       ; 7FF997
iir2_H_Parametric_f00078_q15_Gain18_a2    set -0.49986730       ; C0045A

; IIR2: mode=Parametric fc=99.2126 Q=15 gainDB=18 h=< 0.50058038 -0.99973294 0.49925244 0.99973294 -0.49983282 >,< 401304 8008C1 3FE781 7FF73F C0057B >
; Fc/Fs=0.00224972 Wc/Fs=0.0141354 (01CF30) coefficientScale=0.5
iir2_H_Parametric_f00099_q15_Gain18_b0    set 0.50058038       ; 401304
iir2_H_Parametric_f00099_q15_Gain18_b1    set -0.99973294       ; 8008C1
iir2_H_Parametric_f00099_q15_Gain18_b2    set 0.49925244       ; 3FE781
iir2_H_Parametric_f00099_q15_Gain18_a1    set 0.99973294       ; 7FF73F
iir2_H_Parametric_f00099_q15_Gain18_a2    set -0.49983282       ; C0057B

; IIR2: mode=Parametric fc=125 Q=15 gainDB=18 h=< 0.50073119 -0.99963083 0.49905819 0.99963083 -0.49978938 >,< 4017F5 800C19 3FE123 7FF3E7 C006E7 >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_Parametric_f00125_q15_Gain18_b0    set 0.50073119       ; 4017F5
iir2_H_Parametric_f00125_q15_Gain18_b1    set -0.99963083       ; 800C19
iir2_H_Parametric_f00125_q15_Gain18_b2    set 0.49905819       ; 3FE123
iir2_H_Parametric_f00125_q15_Gain18_a1    set 0.99963083       ; 7FF3E7
iir2_H_Parametric_f00125_q15_Gain18_a2    set -0.49978938       ; C006E7

; IIR2: mode=Parametric fc=157.49 Q=15 gainDB=18 h=< 0.50092116 -0.99948299 0.49881350 0.99948299 -0.49973466 >,< 401E2F 8010F1 3FD91F 7FEF0F C008B2 >
; Fc/Fs=0.0035712 Wc/Fs=0.0224385 (02DF44) coefficientScale=0.5
iir2_H_Parametric_f00157_q15_Gain18_b0    set 0.50092116       ; 401E2F
iir2_H_Parametric_f00157_q15_Gain18_b1    set -0.99948299       ; 8010F1
iir2_H_Parametric_f00157_q15_Gain18_b2    set 0.49881350       ; 3FD91F
iir2_H_Parametric_f00157_q15_Gain18_a1    set 0.99948299       ; 7FEF0F
iir2_H_Parametric_f00157_q15_Gain18_a2    set -0.49973466       ; C008B2

; IIR2: mode=Parametric fc=198.425 Q=15 gainDB=18 h=< 0.50116046 -0.99926627 0.49850528 0.99926627 -0.49966573 >,< 402606 80180B 3FCF05 7FE7F5 C00AF4 >
; Fc/Fs=0.00449944 Wc/Fs=0.0282708 (039E60) coefficientScale=0.5
iir2_H_Parametric_f00198_q15_Gain18_b0    set 0.50116046       ; 402606
iir2_H_Parametric_f00198_q15_Gain18_b1    set -0.99926627       ; 80180B
iir2_H_Parametric_f00198_q15_Gain18_b2    set 0.49850528       ; 3FCF05
iir2_H_Parametric_f00198_q15_Gain18_a1    set 0.99926627       ; 7FE7F5
iir2_H_Parametric_f00198_q15_Gain18_a2    set -0.49966573       ; C00AF4

; IIR2: mode=Parametric fc=250 Q=15 gainDB=18 h=< 0.50146184 -0.99894490 0.49811708 0.99894490 -0.49957892 >,< 402FE7 802293 3FC24D 7FDD6D C00DCD >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_Parametric_f00250_q15_Gain18_b0    set 0.50146184       ; 402FE7
iir2_H_Parametric_f00250_q15_Gain18_b1    set -0.99894490       ; 802293
iir2_H_Parametric_f00250_q15_Gain18_b2    set 0.49811708       ; 3FC24D
iir2_H_Parametric_f00250_q15_Gain18_a1    set 0.99894490       ; 7FDD6D
iir2_H_Parametric_f00250_q15_Gain18_a2    set -0.49957892       ; C00DCD

; IIR2: mode=Parametric fc=314.98 Q=15 gainDB=18 h=< 0.50184138 -0.99846332 0.49762822 0.99846332 -0.49946960 >,< 403C56 80325B 3FB248 7FCDA5 C01162 >
; Fc/Fs=0.00714241 Wc/Fs=0.0448771 (05BE88) coefficientScale=0.5
iir2_H_Parametric_f00314_q15_Gain18_b0    set 0.50184138       ; 403C56
iir2_H_Parametric_f00314_q15_Gain18_b1    set -0.99846332       ; 80325B
iir2_H_Parametric_f00314_q15_Gain18_b2    set 0.49762822       ; 3FB248
iir2_H_Parametric_f00314_q15_Gain18_a1    set 0.99846332       ; 7FCDA5
iir2_H_Parametric_f00314_q15_Gain18_a2    set -0.49946960       ; C01162

; IIR2: mode=Parametric fc=396.85 Q=15 gainDB=18 h=< 0.50231921 -0.99773497 0.49701274 0.99773497 -0.49933196 >,< 404BFF 804A39 3F9E1D 7FB5C7 C015E4 >
; Fc/Fs=0.00899887 Wc/Fs=0.0565416 (073CC1) coefficientScale=0.5
iir2_H_Parametric_f00396_q15_Gain18_b0    set 0.50231921       ; 404BFF
iir2_H_Parametric_f00396_q15_Gain18_b1    set -0.99773497       ; 804A39
iir2_H_Parametric_f00396_q15_Gain18_b2    set 0.49701274       ; 3F9E1D
iir2_H_Parametric_f00396_q15_Gain18_a1    set 0.99773497       ; 7FB5C7
iir2_H_Parametric_f00396_q15_Gain18_a2    set -0.49933196       ; C015E4

; IIR2: mode=Parametric fc=500 Q=15 gainDB=18 h=< 0.50292060 -0.99662451 0.49623812 0.99662451 -0.49915873 >,< 405FB4 806E9C 3F84BB 7F9164 C01B91 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_Parametric_f00500_q15_Gain18_b0    set 0.50292060       ; 405FB4
iir2_H_Parametric_f00500_q15_Gain18_b1    set -0.99662451       ; 806E9C
iir2_H_Parametric_f00500_q15_Gain18_b2    set 0.49623812       ; 3F84BB
iir2_H_Parametric_f00500_q15_Gain18_a1    set 0.99662451       ; 7F9164
iir2_H_Parametric_f00500_q15_Gain18_a2    set -0.49915873       ; C01B91

; IIR2: mode=Parametric fc=629.961 Q=15 gainDB=18 h=< 0.50367710 -0.99491988 0.49526372 0.99491988 -0.49894082 >,< 40787D 80A677 3F64CD 7F5989 C022B5 >
; Fc/Fs=0.0142848 Wc/Fs=0.0897542 (0B7D10) coefficientScale=0.5
iir2_H_Parametric_f00629_q15_Gain18_b0    set 0.50367710       ; 40787D
iir2_H_Parametric_f00629_q15_Gain18_b1    set -0.99491988       ; 80A677
iir2_H_Parametric_f00629_q15_Gain18_b2    set 0.49526372       ; 3F64CD
iir2_H_Parametric_f00629_q15_Gain18_a1    set 0.99491988       ; 7F5989
iir2_H_Parametric_f00629_q15_Gain18_a2    set -0.49894082       ; C022B5

; IIR2: mode=Parametric fc=793.701 Q=15 gainDB=18 h=< 0.50462793 -0.99228836 0.49403901 0.99228836 -0.49866693 >,< 4097A6 80FCB2 3F3CAB 7F034E C02BAF >
; Fc/Fs=0.0179977 Wc/Fs=0.113083 (0E7982) coefficientScale=0.5
iir2_H_Parametric_f00793_q15_Gain18_b0    set 0.50462793       ; 4097A6
iir2_H_Parametric_f00793_q15_Gain18_b1    set -0.99228836       ; 80FCB2
iir2_H_Parametric_f00793_q15_Gain18_b2    set 0.49403901       ; 3F3CAB
iir2_H_Parametric_f00793_q15_Gain18_a1    set 0.99228836       ; 7F034E
iir2_H_Parametric_f00793_q15_Gain18_a2    set -0.49866693       ; C02BAF

; IIR2: mode=Parametric fc=1000 Q=15 gainDB=18 h=< 0.50582152 -0.98820759 0.49250161 0.98820759 -0.49832312 >,< 40BEC2 81826A 3F0A4B 7E7D96 C036F3 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_Parametric_f01000_q15_Gain18_b0    set 0.50582152       ; 40BEC2
iir2_H_Parametric_f01000_q15_Gain18_b1    set -0.98820759       ; 81826A
iir2_H_Parametric_f01000_q15_Gain18_b2    set 0.49250161       ; 3F0A4B
iir2_H_Parametric_f01000_q15_Gain18_a1    set 0.98820759       ; 7E7D96
iir2_H_Parametric_f01000_q15_Gain18_a2    set -0.49832312       ; C036F3

; IIR2: mode=Parametric fc=1259.92 Q=15 gainDB=18 h=< 0.50731690 -0.98185784 0.49057547 0.98185784 -0.49789238 >,< 40EFC2 82527C 3ECB2D 7DAD84 C04510 >
; Fc/Fs=0.0285696 Wc/Fs=0.179508 (16FA21) coefficientScale=0.5
iir2_H_Parametric_f01259_q15_Gain18_b0    set 0.50731690       ; 40EFC2
iir2_H_Parametric_f01259_q15_Gain18_b1    set -0.98185784       ; 82527C
iir2_H_Parametric_f01259_q15_Gain18_b2    set 0.49057547       ; 3ECB2D
iir2_H_Parametric_f01259_q15_Gain18_a1    set 0.98185784       ; 7DAD84
iir2_H_Parametric_f01259_q15_Gain18_a2    set -0.49789238       ; C04510

; IIR2: mode=Parametric fc=1587.4 Q=15 gainDB=18 h=< 0.50918465 -0.97195498 0.48816973 0.97195498 -0.49735438 >,< 412CF6 8396FB 3E7C58 7C6905 C056B1 >
; Fc/Fs=0.0359955 Wc/Fs=0.226166 (1CF304) coefficientScale=0.5
iir2_H_Parametric_f01587_q15_Gain18_b0    set 0.50918465       ; 412CF6
iir2_H_Parametric_f01587_q15_Gain18_b1    set -0.97195498       ; 8396FB
iir2_H_Parametric_f01587_q15_Gain18_b2    set 0.48816973       ; 3E7C58
iir2_H_Parametric_f01587_q15_Gain18_a1    set 0.97195498       ; 7C6905
iir2_H_Parametric_f01587_q15_Gain18_a2    set -0.49735438       ; C056B1

; IIR2: mode=Parametric fc=2000 Q=15 gainDB=18 h=< 0.51150616 -0.95649455 0.48517952 0.95649455 -0.49668567 >,< 417908 859196 3E1A5C 7A6E6A C06C9B >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_Parametric_f02000_q15_Gain18_b0    set 0.51150616       ; 417908
iir2_H_Parametric_f02000_q15_Gain18_b1    set -0.95649455       ; 859196
iir2_H_Parametric_f02000_q15_Gain18_b2    set 0.48517952       ; 3E1A5C
iir2_H_Parametric_f02000_q15_Gain18_a1    set 0.95649455       ; 7A6E6A
iir2_H_Parametric_f02000_q15_Gain18_a2    set -0.49668567       ; C06C9B

; IIR2: mode=Parametric fc=2519.84 Q=15 gainDB=18 h=< 0.51436936 -0.93236760 0.48149158 0.93236760 -0.49586093 >,< 41D6DB 88A82E 3DA184 7757D2 C087A1 >
; Fc/Fs=0.0571393 Wc/Fs=0.359017 (2DF442) coefficientScale=0.5
iir2_H_Parametric_f02519_q15_Gain18_b0    set 0.51436936       ; 41D6DB
iir2_H_Parametric_f02519_q15_Gain18_b1    set -0.93236760       ; 88A82E
iir2_H_Parametric_f02519_q15_Gain18_b2    set 0.48149158       ; 3DA184
iir2_H_Parametric_f02519_q15_Gain18_a1    set 0.93236760       ; 7757D2
iir2_H_Parametric_f02519_q15_Gain18_a2    set -0.49586093       ; C087A1

; IIR2: mode=Parametric fc=3174.8 Q=15 gainDB=18 h=< 0.51785666 -0.89480374 0.47699976 0.89480374 -0.49485642 >,< 424920 8D7712 3D0E54 7288EE C0A88C >
; Fc/Fs=0.071991 Wc/Fs=0.452333 (39E609) coefficientScale=0.5
iir2_H_Parametric_f03174_q15_Gain18_b0    set 0.51785666       ; 424920
iir2_H_Parametric_f03174_q15_Gain18_b1    set -0.89480374       ; 8D7712
iir2_H_Parametric_f03174_q15_Gain18_b2    set 0.47699976       ; 3D0E54
iir2_H_Parametric_f03174_q15_Gain18_a1    set 0.89480374       ; 7288EE
iir2_H_Parametric_f03174_q15_Gain18_a2    set -0.49485642       ; C0A88C

; IIR2: mode=Parametric fc=4000 Q=15 gainDB=18 h=< 0.52201726 -0.83661339 0.47164071 0.83661339 -0.49365797 >,< 42D176 94E9DA 3C5EB9 6B1626 C0CFD1 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_Parametric_f04000_q15_Gain18_b0    set 0.52201726       ; 42D176
iir2_H_Parametric_f04000_q15_Gain18_b1    set -0.83661339       ; 94E9DA
iir2_H_Parametric_f04000_q15_Gain18_b2    set 0.47164071       ; 3C5EB9
iir2_H_Parametric_f04000_q15_Gain18_a1    set 0.83661339       ; 6B1626
iir2_H_Parametric_f04000_q15_Gain18_a2    set -0.49365797       ; C0CFD1

; IIR2: mode=Parametric fc=5039.68 Q=15 gainDB=18 h=< 0.52680959 -0.74728528 0.46546795 0.74728528 -0.49227754 >,< 436E7F A058F5 3B9474 5FA70B C0FD0D >
; Fc/Fs=0.114279 Wc/Fs=0.718033 (5BE884) coefficientScale=0.5
iir2_H_Parametric_f05039_q15_Gain18_b0    set 0.52680959       ; 436E7F
iir2_H_Parametric_f05039_q15_Gain18_b1    set -0.74728528       ; A058F5
iir2_H_Parametric_f05039_q15_Gain18_b2    set 0.46546795       ; 3B9474
iir2_H_Parametric_f05039_q15_Gain18_a1    set 0.74728528       ; 5FA70B
iir2_H_Parametric_f05039_q15_Gain18_a2    set -0.49227754       ; C0FD0D

; IIR2: mode=Parametric fc=6349.6 Q=15 gainDB=18 h=< 0.53199018 -0.61225454 0.45879510 0.61225454 -0.49078529 >,< 441841 B1A1A5 3AB9CC 4E5E5B C12DF3 >
; Fc/Fs=0.143982 Wc/Fs=0.904665 (73CC12) coefficientScale=0.5
iir2_H_Parametric_f06349_q15_Gain18_b0    set 0.53199018       ; 441841
iir2_H_Parametric_f06349_q15_Gain18_b1    set -0.61225454       ; B1A1A5
iir2_H_Parametric_f06349_q15_Gain18_b2    set 0.45879510       ; 3AB9CC
iir2_H_Parametric_f06349_q15_Gain18_a1    set 0.61225454       ; 4E5E5B
iir2_H_Parametric_f06349_q15_Gain18_a2    set -0.49078529       ; C12DF3

; IIR2: mode=Parametric fc=8000 Q=15 gainDB=18 h=< 0.53691488 -0.41332773 0.45245185 0.41332773 -0.48936673 >,< 44B9A0 CB1814 39E9F1 34E7EC C15C6F >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_Parametric_f08000_q15_Gain18_b0    set 0.53691488       ; 44B9A0
iir2_H_Parametric_f08000_q15_Gain18_b1    set -0.41332773       ; CB1814
iir2_H_Parametric_f08000_q15_Gain18_b2    set 0.45245185       ; 39E9F1
iir2_H_Parametric_f08000_q15_Gain18_a1    set 0.41332773       ; 34E7EC
iir2_H_Parametric_f08000_q15_Gain18_a2    set -0.48936673       ; C15C6F

; IIR2: mode=Parametric fc=10079.4 Q=15 gainDB=18 h=< 0.54022343 -0.13276614 0.44819028 0.13276614 -0.48841371 >,< 45260A EF0185 395E4C 10FE7B C17BA9 >
; Fc/Fs=0.228557 Wc/Fs=1.43607 (800000) coefficientScale=0.5
iir2_H_Parametric_f10079_q15_Gain18_b0    set 0.54022343       ; 45260A
iir2_H_Parametric_f10079_q15_Gain18_b1    set -0.13276614       ; EF0185
iir2_H_Parametric_f10079_q15_Gain18_b2    set 0.44819028       ; 395E4C
iir2_H_Parametric_f10079_q15_Gain18_a1    set 0.13276614       ; 10FE7B
iir2_H_Parametric_f10079_q15_Gain18_a2    set -0.48841371       ; C17BA9

; IIR2: mode=Parametric fc=12699.2 Q=15 gainDB=18 h=< 0.53945083 0.23359365 0.44918543 -0.23359365 -0.48863626 >,< 450CB9 1DE665 397EE8 E2199B C1745E >
; Fc/Fs=0.287964 Wc/Fs=1.80933 (800000) coefficientScale=0.5
iir2_H_Parametric_f12699_q15_Gain18_b0    set 0.53945083       ; 450CB9
iir2_H_Parametric_f12699_q15_Gain18_b1    set 0.23359365       ; 1DE665
iir2_H_Parametric_f12699_q15_Gain18_b2    set 0.44918543       ; 397EE8
iir2_H_Parametric_f12699_q15_Gain18_a1    set -0.23359365       ; E2199B
iir2_H_Parametric_f12699_q15_Gain18_a2    set -0.48863626       ; C1745E

; IIR2: mode=Parametric fc=16000 Q=15 gainDB=18 h=< 0.53089789 0.64514308 0.46020203 -0.64514308 -0.49109992 >,< 43F476 52940C 3AE7E6 AD6BF4 C123A4 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_Parametric_f16000_q15_Gain18_b0    set 0.53089789       ; 43F476
iir2_H_Parametric_f16000_q15_Gain18_b1    set 0.64514308       ; 52940C
iir2_H_Parametric_f16000_q15_Gain18_b2    set 0.46020203       ; 3AE7E6
iir2_H_Parametric_f16000_q15_Gain18_a1    set -0.64514308       ; AD6BF4
iir2_H_Parametric_f16000_q15_Gain18_a2    set -0.49109992       ; C123A4

; IIR2: mode=Parametric fc=20158.7 Q=15 gainDB=18 h=< 0.51089817 0.96088905 0.48596264 -0.96088905 -0.49686080 >,< 41651C 7AFE69 3E3406 850197 C066DE >
; Fc/Fs=0.457114 Wc/Fs=2.87213 (800000) coefficientScale=0.5
iir2_H_Parametric_f20158_q15_Gain18_b0    set 0.51089817       ; 41651C
iir2_H_Parametric_f20158_q15_Gain18_b1    set 0.96088905       ; 7AFE69
iir2_H_Parametric_f20158_q15_Gain18_b2    set 0.48596264       ; 3E3406
iir2_H_Parametric_f20158_q15_Gain18_a1    set -0.96088905       ; 850197
iir2_H_Parametric_f20158_q15_Gain18_a2    set -0.49686080       ; C066DE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Iir2_LowPass.h ===
;**************************************************************************
;
;       IIR2_LowPass.h    Coefficients for 2nd order low pass filter
;       
;		Written by Gints Klimanis
;
;**************************************************************************        
    
; IIR2: mode=LowPass fc=62.5 Q=0.707107 gainDB=0 h=< 0.00000984 0.00001969 0.00000984 0.99317251 -0.49321189 >,< 000052 0000A5 000052 7F2047 C0DE6F >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_LowPass_f00062_q00_b0    set 0.00000984       ; 000052
iir2_H_LowPass_f00062_q00_b1    set 0.00001969       ; 0000A5
iir2_H_LowPass_f00062_q00_b2    set 0.00000984       ; 000052
iir2_H_LowPass_f00062_q00_a1    set 0.99317251       ; 7F2047
iir2_H_LowPass_f00062_q00_a2    set -0.49321189       ; C0DE6F

; IIR2: mode=LowPass fc=88.3883 Q=0.707107 gainDB=0 h=< 0.00001963 0.00003927 0.00001963 0.99034867 -0.49042720 >,< 0000A4 000149 0000A4 7EC3BF C139AF >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_LowPass_f00088_q00_b0    set 0.00001963       ; 0000A4
iir2_H_LowPass_f00088_q00_b1    set 0.00003927       ; 000149
iir2_H_LowPass_f00088_q00_b2    set 0.00001963       ; 0000A4
iir2_H_LowPass_f00088_q00_a1    set 0.99034867       ; 7EC3BF
iir2_H_LowPass_f00088_q00_a2    set -0.49042720       ; C139AF

; IIR2: mode=LowPass fc=125 Q=0.707107 gainDB=0 h=< 0.00003911 0.00007822 0.00003911 0.98635939 -0.48651584 >,< 000148 000290 000148 7E4106 C1B9DA >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_LowPass_f00125_q00_b0    set 0.00003911       ; 000148
iir2_H_LowPass_f00125_q00_b1    set 0.00007822       ; 000290
iir2_H_LowPass_f00125_q00_b2    set 0.00003911       ; 000148
iir2_H_LowPass_f00125_q00_a1    set 0.98635939       ; 7E4106
iir2_H_LowPass_f00125_q00_a2    set -0.48651584       ; C1B9DA

; IIR2: mode=LowPass fc=176.777 Q=0.707107 gainDB=0 h=< 0.00007779 0.00015557 0.00007779 0.98072627 -0.48103742 >,< 00028C 000519 00028C 7D8870 C26D5E >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_LowPass_f00176_q00_b0    set 0.00007779       ; 00028C
iir2_H_LowPass_f00176_q00_b1    set 0.00015557       ; 000519
iir2_H_LowPass_f00176_q00_b2    set 0.00007779       ; 00028C
iir2_H_LowPass_f00176_q00_a1    set 0.98072627       ; 7D8870
iir2_H_LowPass_f00176_q00_a2    set -0.48103742       ; C26D5E

; IIR2: mode=LowPass fc=250 Q=0.707107 gainDB=0 h=< 0.00015435 0.00030871 0.00015435 0.97277718 -0.47339460 >,< 00050E 000A1D 00050E 7C83F6 C367CF >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_LowPass_f00250_q00_b0    set 0.00015435       ; 00050E
iir2_H_LowPass_f00250_q00_b1    set 0.00030871       ; 000A1D
iir2_H_LowPass_f00250_q00_b2    set 0.00015435       ; 00050E
iir2_H_LowPass_f00250_q00_a1    set 0.97277718       ; 7C83F6
iir2_H_LowPass_f00250_q00_a2    set -0.47339460       ; C367CF

; IIR2: mode=LowPass fc=353.553 Q=0.707107 gainDB=0 h=< 0.00030531 0.00061062 0.00030531 0.96157073 -0.46279198 >,< 000A01 001402 000A01 7B14C0 C4C33C >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_LowPass_f00353_q00_b0    set 0.00030531       ; 000A01
iir2_H_LowPass_f00353_q00_b1    set 0.00061062       ; 001402
iir2_H_LowPass_f00353_q00_b2    set 0.00030531       ; 000A01
iir2_H_LowPass_f00353_q00_a1    set 0.96157073       ; 7B14C0
iir2_H_LowPass_f00353_q00_a2    set -0.46279198       ; C4C33C

; IIR2: mode=LowPass fc=500 Q=0.707107 gainDB=0 h=< 0.00060124 0.00120248 0.00060124 0.94579441 -0.44819937 >,< 0013B3 002767 0013B3 790FCA C6A168 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_LowPass_f00500_q00_b0    set 0.00060124       ; 0013B3
iir2_H_LowPass_f00500_q00_b1    set 0.00120248       ; 002767
iir2_H_LowPass_f00500_q00_b2    set 0.00060124       ; 0013B3
iir2_H_LowPass_f00500_q00_a1    set 0.94579441       ; 790FCA
iir2_H_LowPass_f00500_q00_a2    set -0.44819937       ; C6A168

; IIR2: mode=LowPass fc=707.107 Q=0.707107 gainDB=0 h=< 0.00117680 0.00235359 0.00117680 0.92363081 -0.42833799 >,< 00268F 004D1F 00268F 763989 C92C39 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_LowPass_f00707_q00_b0    set 0.00117680       ; 00268F
iir2_H_LowPass_f00707_q00_b1    set 0.00235359       ; 004D1F
iir2_H_LowPass_f00707_q00_b2    set 0.00117680       ; 00268F
iir2_H_LowPass_f00707_q00_a1    set 0.92363081       ; 763989
iir2_H_LowPass_f00707_q00_a2    set -0.42833799       ; C92C39

; IIR2: mode=LowPass fc=1000 Q=0.707107 gainDB=0 h=< 0.00228419 0.00456838 0.00228419 0.89258956 -0.40172633 >,< 004AD9 0095B2 004AD9 724060 CC943C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_LowPass_f01000_q00_b0    set 0.00228419       ; 004AD9
iir2_H_LowPass_f01000_q00_b1    set 0.00456838       ; 0095B2
iir2_H_LowPass_f01000_q00_b2    set 0.00228419       ; 004AD9
iir2_H_LowPass_f01000_q00_a1    set 0.89258956       ; 724060
iir2_H_LowPass_f01000_q00_a2    set -0.40172633       ; CC943C

; IIR2: mode=LowPass fc=1414.21 Q=0.707107 gainDB=0 h=< 0.00438425 0.00876851 0.00438425 0.84931088 -0.36684790 >,< 008FA9 011F53 008FA9 6CB638 D10B21 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_LowPass_f01414_q00_b0    set 0.00438425       ; 008FA9
iir2_H_LowPass_f01414_q00_b1    set 0.00876851       ; 011F53
iir2_H_LowPass_f01414_q00_b2    set 0.00438425       ; 008FA9
iir2_H_LowPass_f01414_q00_a1    set 0.84931088       ; 6CB638
iir2_H_LowPass_f01414_q00_a2    set -0.36684790       ; D10B21

; IIR2: mode=LowPass fc=2000 Q=0.707107 gainDB=0 h=< 0.00829210 0.01658419 0.00829210 0.78936286 -0.32253125 >,< 010FB7 021F6E 010FB7 6509D7 D6B74C >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_LowPass_f02000_q00_b0    set 0.00829210       ; 010FB7
iir2_H_LowPass_f02000_q00_b1    set 0.01658419       ; 021F6E
iir2_H_LowPass_f02000_q00_b2    set 0.00829210       ; 010FB7
iir2_H_LowPass_f02000_q00_a1    set 0.78936286       ; 6509D7
iir2_H_LowPass_f02000_q00_a2    set -0.32253125       ; D6B74C

; IIR2: mode=LowPass fc=2828.43 Q=0.707107 gainDB=0 h=< 0.01539295 0.03078589 0.01539295 0.70707082 -0.26864261 >,< 01F865 03F0CA 01F865 5A814C DD9D1F >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_LowPass_f02828_q00_b0    set 0.01539295       ; 01F865
iir2_H_LowPass_f02828_q00_b1    set 0.03078589       ; 03F0CA
iir2_H_LowPass_f02828_q00_b2    set 0.01539295       ; 01F865
iir2_H_LowPass_f02828_q00_a1    set 0.70707082       ; 5A814C
iir2_H_LowPass_f02828_q00_a2    set -0.26864261       ; DD9D1F

; IIR2: mode=LowPass fc=4000 Q=0.707107 gainDB=0 h=< 0.02794091 0.05588181 0.02794091 0.59539110 -0.20715472 >,< 039391 072722 039391 4C35C6 E57BF5 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_LowPass_f04000_q00_b0    set 0.02794091       ; 039391
iir2_H_LowPass_f04000_q00_b1    set 0.05588181       ; 072722
iir2_H_LowPass_f04000_q00_b2    set 0.02794091       ; 039391
iir2_H_LowPass_f04000_q00_a1    set 0.59539110       ; 4C35C6
iir2_H_LowPass_f04000_q00_a2    set -0.20715472       ; E57BF5

; IIR2: mode=LowPass fc=5656.85 Q=0.707107 gainDB=0 h=< 0.04949016 0.09898033 0.04949016 0.44563633 -0.14359698 >,< 0655B1 0CAB63 0655B1 390A9C ED9E9E >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_LowPass_f05656_q00_b0    set 0.04949016       ; 0655B1
iir2_H_LowPass_f05656_q00_b1    set 0.09898033       ; 0CAB63
iir2_H_LowPass_f05656_q00_b2    set 0.04949016       ; 0655B1
iir2_H_LowPass_f05656_q00_a1    set 0.44563633       ; 390A9C
iir2_H_LowPass_f05656_q00_a2    set -0.14359698       ; ED9E9E

; IIR2: mode=LowPass fc=8000 Q=0.707107 gainDB=0 h=< 0.08575648 0.17151296 0.08575648 0.24613286 -0.08915878 >,< 0AFA11 15F423 0AFA11 1F8148 F49672 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_LowPass_f08000_q00_b0    set 0.08575648       ; 0AFA11
iir2_H_LowPass_f08000_q00_b1    set 0.17151296       ; 15F423
iir2_H_LowPass_f08000_q00_b2    set 0.08575648       ; 0AFA11
iir2_H_LowPass_f08000_q00_a1    set 0.24613286       ; 1F8148
iir2_H_LowPass_f08000_q00_a2    set -0.08915878       ; F49672

; IIR2: mode=LowPass fc=11313.7 Q=0.707107 gainDB=0 h=< 0.14731136 0.29462272 0.14731136 -0.02327410 -0.06597134 >,< 12DB19 25B632 12DB19 FD055B F78E41 >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_LowPass_f11313_q00_b0    set 0.14731136       ; 12DB19
iir2_H_LowPass_f11313_q00_b1    set 0.29462272       ; 25B632
iir2_H_LowPass_f11313_q00_b2    set 0.14731136       ; 12DB19
iir2_H_LowPass_f11313_q00_a1    set -0.02327410       ; FD055B
iir2_H_LowPass_f11313_q00_a2    set -0.06597134       ; F78E41

; IIR2: mode=LowPass fc=16000 Q=0.707107 gainDB=0 h=< 0.26078648 0.52157295 0.26078648 -0.41129488 -0.13185103 >,< 216173 42C2E7 216173 CB5AB1 EF1F82 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_LowPass_f16000_q00_b0    set 0.26078648       ; 216173
iir2_H_LowPass_f16000_q00_b1    set 0.52157295       ; 42C2E7
iir2_H_LowPass_f16000_q00_b2    set 0.26078648       ; 216173
iir2_H_LowPass_f16000_q00_a1    set -0.41129488       ; CB5AB1
iir2_H_LowPass_f16000_q00_a2    set -0.13185103       ; EF1F82

; IIR2: mode=LowPass fc=62.5 Q=5 gainDB=0 h=< 0.00000990 0.00001981 0.00000990 0.99906924 -0.49910885 >,< 000053 0000A6 000053 7FE180 C01D34 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_LowPass_f00062_q05_b0    set 0.00000990       ; 000053
iir2_H_LowPass_f00062_q05_b1    set 0.00001981       ; 0000A6
iir2_H_LowPass_f00062_q05_b2    set 0.00000990       ; 000053
iir2_H_LowPass_f00062_q05_a1    set 0.99906924       ; 7FE180
iir2_H_LowPass_f00062_q05_a2    set -0.49910885       ; C01D34

; IIR2: mode=LowPass fc=88.3883 Q=5 gainDB=0 h=< 0.00001980 0.00003960 0.00001980 0.99866101 -0.49874020 >,< 0000A6 00014C 0000A6 7FD41F C02948 >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_LowPass_f00088_q05_b0    set 0.00001980       ; 0000A6
iir2_H_LowPass_f00088_q05_b1    set 0.00003960       ; 00014C
iir2_H_LowPass_f00088_q05_b2    set 0.00001980       ; 0000A6
iir2_H_LowPass_f00088_q05_a1    set 0.99866101       ; 7FD41F
iir2_H_LowPass_f00088_q05_a2    set -0.49874020       ; C02948

; IIR2: mode=LowPass fc=125 Q=5 gainDB=0 h=< 0.00003958 0.00007915 0.00003958 0.99806105 -0.49821935 >,< 00014B 000297 00014B 7FC077 C03A5A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_LowPass_f00125_q05_b0    set 0.00003958       ; 00014B
iir2_H_LowPass_f00125_q05_b1    set 0.00007915       ; 000297
iir2_H_LowPass_f00125_q05_b2    set 0.00003958       ; 00014B
iir2_H_LowPass_f00125_q05_a1    set 0.99806105       ; 7FC077
iir2_H_LowPass_f00125_q05_a2    set -0.49821935       ; C03A5A

; IIR2: mode=LowPass fc=176.777 Q=5 gainDB=0 h=< 0.00007909 0.00015818 0.00007909 0.99716741 -0.49748377 >,< 000297 00052E 000297 7FA32E C05274 >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_LowPass_f00176_q05_b0    set 0.00007909       ; 000297
iir2_H_LowPass_f00176_q05_b1    set 0.00015818       ; 00052E
iir2_H_LowPass_f00176_q05_b2    set 0.00007909       ; 000297
iir2_H_LowPass_f00176_q05_a1    set 0.99716741       ; 7FA32E
iir2_H_LowPass_f00176_q05_a2    set -0.49748377       ; C05274

; IIR2: mode=LowPass fc=250 Q=5 gainDB=0 h=< 0.00015801 0.00031602 0.00015801 0.99581356 -0.49644560 >,< 00052D 000A5A 00052D 7F76D1 C07479 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_LowPass_f00250_q05_b0    set 0.00015801       ; 00052D
iir2_H_LowPass_f00250_q05_b1    set 0.00031602       ; 000A5A
iir2_H_LowPass_f00250_q05_b2    set 0.00015801       ; 00052D
iir2_H_LowPass_f00250_q05_a1    set 0.99581356       ; 7F76D1
iir2_H_LowPass_f00250_q05_a2    set -0.49644560       ; C07479

; IIR2: mode=LowPass fc=353.553 Q=5 gainDB=0 h=< 0.00031552 0.00063104 0.00031552 0.99371968 -0.49498176 >,< 000A56 0014AD 000A56 7F3235 C0A470 >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_LowPass_f00353_q05_b0    set 0.00031552       ; 000A56
iir2_H_LowPass_f00353_q05_b1    set 0.00063104       ; 0014AD
iir2_H_LowPass_f00353_q05_b2    set 0.00031552       ; 000A56
iir2_H_LowPass_f00353_q05_a1    set 0.99371968       ; 7F3235
iir2_H_LowPass_f00353_q05_a2    set -0.49498176       ; C0A470

; IIR2: mode=LowPass fc=500 Q=5 gainDB=0 h=< 0.00062960 0.00125920 0.00062960 0.99040244 -0.49292083 >,< 0014A1 002942 0014A1 7EC582 C0E7F9 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_LowPass_f00500_q05_b0    set 0.00062960       ; 0014A1
iir2_H_LowPass_f00500_q05_b1    set 0.00125920       ; 002942
iir2_H_LowPass_f00500_q05_b2    set 0.00062960       ; 0014A1
iir2_H_LowPass_f00500_q05_a1    set 0.99040244       ; 7EC582
iir2_H_LowPass_f00500_q05_a2    set -0.49292083       ; C0E7F9

; IIR2: mode=LowPass fc=707.107 Q=5 gainDB=0 h=< 0.00125499 0.00250999 0.00125499 0.98500620 -0.49002618 >,< 00291F 00523F 00291F 7E14AF C146D3 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_LowPass_f00707_q05_b0    set 0.00125499       ; 00291F
iir2_H_LowPass_f00707_q05_b1    set 0.00250999       ; 00523F
iir2_H_LowPass_f00707_q05_b2    set 0.00125499       ; 00291F
iir2_H_LowPass_f00707_q05_a1    set 0.98500620       ; 7E14AF
iir2_H_LowPass_f00707_q05_a2    set -0.49002618       ; C146D3

; IIR2: mode=LowPass fc=1000 Q=5 gainDB=0 h=< 0.00249761 0.00499522 0.00249761 0.97598592 -0.48597635 >,< 0051D7 00A3AE 0051D7 7CED1B C1CB87 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_LowPass_f01000_q05_b0    set 0.00249761       ; 0051D7
iir2_H_LowPass_f01000_q05_b1    set 0.00499522       ; 00A3AE
iir2_H_LowPass_f01000_q05_b2    set 0.00249761       ; 0051D7
iir2_H_LowPass_f01000_q05_a1    set 0.97598592       ; 7CED1B
iir2_H_LowPass_f01000_q05_a2    set -0.48597635       ; C1CB87

; IIR2: mode=LowPass fc=1414.21 Q=5 gainDB=0 h=< 0.00495830 0.00991660 0.00495830 0.96051432 -0.48034752 >,< 00A279 0144F2 00A279 7AF222 C283F9 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_LowPass_f01414_q05_b0    set 0.00495830       ; 00A279
iir2_H_LowPass_f01414_q05_b1    set 0.00991660       ; 0144F2
iir2_H_LowPass_f01414_q05_b2    set 0.00495830       ; 00A279
iir2_H_LowPass_f01414_q05_a1    set 0.96051432       ; 7AF222
iir2_H_LowPass_f01414_q05_a2    set -0.48034752       ; C283F9

; IIR2: mode=LowPass fc=2000 Q=5 gainDB=0 h=< 0.00980510 0.01961020 0.00980510 0.93339277 -0.47261317 >,< 01414B 028296 01414B 77796A C3816A >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_LowPass_f02000_q05_b0    set 0.00980510       ; 01414B
iir2_H_LowPass_f02000_q05_b1    set 0.01961020       ; 028296
iir2_H_LowPass_f02000_q05_b2    set 0.00980510       ; 01414B
iir2_H_LowPass_f02000_q05_a1    set 0.93339277       ; 77796A
iir2_H_LowPass_f02000_q05_a2    set -0.47261317       ; C3816A

; IIR2: mode=LowPass fc=2828.43 Q=5 gainDB=0 h=< 0.01926921 0.03853843 0.01926921 0.88512611 -0.46220297 >,< 027769 04EED3 027769 714BD0 C4D689 >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_LowPass_f02828_q05_b0    set 0.01926921       ; 027769
iir2_H_LowPass_f02828_q05_b1    set 0.03853843       ; 04EED3
iir2_H_LowPass_f02828_q05_b2    set 0.01926921       ; 027769
iir2_H_LowPass_f02828_q05_a1    set 0.88512611       ; 714BD0
iir2_H_LowPass_f02828_q05_a2    set -0.46220297       ; C4D689

; IIR2: mode=LowPass fc=4000 Q=5 gainDB=0 h=< 0.03748581 0.07497161 0.03748581 0.79878283 -0.44872606 >,< 04CC55 0998AB 04CC55 663E84 C69025 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_LowPass_f04000_q05_b0    set 0.03748581       ; 04CC55
iir2_H_LowPass_f04000_q05_b1    set 0.07497161       ; 0998AB
iir2_H_LowPass_f04000_q05_b2    set 0.03748581       ; 04CC55
iir2_H_LowPass_f04000_q05_a1    set 0.79878283       ; 663E84
iir2_H_LowPass_f04000_q05_a2    set -0.44872606       ; C69025

; IIR2: mode=LowPass fc=5656.85 Q=5 gainDB=0 h=< 0.07171345 0.14342691 0.07171345 0.64574691 -0.43260072 >,< 092DE8 125BD0 092DE8 52A7D5 C8A08A >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_LowPass_f05656_q05_b0    set 0.07171345       ; 092DE8
iir2_H_LowPass_f05656_q05_b1    set 0.14342691       ; 125BD0
iir2_H_LowPass_f05656_q05_b2    set 0.07171345       ; 092DE8
iir2_H_LowPass_f05656_q05_a1    set 0.64574691       ; 52A7D5
iir2_H_LowPass_f05656_q05_a2    set -0.43260072       ; C8A08A

; IIR2: mode=LowPass fc=8000 Q=5 gainDB=0 h=< 0.13341576 0.26683153 0.13341576 0.38292153 -0.41658458 >,< 1113C4 222789 1113C4 310392 CAAD5C >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_LowPass_f08000_q05_b0    set 0.13341576       ; 1113C4
iir2_H_LowPass_f08000_q05_b1    set 0.26683153       ; 222789
iir2_H_LowPass_f08000_q05_b2    set 0.13341576       ; 1113C4
iir2_H_LowPass_f08000_q05_a1    set 0.38292153       ; 310392
iir2_H_LowPass_f08000_q05_a2    set -0.41658458       ; CAAD5C

; IIR2: mode=LowPass fc=11313.7 Q=5 gainDB=0 h=< 0.23660108 0.47320217 0.23660108 -0.03738121 -0.40902313 >,< 1E48F1 3C91E3 1E48F1 FB3718 CBA522 >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_LowPass_f11313_q05_b0    set 0.23660108       ; 1E48F1
iir2_H_LowPass_f11313_q05_b1    set 0.47320217       ; 3C91E3
iir2_H_LowPass_f11313_q05_b2    set 0.23660108       ; 1E48F1
iir2_H_LowPass_f11313_q05_a1    set -0.03738121       ; FB3718
iir2_H_LowPass_f11313_q05_a2    set -0.40902313       ; CBA522

; IIR2: mode=LowPass fc=16000 Q=5 gainDB=0 h=< 0.38356770 0.76713541 0.38356770 -0.60493716 -0.42933365 >,< 3118BF 62317E 3118BF B2916C C90B99 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_LowPass_f16000_q05_b0    set 0.38356770       ; 3118BF
iir2_H_LowPass_f16000_q05_b1    set 0.76713541       ; 62317E
iir2_H_LowPass_f16000_q05_b2    set 0.38356770       ; 3118BF
iir2_H_LowPass_f16000_q05_a1    set -0.60493716       ; B2916C
iir2_H_LowPass_f16000_q05_a2    set -0.42933365       ; C90B99

; IIR2: mode=LowPass fc=62.5 Q=10 gainDB=0 h=< 0.00000991 0.00001981 0.00000991 0.99951515 -0.49955478 >,< 000053 0000A6 000053 7FF01D C00E97 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_LowPass_f00062_q10_b0    set 0.00000991       ; 000053
iir2_H_LowPass_f00062_q10_b1    set 0.00001981       ; 0000A6
iir2_H_LowPass_f00062_q10_b2    set 0.00000991       ; 000053
iir2_H_LowPass_f00062_q10_a1    set 0.99951515       ; 7FF01D
iir2_H_LowPass_f00062_q10_a2    set -0.49955478       ; C00E97

; IIR2: mode=LowPass fc=88.3883 Q=10 gainDB=0 h=< 0.00001981 0.00003962 0.00001981 0.99929125 -0.49937049 >,< 0000A6 00014C 0000A6 7FE8C6 C014A1 >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_LowPass_f00088_q10_b0    set 0.00001981       ; 0000A6
iir2_H_LowPass_f00088_q10_b1    set 0.00003962       ; 00014C
iir2_H_LowPass_f00088_q10_b2    set 0.00001981       ; 0000A6
iir2_H_LowPass_f00088_q10_a1    set 0.99929125       ; 7FE8C6
iir2_H_LowPass_f00088_q10_a2    set -0.49937049       ; C014A1

; IIR2: mode=LowPass fc=125 Q=10 gainDB=0 h=< 0.00003961 0.00007922 0.00003961 0.99895155 -0.49910999 >,< 00014C 000298 00014C 7FDDA5 C01D2A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_LowPass_f00125_q10_b0    set 0.00003961       ; 00014C
iir2_H_LowPass_f00125_q10_b1    set 0.00007922       ; 000298
iir2_H_LowPass_f00125_q10_b2    set 0.00003961       ; 00014C
iir2_H_LowPass_f00125_q10_a1    set 0.99895155       ; 7FDDA5
iir2_H_LowPass_f00125_q10_a2    set -0.49910999       ; C01D2A

; IIR2: mode=LowPass fc=176.777 Q=10 gainDB=0 h=< 0.00007919 0.00015838 0.00007919 0.99842511 -0.49874187 >,< 000298 000530 000298 7FCC65 C0293A >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_LowPass_f00176_q10_b0    set 0.00007919       ; 000298
iir2_H_LowPass_f00176_q10_b1    set 0.00015838       ; 000530
iir2_H_LowPass_f00176_q10_b2    set 0.00007919       ; 000298
iir2_H_LowPass_f00176_q10_a1    set 0.99842511       ; 7FCC65
iir2_H_LowPass_f00176_q10_a2    set -0.49874187       ; C0293A

; IIR2: mode=LowPass fc=250 Q=10 gainDB=0 h=< 0.00015829 0.00031658 0.00015829 0.99758869 -0.49822185 >,< 00052F 000A5F 00052F 7FB0FC C03A45 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_LowPass_f00250_q10_b0    set 0.00015829       ; 00052F
iir2_H_LowPass_f00250_q10_b1    set 0.00031658       ; 000A5F
iir2_H_LowPass_f00250_q10_b2    set 0.00015829       ; 00052F
iir2_H_LowPass_f00250_q10_a1    set 0.99758869       ; 7FB0FC
iir2_H_LowPass_f00250_q10_a2    set -0.49822185       ; C03A45

; IIR2: mode=LowPass fc=353.553 Q=10 gainDB=0 h=< 0.00031631 0.00063263 0.00031631 0.99622245 -0.49748770 >,< 000A5D 0014BA 000A5D 7F8437 C05253 >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_LowPass_f00353_q10_b0    set 0.00031631       ; 000A5D
iir2_H_LowPass_f00353_q10_b1    set 0.00063263       ; 0014BA
iir2_H_LowPass_f00353_q10_b2    set 0.00031631       ; 000A5D
iir2_H_LowPass_f00353_q10_a1    set 0.99622245       ; 7F8437
iir2_H_LowPass_f00353_q10_a2    set -0.49748770       ; C05253

; IIR2: mode=LowPass fc=500 Q=10 gainDB=0 h=< 0.00063184 0.00126368 0.00063184 0.99392491 -0.49645226 >,< 0014B4 002968 0014B4 7F38EE C07441 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_LowPass_f00500_q10_b0    set 0.00063184       ; 0014B4
iir2_H_LowPass_f00500_q10_b1    set 0.00126368       ; 002968
iir2_H_LowPass_f00500_q10_b2    set 0.00063184       ; 0014B4
iir2_H_LowPass_f00500_q10_a1    set 0.99392491       ; 7F38EE
iir2_H_LowPass_f00500_q10_a2    set -0.49645226       ; C07441

; IIR2: mode=LowPass fc=707.107 Q=10 gainDB=0 h=< 0.00126129 0.00252259 0.00126129 0.98994915 -0.49499432 >,< 002954 0052A8 002954 7EB6A7 C0A407 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_LowPass_f00707_q10_b0    set 0.00126129       ; 002954
iir2_H_LowPass_f00707_q10_b1    set 0.00252259       ; 0052A8
iir2_H_LowPass_f00707_q10_b2    set 0.00126129       ; 002954
iir2_H_LowPass_f00707_q10_a1    set 0.98994915       ; 7EB6A7
iir2_H_LowPass_f00707_q10_a2    set -0.49499432       ; C0A407

; IIR2: mode=LowPass fc=1000 Q=10 gainDB=0 h=< 0.00251527 0.00503053 0.00251527 0.98288635 -0.49294742 >,< 00526B 00A4D7 00526B 7DCF38 C0E71A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_LowPass_f01000_q10_b0    set 0.00251527       ; 00526B
iir2_H_LowPass_f01000_q10_b1    set 0.00503053       ; 00A4D7
iir2_H_LowPass_f01000_q10_b2    set 0.00251527       ; 00526B
iir2_H_LowPass_f01000_q10_a1    set 0.98288635       ; 7DCF38
iir2_H_LowPass_f01000_q10_a2    set -0.49294742       ; C0E71A

; IIR2: mode=LowPass fc=1414.21 Q=10 gainDB=0 h=< 0.00500757 0.01001513 0.00500757 0.97005825 -0.49008852 >,< 00A416 01482D 00A416 7C2ADE C144C8 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_LowPass_f01414_q10_b0    set 0.00500757       ; 00A416
iir2_H_LowPass_f01414_q10_b1    set 0.01001513       ; 01482D
iir2_H_LowPass_f01414_q10_b2    set 0.00500757       ; 00A416
iir2_H_LowPass_f01414_q10_a1    set 0.97005825       ; 7C2ADE
iir2_H_LowPass_f01414_q10_a2    set -0.49008852       ; C144C8

; IIR2: mode=LowPass fc=2000 Q=10 gainDB=0 h=< 0.00994140 0.01988281 0.00994140 0.94636796 -0.48613357 >,< 0145C2 028B85 0145C2 792296 C1C660 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_LowPass_f02000_q10_b0    set 0.00994140       ; 0145C2
iir2_H_LowPass_f02000_q10_b1    set 0.01988281       ; 028B85
iir2_H_LowPass_f02000_q10_b2    set 0.00994140       ; 0145C2
iir2_H_LowPass_f02000_q10_a1    set 0.94636796       ; 792296
iir2_H_LowPass_f02000_q10_a2    set -0.48613357       ; C1C660

; IIR2: mode=LowPass fc=2828.43 Q=10 gainDB=0 h=< 0.01964086 0.03928172 0.01964086 0.90219760 -0.48076104 >,< 028397 05072E 028397 737B36 C2766C >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_LowPass_f02828_q10_b0    set 0.01964086       ; 028397
iir2_H_LowPass_f02828_q10_b1    set 0.03928172       ; 05072E
iir2_H_LowPass_f02828_q10_b2    set 0.01964086       ; 028397
iir2_H_LowPass_f02828_q10_a1    set 0.90219760       ; 737B36
iir2_H_LowPass_f02828_q10_a2    set -0.48076104       ; C2766C

; IIR2: mode=LowPass fc=4000 Q=10 gainDB=0 h=< 0.03847338 0.07694676 0.03847338 0.81982696 -0.47372047 >,< 04ECB2 09D964 04ECB2 68F017 C35D21 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_LowPass_f04000_q10_b0    set 0.03847338       ; 04ECB2
iir2_H_LowPass_f04000_q10_b1    set 0.07694676       ; 09D964
iir2_H_LowPass_f04000_q10_b2    set 0.03847338       ; 04ECB2
iir2_H_LowPass_f04000_q10_a1    set 0.81982696       ; 68F017
iir2_H_LowPass_f04000_q10_a2    set -0.47372047       ; C35D21

; IIR2: mode=LowPass fc=5656.85 Q=10 gainDB=0 h=< 0.07421768 0.14843537 0.07421768 0.66829638 -0.46516712 >,< 097FF7 12FFEE 097FF7 558ABC C47568 >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_LowPass_f05656_q10_b0    set 0.07421768       ; 097FF7
iir2_H_LowPass_f05656_q10_b1    set 0.14843537       ; 12FFEE
iir2_H_LowPass_f05656_q10_b2    set 0.07421768       ; 097FF7
iir2_H_LowPass_f05656_q10_a1    set 0.66829638       ; 558ABC
iir2_H_LowPass_f05656_q10_a2    set -0.46516712       ; C47568

; IIR2: mode=LowPass fc=8000 Q=10 gainDB=0 h=< 0.13922998 0.27845995 0.13922998 0.39960913 -0.45652903 >,< 11D249 23A493 11D249 332664 C59075 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_LowPass_f08000_q10_b0    set 0.13922998       ; 11D249
iir2_H_LowPass_f08000_q10_b1    set 0.27845995       ; 23A493
iir2_H_LowPass_f08000_q10_b2    set 0.13922998       ; 11D249
iir2_H_LowPass_f08000_q10_a1    set 0.39960913       ; 332664
iir2_H_LowPass_f08000_q10_a2    set -0.45652903       ; C59075

; IIR2: mode=LowPass fc=11313.7 Q=10 gainDB=0 h=< 0.24789135 0.49578271 0.24789135 -0.03916498 -0.45240043 >,< 1FBAE7 3F75CE 1FBAE7 FAFCA5 C617BE >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_LowPass_f11313_q10_b0    set 0.24789135       ; 1FBAE7
iir2_H_LowPass_f11313_q10_b1    set 0.49578271       ; 3F75CE
iir2_H_LowPass_f11313_q10_b2    set 0.24789135       ; 1FBAE7
iir2_H_LowPass_f11313_q10_a1    set -0.03916498       ; FAFCA5
iir2_H_LowPass_f11313_q10_a2    set -0.45240043       ; C617BE

; IIR2: mode=LowPass fc=16000 Q=10 gainDB=0 h=< 0.39763495 0.79526991 0.39763495 -0.62712308 -0.46341673 >,< 32E5B3 65CB67 32E5B3 AFBA6F C4AEC3 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_LowPass_f16000_q10_b0    set 0.39763495       ; 32E5B3
iir2_H_LowPass_f16000_q10_b1    set 0.79526991       ; 65CB67
iir2_H_LowPass_f16000_q10_b2    set 0.39763495       ; 32E5B3
iir2_H_LowPass_f16000_q10_a1    set -0.62712308       ; AFBA6F
iir2_H_LowPass_f16000_q10_a2    set -0.46341673       ; C4AEC3

; IIR2: mode=LowPass fc=62.5 Q=0.707107 gainDB=0 h=< 0.00000984 0.00001969 0.00000984 0.99317251 -0.49321189 >,< 000052 0000A5 000052 7F2047 C0DE6F >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_LowPass_f00062_q00_b0    set 0.00000984       ; 000052
iir2_H_LowPass_f00062_q00_b1    set 0.00001969       ; 0000A5
iir2_H_LowPass_f00062_q00_b2    set 0.00000984       ; 000052
iir2_H_LowPass_f00062_q00_a1    set 0.99317251       ; 7F2047
iir2_H_LowPass_f00062_q00_a2    set -0.49321189       ; C0DE6F

; IIR2: mode=LowPass fc=88.3883 Q=0.707107 gainDB=0 h=< 0.00001963 0.00003927 0.00001963 0.99034867 -0.49042720 >,< 0000A4 000149 0000A4 7EC3BF C139AF >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_LowPass_f00088_q00_b0    set 0.00001963       ; 0000A4
iir2_H_LowPass_f00088_q00_b1    set 0.00003927       ; 000149
iir2_H_LowPass_f00088_q00_b2    set 0.00001963       ; 0000A4
iir2_H_LowPass_f00088_q00_a1    set 0.99034867       ; 7EC3BF
iir2_H_LowPass_f00088_q00_a2    set -0.49042720       ; C139AF

; IIR2: mode=LowPass fc=125 Q=0.707107 gainDB=0 h=< 0.00003911 0.00007822 0.00003911 0.98635939 -0.48651584 >,< 000148 000290 000148 7E4106 C1B9DA >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_LowPass_f00125_q00_b0    set 0.00003911       ; 000148
iir2_H_LowPass_f00125_q00_b1    set 0.00007822       ; 000290
iir2_H_LowPass_f00125_q00_b2    set 0.00003911       ; 000148
iir2_H_LowPass_f00125_q00_a1    set 0.98635939       ; 7E4106
iir2_H_LowPass_f00125_q00_a2    set -0.48651584       ; C1B9DA

; IIR2: mode=LowPass fc=176.777 Q=0.707107 gainDB=0 h=< 0.00007779 0.00015557 0.00007779 0.98072627 -0.48103742 >,< 00028C 000519 00028C 7D8870 C26D5E >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_LowPass_f00176_q00_b0    set 0.00007779       ; 00028C
iir2_H_LowPass_f00176_q00_b1    set 0.00015557       ; 000519
iir2_H_LowPass_f00176_q00_b2    set 0.00007779       ; 00028C
iir2_H_LowPass_f00176_q00_a1    set 0.98072627       ; 7D8870
iir2_H_LowPass_f00176_q00_a2    set -0.48103742       ; C26D5E

; IIR2: mode=LowPass fc=250 Q=0.707107 gainDB=0 h=< 0.00015435 0.00030871 0.00015435 0.97277718 -0.47339460 >,< 00050E 000A1D 00050E 7C83F6 C367CF >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_LowPass_f00250_q00_b0    set 0.00015435       ; 00050E
iir2_H_LowPass_f00250_q00_b1    set 0.00030871       ; 000A1D
iir2_H_LowPass_f00250_q00_b2    set 0.00015435       ; 00050E
iir2_H_LowPass_f00250_q00_a1    set 0.97277718       ; 7C83F6
iir2_H_LowPass_f00250_q00_a2    set -0.47339460       ; C367CF

; IIR2: mode=LowPass fc=353.553 Q=0.707107 gainDB=0 h=< 0.00030531 0.00061062 0.00030531 0.96157073 -0.46279198 >,< 000A01 001402 000A01 7B14C0 C4C33C >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_LowPass_f00353_q00_b0    set 0.00030531       ; 000A01
iir2_H_LowPass_f00353_q00_b1    set 0.00061062       ; 001402
iir2_H_LowPass_f00353_q00_b2    set 0.00030531       ; 000A01
iir2_H_LowPass_f00353_q00_a1    set 0.96157073       ; 7B14C0
iir2_H_LowPass_f00353_q00_a2    set -0.46279198       ; C4C33C

; IIR2: mode=LowPass fc=500 Q=0.707107 gainDB=0 h=< 0.00060124 0.00120248 0.00060124 0.94579441 -0.44819937 >,< 0013B3 002767 0013B3 790FCA C6A168 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_LowPass_f00500_q00_b0    set 0.00060124       ; 0013B3
iir2_H_LowPass_f00500_q00_b1    set 0.00120248       ; 002767
iir2_H_LowPass_f00500_q00_b2    set 0.00060124       ; 0013B3
iir2_H_LowPass_f00500_q00_a1    set 0.94579441       ; 790FCA
iir2_H_LowPass_f00500_q00_a2    set -0.44819937       ; C6A168

; IIR2: mode=LowPass fc=707.107 Q=0.707107 gainDB=0 h=< 0.00117680 0.00235359 0.00117680 0.92363081 -0.42833799 >,< 00268F 004D1F 00268F 763989 C92C39 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_LowPass_f00707_q00_b0    set 0.00117680       ; 00268F
iir2_H_LowPass_f00707_q00_b1    set 0.00235359       ; 004D1F
iir2_H_LowPass_f00707_q00_b2    set 0.00117680       ; 00268F
iir2_H_LowPass_f00707_q00_a1    set 0.92363081       ; 763989
iir2_H_LowPass_f00707_q00_a2    set -0.42833799       ; C92C39

; IIR2: mode=LowPass fc=1000 Q=0.707107 gainDB=0 h=< 0.00228419 0.00456838 0.00228419 0.89258956 -0.40172633 >,< 004AD9 0095B2 004AD9 724060 CC943C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_LowPass_f01000_q00_b0    set 0.00228419       ; 004AD9
iir2_H_LowPass_f01000_q00_b1    set 0.00456838       ; 0095B2
iir2_H_LowPass_f01000_q00_b2    set 0.00228419       ; 004AD9
iir2_H_LowPass_f01000_q00_a1    set 0.89258956       ; 724060
iir2_H_LowPass_f01000_q00_a2    set -0.40172633       ; CC943C

; IIR2: mode=LowPass fc=1414.21 Q=0.707107 gainDB=0 h=< 0.00438425 0.00876851 0.00438425 0.84931088 -0.36684790 >,< 008FA9 011F53 008FA9 6CB638 D10B21 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_LowPass_f01414_q00_b0    set 0.00438425       ; 008FA9
iir2_H_LowPass_f01414_q00_b1    set 0.00876851       ; 011F53
iir2_H_LowPass_f01414_q00_b2    set 0.00438425       ; 008FA9
iir2_H_LowPass_f01414_q00_a1    set 0.84931088       ; 6CB638
iir2_H_LowPass_f01414_q00_a2    set -0.36684790       ; D10B21

; IIR2: mode=LowPass fc=2000 Q=0.707107 gainDB=0 h=< 0.00829210 0.01658419 0.00829210 0.78936286 -0.32253125 >,< 010FB7 021F6E 010FB7 6509D7 D6B74C >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_LowPass_f02000_q00_b0    set 0.00829210       ; 010FB7
iir2_H_LowPass_f02000_q00_b1    set 0.01658419       ; 021F6E
iir2_H_LowPass_f02000_q00_b2    set 0.00829210       ; 010FB7
iir2_H_LowPass_f02000_q00_a1    set 0.78936286       ; 6509D7
iir2_H_LowPass_f02000_q00_a2    set -0.32253125       ; D6B74C

; IIR2: mode=LowPass fc=2828.43 Q=0.707107 gainDB=0 h=< 0.01539295 0.03078589 0.01539295 0.70707082 -0.26864261 >,< 01F865 03F0CA 01F865 5A814C DD9D1F >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_LowPass_f02828_q00_b0    set 0.01539295       ; 01F865
iir2_H_LowPass_f02828_q00_b1    set 0.03078589       ; 03F0CA
iir2_H_LowPass_f02828_q00_b2    set 0.01539295       ; 01F865
iir2_H_LowPass_f02828_q00_a1    set 0.70707082       ; 5A814C
iir2_H_LowPass_f02828_q00_a2    set -0.26864261       ; DD9D1F

; IIR2: mode=LowPass fc=4000 Q=0.707107 gainDB=0 h=< 0.02794091 0.05588181 0.02794091 0.59539110 -0.20715472 >,< 039391 072722 039391 4C35C6 E57BF5 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_LowPass_f04000_q00_b0    set 0.02794091       ; 039391
iir2_H_LowPass_f04000_q00_b1    set 0.05588181       ; 072722
iir2_H_LowPass_f04000_q00_b2    set 0.02794091       ; 039391
iir2_H_LowPass_f04000_q00_a1    set 0.59539110       ; 4C35C6
iir2_H_LowPass_f04000_q00_a2    set -0.20715472       ; E57BF5

; IIR2: mode=LowPass fc=5656.85 Q=0.707107 gainDB=0 h=< 0.04949016 0.09898033 0.04949016 0.44563633 -0.14359698 >,< 0655B1 0CAB63 0655B1 390A9C ED9E9E >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_LowPass_f05656_q00_b0    set 0.04949016       ; 0655B1
iir2_H_LowPass_f05656_q00_b1    set 0.09898033       ; 0CAB63
iir2_H_LowPass_f05656_q00_b2    set 0.04949016       ; 0655B1
iir2_H_LowPass_f05656_q00_a1    set 0.44563633       ; 390A9C
iir2_H_LowPass_f05656_q00_a2    set -0.14359698       ; ED9E9E

; IIR2: mode=LowPass fc=8000 Q=0.707107 gainDB=0 h=< 0.08575648 0.17151296 0.08575648 0.24613286 -0.08915878 >,< 0AFA11 15F423 0AFA11 1F8148 F49672 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_LowPass_f08000_q00_b0    set 0.08575648       ; 0AFA11
iir2_H_LowPass_f08000_q00_b1    set 0.17151296       ; 15F423
iir2_H_LowPass_f08000_q00_b2    set 0.08575648       ; 0AFA11
iir2_H_LowPass_f08000_q00_a1    set 0.24613286       ; 1F8148
iir2_H_LowPass_f08000_q00_a2    set -0.08915878       ; F49672

; IIR2: mode=LowPass fc=11313.7 Q=0.707107 gainDB=0 h=< 0.14731136 0.29462272 0.14731136 -0.02327410 -0.06597134 >,< 12DB19 25B632 12DB19 FD055B F78E41 >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_LowPass_f11313_q00_b0    set 0.14731136       ; 12DB19
iir2_H_LowPass_f11313_q00_b1    set 0.29462272       ; 25B632
iir2_H_LowPass_f11313_q00_b2    set 0.14731136       ; 12DB19
iir2_H_LowPass_f11313_q00_a1    set -0.02327410       ; FD055B
iir2_H_LowPass_f11313_q00_a2    set -0.06597134       ; F78E41

; IIR2: mode=LowPass fc=16000 Q=0.707107 gainDB=0 h=< 0.26078648 0.52157295 0.26078648 -0.41129488 -0.13185103 >,< 216173 42C2E7 216173 CB5AB1 EF1F82 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_LowPass_f16000_q00_b0    set 0.26078648       ; 216173
iir2_H_LowPass_f16000_q00_b1    set 0.52157295       ; 42C2E7
iir2_H_LowPass_f16000_q00_b2    set 0.26078648       ; 216173
iir2_H_LowPass_f16000_q00_a1    set -0.41129488       ; CB5AB1
iir2_H_LowPass_f16000_q00_a2    set -0.13185103       ; EF1F82

; IIR2: mode=LowPass fc=62.5 Q=5 gainDB=0 h=< 0.00000990 0.00001981 0.00000990 0.99906924 -0.49910885 >,< 000053 0000A6 000053 7FE180 C01D34 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_LowPass_f00062_q05_b0    set 0.00000990       ; 000053
iir2_H_LowPass_f00062_q05_b1    set 0.00001981       ; 0000A6
iir2_H_LowPass_f00062_q05_b2    set 0.00000990       ; 000053
iir2_H_LowPass_f00062_q05_a1    set 0.99906924       ; 7FE180
iir2_H_LowPass_f00062_q05_a2    set -0.49910885       ; C01D34

; IIR2: mode=LowPass fc=88.3883 Q=5 gainDB=0 h=< 0.00001980 0.00003960 0.00001980 0.99866101 -0.49874020 >,< 0000A6 00014C 0000A6 7FD41F C02948 >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_LowPass_f00088_q05_b0    set 0.00001980       ; 0000A6
iir2_H_LowPass_f00088_q05_b1    set 0.00003960       ; 00014C
iir2_H_LowPass_f00088_q05_b2    set 0.00001980       ; 0000A6
iir2_H_LowPass_f00088_q05_a1    set 0.99866101       ; 7FD41F
iir2_H_LowPass_f00088_q05_a2    set -0.49874020       ; C02948

; IIR2: mode=LowPass fc=125 Q=5 gainDB=0 h=< 0.00003958 0.00007915 0.00003958 0.99806105 -0.49821935 >,< 00014B 000297 00014B 7FC077 C03A5A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_LowPass_f00125_q05_b0    set 0.00003958       ; 00014B
iir2_H_LowPass_f00125_q05_b1    set 0.00007915       ; 000297
iir2_H_LowPass_f00125_q05_b2    set 0.00003958       ; 00014B
iir2_H_LowPass_f00125_q05_a1    set 0.99806105       ; 7FC077
iir2_H_LowPass_f00125_q05_a2    set -0.49821935       ; C03A5A

; IIR2: mode=LowPass fc=176.777 Q=5 gainDB=0 h=< 0.00007909 0.00015818 0.00007909 0.99716741 -0.49748377 >,< 000297 00052E 000297 7FA32E C05274 >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_LowPass_f00176_q05_b0    set 0.00007909       ; 000297
iir2_H_LowPass_f00176_q05_b1    set 0.00015818       ; 00052E
iir2_H_LowPass_f00176_q05_b2    set 0.00007909       ; 000297
iir2_H_LowPass_f00176_q05_a1    set 0.99716741       ; 7FA32E
iir2_H_LowPass_f00176_q05_a2    set -0.49748377       ; C05274

; IIR2: mode=LowPass fc=250 Q=5 gainDB=0 h=< 0.00015801 0.00031602 0.00015801 0.99581356 -0.49644560 >,< 00052D 000A5A 00052D 7F76D1 C07479 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_LowPass_f00250_q05_b0    set 0.00015801       ; 00052D
iir2_H_LowPass_f00250_q05_b1    set 0.00031602       ; 000A5A
iir2_H_LowPass_f00250_q05_b2    set 0.00015801       ; 00052D
iir2_H_LowPass_f00250_q05_a1    set 0.99581356       ; 7F76D1
iir2_H_LowPass_f00250_q05_a2    set -0.49644560       ; C07479

; IIR2: mode=LowPass fc=353.553 Q=5 gainDB=0 h=< 0.00031552 0.00063104 0.00031552 0.99371968 -0.49498176 >,< 000A56 0014AD 000A56 7F3235 C0A470 >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_LowPass_f00353_q05_b0    set 0.00031552       ; 000A56
iir2_H_LowPass_f00353_q05_b1    set 0.00063104       ; 0014AD
iir2_H_LowPass_f00353_q05_b2    set 0.00031552       ; 000A56
iir2_H_LowPass_f00353_q05_a1    set 0.99371968       ; 7F3235
iir2_H_LowPass_f00353_q05_a2    set -0.49498176       ; C0A470

; IIR2: mode=LowPass fc=500 Q=5 gainDB=0 h=< 0.00062960 0.00125920 0.00062960 0.99040244 -0.49292083 >,< 0014A1 002942 0014A1 7EC582 C0E7F9 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_LowPass_f00500_q05_b0    set 0.00062960       ; 0014A1
iir2_H_LowPass_f00500_q05_b1    set 0.00125920       ; 002942
iir2_H_LowPass_f00500_q05_b2    set 0.00062960       ; 0014A1
iir2_H_LowPass_f00500_q05_a1    set 0.99040244       ; 7EC582
iir2_H_LowPass_f00500_q05_a2    set -0.49292083       ; C0E7F9

; IIR2: mode=LowPass fc=707.107 Q=5 gainDB=0 h=< 0.00125499 0.00250999 0.00125499 0.98500620 -0.49002618 >,< 00291F 00523F 00291F 7E14AF C146D3 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_LowPass_f00707_q05_b0    set 0.00125499       ; 00291F
iir2_H_LowPass_f00707_q05_b1    set 0.00250999       ; 00523F
iir2_H_LowPass_f00707_q05_b2    set 0.00125499       ; 00291F
iir2_H_LowPass_f00707_q05_a1    set 0.98500620       ; 7E14AF
iir2_H_LowPass_f00707_q05_a2    set -0.49002618       ; C146D3

; IIR2: mode=LowPass fc=1000 Q=5 gainDB=0 h=< 0.00249761 0.00499522 0.00249761 0.97598592 -0.48597635 >,< 0051D7 00A3AE 0051D7 7CED1B C1CB87 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_LowPass_f01000_q05_b0    set 0.00249761       ; 0051D7
iir2_H_LowPass_f01000_q05_b1    set 0.00499522       ; 00A3AE
iir2_H_LowPass_f01000_q05_b2    set 0.00249761       ; 0051D7
iir2_H_LowPass_f01000_q05_a1    set 0.97598592       ; 7CED1B
iir2_H_LowPass_f01000_q05_a2    set -0.48597635       ; C1CB87

; IIR2: mode=LowPass fc=1414.21 Q=5 gainDB=0 h=< 0.00495830 0.00991660 0.00495830 0.96051432 -0.48034752 >,< 00A279 0144F2 00A279 7AF222 C283F9 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_LowPass_f01414_q05_b0    set 0.00495830       ; 00A279
iir2_H_LowPass_f01414_q05_b1    set 0.00991660       ; 0144F2
iir2_H_LowPass_f01414_q05_b2    set 0.00495830       ; 00A279
iir2_H_LowPass_f01414_q05_a1    set 0.96051432       ; 7AF222
iir2_H_LowPass_f01414_q05_a2    set -0.48034752       ; C283F9

; IIR2: mode=LowPass fc=2000 Q=5 gainDB=0 h=< 0.00980510 0.01961020 0.00980510 0.93339277 -0.47261317 >,< 01414B 028296 01414B 77796A C3816A >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_LowPass_f02000_q05_b0    set 0.00980510       ; 01414B
iir2_H_LowPass_f02000_q05_b1    set 0.01961020       ; 028296
iir2_H_LowPass_f02000_q05_b2    set 0.00980510       ; 01414B
iir2_H_LowPass_f02000_q05_a1    set 0.93339277       ; 77796A
iir2_H_LowPass_f02000_q05_a2    set -0.47261317       ; C3816A

; IIR2: mode=LowPass fc=2828.43 Q=5 gainDB=0 h=< 0.01926921 0.03853843 0.01926921 0.88512611 -0.46220297 >,< 027769 04EED3 027769 714BD0 C4D689 >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_LowPass_f02828_q05_b0    set 0.01926921       ; 027769
iir2_H_LowPass_f02828_q05_b1    set 0.03853843       ; 04EED3
iir2_H_LowPass_f02828_q05_b2    set 0.01926921       ; 027769
iir2_H_LowPass_f02828_q05_a1    set 0.88512611       ; 714BD0
iir2_H_LowPass_f02828_q05_a2    set -0.46220297       ; C4D689

; IIR2: mode=LowPass fc=4000 Q=5 gainDB=0 h=< 0.03748581 0.07497161 0.03748581 0.79878283 -0.44872606 >,< 04CC55 0998AB 04CC55 663E84 C69025 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_LowPass_f04000_q05_b0    set 0.03748581       ; 04CC55
iir2_H_LowPass_f04000_q05_b1    set 0.07497161       ; 0998AB
iir2_H_LowPass_f04000_q05_b2    set 0.03748581       ; 04CC55
iir2_H_LowPass_f04000_q05_a1    set 0.79878283       ; 663E84
iir2_H_LowPass_f04000_q05_a2    set -0.44872606       ; C69025

; IIR2: mode=LowPass fc=5656.85 Q=5 gainDB=0 h=< 0.07171345 0.14342691 0.07171345 0.64574691 -0.43260072 >,< 092DE8 125BD0 092DE8 52A7D5 C8A08A >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_LowPass_f05656_q05_b0    set 0.07171345       ; 092DE8
iir2_H_LowPass_f05656_q05_b1    set 0.14342691       ; 125BD0
iir2_H_LowPass_f05656_q05_b2    set 0.07171345       ; 092DE8
iir2_H_LowPass_f05656_q05_a1    set 0.64574691       ; 52A7D5
iir2_H_LowPass_f05656_q05_a2    set -0.43260072       ; C8A08A

; IIR2: mode=LowPass fc=8000 Q=5 gainDB=0 h=< 0.13341576 0.26683153 0.13341576 0.38292153 -0.41658458 >,< 1113C4 222789 1113C4 310392 CAAD5C >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_LowPass_f08000_q05_b0    set 0.13341576       ; 1113C4
iir2_H_LowPass_f08000_q05_b1    set 0.26683153       ; 222789
iir2_H_LowPass_f08000_q05_b2    set 0.13341576       ; 1113C4
iir2_H_LowPass_f08000_q05_a1    set 0.38292153       ; 310392
iir2_H_LowPass_f08000_q05_a2    set -0.41658458       ; CAAD5C

; IIR2: mode=LowPass fc=11313.7 Q=5 gainDB=0 h=< 0.23660108 0.47320217 0.23660108 -0.03738121 -0.40902313 >,< 1E48F1 3C91E3 1E48F1 FB3718 CBA522 >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_LowPass_f11313_q05_b0    set 0.23660108       ; 1E48F1
iir2_H_LowPass_f11313_q05_b1    set 0.47320217       ; 3C91E3
iir2_H_LowPass_f11313_q05_b2    set 0.23660108       ; 1E48F1
iir2_H_LowPass_f11313_q05_a1    set -0.03738121       ; FB3718
iir2_H_LowPass_f11313_q05_a2    set -0.40902313       ; CBA522

; IIR2: mode=LowPass fc=16000 Q=5 gainDB=0 h=< 0.38356770 0.76713541 0.38356770 -0.60493716 -0.42933365 >,< 3118BF 62317E 3118BF B2916C C90B99 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_LowPass_f16000_q05_b0    set 0.38356770       ; 3118BF
iir2_H_LowPass_f16000_q05_b1    set 0.76713541       ; 62317E
iir2_H_LowPass_f16000_q05_b2    set 0.38356770       ; 3118BF
iir2_H_LowPass_f16000_q05_a1    set -0.60493716       ; B2916C
iir2_H_LowPass_f16000_q05_a2    set -0.42933365       ; C90B99

; IIR2: mode=LowPass fc=62.5 Q=10 gainDB=0 h=< 0.00000991 0.00001981 0.00000991 0.99951515 -0.49955478 >,< 000053 0000A6 000053 7FF01D C00E97 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_LowPass_f00062_q10_b0    set 0.00000991       ; 000053
iir2_H_LowPass_f00062_q10_b1    set 0.00001981       ; 0000A6
iir2_H_LowPass_f00062_q10_b2    set 0.00000991       ; 000053
iir2_H_LowPass_f00062_q10_a1    set 0.99951515       ; 7FF01D
iir2_H_LowPass_f00062_q10_a2    set -0.49955478       ; C00E97

; IIR2: mode=LowPass fc=88.3883 Q=10 gainDB=0 h=< 0.00001981 0.00003962 0.00001981 0.99929125 -0.49937049 >,< 0000A6 00014C 0000A6 7FE8C6 C014A1 >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_LowPass_f00088_q10_b0    set 0.00001981       ; 0000A6
iir2_H_LowPass_f00088_q10_b1    set 0.00003962       ; 00014C
iir2_H_LowPass_f00088_q10_b2    set 0.00001981       ; 0000A6
iir2_H_LowPass_f00088_q10_a1    set 0.99929125       ; 7FE8C6
iir2_H_LowPass_f00088_q10_a2    set -0.49937049       ; C014A1

; IIR2: mode=LowPass fc=125 Q=10 gainDB=0 h=< 0.00003961 0.00007922 0.00003961 0.99895155 -0.49910999 >,< 00014C 000298 00014C 7FDDA5 C01D2A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_LowPass_f00125_q10_b0    set 0.00003961       ; 00014C
iir2_H_LowPass_f00125_q10_b1    set 0.00007922       ; 000298
iir2_H_LowPass_f00125_q10_b2    set 0.00003961       ; 00014C
iir2_H_LowPass_f00125_q10_a1    set 0.99895155       ; 7FDDA5
iir2_H_LowPass_f00125_q10_a2    set -0.49910999       ; C01D2A

; IIR2: mode=LowPass fc=176.777 Q=10 gainDB=0 h=< 0.00007919 0.00015838 0.00007919 0.99842511 -0.49874187 >,< 000298 000530 000298 7FCC65 C0293A >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_LowPass_f00176_q10_b0    set 0.00007919       ; 000298
iir2_H_LowPass_f00176_q10_b1    set 0.00015838       ; 000530
iir2_H_LowPass_f00176_q10_b2    set 0.00007919       ; 000298
iir2_H_LowPass_f00176_q10_a1    set 0.99842511       ; 7FCC65
iir2_H_LowPass_f00176_q10_a2    set -0.49874187       ; C0293A

; IIR2: mode=LowPass fc=250 Q=10 gainDB=0 h=< 0.00015829 0.00031658 0.00015829 0.99758869 -0.49822185 >,< 00052F 000A5F 00052F 7FB0FC C03A45 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_LowPass_f00250_q10_b0    set 0.00015829       ; 00052F
iir2_H_LowPass_f00250_q10_b1    set 0.00031658       ; 000A5F
iir2_H_LowPass_f00250_q10_b2    set 0.00015829       ; 00052F
iir2_H_LowPass_f00250_q10_a1    set 0.99758869       ; 7FB0FC
iir2_H_LowPass_f00250_q10_a2    set -0.49822185       ; C03A45

; IIR2: mode=LowPass fc=353.553 Q=10 gainDB=0 h=< 0.00031631 0.00063263 0.00031631 0.99622245 -0.49748770 >,< 000A5D 0014BA 000A5D 7F8437 C05253 >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_LowPass_f00353_q10_b0    set 0.00031631       ; 000A5D
iir2_H_LowPass_f00353_q10_b1    set 0.00063263       ; 0014BA
iir2_H_LowPass_f00353_q10_b2    set 0.00031631       ; 000A5D
iir2_H_LowPass_f00353_q10_a1    set 0.99622245       ; 7F8437
iir2_H_LowPass_f00353_q10_a2    set -0.49748770       ; C05253

; IIR2: mode=LowPass fc=500 Q=10 gainDB=0 h=< 0.00063184 0.00126368 0.00063184 0.99392491 -0.49645226 >,< 0014B4 002968 0014B4 7F38EE C07441 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_LowPass_f00500_q10_b0    set 0.00063184       ; 0014B4
iir2_H_LowPass_f00500_q10_b1    set 0.00126368       ; 002968
iir2_H_LowPass_f00500_q10_b2    set 0.00063184       ; 0014B4
iir2_H_LowPass_f00500_q10_a1    set 0.99392491       ; 7F38EE
iir2_H_LowPass_f00500_q10_a2    set -0.49645226       ; C07441

; IIR2: mode=LowPass fc=707.107 Q=10 gainDB=0 h=< 0.00126129 0.00252259 0.00126129 0.98994915 -0.49499432 >,< 002954 0052A8 002954 7EB6A7 C0A407 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_LowPass_f00707_q10_b0    set 0.00126129       ; 002954
iir2_H_LowPass_f00707_q10_b1    set 0.00252259       ; 0052A8
iir2_H_LowPass_f00707_q10_b2    set 0.00126129       ; 002954
iir2_H_LowPass_f00707_q10_a1    set 0.98994915       ; 7EB6A7
iir2_H_LowPass_f00707_q10_a2    set -0.49499432       ; C0A407

; IIR2: mode=LowPass fc=1000 Q=10 gainDB=0 h=< 0.00251527 0.00503053 0.00251527 0.98288635 -0.49294742 >,< 00526B 00A4D7 00526B 7DCF38 C0E71A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_LowPass_f01000_q10_b0    set 0.00251527       ; 00526B
iir2_H_LowPass_f01000_q10_b1    set 0.00503053       ; 00A4D7
iir2_H_LowPass_f01000_q10_b2    set 0.00251527       ; 00526B
iir2_H_LowPass_f01000_q10_a1    set 0.98288635       ; 7DCF38
iir2_H_LowPass_f01000_q10_a2    set -0.49294742       ; C0E71A

; IIR2: mode=LowPass fc=1414.21 Q=10 gainDB=0 h=< 0.00500757 0.01001513 0.00500757 0.97005825 -0.49008852 >,< 00A416 01482D 00A416 7C2ADE C144C8 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_LowPass_f01414_q10_b0    set 0.00500757       ; 00A416
iir2_H_LowPass_f01414_q10_b1    set 0.01001513       ; 01482D
iir2_H_LowPass_f01414_q10_b2    set 0.00500757       ; 00A416
iir2_H_LowPass_f01414_q10_a1    set 0.97005825       ; 7C2ADE
iir2_H_LowPass_f01414_q10_a2    set -0.49008852       ; C144C8

; IIR2: mode=LowPass fc=2000 Q=10 gainDB=0 h=< 0.00994140 0.01988281 0.00994140 0.94636796 -0.48613357 >,< 0145C2 028B85 0145C2 792296 C1C660 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_LowPass_f02000_q10_b0    set 0.00994140       ; 0145C2
iir2_H_LowPass_f02000_q10_b1    set 0.01988281       ; 028B85
iir2_H_LowPass_f02000_q10_b2    set 0.00994140       ; 0145C2
iir2_H_LowPass_f02000_q10_a1    set 0.94636796       ; 792296
iir2_H_LowPass_f02000_q10_a2    set -0.48613357       ; C1C660

; IIR2: mode=LowPass fc=2828.43 Q=10 gainDB=0 h=< 0.01964086 0.03928172 0.01964086 0.90219760 -0.48076104 >,< 028397 05072E 028397 737B36 C2766C >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_LowPass_f02828_q10_b0    set 0.01964086       ; 028397
iir2_H_LowPass_f02828_q10_b1    set 0.03928172       ; 05072E
iir2_H_LowPass_f02828_q10_b2    set 0.01964086       ; 028397
iir2_H_LowPass_f02828_q10_a1    set 0.90219760       ; 737B36
iir2_H_LowPass_f02828_q10_a2    set -0.48076104       ; C2766C

; IIR2: mode=LowPass fc=4000 Q=10 gainDB=0 h=< 0.03847338 0.07694676 0.03847338 0.81982696 -0.47372047 >,< 04ECB2 09D964 04ECB2 68F017 C35D21 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_LowPass_f04000_q10_b0    set 0.03847338       ; 04ECB2
iir2_H_LowPass_f04000_q10_b1    set 0.07694676       ; 09D964
iir2_H_LowPass_f04000_q10_b2    set 0.03847338       ; 04ECB2
iir2_H_LowPass_f04000_q10_a1    set 0.81982696       ; 68F017
iir2_H_LowPass_f04000_q10_a2    set -0.47372047       ; C35D21

; IIR2: mode=LowPass fc=5656.85 Q=10 gainDB=0 h=< 0.07421768 0.14843537 0.07421768 0.66829638 -0.46516712 >,< 097FF7 12FFEE 097FF7 558ABC C47568 >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_LowPass_f05656_q10_b0    set 0.07421768       ; 097FF7
iir2_H_LowPass_f05656_q10_b1    set 0.14843537       ; 12FFEE
iir2_H_LowPass_f05656_q10_b2    set 0.07421768       ; 097FF7
iir2_H_LowPass_f05656_q10_a1    set 0.66829638       ; 558ABC
iir2_H_LowPass_f05656_q10_a2    set -0.46516712       ; C47568

; IIR2: mode=LowPass fc=8000 Q=10 gainDB=0 h=< 0.13922998 0.27845995 0.13922998 0.39960913 -0.45652903 >,< 11D249 23A493 11D249 332664 C59075 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_LowPass_f08000_q10_b0    set 0.13922998       ; 11D249
iir2_H_LowPass_f08000_q10_b1    set 0.27845995       ; 23A493
iir2_H_LowPass_f08000_q10_b2    set 0.13922998       ; 11D249
iir2_H_LowPass_f08000_q10_a1    set 0.39960913       ; 332664
iir2_H_LowPass_f08000_q10_a2    set -0.45652903       ; C59075

; IIR2: mode=LowPass fc=11313.7 Q=10 gainDB=0 h=< 0.24789135 0.49578271 0.24789135 -0.03916498 -0.45240043 >,< 1FBAE7 3F75CE 1FBAE7 FAFCA5 C617BE >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_LowPass_f11313_q10_b0    set 0.24789135       ; 1FBAE7
iir2_H_LowPass_f11313_q10_b1    set 0.49578271       ; 3F75CE
iir2_H_LowPass_f11313_q10_b2    set 0.24789135       ; 1FBAE7
iir2_H_LowPass_f11313_q10_a1    set -0.03916498       ; FAFCA5
iir2_H_LowPass_f11313_q10_a2    set -0.45240043       ; C617BE

; IIR2: mode=LowPass fc=16000 Q=10 gainDB=0 h=< 0.39763495 0.79526991 0.39763495 -0.62712308 -0.46341673 >,< 32E5B3 65CB67 32E5B3 AFBA6F C4AEC3 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_LowPass_f16000_q10_b0    set 0.39763495       ; 32E5B3
iir2_H_LowPass_f16000_q10_b1    set 0.79526991       ; 65CB67
iir2_H_LowPass_f16000_q10_b2    set 0.39763495       ; 32E5B3
iir2_H_LowPass_f16000_q10_a1    set -0.62712308       ; AFBA6F
iir2_H_LowPass_f16000_q10_a2    set -0.46341673       ; C4AEC3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\IIr2_HighPass.h ===
;**************************************************************************
;
;       IIR2_HighPass.h    Coefficients for 2nd order high pass filter
;       
;		Written by Gints Klimanis
;
;**************************************************************************        

; IIR2: mode=HighPass fc=62.5 Q=0.707107 gainDB=0 h=< 0.49659610 0.99319220 0.49659610 0.99317251 -0.49321189 >,< 3F9076 7F20EC 3F9076 7F2047 C0DE6F >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_HighPass_f00062_q00_b0    set 0.49659610       ; 3F9076
iir2_H_HighPass_f00062_q00_b1    set 0.99319220       ; 7F20EC
iir2_H_HighPass_f00062_q00_b2    set 0.49659610       ; 3F9076
iir2_H_HighPass_f00062_q00_a1    set 0.99317251       ; 7F2047
iir2_H_HighPass_f00062_q00_a2    set -0.49321189       ; C0DE6F

; IIR2: mode=HighPass fc=88.3883 Q=0.707107 gainDB=0 h=< 0.49519397 0.99038794 0.49519397 0.99034867 -0.49042720 >,< 3F6284 7EC508 3F6284 7EC3BF C139AF >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_HighPass_f00088_q00_b0    set 0.49519397       ; 3F6284
iir2_H_HighPass_f00088_q00_b1    set 0.99038794       ; 7EC508
iir2_H_HighPass_f00088_q00_b2    set 0.49519397       ; 3F6284
iir2_H_HighPass_f00088_q00_a1    set 0.99034867       ; 7EC3BF
iir2_H_HighPass_f00088_q00_a2    set -0.49042720       ; C139AF

; IIR2: mode=HighPass fc=125 Q=0.707107 gainDB=0 h=< 0.49321881 0.98643762 0.49321881 0.98635939 -0.48651584 >,< 3F21CB 7E4396 3F21CB 7E4106 C1B9DA >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_HighPass_f00125_q00_b0    set 0.49321881       ; 3F21CB
iir2_H_HighPass_f00125_q00_b1    set 0.98643762       ; 7E4396
iir2_H_HighPass_f00125_q00_b2    set 0.49321881       ; 3F21CB
iir2_H_HighPass_f00125_q00_a1    set 0.98635939       ; 7E4106
iir2_H_HighPass_f00125_q00_a2    set -0.48651584       ; C1B9DA

; IIR2: mode=HighPass fc=176.777 Q=0.707107 gainDB=0 h=< 0.49044092 0.98088185 0.49044092 0.98072627 -0.48103742 >,< 3EC6C4 7D8D89 3EC6C4 7D8870 C26D5E >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_HighPass_f00176_q00_b0    set 0.49044092       ; 3EC6C4
iir2_H_HighPass_f00176_q00_b1    set 0.98088185       ; 7D8D89
iir2_H_HighPass_f00176_q00_b2    set 0.49044092       ; 3EC6C4
iir2_H_HighPass_f00176_q00_a1    set 0.98072627       ; 7D8870
iir2_H_HighPass_f00176_q00_a2    set -0.48103742       ; C26D5E

; IIR2: mode=HighPass fc=250 Q=0.707107 gainDB=0 h=< 0.48654294 0.97308589 0.48654294 0.97277718 -0.47339460 >,< 3E470A 7C8E14 3E470A 7C83F6 C367CF >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_HighPass_f00250_q00_b0    set 0.48654294       ; 3E470A
iir2_H_HighPass_f00250_q00_b1    set 0.97308589       ; 7C8E14
iir2_H_HighPass_f00250_q00_b2    set 0.48654294       ; 3E470A
iir2_H_HighPass_f00250_q00_a1    set 0.97277718       ; 7C83F6
iir2_H_HighPass_f00250_q00_a2    set -0.47339460       ; C367CF

; IIR2: mode=HighPass fc=353.553 Q=0.707107 gainDB=0 h=< 0.48109068 0.96218136 0.48109068 0.96157073 -0.46279198 >,< 3D9461 7B28C2 3D9461 7B14C0 C4C33C >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_HighPass_f00353_q00_b0    set 0.48109068       ; 3D9461
iir2_H_HighPass_f00353_q00_b1    set 0.96218136       ; 7B28C2
iir2_H_HighPass_f00353_q00_b2    set 0.48109068       ; 3D9461
iir2_H_HighPass_f00353_q00_a1    set 0.96157073       ; 7B14C0
iir2_H_HighPass_f00353_q00_a2    set -0.46279198       ; C4C33C

; IIR2: mode=HighPass fc=500 Q=0.707107 gainDB=0 h=< 0.47349844 0.94699689 0.47349844 0.94579441 -0.44819937 >,< 3C9B98 793731 3C9B98 790FCA C6A168 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_HighPass_f00500_q00_b0    set 0.47349844       ; 3C9B98
iir2_H_HighPass_f00500_q00_b1    set 0.94699689       ; 793731
iir2_H_HighPass_f00500_q00_b2    set 0.47349844       ; 3C9B98
iir2_H_HighPass_f00500_q00_a1    set 0.94579441       ; 790FCA
iir2_H_HighPass_f00500_q00_a2    set -0.44819937       ; C6A168

; IIR2: mode=HighPass fc=707.107 Q=0.707107 gainDB=0 h=< 0.46299220 0.92598440 0.46299220 0.92363081 -0.42833799 >,< 3B4354 7686A8 3B4354 763989 C92C39 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_HighPass_f00707_q00_b0    set 0.46299220       ; 3B4354
iir2_H_HighPass_f00707_q00_b1    set 0.92598440       ; 7686A8
iir2_H_HighPass_f00707_q00_b2    set 0.46299220       ; 3B4354
iir2_H_HighPass_f00707_q00_a1    set 0.92363081       ; 763989
iir2_H_HighPass_f00707_q00_a2    set -0.42833799       ; C92C39

; IIR2: mode=HighPass fc=1000 Q=0.707107 gainDB=0 h=< 0.44857897 0.89715794 0.44857897 0.89258956 -0.40172633 >,< 396B09 72D612 396B09 724060 CC943C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_HighPass_f01000_q00_b0    set 0.44857897       ; 396B09
iir2_H_HighPass_f01000_q00_b1    set 0.89715794       ; 72D612
iir2_H_HighPass_f01000_q00_b2    set 0.44857897       ; 396B09
iir2_H_HighPass_f01000_q00_a1    set 0.89258956       ; 724060
iir2_H_HighPass_f01000_q00_a2    set -0.40172633       ; CC943C

; IIR2: mode=HighPass fc=1414.21 Q=0.707107 gainDB=0 h=< 0.42903969 0.85807939 0.42903969 0.84931088 -0.36684790 >,< 36EAC5 6DD58B 36EAC5 6CB638 D10B21 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_HighPass_f01414_q00_b0    set 0.42903969       ; 36EAC5
iir2_H_HighPass_f01414_q00_b1    set 0.85807939       ; 6DD58B
iir2_H_HighPass_f01414_q00_b2    set 0.42903969       ; 36EAC5
iir2_H_HighPass_f01414_q00_a1    set 0.84931088       ; 6CB638
iir2_H_HighPass_f01414_q00_a2    set -0.36684790       ; D10B21

; IIR2: mode=HighPass fc=2000 Q=0.707107 gainDB=0 h=< 0.40297353 0.80594705 0.40297353 0.78936286 -0.32253125 >,< 3394A3 672946 3394A3 6509D7 D6B74C >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_HighPass_f02000_q00_b0    set 0.40297353       ; 3394A3
iir2_H_HighPass_f02000_q00_b1    set 0.80594705       ; 672946
iir2_H_HighPass_f02000_q00_b2    set 0.40297353       ; 3394A3
iir2_H_HighPass_f02000_q00_a1    set 0.78936286       ; 6509D7
iir2_H_HighPass_f02000_q00_a2    set -0.32253125       ; D6B74C

; IIR2: mode=HighPass fc=2828.43 Q=0.707107 gainDB=0 h=< 0.36892836 0.73785672 0.36892836 0.70707082 -0.26864261 >,< 2F390B 5E7217 2F390B 5A814C DD9D1F >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_HighPass_f02828_q00_b0    set 0.36892836       ; 2F390B
iir2_H_HighPass_f02828_q00_b1    set 0.73785672       ; 5E7217
iir2_H_HighPass_f02828_q00_b2    set 0.36892836       ; 2F390B
iir2_H_HighPass_f02828_q00_a1    set 0.70707082       ; 5A814C
iir2_H_HighPass_f02828_q00_a2    set -0.26864261       ; DD9D1F

; IIR2: mode=HighPass fc=4000 Q=0.707107 gainDB=0 h=< 0.32563646 0.65127291 0.32563646 0.59539110 -0.20715472 >,< 29AE74 535CE9 29AE74 4C35C6 E57BF5 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_HighPass_f04000_q00_b0    set 0.32563646       ; 29AE74
iir2_H_HighPass_f04000_q00_b1    set 0.65127291       ; 535CE9
iir2_H_HighPass_f04000_q00_b2    set 0.32563646       ; 29AE74
iir2_H_HighPass_f04000_q00_a1    set 0.59539110       ; 4C35C6
iir2_H_HighPass_f04000_q00_a2    set -0.20715472       ; E57BF5

; IIR2: mode=HighPass fc=5656.85 Q=0.707107 gainDB=0 h=< 0.27230833 0.54461666 0.27230833 0.44563633 -0.14359698 >,< 22DAFF 45B5FF 22DAFF 390A9C ED9E9E >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_HighPass_f05656_q00_b0    set 0.27230833       ; 22DAFF
iir2_H_HighPass_f05656_q00_b1    set 0.54461666       ; 45B5FF
iir2_H_HighPass_f05656_q00_b2    set 0.27230833       ; 22DAFF
iir2_H_HighPass_f05656_q00_a1    set 0.44563633       ; 390A9C
iir2_H_HighPass_f05656_q00_a2    set -0.14359698       ; ED9E9E

; IIR2: mode=HighPass fc=8000 Q=0.707107 gainDB=0 h=< 0.20882291 0.41764582 0.20882291 0.24613286 -0.08915878 >,< 1ABAB5 35756B 1ABAB5 1F8148 F49672 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_HighPass_f08000_q00_b0    set 0.20882291       ; 1ABAB5
iir2_H_HighPass_f08000_q00_b1    set 0.41764582       ; 35756B
iir2_H_HighPass_f08000_q00_b2    set 0.20882291       ; 1ABAB5
iir2_H_HighPass_f08000_q00_a1    set 0.24613286       ; 1F8148
iir2_H_HighPass_f08000_q00_a2    set -0.08915878       ; F49672

; IIR2: mode=HighPass fc=11313.7 Q=0.707107 gainDB=0 h=< 0.13567431 0.27134862 0.13567431 -0.02327410 -0.06597134 >,< 115DC6 22BB8D 115DC6 FD055B F78E41 >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_HighPass_f11313_q00_b0    set 0.13567431       ; 115DC6
iir2_H_HighPass_f11313_q00_b1    set 0.27134862       ; 22BB8D
iir2_H_HighPass_f11313_q00_b2    set 0.13567431       ; 115DC6
iir2_H_HighPass_f11313_q00_a1    set -0.02327410       ; FD055B
iir2_H_HighPass_f11313_q00_a2    set -0.06597134       ; F78E41

; IIR2: mode=HighPass fc=16000 Q=0.707107 gainDB=0 h=< 0.05513904 0.11027807 0.05513904 -0.41129488 -0.13185103 >,< 070ECB 0E1D97 070ECB CB5AB1 EF1F82 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_HighPass_f16000_q00_b0    set 0.05513904       ; 070ECB
iir2_H_HighPass_f16000_q00_b1    set 0.11027807       ; 0E1D97
iir2_H_HighPass_f16000_q00_b2    set 0.05513904       ; 070ECB
iir2_H_HighPass_f16000_q00_a1    set -0.41129488       ; CB5AB1
iir2_H_HighPass_f16000_q00_a2    set -0.13185103       ; EF1F82

; IIR2: mode=HighPass fc=62.5 Q=5 gainDB=0 h=< 0.49954452 0.99908904 0.49954452 0.99906924 -0.49910885 >,< 3FF113 7FE226 3FF113 7FE180 C01D34 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_HighPass_f00062_q05_b0    set 0.49954452       ; 3FF113
iir2_H_HighPass_f00062_q05_b1    set 0.99908904       ; 7FE226
iir2_H_HighPass_f00062_q05_b2    set 0.49954452       ; 3FF113
iir2_H_HighPass_f00062_q05_a1    set 0.99906924       ; 7FE180
iir2_H_HighPass_f00062_q05_a2    set -0.49910885       ; C01D34

; IIR2: mode=HighPass fc=88.3883 Q=5 gainDB=0 h=< 0.49935030 0.99870061 0.49935030 0.99866101 -0.49874020 >,< 3FEAB6 7FD56C 3FEAB6 7FD41F C02948 >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_HighPass_f00088_q05_b0    set 0.49935030       ; 3FEAB6
iir2_H_HighPass_f00088_q05_b1    set 0.99870061       ; 7FD56C
iir2_H_HighPass_f00088_q05_b2    set 0.49935030       ; 3FEAB6
iir2_H_HighPass_f00088_q05_a1    set 0.99866101       ; 7FD41F
iir2_H_HighPass_f00088_q05_a2    set -0.49874020       ; C02948

; IIR2: mode=HighPass fc=125 Q=5 gainDB=0 h=< 0.49907010 0.99814020 0.49907010 0.99806105 -0.49821935 >,< 3FE187 7FC30F 3FE187 7FC077 C03A5A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_HighPass_f00125_q05_b0    set 0.49907010       ; 3FE187
iir2_H_HighPass_f00125_q05_b1    set 0.99814020       ; 7FC30F
iir2_H_HighPass_f00125_q05_b2    set 0.49907010       ; 3FE187
iir2_H_HighPass_f00125_q05_a1    set 0.99806105       ; 7FC077
iir2_H_HighPass_f00125_q05_a2    set -0.49821935       ; C03A5A

; IIR2: mode=HighPass fc=176.777 Q=5 gainDB=0 h=< 0.49866280 0.99732559 0.49866280 0.99716741 -0.49748377 >,< 3FD42E 7FA85D 3FD42E 7FA32E C05274 >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_HighPass_f00176_q05_b0    set 0.49866280       ; 3FD42E
iir2_H_HighPass_f00176_q05_b1    set 0.99732559       ; 7FA85D
iir2_H_HighPass_f00176_q05_b2    set 0.49866280       ; 3FD42E
iir2_H_HighPass_f00176_q05_a1    set 0.99716741       ; 7FA32E
iir2_H_HighPass_f00176_q05_a2    set -0.49748377       ; C05274

; IIR2: mode=HighPass fc=250 Q=5 gainDB=0 h=< 0.49806479 0.99612958 0.49806479 0.99581356 -0.49644560 >,< 3FC096 7F812C 3FC096 7F76D1 C07479 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_HighPass_f00250_q05_b0    set 0.49806479       ; 3FC096
iir2_H_HighPass_f00250_q05_b1    set 0.99612958       ; 7F812C
iir2_H_HighPass_f00250_q05_b2    set 0.49806479       ; 3FC096
iir2_H_HighPass_f00250_q05_a1    set 0.99581356       ; 7F76D1
iir2_H_HighPass_f00250_q05_a2    set -0.49644560       ; C07479

; IIR2: mode=HighPass fc=353.553 Q=5 gainDB=0 h=< 0.49717536 0.99435072 0.49717536 0.99371968 -0.49498176 >,< 3FA371 7F46E2 3FA371 7F3235 C0A470 >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_HighPass_f00353_q05_b0    set 0.49717536       ; 3FA371
iir2_H_HighPass_f00353_q05_b1    set 0.99435072       ; 7F46E2
iir2_H_HighPass_f00353_q05_b2    set 0.49717536       ; 3FA371
iir2_H_HighPass_f00353_q05_a1    set 0.99371968       ; 7F3235
iir2_H_HighPass_f00353_q05_a2    set -0.49498176       ; C0A470

; IIR2: mode=HighPass fc=500 Q=5 gainDB=0 h=< 0.49583082 0.99166164 0.49583082 0.99040244 -0.49292083 >,< 3F7762 7EEEC4 3F7762 7EC582 C0E7F9 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_HighPass_f00500_q05_b0    set 0.49583082       ; 3F7762
iir2_H_HighPass_f00500_q05_b1    set 0.99166164       ; 7EEEC4
iir2_H_HighPass_f00500_q05_b2    set 0.49583082       ; 3F7762
iir2_H_HighPass_f00500_q05_a1    set 0.99040244       ; 7EC582
iir2_H_HighPass_f00500_q05_a2    set -0.49292083       ; C0E7F9

; IIR2: mode=HighPass fc=707.107 Q=5 gainDB=0 h=< 0.49375809 0.98751619 0.49375809 0.98500620 -0.49002618 >,< 3F3377 7E66EE 3F3377 7E14AF C146D3 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_HighPass_f00707_q05_b0    set 0.49375809       ; 3F3377
iir2_H_HighPass_f00707_q05_b1    set 0.98751619       ; 7E66EE
iir2_H_HighPass_f00707_q05_b2    set 0.49375809       ; 3F3377
iir2_H_HighPass_f00707_q05_a1    set 0.98500620       ; 7E14AF
iir2_H_HighPass_f00707_q05_a2    set -0.49002618       ; C146D3

; IIR2: mode=HighPass fc=1000 Q=5 gainDB=0 h=< 0.49049057 0.98098113 0.49049057 0.97598592 -0.48597635 >,< 3EC865 7D90CA 3EC865 7CED1B C1CB87 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_HighPass_f01000_q05_b0    set 0.49049057       ; 3EC865
iir2_H_HighPass_f01000_q05_b1    set 0.98098113       ; 7D90CA
iir2_H_HighPass_f01000_q05_b2    set 0.49049057       ; 3EC865
iir2_H_HighPass_f01000_q05_a1    set 0.97598592       ; 7CED1B
iir2_H_HighPass_f01000_q05_a2    set -0.48597635       ; C1CB87

; IIR2: mode=HighPass fc=1414.21 Q=5 gainDB=0 h=< 0.48521546 0.97043092 0.48521546 0.96051432 -0.48034752 >,< 3E1B8A 7C3714 3E1B8A 7AF222 C283F9 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_HighPass_f01414_q05_b0    set 0.48521546       ; 3E1B8A
iir2_H_HighPass_f01414_q05_b1    set 0.97043092       ; 7C3714
iir2_H_HighPass_f01414_q05_b2    set 0.48521546       ; 3E1B8A
iir2_H_HighPass_f01414_q05_a1    set 0.96051432       ; 7AF222
iir2_H_HighPass_f01414_q05_a2    set -0.48034752       ; C283F9

; IIR2: mode=HighPass fc=2000 Q=5 gainDB=0 h=< 0.47650148 0.95300297 0.47650148 0.93339277 -0.47261317 >,< 3CFE00 79FC00 3CFE00 77796A C3816A >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_HighPass_f02000_q05_b0    set 0.47650148       ; 3CFE00
iir2_H_HighPass_f02000_q05_b1    set 0.95300297       ; 79FC00
iir2_H_HighPass_f02000_q05_b2    set 0.47650148       ; 3CFE00
iir2_H_HighPass_f02000_q05_a1    set 0.93339277       ; 77796A
iir2_H_HighPass_f02000_q05_a2    set -0.47261317       ; C3816A

; IIR2: mode=HighPass fc=2828.43 Q=5 gainDB=0 h=< 0.46183227 0.92366454 0.46183227 0.88512611 -0.46220297 >,< 3B1D51 763AA3 3B1D51 714BD0 C4D689 >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_HighPass_f02828_q05_b0    set 0.46183227       ; 3B1D51
iir2_H_HighPass_f02828_q05_b1    set 0.92366454       ; 763AA3
iir2_H_HighPass_f02828_q05_b2    set 0.46183227       ; 3B1D51
iir2_H_HighPass_f02828_q05_a1    set 0.88512611       ; 714BD0
iir2_H_HighPass_f02828_q05_a2    set -0.46220297       ; C4D689

; IIR2: mode=HighPass fc=4000 Q=5 gainDB=0 h=< 0.43687722 0.87375444 0.43687722 0.79878283 -0.44872606 >,< 37EB97 6FD72F 37EB97 663E84 C69025 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_HighPass_f04000_q05_b0    set 0.43687722       ; 37EB97
iir2_H_HighPass_f04000_q05_b1    set 0.87375444       ; 6FD72F
iir2_H_HighPass_f04000_q05_b2    set 0.43687722       ; 37EB97
iir2_H_HighPass_f04000_q05_a1    set 0.79878283       ; 663E84
iir2_H_HighPass_f04000_q05_a2    set -0.44872606       ; C69025

; IIR2: mode=HighPass fc=5656.85 Q=5 gainDB=0 h=< 0.39458691 0.78917382 0.39458691 0.64574691 -0.43260072 >,< 3281D3 6503A6 3281D3 52A7D5 C8A08A >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_HighPass_f05656_q05_b0    set 0.39458691       ; 3281D3
iir2_H_HighPass_f05656_q05_b1    set 0.78917382       ; 6503A6
iir2_H_HighPass_f05656_q05_b2    set 0.39458691       ; 3281D3
iir2_H_HighPass_f05656_q05_a1    set 0.64574691       ; 52A7D5
iir2_H_HighPass_f05656_q05_a2    set -0.43260072       ; C8A08A

; IIR2: mode=HighPass fc=8000 Q=5 gainDB=0 h=< 0.32487653 0.64975306 0.32487653 0.38292153 -0.41658458 >,< 29958D 532B1B 29958D 310392 CAAD5C >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_HighPass_f08000_q05_b0    set 0.32487653       ; 29958D
iir2_H_HighPass_f08000_q05_b1    set 0.64975306       ; 532B1B
iir2_H_HighPass_f08000_q05_b2    set 0.32487653       ; 29958D
iir2_H_HighPass_f08000_q05_a1    set 0.38292153       ; 310392
iir2_H_HighPass_f08000_q05_a2    set -0.41658458       ; CAAD5C

; IIR2: mode=HighPass fc=11313.7 Q=5 gainDB=0 h=< 0.21791048 0.43582096 0.21791048 -0.03738121 -0.40902313 >,< 1BE47D 37C8FB 1BE47D FB3718 CBA522 >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_HighPass_f11313_q05_b0    set 0.21791048       ; 1BE47D
iir2_H_HighPass_f11313_q05_b1    set 0.43582096       ; 37C8FB
iir2_H_HighPass_f11313_q05_b2    set 0.21791048       ; 1BE47D
iir2_H_HighPass_f11313_q05_a1    set -0.03738121       ; FB3718
iir2_H_HighPass_f11313_q05_a2    set -0.40902313       ; CBA522

; IIR2: mode=HighPass fc=16000 Q=5 gainDB=0 h=< 0.08109912 0.16219824 0.08109912 -0.60493716 -0.42933365 >,< 0A6174 14C2E9 0A6174 B2916C C90B99 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_HighPass_f16000_q05_b0    set 0.08109912       ; 0A6174
iir2_H_HighPass_f16000_q05_b1    set 0.16219824       ; 14C2E9
iir2_H_HighPass_f16000_q05_b2    set 0.08109912       ; 0A6174
iir2_H_HighPass_f16000_q05_a1    set -0.60493716       ; B2916C
iir2_H_HighPass_f16000_q05_a2    set -0.42933365       ; C90B99

; IIR2: mode=HighPass fc=62.5 Q=10 gainDB=0 h=< 0.49976748 0.99953497 0.49976748 0.99951515 -0.49955478 >,< 3FF861 7FF0C3 3FF861 7FF01D C00E97 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_HighPass_f00062_q10_b0    set 0.49976748       ; 3FF861
iir2_H_HighPass_f00062_q10_b1    set 0.99953497       ; 7FF0C3
iir2_H_HighPass_f00062_q10_b2    set 0.49976748       ; 3FF861
iir2_H_HighPass_f00062_q10_a1    set 0.99951515       ; 7FF01D
iir2_H_HighPass_f00062_q10_a2    set -0.49955478       ; C00E97

; IIR2: mode=HighPass fc=88.3883 Q=10 gainDB=0 h=< 0.49966543 0.99933087 0.49966543 0.99929125 -0.49937049 >,< 3FF509 7FEA13 3FF509 7FE8C6 C014A1 >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_HighPass_f00088_q10_b0    set 0.49966543       ; 3FF509
iir2_H_HighPass_f00088_q10_b1    set 0.99933087       ; 7FEA13
iir2_H_HighPass_f00088_q10_b2    set 0.49966543       ; 3FF509
iir2_H_HighPass_f00088_q10_a1    set 0.99929125       ; 7FE8C6
iir2_H_HighPass_f00088_q10_a2    set -0.49937049       ; C014A1

; IIR2: mode=HighPass fc=125 Q=10 gainDB=0 h=< 0.49951539 0.99903077 0.49951539 0.99895155 -0.49910999 >,< 3FF01E 7FE03D 3FF01E 7FDDA5 C01D2A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_HighPass_f00125_q10_b0    set 0.49951539       ; 3FF01E
iir2_H_HighPass_f00125_q10_b1    set 0.99903077       ; 7FE03D
iir2_H_HighPass_f00125_q10_b2    set 0.49951539       ; 3FF01E
iir2_H_HighPass_f00125_q10_a1    set 0.99895155       ; 7FDDA5
iir2_H_HighPass_f00125_q10_a2    set -0.49910999       ; C01D2A

; IIR2: mode=HighPass fc=176.777 Q=10 gainDB=0 h=< 0.49929175 0.99858349 0.49929175 0.99842511 -0.49874187 >,< 3FE8CA 7FD195 3FE8CA 7FCC65 C0293A >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_HighPass_f00176_q10_b0    set 0.49929175       ; 3FE8CA
iir2_H_HighPass_f00176_q10_b1    set 0.99858349       ; 7FD195
iir2_H_HighPass_f00176_q10_b2    set 0.49929175       ; 3FE8CA
iir2_H_HighPass_f00176_q10_a1    set 0.99842511       ; 7FCC65
iir2_H_HighPass_f00176_q10_a2    set -0.49874187       ; C0293A

; IIR2: mode=HighPass fc=250 Q=10 gainDB=0 h=< 0.49895264 0.99790527 0.49895264 0.99758869 -0.49822185 >,< 3FDDAE 7FBB5C 3FDDAE 7FB0FC C03A45 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_HighPass_f00250_q10_b0    set 0.49895264       ; 3FDDAE
iir2_H_HighPass_f00250_q10_b1    set 0.99790527       ; 7FBB5C
iir2_H_HighPass_f00250_q10_b2    set 0.49895264       ; 3FDDAE
iir2_H_HighPass_f00250_q10_a1    set 0.99758869       ; 7FB0FC
iir2_H_HighPass_f00250_q10_a2    set -0.49822185       ; C03A45

; IIR2: mode=HighPass fc=353.553 Q=10 gainDB=0 h=< 0.49842754 0.99685507 0.49842754 0.99622245 -0.49748770 >,< 3FCC79 7F98F2 3FCC79 7F8437 C05253 >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_HighPass_f00353_q10_b0    set 0.49842754       ; 3FCC79
iir2_H_HighPass_f00353_q10_b1    set 0.99685507       ; 7F98F2
iir2_H_HighPass_f00353_q10_b2    set 0.49842754       ; 3FCC79
iir2_H_HighPass_f00353_q10_a1    set 0.99622245       ; 7F8437
iir2_H_HighPass_f00353_q10_a2    set -0.49748770       ; C05253

; IIR2: mode=HighPass fc=500 Q=10 gainDB=0 h=< 0.49759429 0.99518859 0.49759429 0.99392491 -0.49645226 >,< 3FB12B 7F6257 3FB12B 7F38EE C07441 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_HighPass_f00500_q10_b0    set 0.49759429       ; 3FB12B
iir2_H_HighPass_f00500_q10_b1    set 0.99518859       ; 7F6257
iir2_H_HighPass_f00500_q10_b2    set 0.49759429       ; 3FB12B
iir2_H_HighPass_f00500_q10_a1    set 0.99392491       ; 7F38EE
iir2_H_HighPass_f00500_q10_a2    set -0.49645226       ; C07441

; IIR2: mode=HighPass fc=707.107 Q=10 gainDB=0 h=< 0.49623587 0.99247174 0.49623587 0.98994915 -0.49499432 >,< 3F84A8 7F0950 3F84A8 7EB6A7 C0A407 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_HighPass_f00707_q10_b0    set 0.49623587       ; 3F84A8
iir2_H_HighPass_f00707_q10_b1    set 0.99247174       ; 7F0950
iir2_H_HighPass_f00707_q10_b2    set 0.49623587       ; 3F84A8
iir2_H_HighPass_f00707_q10_a1    set 0.98994915       ; 7EB6A7
iir2_H_HighPass_f00707_q10_a2    set -0.49499432       ; C0A407

; IIR2: mode=HighPass fc=1000 Q=10 gainDB=0 h=< 0.49395844 0.98791688 0.49395844 0.98288635 -0.49294742 >,< 3F3A07 7E740F 3F3A07 7DCF38 C0E71A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_HighPass_f01000_q10_b0    set 0.49395844       ; 3F3A07
iir2_H_HighPass_f01000_q10_b1    set 0.98791688       ; 7E740F
iir2_H_HighPass_f01000_q10_b2    set 0.49395844       ; 3F3A07
iir2_H_HighPass_f01000_q10_a1    set 0.98288635       ; 7DCF38
iir2_H_HighPass_f01000_q10_a2    set -0.49294742       ; C0E71A

; IIR2: mode=HighPass fc=1414.21 Q=10 gainDB=0 h=< 0.49003669 0.98007338 0.49003669 0.97005825 -0.49008852 >,< 3EB985 7D730B 3EB985 7C2ADE C144C8 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_HighPass_f01414_q10_b0    set 0.49003669       ; 3EB985
iir2_H_HighPass_f01414_q10_b1    set 0.98007338       ; 7D730B
iir2_H_HighPass_f01414_q10_b2    set 0.49003669       ; 3EB985
iir2_H_HighPass_f01414_q10_a1    set 0.97005825       ; 7C2ADE
iir2_H_HighPass_f01414_q10_a2    set -0.49008852       ; C144C8

; IIR2: mode=HighPass fc=2000 Q=10 gainDB=0 h=< 0.48312538 0.96625076 0.48312538 0.94636796 -0.48613357 >,< 3DD70D 7BAE1B 3DD70D 792296 C1C660 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_HighPass_f02000_q10_b0    set 0.48312538       ; 3DD70D
iir2_H_HighPass_f02000_q10_b1    set 0.96625076       ; 7BAE1B
iir2_H_HighPass_f02000_q10_b2    set 0.48312538       ; 3DD70D
iir2_H_HighPass_f02000_q10_a1    set 0.94636796       ; 792296
iir2_H_HighPass_f02000_q10_a2    set -0.48613357       ; C1C660

; IIR2: mode=HighPass fc=2828.43 Q=10 gainDB=0 h=< 0.47073966 0.94147932 0.47073966 0.90219760 -0.48076104 >,< 3C4132 788265 3C4132 737B36 C2766C >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_HighPass_f02828_q10_b0    set 0.47073966       ; 3C4132
iir2_H_HighPass_f02828_q10_b1    set 0.94147932       ; 788265
iir2_H_HighPass_f02828_q10_b2    set 0.47073966       ; 3C4132
iir2_H_HighPass_f02828_q10_a1    set 0.90219760       ; 737B36
iir2_H_HighPass_f02828_q10_a2    set -0.48076104       ; C2766C

; IIR2: mode=HighPass fc=4000 Q=10 gainDB=0 h=< 0.44838686 0.89677371 0.44838686 0.81982696 -0.47372047 >,< 3964BD 72C97B 3964BD 68F017 C35D21 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_HighPass_f04000_q10_b0    set 0.44838686       ; 3964BD
iir2_H_HighPass_f04000_q10_b1    set 0.89677371       ; 72C97B
iir2_H_HighPass_f04000_q10_b2    set 0.44838686       ; 3964BD
iir2_H_HighPass_f04000_q10_a1    set 0.81982696       ; 68F017
iir2_H_HighPass_f04000_q10_a2    set -0.47372047       ; C35D21

; IIR2: mode=HighPass fc=5656.85 Q=10 gainDB=0 h=< 0.40836588 0.81673175 0.40836588 0.66829638 -0.46516712 >,< 344555 688AAA 344555 558ABC C47568 >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_HighPass_f05656_q10_b0    set 0.40836588       ; 344555
iir2_H_HighPass_f05656_q10_b1    set 0.81673175       ; 688AAA
iir2_H_HighPass_f05656_q10_b2    set 0.40836588       ; 344555
iir2_H_HighPass_f05656_q10_a1    set 0.66829638       ; 558ABC
iir2_H_HighPass_f05656_q10_a2    set -0.46516712       ; C47568

; IIR2: mode=HighPass fc=8000 Q=10 gainDB=0 h=< 0.33903454 0.67806908 0.33903454 0.39960913 -0.45652903 >,< 2B657B 56CAF7 2B657B 332664 C59075 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_HighPass_f08000_q10_b0    set 0.33903454       ; 2B657B
iir2_H_HighPass_f08000_q10_b1    set 0.67806908       ; 56CAF7
iir2_H_HighPass_f08000_q10_b2    set 0.33903454       ; 2B657B
iir2_H_HighPass_f08000_q10_a1    set 0.39960913       ; 332664
iir2_H_HighPass_f08000_q10_a2    set -0.45652903       ; C59075

; IIR2: mode=HighPass fc=11313.7 Q=10 gainDB=0 h=< 0.22830886 0.45661772 0.22830886 -0.03916498 -0.45240043 >,< 1D3939 3A7273 1D3939 FAFCA5 C617BE >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_HighPass_f11313_q10_b0    set 0.22830886       ; 1D3939
iir2_H_HighPass_f11313_q10_b1    set 0.45661772       ; 3A7273
iir2_H_HighPass_f11313_q10_b2    set 0.22830886       ; 1D3939
iir2_H_HighPass_f11313_q10_a1    set -0.03916498       ; FAFCA5
iir2_H_HighPass_f11313_q10_a2    set -0.45240043       ; C617BE

; IIR2: mode=HighPass fc=16000 Q=10 gainDB=0 h=< 0.08407341 0.16814682 0.08407341 -0.62712308 -0.46341673 >,< 0AC2EA 1585D5 0AC2EA AFBA6F C4AEC3 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_HighPass_f16000_q10_b0    set 0.08407341       ; 0AC2EA
iir2_H_HighPass_f16000_q10_b1    set 0.16814682       ; 1585D5
iir2_H_HighPass_f16000_q10_b2    set 0.08407341       ; 0AC2EA
iir2_H_HighPass_f16000_q10_a1    set -0.62712308       ; AFBA6F
iir2_H_HighPass_f16000_q10_a2    set -0.46341673       ; C4AEC3

; IIR2: mode=HighPass fc=62.5 Q=0.707107 gainDB=0 h=< 0.49659610 0.99319220 0.49659610 0.99317251 -0.49321189 >,< 3F9076 7F20EC 3F9076 7F2047 C0DE6F >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_HighPass_f00062_q00_b0    set 0.49659610       ; 3F9076
iir2_H_HighPass_f00062_q00_b1    set 0.99319220       ; 7F20EC
iir2_H_HighPass_f00062_q00_b2    set 0.49659610       ; 3F9076
iir2_H_HighPass_f00062_q00_a1    set 0.99317251       ; 7F2047
iir2_H_HighPass_f00062_q00_a2    set -0.49321189       ; C0DE6F

; IIR2: mode=HighPass fc=88.3883 Q=0.707107 gainDB=0 h=< 0.49519397 0.99038794 0.49519397 0.99034867 -0.49042720 >,< 3F6284 7EC508 3F6284 7EC3BF C139AF >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_HighPass_f00088_q00_b0    set 0.49519397       ; 3F6284
iir2_H_HighPass_f00088_q00_b1    set 0.99038794       ; 7EC508
iir2_H_HighPass_f00088_q00_b2    set 0.49519397       ; 3F6284
iir2_H_HighPass_f00088_q00_a1    set 0.99034867       ; 7EC3BF
iir2_H_HighPass_f00088_q00_a2    set -0.49042720       ; C139AF

; IIR2: mode=HighPass fc=125 Q=0.707107 gainDB=0 h=< 0.49321881 0.98643762 0.49321881 0.98635939 -0.48651584 >,< 3F21CB 7E4396 3F21CB 7E4106 C1B9DA >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_HighPass_f00125_q00_b0    set 0.49321881       ; 3F21CB
iir2_H_HighPass_f00125_q00_b1    set 0.98643762       ; 7E4396
iir2_H_HighPass_f00125_q00_b2    set 0.49321881       ; 3F21CB
iir2_H_HighPass_f00125_q00_a1    set 0.98635939       ; 7E4106
iir2_H_HighPass_f00125_q00_a2    set -0.48651584       ; C1B9DA

; IIR2: mode=HighPass fc=176.777 Q=0.707107 gainDB=0 h=< 0.49044092 0.98088185 0.49044092 0.98072627 -0.48103742 >,< 3EC6C4 7D8D89 3EC6C4 7D8870 C26D5E >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_HighPass_f00176_q00_b0    set 0.49044092       ; 3EC6C4
iir2_H_HighPass_f00176_q00_b1    set 0.98088185       ; 7D8D89
iir2_H_HighPass_f00176_q00_b2    set 0.49044092       ; 3EC6C4
iir2_H_HighPass_f00176_q00_a1    set 0.98072627       ; 7D8870
iir2_H_HighPass_f00176_q00_a2    set -0.48103742       ; C26D5E

; IIR2: mode=HighPass fc=250 Q=0.707107 gainDB=0 h=< 0.48654294 0.97308589 0.48654294 0.97277718 -0.47339460 >,< 3E470A 7C8E14 3E470A 7C83F6 C367CF >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_HighPass_f00250_q00_b0    set 0.48654294       ; 3E470A
iir2_H_HighPass_f00250_q00_b1    set 0.97308589       ; 7C8E14
iir2_H_HighPass_f00250_q00_b2    set 0.48654294       ; 3E470A
iir2_H_HighPass_f00250_q00_a1    set 0.97277718       ; 7C83F6
iir2_H_HighPass_f00250_q00_a2    set -0.47339460       ; C367CF

; IIR2: mode=HighPass fc=353.553 Q=0.707107 gainDB=0 h=< 0.48109068 0.96218136 0.48109068 0.96157073 -0.46279198 >,< 3D9461 7B28C2 3D9461 7B14C0 C4C33C >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_HighPass_f00353_q00_b0    set 0.48109068       ; 3D9461
iir2_H_HighPass_f00353_q00_b1    set 0.96218136       ; 7B28C2
iir2_H_HighPass_f00353_q00_b2    set 0.48109068       ; 3D9461
iir2_H_HighPass_f00353_q00_a1    set 0.96157073       ; 7B14C0
iir2_H_HighPass_f00353_q00_a2    set -0.46279198       ; C4C33C

; IIR2: mode=HighPass fc=500 Q=0.707107 gainDB=0 h=< 0.47349844 0.94699689 0.47349844 0.94579441 -0.44819937 >,< 3C9B98 793731 3C9B98 790FCA C6A168 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_HighPass_f00500_q00_b0    set 0.47349844       ; 3C9B98
iir2_H_HighPass_f00500_q00_b1    set 0.94699689       ; 793731
iir2_H_HighPass_f00500_q00_b2    set 0.47349844       ; 3C9B98
iir2_H_HighPass_f00500_q00_a1    set 0.94579441       ; 790FCA
iir2_H_HighPass_f00500_q00_a2    set -0.44819937       ; C6A168

; IIR2: mode=HighPass fc=707.107 Q=0.707107 gainDB=0 h=< 0.46299220 0.92598440 0.46299220 0.92363081 -0.42833799 >,< 3B4354 7686A8 3B4354 763989 C92C39 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_HighPass_f00707_q00_b0    set 0.46299220       ; 3B4354
iir2_H_HighPass_f00707_q00_b1    set 0.92598440       ; 7686A8
iir2_H_HighPass_f00707_q00_b2    set 0.46299220       ; 3B4354
iir2_H_HighPass_f00707_q00_a1    set 0.92363081       ; 763989
iir2_H_HighPass_f00707_q00_a2    set -0.42833799       ; C92C39

; IIR2: mode=HighPass fc=1000 Q=0.707107 gainDB=0 h=< 0.44857897 0.89715794 0.44857897 0.89258956 -0.40172633 >,< 396B09 72D612 396B09 724060 CC943C >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_HighPass_f01000_q00_b0    set 0.44857897       ; 396B09
iir2_H_HighPass_f01000_q00_b1    set 0.89715794       ; 72D612
iir2_H_HighPass_f01000_q00_b2    set 0.44857897       ; 396B09
iir2_H_HighPass_f01000_q00_a1    set 0.89258956       ; 724060
iir2_H_HighPass_f01000_q00_a2    set -0.40172633       ; CC943C

; IIR2: mode=HighPass fc=1414.21 Q=0.707107 gainDB=0 h=< 0.42903969 0.85807939 0.42903969 0.84931088 -0.36684790 >,< 36EAC5 6DD58B 36EAC5 6CB638 D10B21 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_HighPass_f01414_q00_b0    set 0.42903969       ; 36EAC5
iir2_H_HighPass_f01414_q00_b1    set 0.85807939       ; 6DD58B
iir2_H_HighPass_f01414_q00_b2    set 0.42903969       ; 36EAC5
iir2_H_HighPass_f01414_q00_a1    set 0.84931088       ; 6CB638
iir2_H_HighPass_f01414_q00_a2    set -0.36684790       ; D10B21

; IIR2: mode=HighPass fc=2000 Q=0.707107 gainDB=0 h=< 0.40297353 0.80594705 0.40297353 0.78936286 -0.32253125 >,< 3394A3 672946 3394A3 6509D7 D6B74C >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_HighPass_f02000_q00_b0    set 0.40297353       ; 3394A3
iir2_H_HighPass_f02000_q00_b1    set 0.80594705       ; 672946
iir2_H_HighPass_f02000_q00_b2    set 0.40297353       ; 3394A3
iir2_H_HighPass_f02000_q00_a1    set 0.78936286       ; 6509D7
iir2_H_HighPass_f02000_q00_a2    set -0.32253125       ; D6B74C

; IIR2: mode=HighPass fc=2828.43 Q=0.707107 gainDB=0 h=< 0.36892836 0.73785672 0.36892836 0.70707082 -0.26864261 >,< 2F390B 5E7217 2F390B 5A814C DD9D1F >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_HighPass_f02828_q00_b0    set 0.36892836       ; 2F390B
iir2_H_HighPass_f02828_q00_b1    set 0.73785672       ; 5E7217
iir2_H_HighPass_f02828_q00_b2    set 0.36892836       ; 2F390B
iir2_H_HighPass_f02828_q00_a1    set 0.70707082       ; 5A814C
iir2_H_HighPass_f02828_q00_a2    set -0.26864261       ; DD9D1F

; IIR2: mode=HighPass fc=4000 Q=0.707107 gainDB=0 h=< 0.32563646 0.65127291 0.32563646 0.59539110 -0.20715472 >,< 29AE74 535CE9 29AE74 4C35C6 E57BF5 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_HighPass_f04000_q00_b0    set 0.32563646       ; 29AE74
iir2_H_HighPass_f04000_q00_b1    set 0.65127291       ; 535CE9
iir2_H_HighPass_f04000_q00_b2    set 0.32563646       ; 29AE74
iir2_H_HighPass_f04000_q00_a1    set 0.59539110       ; 4C35C6
iir2_H_HighPass_f04000_q00_a2    set -0.20715472       ; E57BF5

; IIR2: mode=HighPass fc=5656.85 Q=0.707107 gainDB=0 h=< 0.27230833 0.54461666 0.27230833 0.44563633 -0.14359698 >,< 22DAFF 45B5FF 22DAFF 390A9C ED9E9E >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_HighPass_f05656_q00_b0    set 0.27230833       ; 22DAFF
iir2_H_HighPass_f05656_q00_b1    set 0.54461666       ; 45B5FF
iir2_H_HighPass_f05656_q00_b2    set 0.27230833       ; 22DAFF
iir2_H_HighPass_f05656_q00_a1    set 0.44563633       ; 390A9C
iir2_H_HighPass_f05656_q00_a2    set -0.14359698       ; ED9E9E

; IIR2: mode=HighPass fc=8000 Q=0.707107 gainDB=0 h=< 0.20882291 0.41764582 0.20882291 0.24613286 -0.08915878 >,< 1ABAB5 35756B 1ABAB5 1F8148 F49672 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_HighPass_f08000_q00_b0    set 0.20882291       ; 1ABAB5
iir2_H_HighPass_f08000_q00_b1    set 0.41764582       ; 35756B
iir2_H_HighPass_f08000_q00_b2    set 0.20882291       ; 1ABAB5
iir2_H_HighPass_f08000_q00_a1    set 0.24613286       ; 1F8148
iir2_H_HighPass_f08000_q00_a2    set -0.08915878       ; F49672

; IIR2: mode=HighPass fc=11313.7 Q=0.707107 gainDB=0 h=< 0.13567431 0.27134862 0.13567431 -0.02327410 -0.06597134 >,< 115DC6 22BB8D 115DC6 FD055B F78E41 >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_HighPass_f11313_q00_b0    set 0.13567431       ; 115DC6
iir2_H_HighPass_f11313_q00_b1    set 0.27134862       ; 22BB8D
iir2_H_HighPass_f11313_q00_b2    set 0.13567431       ; 115DC6
iir2_H_HighPass_f11313_q00_a1    set -0.02327410       ; FD055B
iir2_H_HighPass_f11313_q00_a2    set -0.06597134       ; F78E41

; IIR2: mode=HighPass fc=16000 Q=0.707107 gainDB=0 h=< 0.05513904 0.11027807 0.05513904 -0.41129488 -0.13185103 >,< 070ECB 0E1D97 070ECB CB5AB1 EF1F82 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_HighPass_f16000_q00_b0    set 0.05513904       ; 070ECB
iir2_H_HighPass_f16000_q00_b1    set 0.11027807       ; 0E1D97
iir2_H_HighPass_f16000_q00_b2    set 0.05513904       ; 070ECB
iir2_H_HighPass_f16000_q00_a1    set -0.41129488       ; CB5AB1
iir2_H_HighPass_f16000_q00_a2    set -0.13185103       ; EF1F82

; IIR2: mode=HighPass fc=62.5 Q=5 gainDB=0 h=< 0.49954452 0.99908904 0.49954452 0.99906924 -0.49910885 >,< 3FF113 7FE226 3FF113 7FE180 C01D34 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_HighPass_f00062_q05_b0    set 0.49954452       ; 3FF113
iir2_H_HighPass_f00062_q05_b1    set 0.99908904       ; 7FE226
iir2_H_HighPass_f00062_q05_b2    set 0.49954452       ; 3FF113
iir2_H_HighPass_f00062_q05_a1    set 0.99906924       ; 7FE180
iir2_H_HighPass_f00062_q05_a2    set -0.49910885       ; C01D34

; IIR2: mode=HighPass fc=88.3883 Q=5 gainDB=0 h=< 0.49935030 0.99870061 0.49935030 0.99866101 -0.49874020 >,< 3FEAB6 7FD56C 3FEAB6 7FD41F C02948 >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_HighPass_f00088_q05_b0    set 0.49935030       ; 3FEAB6
iir2_H_HighPass_f00088_q05_b1    set 0.99870061       ; 7FD56C
iir2_H_HighPass_f00088_q05_b2    set 0.49935030       ; 3FEAB6
iir2_H_HighPass_f00088_q05_a1    set 0.99866101       ; 7FD41F
iir2_H_HighPass_f00088_q05_a2    set -0.49874020       ; C02948

; IIR2: mode=HighPass fc=125 Q=5 gainDB=0 h=< 0.49907010 0.99814020 0.49907010 0.99806105 -0.49821935 >,< 3FE187 7FC30F 3FE187 7FC077 C03A5A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_HighPass_f00125_q05_b0    set 0.49907010       ; 3FE187
iir2_H_HighPass_f00125_q05_b1    set 0.99814020       ; 7FC30F
iir2_H_HighPass_f00125_q05_b2    set 0.49907010       ; 3FE187
iir2_H_HighPass_f00125_q05_a1    set 0.99806105       ; 7FC077
iir2_H_HighPass_f00125_q05_a2    set -0.49821935       ; C03A5A

; IIR2: mode=HighPass fc=176.777 Q=5 gainDB=0 h=< 0.49866280 0.99732559 0.49866280 0.99716741 -0.49748377 >,< 3FD42E 7FA85D 3FD42E 7FA32E C05274 >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_HighPass_f00176_q05_b0    set 0.49866280       ; 3FD42E
iir2_H_HighPass_f00176_q05_b1    set 0.99732559       ; 7FA85D
iir2_H_HighPass_f00176_q05_b2    set 0.49866280       ; 3FD42E
iir2_H_HighPass_f00176_q05_a1    set 0.99716741       ; 7FA32E
iir2_H_HighPass_f00176_q05_a2    set -0.49748377       ; C05274

; IIR2: mode=HighPass fc=250 Q=5 gainDB=0 h=< 0.49806479 0.99612958 0.49806479 0.99581356 -0.49644560 >,< 3FC096 7F812C 3FC096 7F76D1 C07479 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_HighPass_f00250_q05_b0    set 0.49806479       ; 3FC096
iir2_H_HighPass_f00250_q05_b1    set 0.99612958       ; 7F812C
iir2_H_HighPass_f00250_q05_b2    set 0.49806479       ; 3FC096
iir2_H_HighPass_f00250_q05_a1    set 0.99581356       ; 7F76D1
iir2_H_HighPass_f00250_q05_a2    set -0.49644560       ; C07479

; IIR2: mode=HighPass fc=353.553 Q=5 gainDB=0 h=< 0.49717536 0.99435072 0.49717536 0.99371968 -0.49498176 >,< 3FA371 7F46E2 3FA371 7F3235 C0A470 >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_HighPass_f00353_q05_b0    set 0.49717536       ; 3FA371
iir2_H_HighPass_f00353_q05_b1    set 0.99435072       ; 7F46E2
iir2_H_HighPass_f00353_q05_b2    set 0.49717536       ; 3FA371
iir2_H_HighPass_f00353_q05_a1    set 0.99371968       ; 7F3235
iir2_H_HighPass_f00353_q05_a2    set -0.49498176       ; C0A470

; IIR2: mode=HighPass fc=500 Q=5 gainDB=0 h=< 0.49583082 0.99166164 0.49583082 0.99040244 -0.49292083 >,< 3F7762 7EEEC4 3F7762 7EC582 C0E7F9 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_HighPass_f00500_q05_b0    set 0.49583082       ; 3F7762
iir2_H_HighPass_f00500_q05_b1    set 0.99166164       ; 7EEEC4
iir2_H_HighPass_f00500_q05_b2    set 0.49583082       ; 3F7762
iir2_H_HighPass_f00500_q05_a1    set 0.99040244       ; 7EC582
iir2_H_HighPass_f00500_q05_a2    set -0.49292083       ; C0E7F9

; IIR2: mode=HighPass fc=707.107 Q=5 gainDB=0 h=< 0.49375809 0.98751619 0.49375809 0.98500620 -0.49002618 >,< 3F3377 7E66EE 3F3377 7E14AF C146D3 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_HighPass_f00707_q05_b0    set 0.49375809       ; 3F3377
iir2_H_HighPass_f00707_q05_b1    set 0.98751619       ; 7E66EE
iir2_H_HighPass_f00707_q05_b2    set 0.49375809       ; 3F3377
iir2_H_HighPass_f00707_q05_a1    set 0.98500620       ; 7E14AF
iir2_H_HighPass_f00707_q05_a2    set -0.49002618       ; C146D3

; IIR2: mode=HighPass fc=1000 Q=5 gainDB=0 h=< 0.49049057 0.98098113 0.49049057 0.97598592 -0.48597635 >,< 3EC865 7D90CA 3EC865 7CED1B C1CB87 >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_HighPass_f01000_q05_b0    set 0.49049057       ; 3EC865
iir2_H_HighPass_f01000_q05_b1    set 0.98098113       ; 7D90CA
iir2_H_HighPass_f01000_q05_b2    set 0.49049057       ; 3EC865
iir2_H_HighPass_f01000_q05_a1    set 0.97598592       ; 7CED1B
iir2_H_HighPass_f01000_q05_a2    set -0.48597635       ; C1CB87

; IIR2: mode=HighPass fc=1414.21 Q=5 gainDB=0 h=< 0.48521546 0.97043092 0.48521546 0.96051432 -0.48034752 >,< 3E1B8A 7C3714 3E1B8A 7AF222 C283F9 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_HighPass_f01414_q05_b0    set 0.48521546       ; 3E1B8A
iir2_H_HighPass_f01414_q05_b1    set 0.97043092       ; 7C3714
iir2_H_HighPass_f01414_q05_b2    set 0.48521546       ; 3E1B8A
iir2_H_HighPass_f01414_q05_a1    set 0.96051432       ; 7AF222
iir2_H_HighPass_f01414_q05_a2    set -0.48034752       ; C283F9

; IIR2: mode=HighPass fc=2000 Q=5 gainDB=0 h=< 0.47650148 0.95300297 0.47650148 0.93339277 -0.47261317 >,< 3CFE00 79FC00 3CFE00 77796A C3816A >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_HighPass_f02000_q05_b0    set 0.47650148       ; 3CFE00
iir2_H_HighPass_f02000_q05_b1    set 0.95300297       ; 79FC00
iir2_H_HighPass_f02000_q05_b2    set 0.47650148       ; 3CFE00
iir2_H_HighPass_f02000_q05_a1    set 0.93339277       ; 77796A
iir2_H_HighPass_f02000_q05_a2    set -0.47261317       ; C3816A

; IIR2: mode=HighPass fc=2828.43 Q=5 gainDB=0 h=< 0.46183227 0.92366454 0.46183227 0.88512611 -0.46220297 >,< 3B1D51 763AA3 3B1D51 714BD0 C4D689 >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_HighPass_f02828_q05_b0    set 0.46183227       ; 3B1D51
iir2_H_HighPass_f02828_q05_b1    set 0.92366454       ; 763AA3
iir2_H_HighPass_f02828_q05_b2    set 0.46183227       ; 3B1D51
iir2_H_HighPass_f02828_q05_a1    set 0.88512611       ; 714BD0
iir2_H_HighPass_f02828_q05_a2    set -0.46220297       ; C4D689

; IIR2: mode=HighPass fc=4000 Q=5 gainDB=0 h=< 0.43687722 0.87375444 0.43687722 0.79878283 -0.44872606 >,< 37EB97 6FD72F 37EB97 663E84 C69025 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_HighPass_f04000_q05_b0    set 0.43687722       ; 37EB97
iir2_H_HighPass_f04000_q05_b1    set 0.87375444       ; 6FD72F
iir2_H_HighPass_f04000_q05_b2    set 0.43687722       ; 37EB97
iir2_H_HighPass_f04000_q05_a1    set 0.79878283       ; 663E84
iir2_H_HighPass_f04000_q05_a2    set -0.44872606       ; C69025

; IIR2: mode=HighPass fc=5656.85 Q=5 gainDB=0 h=< 0.39458691 0.78917382 0.39458691 0.64574691 -0.43260072 >,< 3281D3 6503A6 3281D3 52A7D5 C8A08A >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_HighPass_f05656_q05_b0    set 0.39458691       ; 3281D3
iir2_H_HighPass_f05656_q05_b1    set 0.78917382       ; 6503A6
iir2_H_HighPass_f05656_q05_b2    set 0.39458691       ; 3281D3
iir2_H_HighPass_f05656_q05_a1    set 0.64574691       ; 52A7D5
iir2_H_HighPass_f05656_q05_a2    set -0.43260072       ; C8A08A

; IIR2: mode=HighPass fc=8000 Q=5 gainDB=0 h=< 0.32487653 0.64975306 0.32487653 0.38292153 -0.41658458 >,< 29958D 532B1B 29958D 310392 CAAD5C >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_HighPass_f08000_q05_b0    set 0.32487653       ; 29958D
iir2_H_HighPass_f08000_q05_b1    set 0.64975306       ; 532B1B
iir2_H_HighPass_f08000_q05_b2    set 0.32487653       ; 29958D
iir2_H_HighPass_f08000_q05_a1    set 0.38292153       ; 310392
iir2_H_HighPass_f08000_q05_a2    set -0.41658458       ; CAAD5C

; IIR2: mode=HighPass fc=11313.7 Q=5 gainDB=0 h=< 0.21791048 0.43582096 0.21791048 -0.03738121 -0.40902313 >,< 1BE47D 37C8FB 1BE47D FB3718 CBA522 >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_HighPass_f11313_q05_b0    set 0.21791048       ; 1BE47D
iir2_H_HighPass_f11313_q05_b1    set 0.43582096       ; 37C8FB
iir2_H_HighPass_f11313_q05_b2    set 0.21791048       ; 1BE47D
iir2_H_HighPass_f11313_q05_a1    set -0.03738121       ; FB3718
iir2_H_HighPass_f11313_q05_a2    set -0.40902313       ; CBA522

; IIR2: mode=HighPass fc=16000 Q=5 gainDB=0 h=< 0.08109912 0.16219824 0.08109912 -0.60493716 -0.42933365 >,< 0A6174 14C2E9 0A6174 B2916C C90B99 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_HighPass_f16000_q05_b0    set 0.08109912       ; 0A6174
iir2_H_HighPass_f16000_q05_b1    set 0.16219824       ; 14C2E9
iir2_H_HighPass_f16000_q05_b2    set 0.08109912       ; 0A6174
iir2_H_HighPass_f16000_q05_a1    set -0.60493716       ; B2916C
iir2_H_HighPass_f16000_q05_a2    set -0.42933365       ; C90B99

; IIR2: mode=HighPass fc=62.5 Q=10 gainDB=0 h=< 0.49976748 0.99953497 0.49976748 0.99951515 -0.49955478 >,< 3FF861 7FF0C3 3FF861 7FF01D C00E97 >
; Fc/Fs=0.00141723 Wc/Fs=0.00890474 (0123CA) coefficientScale=0.5
iir2_H_HighPass_f00062_q10_b0    set 0.49976748       ; 3FF861
iir2_H_HighPass_f00062_q10_b1    set 0.99953497       ; 7FF0C3
iir2_H_HighPass_f00062_q10_b2    set 0.49976748       ; 3FF861
iir2_H_HighPass_f00062_q10_a1    set 0.99951515       ; 7FF01D
iir2_H_HighPass_f00062_q10_a2    set -0.49955478       ; C00E97

; IIR2: mode=HighPass fc=88.3883 Q=10 gainDB=0 h=< 0.49966543 0.99933087 0.49966543 0.99929125 -0.49937049 >,< 3FF509 7FEA13 3FF509 7FE8C6 C014A1 >
; Fc/Fs=0.00200427 Wc/Fs=0.0125932 (019CA7) coefficientScale=0.5
iir2_H_HighPass_f00088_q10_b0    set 0.49966543       ; 3FF509
iir2_H_HighPass_f00088_q10_b1    set 0.99933087       ; 7FEA13
iir2_H_HighPass_f00088_q10_b2    set 0.49966543       ; 3FF509
iir2_H_HighPass_f00088_q10_a1    set 0.99929125       ; 7FE8C6
iir2_H_HighPass_f00088_q10_a2    set -0.49937049       ; C014A1

; IIR2: mode=HighPass fc=125 Q=10 gainDB=0 h=< 0.49951539 0.99903077 0.49951539 0.99895155 -0.49910999 >,< 3FF01E 7FE03D 3FF01E 7FDDA5 C01D2A >
; Fc/Fs=0.00283447 Wc/Fs=0.0178095 (024794) coefficientScale=0.5
iir2_H_HighPass_f00125_q10_b0    set 0.49951539       ; 3FF01E
iir2_H_HighPass_f00125_q10_b1    set 0.99903077       ; 7FE03D
iir2_H_HighPass_f00125_q10_b2    set 0.49951539       ; 3FF01E
iir2_H_HighPass_f00125_q10_a1    set 0.99895155       ; 7FDDA5
iir2_H_HighPass_f00125_q10_a2    set -0.49910999       ; C01D2A

; IIR2: mode=HighPass fc=176.777 Q=10 gainDB=0 h=< 0.49929175 0.99858349 0.49929175 0.99842511 -0.49874187 >,< 3FE8CA 7FD195 3FE8CA 7FCC65 C0293A >
; Fc/Fs=0.00400854 Wc/Fs=0.0251864 (03394E) coefficientScale=0.5
iir2_H_HighPass_f00176_q10_b0    set 0.49929175       ; 3FE8CA
iir2_H_HighPass_f00176_q10_b1    set 0.99858349       ; 7FD195
iir2_H_HighPass_f00176_q10_b2    set 0.49929175       ; 3FE8CA
iir2_H_HighPass_f00176_q10_a1    set 0.99842511       ; 7FCC65
iir2_H_HighPass_f00176_q10_a2    set -0.49874187       ; C0293A

; IIR2: mode=HighPass fc=250 Q=10 gainDB=0 h=< 0.49895264 0.99790527 0.49895264 0.99758869 -0.49822185 >,< 3FDDAE 7FBB5C 3FDDAE 7FB0FC C03A45 >
; Fc/Fs=0.00566893 Wc/Fs=0.035619 (048F29) coefficientScale=0.5
iir2_H_HighPass_f00250_q10_b0    set 0.49895264       ; 3FDDAE
iir2_H_HighPass_f00250_q10_b1    set 0.99790527       ; 7FBB5C
iir2_H_HighPass_f00250_q10_b2    set 0.49895264       ; 3FDDAE
iir2_H_HighPass_f00250_q10_a1    set 0.99758869       ; 7FB0FC
iir2_H_HighPass_f00250_q10_a2    set -0.49822185       ; C03A45

; IIR2: mode=HighPass fc=353.553 Q=10 gainDB=0 h=< 0.49842754 0.99685507 0.49842754 0.99622245 -0.49748770 >,< 3FCC79 7F98F2 3FCC79 7F8437 C05253 >
; Fc/Fs=0.00801708 Wc/Fs=0.0503728 (06729D) coefficientScale=0.5
iir2_H_HighPass_f00353_q10_b0    set 0.49842754       ; 3FCC79
iir2_H_HighPass_f00353_q10_b1    set 0.99685507       ; 7F98F2
iir2_H_HighPass_f00353_q10_b2    set 0.49842754       ; 3FCC79
iir2_H_HighPass_f00353_q10_a1    set 0.99622245       ; 7F8437
iir2_H_HighPass_f00353_q10_a2    set -0.49748770       ; C05253

; IIR2: mode=HighPass fc=500 Q=10 gainDB=0 h=< 0.49759429 0.99518859 0.49759429 0.99392491 -0.49645226 >,< 3FB12B 7F6257 3FB12B 7F38EE C07441 >
; Fc/Fs=0.0113379 Wc/Fs=0.0712379 (091E53) coefficientScale=0.5
iir2_H_HighPass_f00500_q10_b0    set 0.49759429       ; 3FB12B
iir2_H_HighPass_f00500_q10_b1    set 0.99518859       ; 7F6257
iir2_H_HighPass_f00500_q10_b2    set 0.49759429       ; 3FB12B
iir2_H_HighPass_f00500_q10_a1    set 0.99392491       ; 7F38EE
iir2_H_HighPass_f00500_q10_a2    set -0.49645226       ; C07441

; IIR2: mode=HighPass fc=707.107 Q=10 gainDB=0 h=< 0.49623587 0.99247174 0.49623587 0.98994915 -0.49499432 >,< 3F84A8 7F0950 3F84A8 7EB6A7 C0A407 >
; Fc/Fs=0.0160342 Wc/Fs=0.100746 (0CE53B) coefficientScale=0.5
iir2_H_HighPass_f00707_q10_b0    set 0.49623587       ; 3F84A8
iir2_H_HighPass_f00707_q10_b1    set 0.99247174       ; 7F0950
iir2_H_HighPass_f00707_q10_b2    set 0.49623587       ; 3F84A8
iir2_H_HighPass_f00707_q10_a1    set 0.98994915       ; 7EB6A7
iir2_H_HighPass_f00707_q10_a2    set -0.49499432       ; C0A407

; IIR2: mode=HighPass fc=1000 Q=10 gainDB=0 h=< 0.49395844 0.98791688 0.49395844 0.98288635 -0.49294742 >,< 3F3A07 7E740F 3F3A07 7DCF38 C0E71A >
; Fc/Fs=0.0226757 Wc/Fs=0.142476 (123CA6) coefficientScale=0.5
iir2_H_HighPass_f01000_q10_b0    set 0.49395844       ; 3F3A07
iir2_H_HighPass_f01000_q10_b1    set 0.98791688       ; 7E740F
iir2_H_HighPass_f01000_q10_b2    set 0.49395844       ; 3F3A07
iir2_H_HighPass_f01000_q10_a1    set 0.98288635       ; 7DCF38
iir2_H_HighPass_f01000_q10_a2    set -0.49294742       ; C0E71A

; IIR2: mode=HighPass fc=1414.21 Q=10 gainDB=0 h=< 0.49003669 0.98007338 0.49003669 0.97005825 -0.49008852 >,< 3EB985 7D730B 3EB985 7C2ADE C144C8 >
; Fc/Fs=0.0320683 Wc/Fs=0.201491 (19CA77) coefficientScale=0.5
iir2_H_HighPass_f01414_q10_b0    set 0.49003669       ; 3EB985
iir2_H_HighPass_f01414_q10_b1    set 0.98007338       ; 7D730B
iir2_H_HighPass_f01414_q10_b2    set 0.49003669       ; 3EB985
iir2_H_HighPass_f01414_q10_a1    set 0.97005825       ; 7C2ADE
iir2_H_HighPass_f01414_q10_a2    set -0.49008852       ; C144C8

; IIR2: mode=HighPass fc=2000 Q=10 gainDB=0 h=< 0.48312538 0.96625076 0.48312538 0.94636796 -0.48613357 >,< 3DD70D 7BAE1B 3DD70D 792296 C1C660 >
; Fc/Fs=0.0453515 Wc/Fs=0.284952 (24794C) coefficientScale=0.5
iir2_H_HighPass_f02000_q10_b0    set 0.48312538       ; 3DD70D
iir2_H_HighPass_f02000_q10_b1    set 0.96625076       ; 7BAE1B
iir2_H_HighPass_f02000_q10_b2    set 0.48312538       ; 3DD70D
iir2_H_HighPass_f02000_q10_a1    set 0.94636796       ; 792296
iir2_H_HighPass_f02000_q10_a2    set -0.48613357       ; C1C660

; IIR2: mode=HighPass fc=2828.43 Q=10 gainDB=0 h=< 0.47073966 0.94147932 0.47073966 0.90219760 -0.48076104 >,< 3C4132 788265 3C4132 737B36 C2766C >
; Fc/Fs=0.0641367 Wc/Fs=0.402983 (3394EF) coefficientScale=0.5
iir2_H_HighPass_f02828_q10_b0    set 0.47073966       ; 3C4132
iir2_H_HighPass_f02828_q10_b1    set 0.94147932       ; 788265
iir2_H_HighPass_f02828_q10_b2    set 0.47073966       ; 3C4132
iir2_H_HighPass_f02828_q10_a1    set 0.90219760       ; 737B36
iir2_H_HighPass_f02828_q10_a2    set -0.48076104       ; C2766C

; IIR2: mode=HighPass fc=4000 Q=10 gainDB=0 h=< 0.44838686 0.89677371 0.44838686 0.81982696 -0.47372047 >,< 3964BD 72C97B 3964BD 68F017 C35D21 >
; Fc/Fs=0.0907029 Wc/Fs=0.569903 (48F298) coefficientScale=0.5
iir2_H_HighPass_f04000_q10_b0    set 0.44838686       ; 3964BD
iir2_H_HighPass_f04000_q10_b1    set 0.89677371       ; 72C97B
iir2_H_HighPass_f04000_q10_b2    set 0.44838686       ; 3964BD
iir2_H_HighPass_f04000_q10_a1    set 0.81982696       ; 68F017
iir2_H_HighPass_f04000_q10_a2    set -0.47372047       ; C35D21

; IIR2: mode=HighPass fc=5656.85 Q=10 gainDB=0 h=< 0.40836588 0.81673175 0.40836588 0.66829638 -0.46516712 >,< 344555 688AAA 344555 558ABC C47568 >
; Fc/Fs=0.128273 Wc/Fs=0.805965 (6729DE) coefficientScale=0.5
iir2_H_HighPass_f05656_q10_b0    set 0.40836588       ; 344555
iir2_H_HighPass_f05656_q10_b1    set 0.81673175       ; 688AAA
iir2_H_HighPass_f05656_q10_b2    set 0.40836588       ; 344555
iir2_H_HighPass_f05656_q10_a1    set 0.66829638       ; 558ABC
iir2_H_HighPass_f05656_q10_a2    set -0.46516712       ; C47568

; IIR2: mode=HighPass fc=8000 Q=10 gainDB=0 h=< 0.33903454 0.67806908 0.33903454 0.39960913 -0.45652903 >,< 2B657B 56CAF7 2B657B 332664 C59075 >
; Fc/Fs=0.181406 Wc/Fs=1.13981 (800000) coefficientScale=0.5
iir2_H_HighPass_f08000_q10_b0    set 0.33903454       ; 2B657B
iir2_H_HighPass_f08000_q10_b1    set 0.67806908       ; 56CAF7
iir2_H_HighPass_f08000_q10_b2    set 0.33903454       ; 2B657B
iir2_H_HighPass_f08000_q10_a1    set 0.39960913       ; 332664
iir2_H_HighPass_f08000_q10_a2    set -0.45652903       ; C59075

; IIR2: mode=HighPass fc=11313.7 Q=10 gainDB=0 h=< 0.22830886 0.45661772 0.22830886 -0.03916498 -0.45240043 >,< 1D3939 3A7273 1D3939 FAFCA5 C617BE >
; Fc/Fs=0.256547 Wc/Fs=1.61193 (800000) coefficientScale=0.5
iir2_H_HighPass_f11313_q10_b0    set 0.22830886       ; 1D3939
iir2_H_HighPass_f11313_q10_b1    set 0.45661772       ; 3A7273
iir2_H_HighPass_f11313_q10_b2    set 0.22830886       ; 1D3939
iir2_H_HighPass_f11313_q10_a1    set -0.03916498       ; FAFCA5
iir2_H_HighPass_f11313_q10_a2    set -0.45240043       ; C617BE

; IIR2: mode=HighPass fc=16000 Q=10 gainDB=0 h=< 0.08407341 0.16814682 0.08407341 -0.62712308 -0.46341673 >,< 0AC2EA 1585D5 0AC2EA AFBA6F C4AEC3 >
; Fc/Fs=0.362812 Wc/Fs=2.27961 (800000) coefficientScale=0.5
iir2_H_HighPass_f16000_q10_b0    set 0.08407341       ; 0AC2EA
iir2_H_HighPass_f16000_q10_b1    set 0.16814682       ; 1585D5
iir2_H_HighPass_f16000_q10_b2    set 0.08407341       ; 0AC2EA
iir2_H_HighPass_f16000_q10_a1    set -0.62712308       ; AFBA6F
iir2_H_HighPass_f16000_q10_a2    set -0.46341673       ; C4AEC3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\IO.h ===
;**************************************************************************
;
;  IO.h    

;**************************************************************************        
	include 'io56kevm.h'


kFrameLength	equ		32
kPCValue		equ		0
kCounter		equ		0

;
; NOTE: keep this in sync with dsound.h and the number of fx sends
; dsound mcpx uses
;

NUM_FX_SEND_BINS    equ     20

; ==============================================================
; Global Processor (GP) Address Map as viewed from dma controller
; ==============================================================
; 24 bit words (3 bytes) in 32-bit containers (4 bytes)
;
; Peripheral registers (Control,Status) mapped to upper 128 words
; of X-memory (0xFFFF80 to 0xFFFFFF) (use compact movep instruction)
;
; DSP    memory addresses in words
; System memory address   in bytes 

kGPMemory_Size_XRAM		equ (4*1024)
kGPMemory_Size_YRAM		equ (2*1024)
kGPMemory_Size_PRAM		equ (4*1024)

kGPMemory_Base					equ $000000
kGPMemory_XRAM_Base				equ (kGPMemory_Base+$000000)		; $000000 .. $000BFF
kGPMemory_XRAM_MixBufferTemp	equ (kGPMemory_XRAM_Base+$000C00)	; $000C00 .. $000FFF
kGPMemory_XRAM_Unused			equ (kGPMemory_XRAM_Base+$001000)	; $001000 .. $0013FF
kGPMemory_XRAM_MixBufferRead	equ (kGPMemory_XRAM_Base+$001400)	; $001400 .. $0017FF
kGPMemory_XRAM_PeripheralRegs	equ (kGPMemory_XRAM_Base+$FFFF80)	; $FFFF80 .. $FFFFFF

kGPMemory_Base_YRAM				equ $1800
kGPMemory_Base_PRAM				equ $2800


; Define these so I don't have to update older files
kGPMemory_Base_XRAM	equ kGPMemory_XRAM_Base
kGPMemory_YRAM_Base	equ kGPMemory_Base_YRAM	

; ==============================================================
; Encode Processor (EP) Address Map 
; ==============================================================
; 24 bit words (3 bytes) in 32-bit containers (4 bytes)
;
; Peripheral registers (Control,Status) mapped to upper 128 words
; of X-memory (0xFFFF80 to 0xFFFFFF) (use compact movep instruction)
;
; DSP    memory addresses in words
; System memory address   in bytes 

kEPMemory_Size_XRAM		equ (3*1024)
kEPMemory_Size_YRAM		equ     256
kEPMemory_Size_YROM		equ (2*1024)
kEPMemory_Size_PRAM		equ (4*1024)

kEPMemory_Base				equ $000000
kEPMemory_Base_XRAM			equ (kEPMemory_Base+$000000)		; $000000 .. $000BFF
kEPMemory_Base_XRAM_PeripheralRegs	equ (kEPMemory_Base_XRAM+$FFFF80)	; $FFFF80 .. $FFFFFF

kEPMemory_Base_YRAM			equ (kEPMemory_Base+$001800)
kEPMemory_Base_YROM			equ (kEPMemory_Base_YRAM+$000800)
kEPMemory_Base_PRAM			equ (kEPMemory_Base+$002000)
kEPMemory_Base_PRAM_BootRom		equ (kEPMemory_Base_PRAM+$FF000)	; $FF0000 .. $FF003F

; ==============================================================
; NOTE:Scratch memory offsets for various GP data blocks
; this MUST match what is in tools\xps2\dsp.h!!!!!
; ==============================================================
; Byte Addresses of Command Node data blocks (DMA'd on the fly)
SM_OFFSET_COMMAND_BLOCK		equ		 2048 


; ==============================================================
; Command block : used to communicate with DSP default loader program
; ==============================================================

COMMAND_BLOCK_FIELD_OFFSET      						equ	0
COMMAND_BLOCK_FIELD_CODE_LENGTH							equ	1
COMMAND_BLOCK_FIELD_STATE_OFFSET                        equ 2
COMMAND_BLOCK_FIELD_STATE_LENGTH						equ	3
COMMAND_BLOCK_FIELD_COMMAND_FLAGS						equ	4
COMMAND_BLOCK_FIELD_STATUS   							equ	5

DATASIZE_DWORD                  equ 4
DATASIZE_COMMAND_BLOCK	        equ	(1+COMMAND_BLOCK_FIELD_STATUS)
DATASIZE_BYTES_COMMAND_BLOCK    equ (DATASIZE_COMMAND_BLOCK*4)


;
; the AC3 dma output gets placed right after the end of scratch space
; NOTE: THIS MUST STAY IN SYNC WITH OFFSET CALCULATED IN DSP.H

SM_OFFSET_AC3_DMA_OUTPUT        equ $8000

;
; the number belows comes form the following calc in mcpxhw.h
; #define MCPX_HW_AC3_NUM_INPUT_PAGES     (((AC3_BUFFER_COUNT * AC3_FRAME_SIZE * AC3_CONTAINER_SIZE * AC3_NUM_CHANNELS) + PAGE_SIZE-1)  / PAGE_SIZE)
;

DATASIZE_BYTES_AC3_DMA_OUTPUT   equ (4096*3)

SM_OFFSET_CODE_BLOCK            equ (SM_OFFSET_COMMAND_BLOCK+DATASIZE_BYTES_COMMAND_BLOCK)
SM_OFFSET_MULTIPASS_BUFFER      equ (SM_OFFSET_AC3_DMA_OUTPUT+DATASIZE_BYTES_AC3_DMA_OUTPUT)
DATASIZE_MULTIPASS_BUFFER       equ (kFrameLength*NUM_FX_SEND_BINS)
DATASIZE_BYTES_MULTIPASS_BUFFER equ (DATASIZE_MULTIPASS_BUFFER*DATASIZE_DWORD)

BIT_COMMAND_BLOCK_COMMAND_PRESENT			equ	0
BIT_COMMAND_BLOCK_COMMAND_LOAD_CODE         equ 0
BIT_COMMAND_BLOCK_COMMAND_LOAD_XRAM_STATE   equ 1
BIT_COMMAND_BLOCK_COMMAND_UPDATE_XRAM_STATE equ 2
    
; status definitions

COMMAND_BLOCK_STATUS_IDLE         equ $AA
COMMAND_BLOCK_STATUS_PROCESSED_CMD          equ $FF


; the global block of the concatenated FX state will be placed at the
; the following offset

GLOBAL_FX_STATE_XRAM_BASE_OFFSET   equ 128 ; eq of 512 in SM
DATASIZE_GLOBAL_FX_STATE           equ 512 ; eq. of 2048 bytes in system ram

AC3_BUFFER_SIZE                    equ $800

;
; debug variables
;

DATASIZE_DEBUG_VARIABLES           equ 4
DEBUG_VARIABLES_OFFSET             equ (GLOBAL_FX_STATE_XRAM_BASE_OFFSET-DATASIZE_DEBUG_VARIABLES)


; definition of the DSP_STATE_FIXED data struct that each FX state block
; has at the base of its X-memory state area

FX_STATE_SCRATCH_BASE    equ 0
FX_STATE_SCRATCH_LENGTH  equ 1
FX_STATE_YMEM_BASE       equ 2
FX_STATE_YMEM_LENGTH     equ 3
FX_STATE_FLAGS           equ 4

DATASIZE_FX_STATE_FIXED  equ 5

;
; flag definitions
;

BIT_FX_STATE_FLAG_INITIALIZED equ $0
VALUE_FX_STATE_FLAG_INITIALIZED  equ $1

BIT_FX_STATE_FLAG_GLOBAL_FX   equ $1
VALUE_FX_STATE_FLAG_GLOBAL_FX equ $2

BIT_FX_STATE_FLAG_UPDATE   equ $2
VALUE_FX_STATE_FLAG_UPDATE equ $4

BIT_FX_STATE_FLAG_PROCESS_STEREO   equ $3
VALUE_FX_STATE_FLAG_PROCESS_STEREO equ $8

; zero inputs Data struct

FX_STATE_IO0_OUT0		    equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO0_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO0_OUT2		    equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO0_OUT3		    equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO0_OUT4		    equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO0_OUT5		    equ	(DATASIZE_FX_STATE_FIXED+5)
FX_STATE_IO0_OUT6		    equ	(DATASIZE_FX_STATE_FIXED+6)
FX_STATE_IO0_OUT7		    equ	(DATASIZE_FX_STATE_FIXED+7)



; Mono In, Mono Out Data Structure
FX_STATE_IO1_IN			    equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO1_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO1_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO1_OUT2		    equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO1_OUT3		    equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO1_OUT4		    equ	(DATASIZE_FX_STATE_FIXED+5)
FX_STATE_IO1_OUT5		    equ	(DATASIZE_FX_STATE_FIXED+6)
FX_STATE_IO1_OUT6		    equ	(DATASIZE_FX_STATE_FIXED+7)
FX_STATE_IO1_OUT7		    equ	(DATASIZE_FX_STATE_FIXED+8)


; Stereo In, Stereo Out Data Structure
FX_STATE_IO2_INL			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO2_INR			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO2_OUTL		    equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO2_OUTR		    equ	(DATASIZE_FX_STATE_FIXED+3)

; 2 inputs, 1 outputs
FX_STATE_IO2_IN0			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO2_IN1			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO2_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+2)

; 2 inputs, 4 outputs
FX_STATE_IO2_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO2_OUT2		    equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO2_OUT3		    equ	(DATASIZE_FX_STATE_FIXED+5)

; 3 inputs, 2 outputs
FX_STATE_IO3_IN0			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO3_IN1			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO3_IN2			equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO3_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO3_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+4)

; 4 inputs, 2 outputs
FX_STATE_IO4_IN0			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO4_IN1			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO4_IN2			equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO4_IN3			equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO4_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO4_OUT1		    equ	(DATASIZE_FX_STATE_FIXED+5)

; 4 inputs, 4 outputs
FX_STATE_IO4_OUT2		    equ	(DATASIZE_FX_STATE_FIXED+6)
FX_STATE_IO4_OUT3		    equ	(DATASIZE_FX_STATE_FIXED+7)

; 6 inputs, 1 output
FX_STATE_IO6_IN0			equ	(DATASIZE_FX_STATE_FIXED)
FX_STATE_IO6_IN1			equ	(DATASIZE_FX_STATE_FIXED+1)
FX_STATE_IO6_IN2			equ	(DATASIZE_FX_STATE_FIXED+2)
FX_STATE_IO6_IN3			equ	(DATASIZE_FX_STATE_FIXED+3)
FX_STATE_IO6_IN4			equ	(DATASIZE_FX_STATE_FIXED+4)
FX_STATE_IO6_IN5			equ	(DATASIZE_FX_STATE_FIXED+5)
FX_STATE_IO6_OUT0		    equ	(DATASIZE_FX_STATE_FIXED+6)

DATASIZE_DSP_FX_STATE_MONO      equ (FX_STATE_IO1_OUT0+1)
DATASIZE_DSP_FX_STATE_1IN_2OUT  equ (FX_STATE_IO1_OUT1+1)
DATASIZE_DSP_FX_STATE_1IN_4OUT  equ (FX_STATE_IO1_OUT3+1)
DATASIZE_DSP_FX_STATE_1IN_8OUT  equ (FX_STATE_IO1_OUT7+1)

DATASIZE_DSP_FX_STATE_STEREO    equ (FX_STATE_IO2_OUTR+1)

DATASIZE_DSP_FX_STATE_2IN_1OUT  equ (FX_STATE_IO2_OUT0+1)
DATASIZE_DSP_FX_STATE_2IN_4OUT  equ (FX_STATE_IO2_OUT3+1)

DATASIZE_DSP_FX_STATE_3IN_2OUT  equ (FX_STATE_IO3_OUT1+1)

DATASIZE_DSP_FX_STATE_4IN_2OUT  equ (FX_STATE_IO4_OUT1+1)
DATASIZE_DSP_FX_STATE_4IN_4OUT  equ (FX_STATE_IO4_OUT3+1)

DATASIZE_DSP_FX_STATE_6IN_1OUT  equ (FX_STATE_IO6_OUT0+1)

DATASIZE_DSP_FX_STATE_6IN_0OUT  equ (FX_STATE_IO6_OUT0)


kFxOutShift	equ	2
kFxOutGain	set	32.0
kFxInGain	set	(1.0/2.0)

; **** Mix Buffer definitions
; The 1K of Mix buffer memory can be used as "standard" 
; read/write memory at X-memory address locations 0x0C00 
; through 0x0FFF (24-bit word address).  However, 
; since this memory is "flipped" at each frame, only 
; variables that do not need to persist beyond a frame 
; boundary can be stored here.

; The 1K of Mix buffer memory can be read at a second 
; address region, X-memory address locations 0x1400 through
; 0x17FF.  In this area, the 32 "mix valid" bits are used 
; to force the data to "0" when the bin is "not valid".  
; this guarantees that bins without voices will read "0" 
; samples (quiet audio).

; Lower 16 mix buffers: 512 words, 32 words x 16 buffers
; Address $C00..$DFF = 3072 ..3583
kMixBufBase	equ		$1400		
kMixBuf00	equ		(kMixBufBase)
kMixBuf01	equ		(kMixBuf00+kFrameLength)
kMixBuf02	equ		(kMixBuf01+kFrameLength)
kMixBuf03	equ		(kMixBuf02+kFrameLength)
kMixBuf04	equ		(kMixBuf03+kFrameLength)
kMixBuf05	equ		(kMixBuf04+kFrameLength)
kMixBuf06	equ		(kMixBuf05+kFrameLength)
kMixBuf07	equ		(kMixBuf06+kFrameLength)
kMixBuf08	equ		(kMixBuf07+kFrameLength)
kMixBuf09	equ		(kMixBuf08+kFrameLength)
kMixBuf10	equ		(kMixBuf09+kFrameLength)
kMixBuf11	equ		(kMixBuf10+kFrameLength)
kMixBuf12	equ		(kMixBuf11+kFrameLength)
kMixBuf13	equ		(kMixBuf12+kFrameLength)
kMixBuf14	equ		(kMixBuf13+kFrameLength)
kMixBuf15	equ		(kMixBuf14+kFrameLength)

; Lower 16 mix buffers: 512 words, 32 words x 16 buffers
; Address $E00..$FFF = 3584 ..3FFF
kMixBuf16	equ		(kMixBuf15+kFrameLength)
kMixBuf17	equ		(kMixBuf16+kFrameLength)
kMixBuf18	equ		(kMixBuf17+kFrameLength)
kMixBuf19	equ		(kMixBuf18+kFrameLength)
kMixBuf20	equ		(kMixBuf19+kFrameLength)
kMixBuf21	equ		(kMixBuf20+kFrameLength)
kMixBuf22	equ		(kMixBuf21+kFrameLength)
kMixBuf23	equ		(kMixBuf22+kFrameLength)
kMixBuf24	equ		(kMixBuf23+kFrameLength)
kMixBuf25	equ		(kMixBuf24+kFrameLength)
kMixBuf26	equ		(kMixBuf25+kFrameLength)
kMixBuf27	equ		(kMixBuf26+kFrameLength)
kMixBuf28	equ		(kMixBuf27+kFrameLength)
kMixBuf29	equ		(kMixBuf28+kFrameLength)
kMixBuf30	equ		(kMixBuf29+kFrameLength)
kMixBuf31	equ		(kMixBuf30+kFrameLength)

kMixBuf0	equ		kMixBuf00
kMixBuf1	equ		kMixBuf01
kMixBuf2	equ		kMixBuf02
kMixBuf3	equ		kMixBuf03
kMixBuf4	equ		kMixBuf04
kMixBuf5	equ		kMixBuf05
kMixBuf6	equ		kMixBuf06
kMixBuf7	equ		kMixBuf07
kMixBuf8	equ		kMixBuf08
kMixBuf9	equ		kMixBuf09

kTmpBufBase	equ		(GLOBAL_FX_STATE_XRAM_BASE_OFFSET+DATASIZE_GLOBAL_FX_STATE)	
kTmpBufCount	equ		4	
kTmpBuf00	equ		kTmpBufBase
kTmpBuf01	equ		(kTmpBuf00+kFrameLength)
kTmpBuf02	equ		(kTmpBuf01+kFrameLength)
kTmpBuf03	equ		(kTmpBuf02+kFrameLength)

kTmpBuf0	equ		kTmpBuf00
kTmpBuf1	equ		kTmpBuf01
kTmpBuf2	equ		kTmpBuf02
kTmpBuf3	equ		kTmpBuf03


kReadWriteMixBufBase    equ     $C00
kReadWriteMixBuf00	equ		(kReadWriteMixBufBase)
kReadWriteMixBuf01	equ		(kReadWriteMixBuf00+kFrameLength)
kReadWriteMixBuf02	equ		(kReadWriteMixBuf01+kFrameLength)
kReadWriteMixBuf03	equ		(kReadWriteMixBuf02+kFrameLength)
kReadWriteMixBuf04	equ		(kReadWriteMixBuf03+kFrameLength)
kReadWriteMixBuf05	equ		(kReadWriteMixBuf04+kFrameLength)
kReadWriteMixBuf06	equ		(kReadWriteMixBuf05+kFrameLength)
kReadWriteMixBuf07	equ		(kReadWriteMixBuf06+kFrameLength)
kReadWriteMixBuf08	equ		(kReadWriteMixBuf07+kFrameLength)
kReadWriteMixBuf09	equ		(kReadWriteMixBuf08+kFrameLength)
kReadWriteMixBuf10	equ		(kReadWriteMixBuf09+kFrameLength)
kReadWriteMixBuf11	equ		(kReadWriteMixBuf10+kFrameLength)
kReadWriteMixBuf12	equ		(kReadWriteMixBuf11+kFrameLength)
kReadWriteMixBuf13	equ		(kReadWriteMixBuf12+kFrameLength)
kReadWriteMixBuf14	equ		(kReadWriteMixBuf13+kFrameLength)
kReadWriteMixBuf15	equ		(kReadWriteMixBuf14+kFrameLength)

; Lower 16 mix buffers: 512 words, 32 words x 16 buffers
; Address $E00..$FFF = 3584 ..3FFF
kReadWriteMixBuf16	equ		(kReadWriteMixBuf15+kFrameLength)
kReadWriteMixBuf17	equ		(kReadWriteMixBuf16+kFrameLength)
kReadWriteMixBuf18	equ		(kReadWriteMixBuf17+kFrameLength)
kReadWriteMixBuf19	equ		(kReadWriteMixBuf18+kFrameLength)
kReadWriteMixBuf20	equ		(kReadWriteMixBuf19+kFrameLength)
kReadWriteMixBuf21	equ		(kReadWriteMixBuf20+kFrameLength)
kReadWriteMixBuf22	equ		(kReadWriteMixBuf21+kFrameLength)
kReadWriteMixBuf23	equ		(kReadWriteMixBuf22+kFrameLength)
kReadWriteMixBuf24	equ		(kReadWriteMixBuf23+kFrameLength)
kReadWriteMixBuf25	equ		(kReadWriteMixBuf24+kFrameLength)
kReadWriteMixBuf26	equ		(kReadWriteMixBuf25+kFrameLength)
kReadWriteMixBuf27	equ		(kReadWriteMixBuf26+kFrameLength)
kReadWriteMixBuf28	equ		(kReadWriteMixBuf27+kFrameLength)
kReadWriteMixBuf29	equ		(kReadWriteMixBuf28+kFrameLength)
kReadWriteMixBuf30	equ		(kReadWriteMixBuf29+kFrameLength)
kReadWriteMixBuf31	equ		(kReadWriteMixBuf30+kFrameLength)

;
; friendly names that match mixbins indices in dsound.h
;

kFrontLeftMixBufRW	    equ		(kReadWriteMixBufBase)
kFrontRightMixBufRW	    equ		(kReadWriteMixBuf00+kFrameLength)
kFrontCenterMixBufRW	equ		(kReadWriteMixBuf01+kFrameLength)
kLFEMixBufRW      	    equ		(kReadWriteMixBuf02+kFrameLength)
kBackLeftMixBufRW 	    equ		(kReadWriteMixBuf03+kFrameLength)
kBackRightMixBufRW	    equ		(kReadWriteMixBuf04+kFrameLength)
kXTLKFrontLeftMixBufRW	equ		(kReadWriteMixBuf05+kFrameLength)
kXTLKFrontRightMixBufRW	equ		(kReadWriteMixBuf06+kFrameLength)
kXTLKBackLeftMixBufRW	equ		(kReadWriteMixBuf07+kFrameLength)
kXTLKBackRightMixBufRW	equ		(kReadWriteMixBuf08+kFrameLength)
kI3DL2MixBufRW    	    equ		(kReadWriteMixBuf09+kFrameLength)
kFxSendMixBuf00RW 	    equ		(kReadWriteMixBuf10+kFrameLength)

kFrontLeftMixBuf	    equ		(kMixBufBase)
kFrontRightMixBuf	    equ		(kMixBuf00+kFrameLength)
kFrontCenterMixBuf	    equ		(kMixBuf01+kFrameLength)
kLFEMixBuf      	    equ		(kMixBuf02+kFrameLength)
kBackLeftMixBuf 	    equ		(kMixBuf03+kFrameLength)
kBackRightMixBuf	    equ		(kMixBuf04+kFrameLength)
kXTLKFrontLeftMixBuf	equ		(kMixBuf05+kFrameLength)
kXTLKFrontRightMixBuf	equ		(kMixBuf06+kFrameLength)
kXTLKBackLeftMixBuf 	equ		(kMixBuf07+kFrameLength)
kXTLKBackRightMixBuf	equ		(kMixBuf08+kFrameLength)
kI3DL2MixBuf    	    equ		(kMixBuf09+kFrameLength)
kFxSendMixBuf00 	    equ		(kMixBuf10+kFrameLength)
kFxSendMixBuf01 	    equ		(kMixBuf11+kFrameLength)
kFxSendMixBuf02 	    equ		(kMixBuf12+kFrameLength)
kFxSendMixBuf03 	    equ		(kMixBuf13+kFrameLength)
kFxSendMixBuf04 	    equ		(kMixBuf14+kFrameLength)
kFxSendMixBuf05 	    equ		(kMixBuf15+kFrameLength)
kFxSendMixBuf06 	    equ		(kMixBuf16+kFrameLength)
kFxSendMixBuf07 	    equ		(kMixBuf17+kFrameLength)
kFxSendMixBuf08 	    equ		(kMixBuf18+kFrameLength)
kFxSendMixBuf09 	    equ		(kMixBuf19+kFrameLength)
kFxSendMixBuf10 	    equ		(kMixBuf20+kFrameLength)


;************************************************************
; mSetUpIO		Set up analog I/O for Motorola EVM board
;************************************************************
mSetUpIO	macro

	ori     #$03,mr                ; mask interrupts

; Clear inputs & outputs
	move    #>(ioData+IO_RX_BUFF_BASE),r0      
	move    #>$FFFF,m0
	move    #0,x0
	rep     #4
	move    x0,x:(r0)+              

	move    #>(ioData+IO_RX_BUFF_BASE),x0
	move    x0,x:(ioData+IO_RX_PTR)
	move    #>(ioData+IO_TX_BUFF_BASE),x0
	move    x0,x:(ioData+IO_TX_PTR)

;------------------------------------------------------------
; FST/FSR and SCKT/SCKR are generated from the PLD
; and fed to the DSP, A/D and D/A converters
;------------------------------------------------------------

	movep   #$0c0200,x:M_TCCR
		;FST is input                            (bit22=0)
		;external clock source drives SCKT       (bit21=0)
		;negative FST polarity                   (bit19=1)
		;data & FST clocked out on rising edge  (bit18=1)
		;2 words per frame                       (bit13:9=00001)

	 movep   #$0c0200,x:M_RCCR
			       
       ; movep   #$080200,x:M_RCCR
		;FSR is input                            (bit22=0)
		;external clock source drives SCKR       (bit21=0)
		;negative FSR polarity                   (bit19=1)
		;data & FSR clocked in on rising edge   (bit18=0)BAK(121997)
		;2 words per frame                       (bit13:9=00001)

	movep   #$000000,x:M_SAICR

	movep   #$d17D01,x:M_RCR                        ;RX0 enabled
		;RX1 enabled                             (bit1=1) MLS 12/20/97
		;RX0, RX2, RX3 disabled                  (bit3:2,0=000)
		;reserved                                (bit5:4=00)  
		;MSB shifted first                       (bit6=0)
		;word left-aligned                       (bit7=0)
		;network mode                            (bit9:8=01)
		;32-bit slot length, 24-bit word length  (bit14:10=11111)
		;word-length frame sync                  (bit15=0)
		;frame sync occurs 1 clock cycle earlier (bit16=1)
		;reserved                                (bit19:17=000)
		;RLIE, RIE, REIE enabled                 (bit23:20=0101)
		;bit23 RLIE
		;bit22 RIE
		;bit21 REDIE
		;bit20 REIE

	movep   #$d17d00,x:M_TCR                      ; Mithra 08-09-99
		;TX0, TX1, TX2 enabled                   (bit3:0=0011)
		;TX3, TX4, TX5 disabled                  (bit5:4=00)
		;MSB shifted first                       (bit6=0)
		;word left-aligned                       (bit7=0)
		;network mode                            (bit9:8=01)
		;32-bit slot length, 24-bit word length  (bit14:10=11111)
		;word length frame sync                  (bit15=0)
		;frame sync occurs 1 clock cycle earlier (bit16=0)
		;reserved                                (bit19:17=000)
		;TLIE, TIE, TEIE enabled                 (bit23:20=0101)
		;bit23 TLIE
		;bit22 TIE
		;bit21 TEDIE
		;bit20 TEIE


	movep   #$000fdb,x:M_PCRC       ; SDO0-SDO3 set for ESAI  - Mithra	 09-08-99
	movep   #$000fdb,x:M_PRRC       ; SDO0-SDO3 set for ESAI  - Mithra	 09-08-99


	movep   #$ffffff,x:M_RSMA        ;MLS 12/20/97
	movep   #$ffffff,x:M_RSMB        ;MLS 12/20/97

	movep   #$000003,x:M_TSMA
	movep   #$000003,x:M_TSMB
	movep   #$000000,x:M_TX0        ;zero out transmitter 0
	movep   #$000000,x:M_TX1        ;zero out transmitter 1
	movep   #$000000,x:M_TX2        ;zero out transmitter 2
	movep   #$000000,x:M_TX3        ;zero out transmitter 3
	bset    #0,x:M_TCR              ;now enable TX0
	bset    #1,x:M_TCR              ;now enable TX1
	bset    #2,x:M_TCR              ;now enable TX2
	bset    #3,x:M_TCR              ;now enable TX3

	andi    #$FC,mr                 ;enable all interrupt levels

	endm
; ---- end mSetUpIO ----

;************************************************************
; mWaitForInputData	
;************************************************************
mWaitForInputData	macro
       jclr    #kRightReceive,X:(ioData+IO_FLAGS),*
       bclr    #kRightReceive,X:(ioData+IO_FLAGS)
	endm

;************************************************************
; mMonoOut	Output reg A to left and right channels
;************************************************************
mMonoOut	macro

; Output 
	move    a,x:(ioData+IO_TX_BUFF_BASE)       ; left
	move    a,x:(ioData+IO_TX_BUFF_BASE+1)      ; right
	endm

;************************************************************
; mStereoOut	Output reg A,B to left and right channels
;************************************************************
mStereoOut	macro

; Output 
	move    a,x:(ioData+IO_TX_BUFF_BASE)       ; left
	move    b,x:(ioData+IO_TX_BUFF_BASE+1)      ; right
	endm

;************************************************************
; mFxStereoIn	
;************************************************************
mFxStereoIn	macro
	move	#>kFxInGain,y0
	move	x:(ioData+IO_RX_BUFF_BASE),x0
	mpy		x0,y0,a
	move	a,x:(fxIOData+FXIO_INL)
	move	x:(ioData+IO_RX_BUFF_BASE+1),x0
	mpy		x0,y0,a
	move	a,x:(fxIOData+FXIO_INR)
	endm

;************************************************************
; mFxOutLToIn	
;************************************************************
mFxOutLToIn	macro
	move	x:(fxIOData+FXIO_OUTL),x0
	move	x0,x:(fxIOData+FXIO_INL)
	endm

;************************************************************
; mFxInLToOutL	
;************************************************************
mFxInLToOutL	macro
	move	x:(fxIOData+FXIO_INL),x0
	move	x0,x:(fxIOData+FXIO_OUTL)
	endm

;************************************************************
; mFxOutLToOutR	
;************************************************************
mFxOutLToOutR	macro
	move	x:(fxIOData+FXIO_OUTL),x0
	move	x0,x:(fxIOData+FXIO_OUTR)
	endm

;************************************************************
; mFxMonoOut	Copy left channel to right and output
;************************************************************
mFxMonoOut	macro
;	move	#>0.99,y0
;	move	x:(fxIOData+FXIO_OUTL),x0
;	mpy	x0,y0,a
;	asl	#>kFxOutShift,a,a
;	move	x:(fxIOData+FXIO_OUTR),x0
;	mpy	x0,y0,b
;	asl	#fxOutShift,b,b
	move	x:(fxIOData+FXIO_OUTL),a

; Output 
	move    a,x:(ioData+IO_TX_BUFF_BASE)       ; left
	move    a,x:(ioData+IO_TX_BUFF_BASE+1)      ; right
	endm

;************************************************************
; mFxStereoOut	
;************************************************************
mFxStereoOut	macro
;	move	#>0.99,y0
;	move	x:(fxIOData+FXIO_OUTL),x0
;	mpy	x0,y0,a
;	asl	#>kFxOutShift,a,a
;	move	x:(fxIOData+FXIO_OUTR),x0
;	mpy	x0,y0,b
;	asl	#fxOutShift,b,b

	move	x:(fxIOData+FXIO_OUTL),a
	move	x:(fxIOData+FXIO_OUTR),b
; Output 
	move    a,x:(ioData+IO_TX_BUFF_BASE)       ; left
	move    b,x:(ioData+IO_TX_BUFF_BASE+1)      ; right
	endm

;************************************************************
; mResetFxIn	Clear FX variable state
;************************************************************
mResetFxIn	macro
; Clear Fx Outputs
	move	#0,x0
	move	x0,x:(fxIOData+FXIO_INL)
	move	x0,x:(fxIOData+FXIO_INR)
	endm

;************************************************************
; mResetFxOut	Clear FX variable state
;************************************************************
mResetFxOut	macro
; Clear Fx Outputs
	move	#0,x0
	move	x0,x:(fxIOData+FXIO_OUTL)
	move	x0,x:(fxIOData+FXIO_OUTR)
	endm

;************************************************************
; mResetFxIO	Clear FX variable state
;************************************************************
mResetFxIO	macro
	mResetFxIn
	mResetFxOut
	endm

;************************************************************
; mFxInToModuleIO1	Copy FX input to module input of IO1 structure
;************************************************************
mFxInToModuleIO1	macro
	move	x:(fxIOData+FXIO_INL),x0
	move	x0,x:(rD+IO1_IN)
	endm

;************************************************************
; mFxInToModuleIO2	Copy FX input to module input of IO2 structure
;************************************************************
mFxInToModuleIO2	macro
	move	x:(fxIOData+FXIO_INL),x0
	move	x0,x:(rD+IO2_IN1)
	endm

;************************************************************
; mModuleIO1toFxOutL	Copy output of IO1 structure to FX output
;************************************************************
mModuleIO1toFxOutL	macro
	move	x:(rD+IO1_OUT),x0
	move	x0,x:(fxIOData+FXIO_OUTL)
	endm

;************************************************************
; mModuleIO1AddtoFxOutL	Add output of IO1 structure to FX output
;************************************************************
mModuleIO1AddtoFxOutL	macro
	move	x:(fxIOData+FXIO_OUTL),a
	move	x:(rD+IO1_OUT),x0
	add		x0,a
	move	a,x:(fxIOData+FXIO_OUTL)
	endm

;************************************************************
; mFxOutLToModuleIO1In	Copy output of IO1 structure to FX output
;************************************************************
mFxOutLToModuleIO1In	macro
	move	x:(fxIOData+FXIO_OUTL),x0
	move	x0,x:(rD+IO1_IN)
	endm

;************************************************************
; mModuleIO1toFxOutR	Copy output of IO1 structure to FX output
;************************************************************
mModuleIO1toFxOutR	macro
	move	x:(rD+IO1_OUT),x0
	move	x0,x:(fxIOData+FXIO_OUTR)
	endm

;************************************************************
; mModuleIO1AddtoFxOutR	Add output of IO1 structure to FX output
;************************************************************
mModuleIO1AddtoFxOutR	macro
	move	x:(fxIOData+FXIO_OUTR),a
	move	x:(rD+IO1_OUT),x0
	add		x0,a
	move	a,x:(fxIOData+FXIO_OUTR)
	endm

;************************************************************
; mFxOutRToModuleIO1In	Copy output of IO1 structure to FX output
;************************************************************
mFxOutRToModuleIO1In	macro
	move	x:(fxIOData+FXIO_OUTR),x0
	move	x0,x:(rD+IO1_IN)
	endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Io56kevm.h ===
;*********************************************************************************

;

;     EQUATES for DSP56362 I/O registers and ports

;     Reference: DSP56362 Specifications Revision 0.2 

;

;     Last update: November 6, 1997

;

;*********************************************************************************



    page    132,55,0,0,0

    opt    mex



ioequ   ident   1,0

kRightReceive    equ     0 

kStackBase	equ $40
kStackTop	equ	kStackBase+32

;************************************************************
; mInitStack		
;************************************************************
mInitStack	macro

	ori     #$03,mr                ; mask interrupts

	movep   #$05000b,X:M_PCTL      ; DSP core at 8.192x12=98.3MHz
	move    #0,omr
	movec   #0,sp                  ; reset hardware stack pointer
	movep   #$000003,x:M_IPRP      ; ESAI int's enabled and top Priority
	move    #kStackBase,rStack            ; initialize stack pointer
	move    #-1,m6                 ; linear addressing

	andi    #$FC,mr                 ;enable all interrupt levels
	endm


;------------------------------------------------------------------------

;

;       EQUATES for I/O Port Programming

;

;------------------------------------------------------------------------



;       Register Addresses



M_HDR    EQU     $FFFFC9         ; Host port GPIO data Register

M_HDDR   EQU     $FFFFC8         ; Host port GPIO direction Register

M_PCRC   EQU     $FFFFBF         ; Port C Control Register

M_PRRC   EQU     $FFFFBE         ; Port C Direction Register

M_PDRC   EQU     $FFFFBD         ; Port C GPIO Data Register

M_PCRD   EQU     $FFFFD7         ; Port D Control register

M_PRRD   EQU     $FFFFD6         ; Port D Direction Data Register

M_PDRD   EQU     $FFFFD5         ; Port D GPIO Data Register

M_OGDB   EQU     $FFFFFC         ; OnCE GDB Register 







;------------------------------------------------------------------------

;

;       EQUATES for Exception Processing                                    

;

;------------------------------------------------------------------------



;       Register Addresses



M_IPRC   EQU     $FFFFFF         ; Interrupt Priority Register Core

M_IPRP   EQU     $FFFFFE         ; Interrupt Priority Register Peripheral



;       Interrupt Priority Register Core (IPRC) 



M_IAL    EQU     $7              ; IRQA Mode Mask

M_IAL0   EQU     0               ; IRQA Mode Interrupt Priority Level (low)

M_IAL1   EQU     1               ; IRQA Mode Interrupt Priority Level (high)

M_IAL2   EQU     2               ; IRQA Mode Trigger Mode

M_IBL    EQU     $38             ; IRQB Mode Mask

M_IBL0   EQU     3               ; IRQB Mode Interrupt Priority Level (low)

M_IBL1   EQU     4               ; IRQB Mode Interrupt Priority Level (high)

M_IBL2   EQU     5               ; IRQB Mode Trigger Mode

M_ICL    EQU     $1C0            ; IRQC Mode Mask

M_ICL0   EQU     6               ; IRQC Mode Interrupt Priority Level (low)

M_ICL1   EQU     7               ; IRQC Mode Interrupt Priority Level (high)

M_ICL2   EQU     8               ; IRQC Mode Trigger Mode

M_IDL    EQU     $E00            ; IRQD Mode Mask

M_IDL0   EQU     9               ; IRQD Mode Interrupt Priority Level (low)

M_IDL1   EQU     10              ; IRQD Mode Interrupt Priority Level (high)

M_IDL2   EQU     11              ; IRQD Mode Trigger Mode

M_D0L    EQU     $3000           ; DMA0 Interrupt priority Level Mask

M_D0L0   EQU     12              ; DMA0 Interrupt Priority Level (low)

M_D0L1   EQU     13              ; DMA0 Interrupt Priority Level (high)

M_D1L    EQU     $C000           ; DMA1 Interrupt Priority Level Mask

M_D1L0   EQU     14              ; DMA1 Interrupt Priority Level (low)

M_D1L1   EQU     15              ; DMA1 Interrupt Priority Level (high)

M_D2L    EQU     $30000          ; DMA2 Interrupt priority Level Mask

M_D2L0   EQU     16              ; DMA2 Interrupt Priority Level (low)

M_D2L1   EQU     17              ; DMA2 Interrupt Priority Level (high)

M_D3L    EQU     $C0000          ; DMA3 Interrupt Priority Level Mask

M_D3L0   EQU     18              ; DMA3 Interrupt Priority Level (low)

M_D3L1   EQU     19              ; DMA3 Interrupt Priority Level (high)

M_D4L    EQU     $300000         ; DMA4 Interrupt priority Level Mask

M_D4L0   EQU     20              ; DMA4 Interrupt Priority Level (low)

M_D4L1   EQU     21              ; DMA4 Interrupt Priority Level (high)

M_D5L    EQU     $C00000         ; DMA5 Interrupt priority Level Mask

M_D5L0   EQU     22              ; DMA5 Interrupt Priority Level (low)

M_D5L1   EQU     23              ; DMA5 Interrupt Priority Level (high)



;       Interrupt Priority Register Peripheral (IPRP)



M_ESL    EQU     $3              ; ESAI Interrupt Priority Level Mask

M_ESL0   EQU     0               ; ESAI Interrupt Priority Level (low)

M_ESL1   EQU     1               ; ESAI Interrupt Priority Level (high)

M_SHL    EQU     $C              ; SHI Interrupt Priority Level Mask

M_SHL0   EQU     2               ; SHI Interrupt Priority Level (low)

M_SHL1   EQU     3               ; SHI Interrupt Priority Level (high)

M_HDL    EQU     $30             ; HDI08 Interrupt Priority Level Mask

M_HDL0   EQU     4               ; HDI08 Interrupt Priority Level (low)

M_HDL1   EQU     5               ; HDI08 Interrupt Priority Level (high)

M_DAL    EQU     $C0             ; DAX Interrupt Priority Level  Mask       

M_DAL0   EQU     6               ; DAX Interrupt Priority Level  (low)

M_DAL1   EQU     7               ; DAX Interrupt Priority Level  (high)

M_TAL   EQU     $300             ; Timer Interrupt Priority Level Mask

M_TAL0   EQU     8               ; Timer Interrupt Priority Level (low)

M_TAL1   EQU     9               ; Timer Interrupt Priority Level (high)



;------------------------------------------------------------------------

;

;       EQUATES for Direct Memory Access (DMA)                                


;

;------------------------------------------------------------------------



;       Register Addresses Of DMA



M_DSTR   EQU     $FFFFF4         ; DMA Status Register

M_DOR0   EQU     $FFFFF3         ; DMA Offset Register 0

M_DOR1   EQU     $FFFFF2         ; DMA Offset Register 1

M_DOR2   EQU     $FFFFF1         ; DMA Offset Register 2

M_DOR3   EQU     $FFFFF0         ; DMA Offset Register 3



;       Register Addresses Of DMA0



M_DSR0   EQU     $FFFFEF         ; DMA0 Source Address Register

M_DDR0   EQU     $FFFFEE         ; DMA0 Destination Address Register 

M_DCO0   EQU     $FFFFED         ; DMA0 Counter

M_DCR0   EQU     $FFFFEC         ; DMA0 Control Register 



;       Register Addresses Of DMA1



M_DSR1   EQU     $FFFFEB         ; DMA1 Source Address Register

M_DDR1   EQU     $FFFFEA         ; DMA1 Destination Address Register 

M_DCO1   EQU     $FFFFE9         ; DMA1 Counter

M_DCR1   EQU     $FFFFE8         ; DMA1 Control Register



;       Register Addresses Of DMA2



M_DSR2   EQU     $FFFFE7         ; DMA2 Source Address Register

M_DDR2   EQU     $FFFFE6         ; DMA2 Destination Address Register 

M_DCO2   EQU     $FFFFE5         ; DMA2 Counter

M_DCR2   EQU     $FFFFE4         ; DMA2 Control Register

 

;       Register Addresses Of DMA3



M_DSR3   EQU     $FFFFE3         ; DMA3 Source Address Register

M_DDR3   EQU     $FFFFE2         ; DMA3 Destination Address Register 

M_DCO3   EQU     $FFFFE1         ; DMA3 Counter

M_DCR3   EQU     $FFFFE0         ; DMA3 Control Register



;       Register Addresses Of DMA4



M_DSR4   EQU     $FFFFDF         ; DMA4 Source Address Register

M_DDR4   EQU     $FFFFDE         ; DMA4 Destination Address Register 

M_DCO4   EQU     $FFFFDD         ; DMA4 Counter

M_DCR4   EQU     $FFFFDC         ; DMA4 Control Register 



;       Register Addresses Of DMA5



M_DSR5   EQU     $FFFFDB         ; DMA5 Source Address Register

M_DDR5   EQU     $FFFFDA         ; DMA5 Destination Address Register 

M_DCO5   EQU     $FFFFD9         ; DMA5 Counter

M_DCR5   EQU     $FFFFD8         ; DMA5 Control Register



;       DMA Control Register



M_DSS    EQU     $3              ; DMA Source Space Mask (DSS0-Dss1)

M_DSS0   EQU     0               ; DMA Source Memory space 0

M_DSS1   EQU     1               ; DMA Source Memory space 1    

M_DDS    EQU     $C              ; DMA Destination Space Mask (DDS-DDS1)

M_DDS0   EQU     2               ; DMA Destination Memory Space 0

M_DDS1   EQU     3               ; DMA Destination Memory Space 1

M_DAM    EQU     $3f0            ; DMA Address Mode Mask (DAM5-DAM0)

M_DAM0   EQU     4               ; DMA Address Mode 0

M_DAM1   EQU     5               ; DMA Address Mode 1

M_DAM2   EQU     6               ; DMA Address Mode 2

M_DAM3   EQU     7               ; DMA Address Mode 3

M_DAM4   EQU     8               ; DMA Address Mode 4

M_DAM5   EQU     9               ; DMA Address Mode 5

M_D3D    EQU     10              ; DMA Three Dimensional Mode

M_DRS    EQU     $F800           ; DMA Request Source Mask (DRS0-DRS4)

M_DRS0    EQU     11             ; DMA Request Source bit 0

M_DRS1    EQU     12             ; DMA Request Source bit 1

M_DRS2    EQU     13             ; DMA Request Source bit 2

M_DRS3    EQU     14             ; DMA Request Source bit 3

M_DRS4    EQU     15             ; DMA Request Source bit 4

M_DCON   EQU     16              ; DMA Continuous Mode

M_DPR    EQU     $60000          ; DMA Channel Priority

M_DPR0   EQU     17              ; DMA Channel Priority Level (low)

M_DPR1   EQU     18              ; DMA Channel Priority Level (high)

M_DTM    EQU     $380000         ; DMA Transfer Mode Mask (DTM2-DTM0)

M_DTM0   EQU     19              ; DMA Transfer Mode 0

M_DTM1   EQU     20              ; DMA Transfer Mode 1

M_DTM2   EQU     21              ; DMA Transfer Mode 2

M_DIE    EQU     22              ; DMA Interrupt Enable bit

M_DE     EQU     23              ; DMA Channel Enable bit 



;       DMA Status Register



M_DTD    EQU     $3F             ; Channel Transfer Done Status MASK (DTD0-DTD5)

M_DTD0   EQU     0               ; DMA Channel Transfer Done Status 0

M_DTD1   EQU     1               ; DMA Channel Transfer Done Status 1

M_DTD2   EQU     2               ; DMA Channel Transfer Done Status 2

M_DTD3   EQU     3               ; DMA Channel Transfer Done Status 3

M_DTD4   EQU     4               ; DMA Channel Transfer Done Status 4

M_DTD5   EQU     5               ; DMA Channel Transfer Done Status 5

M_DACT   EQU     8               ; DMA Active State

M_DCH    EQU     $E00            ; DMA Active Channel Mask (DCH0-DCH2)

M_DCH0   EQU     9               ; DMA Active Channel 0

M_DCH1   EQU     10              ; DMA Active Channel 1

M_DCH2   EQU     11              ; DMA Active Channel 2



;------------------------------------------------------------------------

;

;       EQUATES for Phase Locked Loop (PLL) 

;

;------------------------------------------------------------------------



;       Register Addresses Of PLL



M_PCTL   EQU     $FFFFFD         ; PLL Control Register



;       PLL Control Register



M_MF     EQU     $FFF            ; Multiplication Factor Bits Mask (MF0-MF11)

M_MF0    EQU   0                 ; Multiplication Factor bit 0 

M_MF1    EQU   1                 ; Multiplication Factor bit 1 

M_MF2    EQU   2                 ; Multiplication Factor bit 2 

M_MF3    EQU   3                 ; Multiplication Factor bit 3 

M_MF4    EQU   4                 ; Multiplication Factor bit 4

M_MF5    EQU   5                 ; Multiplication Factor bit 5 

M_MF6    EQU   6                 ; Multiplication Factor bit 6 

M_MF7    EQU   7                 ; Multiplication Factor bit 7 

M_MF8    EQU   8                 ; Multiplication Factor bit 8 

M_MF9    EQU   9                 ; Multiplication Factor bit 9 

M_MF10    EQU   10               ; Multiplication Factor bit 10

M_MF11    EQU   11               ; Multiplication Factor bit 11

M_DF     EQU     $7000           ; Division Factor Bits Mask (DF0-DF2)

M_DF0    EQU   12                ; Division Factor bit 0

M_DF1    EQU   13                ; Division Factor bit 1

M_DF2    EQU   14                ; Division Factor bit 2

M_XTLR   EQU     15              ; XTAL Range select bit

M_XTLD   EQU     16              ; XTAL Disable Bit

M_PSTP   EQU     17              ; STOP Processing State Bit 

M_PEN    EQU     18              ; PLL Enable Bit

M_COD   EQU     19               ; PLL Clock Output Disable Bit

M_PD     EQU     $F00000         ; PreDivider Factor Bits Mask (PD0-PD3)

M_PD0    EQU   20                ; PreDivider Factor bit 0

M_PD1    EQU   21                ; PreDivider Factor bit 1

M_PD2    EQU   22                ; PreDivider Factor bit 2

M_PD3    EQU   23                ; PreDivider Factor bit 3



;------------------------------------------------------------------------

;

;       EQUATES for BIU 

;

;------------------------------------------------------------------------



;       Register Addresses Of BIU



M_BCR    EQU     $FFFFFB         ; Bus Control Register

M_DCR    EQU     $FFFFFA         ; DRAM Control Register

M_AAR0   EQU     $FFFFF9         ; Address Attribute Register 0 

M_AAR1   EQU     $FFFFF8         ; Address Attribute Register 1 

M_AAR2   EQU     $FFFFF7         ; Address Attribute Register 2 

M_AAR3   EQU     $FFFFF6         ; Address Attribute Register 3 

M_IDR    EQU     $FFFFF5         ; ID Register



;       Bus Control Register



M_BA0W   EQU     $1F             ; Area 0 Wait Control Mask (BA0W0-BA0W4)

M_BA0W0   EQU   0                ; Area 0 Wait Control Bit 0

M_BA0W1   EQU   1                ; Area 0 Wait Control Bit 1

M_BA0W2   EQU   2                ; Area 0 Wait Control Bit 2

M_BA0W3   EQU   3                ; Area 0 Wait Control Bit 3

M_BA0W4   EQU   4                ; Area 0 Wait Control Bit 4

M_BA1W   EQU     $3E0            ; Area 1 Wait Control Mask (BA1W0-BA14)

M_BA1W0   EQU   5                ; Area 1 Wait Control Bit 0

M_BA1W1   EQU   6                ; Area 1 Wait Control Bit 1

M_BA1W2   EQU   7                ; Area 1 Wait Control Bit 2

M_BA1W3   EQU   8                ; Area 1 Wait Control Bit 3

M_BA1W4   EQU   9                ; Area 1 Wait Control Bit 4

M_BA2W   EQU     $1C00           ; Area 2 Wait Control Mask (BA2W0-BA2W2)

M_BA2W0   EQU   10               ; Area 2 Wait Control Bit 0

M_BA2W1   EQU   11               ; Area 2 Wait Control Bit 1

M_BA2W2   EQU   12               ; Area 2 Wait Control Bit 2

M_BA3W   EQU     $E000           ; Area 3 Wait Control Mask (BA3W0-BA3W3)

M_BA3W0   EQU   13               ; Area 3 Wait Control Bit 0

M_BA3W1   EQU   14               ; Area 3 Wait Control Bit 1

M_BA3W2   EQU   15               ; Area 3 Wait Control Bit 2

M_BDFW   EQU     $1F0000         ; Default Area Wait Control Mask (BDFW0-BDFW4)

M_BDFW0   EQU     16             ; Default Area Wait Control bit 0

M_BDFW1   EQU     17             ; Default Area Wait Control bit 1

M_BDFW2   EQU     18             ; Default Area Wait Control bit 2

M_BDFW3   EQU     19             ; Default Area Wait Control bit 3

M_BDFW4   EQU     20             ; Default Area Wait Control bit 4

M_BBS    EQU     21              ; Bus State

M_BLH    EQU     22              ; Bus Lock Hold

M_BRH    EQU     23              ; Bus Request Hold



;       DRAM Control Register



M_BCW    EQU     $3              ; In Page Wait States Bits Mask (BCW0-BCW1)

M_BCW0    EQU     0              ; In Page Wait States Bit 0

M_BCW1   EQU     1               ; In Page Wait States Bit 1

M_BRW    EQU     $C              ; Out Of Page Wait States Bits Mask (BRW0-BRW1)

M_BRW0    EQU     2              ; Out of Page Wait States bit 0

M_BRW1    EQU     3              ; Out of Page Wait States bit 1

M_BPS    EQU     $300            ; DRAM Page Size Bits Mask (BPS0-BPS1)

M_BPS0    EQU     4              ; DRAM Page Size Bits 0
                                 
M_BPS1    EQU     5              ; DRAM Page Size Bits 1

M_BPLE   EQU     11              ; Page Logic Enable

M_BME    EQU     12              ; Mastership Enable

M_BRE    EQU     13              ; Refresh Enable

M_BSTR   EQU     14              ; Software Triggered Refresh

M_BRF    EQU     $7F8000         ; Refresh Rate Bits Mask (BRF0-BRF7)

M_BRF0    EQU     15             ; Refresh Rate Bit 0

M_BRF1    EQU     16             ; Refresh Rate Bit 1

M_BRF2    EQU     17             ; Refresh Rate Bit 2

M_BRF3    EQU     18             ; Refresh Rate Bit 3

M_BRF4    EQU     19             ; Refresh Rate Bit 4

M_BRF5    EQU     20             ; Refresh Rate Bit 5

M_BRF6    EQU     21             ; Refresh Rate Bit 6

M_BRF7    EQU     22             ; Refresh Rate Bit 7

M_BRP    EQU     23              ; Refresh prescaler



;       Address Attribute Registers



M_BAT    EQU     $3              ; External Access Type and Pin Definition
                                 ; Bits Mask (BAT0-BAT1)

M_BAT0    EQU     0             ; External Access Type and Pin Definition
                                ; Bits 0

M_BAT1    EQU     1             ; External Access Type and Pin Definition
                                ; Bits 1

M_BAAP   EQU     2              ; Address Attribute Pin Polarity

M_BPEN   EQU     3              ; Program Space Enable

M_BXEN   EQU     4              ; X Data Space Enable

M_BYEN   EQU     5              ; Y Data Space Enable

M_BAM    EQU     6              ; Address Muxing

M_BPAC   EQU     7              ; Packing Enable

M_BNC    EQU     $F00           ; Number of Address Bits to Compare Mask
                                ; (BNC0-BNC3)

M_BNC0   EQU     8              ; Number of Address Bits to Compare 0

M_BNC1   EQU     9              ; Number of Address Bits to Compare 1

M_BNC2   EQU     10             ; Number of Address Bits to Compare 2

M_BNC3   EQU     11             ; Number of Address Bits to Compare 3

M_BAC    EQU     $FFF000        ; Address to Compare Bits Mask (BAC0-BAC11)

M_BAC0   EQU     12             ; Address to Compare Bits 0

M_BAC1   EQU     13             ; Address to Compare Bits 1

M_BAC2   EQU     14             ; Address to Compare Bits 2

M_BAC3   EQU     15             ; Address to Compare Bits 3

M_BAC4   EQU     16             ; Address to Compare Bits 4

M_BAC5   EQU     17             ; Address to Compare Bits 5

M_BAC6   EQU     18             ; Address to Compare Bits 6

M_BAC7   EQU     19             ; Address to Compare Bits 7

M_BAC8   EQU     20             ; Address to Compare Bits 8

M_BAC9   EQU     21             ; Address to Compare Bits 9

M_BAC10  EQU    22              ; Address to Compare Bits 10

M_BAC11  EQU    23              ; Address to Compare Bits 11



;       control and status bits in SR



M_C     EQU      0                ; Carry

M_V      EQU     1               ; Overflow      

M_Z      EQU     2               ; Zero

M_N      EQU     3               ; Negative      

M_U      EQU     4               ; Unnormalized

M_E      EQU     5               ; Extension     

M_L      EQU     6               ; Limit

M_S      EQU     7               ; Scaling Bit   

M_I0     EQU     8               ; Interupt Mask Bit 0

M_I1     EQU     9               ; Interupt Mask Bit 1

M_S0     EQU     10              ; Scaling Mode Bit 0

M_S1     EQU     11              ; Scaling Mode Bit 1

M_SC     EQU     13              ; Sixteen_Bit Compatibility

M_DM     EQU     14              ; Double Precision Multiply

M_LF     EQU     15              ; DO-Loop Flag

M_FV     EQU     16              ; DO-Forever Flag

M_SA     EQU     17              ; Sixteen-Bit Arithmetic

M_CE     EQU     19              ; Instruction Cache Enable

M_SM     EQU     20              ; Arithmetic Saturation

M_RM     EQU     21              ; Rounding Mode

M_CP     EQU     $c00000         ; mask for CORE-DMA priority bits in SR 

M_CP0    EQU     22              ; bit 0 of priority bits in SR

M_CP1    EQU     23              ; bit 1 of priority bits in SR



;       control and status bits in OMR



M_MA     EQU     0               ; Operating Mode A

M_MB     EQU     1               ; Operating Mode B

M_MC     EQU     2               ; Operating Mode C

M_MD     EQU     3               ; Operating Mode D

M_EBD    EQU     4               ; External Bus Disable bit in OMR

M_SD     EQU     6               ; Stop Delay 

M_MS     EQU     7               ; Memory Switch Mode 

M_CDP    EQU     $300            ; mask for CORE-DMA priority bits in OMR

M_CDP0   EQU     8               ; bit 0 of priority bits in OMR Core DMA

M_CDP1   EQU     9               ; bit 1 of priority bits in OMR Core DMA

M_BE    EQU     10               ; Burst Enable 

M_TAS    EQU     11              ; TA Synchronize Select

M_BRT    EQU     12              ; Bus Release Timing 

M_ABE   EQU     13               ; Async. Bus Arbitration Enable

M_APD   EQU     14               ; Addess Priority Disable

M_ATE   EQU     15               ; Address Tracing Enable

M_XYS    EQU     16              ; Stack Extension space select bit in OMR.

M_EUN    EQU     17              ; Extensed stack UNderflow flag in OMR.

M_EOV    EQU     18              ; Extended stack OVerflow flag in OMR.

M_WRP    EQU     19              ; Extended WRaP flag in OMR.

M_SEN    EQU     20              ; Stack Extension Enable bit in OMR.

M_PAEN   EQU      23             ; Patch Enable



;------------------------------------------------------------------------

;

;       EQUATES for DAX (SPDIF Tx)

;

;------------------------------------------------------------------------



;       Register Addresses

 

M_XSTR   EQU     $FFFFD4         ; DAX Status Register (XSTR)

M_XADRB  EQU     $FFFFD3         ; DAX Audio Data Register B (XADRB)

M_XADR    EQU     $FFFFD2        ; DAX Audio Data Register (XADR)

M_XADRA  EQU     $FFFFD2         ; DAX Audio Data Register A (XADRA)

M_XNADR  EQU     $FFFFD1         ; DAX Non-Audio Data Register (XNADR)

M_XCTR   EQU     $FFFFD0         ; DAX Control Register (XCTR)



;       status bits in XSTR



M_XADE   EQU     0               ; DAX Audio Data Register Empty (XADE)

M_XAUR   EQU     1               ; DAX Trasmit Underrun Error Flag (XAUR)

M_XBLK   EQU     2               ; DAX Block Transferred (XBLK)



;       non-audio bits in XNADR



M_XVA    EQU     10              ; DAX Channel A Validity (XVA)

M_XUA    EQU     11              ; DAX Channel A User Data (XUA)

M_XCA    EQU     12              ; DAX Channel A Channel Status (XCA)

M_XVB    EQU     13              ; DAX Channel B Validity (XVB)

M_XUB    EQU     14              ; DAX Channel B User Data (XUB)

M_XCB    EQU     15              ; DAX Channel B Channel Status (XCB)



;       control bits in XCTR



M_XDIE   EQU     0               ; DAX Audio Data Register Empty Interrupt
                                 ; Enable (XDIE)

M_XUIE   EQU     1               ; DAX Underrun Error Interrupt Enable (XUIE)

M_XBIE   EQU     2               ; DAX Block Transferred Interrupt Enable
                                 ; (XBIE)

M_XCS0   EQU     3               ; DAX Clock Input Select 0 (XCS0)

M_XCS1   EQU     4               ; DAX Clock Input Select 1 (XCS1)

M_XSB    EQU     5               ; DAX Start Block (XSB)



;------------------------------------------------------------------------

;

;       EQUATES for SHI 

;

;------------------------------------------------------------------------



;       Register Addresses

 

M_HRX    EQU     $FFFF94         ; SHI Receive FIFO (HRX)

M_HTX    EQU     $FFFF93         ; SHI Transmit Register (HTX)

M_HSAR   EQU     $FFFF92         ; SHI I2C Slave Address Register (HSAR)

M_HCSR   EQU     $FFFF91         ; SHI Control/Status Register (HCSR)

M_HCKR   EQU     $FFFF90         ; SHI Clock Control Register (HCKR)



;       HSAR bits



M_HA6    EQU     23              ; SHI I2C Slave Address (HA6)

M_HA5    EQU     22              ; SHI I2C Slave Address (HA5)

M_HA4    EQU     21              ; SHI I2C Slave Address (HA4)

M_HA3    EQU     20              ; SHI I2C Slave Address (HA3)

M_HA1    EQU     18              ; SHI I2C Slave Address (HA1)



;      control and status bits in HCSR



M_HBUSY  EQU     22              ; SHI Host Busy (HBUSY)

M_HBER   EQU     21              ; SHI Bus Error (HBER)

M_HROE   EQU     20              ; SHI Receive Overrun Error (HROE)

M_HRFF   EQU     19              ; SHI Receivr FIFO Full (HRFF)

M_HRNE   EQU     17              ; SHI Receive FIFO Not Empty (HRNE)

M_HTDE   EQU     15              ; SHI Host Transmit data Empty (HTDE)

M_HTUE   EQU     14              ; SHI Host Transmit Underrun Error (HTUE)

M_HRIE1  EQU     13              ; SHI Receive Interrupt Enable (HRIE1)

M_HRIE0  EQU     12              ; SHI Receive Interrupt Enable (HRIE0)

M_HTIE   EQU     11              ; SHI Transmit Interrupt Enable (HTIE)

M_HBIE   EQU     10              ; SHI Bus-Error Interrupt Enable (HBIE)

M_HIDLE  EQU     9               ; SHI Idle (HIDLE)

M_HRQE1  EQU     8               ; SHI Host Request Enable (HRQE1)

M_HRQE0  EQU     7               ; SHI Host Request Enable (HRQE0)

M_HMST   EQU     6               ; SHI Master Mode (HMST)

M_HFIFO  EQU     5               ; SHI FIFO Enable Control (HFIFO)

M_HCKFR  EQU     4               ; SHI Clock Freeze (HCKFR)

M_HM1    EQU     3               ; SHI Serial Host Interface Mode (HM1)

M_HM0    EQU     2               ; SHI Serial Host Interface Mode (HM0)

M_HI2C   EQU     1               ; SHI I2c/SPI Selection (HI2C)

M_HEN    EQU     0               ; SHI Host Enable (HEN)



;       control bits in HCKR



M_HFM1   EQU     13              ; SHI Filter Model (HFM1)

M_HFM0   EQU     12              ; SHI Filter Model (HFM0)

M_HDM7   EQU     10              ; SHI Divider Modulus Select (HDM7)

M_HDM6   EQU     9               ; SHI Divider Modulus Select (HDM6)

M_HDM5   EQU     8               ; SHI Divider Modulus Select (HDM5)

M_HDM4   EQU     7               ; SHI Divider Modulus Select (HDM4)

M_HDM3   EQU     6               ; SHI Divider Modulus Select (HDM3)

M_HDM2   EQU     5               ; SHI Divider Modulus Select (HDM2)

M_HDM1   EQU     4               ; SHI Divider Modulus Select (HDM1)

M_HDM0   EQU     3               ; SHI Divider Modulus Select (HDM0)

M_HRS    EQU     2               ; SHI Prescalar Rate Select (HRS)

M_CPOL   EQU     1               ; SHI Clock Polarity (CPOL)

M_CPHA   EQU     0               ; SHI Clock Phase (CPHA)



;------------------------------------------------------------------------

;

;       EQUATES for ESAI 

;

;------------------------------------------------------------------------



;       Register Addresses

 

M_RSMB   EQU     $FFFFBC         ; ESAI Receive Slot Mask Register B (RSMB)

M_RSMA   EQU     $FFFFBB         ; ESAI Receive Slot Mask Register A (RSMA)

M_TSMB   EQU     $FFFFBA         ; ESAI Transmit Slot Mask Register B (TSMB)

M_TSMA   EQU     $FFFFB9         ; ESAI Transmit Slot Mask Register A (TSMA)

M_RCCR   EQU     $FFFFB8         ; ESAI Receive Clock Control Register (RCCR)

M_RCR    EQU     $FFFFB7         ; ESAI Receive Control Register (RCR)

M_TCCR   EQU     $FFFFB6         ; ESAI Transmit Clock Control Register (TCCR)

M_TCR    EQU     $FFFFB5         ; ESAI Transmit Control Register (TCR)

M_SAICR  EQU     $FFFFB4         ; ESAI Control Register (SAICR)

M_SAISR  EQU     $FFFFB3         ; ESAI Status Register (SAISR)

M_RX3    EQU     $FFFFAB         ; ESAI Receive Data Register 3 (RX3)

M_RX2    EQU     $FFFFAA         ; ESAI Receive Data Register 2 (RX2)

M_RX1    EQU     $FFFFA9         ; ESAI Receive Data Register 1 (RX1)

M_RX0    EQU     $FFFFA8         ; ESAI Receive Data Register 0 (RX0)

M_TSR    EQU     $FFFFA6         ; ESAI Time Slot Register (TSR)

M_TX5    EQU     $FFFFA5         ; ESAI Transmit Data Register 5 (TX5)

M_TX4    EQU     $FFFFA4         ; ESAI Transmit Data Register 4 (TX4)

M_TX3    EQU     $FFFFA3         ; ESAI Transmit Data Register 3 (TX3)

M_TX2    EQU     $FFFFA2         ; ESAI Transmit Data Register 2 (TX2)

M_TX1    EQU     $FFFFA1         ; ESAI Transmit Data Register 1 (TX1)

M_TX0    EQU     $FFFFA0         ; ESAI Transmit Data Register 0 (TX0)



;       RSMB Register bits



M_RS31   EQU     15              ; ESAI 

M_RS30   EQU     14              ; ESAI 

M_RS29   EQU     13              ; ESAI 

M_RS28   EQU     12              ; ESAI 

M_RS27   EQU     11              ; ESAI 

M_RS26   EQU     10              ; ESAI 

M_RS25   EQU     9               ; ESAI 

M_RS24   EQU     8               ; ESAI 

M_RS23   EQU     7               ; ESAI 

M_RS22   EQU     6               ; ESAI 

M_RS21   EQU     5               ; ESAI 

M_RS20   EQU     4               ; ESAI 

M_RS19   EQU     3               ; ESAI 

M_RS18   EQU     2               ; ESAI 

M_RS17   EQU     1               ; ESAI 

M_RS16   EQU     0               ; ESAI 



;       RSMA Register bits



M_RS15   EQU     15              ; ESAI 

M_RS14   EQU     14              ; ESAI 

M_RS13   EQU     13              ; ESAI 

M_RS12   EQU     12              ; ESAI 

M_RS11   EQU     11              ; ESAI 

M_RS10   EQU     10              ; ESAI 

M_RS9    EQU     9               ; ESAI 

M_RS8    EQU     8               ; ESAI 

M_RS7    EQU     7               ; ESAI 

M_RS6    EQU     6               ; ESAI 

M_RS5    EQU     5               ; ESAI 

M_RS4    EQU     4               ; ESAI 

M_RS3    EQU     3               ; ESAI 

M_RS2    EQU     2               ; ESAI 

M_RS1    EQU     1               ; ESAI 

M_RS0    EQU     0               ; ESAI 



;       TSMB Register bits



M_TS31   EQU     15              ; ESAI 

M_TS30   EQU     14              ; ESAI 

M_TS29   EQU     13              ; ESAI 

M_TS28   EQU     12              ; ESAI 

M_TS27   EQU     11              ; ESAI 

M_TS26   EQU     10              ; ESAI 

M_TS25   EQU     9               ; ESAI 

M_TS24   EQU     8               ; ESAI 

M_TS23   EQU     7               ; ESAI 

M_TS22   EQU     6               ; ESAI 

M_TS21   EQU     5               ; ESAI 

M_TS20   EQU     4               ; ESAI 

M_TS19   EQU     3               ; ESAI 

M_TS18   EQU     2               ; ESAI 

M_TS17   EQU     1               ; ESAI 

M_TS16   EQU     0               ; ESAI 



;       TSMA Register bits



M_TS15   EQU     15              ; ESAI 

M_TS14   EQU     14              ; ESAI 

M_TS13   EQU     13              ; ESAI 

M_TS12   EQU     12              ; ESAI 

M_TS11   EQU     11              ; ESAI 

M_TS10   EQU     10              ; ESAI 

M_TS9    EQU     9               ; ESAI 

M_TS8    EQU     8               ; ESAI 

M_TS7    EQU     7               ; ESAI 

M_TS6    EQU     6               ; ESAI 

M_TS5    EQU     5               ; ESAI 

M_TS4    EQU     4               ; ESAI 

M_TS3    EQU     3               ; ESAI 

M_TS2    EQU     2               ; ESAI 

M_TS1    EQU     1               ; ESAI 

M_TS0    EQU     0               ; ESAI 



;       RCCR Register bits



M_RHCKD  EQU     23              ; ESAI 

M_RFSD   EQU     22              ; ESAI 

M_RCKD   EQU     21              ; ESAI 

M_RHCKP   EQU     20             ; ESAI

M_RFSP   EQU     19              ; ESAI

M_RCKP   EQU     18              ; ESAI 

M_RFP     EQU      $3C000        ; ESAI MASK

M_RFP3   EQU     17              ; ESAI 

M_RFP2   EQU     16              ; ESAI 

M_RFP1   EQU     15              ; ESAI 

M_RFP0   EQU     14              ; ESAI

M_RDC     EQU     $3E00          ; ESAI MASK 

M_RDC4   EQU     13              ; ESAI 

M_RDC3   EQU     12              ; ESAI 

M_RDC2   EQU     11              ; ESAI 

M_RDC1   EQU     10              ; ESAI 

M_RDC0   EQU     9               ; ESAI 

M_RPSR   EQU     8               ; ESAI 

M_RPM     EQU    $FF

M_RPM7   EQU     7               ; ESAI 

M_RPM6   EQU     6               ; ESAI 

M_RPM5   EQU     5               ; ESAI 

M_RPM4   EQU     4               ; ESAI 

M_RPM3   EQU     3               ; ESAI 

M_RPM2   EQU     2               ; ESAI 

M_RPM1   EQU     1               ; ESAI 

M_RPM0   EQU     0               ; ESAI 



;       RCR Register bits



M_RLIE   EQU     23              ; ESAI

M_RIE    EQU     22              ; ESAI

M_REDIE  EQU     21              ; ESAI

M_REIE   EQU     20              ; ESAI

M_RFSR   EQU     16              ; ESAI

M_RFSL   EQU     15              ; ESAI

M_RSWS    EQU       $7C00        ; ESAI MASK

M_RSWS4   EQU     14             ; ESAI

M_RSWS3   EQU     13             ; ESAI

M_RSWS2   EQU     12             ; ESAI

M_RSWS1   EQU     11             ; ESAI 

M_RSWS0   EQU     10             ; ESAI 

M_RMOD      EQU       $300

M_RMOD1  EQU     9               ; ESAI

M_RMOD0  EQU     8               ; ESAI

M_RWA   EQU     7                ; ESAI

M_RSHFD  EQU     6               ; ESAI

M_RE      EQU      $F

M_RE3    EQU     3               ; ESAI

M_RE2    EQU     2               ; ESAI

M_RE1    EQU     1               ; ESAI

M_RE0    EQU     0               ; ESAI



;       TCCR Register bits



M_THCKD  EQU     23              ; ESAI 

M_TFSD   EQU     22              ; ESAI 

M_TCKD   EQU     21              ; ESAI 

M_THCKP   EQU     20             ; ESAI 

M_TFSP   EQU     19              ; ESAI 

M_TCKP   EQU     18              ; ESAI

M_TFP    EQU      $3C000

M_TFP3   EQU     17              ; ESAI 

M_TFP2   EQU     16              ; ESAI 

M_TFP1   EQU     15              ; ESAI 

M_TFP0   EQU     14              ; ESAI

M_TDC     EQU     $3E00       

M_TDC4   EQU     13              ; ESAI 

M_TDC3   EQU     12              ; ESAI 

M_TDC2   EQU     11              ; ESAI 

M_TDC1   EQU     10              ; ESAI 

M_TDC0   EQU     9               ; ESAI 

M_TPSR   EQU     8               ; ESAI

M_TPM     EQU    $FF             

M_TPM7   EQU     7               ; ESAI 

M_TPM6   EQU     6               ; ESAI 

M_TPM5   EQU     5               ; ESAI 

M_TPM4   EQU     4               ; ESAI 

M_TPM3   EQU     3               ; ESAI 

M_TPM2   EQU     2               ; ESAI 

M_TPM1   EQU     1               ; ESAI 

M_TPM0   EQU     0               ; ESAI 



;       TCR Register bits



M_TLIE   EQU     23              ; ESAI

M_TIE    EQU     22              ; ESAI

M_TEDIE  EQU     21              ; ESAI

M_TEIE   EQU     20              ; ESAI

M_TFSR   EQU     16              ; ESAI

M_TFSL   EQU     15              ; ESAI

M_TSWS   EQU    $7C00

M_TSWS4   EQU     14             ; ESAI

M_TSWS3   EQU     13             ; ESAI

M_TSWS2   EQU     12             ; ESAI

M_TSWS1   EQU     11             ; ESAI

M_TSWS0   EQU     10             ; ESAI

M_TMOD    EQU      $300

M_TMOD1  EQU     9               ; ESAI

M_TMOD0  EQU     8               ; ESAI

M_TWA   EQU     7                ; ESAI

M_TSHFD  EQU     6               ; ESAI

M_TEM       EQU     $3F

M_TE5    EQU     5               ; ESAI

M_TE4    EQU     4               ; ESAI

M_TE3    EQU     3               ; ESAI

M_TE2    EQU     2               ; ESAI

M_TE1    EQU     1               ; ESAI

M_TE0    EQU     0               ; ESAI



;       control bits of SAICR



M_ALC   EQU   8                  ;ESAI

M_TEBE   EQU     7               ; ESAI 

M_SYN    EQU     6               ; ESAI 

M_OF2    EQU     2               ; ESAI 

M_OF1    EQU     1               ; ESAI 

M_OF0    EQU     0               ; ESAI 



;       status bits of SAISR



M_TODE   EQU     17              ; ESAI

M_TEDE   EQU     16              ; ESAI

M_TDE    EQU     15              ; ESAI

M_TUE    EQU     14              ; ESAI

M_TFS    EQU     13              ; ESAI

M_RODF   EQU     10              ; ESAI

M_REDF   EQU     9               ; ESAI

M_RDF    EQU     8               ; ESAI

M_ROE    EQU     7               ; ESAI

M_RFS    EQU     6               ; ESAI

M_IF2    EQU     2               ; ESAI

M_IF1    EQU     1               ; ESAI

M_IF0    EQU     0               ; ESAI



;------------------------------------------------------------------------

;

;       EQUATES for HDI08 

;

;------------------------------------------------------------------------



;       Register Addresses

 

M_HOTX    EQU     $FFFFC7        ; HOST Transmit Register (HOTX)

M_HORX    EQU     $FFFFC6        ; HOST Receive Register (HORX)

M_HBAR   EQU     $FFFFC5         ; HOST Base Address Register (HBAR)

M_HPCR   EQU     $FFFFC4         ; HOST Polarity Control Register (HPCR)

M_HSR    EQU     $FFFFC3         ; HOST Status Register (HSR)

M_HCR    EQU     $FFFFC2         ; HOST Control Register (HCR)





;       HCR bits



M_HRIE   EQU     $0              ; HOST Receive interrupts Enable

M_HOTIE   EQU     $1             ; HOST Transmit Interrupt Enable

M_HCIE   EQU     $2              ; HOST Command Interrupt Enable

M_HF2    EQU     $3              ; HOST Flag 2

M_HF3    EQU     $4              ; HOST Flag 3

M_HODM0   EQU     $5             ; HOST DMA Mode Control Bit 0

M_HODM1   EQU     $6             ; HOST DMA Mode Control Bit 1

M_HODM2   EQU     $7             ; HOST DMA Mode Control Bit 2

        

;       HSR bits



M_HRDF   EQU     $0              ; HOST Receive Data Full

M_HOTDE   EQU     $1             ; HOST Receive Data Emptiy

M_HCP    EQU     $2              ; HOST Command Pending

M_HF0    EQU     $3              ; HOST Flag 0

M_HF1    EQU     $4              ; HOST Flag 1

M_DMA    EQU     $7              ; HOST DMA Status

        

;       HPCR bits



M_HGEN   EQU     $0              ; HOST Port Enable

M_HA8EN  EQU     $1              ; HOST Address 8 Enable

M_HA9EN  EQU     $2              ; HOST Address 9 Enable

M_HCSEN  EQU     $3              ; HOST Chip Select Enable

M_HREN   EQU     $4              ; HOST Request Enable

M_HAEN   EQU     $5              ; HOST Acknowledge Enable

M_HOEN    EQU     $6             ; HOST Enable

M_HROD    EQU     $8             ; HOST Request Open Dranin mode

M_HDSP   EQU     $9              ; HOST Data Strobe Polarity

M_HASP   EQU     $a              ; HOST Address Strobe Polarity

M_HMUX   EQU     $b              ; HOST Multiplexed bus select

M_HDDS  EQU     $c               ; HOST Double/Single Strobe select

M_HCSP   EQU     $d              ; HOST Chip Select Polarity

M_HRP    EQU     $e              ; HOST Request PolarityPolarity

M_HAP    EQU     $f              ; HOST Acknowledge Polarity



;                  HBAR  BITS



M_BA   EQU   $FF

M_BA10   EQU   7

M_BA9   EQU   6

M_BA8   EQU   5

M_BA7   EQU   4

M_BA6   EQU   3

M_BA5   EQU   2

M_BA4   EQU   1

M_BA3   EQU   0



;-----------------------------------------------------------------------

;

;       EQUATES for TIMER 

;

;------------------------------------------------------------------------



;       Register Addresses Of TIMER0



M_TCSR0  EQU     $FFFF8F         ; TIMER0 Control/Status Register        

M_TLR0   EQU     $FFFF8E         ; TIMER0 Load Reg   

M_TCPR0  EQU     $FFFF8D         ; TIMER0 Compare Register

M_TCR0   EQU     $FFFF8C         ; TIMER0 Count Register



;       Register Addresses Of TIMER1



M_TCSR1  EQU     $FFFF8B         ; TIMER1 Control/Status Register        

M_TLR1   EQU     $FFFF8A         ; TIMER1 Load Reg   

M_TCPR1  EQU     $FFFF89         ; TIMER1 Compare Register

M_TCR1   EQU     $FFFF88         ; TIMER1 Count Register





;       Register Addresses Of TIMER2



M_TCSR2  EQU     $FFFF87         ; TIMER2 Control/Status Register        

M_TLR2   EQU     $FFFF86         ; TIMER2 Load Reg   

M_TCPR2  EQU     $FFFF85         ; TIMER2 Compare Register

M_TCR2   EQU     $FFFF84         ; TIMER2 Count Register

M_TPLR   EQU     $FFFF83         ; TIMER Prescaler Load Register

M_TPCR   EQU     $FFFF82         ; TIMER Prescalar Count Register



;       Timer Control/Status Register Bit Flags        



M_TE     EQU     0               ; Timer Enable 

M_TOIE   EQU     1               ; Timer Overflow Interrupt Enable

M_TCIE   EQU     2               ; Timer Compare Interrupt Enable

M_TC     EQU     $F0             ; Timer Control Mask (TC0-TC3)

M_INV    EQU     8               ; Inverter Bit

M_TRM    EQU     9               ; Timer Restart Mode 

M_DIR    EQU     11              ; Direction Bit

M_DI     EQU     12              ; Data Input

M_DO     EQU     13              ; Data Output

M_PCE    EQU     15              ; Prescaled Clock Enable

M_TOF    EQU     20              ; Timer Overflow Flag

M_TCF    EQU     21              ; Timer Compare Flag 



;       Timer Prescaler Register Bit Flags        



M_PS    EQU  $600000             ; Prescaler Source Mask

M_PS0   EQU  21

M_PS1   EQU  22



;   Timer Control Bits

M_TC0    EQU     4               ; Timer Control 0

M_TC1    EQU     5               ; Timer Control 1

M_TC2    EQU     6               ; Timer Control 2

M_TC3    EQU     7               ; Timer Control 3


; nVidia timer registers

TIMER1_CONFIG               equ $FFFFB0
TIMER2_CONFIG               equ $FFFFB4

TIMER1_CONTROL              equ $FFFFB1
TIMER2_CONTROL              equ $FFFFB5

TIMER1_TERMINAL_COUNT       equ $ffffB2
TIMER2_TERMINAL_COUNT       equ $ffffB6

TIMER1_COUNT                equ $ffffB3
TIMER2_COUNT                equ $ffffB7
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\minirvb.h ===
;**************************************************************************
;
;       minirvb.h    
;
;**************************************************************************        

        IF @DEF('SIM')
    	org	x:$80
        ELSE
        org     x:
        ENDIF

NUM_REFLECTIONS  equ 8


StateBlock
FIXED_STATE_INFO ds	DATASIZE_DSP_FX_STATE_1IN_4OUT 

    ; pointers to the reflection buffers
    ; they must be right after the FX_STATE block so the overlap with the output IO pointers
    ; The tool will place GPTEMPBIN pointers at compile time

pTemp               dc 0
pReflection1        dc 0
pReflection2        dc 0
pReflection3        dc 0
pReflection4        dc 0
pReflection5        dc 0
pReflection6        dc 0
pReflection7        dc 0

Reflection0Length   dc 0
Reflection1Length   dc 0
Reflection2Length   dc 0
Reflection3Length   dc 0
Reflection4Length   dc 0
Reflection5Length   dc 0
Reflection6Length   dc 0
Reflection7Length   dc 0

Reflection0Tap      dc 0
Reflection1Tap      dc 0
Reflection2Tap      dc 0
Reflection3Tap      dc 0
Reflection4Tap      dc 0
Reflection5Tap      dc 0
Reflection6Tap      dc 0
Reflection7Tap      dc 0

Reflection0Gain     dc 0
Reflection1Gain     dc 0
Reflection2Gain     dc 0
Reflection3Gain     dc 0
Reflection4Gain     dc 0
Reflection5Gain     dc 0
Reflection6Gain     dc 0
Reflection7Gain     dc 0


NewIIRBlock macro

    dc  0
    dc  0
    dc  0

    endm

IIR0
    NewIIRBlock
IIR1
    NewIIRBlock


IIR_CoefficientA1   equ     0
IIR_CoefficientB0   equ     1
IIR_DelayElement    equ     2



; after this point all variables are internal to the dsp and not-downloadable


DMAReadBlock0
    NewDMABlock

DMAReadBlock1
    NewDMABlock

DMAReadBlock2
    NewDMABlock

DMAReadBlock3
    NewDMABlock

DMAReadBlock4
    NewDMABlock

DMAReadBlock5
    NewDMABlock

DMAReadBlock6
    NewDMABlock

DMAReadBlock7
    NewDMABlock


DMAWriteBlock0
    NewDMABlock

DMAWriteBlock1
    NewDMABlock

DMAWriteBlock2
    NewDMABlock

DMAWriteBlock3
    NewDMABlock

DMAWriteBlock4
    NewDMABlock

DMAWriteBlock5
    NewDMABlock

DMAWriteBlock6
    NewDMABlock

DMAWriteBlock7
    NewDMABlock
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\mixer.h ===
;**************************************************************************
;
;       mixer.h    
;
;**************************************************************************        



    IF @DEF('IO_2IN_1OUT')
FX_OFFSET   set DATASIZE_DSP_FX_STATE_STEREO
    ENDIF

    IF @DEF('IO_4IN_2OUT')
FX_OFFSET   set DATASIZE_DSP_FX_STATE_4IN_2OUT 
    ENDIF

GAIN_IN0    set FX_OFFSET
FXOFFSET    set FX_OFFSET+1

GAIN_IN1    set FX_OFFSET
FXOFFSET    set FX_OFFSET+1


DATASIZE_MIXER	equ	(FX_OFFSET)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\osci_iir.h ===
;**************************************************************************
;
;       oscillator.h    
;
;**************************************************************************        

; we support max of 8 outputs

FX_OFFSET          set (DATASIZE_DSP_FX_STATE_MONO-1)

FX_OSCILLATOR_H    set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1

FX_OSCILLATOR_Y1   set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1

FX_OSCILLATOR_Y2   set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1

DATASIZE_OSCILLATOR  equ	(FX_OFFSET)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Options.inc ===
;======================================================================
;======================================================================
;	The following variables enable and control the reverb fader.
;
; To enable the fader set 'FADER_ENABLED' equal to 1
; To disble the fader set 'FADER_ENABLED' equal to 0
;
;
FADER_ENABLED		set	1
;
;
; The following variables control the type of fading that is performed
; when the reverb parameters are changed.  Either, both or neither
; can be enabled.
;
;
;	'FADER_ENABLE_OUTPUTAMPITUDEFADE'	controls the fading of 
;	the output amplitudes.
;		FADER_ENABLE_OUTPUTAMPITUDEFADE=0	Disable output amplitude fading
;		FADER_ENABLE_OUTPUTAMPITUDEFADE=1	Enable output amplitude fading
;
;										
FADER_ENABLE_OUTPUTAMPITUDEFADE	set	1



;	'FADER_ENABLE_DELAYTAPFADE'	controls the fading of the delay buffers
;	on the main delay line.
;		FADER_ENABLE_DELAYTAPFADE=0	Disable fading
;		FADER_ENABLE_DELAYTAPFADE=1	Enable fading
;
;
FADER_ENABLE_DELAYTAPFADE		set 1

;======================================================================
;======================================================================


;	'HALFSAMPLERATE' controls whether the reverb engine is running at
;	the full sample rate or half the input sample rate.
;		HALFSAMPLERATE = 0	Full sample rate processing
;		HALFSAMPLERATE = 1	Half sample rate processing
;
;

;======================================================================
;======================================================================



;	'SizeOfFrame'   is the size of the internal audio frames measured in samples (=words)
;	'SizeOfIoFrame' is the size of the input/output audio frames measured in samples (=words)
; These settings are identical unless the reverb engine is operating at half the external
; sample rate.

	IF @DEF('HALFSAMPLERATE')
	msg				"Reverb engine operating a half external sample rate"
SizeOfFrame			set	16
SizeOfIoFrame		set	32

	ELSE

SizeOfFrame			set	32
SizeOfIoFrame		set	32

	ENDIF


;======================================================================
;======================================================================

;       set if reverb is supposed to be 2in->4out fx

USE_TWO_INPUTS    set     0

;======================================================================
;======================================================================

;       if BLOCKING_DMA is set, dma transfers will be syncronous
;       if not set, DMA will not block until the next dma transfer starts

BLOCKING_DMA    set     0

;======================================================================
;======================================================================


        ;
        ; set to skip crossfeed
        ;

SKIP_CROSSFEED    set     0

;======================================================================
;======================================================================

        ;
        ; set to skip short reverb
        ;

SKIP_SHORT_REVERB set     0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\osci_table.h ===
;**************************************************************************
;
;       spliter.h    
;
;**************************************************************************        

; we support max of 4 outputs

FX_OFFSET          set (DATASIZE_DSP_FX_STATE_1IN_4OUT-1)

FX_NUM_OUTPUTS     set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1

FX_FREQ0           set FX_OFFSET
FX_OFFSET          set FX_OFFSET+4

FX_TABLE_INDEX0    set FX_OFFSET
FX_OFFSET          set FX_OFFSET+(2*4)

FX_SIN_TABLE       set FX_OFFSET
FX_OFFSET          set FX_OFFSET+65

DATASIZE_LFO       equ	(FX_OFFSET)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\osci.h ===
;**************************************************************************
;
;       oscillator.h    
;
;**************************************************************************        

; we support max of 8 outputs

FX_OFFSET          set (DATASIZE_DSP_FX_STATE_MONO-1)

FX_OSCILLATOR_H    set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1

FX_OSCILLATOR_Y1   set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1

FX_OSCILLATOR_Y2   set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1

DATASIZE_OSCILLATOR  equ	(FX_OFFSET)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Parameters.inc ===
;	File	:	Parameters.inc
;	Version	:	1.0
;	Date	:	21/11/2000
;
;	Author	:	RDA
;				Sensaura Ltd
;
;
;
; Description
; ===========
; This file defines the default parameters for the reverb engine.
; It includes definitions for the position and size of the delay
; buffers when running on the Motorola DSP56362EVM board.
; Values that are specific to the DSP56362EVM board are prefixed 
; by 'EVM_'.
;
;

;
;------------------------------------------------------
;	Reverb Engine output scaling parameters
;------------------------------------------------------
FixedOutputScaling			equ	7



       
;*********************************************************************
;***  All delays and buffer lengths must be greater than 32        ***
;***  All delays and buffer lengths must be a multiple of 4 words  ***
;*********************************************************************

;------------------------------------------------------
;	Buffer sizes for the DSM56362EVM board
;	(assuming 48 kHz sample rate)
;------------------------------------------------------
EVM_SizeOf_BufferReflection0	equ	1360		;  28.33 ms
EVM_SizeOf_BufferReflection1	equ	1228		;  25.60 ms
EVM_SizeOf_BufferReflection2	equ	1284		;  26.77 ms
EVM_SizeOf_BufferReflection3	equ	1440		;  30.02 ms



	; The short reverb buffers are fixed in length according 
	; to the sample rate.  If the sample rate halves, so does
	; the buffer length.
EVM_SizeOf_BufferShortReverb0	set 2784*4		;  58.00 ms
EVM_SizeOf_BufferShortReverb1	set 4088*4		;  85.25 ms
EVM_SizeOf_BufferShortReverb2	set 3372*4		;  70.25 ms
EVM_SizeOf_BufferShortReverb3	set 4956*4		; 103.17 ms

	IF @DEF('HALFSAMPLERATE')
EVM_SizeOf_BufferShortReverb0	set	(EVM_SizeOf_BufferShortReverb0/2)&$FFFFFC		;Make the buffers half the size, but still a multiple of 4 long
EVM_SizeOf_BufferShortReverb1	set	(EVM_SizeOf_BufferShortReverb1/2)&$FFFFFC
EVM_SizeOf_BufferShortReverb2	set	(EVM_SizeOf_BufferShortReverb2/2)&$FFFFFC
EVM_SizeOf_BufferShortReverb3	set	(EVM_SizeOf_BufferShortReverb3/2)&$FFFFFC
	ENDIF



EVM_SizeOf_BufferLongReverb0	equ 31280		; 0.65 seconds
EVM_SizeOf_BufferLongReverb1	equ 31280		; 0.65 seconds

EVM_SizeOf_MainDelayLine		set 12000		; 0.25 seconds
EVM_SizeOf_MainDelayLine1		set	12000		; 0.25 seconds
EVM_SizeOf_MainDelayLine2		set	12000		; 0.25 seconds
EVM_SizeOf_MainDelayLine3		set	12000		; 0.25 seconds

	IF @DEF('HALFSAMPLERATE')
EVM_SizeOf_MainDelayLine		set (EVM_SizeOf_MainDelayLine/2)&$FFFFFC		; 0.25 seconds
EVM_SizeOf_MainDelayLine1		set	(EVM_SizeOf_MainDelayLine1/2)&$FFFFFC		; 0.25 seconds
EVM_SizeOf_MainDelayLine2		set	(EVM_SizeOf_MainDelayLine2/2)&$FFFFFC		; 0.25 seconds
EVM_SizeOf_MainDelayLine3		set	(EVM_SizeOf_MainDelayLine3/2)&$FFFFFC		; 0.25 seconds
	ENDIF



;------------------------------------------------------
;	Base address of delay line on host 
; (configured for external memory on Motorola DSP56362EVM board)
;------------------------------------------------------
EVM_MainDelayLine				equ $C000
EVM_MainDelayLine1				equ EVM_MainDelayLine+EVM_SizeOf_MainDelayLine
EVM_MainDelayLine2				equ EVM_MainDelayLine1+EVM_SizeOf_MainDelayLine1
EVM_MainDelayLine3				equ EVM_MainDelayLine2+EVM_SizeOf_MainDelayLine2

EVM_BufferReflection0			equ	EVM_MainDelayLine3+EVM_SizeOf_MainDelayLine3
EVM_BufferReflection1			equ	EVM_BufferReflection0+EVM_SizeOf_BufferReflection0
EVM_BufferReflection2			equ	EVM_BufferReflection1+EVM_SizeOf_BufferReflection1
EVM_BufferReflection3			equ	EVM_BufferReflection2+EVM_SizeOf_BufferReflection2

EVM_BufferShortReverb0			equ EVM_BufferReflection3+EVM_SizeOf_BufferReflection3
EVM_BufferShortReverb1			equ EVM_BufferShortReverb0+EVM_SizeOf_BufferShortReverb0
EVM_BufferShortReverb2			equ EVM_BufferShortReverb1+EVM_SizeOf_BufferShortReverb1
EVM_BufferShortReverb3			equ EVM_BufferShortReverb2+EVM_SizeOf_BufferShortReverb2

EVM_BufferLongReverb0			equ EVM_BufferShortReverb3+EVM_SizeOf_BufferShortReverb3
EVM_BufferLongReverb1			equ EVM_BufferLongReverb0+EVM_SizeOf_BufferLongReverb0




;
;------------------------------------------------------
;	Reverb Engine input delay parameters
;------------------------------------------------------


DefaultReflectionInputDelay	set	336		; 0 <= ReflectionDelay < 16384
												; The delay between the source sound and 
												; the first reflection tap

DefaultShortReverbInputDelay	set	524		; 0 <= ReverbInputDelay < 4800
												; The delay between the source sound and
												; the first reverb tap


												; The DefaultReflectionInputDelay# variables
												; are used when creating the default DMA 
												; parameter blocks
												; Values are relative to 'DefaultReflectionInputDelay'
DefaultReflectionInputDelay0	set	0
DefaultReflectionInputDelay1	set	56
DefaultReflectionInputDelay2	set	36
DefaultReflectionInputDelay3	set	92
DefaultReflectionInputDelay4	set	124

												; Values are relative to 'DefaultReflectionInputDelay'
DefaultShortReverbInputDelay0a	set	0
DefaultShortReverbInputDelay0b	set	116
DefaultShortReverbInputDelay1a	set	268
DefaultShortReverbInputDelay1b	set	464
DefaultShortReverbInputDelay2a	set	0
DefaultShortReverbInputDelay2b	set	116
DefaultShortReverbInputDelay3a	set	268
DefaultShortReverbInputDelay3b	set	464

												; Values are absolute. However they
												; are measured from the start of the
												; respective delay buffer
DefaultLongReverbInputDelay0a	set	100
DefaultLongReverbInputDelay1a	set	124
DefaultLongReverbInputDelay0b	set	64
DefaultLongReverbInputDelay1b	set	72
DefaultLongReverbInputDelay0c	set	232
DefaultLongReverbInputDelay1c	set	312
DefaultLongReverbInputDelay0d	set	76
DefaultLongReverbInputDelay1d	set	92


;------------------------------------------------------
;	Reverb engine delay tap positions
;------------------------------------------------------
												; Values are absolute
DefaultReflectionDelay0			set	308
DefaultReflectionDelay1			set	284
DefaultReflectionDelay2			set	296
DefaultReflectionDelay3			set	328

												; Values are absolute
DefaultShortReverbDelay0		set	EVM_SizeOf_BufferShortReverb0
DefaultShortReverbDelay1		set	EVM_SizeOf_BufferShortReverb1
DefaultShortReverbDelay2		set	EVM_SizeOf_BufferShortReverb2
DefaultShortReverbDelay3		set	EVM_SizeOf_BufferShortReverb3

												; Values are absolute
DefaultLongReverbDelay0			set	800
DefaultLongReverbDelay1			set	900


;------------------------------------------------------
;	Long Reverb Gain defaults
;------------------------------------------------------

DefaultLongReverbCrossfeedGain	set	$400000
DefaultLongReverbInputGain		set	$300000


;------------------------------------------------------
;	Default IIR parameters
;------------------------------------------------------
IIR_DefaultCoefficientA1	equ	$0
IIR_DefaultCoefficientB0	equ	$0


IIR2_DefaultInputCoefficientA1	equ $0
IIR2_DefaultInputCoefficientA2	equ $0
IIR2_DefaultInputCoefficientB0	equ $0

IIR2_InterpolationCoefficientA1	equ $0
IIR2_InterpolationCoefficientA2	equ $0
IIR2_InterpolationCoefficientB0	equ $0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\spliter.h ===
;**************************************************************************
;
;       spliter.h    
;
;**************************************************************************        

; we support max of 8 outputs

FX_OFFSET          set DATASIZE_DSP_FX_STATE_1IN_8OUT 

FX_NUM_OUTPUTS     set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1


FX_OUTPUT_GAIN0    set FX_OFFSET
FX_OFFSET          set FX_OFFSET+9

FX_TEMP            set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1
FX_TEMP1           set FX_OFFSET
FX_OFFSET          set FX_OFFSET+1



DATASIZE_SPLITER	equ	(FX_OFFSET)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\rateconv.h ===
;**************************************************************************
;
;       RATECONV.h    
;
;**************************************************************************        

FXMEM               set DATASIZE_DSP_FX_STATE_MONO
FX_TEMP_BUFFER      equ FX_STATE_IO1_OUT0

FX_SRC_STEP         set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE0     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE1     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE2     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE3     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE4     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE5     set FXMEM
FXMEM               set FXMEM+1

DMA_NODE_WRITE6     set FXMEM
FXMEM               set FXMEM+1

FX_INDEX            set FXMEM
FXMEM               set FXMEM+1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\xtc.inc ===
;	File	:	XTC.asm
;	Version	:	1.0
;	Date	:	16/8/2000
;
;	Author	:	RDA
;				Sensaura Ltd
;
;       Modified/optimized by georgioc so single xtalk can do 4in->4out
;
; Description
; ===========
;	Crosstalk canceller include file.
;	This file contains the constant definitions and macros
;	for the crosstalk canceller.
;
; Assembler options : Don't preserve comments in macros
	opt     nocm


; CTC_DELAYBUFFER_SIZE
;	The length of the crosstalk canceller delay line.
;
CTC_DELAYBUFFER_SIZE	set	11


; CTC_COEFF_A1_DEFAULT
;	The IIR A1 coefficient. (The feedback gain)
;
; CTC_COEFF_B0_DEFAULT
;	The IIR B0 coefficient. (The input gain)
;
CTC_COEFF_A1_DEFAULT	set	$7645A1		;0.924*(1<<23)
CTC_COEFF_B0_DEFAULT	set	$F88313		;-0.0585*(1<<23)



; Define the memory layout of the CTC structure

CTC_Memory			set     DATASIZE_DSP_FX_STATE_4IN_4OUT

CTC_FrontDelayBuffer_Left	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+CTC_DELAYBUFFER_SIZE

CTC_IIR_FrontDelayElement_Left	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+1

CTC_FrontDelayBuffer_Right	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+CTC_DELAYBUFFER_SIZE

CTC_IIR_FrontDelayElement_Right	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+1

CTC_FrontDelayBufferIndex	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+1

; rear delay data

CTC_RearDelayBuffer_Left	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+CTC_DELAYBUFFER_SIZE

CTC_IIR_RearDelayElement_Left	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+1

CTC_RearDelayBuffer_Right	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+CTC_DELAYBUFFER_SIZE

CTC_IIR_RearDelayElement_Right	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+1

CTC_RearDelayBufferIndex	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+1

; constants

CTC_Coeff_A1		       	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+1
CTC_Coeff_B0		       	set	CTC_Memory
CTC_Memory		       	set	CTC_Memory+1

CTC_Memory		       	set	CTC_Memory+1	; Add an extra word to make the structure
						        ; a multiple of 4 words long

DATASIZE_XTALK		       	set	CTC_Memory
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\rms.h ===
; **************************************************************************
;
; rms.h    
;
; **************************************************************************        


; memory locations and pointers

FX_OFFSET       set     (DATASIZE_DSP_FX_STATE_6IN_0OUT)    

FX_RMS_NUM_MIXBINS  set  FX_OFFSET
FX_OFFSET           set  FX_OFFSET+1

FX_RMS_AVG_OUTPUT  set  FX_OFFSET
FX_OFFSET          set  FX_OFFSET+6

FX_RMS_MAX_OUTPUT  set  FX_OFFSET
FX_OFFSET          set  FX_OFFSET+6


DATASIZE_RMS	    equ  FX_OFFSET	

; constants

RMS_NUM_MIXBINS     equ  6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\Reverb.inc ===
;	File	:	Reverb.inc
;	Version	:	0.0
;	Date	:	22/8/2000
;
;	Author	:	RDA
;				Sensaura Ltd
;
;
;
; Description
; ===========
; Reverb definitions and macros
;
; Version history
; ===============
;


; Options : Don't preserve comments in macros
	opt     nocm





DMAcbs_pNxtCmd				set 0
DMAcbs_controlBits			set 1
DMAcbs_count				set 2
DMAcbs_pDspStart			set 3
DMAcbs_smOffset				set 4
DMAcbs_smBaseAddress		set 5
DMAcbs_smSizeMinus1			set 6

DMAcbs_SizeofDMAcbs			set 7

DMAcbs_eol					set $004000				; Set pNxtCmd=DMAcbs_eol to indicate the end of the linked list
DMAcbs_Bit_eol				set 14

; Control bit values
DMAcbs_InterleaveOFF		set $000000
DMAcbs_InterleaveON			set $000001

DMAcbs_HostToDsp			set $000000
DMAcbs_DspToHost			set $000002
DMAcbs_Bit_rdDSPmem			set 1

DMAcbs_IOCOFF				set $000000
DMAcbs_IOC1					set $000004
DMAcbs_IOC2					set $000005
DMAcbs_IOC3					set $000006

DMAcbs_smOffWrBkON			set $000010
DMAcbs_smOffWrBkOFF			set $000000

DMAcbs_smBufIdNotifier		set $000000
DMAcbs_smBufIdLinear		set $000040
DMAcbs_smBufIdDMAreg0		set $000100
DMAcbs_smBufIdDMAreg1		set $000120
DMAcbs_smBufIdDMAreg2		set $000140
DMAcbs_smBufIdDMAreg3		set $000160
DMAcbs_smBufIdCircular		set $0001C0
DMAcbs_smBufIdOffset		set $0001E0

DMAcbs_isoOFF				set $000000
DMAcbs_isoON				set $000200

DMAcbs_smDataFmt0			set $000000
DMAcbs_smDataFmt1			set $000400
DMAcbs_smDataFmt2			set $000800
DMAcbs_smDataFmt3			set $000C00
DMAcbs_smDataFmt4			set $001000

;
DMAcbs_inc					set $004000				; Multiply the required increment by this value to calculate 
													; the correct increment for the control block
DMAcbs_inc1					set $004000				; Increment by 1 after each transfer


DMAcbs_count0				set $000000
DMAcbs_count1				set $000010

DMAcbs_nul					set $004000


NewDMAcbs	MACRO M_pNxtCmd,M_controlbits,M_count,M_pDspStart,M_HostBase,M_HostSize,M_HostOffset
	dc	M_pNxtCmd
	dc	M_controlbits+DMAcbs_InterleaveOFF+DMAcbs_IOCOFF+DMAcbs_smOffWrBkON+DMAcbs_smBufIdCircular+DMAcbs_isoOFF+DMAcbs_smDataFmt2+DMAcbs_inc1
	dc	M_count
	dc	M_pDspStart
	dc	M_HostOffset
	dc	M_HostBase
	dc	M_HostSize-1
	ENDM






;==========================
;	IIR data structure
;==========================
;
; The notation used for IIR filters is as follows
;	'a'		A feedback (recursive) gain
;	'b'		A feedforward (non-recursive) gain

IIR_Offset					set 0
IIR_DelayElement			set IIR_Offset
IIR_Offset					set IIR_Offset+1

IIR_CoefficientA1			set IIR_Offset
IIR_Offset					set IIR_Offset+1

IIR_CoefficientB0			set IIR_Offset
IIR_Offset					set IIR_Offset+1

SizeOfIIR_Data				set	IIR_Offset


;	Parameters
;		M_A1	Initial coefficient for coefficient A1
;		M_B0	Initial coefficient for coefficient B0
NewIIR_Coefficients	MACRO M_A1,M_B0
	dc	0					; Initial delay element value
	dc	M_A1				; Initial value of coefficient A1
	dc	M_B0				; Initial value of coefficient B0
	ENDM

;                  __
;          ---A1--|__|--
;         |             |
;   --B0-(+)-----------------
;



;==========================
;	IIR2 data structure
;==========================
;	Stores data for a second order section

IIR2_Offset					set 0

IIR2_CoefficientA0			set IIR2_Offset
IIR2_Offset					set IIR2_Offset+1
IIR2_CoefficientA1			set IIR2_Offset
IIR2_Offset					set IIR2_Offset+1
IIR2_CoefficientA2			set IIR2_Offset
IIR2_Offset					set IIR2_Offset+1

IIR2_CoefficientB1			set IIR2_Offset
IIR2_Offset					set IIR2_Offset+1
IIR2_CoefficientB2			set IIR2_Offset
IIR2_Offset					set IIR2_Offset+1

SizeOfIIR2_Coefficients		set	IIR2_Offset



;	Parameters
;		M_A0	Initial coefficient for coefficient A0
;		M_A1	Initial coefficient for coefficient A1
;		M_A2	Initial coefficient for coefficient A2
;		M_B1	Initial coefficient for coefficient B1
;		M_B2	Initial coefficient for coefficient B2
IIR2_Coefficients	MACRO M_A0,M_A1,M_A2,M_B1,M_B2
	dc	M_A0				; Initial value of coefficient A0
	dc	M_A1				; Initial value of coefficient A1
	dc	M_A2				; Initial value of coefficient A2
	dc	M_B1				; Initial value of coefficient B1
	dc	M_B2				; Initial value of coefficient B2
	ENDM



;                 _
;         ,--B2--|_|--A2--.
;         |       |       |
;         |       _       |
;         |--B1--|_|--A1--|
;         |       |       |
;   -----(+)----------A0-(+)----
;



;==========================
;	Data structure for the second order interpolation filters
;==========================
;	Stores data for a second order section

IIR2_CoefficientY0			set 0
IIR2_CoefficientY1			set 1

SizeOfIIR2_Data				set	2


;	Parameters
;		None
IIR2_Data	MACRO
	dc	0					; Initial delay element value
	dc	0					; Initial delay element value

	ENDM


; See 'Parameters.inc' for the definition of the IIR parameters


        IF @DEF('DEBUG')
              
DEBUG_IWOZHERE_OFFSET           equ $800
DEBUG_IWOZHERE_COUNTER          equ (DEBUG_IWOZHERE_OFFSET)
DEBUG_IWOZHERE_TEMP             equ (DEBUG_IWOZHERE_OFFSET+1)
DEBUG_IWOZHERE_DATA             equ (DEBUG_IWOZHERE_OFFSET+2)
SIZEOFDEBUGLOG                  set 256
IWOZHERE MACRO IWOZ_ID
	;DEBUGGERLOG
        move	a,x:(DEBUG_IWOZHERE_TEMP)
        move	IWOZ_ID,a
        move    x:(DEBUG_IWOZHERE_COUNTER),n7
        move    #DEBUG_IWOZHERE_DATA,r7
        move    a,x:(r7+n7)
        move    n7,a
        add     #1,a
	cmp	#SIZEOFDEBUGLOG,a
	clr	a	ifge
        move    a,x:(DEBUG_IWOZHERE_COUNTER)
        move	x:(DEBUG_IWOZHERE_TEMP),a

	ENDM

        ELSE

IWOZHERE MACRO IWOZ_ID
        ENDM

        ENDIF

; A debugging macro to log when a frame contains a non-zero value
LOGIFFRAMENONZERO MACRO PFRAMEADDRESS
	move	r0,x:(DEBUG_IWOZHERE_TEMP+1)
	move	a,x:(DEBUG_IWOZHERE_TEMP+2)
	move	x:(r5+PFRAMEADDRESS-StaticWorkspaceBase),r0
	
	do		#SizeOfFrame,_debugloop
		move	x:(r0)+,a
		cmp		#0,a
		beq		_debugequaltozero
		DEBUGGERLOG	#*
		DEBUGGERLOG	r0
_debughang
		bra	_debughang
_debugequaltozero
		nop
_debugloop
	move	x:(DEBUG_IWOZHERE_TEMP+2),a
	move	x:(DEBUG_IWOZHERE_TEMP+1),r0
	ENDM



; A debugging macro to log when a frame contains a non-zero value
LOGIFBLOCKNONZERO MACRO ADDR_START,ADDR_END
	move	r0,x:(DEBUG_IWOZHERE_TEMP+1)
	move	a,x:(DEBUG_IWOZHERE_TEMP+2)
	
	move	#ADDR_START,r0

	do		#(ADDR_END-ADDR_START)/4,_debugloop1
		move	x:(r0),a
;		cmp		#0,a
;		beq		_debugequaltozero1
;		DEBUGGERLOG #$123456
;		DEBUGGERLOG #$123456
;		DEBUGGERLOG	#*
;		DEBUGGERLOG	r0
;_debughang1
;		bra	_debughang1
;_debugequaltozero1
;		move	r0,a
;		add		#4,a
;		move	a,r0
_debugloop1
	move	x:(DEBUG_IWOZHERE_TEMP+2),a
	move	x:(DEBUG_IWOZHERE_TEMP+1),r0
	ENDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\dsound\dsp\include\util.h ===
;**************************************************************************
;
;  Util.h   
;
;**************************************************************************        
	
	include 'DMAUtil.h'
	include 'Io.h'
;	include 'vectors.asm'

	define rD 	  'r5'		; Standard data structure register
	define rStack 'r6'		; Stack pointer register

kGPMemory_Base_BootROM			equ $FF0000	; X-memory, 128 words
;kGPMemory_Base_PeripheralRegisters	equ $FFFF80	; X-memory, to 0xFFFFFF

INTERRUPT_TABLE_BASE 		equ $FF0000

; VBA at $FF0000 (requires 256 word alignment).  
; The vector table is exactly where the power-up reset starts fetching instructions.
; The first interrupt vector is hardware RESET.
; Only needs up to $24 (36d) .. $44 (68d) interrupts or so, not full 256 word table.

INTERRUPT_REGISTER		equ $FFFFC5	; Interrupt request/clear register
kAbortFrameBit		equ		0			; Bit 0
kStartFrameBit		equ		1			
kPutUpdateBit		equ		2
kMailInUpdateBit	equ		3
kDMAComplete1Bit	equ		4
kDMAComplete2Bit	equ		5
kDMAComplete3Bit	equ		6	
kDMAEndOfListBit	equ		7
kTimer1Bit			equ		8
kTimer2Bit			equ		9
kDMAErrorBit		equ		10
kAddressErrorBit	equ		11

; ==============================================================
;  MailBox Register stuff  
; ==============================================================
MAILBOX_OUT_REGISTER	equ $FFFFC2	; For DSP->Host messages
MAILBOX_IN_REGISTER		equ $FFFFC3	; For DSP<-Host messages

; ==============================================================
;  FIFO stuff  
; ==============================================================
FIFOOUT_CONTROL_REGISTER	equ		$FFFFC8
FIFOIN_CONTROL_REGISTER		equ		$FFFFC9
SAMPLE_CONTROL_REGISTER		equ		$FFFFCA

; Current Value is bits 23:2  (22 bits)	(from dev_apu.ref)
;NV_PAPU_GPOFCUR0  equ	$0000302C 
;NV_PAPU_GPOFCUR1  equ	$0000303C 
;NV_PAPU_GPOFCUR2  equ	$0000304C 
;NV_PAPU_GPOFCUR3  equ	$0000305C 

; End Value is bits 23:8  (16 bits) (from dev_apu.ref)
;NV_PAPU_GPOFEND0  equ	$00003028 
;NV_PAPU_GPOFEND1  equ	$00003038 
;NV_PAPU_GPOFEND2  equ	$00003048 
;NV_PAPU_GPOFEND3  equ	$00003058 

; Base Value is bits 23:8 (16 bits) (from dev_apu.ref)
;NV_PAPU_GPOFBASE0  equ	$00003024 
;NV_PAPU_GPOFBASE1  equ	$00003034 
;NV_PAPU_GPOFBASE2  equ	$00003044 
;NV_PAPU_GPOFBASE3  equ	$00003054 

; ==============================================================
;  Headroom/Valid stuff		Bits 23:4 Zero, Bit 3=Valid, Bits 2:0=Headroom, # right shifts
; ==============================================================
HEADROOM_VALID_REGISTER00	equ		$FFFF90
HEADROOM_VALID_REGISTER01	equ		$FFFF91
HEADROOM_VALID_REGISTER02	equ		$FFFF92
HEADROOM_VALID_REGISTER03	equ		$FFFF93
HEADROOM_VALID_REGISTER04	equ		$FFFF94
HEADROOM_VALID_REGISTER05	equ		$FFFF95
HEADROOM_VALID_REGISTER06	equ		$FFFF96
HEADROOM_VALID_REGISTER07	equ		$FFFF97

HEADROOM_VALID_REGISTER08	equ		$FFFF98
HEADROOM_VALID_REGISTER09	equ		$FFFF99
HEADROOM_VALID_REGISTER10	equ		$FFFF9A
HEADROOM_VALID_REGISTER11	equ		$FFFF9B
HEADROOM_VALID_REGISTER12	equ		$FFFF9C
HEADROOM_VALID_REGISTER13	equ		$FFFF9D
HEADROOM_VALID_REGISTER14	equ		$FFFF9E
HEADROOM_VALID_REGISTER15	equ		$FFFF9F

HEADROOM_VALID_REGISTER16	equ		$FFFFA0
HEADROOM_VALID_REGISTER17	equ		$FFFFA1
HEADROOM_VALID_REGISTER18	equ		$FFFFA2
HEADROOM_VALID_REGISTER19	equ		$FFFFA3
HEADROOM_VALID_REGISTER20	equ		$FFFFA4
HEADROOM_VALID_REGISTER21	equ		$FFFFA5
HEADROOM_VALID_REGISTER22	equ		$FFFFA6
HEADROOM_VALID_REGISTER23	equ		$FFFFA7

HEADROOM_VALID_REGISTER24	equ		$FFFFA8
HEADROOM_VALID_REGISTER25	equ		$FFFFA9
HEADROOM_VALID_REGISTER26	equ		$FFFFAA
HEADROOM_VALID_REGISTER27	equ		$FFFFAB
HEADROOM_VALID_REGISTER28	equ		$FFFFAC
HEADROOM_VALID_REGISTER29	equ		$FFFFAD
HEADROOM_VALID_REGISTER30	equ		$FFFFAE
HEADROOM_VALID_REGISTER31	equ		$FFFFAF

; ==============================================================
;  Timer stuff	
; ==============================================================
TIMER1_CONFIGURATION_REGISTER	equ	$FFFFB0
TIMER1_CONTROL_REGISTER			equ	$FFFFB1
TIMER1_TERMINAL_COUNT_REGISTER	equ	$FFFFB2
TIMER1_COUNT_REGISTER			equ	$FFFFB3
TIMER2_CONFIGURATION_REGISTER	equ	$FFFFB4
TIMER2_CONTROL_REGISTER			equ	$FFFFB5
TIMER2_TERMINAL_COUNT_REGISTER	equ	$FFFFB6
TIMER2_COUNT_REGISTER			equ	$FFFFB7

; ==============================================================
;  Command stuff		Bits 11:2  offset in 4KB circular buffer
; ==============================================================
kGPMemory_Base_CommandCue		equ $FFF000		; Top 4KByte page

COMMAND_GET_REGISTER 		equ $FFFFC0	; Ptr to next read location
COMMAND_PUT_REGISTER 		equ $FFFFC1	; Ptr to 1st empty write location

; ==============================================================
;  Processing control
; ==============================================================
PROCESSING_CONTROL_REGISTER		equ $FFFFC4	
kProcessingControl_SetIdleBit				equ 0		; Bit 0
kProcessingControl_NotifyInterruptBit		equ 1		

; ==============================================================
;  Global Sample Count Register		Bits 23:0
; ==============================================================
GLOBAL_SAMPLE_COUNT_REGISTER		equ $FFFFC6	

k2To7			set		     128.0
k2To8			set		     256.0
k2To15			set		   32768.0
k2To16			set		   65536.0
k2To22			set		 (64.0*k2To16)
k2To23			set		(128.0*k2To16)
k2To24			set		(256.0*k2To16)
k2To31			set		(128.0*k2To24)
k2To32			set		(256.0*k2To24)

k2To15m1		set		 (k2To15-1.0)
k2To16m1		set		 (k2To16-1.0)
k2To23m1		set		 (k2To23-1.0)
k2To24m1		set		 (k2To24-1.0)
k24Normalizer	set		 (k2To23)

Fs			set     48000.0     ; Sampling frequency
SamplingFrequency	set     48000.0              
SamplingPeriod		set     1.0/48000.0              
NormalSamplingFrequency	set     (48000.0/k2To23)              

kFs					equ     48000     
kSamplingFrequency	EQU     kFs              

PI				set     2.0*@asn(1.0)                   
kPi				set     PI                   
kTwoPi			set     2.0*kPi                   
kHalfPi			set     (kPi/2.0)                 
kQuarterPi		set     (kPi/4.0)                   

kDegreeToRadian  set     kPi/180.0   
kDegreeToPi      set	(1.0/180.0)   

kPiOverFs		set		(kPi/Fs)
kTwoPiOverFs	set		(kTwoPi/Fs)

kLog10_2	set 0.3010299956639812
kLog2_10	set (1.0/kLog10_2)	; 1/log2(10) = log10(2)

kLogE_2	    set	0.69314718055994529
kLn_2		set kLogE_2

kLog2_E		set (1.0/kLogE_2)		;  1/logE( 2) = log2(E)

;  FIXXX: go back and get the real numbers !!!
kDetuneRatio_p01CentFraction	set		0.0005777895

kDetuneRatio_m18Cents	set		0.9896566564
kDetuneRatio_m16Cents	set		0.9908006133
kDetuneRatio_m14Cents	set		0.9919458924
kDetuneRatio_m12Cents	set		0.9930924954
kDetuneRatio_m10Cents	set		0.9942404238
kDetuneRatio_m08Cents	set		0.9953896791
kDetuneRatio_m06Cents	set		0.9965402628
kDetuneRatio_m04Cents	set		0.9976921765
kDetuneRatio_m02Cents	set		0.9988454217
kDetuneRatio_m01Cents	set		0.9994225441
kDetuneRatio_m00Cents	set		1.0
kDetuneRatio_p00Cents	set		1.0
kDetuneRatio_p01Cents	set		(1.0+1.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p02Cents	set		(1.0+2.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p03Cents	set		(1.0+3.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p04Cents	set		(1.0+4.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p05Cents	set		(1.0+5.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p06Cents	set		(1.0+6.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p07Cents	set		(1.0+7.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p08Cents	set		(1.0+8.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p09Cents	set		(1.0+9.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p10Cents	set		(1.0+10.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p11Cents	set		(1.0+11.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p12Cents	set		(1.0+12.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p13Cents	set		(1.0+13.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p14Cents	set		(1.0+14.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p15Cents	set		(1.0+15.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p16Cents	set		(1.0+16.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p17Cents	set		(1.0+17.0*kDetuneRatio_p01CentFraction)
kDetuneRatio_p18Cents	set		(1.0+18.0*kDetuneRatio_p01CentFraction)

kTuneRatio_p01SemitoneFraction set 0.0594630944
kTuneRatio_p01Semitones	set 1.0594630944
kTuneRatio_p02Semitones	set 1.1224620483
kTuneRatio_p03Semitones	set	1.1892071150
kTuneRatio_p04Semitones	set	1.2599210499
kTuneRatio_p05Semitones	set	1.3348398542
kTuneRatio_p06Semitones	set	1.4142135624
kTuneRatio_p07Semitones	set	1.4983070769
kTuneRatio_p08Semitones	set	1.5874019520
kTuneRatio_p09Semitones	set	1.6817928305
kTuneRatio_p10Semitones	set	1.7817974363
kTuneRatio_p11Semitones	set	1.8877486254
kTuneRatio_p12Semitones	set	2.0

kTmpBufSize equ		1024
kTmpBufMask set		(kTmpBufSize-1)

kMixBufSize equ		32

;************************************************************
; Bound	
;************************************************************
Bound macro
Bound_IsABigger
	cmp		x0,a		; a - x
	ble		Bound_IsASmaller
	move	x0,a
	bra		Bound_AOk
Bound_IsASmaller
	cmp		y0,a		; a - y
	jge		Bound_AOk
	move	y0,a
Bound_AOk
	move	a,r1
	endm

;************************************************************
; Ceiling	
;************************************************************
Ceiling macro
Ceiling_IsABigger
	cmp		x0,a		; a - x
	ble		Ceiling_Bound_AOk
	move	x0,a
Ceiling_Bound_AOk
	move	a,r1
	endm

;************************************************************
; Wrap	
;************************************************************
Wrap macro
Wrap_IsABigger
	cmp		x0,a		; a - x0
	ble		Wrap_IsASmaller
	move	x0,a
	bra		Wrap_AOk
Wrap_IsASmaller
	cmp		y0,a		; a - y0
	jge		Wrap_AOk
	move	y0,a
Wrap_AOk
	move	a,r1
	endm

;************************************************************
; ClearBufferX_R0X0	Clear buffer at address	x:(r0) of length X0
;************************************************************
ClearBufferX_R0X0	macro
	clr		a
	rep		x0
	move	a,x:(r0)+
					endm

;************************************************************
; ClearBufferY_R0X0	Clear buffer at address	y:(r0) of length X0
;************************************************************
ClearBufferY_R0X0	macro
	clr		a
	rep		x0
	move	a,y:(r0)+
					endm

;************************************************************
; GPAddX	Add frames in XRAM
;			b = a + b	
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;************************************************************

GPAddX  macro
    dor      #kFrameLength,GPAddX_Loop             
	move	x:(r0)+,x0
	move	x:(r1),a
	add	x0,a
	move	a,x:(r1)+
GPAddX_Loop
 	endm
; ---- end GPAddX ----

;************************************************************
; GPAddY	Add frames in YRAM	
;			c = a + b
;
;			r0	a YRAM Buffer address
;                       r1	b YRAM Buffer address
;                       r2	c YRAM Buffer address
;************************************************************
GPAddY  macro
    dor      #kFrameLength,GPAddY_Loop             
	move	y:(r0)+,x0
	move	y:(r1)+,a
	add	x0,a
	move	a,y:(r2)+
GPAddY_Loop
 	endm
; ---- end GPAddY ----

;************************************************************
; GPScaleXAddtoY	Scale frames in XRAM then add them to
; in Y ram
;			y:(r4) = x:(r0)*x1+y:(r4)
;
;			r0	XRAM Buffer address
;           r4	YRAM Buffer address
;           x1  scaling
;************************************************************
GPScaleXAddToY macro
	move	x:(r0)+,x0
              
    dor     #kFrameLength,GPScaleXAddToY_Loop             
	mpy     x1,x0,a  x:(r0)+,x0  y:(r4),y0
    add     y0,a
	move	a,y:(r4)+
GPScaleXAddToY_Loop
 	endm

;************************************************************
; GPScaleXtoY	Scale frames in XRAM then then put
; in Y ram
;			y:(r4) = x:(r0)*x1
;
;			r0	XRAM Buffer address
;           r1	YRAM Buffer address
;           x1  scaling
;************************************************************
GPScaleXToY macro
	move	x:(r0)+,x0

    dor     #kFrameLength,GPScaleXToY_Loop             
	mpy     x1,x0,a  x:(r0)+,x0 
	move	a,y:(r1)+
GPScaleXToY_Loop
 	endm

;************************************************************
; GPScaleYAddXtoX	Add frames in YRAM	to X ram then put
; in X ram
;			x:(r2) = y:(r0)*x0 + x:(r1)
;
;			r0	a YRAM Buffer address
;           r1	b XRAM Buffer address
;           r2	c XRAM Buffer address
;           x1  scaling
;************************************************************
GPScaleYAddXToX macro
	move	y:(r4)+,y0

    dor     #kFrameLength,GPScaleYAddXToX_Loop             
	mpy     x1,y0,a  x:(r1)+,x0  y:(r4)+,y0
    add     x0,a
	move	a,y:(r2)+
GPScaleYAddXToX_Loop
 	endm
; ---- end ----

;************************************************************
; GPScaleXAddX	Add frames in XRAM	to X ram then put
; in X ram
;			x:(r1) = x:(r0)*x1 + x:(r1)
;
;			r0	a XRAM Buffer address
;           r1	b XRAM Buffer address
;           r2	c XRAM Buffer address
;           x1  scaling
;************************************************************
GPScaleXAddX macro
	move	x:(r0)+,x0

    dor     #kFrameLength,GPScaleXAddX_Loop             
	mpy     x1,x0,a  x:(r0)+,x0 
    move    x:(r1),y0
    add     y0,a
	move	a,x:(r1)+

GPScaleXAddX_Loop
 	endm
; ---- end GPAddY ----



;************************************************************
; GPAverageX	Average frames in XRAM
;			c = (a+b)/2
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;                       r2	c XRAM Buffer address
;************************************************************
GPAverageX macro
    dor      #kFrameLength,GPAverageX_Loop             
	move	x:(r0)+,a
	move	x:(r1)+,x0
	add	x0,a
	asr	#1,a,a
	move	a,x:(r2)+
GPAverageX_Loop
 	endm
; ---- end GPAverageX ----

;************************************************************
; GPDiffX	Take difference frames in XRAM
;			c = (a-b)/2
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;                       r2	c XRAM Buffer address
;************************************************************
GPDiffX macro
    dor      #kFrameLength,GPDiffX_Loop             
	move	x:(r0)+,a
	move	x:(r1)+,x0
	sub	x0,a
	asr	#1,a,a
	move	a,x:(r2)+
GPDiffX_Loop
 	endm
; ---- end GPDiffX ----

;************************************************************
; GPAccY	Accumulate frames in YRAM
;			b += a
;
;			r0	a YRAM Buffer address
;                       r1	b YRAM Buffer address
;************************************************************
GPAccY  macro
    dor      #kFrameLength,GPAccY_Loop             
	move	y:(r0)+,x0
	move	y:(r1),a
	add	x0,a
	move	a,y:(r1)+
GPAccY_Loop
 	endm
; ---- end GPAccY ----

;************************************************************
; GPAccXtoY	Accumulate XRAM frame to YRAM
;			ax += by
;
;			r0	a XRAM Buffer address
;                       r1	b YRAM Buffer address
;************************************************************
GPAccXtoY macro
    dor      #kFrameLength,GPAccXtoY_Loop             
	move	x:(r0)+,x0
	move	y:(r1),a
	add	x0,a
	move	a,y:(r1)+
GPAccXtoY_Loop
 	endm
; ---- end GPAccYtoX ----

;************************************************************
; GPAccYtoX	Accumulate YRAM frame to XRAM
;			ax += by
;
;			r0	a YRAM Buffer address
;                       r1	b XRAM Buffer address
;************************************************************
GPAccYtoX macro
    dor      #kFrameLength,GPAccYtoX_Loop             
	move	y:(r0)+,x0
	move	x:(r1),a
	add	x0,a
	move	a,x:(r1)+
GPAccYtoX_Loop
 	endm
; ---- end GPAccYtoX ----

;************************************************************
; GPScaleX	Scale frame in XRAM	
;			b = k*a
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;			x0	k scale factor
;************************************************************
GPScaleX macro
    dor      #kFrameLength,GPScaleX_Loop             
	move	x:(r0)+,y0
	mpy	x0,y0,a
	move	a,x:(r1)+
GPScaleX_Loop
 	endm
; ---- end GPScaleX ----

;************************************************************
; GPScaleY	Scale frame in YRAM
;			b = k*a
;
;			r0	a YRAM Buffer address
;                       r1	b YRAM Buffer address
;			x0	k scale factor
;************************************************************
GPScaleY macro
    dor      #kFrameLength,GPScaleY_Loop             
	move	y:(r0)+,y0
	mpy	x0,y0,a
	move	a,y:(r1)+
GPScaleY_Loop
 	endm
; ---- end GPScaleY ----

;************************************************************
; GPMacX	Multiply-accumulate frame in XRAM
;			b += k*a
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;			x0	k scale factor
;************************************************************
GPMacX  macro
    dor      #kFrameLength,GPMacX_Loop             
	move	x:(r0)+,y0
	move	x:(r1),a
	mac	x0,y0,a
	move	a,x:(r1)+
GPMacX_Loop
 	endm
; ---- end GPMacX ----
	
;************************************************************
; GPMacY	Multiply-accumulate frame in YRAM
;			b += k*a
;
;			r0	a YRAM Buffer address
;                       r1	b YRAM Buffer address
;			x0	k scale factor
;************************************************************
GPMacY  macro
    dor      #kFrameLength,GPMacY_Loop             
	move	x:(r0)+,y0
	move	x:(r1),a
	mac	x0,y0,a
	move	a,x:(r1)+
GPMacY_Loop
 	endm
; ---- end GPMacY ----
		  
;************************************************************
; GPMSubX	Multiply-subtract frame in XRAM
;			b -= k*a
;
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;			x0	k scale factor
;************************************************************
GPMSubX macro
    dor      #kFrameLength,GPMSubX_Loop             
	move	x:(r0)+,y0
	move	x:(r1),a
	mac	-x0,y0,a
	move	a,x:(r1)+
GPMSubX_Loop
 	endm
; ---- end GPMSubX ----

;************************************************************
; GPSubX	Subtract frame in XRAM
;			c = a - b	
;			r0	a XRAM Buffer address
;                       r1	b XRAM Buffer address
;                       r2	c XRAM Buffer address
;************************************************************
GPSubX  macro
    dor      #kFrameLength,GPSubX_Loop             
	move	x:(r0)+,x0
	move	x:(r1)+,a
	sub	x0,a
	move	a,x:(r2)+
GPSubX_Loop
 	endm
; ---- end GPSubX ----

;************************************************************
; GPClrX	Fill X-RAM frame with zeros
;
;			r0	XRAM Buffer address
;************************************************************
GPClrX  macro
	clr	a
    dor      #kFrameLength,GPClrX_Loop             
	move	a,x:(r0)+
GPClrX_Loop
 	endm
; ---- end GPClrX ----

;************************************************************
; GPClrY	Fill Y-RAM frame with zeros
;
;			r0	YRAM Buffer address
;************************************************************
GPClrY  macro
	clr	a
    dor      #kFrameLength,GPClrY_Loop             
	move	a,y:(r0)+
GPClrY_Loop
 	endm
; ---- end GPClrY ----

;************************************************************
; GPSetX	Fill X-RAM frame with constant
;
;			r0	XRAM Buffer address
;			x0	fill value
;************************************************************
GPSetX  macro
    dor      #kFrameLength,GPSetX_Loop             
	move	x0,x:(r0)+
GPSetX_Loop
 	endm
; ---- end GPSetX ----

;************************************************************
; GPSetY	Fill Y-RAM frame with constant
;
;			r0	YRAM Buffer address
;			x0	fill value
;************************************************************
GPSetY  macro
    dor      #kFrameLength,GPSetY_Loop             
	move	x0,y:(r0)+
GPSetY_Loop
 	endm
; ---- end GPSetY ----

GPCopyXtoXRAM macro
    dor      #kFrameLength,GPCopyXtoXRAM_Loop             
	move	x:(r0)+,x0
	move	x0,x:(r1)+
GPCopyXtoXRAM_Loop
 	endm
			
GPCopyXtoYRAM macro
    dor      #kFrameLength,GPCopyXtoYRAM_Loop             
	move	x:(r0)+,x0     
	move	x0,y:(r1)+
GPCopyXtoYRAM_Loop
 	endm

GPCopyYtoXRAM macro
    dor      #kFrameLength,GPCopyYtoXRAM_Loop             
	move	y:(r0)+,y0     
	move	y0,x:(r1)+
GPCopyYtoXRAM_Loop
 	endm


;************************************************************
; GPClearInterruptRegister	Clear  GP register
;************************************************************
GPClearInterruptRegister macro
      	movep    #$FFF,x:INTERRUPT_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end GPClearInterruptRegister ----

;************************************************************
; GPClearProcessingControlRegister	Clear  GP register
;************************************************************
GPClearProcessingControlRegister macro
      	movep    #$1,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"	
	endm
; ---- end GPClearProcessingControlRegister ----

;************************************************************
; GPClearSampleControlRegister	Clear  GP register
;************************************************************
GPClearSampleControlRegister macro
      	movep    #$0,x:SAMPLE_CONTROL_REGISTER	 
	endm
; ---- end GPClearSampleControlRegister ----

;************************************************************
; GPSetIdleBit		Assert GP Idle signal (Bit 0)
;************************************************************
GPSetIdleBit macro
	movep    #1,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end GPSetIdleBit ----

;************************************************************
; GPClearStartFrameBit		Start Frame (Bit 1)
;************************************************************
GPClearStartFrameBit macro
	movep    #2,x:INTERRUPT_REGISTER  ; "Write-1-To-Clear-One"	
	endm
; ---- end GPClearStartFrameBit ----

;**************************************************************
; entry point standard code for avoiding re-init on every frame
;**************************************************************

FXEntryPoint macro
    IF @DEF('STANDALONE')
    move #>$40,rD
    ENDIF        
    move    x:(rD+FX_STATE_FLAGS),x0
    brset   #BIT_FX_STATE_FLAG_INITIALIZED,x0,ComputeFX               
InitFX
    bset    #BIT_FX_STATE_FLAG_INITIALIZED,x0
    move    x0,x:(rD+FX_STATE_FLAGS)
    endm


;**************************************************************
; entry point standard code assuming no init
;**************************************************************

FXEntryPointNoInit macro
    IF @DEF('STANDALONE')
    move #>$40,rD
    ENDIF        
    endm
    
;**************************************************************
; exit point standard code
;**************************************************************

FXExit macro
    IF @DEF('STANDALONE')
    bra     FX_END  
    ELSE
    rts   
    ENDIF
    endm

;**************************************************************
; macro for computing right channel, by invoking compute routine
; a second time
;**************************************************************


FXStereoComputeRightChannel macro

    ;
    ; stereo processing. set a flag telling the FX
    ; to process the right channel, call compute routine again
    ;

    move    x:(rD+FX_STATE_FLAGS),x0
    bset    #BIT_FX_STATE_FLAG_PROCESS_STEREO,x0
    move    x0,x:(rD+FX_STATE_FLAGS)           

    bsr	ComputeFXSubroutine

    ;
    ; restore flags
    ;

    move    x:(rD+FX_STATE_FLAGS),x0
    bclr    #BIT_FX_STATE_FLAG_PROCESS_STEREO,x0
    move    x0,x:(rD+FX_STATE_FLAGS)
    endm


;**************************************************************
;
; set arithmetic saturation, x0 gets clobbered
;
;**************************************************************

FXSetSMMode macro
        movec   sr,x0            ; Set arithmetic saturation 
        bset    #20,x0
        movec   x0,sr
        endm

;**************************************************************
;
; unset arithmetic saturation, x0 gets clobbered
;
;**************************************************************

FXUnsetSMMode macro
        movec   sr,x0            ; Set arithmetic saturation 
        bclr    #20,x0
        movec   x0,sr
        endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\fx\echo\echo.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include "echop.h"
#include "echo.h"

#define MY_ASSERT(x) if( !(x) ) _asm int 3;

//
// implements a simple synchronous XMO and in-place
//

HRESULT
XCreateEchoFxMediaObject(
    DWORD dwDelay,
    DWORD dwSampleSize,
    XMediaObject **ppMediaObject
    )
{   
    HRESULT hr;
    CEchoXMO *pXmo;

    //
    // create net xmo
    //

    pXmo = new CEchoXMO();
    MY_ASSERT(pXmo);
    if (pXmo == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pXmo->Initialize(dwDelay,
                          dwSampleSize);


    *ppMediaObject = NULL;

    if (SUCCEEDED(hr)) {
        *ppMediaObject = pXmo;
        pXmo->AddRef();
    }

    return hr;

}

HRESULT CEchoXMO::Initialize(
    DWORD dwDelay,
    DWORD dwSampleSize
    )
{

    //
    // this simple XMO only supports 16 bit samples (2 bytes)
    // however arbitrary sample size can be supported if the Process routine
    // treats input/dst buffers as arrays with proper size element size
    //

    MY_ASSERT(dwSampleSize == (16 >> 3));
    m_dwSampleSize = dwSampleSize;
    m_dwDelay = dwDelay;

    //
    // allocate a buffer used as the delay line. Caches the previous packet..
    //

    m_pPreviousPacket = new SHORT[dwDelay/dwSampleSize];
    MY_ASSERT(m_pPreviousPacket);

    memset(m_pPreviousPacket,0,dwDelay/dwSampleSize);
    return S_OK;

}



HRESULT STDMETHODCALLTYPE CEchoXMO::GetInfo( 
    PXMEDIAINFO pInfo
    )
{
    MY_ASSERT(pInfo);

    //
    // we are a synchronous, in-place XMO
    //

    pInfo->dwFlags = XMO_STREAMF_IN_PLACE | XMO_STREAMF_FIXED_SAMPLE_SIZE;

    //
    // because we are synchronous and not in place the buffers they pass
    // must be large enough to implement the echo effect
    // For a synchronous XMO, maxlookahead is irrelevant
    //

    pInfo->dwInputSize = m_dwDelay;
    pInfo->dwOutputSize = m_dwDelay;

    return S_OK;

}

HRESULT STDMETHODCALLTYPE CEchoXMO::GetStatus( 
        /* [out] */ DWORD __RPC_FAR *pdwFlags
        )
{

    //
    // let the caller know if we can accept any more data
    //

    MY_ASSERT(pdwFlags);
    *pdwFlags = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;
    return S_OK;

}


HRESULT STDMETHODCALLTYPE CEchoXMO::Process( 
    const XMEDIAPACKET __RPC_FAR *pSrcBuffer,
    const XMEDIAPACKET __RPC_FAR *pDstBuffer
    )
{
    DWORD delayOffset = m_dwDelay/m_dwSampleSize;
    PSHORT dstBuffer, srcBuffer;
    SHORT srcSample;
    LONG temp32;

    //
    // we need both a destination and source buffer to operate
    //

    MY_ASSERT(pSrcBuffer);
    MY_ASSERT(pDstBuffer);

    //
    // make sure we have enough data to implement the echo effect
    //

    MY_ASSERT(pSrcBuffer->dwMaxSize >= m_dwDelay);
    MY_ASSERT(pDstBuffer->dwMaxSize >= m_dwDelay);
    MY_ASSERT(pSrcBuffer->pvBuffer);
    MY_ASSERT(pDstBuffer->pvBuffer);

    dstBuffer = (PSHORT) pDstBuffer->pvBuffer;
    srcBuffer = (PSHORT) pSrcBuffer->pvBuffer;

    //
    // echo effect
    //

    for (ULONG i=0;i<pDstBuffer->dwMaxSize/m_dwSampleSize;i++) {

        srcSample = srcBuffer[i];

        //
        // assume 16 bit samples. See comment in Initialize function.
        // Below we clip to avoid noise
        // 

        temp32 = m_pPreviousPacket[i]/2;

        temp32 += (LONG)srcSample;

        if (temp32 > 32767) {
            temp32 = 32767;
        } else if (temp32 < -32767) {
            temp32 = -32767;
        }

        dstBuffer[i] = (SHORT)temp32;

        //
        // cache the current src packet for the next call to process
        //

        m_pPreviousPacket[i] = srcSample;
    }

    if (pDstBuffer->pdwCompletedSize) {
        *pDstBuffer->pdwCompletedSize = pSrcBuffer->dwMaxSize;
    }

    if (pDstBuffer->pdwStatus) {
        *pDstBuffer->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
    }

    if (pSrcBuffer->pdwCompletedSize) {
        *pSrcBuffer->pdwCompletedSize = pSrcBuffer->dwMaxSize;
    }

    if (pSrcBuffer->pdwStatus) {
        *pSrcBuffer->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
    }

    //
    // set any events
    //

    if (pSrcBuffer->hCompletionEvent) {
        SetEvent(pSrcBuffer->hCompletionEvent);
    }

    if (pDstBuffer->hCompletionEvent) {
        SetEvent(pDstBuffer->hCompletionEvent);
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\fx\echo\echo.h ===
HRESULT
XCreateEchoFxMediaObject(
    DWORD dwDelay,
    DWORD dwSampleSize,
    XMediaObject **ppMediaObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\fx\echo\echop.h ===
#define _NTDRIVER_

#include <xtl.h>

#undef max
#undef min
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#undef  BREAK_INTO_DEBUGGER
#define BREAK_INTO_DEBUGGER __asm int 3


class CEchoXMO:public XMediaObject {

public:
    CEchoXMO()
    {
        m_cRef = 0;
        m_dwDelay = 0;
        m_dwSampleSize = 0;
        m_pPreviousPacket = NULL;
    }

    ~CEchoXMO()
    {
    }

    HRESULT Initialize(
        DWORD dwDelay,
        DWORD dwSampleSize
        );

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
        long l = InterlockedDecrement((long*)&m_cRef);
     
        if (l == 0)
           delete this;
        return l;
    }

    HRESULT STDMETHODCALLTYPE GetInfo( 
        PXMEDIAINFO pInfo
        );
    
    HRESULT STDMETHODCALLTYPE Process( 
        const XMEDIAPACKET __RPC_FAR *pSrcBuffer,
        const XMEDIAPACKET __RPC_FAR *pDstBuffer
        );
    
    HRESULT STDMETHODCALLTYPE Flush()
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Discontinuity(void)
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetStatus( 
        DWORD *dwFlags
        );
    

protected:

    PSHORT m_pPreviousPacket;
    ULONG m_cRef;
    DWORD m_dwDelay;
    DWORD m_dwSampleSize;


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\AC3Dolby2.h ===
0xD01B40, 0x000844, 0x020150, 0x72E809, 0x447000, 0x00095F, 0x607000, 0x000962, 0x20000B, 0x05A407, 0x0508DF, 0x0D1080, 0x0007BA, 0x0D1080, 0x0007ED, 0x050C05, 0x0D1080, 0x0007C0, 0x0D1080, 0x0007DA, 0x0508D9, 0x62F000, 0x000962, 0x60F400, 0x000FC2, 0x0A72D8, 0x000005, 0x240000, 0x447000, 0x000960, 0x5EE800, 0x021A9F, 0x20000B, 0x05A402, 0x014180, 0x547000, 0x000961, 0x44F000, 0x000960, 0x050952, 0x050811, 0x44F000, 0x000960, 0x0D1080, 0x0007E4, 0x56F000, 0x000960, 0x014180, 0x44F000, 0x000961, 0x547000, 0x000960, 0x200045, 0x0597D0, 0x0D1080, 0x0007A8, 0x00000C, 0x56F000, 0x000960, 0x44F000, 0x00095F, 0x0C1940, 0x008020, 0x547000, 0x00093D, 0x56F000, 0x000960, 0x200003, 0x05245A, 0x62F000, 0x000962, 0x60F400, 0x00094D, 0x44F400, 0x000080, 0x060690, 0x000002, 0x445800, 0x0212DE, 0x021A94, 0x0C1940, 0x00101B, 0x547000, 0x000930, 0x44F413, 0x000012, 0x0C1940, 0x005021, 0x547000, 0x000934, 0x02229E, 0x022AD4, 0x0C1940, 0x001021, 0x022A94, 0x0C1940, 0x001022, 0x0222D4, 0x0C1940, 0x001023, 0x547000, 0x000935, 0x200013, 0x024A94, 0x0C1940, 0x00201A, 0x547000, 0x000941, 0x021AD4, 0x447000, 0x000942, 0x200013, 0x023A94, 0x0C1940, 0x001018, 0x023294, 0x0C1940, 0x001019, 0x547000, 0x00093E, 0x023AD4, 0x447000, 0x000940, 0x0232D4, 0x447000, 0x00093F, 0x60F413, 0x00092C, 0x57F400, 0x000010, 0x0D1080, 0x0002A9, 0x44F400, 0x000000, 0x200045, 0x057400, 0x00000C, 0x30001B, 0x0D1080, 0x0002A1, 0x00000C, 0x44F400, 0x000015, 0x447000, 0x00092C, 0x44F400, 0x00094D, 0x447000, 0x00092D, 0x44F400, 0x000959, 0x447000, 0x00092E, 0x44F400, 0x000953, 0x447000, 0x00092F, 0x44F400, 0x00FFFF, 0x447000, 0x000933, 0x44F400, 0x000941, 0x447000, 0x000936, 0x240000, 0x447000, 0x000931, 0x447000, 0x000932, 0x447000, 0x000937, 0x447000, 0x000938, 0x447000, 0x000939, 0x447000, 0x00093A, 0x447000, 0x00093B, 0x447000, 0x00093C, 0x60F400, 0x000947, 0x44F400, 0x000000, 0x445800, 0x44F400, 0x000002, 0x445800, 0x44F400, 0x000003, 0x445800, 0x44F400, 0x000004, 0x445800, 0x44F400, 0x000001, 0x445800, 0x44F400, 0x000005, 0x445800, 0x60F400, 0x000959, 0x44F400, 0x000001, 0x060690, 0x000002, 0x445800, 0x60F400, 0x000953, 0x44F400, 0x00FFFF, 0x060690, 0x000002, 0x445800, 0x00000C, 0x62F000, 0x000962, 0x45F400, 0x000003, 0x0212D6, 0x2000E0, 0x62F400, 0x000F92, 0x210E00, 0x200040, 0x60F400, 0x000080, 0x219A00, 0x70F400, 0x000100, 0x56F400, 0x000007, 0x79EA00, 0x0D0180, 0x200003, 0x052400, 0x00000C, 0x230800, 0x00000A, 0x04C8A0, 0x0461A0, 0x0464A0, 0x0465A0, 0x0004F8, 0x230E00, 0x200022, 0x219800, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x4FE100, 0x5EE078, 0x06D810, 0x000009, 0x45D919, 0x200016, 0x8F8000, 0x8AB868, 0x4FE119, 0x200016, 0xCF1C00, 0xCA1D78, 0x230E00, 0x223022, 0x219800, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x4FE100, 0x5EE078, 0x06D810, 0x000009, 0x45D919, 0x200016, 0x8F8000, 0x8AB868, 0x4FE119, 0x200016, 0xCF1C00, 0xCA1D78, 0x223000, 0x221400, 0x044811, 0x223500, 0x5FE000, 0x45E100, 0x5EE06C, 0x06D810, 0x000009, 0x4FD919, 0x200016, 0x8F8000, 0x8AB878, 0x45E119, 0x200016, 0xCF1C00, 0xCA1D6C, 0x230E00, 0x3A0222, 0x223000, 0x219900, 0x221100, 0x233200, 0x221400, 0x66F400, 0x000F52, 0x204900, 0x223500, 0x045A18, 0x231C00, 0x231D00, 0x205200, 0x5FE000, 0xF4C100, 0x4CDE00, 0x4FD9AE, 0x5EE0BF, 0x06DA10, 0x000020, 0x06D210, 0x000007, 0x8F8016, 0x45E1EE, 0x8AB8CB, 0xCF1C16, 0x4FD9AE, 0xCA1DBF, 0x204900, 0x8F8016, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x4FD9EA, 0xCA0DCF, 0x06D210, 0x000007, 0x8F8016, 0x45E1AE, 0x8AB8BF, 0xCF1C16, 0x4FD9EA, 0xCA1DCF, 0x204900, 0x8F8016, 0x8AA8AE, 0xF4C1BF, 0x4CDE00, 0xCF0C16, 0x4FD9AE, 0xCA0DBF, 0x232F00, 0x234E2A, 0x200032, 0x21B900, 0x219A00, 0x0CCD80, 0xFFFFCA, 0x380200, 0x221400, 0x231C00, 0x235200, 0x66F400, 0x000F52, 0x045811, 0x231900, 0x223500, 0x231D00, 0x205200, 0x5FE000, 0xF4C100, 0x4CDE00, 0x4FC9AE, 0x5EE0BF, 0x200016, 0x8F8000, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x06D210, 0x000010, 0x4FC9EA, 0xCA0DCF, 0x200016, 0x8F8000, 0x8AA8AE, 0xF4C1BF, 0x4CDE00, 0xCF0C16, 0x4FC9AE, 0xCA0DBF, 0x200016, 0x8F8000, 0x8AA8EE, 0x45E1CB, 0xCF0C16, 0x4FC9EA, 0xCA0DCF, 0x200016, 0x8F8000, 0x8AA8AE, 0x2000BF, 0x05F420, 0x00FFFF, 0x574C16, 0x0461A0, 0x564D00, 0x0464A0, 0x0465A0, 0x00F3B8, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x00001A, 0xF0B900, 0x06DE10, 0x00000A, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D3, 0x10DD00, 0x444C00, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D3, 0x564C00, 0x03F18E, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x000021, 0x57DA00, 0x51D200, 0xF0B900, 0x06DE10, 0x00000B, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D2, 0x200010, 0x10DD09, 0x444C4C, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D2, 0x200010, 0x21C409, 0x444C4C, 0x03F184, 0x555A00, 0x515A00, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C, 0x44C800, 0x2000A0, 0x44C814, 0x200011, 0x06DE10, 0x000005, 0x180CA0, 0x44C8BA, 0x200014, 0x200011, 0x182400, 0x2000BA, 0x00000C, 0x46C813, 0x2000E1, 0x06DE10, 0x000003, 0x46C800, 0x564CE1, 0x566400, 0x00000C, 0x394000, 0x233D00, 0x204900, 0x204D00, 0x045112, 0x045516, 0x06D910, 0x000004, 0x46D900, 0xB0B200, 0x445600, 0x38FF00, 0x231C00, 0x204100, 0x204500, 0x044812, 0x044C16, 0x380200, 0x72F400, 0xFFFFFE, 0x3C0200, 0x76F400, 0xFFFFFE, 0xD08800, 0xD5CAD4, 0x2000F3, 0x5659C8, 0xD088EB, 0x063F90, 0x000005, 0xD5CAD4, 0x575DF3, 0x5659C8, 0xD088EB, 0x575D00, 0x204000, 0x204400, 0x387F00, 0x231A00, 0x231C00, 0x231E00, 0x204100, 0x204500, 0x204000, 0x204A00, 0x204400, 0x204E00, 0x380200, 0x72F400, 0xFFFFFE, 0x3C0200, 0x76F400, 0xFFFFFE, 0xD08800, 0xD5CAD4, 0x2000F3, 0x5679C8, 0xD088EB, 0x063F90, 0x000005, 0xD5CAD4, 0x5F7DF3, 0x5679C8, 0xD088EB, 0x5F7D00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4ED8C8, 0x2000EB, 0x5F64B0, 0x06DA10, 0x000006, 0xF1C0A7, 0x4DDA00, 0x4ED8C8, 0x565CEB, 0x5F64B0, 0x2000A7, 0x565C00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4EE1C8, 0x2000EB, 0x4ED8B0, 0x44D9A7, 0x5F64C8, 0x565CEB, 0x5F65B0, 0x06DA10, 0x00000A, 0xF1C0A7, 0x4DDA00, 0x4EE1C8, 0x565DEB, 0x4ED8B0, 0x44D9A7, 0x5F64C8, 0x565CEB, 0x5F65B0, 0x2000A7, 0x565D00, 0x00000C, 0xF1C000, 0x4DDA00, 0x4EC8A8, 0x2000BB, 0x574DE0, 0x06DA10, 0x000006, 0xF1C0C7, 0x4DDA00, 0x4EC8A8, 0x564CBB, 0x574DE0, 0x2000C7, 0x564C00, 0x00000C, 0xF1C100, 0x4DDA00, 0x4EE1A8, 0x4EE0BB, 0x44C8E0, 0x5755C7, 0x4EE1B8, 0x565CAB, 0x44C9E0, 0x574DC7, 0x06DA10, 0x00000B, 0xF1C100, 0x4DDA00, 0x4EE1A8, 0xC80CBB, 0x44C8E0, 0x5755C7, 0x4EE1B8, 0x565CAB, 0x44C9E0, 0x574DC7, 0x564C00, 0x00000C, 0x56D800, 0x06D910, 0x000007, 0x0C1E01, 0x20003E, 0x23A403, 0x02A048, 0x56D800, 0x575900, 0x205000, 0x00000C, 0x46F400, 0x000001, 0x23AE00, 0x223555, 0x05A40D, 0x22B400, 0x06DC10, 0x000009, 0x56F400, 0x7FFFFF, 0x06DD10, 0x000004, 0x44DC00, 0x200045, 0x027040, 0x544D00, 0x223500, 0x234F00, 0x56E20B, 0x052406, 0x44F400, 0x00000F, 0x200045, 0x027040, 0x546200, 0x218500, 0x06DC10, 0x000004, 0x56E500, 0x218564, 0x544D00, 0x223500, 0x238759, 0x45F400, 0x000002, 0x56E500, 0x45F465, 0xFFFFFE, 0x057417, 0x45F465, 0x000002, 0x059411, 0x204D58, 0x20007D, 0x05744D, 0x0597D6, 0x56E500, 0x45F465, 0xFFFFFE, 0x057413, 0x45F465, 0x000002, 0x059406, 0x204D58, 0x20007D, 0x057442, 0x0597CB, 0x05A7D5, 0x20455C, 0x05A40D, 0x56E500, 0x200054, 0x544D00, 0x56E500, 0x45F450, 0x000002, 0x544500, 0x050FC0, 0x45F454, 0x000002, 0x546500, 0x050FC7, 0x234E00, 0x204D03, 0x05A407, 0x56E200, 0x200054, 0x546200, 0x56E500, 0x200050, 0x546500, 0x56E200, 0x200054, 0x546200, 0x56E500, 0x45F450, 0x000002, 0x546558, 0x050F8B, 0x223500, 0x45E200, 0x06DC10, 0x000005, 0x56E500, 0x200060, 0x218500, 0x544D00, 0x23AE00, 0x223555, 0x05A409, 0x22B400, 0x06DC10, 0x000006, 0x44CD00, 0x06DD10, 0x000002, 0x445C00, 0x000000, 0x00000C, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x200045, 0x05A413, 0x209600, 0x60F400, 0x000180, 0x61F400, 0x000241, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x71E200, 0x06D910, 0x000005, 0x44D900, 0x56E000, 0x0C1E48, 0x545800, 0x050C10, 0x56F000, 0x000B7E, 0x200003, 0x05A40C, 0x60F400, 0x000235, 0x61F400, 0x0002F6, 0x390700, 0x06D910, 0x000005, 0x44D900, 0x56E000, 0x0C1E48, 0x545800, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x000011, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x567000, 0x000912, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x05085C, 0x0D1080, 0x000096, 0x56F000, 0x000B96, 0x200003, 0x057453, 0x0D1080, 0x0000C4, 0x56F000, 0x000B96, 0x200003, 0x05744D, 0x0D1080, 0x00016E, 0x0D1080, 0x0001B1, 0x0D1080, 0x0001F4, 0x240000, 0x447000, 0x00092B, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x200045, 0x05A409, 0x0D1080, 0x000146, 0x0D1080, 0x00021B, 0x557000, 0x00092B, 0x0D1080, 0x000303, 0x0D1080, 0x00031B, 0x0D1080, 0x00032A, 0x0D1080, 0x000385, 0x0D1080, 0x000341, 0x56F000, 0x000B41, 0x200003, 0x0D100A, 0x00042C, 0x0D1080, 0x00038E, 0x0D1080, 0x0003BB, 0x0D1080, 0x0003D6, 0x0D1080, 0xFFFF81, 0x200013, 0x21101B, 0x00000C, 0x205800, 0x44D800, 0x447000, 0x000B42, 0x44D800, 0x447000, 0x000B43, 0x44D800, 0x447000, 0x000B44, 0x57D800, 0x0C1890, 0x002024, 0x507000, 0x000B7B, 0x0C1890, 0x00101B, 0x507000, 0x000B7E, 0x0C1890, 0x003018, 0x507000, 0x000B7D, 0x44D800, 0x447000, 0x000B45, 0x44D800, 0x447000, 0x000B46, 0x44D800, 0x447000, 0x000B47, 0x57D800, 0x0C1890, 0x006020, 0x507000, 0x000B7C, 0x57D800, 0x0C1890, 0x001023, 0x507000, 0x00023D, 0x0C1890, 0x001022, 0x507000, 0x00023E, 0x0C1890, 0x001021, 0x507000, 0x00023F, 0x0C1890, 0x004018, 0x507000, 0x000240, 0x61D800, 0x380600, 0x204800, 0x57D900, 0x0C1890, 0x00201A, 0x507000, 0x000B4E, 0x57D900, 0x015F8E, 0x577000, 0x000B49, 0x57D800, 0x0C1890, 0x008018, 0x507000, 0x000B41, 0x0C1890, 0x008020, 0x507000, 0x000B40, 0x57D800, 0x0C1890, 0x001018, 0x507000, 0x000B4C, 0x0C1890, 0x001019, 0x507000, 0x000B4A, 0x57D800, 0x577000, 0x000B4B, 0x57E000, 0x577000, 0x000B4D, 0x00000C, 0x44F400, 0x000000, 0x447000, 0x000B96, 0x56F000, 0x000240, 0x44F400, 0x000009, 0x200045, 0x202741, 0x547000, 0x000240, 0x56F000, 0x000B49, 0x44F400, 0x00001F, 0x45F445, 0x000000, 0x202741, 0x200065, 0x202961, 0x547000, 0x000B49, 0x56F000, 0x000B7D, 0x44F400, 0x000007, 0x45F445, 0x000006, 0x05A414, 0x44F465, 0x000003, 0x05A411, 0x45F445, 0x000002, 0x05A40E, 0x44F465, 0x000004, 0x05A40B, 0x45F445, 0x000005, 0x05A408, 0x44F465, 0x000001, 0x05A405, 0x44F400, 0x000002, 0x447000, 0x000B96, 0x547000, 0x000B7D, 0x00000C, 0x56F000, 0x000912, 0x44F400, 0x020765, 0x200045, 0x052406, 0x56F000, 0x000B40, 0x200003, 0x05A45E, 0x00000C, 0x60F413, 0x0004FD, 0x060690, 0x000003, 0x545800, 0x545800, 0x60F413, 0x0005A8, 0x060590, 0x000002, 0x545800, 0x60F413, 0x00057B, 0x062890, 0x000002, 0x545800, 0x60F413, 0x0005AE, 0x065A90, 0x000002, 0x545800, 0x60F413, 0x000608, 0x060590, 0x000002, 0x545800, 0x60F413, 0x00060D, 0x060590, 0x000002, 0x545800, 0x60F413, 0x000509, 0x061090, 0x000002, 0x545800, 0x60F413, 0x000519, 0x060890, 0x000002, 0x545800, 0x60F413, 0x000521, 0x063C90, 0x000002, 0x545800, 0x60F413, 0x00055D, 0x061E90, 0x000002, 0x545800, 0x60F413, 0x000612, 0x060093, 0x000002, 0x545800, 0x44F400, 0x020765, 0x447000, 0x000912, 0x44F400, 0x000000, 0x447000, 0x000B96, 0x61F400, 0x000FC2, 0x71F000, 0x000B7D, 0x44F000, 0x000B7E, 0x5EE900, 0x547040, 0x000B97, 0x547000, 0x000B98, 0x44F01B, 0x000B97, 0x2D0513, 0x2C024D, 0x05945A, 0x44F01B, 0x000B98, 0x2D0613, 0x2C024D, 0x059455, 0x56F000, 0x000B7C, 0x200023, 0x547000, 0x000B99, 0x44F01B, 0x000B7B, 0x2D0313, 0x2C044D, 0x05944B, 0x44F01B, 0x000B99, 0x2D1313, 0x2C034D, 0x059446, 0x56F000, 0x000B7C, 0x0140C4, 0x000024, 0x21DA00, 0x44F000, 0x000B7B, 0x46F400, 0x000006, 0x2344D0, 0x0C1D2E, 0x44F440, 0x000F4C, 0x200040, 0x219100, 0x5EE100, 0x21CF22, 0x218422, 0x200022, 0x577040, 0x000B9A, 0x218500, 0x21E46C, 0x46F400, 0x000008, 0x21A7D0, 0x5070E8, 0x000B9D, 0x457000, 0x000B9B, 0x5170B0, 0x000B9E, 0x477000, 0x000B9C, 0x507000, 0x000B9F, 0x050C03, 0x547000, 0x000B96, 0x00000C, 0x56F400, 0x000914, 0x44F000, 0x000B41, 0x200040, 0x219100, 0x56E100, 0x0C1E01, 0x44F43E, 0x000001, 0x20004C, 0x20291B, 0x45F403, 0x000003, 0x02A068, 0x20006D, 0x027068, 0x56F400, 0x000B61, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x00000C, 0x44F000, 0x000B7D, 0x46F400, 0x000006, 0x44F0D0, 0x000B41, 0x0C1D2E, 0x44F440, 0x000F92, 0x200040, 0x219400, 0x56F000, 0x000B44, 0x4CE400, 0x200040, 0x219100, 0x05E120, 0x56F000, 0x000B42, 0x4CE400, 0x200040, 0x219100, 0x56F000, 0x000B43, 0x4CE400, 0x200040, 0x219200, 0x44F400, 0x000100, 0x46E200, 0x2000D0, 0x240022, 0x210600, 0x2400D0, 0x46E200, 0x2400D2, 0x0C1D2E, 0x44E140, 0x200040, 0x219000, 0x70E200, 0x64F400, 0x0002FD, 0x3C0100, 0x3EFF00, 0x45F400, 0x3FF7CF, 0x56F000, 0x00023F, 0x200003, 0x05A40F, 0x56F000, 0x000B41, 0x44F432, 0x0004FD, 0x200040, 0x219100, 0x47F400, 0x000347, 0x57D900, 0x51D100, 0x0D04E7, 0x555900, 0x516100, 0x050C02, 0x0D04F4, 0x05F420, 0x00FFFF, 0x00000C, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x200045, 0x05A44D, 0x56F000, 0x00023D, 0x200003, 0x05A45B, 0x60F400, 0x0002FD, 0x221400, 0x380100, 0x231C00, 0x44F000, 0x000B41, 0x46F400, 0x00000C, 0x44F4D0, 0x000521, 0x0C1D2E, 0x200040, 0x219100, 0x44F000, 0x000B41, 0x46F400, 0x000006, 0x44F4D0, 0x00055D, 0x0C1D2E, 0x200040, 0x219200, 0x56F000, 0x000240, 0x0140C4, 0x000007, 0x21DA00, 0x234400, 0x46F400, 0x00000F, 0x44F4D0, 0x000814, 0x0C1D2E, 0x200040, 0x219500, 0x3A0300, 0x3EFF00, 0x0D049E, 0x050C13, 0x56F000, 0x00023E, 0x200003, 0x05A40F, 0x60F400, 0x0002FD, 0x221400, 0x380100, 0x231C00, 0x61F400, 0x000509, 0x62F400, 0x000519, 0x65F400, 0x000800, 0x3A0400, 0x3EFF00, 0x0D04BF, 0x00000C, 0x44F000, 0x000B7D, 0x46F400, 0x000006, 0x44F0D0, 0x000B41, 0x0C1D2E, 0x44F440, 0x000F92, 0x200040, 0x219100, 0x4CE100, 0x447000, 0x000913, 0x61F400, 0x0002FD, 0x200013, 0x44D91B, 0x060091, 0x000004, 0x200047, 0x029040, 0x44D98A, 0x60F400, 0x0005A8, 0x70F000, 0x000B41, 0x200032, 0x44E826, 0x566847, 0x029040, 0x21C700, 0x56F400, 0x000914, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x476000, 0x0C1C91, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x00091A, 0x0C1D2E, 0x200040, 0x219000, 0x555800, 0x516000, 0x00000C, 0x60F400, 0x0002FD, 0x64F400, 0x0003FD, 0x380100, 0x231C00, 0x44F000, 0x000B41, 0x46F400, 0x000008, 0x44F4D0, 0x00057B, 0x0C1D2E, 0x200040, 0x219100, 0x65F400, 0x0008A2, 0x3A0200, 0x3EFF00, 0x0D049E, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380E00, 0x61F400, 0x0003FD, 0x204800, 0x060490, 0x000009, 0x200013, 0x064090, 0x000004, 0x44D900, 0x200047, 0x029040, 0x200026, 0x565800, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380800, 0x57F400, 0x000002, 0x204800, 0x380600, 0x060290, 0x00000B, 0x221100, 0x044812, 0x06CD10, 0x000006, 0x44DA00, 0x56DA00, 0x200045, 0x029040, 0x565900, 0x20402A, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x62F400, 0x0008AF, 0x390200, 0x45F41B, 0x000001, 0x20A600, 0x060390, 0x00000D, 0x221100, 0x4FDA00, 0x204900, 0x44D100, 0x06C610, 0x000004, 0x44C9C0, 0x44D145, 0x027068, 0x20CE00, 0x204832, 0x218600, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380200, 0x44F400, 0x003200, 0x56E800, 0x200045, 0x20291B, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x00091A, 0x0C1D2E, 0x200040, 0x219100, 0x56F400, 0x000608, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x44E100, 0x46F400, 0x7FFFFF, 0x44E0D0, 0x200045, 0x20291B, 0x56F400, 0x000926, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x62F400, 0x0008AC, 0x390200, 0x20A61B, 0x060390, 0x00000D, 0x221100, 0x4FDA00, 0x204900, 0x44D100, 0x06C610, 0x000004, 0x44C9C0, 0x44D145, 0x027068, 0x20CE00, 0x204832, 0x218600, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380200, 0x44F400, 0x003200, 0x56E800, 0x200045, 0x20291B, 0x44F000, 0x000B41, 0x46F400, 0x000002, 0x44F4D0, 0x00091A, 0x0C1D2E, 0x200040, 0x219100, 0x56F400, 0x000608, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x44E100, 0x46F400, 0x400000, 0x46E0D0, 0x446055, 0x20291B, 0x56F400, 0x000B7F, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x556000, 0x44F000, 0x000B41, 0x46F400, 0x000012, 0x44F4D0, 0x0005AE, 0x0C1D2E, 0x200040, 0x219000, 0x380600, 0x20AE00, 0x060390, 0x00000A, 0x221100, 0x219900, 0x221200, 0x204900, 0x44D900, 0x445A00, 0x44D900, 0x445A00, 0x204832, 0x00000C, 0x56F400, 0x000B7F, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x00060D, 0x44F000, 0x000B41, 0x200040, 0x219100, 0x56F400, 0x000B84, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x44E01B, 0x56E100, 0x45F442, 0x000001, 0x02A068, 0x576200, 0x446100, 0x00000C, 0x60F400, 0x0002FD, 0x44F000, 0x000B41, 0x46F400, 0x000080, 0x44F4D0, 0x000612, 0x0C1D2E, 0x200040, 0x219100, 0x64F400, 0x0008B2, 0x65F400, 0x000000, 0x0D04FC, 0x00000C, 0x56F000, 0x00092B, 0x200003, 0x05A40E, 0x60F400, 0x000000, 0x61F400, 0x000040, 0x221400, 0x223500, 0x62F400, 0x000AB2, 0x66F400, 0x000AF2, 0x3A3F00, 0x0D054D, 0x050C0A, 0x60F400, 0x000000, 0x221400, 0x62F400, 0x0009B2, 0x66F400, 0x000A32, 0x3A7F00, 0x0D053E, 0x00000C, 0x0500A0, 0x0461A0, 0x56F000, 0x00092B, 0x200003, 0x05A415, 0x60F400, 0x000000, 0x61F400, 0x000040, 0x64F400, 0x0003FD, 0x65F400, 0x0004FC, 0x62F400, 0x000AB2, 0x66F400, 0x000AF2, 0x382000, 0x231900, 0x3A3F00, 0x3C0300, 0x75F400, 0xFFFFFD, 0x0D0573, 0x050C11, 0x60F400, 0x000000, 0x64F400, 0x0003FD, 0x65F400, 0x0004FC, 0x62F400, 0x0009B2, 0x66F400, 0x000A32, 0x384000, 0x3A7F00, 0x3C0200, 0x75F400, 0xFFFFFE, 0x0D0564, 0x05F420, 0x00FFFF, 0x0461A0, 0x56F000, 0x000B41, 0x44F000, 0x000B97, 0x60F445, 0x0003FD, 0x05A408, 0x61F400, 0x000180, 0x06B590, 0x000003, 0x44D800, 0x445900, 0x050C07, 0x61F400, 0x000235, 0x060790, 0x000003, 0x44D800, 0x445900, 0x00000C, 0x56F000, 0x00092B, 0x200003, 0x05A40A, 0x60F400, 0x000000, 0x384000, 0x0D03EF, 0x60F400, 0x000040, 0x384000, 0x0D03EF, 0x050C05, 0x60F400, 0x000000, 0x388000, 0x0D03EF, 0x00000C, 0x56F000, 0x000B97, 0x44F000, 0x000B41, 0x45F445, 0x000001, 0x05A403, 0x05080D, 0x050C03, 0x457000, 0x000B8F, 0x60F400, 0x000B7F, 0x61F400, 0x0005A3, 0x060590, 0x000003, 0x44D800, 0x445900, 0x00000C, 0x290300, 0x70F000, 0x000B41, 0x60F400, 0x000B7F, 0x56E800, 0x014185, 0x05A410, 0x60F400, 0x000926, 0x56E800, 0x014185, 0x05A40B, 0x56F000, 0x000B40, 0x014085, 0x05A406, 0x60F400, 0x0005A3, 0x56E800, 0x014185, 0x05A402, 0x290200, 0x60F400, 0x000B8A, 0x516800, 0x00000C, 0x3D1800, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x60F445, 0x000180, 0x05A40C, 0x209600, 0x61F400, 0x000241, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x71E200, 0x0D058B, 0x050C0A, 0x56F000, 0x000B7E, 0x60F403, 0x000235, 0x05A405, 0x61F400, 0x0002F6, 0x390700, 0x0D058B, 0x00000C, 0x44F000, 0x000B41, 0x56F000, 0x000B97, 0x61F445, 0x000241, 0x05A459, 0x56F400, 0x000B8A, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x000BA5, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x56E000, 0x71E200, 0x219400, 0x223600, 0x56F400, 0x000B5C, 0x44F000, 0x000B41, 0x200040, 0x219000, 0x56F400, 0x000B91, 0x44F000, 0x000B41, 0x200040, 0x219200, 0x232E00, 0x014184, 0x0B74C4, 0x000F16, 0x218500, 0x47F4AD, 0x000001, 0x0B74C4, 0x000F12, 0x21E600, 0x209DD0, 0x0C1D2E, 0x46F465, 0x2AAAAB, 0x202978, 0x556000, 0x21A500, 0x21BCE9, 0x0C1D82, 0x200010, 0x200065, 0x202978, 0x556200, 0x223200, 0x205900, 0x3A0000, 0x0D0596, 0x050C11, 0x56F000, 0x000B7E, 0x60F403, 0x000B8F, 0x05A40C, 0x61F400, 0x0002F6, 0x390700, 0x223600, 0x223200, 0x205900, 0x3A0000, 0x3C0600, 0x7DF000, 0x000F13, 0x0D0596, 0x00000C, 0x56F000, 0x000240, 0x0C1D04, 0x21C700, 0x46F400, 0x000003, 0x2000B0, 0x0C1D2E, 0x0140C0, 0x000049, 0x21C600, 0x61F400, 0x000BA0, 0x62F400, 0x000BA5, 0x45F000, 0x000B97, 0x06C510, 0x000003, 0x475900, 0x465A00, 0x57F400, 0x000001, 0x56F000, 0x000B40, 0x200003, 0x05A402, 0x20001B, 0x577000, 0x000B90, 0x00000C, 0x56F400, 0x00000F, 0x57F400, 0x000000, 0x70F400, 0x000416, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x00000F, 0x57F400, 0x000001, 0x60F400, 0x0004FD, 0x70F400, 0x000416, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x00000F, 0x57F400, 0x000002, 0x60F400, 0x0004FD, 0x70F400, 0x000416, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000016, 0x57F400, 0x000001, 0x390000, 0x70F400, 0x000080, 0x60F400, 0x000B40, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000012, 0x57F400, 0x000000, 0x70F400, 0x000390, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F400, 0x000013, 0x57F400, 0x000000, 0x70F400, 0x000390, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x447000, 0x000963, 0x56F000, 0x000B97, 0x200045, 0x052407, 0x71F400, 0x000389, 0x380700, 0x60F400, 0x000235, 0x050C07, 0x46F400, 0x0000B5, 0x20D8D0, 0x60F422, 0x000180, 0x211900, 0x56F400, 0x000012, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x44F000, 0x000963, 0x56F000, 0x000B97, 0x200045, 0x052407, 0x71F400, 0x000389, 0x380700, 0x60F400, 0x0002F6, 0x050C07, 0x46F400, 0x0000B5, 0x20D8D0, 0x60F422, 0x000241, 0x211900, 0x56F400, 0x000013, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\AC3Dolby1.h ===
0xD01B40, 0x0002B3, 0x010160, 0xB9C253, 0x050C40, 0x040C37, 0x048AA7, 0x051884, 0x05B7B1, 0x066A4A, 0x0732AE, 0x081385, 0x090FCC, 0x0A2ADB, 0x0B6873, 0x0CCCCD, 0x0E5CA1, 0x101D3F, 0x12149A, 0x144961, 0x16C311, 0x198A13, 0x1CA7D7, 0x2026F3, 0x241347, 0x287A27, 0x2D6A86, 0x32F52D, 0x392CEE, 0x4026E7, 0x47FACD, 0x50C336, 0x5A9DF8, 0x65AC8C, 0x721483, 0x7FFFFF, 0x607000, 0x00062E, 0x20000B, 0x05A406, 0x44F400, 0x008002, 0x447000, 0x000604, 0x050C05, 0x44F400, 0x000002, 0x447000, 0x000604, 0x44F400, 0x00000A, 0x447000, 0x000600, 0x44F400, 0x00060A, 0x447000, 0x000601, 0x44F400, 0x000610, 0x447000, 0x000602, 0x44F400, 0x000616, 0x447000, 0x000603, 0x44F400, 0x00061C, 0x447000, 0x000605, 0x44F400, 0x000622, 0x447000, 0x000606, 0x44F400, 0x000628, 0x447000, 0x000607, 0x44F400, 0x000000, 0x447000, 0x000608, 0x44F400, 0x000100, 0x447000, 0x000609, 0x60F400, 0x00060A, 0x44F400, 0x000000, 0x445800, 0x44F400, 0x000100, 0x445800, 0x44F400, 0x000200, 0x445800, 0x44F400, 0x000300, 0x445800, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x446000, 0x60F400, 0x000610, 0x44F400, 0x000001, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x240000, 0x446000, 0x60F400, 0x000616, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x446000, 0x60F400, 0x00061C, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0x000500, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x60F400, 0x000622, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x60F400, 0x000628, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x62F013, 0x00062E, 0x021ADC, 0x44F400, 0x000001, 0x200045, 0x202941, 0x44F400, 0x00001F, 0x200045, 0x202741, 0x219800, 0x60F400, 0x000305, 0x07E885, 0x050818, 0x60F413, 0x000600, 0x57F400, 0x000016, 0x0D1080, 0x00001C, 0x56F400, 0x000008, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x00000C, 0x60F400, 0x000000, 0x068092, 0x000005, 0x44D800, 0x46D0A1, 0x5658E9, 0x575800, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000016, 0x20004D, 0x0D104A, 0x000008, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x0D1080, 0x0000B8, 0x56F000, 0x000632, 0x200003, 0x05A406, 0x0D1080, 0x000150, 0x0D1080, 0x00012F, 0x050C03, 0x0D1080, 0x000153, 0x0D1080, 0x000130, 0x56F000, 0x000633, 0x014085, 0x05A417, 0x66F000, 0x00062F, 0x3E0300, 0x60EE00, 0x3E0400, 0x61EE00, 0x66F000, 0x000630, 0x3E0300, 0x70EE00, 0x3E0400, 0x71EE00, 0x46F400, 0x5A827A, 0x62F000, 0x000638, 0x06D210, 0x000005, 0x44E000, 0x44C9D0, 0x2000D3, 0x564800, 0x66F000, 0x00062F, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x3E0100, 0x62EE00, 0x66F000, 0x000634, 0x3E0000, 0x64EE00, 0x3E0200, 0x65EE00, 0x66F000, 0x000630, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x3E0100, 0x72EE00, 0x66F000, 0x000635, 0x3E0000, 0x74EE00, 0x76F400, 0x000002, 0x75EE00, 0x45F400, 0x5A827A, 0x66F000, 0x000638, 0x06D600, 0x000467, 0x44CA00, 0x56C800, 0x57C9A3, 0x564CAB, 0x574D00, 0x61F400, 0x000639, 0x65F000, 0x000687, 0x62F400, 0x00066D, 0x66F000, 0x000634, 0x3E0000, 0x60EE00, 0x221400, 0x66F000, 0x000635, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x00058B, 0x61F400, 0x000649, 0x65F000, 0x000687, 0x62F400, 0x000675, 0x66F000, 0x000634, 0x3E0200, 0x60EE00, 0x221400, 0x66F000, 0x000635, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x00058B, 0x61F400, 0x000659, 0x65F000, 0x000688, 0x62F400, 0x00067D, 0x66F000, 0x00062F, 0x3E0300, 0x60EE00, 0x221400, 0x66F000, 0x000630, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000005, 0x0BF080, 0x00058B, 0x66F000, 0x000634, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x66F000, 0x00062F, 0x3E0300, 0x62EE00, 0x66F000, 0x000635, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x66F000, 0x000630, 0x3E0300, 0x72EE00, 0x45F400, 0x5A827A, 0x64F000, 0x000638, 0x06D400, 0x0004CB, 0x44CA00, 0x56E000, 0x57E1A3, 0x5648AF, 0x574900, 0x0D1080, 0x0000B4, 0x00000C, 0x205800, 0x44D800, 0x447000, 0x00062F, 0x44D800, 0x447000, 0x000630, 0x44D800, 0x447000, 0x000631, 0x57D800, 0x0C1890, 0x001027, 0x507000, 0x000632, 0x0C1890, 0x001019, 0x507000, 0x000633, 0x44D800, 0x447000, 0x000634, 0x44D800, 0x447000, 0x000635, 0x44D800, 0x447000, 0x000636, 0x57D800, 0x0C1890, 0x002024, 0x507000, 0x000637, 0x44D800, 0x447000, 0x000638, 0x00000C, 0xC0958D, 0x000000, 0x7ED4E5, 0xC00000, 0x000000, 0x4FE24A, 0x3F67CC, 0x3F67CC, 0x4FE24A, 0x7FFFFF, 0x855BE8, 0x756638, 0x756638, 0x855BE8, 0x7FFFFF, 0xEA1F92, 0xE2404B, 0xE2404B, 0xEA1F92, 0x7FFFFF, 0x812B1B, 0x7DAC85, 0x7ED594, 0x812A6C, 0x7ED594, 0x4FE24A, 0x3F67CC, 0x579426, 0x55FF7F, 0x579426, 0x4FE24A, 0x3F67CC, 0x579426, 0x55FF7F, 0x579426, 0x823E22, 0x7B876D, 0x7B876D, 0x823E22, 0x7FFFFF, 0xB23B5E, 0x27F74F, 0x27F74F, 0xB23B5E, 0x7FFFFF, 0xC08974, 0x000000, 0x7EED19, 0xC00000, 0x000000, 0x462AF8, 0x378620, 0x378620, 0x462AF8, 0x7FFFFF, 0x84EF9E, 0x763A35, 0x763A35, 0x84EF9E, 0x7FFFFF, 0xE648FE, 0xE4B78A, 0xE4B78A, 0xE648FE, 0x7FFFFF, 0x8112E7, 0x7DDC7F, 0x7EEDAC, 0x811254, 0x7EEDAC, 0x462AF8, 0x378620, 0x511DF3, 0x4EF590, 0x511DF3, 0x462AF8, 0x378620, 0x511DF3, 0x4EF590, 0x511DF3, 0x82101A, 0x7BE2ED, 0x7BE2ED, 0x82101A, 0x7FFFFF, 0xAF2EFC, 0x2C7800, 0x2C7800, 0xAF2EFC, 0x7FFFFF, 0x61F413, 0x000639, 0x064E90, 0x000002, 0x565900, 0x00000C, 0x60F400, 0x0004F4, 0x61F400, 0x000000, 0x065A90, 0x000003, 0x07D884, 0x4C5900, 0x56F000, 0x000637, 0x240000, 0x60F400, 0x00002D, 0x61F445, 0x000041, 0x05A405, 0x60F400, 0x000000, 0x61F400, 0x000014, 0x607000, 0x000687, 0x617000, 0x000688, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000000, 0x384E00, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000001, 0x60F400, 0x000639, 0x384E00, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000002, 0x60F400, 0x000639, 0x384E00, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x000021, 0x57DA00, 0x51D200, 0xF0B900, 0x06DE10, 0x00000B, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D2, 0x200010, 0x10DD09, 0x444C4C, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D2, 0x200010, 0x21C409, 0x444C4C, 0x03F184, 0x555A00, 0x515A00, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\AC3Dolby5.h ===
0xD01B40, 0x00007D, 0x050150, 0x3F2E8D, 0x607000, 0x000700, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x44F400, 0x400000, 0x4C7000, 0x000000, 0x44F400, 0x5A8279, 0x4C7000, 0x000001, 0x44F400, 0x400000, 0x4C7000, 0x000002, 0x44F400, 0x2D413C, 0x4C7000, 0x000003, 0x44F400, 0x2D413C, 0x4C7000, 0x000004, 0x62F000, 0x000700, 0x000000, 0x000000, 0x0242D5, 0x02429E, 0x200003, 0x05A40B, 0x60F400, 0x000000, 0x380100, 0x4EF000, 0x000000, 0x060590, 0x000004, 0x2000E1, 0x4EE800, 0x5E5800, 0x62F400, 0x000500, 0x66F400, 0x000600, 0x70F400, 0x000100, 0x60F400, 0x000000, 0x64F400, 0x000000, 0x221500, 0x060091, 0x00000C, 0xF08800, 0xF088D0, 0xF088D2, 0xF088D2, 0xC080D2, 0x4EDDD3, 0x22B000, 0x64F400, 0x000000, 0x565A00, 0x565E00, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000600, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\AC3Dolby3.h ===
0xD01B40, 0x000652, 0x030150, 0x8C0B75, 0x20000B, 0x0D1002, 0x00064B, 0x0D1080, 0x00063B, 0x57F400, 0x000010, 0x300000, 0x0D1080, 0x000233, 0x44F400, 0x000000, 0x200045, 0x057400, 0x0D1080, 0x00063F, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x06D910, 0x00000A, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x61F400, 0x000D12, 0x46F400, 0x0000FF, 0x06D810, 0x00000E, 0x0C1C90, 0x200056, 0x51D800, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1C90, 0x200056, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x61F41B, 0x000E12, 0x46F400, 0x0000FF, 0x204800, 0x06D810, 0x00000D, 0x21AE5E, 0x44F800, 0x21B900, 0x0C1ED0, 0x200042, 0x4CE900, 0x200043, 0x218F56, 0x219900, 0x0C1ED1, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x000418, 0x000418, 0x000418, 0x00042A, 0x00042A, 0x00042A, 0x000425, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x000442, 0x00044E, 0x00044E, 0x00044E, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x00045F, 0x22B100, 0x231900, 0x204800, 0x204900, 0x45F41B, 0x000040, 0x51F400, 0x000C00, 0x44D801, 0x06DC10, 0x000003, 0x44D8A6, 0x505901, 0x240000, 0x447000, 0x000492, 0x240000, 0x447000, 0x000491, 0x231000, 0x22B800, 0x74F400, 0x0003A5, 0x65F400, 0x000B32, 0x44F000, 0x000B7B, 0x46F400, 0x000032, 0x2244D0, 0x0C1D2E, 0x44F440, 0x000C1C, 0x200040, 0x219600, 0x390100, 0x0B72CE, 0x000F1A, 0x23C400, 0x220745, 0x027040, 0x232474, 0x57E844, 0x205800, 0x45E800, 0x05A40D, 0x47F400, 0x0000D1, 0x06CC10, 0x000009, 0x21EE6C, 0x029060, 0x20582E, 0x45E82B, 0x21BD7D, 0x4CED00, 0x202F40, 0x21CF00, 0x225400, 0x44F461, 0x000100, 0x07EC94, 0x47F044, 0x000491, 0x0AE480, 0x57700D, 0x000493, 0x05F408, 0x20EE6D, 0x05F458, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C53, 0x47F400, 0x000180, 0x050C50, 0x218600, 0x23CE00, 0x014785, 0x05A40D, 0x20CE00, 0x20000D, 0x05F408, 0x20EE6D, 0x05F408, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C03, 0x47F400, 0x000180, 0x44F000, 0x000493, 0x56F04D, 0x000492, 0x557000, 0x000493, 0x059404, 0x232E00, 0x717000, 0x000492, 0x200003, 0x05A414, 0x050C1E, 0x20000D, 0x05F408, 0x20EE6D, 0x05F41A, 0x0140C4, 0x000040, 0x202913, 0x218700, 0x050C15, 0x47F400, 0x000140, 0x050C12, 0x200071, 0x0140C4, 0x000080, 0x202913, 0x218700, 0x050C0C, 0x44F001, 0x00048F, 0x44F044, 0x00048E, 0x547001, 0x00048B, 0x477044, 0x000491, 0x547074, 0x00048A, 0x050C1B, 0x56F000, 0x00048B, 0x44F000, 0x00048D, 0x44F044, 0x00048F, 0x218601, 0x45F044, 0x00048A, 0x44F055, 0x00048C, 0x029050, 0x547061, 0x00048B, 0x44F044, 0x00048E, 0x218601, 0x477044, 0x000491, 0x44F055, 0x00048B, 0x029050, 0x547074, 0x00048A, 0x200045, 0x029040, 0x44F000, 0x000490, 0x4EDE4C, 0x0C1C85, 0x202914, 0x200055, 0x029050, 0x546A00, 0x220E00, 0x23C400, 0x205A45, 0x0596D7, 0x00000C, 0x56F000, 0x0004B7, 0x44F003, 0x0004A2, 0x05A407, 0x20EE00, 0x240064, 0x06CC10, 0x000002, 0x445900, 0x050C4D, 0x64F400, 0x000CBA, 0x66F400, 0x0004A5, 0x57DA00, 0x46F04C, 0x0004BF, 0x20005C, 0x20291B, 0x0140CE, 0x001FE0, 0x5EDD58, 0x200075, 0x027070, 0x21C564, 0x014184, 0x219E00, 0x56D800, 0x46F414, 0x00003F, 0x202913, 0x0C1ECA, 0x200055, 0x027050, 0x219C00, 0x06DE10, 0x00000B, 0x56D800, 0x7EEC14, 0x202913, 0x0C1ECA, 0x765955, 0x027050, 0x219C00, 0x56EE00, 0x014180, 0x546E00, 0x7EEC00, 0x765900, 0x56EE00, 0x014180, 0x546E71, 0x200065, 0x057799, 0x00000C, 0x60F400, 0x000B68, 0x70F000, 0x000B40, 0x57E800, 0x44F000, 0x000B7A, 0x20004C, 0x20000B, 0x05140C, 0x200013, 0x567000, 0x000B66, 0x567000, 0x000B67, 0x567000, 0x0004A4, 0x567000, 0x000B6E, 0x0D10C0, 0x000027, 0x200013, 0x21D800, 0x44F000, 0x000B70, 0x200045, 0x059404, 0x56F400, 0x000009, 0x21D800, 0x200005, 0x05F409, 0x200013, 0x567000, 0x000B66, 0x567000, 0x000B67, 0x567000, 0x0004A4, 0x050C13, 0x56F400, 0x000001, 0x567000, 0x000B66, 0x21EE00, 0x230400, 0x200044, 0x0C1C06, 0x280000, 0x567000, 0x000B67, 0x0C1D06, 0x230400, 0x200040, 0x567000, 0x0004A4, 0x21C400, 0x20004C, 0x56F000, 0x000B40, 0x44F400, 0x000005, 0x200045, 0x052413, 0x56F000, 0x000B9F, 0x44F000, 0x000B7A, 0x200044, 0x44F000, 0x000B53, 0x200044, 0x21D900, 0x577000, 0x000B6E, 0x200003, 0x059404, 0x200005, 0x05F402, 0x050C03, 0x232400, 0x208F00, 0x56F000, 0x000B70, 0x200003, 0x05F40A, 0x44F400, 0x000001, 0x447000, 0x000B66, 0x44F000, 0x000B67, 0x200040, 0x567000, 0x000B67, 0x00000C, 0x221100, 0x22B200, 0x46F469, 0x000002, 0x06D810, 0x000005, 0x56C900, 0x218F14, 0x200050, 0x545A00, 0x234E00, 0x234432, 0x230440, 0x240044, 0x05A404, 0x06CC10, 0x000002, 0x445A00, 0x22B000, 0x229100, 0x65F400, 0x000D0D, 0x75F400, 0xFFFFFE, 0x06DA10, 0x000007, 0xF0B800, 0xF0B8D0, 0xD0B8D2, 0x2000D2, 0x200022, 0x585900, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x00000F, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x05741E, 0x56F000, 0x000B40, 0x2E0003, 0x052402, 0x014180, 0x567000, 0x000B89, 0x0D1080, 0x00038B, 0x44F400, 0x0007B0, 0x447000, 0x000B72, 0x0D1080, 0x000014, 0x56F000, 0x000B40, 0x2E0003, 0x052403, 0x0D1080, 0x000353, 0x0D1080, 0x00009D, 0x56F000, 0x000B96, 0x200003, 0x052403, 0x0D1080, 0x00019C, 0x200013, 0x21101B, 0x00000C, 0x00000C, 0x44F400, 0x000001, 0x447000, 0x000B6F, 0x56F01B, 0x000B40, 0x200003, 0x052402, 0x000009, 0x517000, 0x0004C0, 0x300200, 0x310100, 0x320100, 0x350200, 0x0B70C4, 0x000C08, 0x447000, 0x00048D, 0x0B71C4, 0x000C04, 0x447000, 0x00048C, 0x0B72C4, 0x000C14, 0x447000, 0x00048F, 0x0B75C4, 0x000C18, 0x447000, 0x000490, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00004E, 0x280100, 0x507000, 0x0004C0, 0x300400, 0x0B70C4, 0x000C0C, 0x447000, 0x00048E, 0x44F400, 0xFF8000, 0x447000, 0x00048A, 0x44F400, 0xFF8000, 0x447000, 0x00048B, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219500, 0x22C400, 0x46F400, 0x000032, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219A00, 0x380000, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219100, 0x74E100, 0x76E100, 0x320000, 0x667000, 0x000B41, 0x0D03D7, 0x66F000, 0x000B41, 0x56F400, 0x0004C1, 0x22C400, 0x200040, 0x219000, 0x626000, 0x56F400, 0x000494, 0x22C400, 0x200040, 0x219000, 0x44F000, 0x00048A, 0x446000, 0x56F400, 0x000499, 0x22C400, 0x200040, 0x219000, 0x44F000, 0x00048B, 0x446000, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A41C, 0x280100, 0x507000, 0x0004C0, 0x300400, 0x0B70C4, 0x000C0C, 0x447000, 0x00048E, 0x44F400, 0xFF8000, 0x447000, 0x00048A, 0x44F400, 0xFF8000, 0x447000, 0x00048B, 0x60F400, 0x000483, 0x65F400, 0x000483, 0x72F400, 0x0004B8, 0x380000, 0x3C0700, 0x3E0700, 0x320000, 0x0D03D7, 0x00000C, 0x56F000, 0x000B40, 0x200003, 0x052404, 0x240000, 0x447000, 0x000B6E, 0x340000, 0x20001B, 0x44F000, 0x000B97, 0x06C410, 0x000003, 0x014188, 0x014188, 0x014188, 0x56F000, 0x000B7D, 0x200003, 0x052402, 0x014188, 0x56F000, 0x000B4A, 0x44F403, 0x000008, 0x05A402, 0x200048, 0x014188, 0x56F000, 0x000B89, 0x200003, 0x05A402, 0x014188, 0x56F000, 0x000B7D, 0x014285, 0x052407, 0x014188, 0x56F000, 0x000B40, 0x44F403, 0x000004, 0x202A48, 0x44F000, 0x000B97, 0x06C410, 0x000002, 0x014288, 0x56F000, 0x000B7E, 0x200003, 0x05A402, 0x014188, 0x56F400, 0x000B8A, 0x240000, 0x200040, 0x219000, 0x44F000, 0x000B97, 0x06C410, 0x000006, 0x56D800, 0x200003, 0x05A402, 0x014688, 0x000000, 0x60F400, 0x000B8A, 0x61F400, 0x000B91, 0x46F400, 0x000007, 0x44F000, 0x000B97, 0x06C410, 0x00000A, 0x56D800, 0x44D903, 0x05A406, 0x014488, 0x2000D0, 0x0C1D2E, 0x200018, 0x014288, 0x000000, 0x56F000, 0x000B7E, 0x200003, 0x05A408, 0x56F000, 0x000B8F, 0x44F403, 0x00000E, 0x05A403, 0x014488, 0x200048, 0x014188, 0x56F000, 0x000B90, 0x200003, 0x05A406, 0x014288, 0x014288, 0x014288, 0x014288, 0x014388, 0x014188, 0x56F000, 0x000B6F, 0x200003, 0x05A40E, 0x014688, 0x44F000, 0x000B97, 0x06C410, 0x000003, 0x014488, 0x014388, 0x56F000, 0x000B7E, 0x200003, 0x05A403, 0x014488, 0x014388, 0x014188, 0x014188, 0x21E71B, 0x56F000, 0x000B40, 0x0140C5, 0x000003, 0x0D1042, 0x00000D, 0x21E779, 0x014988, 0x21E779, 0x014188, 0x014188, 0x56F000, 0x000B40, 0x0140C5, 0x000003, 0x052402, 0x016F88, 0x014788, 0x0C1EC7, 0x557000, 0x000B70, 0x0C1E87, 0x21E479, 0x200048, 0x557000, 0x000B71, 0x56F000, 0x000B40, 0x200003, 0x052407, 0x20001B, 0x014188, 0x014188, 0x015088, 0x557000, 0x000B53, 0x56F000, 0x000B40, 0x200003, 0x05248C, 0x57F000, 0x000B51, 0x44F000, 0x000B53, 0x200048, 0x44F000, 0x000B9A, 0x46F400, 0x000008, 0x2000D0, 0x210E00, 0x200014, 0x547000, 0x000B52, 0x56F000, 0x000B53, 0x44F000, 0x000B9F, 0x200045, 0x057485, 0x44F41B, 0x155555, 0x56F000, 0x000B52, 0x0140C4, 0x00002F, 0x218500, 0x2000A8, 0x21AF00, 0x44F000, 0x000B71, 0x20004D, 0x05F458, 0x21A500, 0x44F400, 0x000006, 0x2000A0, 0x0C1D2E, 0x44F036, 0x000B52, 0x200040, 0x0140C4, 0x00002F, 0x21C700, 0x0140C8, 0x000001, 0x56F400, 0x000B68, 0x240000, 0x200040, 0x219000, 0x20F800, 0x06D810, 0x000002, 0x575800, 0x0140CC, 0x000001, 0x56F400, 0x000006, 0x200074, 0x200003, 0x05F405, 0x21D800, 0x06D810, 0x000002, 0x575800, 0x56F400, 0x000B68, 0x44F400, 0x000003, 0x200040, 0x219000, 0x56E000, 0x016F80, 0x566000, 0x56F400, 0x000B68, 0x240000, 0x200040, 0x219000, 0x70F000, 0x000B40, 0x56E800, 0x44F000, 0x000B71, 0x200044, 0x566800, 0x00000C, 0x44F400, 0x000001, 0x447000, 0x000B96, 0x00000C, 0x0D1080, 0x000023, 0x200003, 0x05A41B, 0x0D1080, 0xFFFDA2, 0x56F400, 0x000005, 0x44F000, 0x000B40, 0x200045, 0x05F417, 0x56F400, 0x000B68, 0x44F000, 0x000B40, 0x200040, 0x0140C0, 0x000001, 0x21D000, 0x56D000, 0x44D800, 0x200040, 0x44F000, 0x000B7A, 0x45F044, 0x0004A4, 0x200064, 0x566000, 0x050C05, 0x0D1080, 0x000158, 0x0D1080, 0xFFFD86, 0x00000C, 0x45F400, 0xFFFF90, 0x457000, 0x00049F, 0x0D1080, 0x00007C, 0x44F400, 0x000008, 0x447000, 0x00049E, 0x240000, 0x447000, 0x0004B5, 0x50F000, 0x00049E, 0x00000A, 0x507000, 0x00049E, 0x0D1080, 0x000087, 0x20000B, 0x059409, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x44F000, 0x00049F, 0x447000, 0x0004B6, 0x56F000, 0x0004B5, 0x200003, 0x05A40F, 0x56F400, 0x000010, 0x21C400, 0x567000, 0x0004A0, 0x56F000, 0x00049F, 0x567000, 0x0004A1, 0x200040, 0x200022, 0x567000, 0x00049F, 0x050C0E, 0x56F400, 0xFFFF10, 0x21C400, 0x567000, 0x0004A1, 0x56F000, 0x00049F, 0x567000, 0x0004A0, 0x200040, 0x200022, 0x567000, 0x00049F, 0x0D1080, 0x000043, 0x0D1080, 0x00005A, 0x20000B, 0x05940E, 0x44F000, 0x00049F, 0x447000, 0x0004A1, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x44F000, 0x00049F, 0x447000, 0x0004B6, 0x050C05, 0x44F000, 0x00049F, 0x447000, 0x0004A0, 0x56F000, 0x0004A0, 0x44F000, 0x0004A1, 0x21C644, 0x0140C5, 0x000001, 0x052408, 0x0D1080, 0x000128, 0x44F400, 0x000001, 0x447000, 0x0004B5, 0x050C1B, 0x200051, 0x200040, 0x200022, 0x200045, 0x057404, 0x208E00, 0x014180, 0x050C05, 0x200055, 0x059403, 0x20CE00, 0x014184, 0x547000, 0x00049F, 0x56F000, 0x00049E, 0x014184, 0x547000, 0x00049E, 0x057787, 0x56F000, 0x0004B5, 0x014185, 0x052403, 0x0D1080, 0x000109, 0x56F000, 0x0004B5, 0x00000C, 0x56F000, 0x00049F, 0x0140C0, 0x0000F0, 0x0C1C08, 0x218400, 0x2C0000, 0x0C1D08, 0x218600, 0x60F400, 0x000B73, 0x62F400, 0x000B79, 0x64F400, 0x000B74, 0x3C0500, 0x70F000, 0x000B97, 0x229500, 0x445800, 0x465A00, 0x06D810, 0x000002, 0x465D00, 0x00000C, 0x70F000, 0x000B40, 0x60F400, 0x000B68, 0x57E800, 0x21FA00, 0x56F000, 0x0004C0, 0x200003, 0x05A545, 0x56F400, 0x000001, 0x567000, 0x0004B7, 0x56F400, 0x000000, 0x44F000, 0x000B73, 0x200045, 0x05A404, 0x240000, 0x447000, 0x0004B7, 0x46F400, 0x000000, 0x60F400, 0x000B74, 0x44F000, 0x000B97, 0x06C410, 0x000008, 0x56D800, 0x200055, 0x05A404, 0x200013, 0x567000, 0x0004B7, 0x000000, 0x56F000, 0x000B7E, 0x200003, 0x05A408, 0x56F000, 0x000B79, 0x200055, 0x05A404, 0x200013, 0x567000, 0x0004B7, 0x300700, 0x0B70C4, 0x000CB2, 0x447000, 0x0004BF, 0x60F413, 0x0004A5, 0x061090, 0x000002, 0x565800, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000036, 0x56F400, 0x000B74, 0x22C400, 0x200040, 0x219000, 0x56F000, 0x000B73, 0x44E000, 0x014F84, 0x0C1D08, 0x200040, 0x0C1D04, 0x547000, 0x0004A2, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x250000, 0x47E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219100, 0x22C400, 0x46F400, 0x000032, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219200, 0x65F400, 0x000F1A, 0x667000, 0x000B41, 0x0D0486, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A417, 0x56F000, 0x000B73, 0x44F000, 0x000B79, 0x014F84, 0x0C1D08, 0x200040, 0x0C1D04, 0x547000, 0x0004A2, 0x250000, 0x47F400, 0x000007, 0x60F400, 0x000483, 0x61F400, 0x000B39, 0x62F400, 0x0004B8, 0x65F400, 0x000F1A, 0x0D0486, 0x60F400, 0x0004A6, 0x66F41B, 0x000CFB, 0x44D800, 0x47F413, 0xD55555, 0x20E800, 0x4EDEC6, 0x218413, 0x44D8DA, 0x20E800, 0x4EDEC6, 0x218400, 0xF0D8DA, 0x44D8DA, 0x47F413, 0xC00000, 0x20E800, 0x4EDEC6, 0x218400, 0x2000DA, 0xF0D800, 0x060A90, 0x000002, 0xF0D8DA, 0x2000DA, 0x0C1DAE, 0x567000, 0x000B7A, 0x050C02, 0x050C00, 0x44F01B, 0x000B7A, 0x234F00, 0x20004C, 0x21FA00, 0x20000B, 0x051402, 0x050C03, 0x0D1080, 0xFFFC33, 0x00000C, 0x60F41B, 0x000B7A, 0x576000, 0x60F400, 0x000B73, 0x62F400, 0x000B79, 0x64F400, 0x000B74, 0x70F000, 0x000B97, 0x229500, 0x576000, 0x576200, 0x06D810, 0x000002, 0x575D00, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000012, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219000, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219200, 0x066210, 0x000002, 0x575800, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A406, 0x60F400, 0x000B39, 0x060790, 0x000002, 0x575800, 0x00000C, 0x44F000, 0x0004B6, 0x447000, 0x00049F, 0x0D1080, 0xFFFEF8, 0x050A0F, 0x00000C, 0x20001B, 0x015088, 0x015088, 0x014288, 0x014688, 0x014588, 0x014388, 0x014388, 0x56F000, 0x000B7D, 0x014185, 0x05A404, 0x014186, 0x05A402, 0x014288, 0x56F000, 0x000B7D, 0x014486, 0x05A402, 0x014288, 0x56F000, 0x000B7D, 0x014285, 0x052402, 0x014288, 0x014188, 0x014588, 0x014188, 0x56F000, 0x000B4C, 0x44F403, 0x000008, 0x05A402, 0x200048, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x014188, 0x577000, 0x000B51, 0x00000C, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000034, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219000, 0x56E000, 0x219203, 0x05A44B, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0000FA, 0x0C1D2E, 0x200040, 0x219000, 0x56F400, 0x000B5C, 0x22C400, 0x200040, 0x219100, 0x70E100, 0x0B72D9, 0x000F12, 0x56F400, 0x000B91, 0x22C400, 0x200040, 0x219100, 0x72E100, 0x45D800, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x0007B0, 0x0C1D2E, 0x200040, 0x219500, 0x455D00, 0x22C400, 0x46F400, 0x00001F, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219400, 0x4D5C00, 0x0D051E, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A413, 0x56F000, 0x000B8F, 0x200003, 0x05A40F, 0x60F400, 0x000483, 0x380600, 0x79F000, 0x000F13, 0x3A0200, 0x45D800, 0x65F400, 0x000B39, 0x455D00, 0x64F400, 0x00009B, 0x4D5C00, 0x0D051E, 0x00000C, 0x56F400, 0x000013, 0x57F400, 0x000001, 0x70F400, 0x000390, 0x390000, 0x60F400, 0x0000FA, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x00000C, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\AC3Dolby6.h ===
0xD01B40, 0x00008A, 0x060150, 0x499517, 0x607000, 0x000700, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x44F400, 0x7FFFFF, 0x4C7000, 0x000000, 0x4C7000, 0x000005, 0x44F400, 0x5A8279, 0x4C7000, 0x000002, 0x4C7000, 0x000003, 0x44F400, 0x5A8279, 0x4C7000, 0x000006, 0x4C7000, 0x000009, 0x44F400, 0x000000, 0x4C7000, 0x000004, 0x4C7000, 0x000008, 0x4C7000, 0x000001, 0x4C7000, 0x000007, 0x62F000, 0x000700, 0x000000, 0x000000, 0x0242D5, 0x02429E, 0x200003, 0x05A40B, 0x60F400, 0x000000, 0x380100, 0x4EF000, 0x000000, 0x060A90, 0x000004, 0x2000E1, 0x4EE800, 0x5E5800, 0x62F400, 0x000500, 0x66F400, 0x000600, 0x70F400, 0x000100, 0x60F400, 0x000000, 0x64F400, 0x000000, 0x221500, 0x060091, 0x000011, 0xF08800, 0x4EDCD0, 0xF088D8, 0x4EDCD2, 0xF088DA, 0x4EDCD2, 0xF088DA, 0x4EDCD2, 0xF088DA, 0x4EDCD3, 0x4EDDDB, 0x22B000, 0x64F400, 0x000000, 0x565A00, 0x575E00, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000600, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\AC3Dolby4.h ===
0xD01B40, 0x0006D3, 0x040150, 0x0FC6ED, 0x447000, 0x0000FB, 0x20000B, 0x05A403, 0x0D1080, 0x0006C0, 0x0D1080, 0x00066C, 0x57F000, 0x0000FB, 0x60F40B, 0x00001F, 0x052412, 0x240000, 0x447000, 0x000B4F, 0x447000, 0x000B50, 0x44F400, 0xF87200, 0x445800, 0x44F400, 0x4E1F00, 0x445800, 0x44F400, 0x000100, 0x445800, 0x44F400, 0x500000, 0x445800, 0x56F000, 0x000B4F, 0x44F003, 0x000B50, 0x05A402, 0x445800, 0x57F400, 0x000010, 0x0D1080, 0x0001A6, 0x44F400, 0x000000, 0x200045, 0x057400, 0x205800, 0x56D800, 0x57F000, 0x0000FB, 0x44F40B, 0x000004, 0x202A40, 0x57F000, 0x000B4F, 0x44F40B, 0x000001, 0x202240, 0x240000, 0x250000, 0x60F400, 0x00001F, 0x0CCC80, 0x000007, 0x0ACC40, 0x219800, 0x44F400, 0x000001, 0x45E800, 0x447000, 0x000B4F, 0x457000, 0x000B50, 0x218400, 0x56F000, 0x0000FB, 0x0D1080, 0x000636, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x06D910, 0x00000A, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F461, 0x000010, 0x230700, 0x50D97C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x06D910, 0x00000D, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x56D900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x46F400, 0x000010, 0x230700, 0x5ED900, 0x0C1E6E, 0x20AC7C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x218500, 0x00000C, 0x61F400, 0x000D12, 0x46F400, 0x0000FF, 0x06D810, 0x00000E, 0x0C1C90, 0x200056, 0x51D800, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1C90, 0x200056, 0x219900, 0x0C1D91, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x61F41B, 0x000E12, 0x46F400, 0x0000FF, 0x204800, 0x06D810, 0x00000D, 0x21AE5E, 0x44F800, 0x21B900, 0x0C1ED0, 0x200042, 0x4CE900, 0x200043, 0x218F56, 0x219900, 0x0C1ED1, 0x4CE900, 0x20004B, 0x0C1E91, 0x21AE00, 0x0C1C11, 0x00000C, 0x000479, 0x0003FA, 0x000417, 0x000434, 0x00043B, 0x000454, 0x00045B, 0x00045E, 0x000461, 0x000464, 0x000467, 0x00046A, 0x00046D, 0x000470, 0x000473, 0x000476, 0x74F400, 0x0003E1, 0x06D810, 0x000086, 0x64DD00, 0x56E000, 0x07EC96, 0x218500, 0x0AE680, 0x44F400, 0x000003, 0x62F4A0, 0x000005, 0x72F040, 0x000002, 0x234F22, 0x39010B, 0x546A00, 0x052404, 0x607000, 0x00000D, 0x050C0E, 0x66F400, 0x000D0A, 0x232400, 0x39024D, 0x05A409, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000D, 0x0C1D24, 0x390000, 0x506600, 0x717013, 0x000002, 0x050CC3, 0x44F400, 0x000005, 0x62F4A0, 0x000008, 0x72F040, 0x000003, 0x234F22, 0x39010B, 0x546A00, 0x052404, 0x607000, 0x00000E, 0x050C0E, 0x66F400, 0x000D0D, 0x232400, 0x39024D, 0x05A409, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000E, 0x0C1D20, 0x390000, 0x506600, 0x717013, 0x000003, 0x050C86, 0x44F400, 0x000007, 0x2000A0, 0x200040, 0x0C1D38, 0x0C1C10, 0x050C5F, 0x44F400, 0x00000B, 0x62F4A0, 0x00000B, 0x72F040, 0x000004, 0x234F22, 0x39010B, 0x66F400, 0x000D10, 0x546A00, 0x052404, 0x607000, 0x00000F, 0x050C08, 0xF0DA00, 0xF0DAD0, 0x66F0D2, 0x00000F, 0x0C1D20, 0x390000, 0x506600, 0x717013, 0x000004, 0x050C46, 0x44F400, 0x00000F, 0x2000A0, 0x200040, 0x0C1D36, 0x0C1C10, 0x050C1F, 0x56F400, 0x040000, 0x050C1B, 0x56F400, 0x020000, 0x050C18, 0x56F400, 0x010000, 0x050C15, 0x56F400, 0x008000, 0x050C12, 0x56F400, 0x004000, 0x050C0F, 0x56F400, 0x002000, 0x050C0C, 0x56F400, 0x001000, 0x050C09, 0x56F400, 0x000800, 0x050C06, 0x56F400, 0x000400, 0x050C03, 0x56F400, 0x000100, 0x200060, 0x565800, 0x00000C, 0x0004C6, 0x0004B2, 0x0004A8, 0x0004BB, 0x00049E, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x0004BB, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x56F000, 0x000B56, 0x45F000, 0x000B57, 0x46F400, 0x000010, 0x74F400, 0x00047B, 0x06D810, 0x00002F, 0x64DD00, 0x07EC96, 0x0B74C7, 0x000CFA, 0x0AE680, 0x57F000, 0x000004, 0x01418C, 0x557000, 0x000004, 0x052443, 0x390200, 0x717000, 0x000004, 0x050C14, 0x57F000, 0x000003, 0x01418C, 0x557000, 0x000003, 0x052419, 0x390300, 0x717000, 0x000003, 0x050C0A, 0x57F000, 0x000002, 0x01418C, 0x557000, 0x000002, 0x05240F, 0x390300, 0x717000, 0x000002, 0x200069, 0x50E07C, 0x057407, 0x21E478, 0x0C1E46, 0x0C1E90, 0x21E449, 0x545A58, 0x0C1E68, 0x0C1E4E, 0x21A500, 0x205800, 0x547000, 0x000B56, 0x457000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000000, 0x20004D, 0x05A40C, 0x44F400, 0x000010, 0x20004D, 0x0D104A, 0x00000F, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x200013, 0x300000, 0x56F400, 0x000000, 0x57F400, 0x000608, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x057458, 0x607000, 0x000B45, 0x607000, 0x000B55, 0x45F400, 0x0007B0, 0x457000, 0x000B72, 0x56F000, 0x000B40, 0x240003, 0x052409, 0x447000, 0x000B56, 0x447000, 0x000B57, 0x447000, 0x000B9D, 0x0D1080, 0x00008C, 0x0D1080, 0x000129, 0x0D1080, 0x00019E, 0x0D1080, 0x000366, 0x56F000, 0x000B40, 0x014585, 0x052403, 0x0D1080, 0x000393, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x547000, 0x000B58, 0x0D1080, 0x0003D0, 0x56F000, 0x000B40, 0x014585, 0x05A40B, 0x44F000, 0x000B58, 0x45F400, 0x000010, 0x44F0A0, 0x000B9D, 0x0C1D2E, 0x200040, 0x567000, 0x000B9D, 0x0D1080, 0x000008, 0x00000C, 0x44F400, 0x000100, 0x447000, 0x000010, 0x00000C, 0x56F000, 0x000B96, 0x200003, 0x05F407, 0x44F013, 0x000B45, 0x447000, 0x000B55, 0x547000, 0x000B9A, 0x60F400, 0x000011, 0x44F400, 0x00000D, 0x445800, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x545800, 0x44F000, 0x000B55, 0x445800, 0x240000, 0x445800, 0x445800, 0x445800, 0x445800, 0x44F413, 0x000009, 0x447000, 0x00001E, 0x44F000, 0x00001E, 0x0C1940, 0x004018, 0x545800, 0x240000, 0x445800, 0x20001B, 0x200013, 0x0C1EDF, 0x21A400, 0x0C1940, 0x008020, 0x20001B, 0x0C1EDF, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x57F013, 0x000B7D, 0x45F40B, 0x000080, 0x052407, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008020, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x57F013, 0x000B7D, 0x20000B, 0x052407, 0x20001B, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008020, 0x0C1CA1, 0x200068, 0x21A400, 0x0C1940, 0x008018, 0x545800, 0x200013, 0x545800, 0x60F400, 0x000011, 0x56F000, 0x000B96, 0x57F400, 0x000608, 0x00000C, 0x62F000, 0x000B45, 0x05F022, 0x000B47, 0x57F400, 0x000010, 0x250000, 0x44F400, 0x000B77, 0x447000, 0x000000, 0x44F400, 0x000000, 0x447000, 0x000B54, 0x61F400, 0x000000, 0x381000, 0x0D0393, 0x61F400, 0x000B54, 0x381000, 0x0D0393, 0x61F400, 0x000B7B, 0x380200, 0x0D0393, 0x61F400, 0x000B7C, 0x380600, 0x0D0393, 0x280400, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380500, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F400, 0x000B7D, 0x380300, 0x0D0393, 0x56F000, 0x000B7D, 0x014185, 0x05A40A, 0x014186, 0x05A408, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F000, 0x000B7D, 0x014486, 0x05A408, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F000, 0x000B7D, 0x014285, 0x052405, 0x61F400, 0x000B4E, 0x380200, 0x0D0393, 0x61F400, 0x000B7E, 0x380100, 0x0D0393, 0x61F400, 0x000B49, 0x380500, 0x0D0393, 0x61F400, 0x000B4C, 0x380100, 0x0D0393, 0x56F000, 0x000B4C, 0x200003, 0x05A405, 0x61F400, 0x000B4D, 0x380800, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280000, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x280100, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x200013, 0x507000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x200013, 0x567000, 0x000002, 0x567000, 0x000003, 0x567000, 0x000004, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00001D, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x70E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x000100, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219500, 0x667000, 0x000B41, 0x0D03F1, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A407, 0x380700, 0x60F400, 0x000489, 0x65F400, 0x000B39, 0x0D03F1, 0x57F000, 0x000002, 0x20000B, 0x05A414, 0x62F400, 0x000005, 0x66F400, 0x000D0A, 0x224E00, 0x44F410, 0x000001, 0x01438C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000D, 0x0C1D24, 0x506600, 0x57F000, 0x000003, 0x20000B, 0x05A414, 0x62F400, 0x000008, 0x66F400, 0x000D0D, 0x224E00, 0x44F410, 0x000002, 0x01438C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0xF0DAD2, 0x66F0D2, 0x00000E, 0x0C1D20, 0x506600, 0x57F000, 0x000004, 0x20000B, 0x05A413, 0x62F400, 0x00000B, 0x66F400, 0x000D10, 0x224E00, 0x44F410, 0x000005, 0x01428C, 0x21D03E, 0x06CD10, 0x000002, 0x445800, 0xF0DA00, 0xF0DAD0, 0x66F0D2, 0x00000F, 0x0C1D20, 0x506600, 0x00000C, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x57F000, 0x000B57, 0x45F000, 0x000B56, 0x61F400, 0x000B7F, 0x71F000, 0x000B97, 0x380100, 0x0D036F, 0x61F400, 0x000B84, 0x71F000, 0x000B97, 0x380100, 0x0D036F, 0x61F400, 0x000B4A, 0x380100, 0x0D0393, 0x56F000, 0x000B4A, 0x200003, 0x05A405, 0x61F400, 0x000B4B, 0x380800, 0x0D0393, 0x200013, 0x567000, 0x00001E, 0x61F400, 0x000B89, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A405, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x56F000, 0x000B7D, 0x0140C5, 0x000002, 0x052412, 0x44F400, 0x000010, 0x447000, 0x00001E, 0x56F000, 0x000B40, 0x200003, 0x052406, 0x61F400, 0x00001E, 0x380500, 0x0D0393, 0x050C05, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x61F400, 0x000B8A, 0x71F000, 0x000B97, 0x380200, 0x0D036F, 0x56F000, 0x000B7E, 0x200003, 0x05A405, 0x61F400, 0x000B8F, 0x380100, 0x0D0393, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000011, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219100, 0x56E100, 0x200003, 0x05A408, 0x56F400, 0x000BA0, 0x22C400, 0x200040, 0x219100, 0x380600, 0x0D0393, 0x205E00, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000023, 0x56F400, 0x000B8A, 0x22C400, 0x200040, 0x219100, 0x56E100, 0x200003, 0x05A41A, 0x22C400, 0x46F400, 0x00001F, 0x44F4D0, 0x000000, 0x0C1D2E, 0x200040, 0x219100, 0x380400, 0x0D03A3, 0x56F400, 0x000B91, 0x22C400, 0x200040, 0x219000, 0x71E000, 0x380700, 0x0D0381, 0x56F400, 0x000B61, 0x22C400, 0x200040, 0x219100, 0x380200, 0x0D0393, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A40C, 0x56F000, 0x000B8F, 0x200003, 0x05A408, 0x61F400, 0x00009B, 0x380400, 0x0D03A3, 0x390200, 0x380700, 0x0D0381, 0x61F400, 0x000B90, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A449, 0x56F400, 0x000002, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000002, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380200, 0x0D0393, 0x56F400, 0x000007, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F400, 0x000B6F, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A44A, 0x61F400, 0x000B73, 0x380600, 0x0D0393, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x000011, 0x56F400, 0x000B74, 0x22C400, 0x200040, 0x219100, 0x380400, 0x0D0393, 0x56F400, 0x000004, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A40D, 0x61F400, 0x000B79, 0x380400, 0x0D0393, 0x56F400, 0x000004, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380300, 0x0D0393, 0x61F413, 0x00001E, 0x566100, 0x380100, 0x0D0393, 0x050C01, 0x56F000, 0x000B40, 0x014385, 0x052455, 0x224E00, 0x44F000, 0x000B45, 0x46F444, 0x000010, 0x21C700, 0x21EE00, 0x44F436, 0x000010, 0x200040, 0x21C400, 0x47F0B0, 0x000B9D, 0x0C1D2E, 0x200040, 0x44F070, 0x000B67, 0x21C741, 0x0C1D06, 0x18B000, 0x000B9E, 0x44F054, 0x000B7A, 0x200044, 0x200074, 0x200003, 0x05F41A, 0x014780, 0x44F000, 0x000B67, 0x0C1C06, 0x21C441, 0x200040, 0x567000, 0x000B67, 0x0140C5, 0x0001FF, 0x05F402, 0x00000C, 0x56F000, 0x000B71, 0x21C441, 0x0C1D06, 0x21C441, 0x200040, 0x567000, 0x000B71, 0x60F400, 0x000B6C, 0x56E000, 0x200044, 0x566000, 0x61F400, 0x000B66, 0x380100, 0x0D0393, 0x56F900, 0x200003, 0x05A501, 0x61F400, 0x000B67, 0x380900, 0x0D0393, 0x56F000, 0x000B70, 0x200003, 0x05F49F, 0x44F400, 0x000001, 0x447000, 0x000B5B, 0x61F413, 0x00001E, 0x566100, 0x380100, 0x0D0393, 0x240000, 0x447000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x56F000, 0x000B5B, 0x014180, 0x567000, 0x000B5B, 0x56F000, 0x000B40, 0x014385, 0x052441, 0x240000, 0x447000, 0x00001E, 0x21EE00, 0x015085, 0x05A40B, 0x44F000, 0x000B5B, 0x200040, 0x21E400, 0x567000, 0x000B5B, 0x61F400, 0x00001E, 0x209800, 0x0D0393, 0x224E00, 0x567000, 0x000B59, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x56F000, 0x000B5B, 0x016080, 0x567000, 0x000B5B, 0x240000, 0x447000, 0x00001E, 0x56F000, 0x000B70, 0x0C1D06, 0x44F000, 0x000B5B, 0x200044, 0x0C1C06, 0x06CC10, 0x00000A, 0x61F400, 0x00001E, 0x380800, 0x0D0393, 0x56F000, 0x000B5B, 0x014880, 0x567000, 0x000B5B, 0x56F000, 0x000B70, 0x0C1D06, 0x44F000, 0x000B5B, 0x200044, 0x61F400, 0x00001E, 0x219800, 0x0D0393, 0x56F000, 0x000B67, 0x44F000, 0x000B70, 0x200044, 0x050C0F, 0x56F000, 0x000B67, 0x2E0003, 0x05F40B, 0x240000, 0x447000, 0x00001E, 0x61F400, 0x00001E, 0x380800, 0x0D0393, 0x56F000, 0x000B67, 0x014184, 0x200003, 0x05A40B, 0x06CC10, 0x000009, 0x200013, 0x567000, 0x000010, 0x61F400, 0x000010, 0x380800, 0x0D0361, 0x000000, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x00000C, 0x390100, 0x717000, 0x000002, 0x717000, 0x000003, 0x717000, 0x000004, 0x360000, 0x44F000, 0x000B97, 0x06C410, 0x00001D, 0x56F400, 0x000BA5, 0x22C400, 0x200040, 0x219000, 0x70E000, 0x22C400, 0x46F400, 0x0000B5, 0x44F4D0, 0x000100, 0x0C1D2E, 0x200040, 0x219000, 0x22C400, 0x46F400, 0x0000B5, 0x44F0D0, 0x000B72, 0x0C1D2E, 0x200040, 0x219500, 0x667000, 0x000B41, 0x0D048B, 0x66F000, 0x000B41, 0x205E00, 0x56F000, 0x000B7E, 0x200003, 0x05A407, 0x380700, 0x60F400, 0x000489, 0x65F400, 0x000B39, 0x0D048B, 0x00000C, 0x62F000, 0x000B55, 0x05F022, 0x000B47, 0x57F000, 0x000B57, 0x45F000, 0x000B56, 0x240000, 0x447000, 0x00001E, 0x56F000, 0x000B6E, 0x015085, 0x059409, 0x015084, 0x547000, 0x000B6E, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x050FD5, 0x200003, 0x05A405, 0x61F400, 0x00001E, 0x219800, 0x0D0393, 0x200013, 0x567000, 0x000001, 0x567000, 0x00001E, 0x61F400, 0x00001E, 0x380100, 0x0D0393, 0x61F400, 0x000001, 0x380100, 0x0D0393, 0x61F400, 0x00001E, 0x381000, 0x0D0393, 0x457000, 0x000B56, 0x577000, 0x000B57, 0x627000, 0x000B55, 0x05F422, 0x00FFFF, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x21C400, 0x45F400, 0x000010, 0x2000A0, 0x0C1D2E, 0x44F000, 0x000B9D, 0x200040, 0x567000, 0x000B9D, 0x00000C, 0x56F000, 0x000B40, 0x014085, 0x052410, 0x60F000, 0x000B45, 0x205800, 0x05F020, 0x000B47, 0x56F000, 0x000B58, 0x014184, 0x21D81B, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050CDA, 0x014185, 0x05A403, 0x014285, 0x05240F, 0x60F000, 0x000B45, 0x05F020, 0x000B47, 0x70F01B, 0x000B58, 0x55F000, 0x000B5A, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050CC8, 0x014385, 0x052482, 0x56F000, 0x000B59, 0x44F000, 0x000B45, 0x200044, 0x014180, 0x21D800, 0x209000, 0x05F020, 0x000B47, 0x55F000, 0x000B5A, 0x0D03B3, 0x0C1E91, 0x61F000, 0x000B59, 0x556100, 0x0C1C91, 0x44F000, 0x000B9D, 0x250800, 0x2000A0, 0x44F000, 0x000B9B, 0x21C441, 0x200044, 0x230400, 0x200044, 0x209A00, 0x21D800, 0x56F000, 0x000B59, 0x014180, 0x21D000, 0x0D03CA, 0x56F000, 0x000B59, 0x014180, 0x21D000, 0x0C1E91, 0x556000, 0x0C1C91, 0x56F000, 0x000B55, 0x44F000, 0x000B45, 0x200044, 0x234400, 0x200044, 0x230400, 0x200044, 0x21D800, 0x56F000, 0x000B45, 0x200040, 0x234400, 0x200040, 0x21D000, 0x20001B, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050C45, 0x014485, 0x05240F, 0x05F020, 0x000B47, 0x60F000, 0x000B45, 0x70F000, 0x000B58, 0x57F000, 0x000B5A, 0x0D03B3, 0x557000, 0x000B5A, 0x05F420, 0x00FFFF, 0x050C15, 0x014585, 0x052413, 0x05F020, 0x000B47, 0x60F000, 0x000B45, 0x70F000, 0x000B58, 0x57F000, 0x000B5A, 0x0D03B3, 0x56F000, 0x000B55, 0x014184, 0x21D000, 0x0C1E91, 0x556000, 0x0C1C91, 0x05F420, 0x00FFFF, 0x00000C, 0x56F400, 0x000012, 0x57F400, 0x000001, 0x70F400, 0x000390, 0x390000, 0x60F400, 0x000100, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x547000, 0x0000FD, 0x447000, 0x0000FE, 0x607000, 0x0000FF, 0x200003, 0x052410, 0x56F400, 0x00000C, 0x70F400, 0x0005DA, 0x390000, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F000, 0x0000FD, 0x60F000, 0x0000FF, 0x44F000, 0x0000FE, 0x45F403, 0x0005DA, 0x052403, 0x457000, 0x000B48, 0x209800, 0x56F000, 0x000B48, 0x219940, 0x547000, 0x000B48, 0x56F400, 0x000009, 0x57F400, 0x000002, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x56F000, 0x0000FD, 0x014585, 0x052409, 0x56F400, 0x00000C, 0x70F400, 0x000122, 0x71F400, 0x000ADE, 0x0BF080, 0x000180, 0x56F400, 0x000016, 0x57F400, 0x000002, 0x390000, 0x70F400, 0x000080, 0x60F400, 0x000B40, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C, 0x56F400, 0x000016, 0x57F400, 0x000000, 0x70F400, 0x000080, 0x0BF080, 0x000180, 0x200003, 0x052400, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\AC3SuperExec.h ===
0x050C08, 
0x000000, 
0x000001, 
0x000001, 
0x000000, 
0x000000, 
0xCCCCCC, 
0x000000, 
0x240000, 
0x077084, 
0x000004, 
0x077084, 
0x000005, 
0x07F432, 
0xFFFFFF, 
0x07F430, 
0x000001, 
0x07F431, 
0x000001, 
0x0500BB, 
0x05F42A, 
0x000BE0, 
0x0520B8, 
0x0AFA74, 
0x200013, 
0x077088, 
0x000001, 
0x000008, 
0x077088, 
0x000002, 
0x077088, 
0x000003, 
0x56F400, 
0x000000, 
0x0BF080, 
0x000180, 
0x08F485, 
0x000002, 
0x07F08E, 
0x000007, 
0x014180, 
0x07708E, 
0x000007, 
0x08F484, 
0x000001, 
0x200013, 
0x014180, 
0x0A8581, 
0x00002E, 
0x44F000, 
0xFFFFB3, 
0x077084, 
0x000005, 
0x08F485, 
0x000002, 
0x56F400, 
0x00000B, 
0x0BF080, 
0x000180, 
0x56F000, 
0xFFFFB3, 
0x07F084, 
0x000005, 
0x200044, 
0x07708C, 
0x000004, 
0x44F400, 
0x0ACDA0, 
0x0C1FF8, 
0x0597C1, 
0x44F400, 
0xBBBBBB, 
0x077084, 
0x000006, 
0x050C00, 
0x050C00,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\acireg.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       acireg.h
 *  Content:    ACI registers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/27/00    dereks  Created based on NVidia code.
 *
 ****************************************************************************/

#ifndef __ACIREG_H__
#define __ACIREG_H__

//
// Memory-mapped IO offsets
//

#define AC97_MIO_BASE       0x0000      // AC'97 base offset
#define ACI_MIO_BASE        0x0100      // ACI base offset

//
// DMA channel relative offsets.
//

#define AO_BL_BASE          0x0010      // audio out buffer list offset
#define SO_BL_BASE          0x0070      // SP/DIF out buffer list offset

//
// Defines for base-relative bus master register access
//

#define X_BL_BASE           0x0000      // Buffer List Base Address
#define X_CUR_IDX           0x0004      // Current Index
#define X_LST_IDX           0x0005      // Last Valid Index
#define X_STATUS            0x0006      // Status Register
#define X_CUR_POS           0x0008      // Current Position
#define X_NXT_IDX           0x000a      // Next Index
#define X_CTRL              0x000b      // Control
#define X_STWD              0x000c      // Channel status word (SPDIF only)

//
// DMA Status Register bit defines
//

#define X_STATUS_FIFOE      0x0010      // FIFO Error
#define X_STATUS_BCI        0x0008      // Buffer Completion Interrupt
#define X_STATUS_LVBCI      0x0004      // Last Valid Buffer Completion Interrupt
#define X_STATUS_CIELV      0x0002      // Current Index Equals Last Valid
#define X_STATUS_DCH        0x0001      // DMA Controller Halted

//
// DMA Control Register bit defines
//

#define X_CTRL_IOCE         0x10        // Interrupt On Completion Enable
#define X_CTRL_FEIE         0x08        // FIFO Error Interrupt Enable
#define X_CTRL_LVBIE        0x04        // Last Valid Buffer Interrupt Enable
#define X_CTRL_RBMR         0x02        // Reset Bus Master Registers
#define X_CTRL_RPBM         0x01        // Run/Pause Bus Master

//
// Global Control Register
//

#define GLB_CTRL            0x002c

//
// Global Control bit defines
//

#define GLB_CTRL_SRIE       0x00000020  // Secondary Resume Interrupt Enable
#define GLB_CTRL_PRIE       0x00000010  // Primary Resume Interrupt Enable
#define GLB_CTRL_ACSD       0x00000008  // AC-link Shut Down
#define GLB_CTRL_WARM       0x00000004  // AC97 Warm Reset
#define GLB_CTRL_COLD       0x00000002  // AC97 Cold Reset
#define GLB_CTRL_GIE        0x00000001  // GPIO Interrupt Enable

//
// Global Status Register
//

#define GLB_STATUS          0x0030

//
// Global Status bit defines
//

#define GLB_STATUS_MD3      0x00020000  // Power Down Semaphore for Modem
#define GLB_STATUS_AD3      0x00010000  // Power Down Semaphore for Audio
#define GLB_STATUS_RCS      0x00008000  // Read Completion Status
#define GLB_STATUS_B3S12    0x00004000  // Bit 3 Slot 12
#define GLB_STATUS_B2S12    0x00002000  // Bit 2 Slot 12
#define GLB_STATUS_B1S12    0x00001000  // Bit 1 Slot 12
#define GLB_STATUS_SRI      0x00000800  // Secondary Resume Interrupt
#define GLB_STATUS_PRI      0x00000400  // Primary Resume Interrupt
#define GLB_STATUS_SCR      0x00000200  // Secondary Codec Ready
#define GLB_STATUS_PCR      0x00000100  // Primary Codec Ready
#define GLB_STATUS_AOINT    0x00000040  // Audio Out Interrupt
#define GLB_STATUS_SOINT    0x00000010  // SP/DIF Out Interrupt
#define GLB_STATUS_GPINT    0x00000001  // GPIO Interrupt

//
// AC97 Register Semaphore
//

#define AC97_SEM4           0x0034

//
// AC97 Register Semaphore bit defines
//

#define AC97_SEM4_OWNED     0x01        // AC97 Semaphore Owned

//
// Physical region descriptor
//

typedef struct
{
    DWORD   dwPhysicalAddress;
    DWORD   wLength                 : 16;
    DWORD   wReserved               : 14;
    BOOL    fBufferUnderrunPolicy   : 1;
    BOOL    fInterruptOnCompletion  : 1;
} ACIPRD, *LPACIPRD;

//
// Physical region descriptor list
//

#define ACIPRDL_ENTRY_COUNT 32
#define ACIPRDL_ENTRY_SHIFT 5
#define ACIPRDL_ENTRY_MASK  0x1F

//
// SP/DIF STWD values
//

#define SPDIF_STWD_SURROUND 0x02000000
#define SPDIF_STWD_AC3      0x02000002

#endif // __ACIREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\cipher.cpp ===
#include "dsoundi.h"
#include "..\tools\xcodescr\cipher.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\AC3Loader.h ===
0x014085, 
0x05A441, 
0x014B85, 
0x05A40C, 
0x050C1C, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x000000, 
0x60F400, 
0x000400, 
0x64F400, 
0x000800, 
0x060098, 
0x000003, 
0x4CDC00, 
0x445800, 
0x60F400, 
0x000400, 
0x70F400, 
0x000800, 
0x61F400, 
0x000000, 
0x0BF080, 
0x0001B4, 
0x050C01, 
0x200013, 
0x00000C, 
0x60F413, 
0x00011C, 
0x062490, 
0x000002, 
0x07588E, 
0x0D1080, 
0x0000C6, 
0x050FD7, 
0x64F400, 
0x000186, 
0x220C00, 
0x014080, 
0x219000, 
0x0BF080, 
0x0001F4, 
0x0BF080, 
0x00025F, 
0x00000C, 
0x64F400, 
0x000186, 
0x220C00, 
0x014080, 
0x219000, 
0x0BF080, 
0x000206, 
0x0BF080, 
0x00025F, 
0x00000C, 
0x64F400, 
0x000186, 
0x220C00, 
0x014080, 
0x219000, 
0x0BF080, 
0x000218, 
0x0BF080, 
0x00025F, 
0x00000C, 
0x64F400, 
0x000186, 
0x220C00, 
0x0140C0, 
0x001800, 
0x219000, 
0x0BF080, 
0x0001F4, 
0x0BF080, 
0x00025F, 
0x00000C, 
0x64F400, 
0x000186, 
0x220C00, 
0x0140C0, 
0x001800, 
0x219000, 
0x0BF080, 
0x000206, 
0x0BF080, 
0x00025F, 
0x00000C, 
0x64F400, 
0x000186, 
0x220C00, 
0x0140C0, 
0x002800, 
0x219000, 
0x0BF080, 
0x0001F4, 
0x0BF080, 
0x00025F, 
0x00000C, 
0x64F400, 
0x000186, 
0x220C00, 
0x0140C0, 
0x002800, 
0x219000, 
0x0BF080, 
0x000206, 
0x0BF080, 
0x00025F, 
0x00000C, 
0x0BF080, 
0x00024E, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x005BE0, 
0x075D8C, 
0x075D98, 
0x075D90, 
0x222E00, 
0x0C1E84, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x00024E, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x005BE2, 
0x075D8C, 
0x075D98, 
0x075D90, 
0x222E00, 
0x0C1E84, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x00024E, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x005A02, 
0x222F00, 
0x0C1E8B, 
0x21E500, 
0x200062, 
0x075D8C, 
0x075D98, 
0x238E00, 
0x0C1E9C, 
0x220400, 
0x200040, 
0x075D8C, 
0x00000C, 
0x0BF080, 
0x00024E, 
0x229500, 
0x228C00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x075D8C, 
0x54F400, 
0x000603, 
0x222F00, 
0x0C1E8B, 
0x21E500, 
0x200062, 
0x230F00, 
0x0C1E9D, 
0x21E500, 
0x200062, 
0x075D8C, 
0x230F00, 
0x0C1E89, 
0x234500, 
0x200068, 
0x075D8D, 
0x238E00, 
0x0C1E9C, 
0x220400, 
0x200040, 
0x075D8C, 
0x00000C, 
0x0A96A4, 
0x00024E, 
0x08F485, 
0x000080, 
0x00000C, 
0x08F496, 
0x000001, 
0x0A9684, 
0x000255, 
0x00000C, 
0x0A85AA, 
0x00027C, 
0x0A8587, 
0x000258, 
0x08F485, 
0x000080, 
0x00000C, 
0x228E00, 
0x0140C0, 
0x002800, 
0x08CE14, 
0x0BF080, 
0x000253, 
0x20001B, 
0x23AF00, 
0x01408D, 
0x0D104A, 
0x000004, 
0x0BF080, 
0x000258, 
0x00000C, 
0x08F485, 
0x000FFF, 
0x08F484, 
0x000001, 
0x08F48A, 
0x000000, 
0x44F400, 
0x004000, 
0x447000, 
0xFFFFD5, 
0x447000, 
0xFFFFD4, 
0x08F497, 
0x000000, 
0x00000C, 
0x050C00,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\drvhlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drvhlp.cpp
 *  Content:    Miscelaneous NT-style driver helper functions and objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/07/01    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

DWORD CFpState::m_dwRefCount = 0;
KFLOATING_SAVE CFpState::m_fps;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\ac97.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ac97.h
 *  Content:    DirectSound AC97 device driver.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/27/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __AC97_H__
#define __AC97_H__

#ifndef AC97_AMR
#define AC97_USE_MIO
#endif // AC97_AMR

#include "ac97reg.h"
#include "acireg.h"
#include <conio.h>

#pragma intrinsic(_inp,_inpw,_inpd,_outp,_outpw,_outpd)

//
// AC97 channel identifiers
//

typedef enum
{
    AC97_CHANNELTYPE_ANALOG = 0,
    AC97_CHANNELTYPE_DIGITAL,
    AC97_CHANNELTYPE_COUNT
} AC97CHANNELTYPE;

//
// AC97 channel interrupt bits
//

#define AC97_CHANNELINTERRUPT(line) \
    (1UL << (line))

#define AC97_CHANNELINTERRUPT_ANALOG    AC97_CHANNELINTERRUPT(AC97_CHANNELTYPE_ANALOG)
#define AC97_CHANNELINTERRUPT_DIGITAL   AC97_CHANNELINTERRUPT(AC97_CHANNELTYPE_DIGITAL)

#define AC97_CHANNELINTERRUPT_MASK      (AC97_CHANNELINTERRUPT(AC97_CHANNELTYPE_COUNT) - 1)

//
// AC97 channel interrupt callback
//

typedef void (CALLBACK *LPFNAC97CHANNELCALLBACK)(LPVOID pvContext);

//
// AC97 device object creation flags
//

#define AC97_OBJECTF_DIRECTISR      0x00000001      // The device does not spawn a DPC to handle interrupts

//
// AC97 channel object creation flags
//

#define AC97CHANNEL_OBJECTF_STREAM          0x00000001      // The channel removed played packets from the list
#define AC97CHANNEL_OBJECTF_DISCONTINUITY   0x00000002      // Internal channel flag.  Do not set

#ifdef __cplusplus

//
// Forward declarations
//

class CAc97Channel;

//
// AC97 device object
//

class CAc97Device
{
    friend class CAc97Channel;

public:
    static const WAVEFORMATEX   m_wfxFormat;                                            // Device format
                                                                                        
#ifdef AC97_AMR                                                                         
                                                                                        
    static const DWORD          m_dwVendorId;                                           // PCI device vendor identifier
    static const DWORD          m_dwDeviceId;                                           // PCI device identifier
    static const DWORD          m_dwBusNumber;                                          // PCI bus index
    static const DWORD          m_dwDeviceNumber;                                       // PCI device index
    static const DWORD          m_dwFunctionNumber;                                     // PCI device function index
                                                                                        
#endif // AC97_AMR                                                                      
                                                                                        
    static const DWORD          m_dwAc97RegisterBase;                                   // AC97 register base address
    static const DWORD          m_dwAciRegisterBase;                                    // ACI register base address
    static CAc97Device *        m_pDevice;                                              // The one-and-only device object
    CAc97Channel *              m_apChannels[AC97_CHANNELTYPE_COUNT];                   // Channel objects
                                                                                        
protected:                                                                              
    DWORD                       m_dwFlags;                                              // Object creation flags
    static KINTERRUPT           m_Interrupt;                                            // Interrupt object
    HAL_SHUTDOWN_REGISTRATION   m_HalShutdownData;                                      // HAL shutdown registration data
    KDPC                        m_dpc;                                                  // Interrupt DPC routine
    BYTE                        m_abPendingBufferCompletions[AC97_CHANNELTYPE_COUNT][2];// Count of buffer completions waiting to be handled (live and cached)

public:
    CAc97Device(void);
    ~CAc97Device(void);

public:
    CAc97Device &operator=(const CAc97Device &);

public:
    // Initialization
    HRESULT Initialize(DWORD dwFlags = 0);
    void Terminate(void);

    // Channel allocation
    HRESULT CreateChannel(AC97CHANNELTYPE nChannelType, CAc97Channel **ppChannel = NULL);
    void ReleaseChannel(AC97CHANNELTYPE nChannelType);
    void ReleaseChannel(CAc97Channel *pChannel);

protected:
    // CODEC power state
    BOOL CodecReady(void);
    HRESULT PowerUp(void);

    // Interrupt handlers
    DWORD ServiceAciInterrupt(void);
    void ServiceAciInterruptDpc(void);
    void SynchronizeAciInterrupt(void);
    DWORD GetInterruptStatus(void);

    // Register access
    static BOOL AcquireCodecSemaphore(void);
    
    static BYTE PeekRegister8(DWORD dwRegister);
    static void PokeRegister8(DWORD dwRegister, BYTE bValue);
    static WORD PeekRegister16(DWORD dwRegister);
    static void PokeRegister16(DWORD dwRegister, WORD wValue);
    static DWORD PeekRegister32(DWORD dwRegister);
    static void PokeRegister32(DWORD dwRegister, DWORD dwValue);

    static BYTE PeekAciRegister8(DWORD dwRegister);
    static void PokeAciRegister8(DWORD dwRegister, BYTE bValue);
    static WORD PeekAciRegister16(DWORD dwRegister);
    static void PokeAciRegister16(DWORD dwRegister, WORD wValue);
    static DWORD PeekAciRegister32(DWORD dwRegister);
    static void PokeAciRegister32(DWORD dwRegister, DWORD dwValue);

    static BOOL PeekAc97Register(AC97REGISTER reg, LPWORD pwValue);
    static BOOL PokeAc97Register(AC97REGISTER reg, WORD wValue);
    static BOOL VerifyPokeAc97Register(AC97REGISTER reg, WORD wValue);

    static void WaitRegisterRetry(void);

private:
    // HAL callbacks
    static BOOLEAN AciInterruptServiceRoutine(PKINTERRUPT pInterrupt, LPVOID pvContext);
    static void AciInterruptDpcHandler(PKDPC pdpc, LPVOID pvDeferredContext, LPVOID pvSystemArgument1, LPVOID pvSystemArgument2);
    static void AciShutdownNotifier(PHAL_SHUTDOWN_REGISTRATION pHalShutdownData);
    static BOOLEAN AciSynchronizationRoutine(LPVOID pvContext);
};

__inline BYTE CAc97Device::PeekRegister8(DWORD dwRegister)
{

#ifdef AC97_USE_MIO

    return *(LPBYTE)dwRegister;

#else // AC97_USE_MIO

    return (BYTE)_inp((WORD)dwRegister);

#endif // AC97_USE_MIO

}    

__inline void CAc97Device::PokeRegister8(DWORD dwRegister, BYTE bValue)
{

#ifdef AC97_USE_MIO

    *(LPBYTE)dwRegister = bValue;

#else // AC97_USE_MIO

    _outp((WORD)dwRegister, bValue);

#endif // AC97_USE_MIO

}

__inline WORD CAc97Device::PeekRegister16(DWORD dwRegister)
{

#ifdef AC97_USE_MIO

    return *(LPWORD)dwRegister;

#else // AC97_USE_MIO

    return _inpw((WORD)dwRegister);

#endif // AC97_USE_MIO

}

__inline void CAc97Device::PokeRegister16(DWORD dwRegister, WORD wValue)
{

#ifdef AC97_USE_MIO

    *(LPWORD)dwRegister = wValue;

#else // AC97_USE_MIO

    _outpw((WORD)dwRegister, wValue);

#endif // AC97_USE_MIO

}

__inline DWORD CAc97Device::PeekRegister32(DWORD dwRegister)
{

#ifdef AC97_USE_MIO

    return *(LPDWORD)dwRegister;

#else // AC97_USE_MIO

    return _inpd((WORD)dwRegister);

#endif // AC97_USE_MIO

}

__inline void CAc97Device::PokeRegister32(DWORD dwRegister, DWORD dwValue)
{

#ifdef AC97_USE_MIO

    *(LPDWORD)dwRegister = dwValue;

#else // AC97_USE_MIO

    _outpd((WORD)dwRegister, dwValue);

#endif // AC97_USE_MIO

}

__inline BYTE CAc97Device::PeekAciRegister8(DWORD dwRegister)
{
    return PeekRegister8(m_dwAciRegisterBase + dwRegister);
}
    
__inline void CAc97Device::PokeAciRegister8(DWORD dwRegister, BYTE bValue)
{
    PokeRegister8(m_dwAciRegisterBase + dwRegister, bValue);
}

__inline WORD CAc97Device::PeekAciRegister16(DWORD dwRegister)
{
    return PeekRegister16(m_dwAciRegisterBase + dwRegister);
}

__inline void CAc97Device::PokeAciRegister16(DWORD dwRegister, WORD wValue)
{
    PokeRegister16(m_dwAciRegisterBase + dwRegister, wValue);
}

__inline DWORD CAc97Device::PeekAciRegister32(DWORD dwRegister)
{
    return PeekRegister32(m_dwAciRegisterBase + dwRegister);
}

__inline void CAc97Device::PokeAciRegister32(DWORD dwRegister, DWORD dwValue)
{
    PokeRegister32(m_dwAciRegisterBase + dwRegister, dwValue);
}

__inline void CAc97Device::WaitRegisterRetry(void)
{
    KeStallExecutionProcessor(20);
}

__inline BOOLEAN CAc97Device::AciInterruptServiceRoutine(PKINTERRUPT pInterrupt, LPVOID pvContext)
{
    CAc97Device *           pThis   = (CAc97Device *)pvContext;
    
    return (BOOLEAN)MAKEBOOL(pThis->ServiceAciInterrupt());
}

__inline void CAc97Device::AciInterruptDpcHandler(PKDPC pdpc, LPVOID pvDeferredContext, LPVOID pvSystemArgument1, LPVOID pvSystemArgument2)
{
    CAc97Device *           pThis   = (CAc97Device *)pvDeferredContext;
    
    pThis->ServiceAciInterruptDpc();
}

__inline void CAc97Device::AciShutdownNotifier(PHAL_SHUTDOWN_REGISTRATION pHalShutdownData)
{
    CAc97Device *           pThis   = CONTAINING_RECORD(pHalShutdownData, CAc97Device, m_HalShutdownData);
    
    pThis->Terminate();
}

__inline BOOLEAN CAc97Device::AciSynchronizationRoutine(LPVOID pvContext)
{
    CAc97Device *           pThis   = (CAc97Device *)pvContext;
    
    pThis->SynchronizeAciInterrupt();

    return TRUE;
}    

//
// AC97 channel object
//

class CAc97Channel
{
    friend class CAc97Device;

public:
    static const DWORD          m_adwRegisterOffsets[AC97_CHANNELTYPE_COUNT];   // Channel register offsets
    static const DWORD          m_dwSilenceSize;                                // Silent packet size

public:
    const AC97CHANNELTYPE       m_nChannelType;                                 // Channel type
    DWORD                       m_dwPosition;                                   // Absolute channel position
                                                                                
protected:                                                                      
    CAc97Device *               m_pDevice;                                      // Pointer back to the parent device
    DWORD                       m_dwFlags;                                      // Object creation flags
    LPFNAC97CHANNELCALLBACK     m_pfnCallback;                                  // Interrupt callback function
    LPVOID                      m_pvCallbackContext;                            // Callback function context
    LPACIPRD                    m_pPrdl;                                        // Physical resource descriptor list
    DWORD                       m_dwPrdlAddress;                                // PRDL physical address
    LPVOID                      m_pvSilence;                                    // Silent packet data
    BYTE                        m_bPrdCount;                                    // Count of PRDs in the PRDL
    BYTE                        m_bCurrentPrd;                                  // Current index into the PRDL
    DWORD                       m_dwMode;                                       // Channel mode
    DWORD                       m_dwLastPosition;                               // Last position returned from GetPosition

public:
    CAc97Channel(CAc97Device *pDevice, AC97CHANNELTYPE nChannelType);
    ~CAc97Channel(void);

public:
    CAc97Channel &operator=(const CAc97Channel &);

public:
    // Initialization
    HRESULT Initialize(DWORD dwFlags = 0, LPFNAC97CHANNELCALLBACK pfnCallback = NULL, LPVOID pvContext = NULL);
    void Terminate(void);

    // Reference counting
    void Release(void);

    // Audio data packets
    DWORD GetFreePacketCount(void);
    void AttachPacket(LPCVOID pvBufferData, DWORD dwBufferSize);
    void AttachPacket(DWORD dwBufferAddress, DWORD dwBufferSize);
    void AttachBuffer(LPCVOID pvBufferData, DWORD dwBufferSize, DWORD dwPacketCount);
    void AttachBuffer(DWORD dwBufferAddress, DWORD dwBufferSize, DWORD dwPacketCount);

    // Channel state
    void Run(DWORD dwPosition = -1);
    void Pause(void);
    void Flush(BOOL fResetPosition = TRUE);
    void Discontinuity(void);
    void Reset(void);
    
    // Channel position
    DWORD GetPosition(void);

    // Channel mode
    void SetMode(DWORD dwMode);

protected:
    // Channel position
    void SetPosition(DWORD dwPosition);

    // Interrupts
    void ServiceInterrupt(void);

    // Resource descriptor list
    void SetPrdIndeces(BYTE bCurrentPrd, BYTE bPrdCount, BOOL fApplyCurrent, BOOL fApplyLast);

    // Register access
    BYTE PeekAciRegister8(DWORD dwRegister);
    void PokeAciRegister8(DWORD dwRegister, BYTE bValue);
    WORD PeekAciRegister16(DWORD dwRegister);
    void PokeAciRegister16(DWORD dwRegister, WORD wValue);
    DWORD PeekAciRegister32(DWORD dwRegister);
    void PokeAciRegister32(DWORD dwRegister, DWORD dwValue);
};

__inline void CAc97Device::ReleaseChannel(CAc97Channel *pChannel)
{
    ReleaseChannel(pChannel->m_nChannelType);
}

__inline void CAc97Channel::Release(void)
{
    m_pDevice->ReleaseChannel(this);
}

__inline void CAc97Channel::AttachPacket(LPCVOID pvBufferData, DWORD dwBufferSize)
{
    AttachPacket(MmGetPhysicalAddress((LPVOID)pvBufferData), dwBufferSize);
}

__inline void CAc97Channel::AttachBuffer(LPCVOID pvBufferData, DWORD dwBufferSize, DWORD dwPacketCount)
{
    AttachBuffer(MmGetPhysicalAddress((LPVOID)pvBufferData), dwBufferSize, dwPacketCount);
}

__inline DWORD CAc97Channel::GetFreePacketCount(void)
{
    return ACIPRDL_ENTRY_COUNT - m_bPrdCount;
}

__inline BYTE CAc97Channel::PeekAciRegister8(DWORD dwRegister)
{
    return m_pDevice->PeekAciRegister8(dwRegister + m_adwRegisterOffsets[m_nChannelType]);
}

__inline void CAc97Channel::PokeAciRegister8(DWORD dwRegister, BYTE bValue)
{
    m_pDevice->PokeAciRegister8(dwRegister + m_adwRegisterOffsets[m_nChannelType], bValue);
}

__inline WORD CAc97Channel::PeekAciRegister16(DWORD dwRegister)
{
    return m_pDevice->PeekAciRegister16(dwRegister + m_adwRegisterOffsets[m_nChannelType]);
}

__inline void CAc97Channel::PokeAciRegister16(DWORD dwRegister, WORD wValue)
{
    m_pDevice->PokeAciRegister16(dwRegister + m_adwRegisterOffsets[m_nChannelType], wValue);
}

__inline DWORD CAc97Channel::PeekAciRegister32(DWORD dwRegister)
{
    return m_pDevice->PeekAciRegister32(dwRegister + m_adwRegisterOffsets[m_nChannelType]);
}

__inline void CAc97Channel::PokeAciRegister32(DWORD dwRegister, DWORD dwValue)
{
    m_pDevice->PokeAciRegister32(dwRegister + m_adwRegisterOffsets[m_nChannelType], dwValue);
}
    
#endif // __cplusplus

#endif // __AC97_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\ac97.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ac97.cpp
 *  Content:    DirectSound AC '97 device driver.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/27/00    dereks  Created based on NVidia code.
 *
 ****************************************************************************/

#include "dsoundi.h"

//#define DPF_AC97 DPF_ABSOLUTE
#define DPF_AC97()


/****************************************************************************
 *
 *  CAc97Device
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::CAc97Device"

#ifdef AC97_AMR

const DWORD CAc97Device::m_dwVendorId = 0x8086;
const DWORD CAc97Device::m_dwDeviceId = 0x2415;
const DWORD CAc97Device::m_dwBusNumber = 0;
const DWORD CAc97Device::m_dwDeviceNumber = 31;
const DWORD CAc97Device::m_dwFunctionNumber = 5;
const DWORD CAc97Device::m_dwAc97RegisterBase = 0xD800;
const DWORD CAc97Device::m_dwAciRegisterBase = 0xDC00;

#else // AC97_AMR

#ifdef AC97_USE_MIO

const DWORD CAc97Device::m_dwAc97RegisterBase = XPCICFG_ACI_MEMORY_REGISTER_BASE_2 + AC97_MIO_BASE;
const DWORD CAc97Device::m_dwAciRegisterBase = XPCICFG_ACI_MEMORY_REGISTER_BASE_2 + ACI_MIO_BASE;

#else // AC97_USE_MIO

const DWORD CAc97Device::m_dwAc97RegisterBase = XPCICFG_ACI_IO_REGISTER_BASE_0;
const DWORD CAc97Device::m_dwAciRegisterBase = XPCICFG_ACI_IO_REGISTER_BASE_1;

#endif // AC97_USE_MIO

#endif // AC97_AMR

const WAVEFORMATEX CAc97Device::m_wfxFormat = 
{ 
    WAVE_FORMAT_PCM,    // wFormatTag
    2,                  // nChannels
    48000,              // nSamplesPerSec
    192000,             // nAvgBytesPerSec
    4,                  // nBlockAlign
    16,                 // wBitsPerSample
    0                   // cbSize
};

CAc97Device *CAc97Device::m_pDevice = NULL;
KINTERRUPT CAc97Device::m_Interrupt = { 0 };

CAc97Device::CAc97Device
(
    void
)
{
    DPF_ENTER();

    if(m_pDevice)
    {
        DPF_ERROR("The AC97 device driver is already running");
    }

    m_pDevice = this;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CAc97Device
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::~CAc97Device"

CAc97Device::~CAc97Device
(
    void
)
{
    DPF_ENTER();

    Terminate();

    m_pDevice = NULL;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::Initialize"

HRESULT
CAc97Device::Initialize
(
    DWORD                   dwFlags
)
{
    HRESULT                 hr                  = DS_OK;

#ifdef AC97_AMR

    DWORD                   dwRegisterValue;
    BYTE                    bInterruptLine;
    PCI_COMMON_CONFIG       PciConfig;
    PCI_SLOT_NUMBER         Slot;

#endif // AC97_AMR

    KIRQL                   Irql;
    ULONG                   ulInterruptVector;
    DWORD                   i;

    DPF_ENTER();

    //
    // Save the flags
    //
    
    m_dwFlags = dwFlags;

#ifdef AC97_AMR

    //
    // Poke the PCI controller to enable the AMR sound device
    //

    _outpd(0xCF8, 0x8000F8F0);

    dwRegisterValue = _inpd(0xCFC);

    if(dwRegisterValue & 0x200000)
    {
        _outpd(0xCFC, dwRegisterValue & ~0x200000);
    }

    //
    // Get the device's interrupt line, since it won't be in the PCI config
    //

    Slot.u.bits.DeviceNumber = m_dwDeviceNumber;
    Slot.u.bits.FunctionNumber = 0;
    Slot.u.bits.Reserved = 0;

    HalReadPCISpace(m_dwBusNumber, Slot.u.AsULONG, 0x61, &bInterruptLine, sizeof(bInterruptLine));

    //
    // Get the device's current PCI config data
    //

    Slot.u.bits.FunctionNumber = m_dwFunctionNumber;

    HalReadPCISpace(m_dwBusNumber, Slot.u.AsULONG, 0, &PciConfig, sizeof(PciConfig));

    ASSERT(m_dwVendorId == PciConfig.VendorID);
    ASSERT(m_dwDeviceId == PciConfig.DeviceID);

    //
    // Assign base addresses and IRQ
    //

    DPF_AC97("Using IRQ %x", (DWORD)bInterruptLine);

    PciConfig.Command = 5;

    PciConfig.u.type0.BaseAddresses[0] = m_dwAc97RegisterBase | 1;
    PciConfig.u.type0.BaseAddresses[1] = m_dwAciRegisterBase | 1;

    PciConfig.u.type0.InterruptLine = bInterruptLine;
    PciConfig.u.type0.InterruptPin = 0;

    HalWritePCISpace(m_dwBusNumber, Slot.u.AsULONG, 0, &PciConfig, sizeof(PciConfig));

#endif // AC97_AMR

    //
    // Make sure the CODEC is ready to be powered up
    //

    if(!CodecReady())
    {
        DPF_ERROR("CODEC not ready");
        hr = DSERR_NODRIVER;
    }
    
    //
    // Power up the CODEC
    //

    if(SUCCEEDED(hr))
    {
        hr = PowerUp();
    }

    //
    // Reset all channels
    //

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < NUMELMS(CAc97Channel::m_adwRegisterOffsets); i++)
        {
            PokeAciRegister8(CAc97Channel::m_adwRegisterOffsets[i] + X_CTRL, X_CTRL_RBMR);
        }
    }

    //
    // Initialize the interrupt DPC
    //

    if(SUCCEEDED(hr) && !(m_dwFlags & AC97_OBJECTF_DIRECTISR))
    {
        KeInitializeDpc(&m_dpc, AciInterruptDpcHandler, this);
    }

    //
    // Set up the interrupt handler
    //

    if(SUCCEEDED(hr))
    {

#ifdef AC97_AMR

        ulInterruptVector = HalGetInterruptVector(PciConfig.u.type0.InterruptLine, &Irql);

#else // AC97_AMR

        ulInterruptVector = HalGetInterruptVector(XPCICFG_ACI_IRQ, &Irql);

#endif // AC97_AMR

        KeInitializeInterrupt(&m_Interrupt, AciInterruptServiceRoutine, this, ulInterruptVector, Irql, LevelSensitive, TRUE);

        if(!KeConnectInterrupt(&m_Interrupt))
        {
            DPF_ERROR("Failed to connect interrupt");
            hr = DSERR_GENERIC;
        }
    }

    //
    // Unmute the CODEC
    //

    if(SUCCEEDED(hr))
    {
        if(!PokeAc97Register(AC97REG_FRONT_VOLUME, 0))
        {
            DPF_ERROR("Unable to set front volume");
            hr = DSERR_GENERIC;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(!PokeAc97Register(AC97REG_PCM_OUT_VOLUME, 0x0808))
        {
            DPF_ERROR("Unable to set PCM out volume");
            hr = DSERR_GENERIC;
        }
    }

    //
    // Register for HAL shutdown notification
    //

    if(SUCCEEDED(hr))
    {
        m_HalShutdownData.NotificationRoutine = AciShutdownNotifier;

        HalRegisterShutdownNotification(&m_HalShutdownData, TRUE);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Shuts down the driver object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::Terminate"

void
CAc97Device::Terminate
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();
    AutoIrql();

    //
    // Disconnect the interrupt handler
    //

    if(m_Interrupt.ServiceRoutine)
    {
        KeDisconnectInterrupt(&m_Interrupt);
        m_Interrupt.ServiceRoutine = NULL;
    }

    //
    // Clear any pending DPCs
    //

    if(DpcObject == m_dpc.Type)
    {
        KeRemoveQueueDpc(&m_dpc);
        m_dpc.Type = ~m_dpc.Type;
    }

    //
    // Unregister the shutdown handler
    //

    if(m_HalShutdownData.NotificationRoutine)
    {
        HalRegisterShutdownNotification(&m_HalShutdownData, FALSE);
        m_HalShutdownData.NotificationRoutine = NULL;
    }

    //
    // Free all channels
    //

    for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)
    {
        ReleaseChannel((AC97CHANNELTYPE)i);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CreateChannel
 *
 *  Description:
 *      Allocates a channel object.  The AC97 device object and it's channels
 *      are primitive enough that you can only allocate each channel once, and
 *      neither of them support ref counting.  Oh well...
 *
 *  Arguments:
 *      AC97CHANNELTYPE [in]: channel type.
 *      CAc97Channel ** [out]: receives channel object.  The caller can
 *                             release this object by calling ReleaseChannel,
 *                             but it's not required.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::CreateChannel"

HRESULT
CAc97Device::CreateChannel
(
    AC97CHANNELTYPE         nChannelType, 
    CAc97Channel **         ppChannel
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    AutoIrql();
    
    ASSERT(!m_apChannels[nChannelType]);

    hr = HRFROMP(m_apChannels[nChannelType] = NEW(CAc97Channel(this, nChannelType)));

    if(SUCCEEDED(hr) && ppChannel)
    {
        *ppChannel = m_apChannels[nChannelType];
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ReleaseChannel
 *
 *  Description:
 *      Releases a previously allocated channel.
 *
 *  Arguments:
 *      AC97CHANNELTYPE [in]: channel type.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::ReleaseChannel"

void
CAc97Device::ReleaseChannel
(
    AC97CHANNELTYPE         Channel
)
{
    DPF_ENTER();
    AutoIrql();
    
    DELETE(m_apChannels[Channel]);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AcquireCodecSemaphore
 *
 *  Description:
 *      Acquires access to the CODEC semaphore.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the semaphore was acquired.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::AcquireCodecSemaphore"

BOOL
CAc97Device::AcquireCodecSemaphore
(
    void
)
{
    DWORD                   dwAttempts  = 1000;
    BOOL                    fAcquired   = TRUE;

    DPF_ENTER();

    while(PeekAciRegister8(AC97_SEM4) & AC97_SEM4_OWNED)
    {
        if(!dwAttempts--)
        {
            DPF_ERROR("Failed to get CODEC semaphore");
            fAcquired = FALSE;
            break;
        }

        WaitRegisterRetry();
    }

    DPF_LEAVE(fAcquired);

    return fAcquired;
}


/****************************************************************************
 *
 *  CodecReady
 *
 *  Description:
 *      Checks the AC-Link state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the CODEC is ready.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::CodecReady"

BOOL
CAc97Device::CodecReady
(
    void
)
{
    BOOL                    fReady      = TRUE;
    DWORD                   dwAttempts  = 1000;
    DWORD                   dwValue;
    
    DPF_ENTER();

    //
    // Get the value of the control register.
    //

    dwValue = PeekAciRegister32(GLB_CTRL);
    
    //
    // If the AC_RST# line is low, raise it and do a cold reset.
    //

    if(!(dwValue & GLB_CTRL_COLD))
    {
        DPF_AC97("Performing cold reset");
        
        dwValue |= GLB_CTRL_COLD;

        PokeAciRegister32(GLB_CTRL, dwValue);
    }

    //
    // If the AC link is down, raise it and do a warm reset.  This is only
    // needed if agressive power management is used.
    //

    if(dwValue & GLB_CTRL_ACSD)
    {
        DPF_AC97("Performing warm reset");
        
        dwValue &= ~(GLB_CTRL_ACSD | GLB_CTRL_WARM);

        PokeAciRegister32(GLB_CTRL, dwValue);
    }

    //
    // Check to see if the ready bit is set.  This takes a maximum of 200us.
    //

    while(!(PeekAciRegister32(GLB_STATUS) & GLB_STATUS_PCR))
    {
        if(!dwAttempts--)
        {
            DPF_ERROR("Timed out waiting for ready bit");
            fReady = FALSE;
            break;
        }

        WaitRegisterRetry();
    }

    if(fReady)
    {
        DPF_AC97("CODEC ready");
    }

    DPF_LEAVE(fReady);

    return fReady;
}


/****************************************************************************
 *
 *  GetInterruptStatus
 *
 *  Description:
 *      Determines if there is an interrupt pending for the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: interrupt status.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::GetInterruptStatus"

DWORD
CAc97Device::GetInterruptStatus
(
    void
)
{
    static const DWORD      dwStatusMask    = GLB_STATUS_AOINT | GLB_STATUS_SOINT | GLB_STATUS_GPINT;

    return PeekAciRegister32(GLB_STATUS) & dwStatusMask;
}


/****************************************************************************
 *
 *  ServiceAciInterrupt
 *
 *  Description:
 *      Services interrupts for the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: bitmask of the channels that triggered the interrupt.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::ServiceAciInterrupt"

DWORD
CAc97Device::ServiceAciInterrupt
(
    void
)
{
    static const DWORD      adwChannelStatusMasks[AC97_CHANNELTYPE_COUNT] = 
    { 
        GLB_STATUS_AOINT, 
        GLB_STATUS_SOINT,
    };

    DWORD                   dwInterruptMask;
    DWORD                   dwStatus;
    WORD                    wChannelStatus;
    DWORD                   i;

    DPF_ENTER();

    //
    // Get the ACI interrupt status bits
    //

    if(dwStatus = GetInterruptStatus())
    {
        //
        // Set the interrupt mask to a non-zero value that won't conflict
        // with any of the channel-specific values.
        //
        
        dwInterruptMask = 0x80000000;

        //
        // Handle channel interrupts
        //
        
        for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)
        {
            if(dwStatus & adwChannelStatusMasks[i])
            {
                if(m_apChannels[i])
                {
                    //
                    // Ok, this channel had an interrupt.  The only ones we
                    // really care about are buffer completion interrupts.
                    // If either of those are set in the channel status 
                    // registers, increment the channel's count of pending
                    // completions and schedule a DPC to handle them.
                    //

                    wChannelStatus = m_apChannels[i]->PeekAciRegister16(X_STATUS);

                    if(wChannelStatus & X_STATUS_FIFOE) 
                    {
                        DPF_AC97("(channel %lu) FIFO underrun", i);
                    }

                    if(wChannelStatus & X_STATUS_CIELV)
                    {
                        DPF_AC97("(channel %lu) Current index equals last valid", i);
                    }

                    if(wChannelStatus & X_STATUS_LVBCI)
                    {
                        DPF_AC97("(channel %lu) Last valid buffer completion interrupt", i);
                    }
                
                    if(wChannelStatus & X_STATUS_BCI)
                    {
                        DPF_AC97("(channel %lu) Buffer completed", i);

                        dwInterruptMask |= AC97_CHANNELINTERRUPT(i);

                        if(m_dwFlags & AC97_OBJECTF_DIRECTISR)
                        {
                            m_apChannels[i]->ServiceInterrupt();
                        }
                        else
                        {
                            m_abPendingBufferCompletions[i][0]++;
                        }
                    }

                    m_apChannels[i]->PokeAciRegister16(X_STATUS, wChannelStatus);
                }
                else
                {
                    DPF_WARNING("Channel %lu not allocated!", i);
                }
            }
        }
    
        //
        // Schedule a DPC to handle any buffer completion interrupts
        //

        if(!(m_dwFlags & AC97_OBJECTF_DIRECTISR) && (dwInterruptMask & AC97_CHANNELINTERRUPT_MASK))
        {
            KeInsertQueueDpc(&m_dpc, NULL, NULL);
        }

        //
        // Acknowlege the interrupt
        //
        
        PokeAciRegister32(GLB_STATUS, dwStatus & ~GLB_STATUS_GPINT);
    }
    else
    {
        //
        // Not our interrupt
        //

        dwInterruptMask = 0;
    }

    DPF_LEAVE(dwInterruptMask);

    return dwInterruptMask;
}


/****************************************************************************
 *
 *  ServiceAciInterruptDpc
 *
 *  Description:
 *      Services interrupts for the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::ServiceAciInterruptDpc"

void
CAc97Device::ServiceAciInterruptDpc
(
    void
)
{
    BOOL                    fContinue;
    DWORD                   i;

    DPF_ENTER();

    do
    {
        //
        // Copy live buffer completion counts to cached
        //

        KeSynchronizeExecution(&m_Interrupt, AciSynchronizationRoutine, this);

        //
        // Handle all pending buffer completions
        //

        for(i = 0, fContinue = FALSE; i < AC97_CHANNELTYPE_COUNT; i++)
        {
            if(m_abPendingBufferCompletions[i][1])
            {
                fContinue = TRUE;

                if(m_apChannels[i])
                {
                    do
                    {
                        m_apChannels[i]->ServiceInterrupt();
                    }
                    while(--m_abPendingBufferCompletions[i][1]);
                }
                else
                {
                    m_abPendingBufferCompletions[i][1] = 0;
                }
            }
        }
    }
    while(fContinue);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SynchronizeAciInterrupt
 *
 *  Description:
 *      Interrupt synchonization function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::SynchronizeAciInterrupt"

void
CAc97Device::SynchronizeAciInterrupt
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();

    //
    // Copy live pending buffer completions to cached and clear the live
    // ones.
    //

    for(i = 0; i < AC97_CHANNELTYPE_COUNT; i++)
    {
        m_abPendingBufferCompletions[i][1] += m_abPendingBufferCompletions[i][0];

        m_abPendingBufferCompletions[i][0] = 0;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  PeekAc97Register
 *
 *  Description:
 *      Gets the contents of an AC '97 register.
 *
 *  Arguments:
 *      AC97REGISTER [in]: register.
 *      LPWORD [out]: register value.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::PeekAc97Register"

BOOL
CAc97Device::PeekAc97Register
(
    AC97REGISTER            reg,
    LPWORD                  pwValue
)
{
    DWORD                   dwStatus;
    BOOL                    fSuccess;

    DPF_ENTER();
    
    //
    // Acquire the CODEC semaphore
    //

    fSuccess = AcquireCodecSemaphore();

    //
    // Read the contents of the register
    //

    if(fSuccess)
    {
        *pwValue = PeekRegister16(m_dwAc97RegisterBase + (reg * 2));
    }

    //
    // Make sure the read was successful
    //

    if(fSuccess)
    {
        if((dwStatus = PeekAciRegister32(GLB_STATUS)) & GLB_STATUS_RCS)
        {
            //
            // Nope.  Clear the bit.
            //

            DPF_ERROR("AC '97 register peek failed");
            
            PokeAciRegister32(GLB_STATUS, dwStatus & ~GLB_STATUS_RCS);
            
            fSuccess = FALSE;
        }
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/****************************************************************************
 *
 *  PokeAc97Register
 *
 *  Description:
 *      Writes the contents of an AC '97 register.
 *
 *  Arguments:
 *      AC97REGISTER [in]: register.
 *      WORD [in]: register value.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::PokeAc97Register"

BOOL
CAc97Device::PokeAc97Register
(
    AC97REGISTER            reg,
    WORD                    wValue
)
{
    BOOL                    fSuccess;

    DPF_ENTER();
    
    //
    // Acquire the CODEC semaphore
    //

    fSuccess = AcquireCodecSemaphore();

    //
    // Write to the register
    //

    if(fSuccess)
    {
        PokeRegister16(m_dwAc97RegisterBase + (reg * 2), wValue);
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/****************************************************************************
 *
 *  VerifyPokeAc97Register
 *
 *  Description:
 *      Writes the contents of an AC '97 register and verifies that it 
 *      stuck.
 *
 *  Arguments:
 *      AC97REGISTER [in]: register.
 *      WORD [in]: register value.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::VerifyPokeAc97Register"

BOOL
CAc97Device::VerifyPokeAc97Register
(
    AC97REGISTER            reg,
    WORD                    wValue
)
{
    WORD                    wNewValue;
    BOOL                    fSuccess;

    DPF_ENTER();
    
    //
    // Write the new value
    //

    fSuccess = PokeAc97Register(reg, wValue);

    //
    // Read back the new value
    //

    if(fSuccess)
    {
        fSuccess = PeekAc97Register(reg, &wNewValue);
    }

    //
    // Did it stick?
    //

    if(fSuccess && (wValue != wNewValue))
    {
        fSuccess = FALSE;
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/****************************************************************************
 *
 *  PowerUp
 *
 *  Description:
 *      Sets the CODEC to full power.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Device::PowerUp"

HRESULT
CAc97Device::PowerUp
(
    void
)
{
    HRESULT                 hr  = DS_OK;
    
    DPF_ENTER();

    //
    // Set the CODEC to full power
    //

    if(!PokeAc97Register(AC97REG_POWERDOWN, AC97REG_PCS_FULL_POWER))
    {
        DPF_ERROR("Failed to set power state");
        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CAc97Channel
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CAc97Device * [in]: parent device.
 *      DWORD [in]: channel register base offset.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::CAc97Channel"

const DWORD CAc97Channel::m_adwRegisterOffsets[AC97_CHANNELTYPE_COUNT] = 
{ 
    AO_BL_BASE, 
    SO_BL_BASE,
};

const DWORD CAc97Channel::m_dwSilenceSize = 0x2000;

CAc97Channel::CAc97Channel
(
    CAc97Device *           pDevice,
    AC97CHANNELTYPE         nChannelType
)
:   m_nChannelType(nChannelType)
{

    DPF_ENTER();

    //
    // Initialize defaults
    //

    m_dwMode = DSAC97_MODE_DEFAULT;

    //
    // Save a pointer back to the parent device.  Note that we're not 
    // AddRef'ing it, since the device controls our construction and 
    // destruction.
    //

    m_pDevice = pDevice;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CAc97Channel
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::~CAc97Channel"

CAc97Channel::~CAc97Channel
(
    void
)
{
    DPF_ENTER();
    
    Terminate();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *      LPFNAC97CHANNELCALLBACK [in]: interrupt callback function.
 *      LPVOID [in]: interrupt callback context.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Initialize"

HRESULT
CAc97Channel::Initialize
(
    DWORD                   dwFlags,
    LPFNAC97CHANNELCALLBACK pfnCallback,
    LPVOID                  pvContext
)
{
    HRESULT                 hr;
    
    DPF_ENTER();
    AutoIrql();


    m_dwFlags = dwFlags;
    m_pfnCallback = pfnCallback;
    m_pvCallbackContext = pvContext;

    //
    // Allocate the PRDL
    //

    hr = HRFROMP(m_pPrdl = PHYSALLOC(ACIPRD, ACIPRDL_ENTRY_COUNT, PAGE_SIZE, PAGE_READWRITE));

    if(SUCCEEDED(hr))
    {
        m_dwPrdlAddress = MmGetPhysicalAddress(m_pPrdl);
    }

    //
    // If we're a stream, allocate a packet of silence to loop on when we
    // starve.
    //

    if(SUCCEEDED(hr) && (dwFlags & AC97CHANNEL_OBJECTF_STREAM))
    {
        hr = HRFROMP(m_pvSilence = PHYSALLOC(BYTE, m_dwSilenceSize, PAGE_SIZE, PAGE_READWRITE));
    }

    //
    // Reset the channel
    //

    if(SUCCEEDED(hr))
    {
        Reset();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Uninitializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Terminate"

void
CAc97Channel::Terminate
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    //
    // Reset the channel
    //

    Flush();
    
    //
    // Free resources
    //

    PHYSFREE(m_pPrdl);
    PHYSFREE(m_pvSilence);

    m_dwPrdlAddress = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AttachPacket
 *
 *  Description:
 *      Attaches an audio data packet to be played.
 *
 *  Arguments:
 *      DWORD [in]: data buffer physical memory address.
 *      DWORD [in]: data buffer size, in bytes.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::AttachPacket"

void
CAc97Channel::AttachPacket
(
    DWORD                   dwBufferAddress,
    DWORD                   dwBufferSize
)
{
    BYTE                    bPrdIndex;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(m_bPrdCount < ACIPRDL_ENTRY_COUNT);
    ASSERT((dwBufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8)) <= 0xFFFF);
    ASSERT(!(dwBufferSize % m_pDevice->m_wfxFormat.nBlockAlign));

    if(!(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM))
    {
        ASSERT(!m_bCurrentPrd);
    }

    //
    // If a discontinuity has been signaled, but another packet has been
    // attached, we can remove the discontinuity by resetting the flags and
    // removing the silence packet.  The easiest way to remove the silence
    // packet is to just stomp on the PRD.
    //

    if(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY)
    {
        ASSERT(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM);
        ASSERT(m_bPrdCount);
        
        m_dwFlags &= ~AC97CHANNEL_OBJECTF_DISCONTINUITY;

        m_bPrdCount--;
    }

    //
    // Add the PRD to the end of the list.  We're assuming that the buffer
    // is already locked.
    //

    bPrdIndex = (m_bCurrentPrd + m_bPrdCount) & ACIPRDL_ENTRY_MASK;

    m_pPrdl[bPrdIndex].dwPhysicalAddress = dwBufferAddress;
    m_pPrdl[bPrdIndex].wLength = LOWORD(dwBufferSize / (m_pDevice->m_wfxFormat.wBitsPerSample / 8));
    m_pPrdl[bPrdIndex].wReserved = 0;
    m_pPrdl[bPrdIndex].fBufferUnderrunPolicy = TRUE;
    m_pPrdl[bPrdIndex].fInterruptOnCompletion = TRUE;

    DPF_AC97("(channel %lu) PRD %d set to %x %x", m_nChannelType, (int)bPrdIndex, m_pPrdl[bPrdIndex].dwPhysicalAddress, (DWORD)m_pPrdl[bPrdIndex].wLength);

    //
    // Inform the hardware that the last valid PRD has changed
    //

    SetPrdIndeces(m_bCurrentPrd, m_bPrdCount + 1, FALSE, TRUE);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AttachBuffer
 *
 *  Description:
 *      Attaches an audio data packet to be played.
 *
 *  Arguments:
 *      DWORD [in]: data buffer physical memory address.
 *      DWORD [in]: data buffer size, in bytes.
 *      DWORD [in]: count of packets to split the buffer into.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::AttachBuffer"

void
CAc97Channel::AttachBuffer
(
    DWORD                   dwBufferAddress,
    DWORD                   dwBufferSize,
    DWORD                   dwPacketCount
)
{
    DPF_ENTER();
    AutoIrql();

    //
    // Attach the buffer in as many packets as were specified
    //

    ASSERT(!(dwBufferSize % dwPacketCount));

    dwBufferSize /= dwPacketCount;

    while(dwPacketCount--)
    {
        AttachPacket(dwBufferAddress, dwBufferSize);

        dwBufferAddress += dwBufferSize;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Discontinuity
 *
 *  Description:
 *      Signals that the stream may starve.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Discontinuity"

void
CAc97Channel::Discontinuity
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    ASSERT(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM);

    //
    // Attach a packet of silence that the DMA can spin on when we starve.
    //

    if(!(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY))
    {
        AttachPacket(m_pvSilence, m_dwSilenceSize);

        m_dwFlags |= AC97CHANNEL_OBJECTF_DISCONTINUITY;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceInterrupt
 *
 *  Description:
 *      Services interrupts for the channel.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::ServiceInterrupt"

void
CAc97Channel::ServiceInterrupt
(
    void
)
{
    DPF_ENTER();

    if(m_bPrdCount)
    {
        //
        // A buffer has completed.  If we're a stream, we'll need to increment
        // the first PRD index and decrement the count in order to detach the
        // packet.
        //
        // If we're out of PRDs, stop the DMA.  This only happens because you
        // starved the stream.  Until we get a chance to stop the DMA, it's 
        // going to continue to play the last PRD over again.  If you know 
        // you're going to starve me, attach a packet of silence.
        //

        m_dwPosition += m_pPrdl[m_bCurrentPrd].wLength;

        if(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM)
        {
            if(m_bPrdCount > 2)
            {
                SetPrdIndeces(m_bCurrentPrd + 1, m_bPrdCount - 1, FALSE, FALSE);
            }
            else
            {
                if(!(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY))
                {
                    DPF_WARNING("AC'97 stream starving");
                }
                
                Flush(FALSE);
            }
        }
        else
        {
            SetPrdIndeces(m_bCurrentPrd + 1, m_bPrdCount, FALSE, FALSE);
        }

        //
        // Notify the callback function
        //

        if(m_pfnCallback)
        {
            m_pfnCallback(m_pvCallbackContext);
        }
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Resets DMA registers.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Reset"

void
CAc97Channel::Reset
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    DPF_AC97("(channel %lu) Resetting DMA registers", m_nChannelType);

    //
    // Reset the channel
    //

    PokeAciRegister8(X_CTRL, X_CTRL_RBMR);

    //
    // Wait for the reset to be acknowledged
    //

    while(PeekAciRegister8(X_CTRL) & X_CTRL_RBMR);

    //
    // Set the PRDL location
    //

    PokeAciRegister32(X_BL_BASE, m_dwPrdlAddress);

    //
    // If this is the S/PDIF channel, set the output mode
    //

    if(AC97_CHANNELTYPE_DIGITAL == m_nChannelType)
    {
        PokeAciRegister32(X_STWD, m_dwMode);
    }

    //
    // Reset PRD indeces
    //

    SetPrdIndeces(m_bCurrentPrd, m_bPrdCount, TRUE, TRUE);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Resets the object and flushes all packets.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to reset the cursor position.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Flush"

void
CAc97Channel::Flush
(
    BOOL                    fResetPosition
)
{
    BYTE                    bState;

    DPF_ENTER();
    AutoIrql();

    //
    // Stop the DMA
    //
    
    Pause();

    //
    // Reset the channel
    //

    Reset();

    //
    // Update PRD indeces
    //

    SetPrdIndeces(0, 0, TRUE, TRUE);

    //
    // Remove any existing discontinuity
    //

    m_dwFlags &= ~AC97CHANNEL_OBJECTF_DISCONTINUITY;

    //
    // Reset stored positions
    //

    if(fResetPosition)
    {
        m_dwPosition = 0;
        m_dwLastPosition = 0;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Run
 *
 *  Description:
 *      Starts the DMA running.
 *
 *  Arguments:
 *      DWORD [in]: PRD position.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Run"

void
CAc97Channel::Run
(
    DWORD                   dwPosition
)
{
    DPF_ENTER();
    AutoIrql();

    ASSERT(m_bPrdCount);

    //
    // Check the channel status.  If the DMA is halted, we'll have to
    // reset before we can run.
    //

    if(PeekAciRegister16(X_STATUS) & X_STATUS_DCH)
    {
        Reset();
    }

    //
    // Set the buffer position
    //

    if(-1 != dwPosition)
    {
        SetPosition(dwPosition);
    }

    //
    // Set the channel to RUN state and enable interrupts
    //

    PokeAciRegister8(X_CTRL, X_CTRL_IOCE | X_CTRL_FEIE | X_CTRL_LVBIE | X_CTRL_RPBM);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Pause
 *
 *  Description:
 *      Pauses the DMA.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::Pause"

void
CAc97Channel::Pause
(
    void
)
{
    DPF_ENTER();
    AutoIrql();

    PokeAciRegister8(X_CTRL, 0);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetPrdIndeces
 *
 *  Description:
 *      Sets the current PRDL index and count.
 *
 *  Arguments:
 *      DWORD [in]: index.
 *      DWORD [in]: count.
 *      BOOL [in]: TRUE to apply the current PRD index to the hardware.
 *                 In some cases, we may be calling this function late and it
 *                 may be better not to overwrite the hardware value.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::SetPrdIndeces"

void
CAc97Channel::SetPrdIndeces
(
    BYTE                    bCurrentPrd,
    BYTE                    bPrdCount,
    BOOL                    fApplyCurrent,
    BOOL                    fApplyLast
)
{
    BYTE                    bLastPrd;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Calculate the current and last valid PRDs
    //

    if(bPrdCount)
    {
        ASSERT(bPrdCount <= ACIPRDL_ENTRY_COUNT);

        bLastPrd = bCurrentPrd + bPrdCount - 1;

        if(m_dwFlags & AC97CHANNEL_OBJECTF_STREAM)
        {
            bCurrentPrd &= ACIPRDL_ENTRY_MASK;
            bLastPrd &= ACIPRDL_ENTRY_MASK;
        }
        else
        {
            bCurrentPrd %= bPrdCount;
            bLastPrd %= bPrdCount;
        }
    }
    else
    {
        bCurrentPrd = 0;
        bLastPrd = 0;
    }

    //
    // Inform the hardware
    //
    
    if(fApplyCurrent)
    {
        PokeAciRegister8(X_CUR_IDX, bCurrentPrd);
    }

    if(fApplyLast)
    {
        PokeAciRegister8(X_LST_IDX, bLastPrd);
    }

    m_bCurrentPrd = bCurrentPrd;
    m_bPrdCount = bPrdCount;

    DPF_AC97("(channel %lu) PRD indeces set to %d, %d (%d)", m_nChannelType, (int)bCurrentPrd, (int)bLastPrd, (int)bPrdCount);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the digital channel's output mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::SetMode"

void
CAc97Channel::SetMode
(
    DWORD                   dwMode
)
{
    BYTE                    bState;
    
    DPF_ENTER();
    AutoIrql();

    if(AC97_CHANNELTYPE_DIGITAL == m_nChannelType)
    {
        //
        // Save the mode
        //

        m_dwMode = dwMode;

        //
        // Update the STWD register
        //

        PokeAciRegister32(X_STWD, m_dwMode);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the buffer or stream position
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: absolute stream position.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::GetPosition"

DWORD
CAc97Channel::GetPosition
(
    void
)
{
    DWORD               dwLastPosition;
    DWORD               dwPosition;
    DWORD               dwLength;
    BYTE                bCurrentPrd;
        
    DPF_ENTER();

    if(m_bPrdCount)
    {
        //
        // Calculate the position until we get the same position twice.
        // That way, we don't have to synchronize this function with the
        // ISR.
        //
    
        dwPosition = -1;

        int iTry = 0;

        while(TRUE)
        {
            iTry++;
            
            //
            // Save the last position we got
            //

            dwLastPosition = dwPosition;

            //
            // Check the PRD index register and compare it to our own index.
            // There seems to be some delay between when the DMA program
            // changes PRDs and when we get notified.
            //

            if((bCurrentPrd = PeekAciRegister8(X_CUR_IDX)) == m_bCurrentPrd)
            {

#ifdef DEBUG
                //
                // Since they're in sync, we should never be playing the
                // discontinuity packet.
                //

                if(m_dwFlags & AC97CHANNEL_OBJECTF_DISCONTINUITY)
                {
                    if(m_bPrdCount <= 1)
                    {
                        if((bCurrentPrd = PeekAciRegister8(X_CUR_IDX)) == m_bCurrentPrd)
                        {
                            ASSERTMSG("Improperly looping on the discontinuity packet");
                        }
                    }
                }

#endif // DEBUG

                //
                // The position in the ACI register is really the count of samples 
                // left to transfer.
                //

                dwLength = m_pPrdl[m_bCurrentPrd].wLength;

                dwPosition = PeekAciRegister16(X_CUR_POS);

                if(dwPosition <= dwLength)
                {
                    dwPosition = dwLength - dwPosition;
                }
                else
                {
                    dwPosition = 0;
                }
            }
            else
            {
                //
                // Our internal state and the hardware's aren't in synch.  Simply
                // return that we're at the end of the current packet
                //

                dwPosition = m_pPrdl[m_bCurrentPrd].wLength;
            }

            //
            // Add the absolute stream position.  If you're a buffer, well, you'll
            // need to MOD this value with the buffer size.  We don't currently 
            // have any buffer clients of this function, so why bother writing
            // the code?
            //

            dwPosition += m_dwPosition;

            //
            // Compare this position to the last one we calculated.  If they 
            // match, we can quit looping.
            //

            if(dwLastPosition == dwPosition)
            {
                //
                // Compare this position to the last one we returned.  If the 
                // current position is less than the last one, the buffer has 
                // wrapped, but the interrupt hasn't happened yet.
                //

                if(dwPosition >= m_dwLastPosition)
                {
                    m_dwLastPosition = dwPosition;
                }
                else
                {
                    dwPosition = m_dwLastPosition;
                }

                break;
            }

            //
            // If we're at raised IRQL, we can't loop
            //

            if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
            {
                break;
            }
        }
    }
    else
    {
        dwPosition = m_dwPosition;
    }

    //
    // Convert sample position to bytes
    //

    dwPosition *= m_pDevice->m_wfxFormat.wBitsPerSample / 8;

    DPF_LEAVE(dwPosition);

    return dwPosition;
}

#endif


/****************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the current PRD-relative position.
 *
 *  Arguments:
 *      DWORD [in]: PRD position.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97Channel::SetPosition"

void
CAc97Channel::SetPosition
(
    DWORD               dwPosition
)
{
    DWORD               dwLength;

    DPF_ENTER();

    //
    // Make sure we're stopped
    //

    ASSERT(!PeekAciRegister8(X_CTRL));

    //
    // Convert byte position to samples
    //

    dwPosition /= m_pDevice->m_wfxFormat.wBitsPerSample / 8;

    //
    // Convert buffer position to samples remaining
    //

    dwLength = m_pPrdl[m_bCurrentPrd].wLength;
    ASSERT(dwPosition <= dwLength);
    
    dwPosition = dwLength - dwPosition;

    //
    // Set the position
    //

    ASSERT(dwPosition < 0xFFFF);
    PokeAciRegister16(X_CUR_POS, (WORD)dwPosition);

    //
    // Clear the last returned position
    //

    m_dwLastPosition = 0;

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\ac97reg.h ===
//****************************************************************************
//****************************************************************************
//
// ac97reg.h
//
//
//
// Description:
// This file contains the codec register descriptions.
//
//
// Copyright (c) 2000 nVidia Corporation.
//
//****************************************************************************
//****************************************************************************




#ifndef _AC97REG_H_
#define _AC97REG_H_


//****************************************************************************
//****************************************************************************
//
// Defines
//
//****************************************************************************
//****************************************************************************

//
// These are the AC'97 registers found in the 2.1 specification.
//
typedef enum
{
    AC97REG_RESET = 0,
    AC97REG_FRONT_VOLUME,               // 0x02
    AC97REG_HEADPHONE_VOLUME,           // 0x04
    AC97REG_MONOOUT_VOLUME,             // 0x06
    AC97REG_MASTER_TONE,                // 0x08
    AC97REG_PCBEEP_VOLUME,              // 0x0a
    AC97REG_PHONE_VOLUME,               // 0x0c
    AC97REG_MIC_VOLUME,                 // 0x0e
    AC97REG_LINE_IN_VOLUME,             // 0x10
    AC97REG_CD_VOLUME,                  // 0x12
    AC97REG_VIDEO_VOLUME,               // 0x14
    AC97REG_AUX_VOLUME,                 // 0x16
    AC97REG_PCM_OUT_VOLUME,             // 0x18
    AC97REG_RECORD_SELECT,              // 0x1a
    AC97REG_RECORD_GAIN,                // 0x1c
    AC97REG_RECORD_GAIN_MIC,            // 0x1e
    AC97REG_GENERAL = 0x10,             // 0x20
    AC97REG_3D_CTRL,                    // 0x22
    AC97REG_RESERVED0,                  // 0x24
    AC97REG_POWERDOWN,                  // 0x26

    //
    // AC97 2.0 registers (0x28 - 0x3a)
    //
    AC97REG_EXT_AUDIO_ID,               // 0x28
    AC97REG_EXT_AUDIO_CTRL,             // 0x2a
    AC97REG_FRONT_RATE,                 // 0x2c
    AC97REG_SURR_RATE,                  // 0x2e
    AC97REG_LFE_RATE,                   // 0x30
    AC97REG_LR_RATE,                    // 0x32
    AC97REG_MIC_RATE,                   // 0x34
    AC97REG_6CH_VOL_CLFE,               // 0x36
    AC97REG_6CH_VOL_SURR,               // 0x38
    AC97REG_RESERVED1,                  // 0x3a

    //
    // Modem registers (0x3c - 0x58)
    //
    AC97REG_EXT_MODEM_ID,               // 0x3c
    AC97REG_EXT_MODEM_CTRL,             // 0x3e
    AC97REG_LINE1_RATE = 0x20,          // 0x40
    AC97REG_LINE2_RATE,                 // 0x42
    AC97REG_HANDSET_RATE,               // 0x44
    AC97REG_LINE1_LEVEL,                // 0x46
    AC97REG_LINE2_LEVEL,                // 0x48
    AC97REG_HANDSET_LEVEL,              // 0x4a
    AC97REG_GPIO_CONFIG,                // 0x4c
    AC97REG_GPIO_POLARITY,              // 0x4e
    AC97REG_GPIO_STICKY,                // 0x50
    AC97REG_GPIO_WAKEUP,                // 0x52
    AC97REG_GPIO_STATUS,                // 0x54
    AC97REG_MISC_MODEM_CTRL,            // 0x56
    AC97REG_RESERVED2,                  // 0x58

    //
    // Vendor reserved registers (0x5a - 0x7a)
    //
    AC97REG_VENDOR_RESERVED0,           // 0x5a
    AC97REG_VENDOR_RESERVED1,           // 0x5c
    AC97REG_VENDOR_RESERVED2,           // 0x5e
    AC97REG_VENDOR_RESERVED3 = 0x30,    // 0x60
    AC97REG_VENDOR_RESERVED4,           // 0x62
    AC97REG_VENDOR_RESERVED5,           // 0x64
    AC97REG_VENDOR_RESERVED6,           // 0x66
    AC97REG_VENDOR_RESERVED7,           // 0x68
    AC97REG_VENDOR_RESERVED8,           // 0x6a
    AC97REG_VENDOR_RESERVED9,           // 0x6c
    AC97REG_VENDOR_RESERVED10,          // 0x6e
    AC97REG_VENDOR_RESERVED11,          // 0x70
    AC97REG_VENDOR_RESERVED12,          // 0x72
    AC97REG_VENDOR_RESERVED13,          // 0x74
    AC97REG_VENDOR_RESERVED14,          // 0x76
    AC97REG_VENDOR_RESERVED15,          // 0x78
    AC97REG_VENDOR_RESERVED16,          // 0x7a

    //
    // Vendor IDs (0x7c - 0x7e)
    //
    AC97REG_VENDOR_ID1 = 0x3e,          // 0x7c
    AC97REG_VENDOR_ID2,                 // 0x7e


    AC97REG_INVALID
} AC97REGISTER;
#define FIRST_AC97REG       AC97REG_RESET
#define LAST_AC97REG        AC97REG_VENDOR_ID2
#define NUM_AC97REGS        AC97REG_INVALID


//
// Reset Register Bit Defines
//
#define AC97REG_RESET_VALUE                         0x0000

#define AC97REG_RESET_ID0                           0x0001  // Dedicated Mic In Channel
#define AC97REG_RESET_ID1                           0x0002  // Reserved
#define AC97REG_RESET_ID2                           0x0004  // Bass & Treble Control
#define AC97REG_RESET_ID3                           0x0008  // Simulated Stereo
#define AC97REG_RESET_ID4                           0x0010  // Headphone Out Support
#define AC97REG_RESET_ID5                           0x0020  // Loudness Support
#define AC97REG_RESET_ID6                           0x0040  // 18-bit DAC Resolution
#define AC97REG_RESET_ID7                           0x0080  // 20-bit DAC Resolution
#define AC97REG_RESET_ID8                           0x0100  // 18-bit ADC Resolution
#define AC97REG_RESET_ID9                           0x0200  // 20-bit ADC Resolution


//
// 3D Bits Defines
//
#define AC97REG_RESET_3D_MASK                       0x7c00
#define AC97REG_RESET_3D_SHIFT                      10

#define AC97REG_RESET_3D_NONE                       0x0000
#define AC97REG_RESET_3D_ANALOG_DEVICES             0x0400
#define AC97REG_RESET_3D_CREATIVE                   0x0800
#define AC97REG_RESET_3D_NATIONAL                   0x0c00
#define AC97REG_RESET_3D_YAMAHA                     0x1000
#define AC97REG_RESET_3D_BBE                        0x1400
#define AC97REG_RESET_3D_CRYSTAL                    0x1800
#define AC97REG_RESET_3D_QSOUND                     0x1c00
#define AC97REG_RESET_3D_SPATIALIZER                0x2000
#define AC97REG_RESET_3D_SRS                        0x2400
#define AC97REG_RESET_3D_PLATFORM_TECH              0x2800
#define AC97REG_RESET_3D_AKM                        0x2c00
#define AC97REG_RESET_3D_AUREAL                     0x3000
#define AC97REG_RESET_3D_AZTECH                     0x3400
#define AC97REG_RESET_3D_BINAURA                    0x3800
#define AC97REG_RESET_3D_ESS                        0x3c00
#define AC97REG_RESET_3D_HARMAN_INT                 0x4000
#define AC97REG_RESET_3D_NVIDIA                     0x4400
#define AC97REG_RESET_3D_PHILIPS                    0x4800
#define AC97REG_RESET_3D_TI                         0x4c00
#define AC97REG_RESET_3D_VLSI                       0x5000
#define AC97REG_RESET_3D_TRITECH                    0x5400
#define AC97REG_RESET_3D_REALTEK                    0x5800
#define AC97REG_RESET_3D_SAMSUNG                    0x5c00
#define AC97REG_RESET_3D_WOLFSON                    0x6000
#define AC97REG_RESET_3D_DELTA_INTEGRATION          0x6400
#define AC97REG_RESET_3D_SIGMATEL                   0x6800
#define AC97REG_RESET_3D_UNDEFINED0                 0x6c00
#define AC97REG_RESET_3D_ROCKWELL                   0x7000


//
// Volume most significant bit masks
//
#define AC97REG_VOLUME_LEFT_MSB_MASK                0x2000  // Determine bit resolution
#define AC97REG_VOLUME_RIGHT_MSB_MASK               0x0020  // Determine bit resolution
#define AC97REG_VOLUME_LEFT_MSB_UNSUPPORTED_MASK    0x1f00  // Mask off unsupported bits
#define AC97REG_VOLUME_RIGHT_MSB_UNSUPPORTED_MASK   0x001f  // Mask off unsupported bits


//
// Front Volume Register bit defines
//
#define AC97REG_FRONT_DEFAULT                       0x8000  // The default register value
#define AC97REG_FRONT_VOLUME_UNMUTED                0x0000  // The unmuted value
#define AC97REG_FRONT_MSB_MASK                      (AC97REG_VOLUME_LEFT_MSB_MASK | AC97REG_VOLUME_RIGHT_MSB_MASK)


//
// Headphone Volume Register bit defines
//
#define AC97REG_HEADPHONE_DEFAULT                   0x8000  // The default register value
#define AC97REG_HPHONE_MSB_MASK                     (AC97REG_VOLUME_LEFT_MSB_MASK | AC97REG_VOLUME_RIGHT_MSB_MASK)


//
// Master Mono Volume Register bit defines
//
#define AC97REG_MONOOUT_DEFAULT                     0x8000  // The default register value
#define AC97REG_MONOOUT_MSB_MASK                    AC97REG_VOLUME_RIGHT_MSB_MASK


//
// Tone Register bit defines
//
#define AC97REG_TONE_BYPASS_VALUE                   0x0f0f  // Tone bypass value
#define AC97REG_BASS_LSB_MASK                       0x0100  // Determine bit resolution
#define AC97REG_TREBLE_LSB_MASK                     0x0001  // Determine bit resolution


//
// PC BEEP Register bit defines
//
#define AC97REG_PCBEEP_DEFAULT                      0x8000  // The default register value


//
// Phone Register bit defines
//
#define AC97REG_PHONE_DEFAULT                       0x8008  // The default register value


//
// Video Register bit defines
//
#define AC97REG_VIDEO_DEFAULT                       0x8808  // The default register value


//
// Aux Register bit defines
//
#define AC97REG_AUX_DEFAULT                         0x8808  // The default register value


//
// Record Select Control Register bit defines
//
#define AC97REG_RSC_MIC                             0x0000  // Microphone
#define AC97REG_RSC_CD                              0x0001  // CD
#define AC97REG_RSC_VIDEO                           0x0002  // Video
#define AC97REG_RSC_AUX                             0x0003  // AUX
#define AC97REG_RSC_LINEIN                          0x0004  // Line In
#define AC97REG_RSC_STEREO_MIX                      0x0005  // Stereo Mix
#define AC97REG_RSC_MONO_MIX                        0x0006  // Mono Mix
#define AC97REG_RSC_PHONE                           0x0007  // Phone


//
// Record Gain Mic Register bit defines
//
#define AC97REG_RGM_DEFAULT                         0x8000  // The default register value


//
// General Purpose Register bit defines
//
#define AC97REG_GENERAL_DEFAULT                     0x0000  // The default register value
#define AC97REG_GENERAL_POP                         0x8000  // 3D Bypass bit
#define AC97REG_GENERAL_ST                          0x4000  // Simulated stereo bit
#define AC97REG_GENERAL_3D                          0x2000  // 3D stereo enable bit
#define AC97REG_GENERAL_LD                          0x1000  // Loudness bit
#define AC97REG_GENERAL_MIX                         0x0200  // Mix select bit
#define AC97REG_GENERAL_MS                          0x0100  // Mic Select bit


//
// 3D Stereo Enhancement Register bit defines
//
#define AC97REG_3DCTRL_DEPTH_MASK                   0x00ff  // Masks off center bits
#define AC97REG_3DCTRL_DEPTH_MASK1                  0x0000  // Determine if control is fixed
#define AC97REG_3DCTRL_DEPTH_MASK2                  0x000f  // Determine if control is fixed
#define AC97REG_3DCTRL_CENTER_MASK                  0xff00  // Masks off depth bits
#define AC97REG_3DCTRL_CENTER_MASK1                 0x0000  // Determine if control is fixed
#define AC97REG_3DCTRL_CENTER_MASK2                 0x0f00  // Determine if control is fixed


//
// Powerdown Control/Status Register bit defines
//
#define AC97REG_PCS_EAPD                            0x8000  // External Amp Powerdown
#define AC97REG_PCS_PR6                             0x4000  // Alt Line Output Buffer Powerdown
#define AC97REG_PCS_PR5                             0x2000  // Internal Clock Disable
#define AC97REG_PCS_PR4                             0x1000  // AC-Link Power Down (BIT_CLK off)
#define AC97REG_PCS_PR3                             0x0800  // Analog Mixer Off (Vref off)
#define AC97REG_PCS_PR2                             0x0400  // Analog Mixer Off (Vref still on)
#define AC97REG_PCS_PR1                             0x0200  // DACs Powerdown
#define AC97REG_PCS_PR0                             0x0100  // ADCs and Input Mux Powerdown

#define AC97REG_PCS_POWER_OFF                       0xff00
#define AC97REG_PCS_FULL_POWER                      0x0000

#define AC97REG_PCS_REF                             0x0008  // Vreg at nominal levels
#define AC97REG_PCS_ANL                             0x0004  // Mixer, Mux, and Volume ctrls ready
#define AC97REG_PCS_DAC                             0x0002  // DAC ready to accept data
#define AC97REG_PCS_ADC                             0x0001  // ADC ready to transmit data

#define AC97REG_PCS_STATUS_READY                    (AC97REG_PCS_REF | AC97REG_PCS_ANL | AC97REG_PCS_DAC | AC97REG_PCS_ADC)


//
// Extended Audio ID Register bit defines
//

//
// Codec Config Bits (Primary = 0x00, Secondary = 0x01, 0x10, 0x11)
//
#define AC97REG_EAID_ID1                            0x8000  // Codec config ID1 bit
#define AC97REG_EAID_ID0                            0x4000  // Codec config ID0 bit
#define AC97REG_EAID_CONFIG_MASK                    (AC97REG_EAID_ID1 | AC97REG_EAID_ID0)

#define AC97REG_EAID_AMAP                           0x0200  // Optional slot/DAC mappings bit

#define AC97REG_EAID_LDAC                           0x0100  // LFE DAC bit
#define AC97REG_EAID_SDAC                           0x0080  // Surround DAC bit
#define AC97REG_EAID_CDAC                           0x0040  // Center DAC bit
#define AC97REG_EAID_CHANNEL_MASK                   (AC97REG_EAID_LDAC | AC97REG_EAID_SDAC | AC97REG_EAID_CDAC)

#define AC97REG_EAID_VRM                            0x0008  // Variable Rate Mic input bit
#define AC97REG_EAID_DRA                            0x0002  // Double Rate bit
#define AC97REG_EAID_VRA                            0x0001  // Variable sample Rate bit
#define AC97REG_EAID_VARIABLE_RATE_MASK             (AC97REG_EAID_VRM | AC97REG_EAID_DRA | AC97REG_EAID_VRA)


//
// Extended Audio Status and Control Register bit defines
//
#define AC97REG_EASCR_PRL                           0x4000  // MIC ADC off
#define AC97REG_EASCR_PRK                           0x2000  // PCM LFE DAC off
#define AC97REG_EASCR_PRJ                           0x1000  // PCM Surround DAC off
#define AC97REG_EASCR_PRI                           0x0800  // PCM Center DAC off
#define AC97REG_EASCR_POWER_MASK                    (AC97REG_EASCR_PRI | AC97REG_EASCR_PRJ | AC97REG_EASCR_PRK | AC97REG_EASCR_PRL)

#define AC97REG_EASCR_MADC                          0x0200  // Mic ADC bit
#define AC97REG_EASCR_LDAC                          0x0100  // LFE DAC bit
#define AC97REG_EASCR_SDAC                          0x0080  // Surround DAC bit
#define AC97REG_EASCR_CDAC                          0x0040  // Center DAC bit

#define AC97REG_EASCR_VRM                           0x0008  // Variable Rate Mic input bit
#define AC97REG_EASCR_DRA                           0x0002  // Double Rate bit
#define AC97REG_EASCR_VRA                           0x0001  // Variable sample Rate bit

//
// Double Rate Bit Mask
//
#define AC97REG_DR_MASK                             0xffff0000

//
// Default Audio Sample Rate
//
#define AC97REG_ASRC_DEFAULT                        0xbb80

//
// Default Six Channel Volume Control Value
//
#define AC97REG_6CVC_DEFAULT                        0x8080
#define AC97REG_CENTER_MUTE_MASK                    0x0080
#define AC97REG_LFE_MUTE_MASK                       0x8000


//
// Extended Modem ID Register Bits
//
#define AC97REG_EMID_INVALID                        0xffff  // Register is not supported


//
// Codec ID Register Bits
//
#define AC97REG_VID_MASK                            0xffff  // Allow all ID bits
#define AC97REG_VID1_F_MASK                         0xff00  // First character of ID
#define AC97REG_VID1_S_MASK                         0x00ff  // Second character of ID
#define AC97REG_VID2_T_MASK                         0xff00  // Third character of ID
#define AC97REG_VID2_REV_MASK                       0x00ff  // Revision ID mask

//
// Codec IDs
//
#define AC97REG_VID1_ADI                            0x4144  // "AD"I ID1
#define AC97REG_VID2_ADI                            0x5300  // AD"I" ID2
#define AC97REG_VID2_ADI_REVISION_MASK              0x00ff  // Rev ID Mask
#define AC97REG_VID2_ADI_REV_1881                   0x0040  // ADI1881
#define AC97REG_VID2_ADI_REV_1885                   0x0060  // ADI1885

#define AC97REG_VID1_CRYSTAL                        0x4352  // "CR"ystal ID1
#define AC97REG_VID2_CRYSTAL                        0x5900  // Cr"Y"stal ID2
#define AC97REG_VID2_CRYSTAL_PID_MASK               0x0070  // Part ID Mask
#define AC97REG_VID2_CRYSTAL_RID_MASK               0x0070  // Rev ID Mask
#define AC97REG_VID2_CRYSTAL_PID_4297               0x0000  // CS4297
#define AC97REG_VID2_CRYSTAL_PID_4297A              0x0010  // CS4297A
#define AC97REG_VID2_CRYSTAL_PID_4294C              0x0020  // CS4294 Rev C
#define AC97REG_VID2_CRYSTAL_PID_4298               0x0020  // CS4298
#define AC97REG_VID2_CRYSTAL_PID_4299               0x0030  // CS4299
#define AC97REG_VID2_CRYSTAL_PID_4201               0x0040  // CS4201



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\ac97xmo.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ac97xmo.cpp
 *  Content:    AC97 direct-access media object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/05/01    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY      leListEntry;
    XMEDIAPACKET    xmp;
END_DEFINE_STRUCT(AC97PACKET);

//
// AC'97 XMO
//

#ifdef VALIDATE_PARAMETERS

class CAc97MediaObject
    : public XAc97MediaObject, CValidObject<'AC97'>, public CRefCountTest

#else // VALIDATE_PARAMETERS

class CAc97MediaObject
    : public XAc97MediaObject, public CRefCountTest

#endif // VALIDATE_PARAMETERS

{
protected:
    static DWORD                m_dwGlobalRefCount;     // Shared reference count
    static CAc97Device *        m_pDevice;              // Shared AC97 device object
                                                        
protected:                                              
    CAc97Channel *              m_pChannel;             // AC97 channel object
    LIST_ENTRY                  m_lstPending;           // Pending packet list
    LIST_ENTRY                  m_lstFree;              // Free packet list
    LPFNXMEDIAOBJECTCALLBACK    m_pfnCallback;          // Callback function
    LPVOID                      m_pvCallbackContext;    // Callback context
    LPAC97PACKET                m_paPackets;            // Packet pool
    DWORD                       m_dwStatus;             // XMO status

public:
    CAc97MediaObject(void);
    virtual ~CAc97MediaObject(void);

public:
    // Initialization
    virtual HRESULT STDMETHODCALLTYPE Initialize(DWORD dwChannel, LPFNXMEDIAOBJECTCALLBACK pfnCallback, LPVOID pvCallbackContext);
    
    // IUnknown methods
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // XMediaObject methods
    virtual HRESULT STDMETHODCALLTYPE GetInfo(LPXMEDIAINFO pInfo);
    virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
    virtual HRESULT STDMETHODCALLTYPE Process(LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket);
    virtual HRESULT STDMETHODCALLTYPE Discontinuity(void);
    virtual HRESULT STDMETHODCALLTYPE Flush(void);

    // XAc97MediaObject methods
    virtual HRESULT STDMETHODCALLTYPE SetMode(DWORD dwMode);
    virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD pdwPosition);

protected:
    // Packet completion
    void CompletePendingPackets(void);
    void CompletePacket(LPAC97PACKET pPacket, DWORD dwStatus);
    
private:
    // Event handlers
    static void CALLBACK InterruptCallback(LPVOID pvContext);
};

__inline ULONG CAc97MediaObject::AddRef(void)
{
    _ENTER_EXTERNAL_METHOD("CAc97MediaObject::AddRef");
    return CRefCountTest::AddRef();
}

__inline ULONG CAc97MediaObject::Release(void)
{
    _ENTER_EXTERNAL_METHOD("CAc97MediaObject::Release");
    return CRefCountTest::Release();
}

__inline HRESULT CAc97MediaObject::Discontinuity(void)
{
    return DS_OK;
}

__inline void CAc97MediaObject::InterruptCallback(LPVOID pvContext)
{
    ((CAc97MediaObject *)pvContext)->CompletePendingPackets();
}


/****************************************************************************
 *
 *  Ac97CreateMediaObject
 *
 *  Description:
 *      Creates and initializes an AC97 Media Object.
 *
 *  Arguments:
 *      DWORD [in]: channel identifier.
 *      XMediaObject ** [out]: receives channel object.  The caller is
 *                             responsible for freeing this object with
 *                             Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Ac97CreateMediaObject"

HRESULT
Ac97CreateMediaObject
(
    DWORD                       dwChannel,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback, 
    LPVOID                      pvCallbackContext,
    XAc97MediaObject **         ppMediaObject
)
{
    CAc97MediaObject *          pMediaObject    = NULL;
    HRESULT                     hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

    //
    // Create the AC97 media object
    //

    hr = HRFROMP(pMediaObject = NEW(CAc97MediaObject));
   
    if(SUCCEEDED(hr))
    {
        hr = pMediaObject->Initialize(dwChannel, pfnCallback, pvCallbackContext);
    }

    if(SUCCEEDED(hr))
    {
        *ppMediaObject = ADDREF(pMediaObject);
    }

    RELEASE(pMediaObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CAc97MediaObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::CAc97MediaObject"

DWORD CAc97MediaObject::m_dwGlobalRefCount = 0;
CAc97Device *CAc97MediaObject::m_pDevice = NULL;

CAc97MediaObject::CAc97MediaObject
(
    void
)
{
    DPF_ENTER();

    InitializeListHead(&m_lstPending);
    InitializeListHead(&m_lstFree);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CAc97MediaObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::~CAc97MediaObject"

CAc97MediaObject::~CAc97MediaObject
(
    void
)
{
    DPF_ENTER();

    //
    // Flush any remaining packets
    //

    Flush();

    //
    // Free the channel
    //

    RELEASE(m_pChannel);

    //
    // Free resources
    //

    MEMFREE(m_paPackets);

    //
    // Release the shared stuff
    //

    ASSERT(m_dwGlobalRefCount);
    
    if(!--m_dwGlobalRefCount)
    {
        DELETE(m_pDevice);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: channel type.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::Initialize"

HRESULT
CAc97MediaObject::Initialize
(
    DWORD                       dwChannel,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback, 
    LPVOID                      pvCallbackContext
)
{
    HRESULT                     hr              = DS_OK;
    AC97CHANNELTYPE             nChannelType;
    DWORD                       i;
    
    DPF_ENTER();

    m_pfnCallback = pfnCallback;
    m_pvCallbackContext = pvCallbackContext;

    //
    // Set up data shared between all instances of the AC97 XMO
    //

    if(!m_dwGlobalRefCount++)
    {
        ASSERT(!m_pDevice);

        hr = HRFROMP(m_pDevice = NEW(CAc97Device));

        if(SUCCEEDED(hr))
        {
            hr = m_pDevice->Initialize();
        }
    }
    else
    {
        ASSERT(m_pDevice);
    }

    //
    // Create the audio channel
    //

    if(SUCCEEDED(hr))
    {
        switch(dwChannel)
        {
            case DSAC97_CHANNEL_ANALOG:
                nChannelType = AC97_CHANNELTYPE_ANALOG;
                break;

            case DSAC97_CHANNEL_DIGITAL:
                nChannelType = AC97_CHANNELTYPE_DIGITAL;
                break;

            default:
                ASSERTMSG("Invalid channel type");
                break;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(m_pDevice->m_apChannels[nChannelType])
        {
            DPF_ERROR("Channel already open");
            hr = DSERR_INVALIDCALL;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDevice->CreateChannel(nChannelType, &m_pChannel);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pChannel->Initialize(AC97CHANNEL_OBJECTF_STREAM, InterruptCallback, this);
    }

    //
    // Allocate packet data
    //

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_paPackets = MEMALLOC(AC97PACKET, DSAC97_MAX_ATTACHED_PACKETS));
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < DSAC97_MAX_ATTACHED_PACKETS; i++)
        {
            InsertTailListUninit(&m_lstFree, &m_paPackets[i].leListEntry);
        }
    }

    //
    // Set the initial status
    //

    if(SUCCEEDED(hr))
    {
        m_dwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the object supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [in/out]: info data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::GetInfo"

HRESULT
CAc97MediaObject::GetInfo
(
    LPXMEDIAINFO            pInfo
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pInfo)
    {
        DPF_ERROR("XMO info buffer not supplied");
    }

#endif // VALIDATE_PARAMETERS

    ZeroMemory(pInfo, sizeof(*pInfo));

    //
    // Flags are easy
    //
    
    pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC;

    //
    // Input size is just sample-aligment, since that's the smallest amount of
    // data we require to process.
    //

    pInfo->dwInputSize = m_pDevice->m_wfxFormat.nBlockAlign;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Resets the stream to it's default state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::Flush"

HRESULT
CAc97MediaObject::Flush
(
    void
)                                       
{                                           
    PLIST_ENTRY             plePacket;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    //
    // Reset the channel
    //
    
    if(m_pChannel)
    {
        m_pChannel->Flush();
    }

    //
    // Reset our internal packet list
    //

    while((plePacket = m_lstPending.Flink) != &m_lstPending)
    {
        MoveEntryTailList(&m_lstFree, plePacket);
        
        CompletePacket(CONTAINING_RECORD(plePacket, AC97PACKET, leListEntry), XMEDIAPACKET_STATUS_FLUSHED);
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets stream status.
 *
 *  Arguments:
 *      LPDWORD [out]: stream status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::GetStatus"

HRESULT
CAc97MediaObject::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwStatus)
    {
        DPF_ERROR("Status buffer not supplied");
    }

#endif // VALIDATE_PARAMETERS

    *pdwStatus = m_dwStatus;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Submits buffers to the stream.
 *
 *  Arguments:
 *      LPXMEDIAPACKET  [in]: input buffer.
 *      LPXMEDIAPACKET  [in]: output buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::Process"

HRESULT
CAc97MediaObject::Process
(
    LPCXMEDIAPACKET         pxmbSource, 
    LPCXMEDIAPACKET         pxmbDest 
)
{
    HRESULT                 hr                      = DS_OK;
    PLIST_ENTRY             plePacket;
    LPAC97PACKET            pPacket;
    CIrql                   irql;

#ifdef VALIDATE_PARAMETERS

    DWORD                   dwBasePhysicalAddress;
    DWORD                   dwContiguousLength;
    DWORD                   dwPhysicalAddress;

#endif // VALIDATE_PARAMETERS

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pxmbSource)
    {
        DPF_ERROR("No input buffer supplied");
    }

    if(!pxmbSource->pvBuffer)
    {
        DPF_ERROR("No input data buffer supplied");
    }

    if(!pxmbSource->dwMaxSize)
    {
        DPF_ERROR("No input buffer size");
    }

    if(pxmbSource->dwMaxSize % m_pDevice->m_wfxFormat.nBlockAlign)
    {
        DPF_ERROR("Input buffer size not block-aligned");
    }

    if(pxmbSource->dwMaxSize > 131068)
    {
        DPF_ERROR("Input buffers are restricted to 131068 bytes or less");
    }

    if(pxmbDest)
    {
        DPF_ERROR("AC97 streams are input only");
    }

#endif // VALIDATE_PARAMETERS

    //
    // Get a packet from the free list and add it to the pending list
    //

    irql.Raise();
    
    if((plePacket = MoveHeadTailList(&m_lstPending, &m_lstFree)) == &m_lstFree)
    {
        DPF_ERROR("No free packets");
        hr = DSERR_INVALIDCALL;
    }

    //
    // Initialize the packet data and add it to the pending list
    //

    if(SUCCEEDED(hr))
    {
        pPacket = CONTAINING_RECORD(plePacket, AC97PACKET, leListEntry);
        
        pPacket->xmp = *pxmbSource;

        XMOAcceptPacket(&pPacket->xmp);

        DPF_BLAB("Accepted packet %x", pPacket);
    }

    irql.Lower();

    //
    // Lock packet data
    //

    if(SUCCEEDED(hr))
    {
        MmLockUnlockBufferPages(pPacket->xmp.pvBuffer, pPacket->xmp.dwMaxSize, FALSE);

#ifdef VALIDATE_PARAMETERS

        dwBasePhysicalAddress = MmGetPhysicalAddress(pxmbSource->pvBuffer);
        dwContiguousLength = PAGE_SIZE - BYTE_OFFSET(pxmbSource->pvBuffer); 

        while(dwContiguousLength < pxmbSource->dwMaxSize)
        {
            dwPhysicalAddress = MmGetPhysicalAddress((LPBYTE)pxmbSource->pvBuffer + dwContiguousLength);
            ASSERT(!(dwPhysicalAddress & (PAGE_SIZE - 1)));

            if(dwBasePhysicalAddress + dwContiguousLength != dwPhysicalAddress)
            {
                DPF_ERROR("Packet data submitted to the AC97 XMO must be physically contiguous.  Use XPhysicalAlloc");
                break;
            }

            dwContiguousLength += PAGE_SIZE;
        }

#endif // VALIDATE_PARAMETERS

    }

    //
    // Send the packet to the channel
    //

    if(SUCCEEDED(hr))
    {
        m_pChannel->AttachPacket(pPacket->xmp.pvBuffer, pPacket->xmp.dwMaxSize);
    }

    //
    // Signal a discontinuity to the channel.  This will prevent the channel
    // from playing crap if the stream starves.  It's really low overhead to
    // do this, so better safe than sorry.  As a side effect of this, the
    // AC97 channel will never complain about being starved.  Oh well.
    //

    if(SUCCEEDED(hr))
    {
        m_pChannel->Discontinuity();
    }

    //
    // Start the channel running
    //

    if(SUCCEEDED(hr))
    {
        m_pChannel->Run();
    }

    //
    // Update the status
    //

    if(SUCCEEDED(hr) && IsListEmpty(&m_lstFree))
    {
        ASSERT(XMO_STATUSF_ACCEPT_INPUT_DATA == m_dwStatus);

        m_dwStatus = 0;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CompletePendingPackets
 *
 *  Description:
 *      Completes all packets in the pending list that have been played.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::CompletePendingPackets"

void
CAc97MediaObject::CompletePendingPackets
(
    void
)
{
    PLIST_ENTRY             plePacket;
    LPAC97PACKET            pPacket;
    CIrql                   irql;
    
    DPF_ENTER();

    //
    // Complete the first packet in the list
    //

    irql.Raise();

    if((plePacket = MoveHeadTailList(&m_lstFree, &m_lstPending)) != &m_lstPending)
    {
        pPacket = CONTAINING_RECORD(plePacket, AC97PACKET, leListEntry);
    }
    else
    {
        pPacket = NULL;
    }

    irql.Lower();

    if(pPacket)
    {
        CompletePacket(pPacket, XMEDIAPACKET_STATUS_SUCCESS);
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CompletePacket
 *
 *  Description:
 *      Marks a packet as complete.
 *
 *  Arguments:
 *      LPAC97PACKET [in]: packet.
 *      DWORD [in]: status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::CompletePacket"

void
CAc97MediaObject::CompletePacket
(
    LPAC97PACKET            pPacket,
    DWORD                   dwStatus
)
{
    DPF_ENTER();

    DPF_BLAB("Completing packet %x", pPacket);

    //
    // Unlock packet data
    //

    MmLockUnlockBufferPages(pPacket->xmp.pvBuffer, pPacket->xmp.dwMaxSize, TRUE);

    //
    // Update the status to reflect the fact that we have at least one
    // free packet.
    //

    ASSERT(!IsListEmpty(&m_lstFree));
    
    m_dwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA;

    //
    // Finalize completion
    //

    XMOCompletePacket(&pPacket->xmp, pPacket->xmp.dwMaxSize, m_pfnCallback, m_pvCallbackContext, dwStatus);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the channel mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::SetMode"

HRESULT
CAc97MediaObject::SetMode
(
    DWORD                   dwMode
)
{
    HRESULT                 hr              = DS_OK;
    DWORD                   dwSpeakerConfig;
    
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if((DSAC97_MODE_PCM != dwMode) && (DSAC97_MODE_ENCODED != dwMode))
    {
        DPF_ERROR("Invalid channel mode");
    }

    if((AC97_CHANNELTYPE_ANALOG == m_pChannel->m_nChannelType) && (DSAC97_MODE_ENCODED == dwMode))
    {
        DPF_ERROR("The analog channel can only output PCM data");
    }

#endif // VALIDATE_PARAMETERS

    if(DSAC97_MODE_PCM != dwMode)
    {
        dwSpeakerConfig = XAudioGetSpeakerConfig();

        if(!(dwSpeakerConfig & DSSPEAKER_ENCODED_VALID))
        {
            DPF_ERROR("Encoded output not enabled");
            hr = DSERR_INVALIDCALL;
        }
    }
    
    if(SUCCEEDED(hr))
    {
        m_pChannel->SetMode(dwMode);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current stream position.
 *
 *  Arguments:
 *      LPDWORD [out]: stream position.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CAc97MediaObject::GetCurrentPosition"

HRESULT
CAc97MediaObject::GetCurrentPosition
(
    LPDWORD                 pdwPosition
)
{
    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

#ifdef VALIDATE_PARAMETERS

    if(!pdwPosition)
    {
        DPF_ERROR("Failed to supply a position buffer");
    }

#endif // VALIDATE_PARAMETERS

    *pdwPosition = m_pChannel->GetPosition();

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\debug.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.cpp
 *  Content:    Debugger helper object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  05/23/00    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"

#ifdef USEDPF

//
// Debug levels
//

DWORD g_dwDirectSoundDebugLevel = DPFLVL_DEFAULT;
DWORD g_dwDirectSoundDebugBreakLevel = DPFLVL_DEFAULT_BREAK;

//
// Deferred breakpoint
//

BOOL g_fDirectSoundBreakPoint = FALSE;

//
// Debug context data
//

BEGIN_DEFINE_STRUCT()
    DWORD   dwFlags;
    DWORD   dwLevel;
    LPCSTR  pszFile;
    UINT    nLine;
    LPCSTR  pszFunction;
    LPCSTR  pszLibrary;
END_DEFINE_STRUCT(DPFCONTEXT);

DPFCONTEXT g_DpfContext[HIGH_LEVEL + 1];


/***************************************************************************
 *
 *  dstrcpy
 *
 *  Description:
 *      Copies one string to another.
 *
 *  Arguments:
 *      LPSTR [in/out]: destination string.
 *      LPCSTR [in]: source string.
 *
 *  Returns:  
 *      LPSTR: pointer to the end of the string.
 *
 ***************************************************************************/

__inline LPSTR 
dstrcpy
(
    LPSTR                   dst, 
    LPCSTR                  src
)
{
    while(*dst = *src)
    {
        dst++;
        src++;
    }
    
    return dst;
}


/****************************************************************************
 *
 *  DwDbgPrintStaticV
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *      LPCSTR [in]: format string.
 *      va_list [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgPrintStaticV
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction, 
    LPCSTR                  pszLibrary,
    LPCSTR                  pszFormat,
    va_list                 va
)
{
    CHAR                    szFinal[0x400];
    LPSTR                   pszWorking;
    DWORD                   dwWritten;

    if(dwLevel <= g_dwDirectSoundDebugLevel)
    {
        pszWorking = szFinal;

        //
        // Add the library name
        //

        if((dwFlags & DPRINTF_LIBRARY) && pszLibrary && *pszLibrary)
        {
            pszWorking += sprintf(pszWorking, "%s: ", pszLibrary);
        }

        //
        // Add the source file and line number
        //

        if((dwFlags & DPRINTF_FILELINE) && pszFile && *pszFile)
        {
            pszWorking += sprintf(pszWorking, "%hs(%lu): ", pszFile, nLine);
        }

        //
        // Add the function name
        //

        if((dwFlags & DPRINTF_FUNCTIONNAME) && pszFunction && *pszFunction)
        {
            pszWorking += sprintf(pszWorking, "%hs: ", pszFunction);
        }

        //
        // Add process and thread id
        //

        if(dwFlags & DPRINTF_PROCESSTHREADID)
        {
            pszWorking += sprintf(pszWorking, "%.8lx: ", GetCurrentThreadId());
        }

        //
        // Add the type of message it is (i.e. error or warning)
        //

        switch(dwLevel)
        {
            case DPFLVL_ERROR:
                pszWorking = dstrcpy(pszWorking, "Error: ");
                break;

            case DPFLVL_RESOURCE:
                pszWorking = dstrcpy(pszWorking, "Resource failure: ");
                break;

            case DPFLVL_WARNING:
                pszWorking = dstrcpy(pszWorking, "Warning: ");
                break;
        }

        //
        // Add the debug string
        //

        pszWorking += vsprintf(pszWorking, pszFormat, va);

        //
        // Add a carriage-return since OutputDebugString doesn't
        //

        pszWorking = dstrcpy(pszWorking, "\n");

        //
        // Output to the debugger
        //

        OutputDebugStringA(szFinal);

        //
        // Break into the debugger
        //

        if(dwLevel && (dwLevel <= g_dwDirectSoundDebugBreakLevel))
        {
            DwDbgBreak();
        }
    }
}


/****************************************************************************
 *
 *  DwDbgPrintStatic
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *      LPCSTR [in]: format string.
 *      va_list [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgPrintStatic
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction, 
    LPCSTR                  pszLibrary,
    LPCSTR                  pszFormat,
    ...
)
{
    va_list                 va;

    va_start(va, pszFormat);
    DwDbgPrintStaticV(dwFlags, dwLevel, pszFile, nLine, pszFunction, pszLibrary, pszFormat, va);
    va_end(va);
}


/****************************************************************************
 *
 *  DwDbgSetContext
 *
 *  Description:
 *      Sets context for a DPF.
 *
 *  Arguments:
 *      DWORD [in]: option flags.
 *      DWORD [in]: debug level.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line called from.
 *      LPCSTR [in]: function called from.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgSetContext
(
    DWORD                   dwFlags, 
    DWORD                   dwLevel,     
    LPCSTR                  pszFile, 
    UINT                    nLine, 
    LPCSTR                  pszFunction,
    LPCSTR                  pszLibrary
)
{
    const KIRQL             irql    = KeGetCurrentIrql();

    g_DpfContext[irql].dwFlags = dwFlags;
    g_DpfContext[irql].dwLevel = dwLevel;
    g_DpfContext[irql].pszFile = pszFile;
    g_DpfContext[irql].nLine = nLine;
    g_DpfContext[irql].pszFunction = pszFunction;
    g_DpfContext[irql].pszLibrary = pszLibrary;
}


/****************************************************************************
 *
 *  DwDbgPrint
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      LPCSTR [in]: format string.
 *      ... [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgPrint
(
    LPCSTR                  pszFormat,
    ...
)
{
    const KIRQL             irql    = KeGetCurrentIrql();
    va_list                 va;

    va_start(va, pszFormat);
    DwDbgPrintStaticV(g_DpfContext[irql].dwFlags, g_DpfContext[irql].dwLevel, g_DpfContext[irql].pszFile, g_DpfContext[irql].nLine, g_DpfContext[irql].pszFunction, g_DpfContext[irql].pszLibrary, pszFormat, va);
    va_end(va);
}


/****************************************************************************
 *
 *  DwDbgAssert
 *
 *  Description:
 *      Breaks into the debugger.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to assert.
 *      LPCSTR [in]: expression string.
 *      LPCSTR [in]: file called from.
 *      UINT [in]: line number called from.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgAssert
(
    BOOL                    fAssert,
    LPCSTR                  pszExpression,
    LPCSTR                  pszFile,
    UINT                    nLine
)
{
    static const LPCSTR     pszBanner           = "******************************************************************************";
    CHAR                    szMessage[0x400];
    LPSTR                   pszMessage;

    if(fAssert)
    {
        pszMessage = szMessage;

        pszMessage = dstrcpy(pszMessage, pszBanner);
        pszMessage = dstrcpy(pszMessage, "\n");
    
#ifdef DPF_LIBRARY

        pszMessage = dstrcpy(pszMessage, DPF_LIBRARY ": ");

#endif // DPF_LIBRARY
    
        pszMessage = dstrcpy(pszMessage, "Assertion failed in ");
        pszMessage = dstrcpy(pszMessage, pszFile);
        pszMessage = dstrcpy(pszMessage, ", line ");
    
        _itoa(nLine, pszMessage, 10);
        pszMessage += strlen(pszMessage);

        pszMessage = dstrcpy(pszMessage, ":\n");
        pszMessage = dstrcpy(pszMessage, pszExpression);
        pszMessage = dstrcpy(pszMessage, "\n");
        pszMessage = dstrcpy(pszMessage, pszBanner);
        pszMessage = dstrcpy(pszMessage, "\n");

        OutputDebugStringA(szMessage);
        DwDbgBreak();
    }
}


/****************************************************************************
 *
 *  DwDbgBreak
 *
 *  Description:
 *      Breaks into the debugger.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DwDbgBreak
(
    void
)
{
    //
    // Break in the debugger
    //
    
    __asm int 3;

    //
    // If we're at DISPATCH_LEVEL or higher, the VC debugger won't catch
    // the break.
    //
    
    if(KeGetCurrentIrql() >= DISPATCH_LEVEL)
    {
        g_fDirectSoundBreakPoint = TRUE;
    }
}


#endif // USEDPF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    Debugger helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/21/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifndef DPF_LIBRARY
#error DPF_LIBRARY not defined
#endif // DPF_LIBRARY

#pragma warning(disable:4002)

#if defined(DEBUG) && !defined(NODPF) && !defined(USEDPF)
#define USEDPF
#endif // defined(DEBUG) && !defined(NODPF)

//
// Preprocessor hacks
//

#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)
                                
//
// #pragma Reminders
//

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)
#define BUGBUG(a)               MESSAGE("BUGBUG: " a)
#define HACKHACK(a)             MESSAGE("HACKHACK: " a)

//
// Debug flags
//

#define DPRINTF_LIBRARY         0x00000001
#define DPRINTF_FILELINE        0x00000002
#define DPRINTF_PROCESSTHREADID 0x00000004
#define DPRINTF_FUNCTIONNAME    0x00000008

#ifndef DPRINTF_DEFAULT
#define DPRINTF_DEFAULT         (DPRINTF_LIBRARY | DPRINTF_FUNCTIONNAME)
#endif // DPRINTF_DEFAULT

//
// Debug levels
//

#define DPFLVL_ABSOLUTE         0   // Disregard level
#define DPFLVL_ERROR            1   // Errors
#define DPFLVL_RESOURCE         2   // Resource allocation failures
#define DPFLVL_WARNING          3   // Warnings
#define DPFLVL_INFO             4   // General info
#define DPFLVL_BLAB             5   // Mostly useless info
#define DPFLVL_ENTERLEAVE       9   // Function enter/leave

#ifdef USEDPF

#ifndef DPFLVL_DEFAULT
#define DPFLVL_DEFAULT          DPFLVL_WARNING
#endif // DPFLVL_DEFAULT

#ifndef DPFLVL_DEFAULT_BREAK
#define DPFLVL_DEFAULT_BREAK    DPFLVL_RESOURCE
#endif // DPFLVL_DEFAULT_BREAK

EXTERN_C BOOL g_fDirectSoundBreakPoint;

#endif // USEDPF

//
// Debug API
//

#undef ASSERTMSG
#undef ASSERT
#undef BREAK

#ifdef USEDPF

EXTERN_C void __cdecl DwDbgSetContext(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary);
EXTERN_C void __cdecl DwDbgPrint(LPCSTR pszFormat, ...);
EXTERN_C void __cdecl DwDbgPrintStatic(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary, LPCSTR pszFormat, ...);
EXTERN_C void __cdecl DwDbgPrintStaticV(DWORD dwFlags, DWORD dwLevel, LPCSTR pszFile, UINT nLine, LPCSTR pszFunction, LPCSTR pszLibrary, LPCSTR pszFormat, va_list va);
EXTERN_C void __cdecl DwDbgAssert(BOOL fAssert, LPCSTR pszExpression, LPCSTR pszFile, UINT nLine);
EXTERN_C void __cdecl DwDbgBreak(void);

#define DPF_ABSOLUTE \
    DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_ABSOLUTE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_ERROR \
    DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_ERROR, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_RESOURCE \
    DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_RESOURCE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_WARNING \
    DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_WARNING, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_INFO \
    DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_INFO, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_BLAB \
    DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_BLAB, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint

#define DPF_ENTERLEAVE \
    DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_ENTERLEAVE, __FILE__, __LINE__, DPF_FNAME, DPF_LIBRARY), \
    DwDbgPrint
                                
#define ASSERT(a) \
    DwDbgAssert(!(a), #a, __FILE__, __LINE__)

#define ASSERTMSG(a) \
    DwDbgAssert(TRUE, a, __FILE__, __LINE__)

#define BREAK() \
    DwDbgBreak()

#else // USEDPF

#define DPF_ABSOLUTE(a)
#define DPF_ERROR(a)
#define DPF_RESOURCE(a)
#define DPF_WARNING(a)
#define DPF_INFO(a)
#define DPF_BLAB(a)
#define DPF_ENTERLEAVE(a)

#define ASSERT(a)
#define ASSERTMSG(a)
#define BREAK()

#endif // USEDPF
                                
#define DPF_ENTER()             // DPF_ENTERLEAVE("Enter")
#define DPF_LEAVE(a)            // DPF_ENTERLEAVE("Leave, returning %#x", (DWORD)(a))
#define DPF_LEAVE_VOID()        // DPF_ENTERLEAVE("Leave")

#define DPF_LEAVE_HRESULT(a)    // DPF_LEAVE(a)
#define DPF_LEAVE_WINERROR(a)   // DPF_LEAVE(a)
#define DPF_LEAVE_NTSTATUS(a)   // DPF_LEAVE(a)

#undef DPF_FNAME
#define DPF_FNAME               NULL

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\drvhlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drvhlp.h
 *  Content:    Miscelaneous NT-style driver helper functions and objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/07/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __DRVHLP_H__
#define __DRVHLP_H__

#ifdef __cplusplus

// 
// Raised IRQL object
//

class CIrql
{
private:
    KIRQL                   m_irql;
    BOOL                    m_fRaised;

public:
    CIrql(void);

public:
    void Raise(void);
    void Lower(void);
};

__inline CIrql::CIrql(void)
{
    m_fRaised = FALSE;
}
    
__inline void CIrql::Raise(void)
{
    if(m_fRaised = (KeGetCurrentIrql() < DISPATCH_LEVEL))
    {
        m_irql = KfRaiseIrql(DISPATCH_LEVEL);
    }
}

__inline void CIrql::Lower(void)
{
    if(m_fRaised)
    {
        KfLowerIrql(m_irql);
        m_fRaised = FALSE;
    }
}

//
// Automatic (function-scope) raised IRQL
//

class CAutoIrql
    : public CIrql
{
public:
    CAutoIrql(void);
    ~CAutoIrql(void);
};

__inline CAutoIrql::CAutoIrql(void)
{
    Raise();
}

__inline CAutoIrql::~CAutoIrql(void)
{
    Lower();
}

#define AutoIrql() \
    CAutoIrql __AutoIrql

//
// Floating point state
//

class CFpState
{
private:
    static DWORD            m_dwRefCount;
    static KFLOATING_SAVE   m_fps;

public:
    void Save(void);
    void Restore(void);
};

__inline void CFpState::Save(void)
{
    if(KeIsExecutingDpc())
    {
        if(!m_dwRefCount++)
        {
            KeSaveFloatingPointState(&m_fps);
        }
    }
}

__inline void CFpState::Restore(void)
{
    if(KeIsExecutingDpc())
    {
        if(!--m_dwRefCount)
        {
            KeRestoreFloatingPointState(&m_fps);
        }
    }
}

//
// Automatic (function-scope) floating-point state
//

class CAutoFpState
    : private CFpState
{
public:
    CAutoFpState(void);
    ~CAutoFpState(void);
};

__inline CAutoFpState::CAutoFpState(void)
{
    Save();
}

__inline CAutoFpState::~CAutoFpState(void)
{
    Restore();
}

#define AutoFpState() \
    CAutoFpState __AutoFpState

//
// Misc. helpers
//

__inline UINT CountBits(DWORD dwBits)
{
    UINT                    nCount;
    UINT                    i;

    for(i = 0, nCount = 0; i < 32; i++)
    {
        if(dwBits & (1UL << i))
        {
            nCount++;
        }
    }

    return nCount;
}

__inline UINT GetBitIndex(DWORD dwBit)
{
    UINT                    i;

    for(i = 0; i < 32; i++)
    {
        if(dwBit & (1UL << i))
        {
            break;
        }
    }

    return i;
}

#endif // __cplusplus

#endif // __DRVHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsndver.h ===
#include <xboxverp.h>

#ifdef __cplusplus
extern "C"
{
#endif

#pragma data_seg(push)
#pragma data_seg(".XBLD$V")

#if DBG
#pragma comment(linker, "/include:_TestSoundLibBuildNumberD")
__declspec(selectany) unsigned short TestSoundLibBuildNumberD[8] = { 'T' | ('E' << 8), 'S' | ('T' << 8), 'S' | ('N' << 8), 'D' | ('D' << 8),
                                        VER_PRODUCTVERSION | 0x8000 };
#elif LTCG
#pragma comment(linker, "/include:_TestSoundLibBuildNumberL")
__declspec(selectany) unsigned short TestSoundLibBuildNumberL[8] = { 'T' | ('E' << 8), 'S' | ('T' << 8), 'S' | ('N' << 8), 'D' | ('D' << 8), 'L',
                                        VER_PRODUCTVERSION | 0x4000 };
#else
#pragma comment(linker, "/include:_TestSoundLibBuildNumber")
__declspec(selectany) unsigned short TestSoundLibBuildNumber[8] = { 'T' | ('E' << 8), 'S' | ('T' << 8), 'S' | ('N' << 8), 'D',
                                        VER_PRODUCTVERSION | 0x4000 };
#endif

#pragma data_seg(pop)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsapi.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsapi.cpp
 *  Content:    DirectSound API objects and entry points.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/06/00    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

#pragma comment(linker, "/merge:DSOUND_RW=DSOUND")
#pragma comment(linker, "/merge:DSOUND_URW=DSOUND")
#pragma comment(linker, "/merge:DSOUND_RD=DSOUND")
#pragma comment(linker, "/section:DSOUND,ERW")

DWORD g_dwDirectSoundTestOverrideSpeakerConfig = -1;
BOOL g_fDirectSoundTestInFinalRelease = FALSE;

INITIALIZED_CRITICAL_SECTION(g_DirectSoundTestCriticalSection);

#ifdef ASSUME_VALID_PARAMETERS

#define NormalizeFloat(a) (a)
#define NormalizeDouble(a) (a)

#endif // ASSUME_VALID_PARAMETERS


/****************************************************************************
 *
 *  DirectSoundCreate
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      CDirectSoundTest ** [out]: DirectSound object.  The caller is responbile
 *                             for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateInternal"

HRESULT
DirectSoundCreateInternal
(
    CDirectSoundTest **         ppDirectSound
)
{
    CDirectSoundTest *          pDirectSound    = NULL;
    HRESULT                 hr              = DS_OK;
    
    DPF_ENTER();

    //
    // Check to see if the DirectSound object already exists
    //

    if(CDirectSoundTest::m_pDirectSound)
    {
        *ppDirectSound = ADDREF(CDirectSoundTest::m_pDirectSound);
    }
    else
    {
        hr = HRFROMP(pDirectSound = NEW(CDirectSoundTest));

        if(SUCCEEDED(hr))
        {
            hr = pDirectSound->Initialize();
        }

        if(SUCCEEDED(hr))
        {
            *ppDirectSound = pDirectSound;
        }
        else
        {
            RELEASE(pDirectSound);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  DirectSoundCreate
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      LPGUID [in]: unused.  Must be NULL.
 *      LPDIRECTSOUND * [out]: DirectSound object.  The caller is responbile
 *                             for freeing this object with Release.
 *      LPUNKNOWN [in]: unused.  Must be NULL.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreateTest"

STDAPI
DirectSoundCreateTest
(
    LPGUID                  pguidDeviceId,
    LPDIRECTSOUND *         ppDirectSound,
    LPUNKNOWN               pControllingUnknown
)
{
    CDirectSoundTest *          pDirectSound;
    HRESULT                 hr;
    
    DPF_ENTER();
    ENTER_EXTERNAL_FUNCTION();

#ifdef VALIDATE_PARAMETERS

    if(!IS_NULL_GUID(*pguidDeviceId))
    {
        DPF_ERROR("NULL or GUID_NULL is the only supported device identifier");
    }

    if(!ppDirectSound)
    {
        DPF_ERROR("Failed to supply an LPDIRECTSOUND *");
    }
    
    if(pControllingUnknown)
    {
        DPF_ERROR("Aggregation is not supported");
    }

#endif // VALIDATE_PARAMETERS

    hr = DirectSoundCreateInternal(&pDirectSound);

    if(SUCCEEDED(hr))
    {
        *ppDirectSound = pDirectSound;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  CDirectSoundTestSettings
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundTestSettings::CDirectSoundTestSettings"

CDirectSoundTestSettings::CDirectSoundTestSettings
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();

#ifndef MCPX_BOOT_LIB

    m_3dParams.HrtfParams = DirectSoundDefault3DListener;
    m_3dParams.I3dl2Params = DirectSoundI3DL2ListenerPreset_Default;

#endif // MCPX_BOOT_LIB

    //
    // Read the speaker configuration from the EEPROM
    //

#ifndef MCPX_BOOT_LIB

    if(DSSPEAKER_IS_VALID(g_dwDirectSoundTestOverrideSpeakerConfig))
    {
        m_dwSpeakerConfig = g_dwDirectSoundTestOverrideSpeakerConfig;
    }
    else
    {
        m_dwSpeakerConfig = XAudioGetSpeakerConfig();
    }

#else // MCPX_BOOT_LIB

    m_dwSpeakerConfig = DSSPEAKER_STEREO;

#endif // MCPX_BOOT_LIB

    //
    // Set default mixbin headroom
    //

    for(i = 0; i < DSMIXBIN_SUBMIX; i++)
    {
        m_abMixBinHeadroom[i] = DSHEADROOM_DEFAULT;
    }

    m_abMixBinHeadroom[DSMIXBIN_SUBMIX] = 0;

    //
    // Set default effect locations
    //

    SetEffectImageLocations(NULL);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundTestSettings
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundTestSettings::~CDirectSoundTestSettings"

CDirectSoundTestSettings::~CDirectSoundTestSettings
(
    void
)
{
    DPF_ENTER();
    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetEffectImageLocations
 *
 *  Description:
 *      Sets effect indeces.
 *
 *  Arguments:
 *      LPCDSEFFECTIMAGELOC [in]: effect locations.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundTestSettings::SetEffectImageLocations"

void
CDirectSoundTestSettings::SetEffectImageLocations
(
    LPCDSEFFECTIMAGELOC     pImageLoc
)
{
    DPF_ENTER();

    if(pImageLoc)
    {
        CopyMemory(&m_EffectLocations, pImageLoc, sizeof(*pImageLoc));
    }
    else
    {
        memset(&m_EffectLocations, 0xFF, sizeof(m_EffectLocations));
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CDirectSoundTest
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundTest::CDirectSoundTest"

CDirectSoundTest *CDirectSoundTest::m_pDirectSound;

#ifdef DEBUG

LPVOID CDirectSoundTest::m_pvEncoderImageData;
DWORD CDirectSoundTest::m_dwEncoderImageSize;

#endif // DEBUG

CDirectSoundTest::CDirectSoundTest
(
    void
)

#ifdef USE_KEEPALIVE_BUFFERS

:   CRefCountTest(2)

#endif // USE_KEEPALIVE_BUFFER

{
    DPF_ENTER();

    //
    // Set the global DirectSound object pointer
    //

    m_pDirectSound = this;

    //
    // Initialize defaults
    //

    InitializeListHead(&m_lst3dVoices);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CDirectSoundTest
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundTest::~CDirectSoundTest"

CDirectSoundTest::~CDirectSoundTest
(
    void
)
{
    DPF_ENTER();

    //
    // Release the global DirectSound object pointer
    //

    m_pDirectSound = NULL;

    //
    // Free owned objects
    //

    RELEASE(m_pDevice);
    RELEASE(m_pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: reference count.
 *
 ****************************************************************************/

#ifdef USE_KEEPALIVE_BUFFERS

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundTest::Release"

DWORD
CDirectSoundTest::Release
(
    void
)
{
    DWORD                   dwRefCount;
    DWORD                   dwStatus;
    HRESULT                 hr;
    DWORD                   i;

    DPF_ENTER();
    ENTER_EXTERNAL_METHOD();

    if((dwRefCount = CRefCountTest::Release()) == NUMELMS(m_apKeepAliveBuffers) + 1)
    {
        dwRefCount = CRefCountTest::Release();
        ASSERT(!dwRefCount);
    }

    DPF_LEAVE(dwRefCount);

    return dwRefCount;
}

#endif // USE_KEEPALIVE_BUFFERS


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundTest::Initialize"

HRESULT
CDirectSoundTest::Initialize
(
    void
)
{

#ifdef USE_KEEPALIVE_BUFFERS

    static const WAVEFORMATEX   wfxSilence              = INIT_PCM_WAVEFORMAT(1, 48000, 16);
    static const SHORT          asSilence[32]           = { 0 };
    DSBUFFERDESC                dsbd;
    DSMIXBINVOLUMEPAIR          MixBinVolumePairs[8];
    DSMIXBINS                   MixBins;
    DWORD                       i, z;

#endif // USE_KEEPALIVE_BUFFERS

    HRESULT                     hr;

    DPF_ENTER();

    //
    // Create the shared settings object
    //

    hr = HRFROMP(m_pSettings = NEW(CDirectSoundTestSettings));

    //
    // Create the device object
    //

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pDevice = NEW(CMcpxAPUTest(m_pSettings)));
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDevice->Initialize();
    }

#ifdef USE_KEEPALIVE_BUFFERS

    //
    // Create dummy buffers.  The MCPX refuses to output any data at least 
    // one voice writes to the speaker mixbins.  We'll burn voices in order 
    // to write silence to all the mixbins all the time.
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));
        ZeroMemory(&MixBinVolumePairs, sizeof(MixBinVolumePairs));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = (LPWAVEFORMATEX)&wfxSilence;
        dsbd.lpMixBins = &MixBins;

        MixBins.dwMixBinCount = NUMELMS(MixBinVolumePairs);
        MixBins.lpMixBinVolumePairs = MixBinVolumePairs;

        for(i = 0; SUCCEEDED(hr) && (i < NUMELMS(m_apKeepAliveBuffers)); i++)
        {
            for(z = 0; z < NUMELMS(MixBinVolumePairs); z++)
            {
                MixBinVolumePairs[z].dwMixBin = (i * NUMELMS(MixBinVolumePairs)) + z;
            }

            if(DSMIXBIN_SUBMIX == MixBinVolumePairs[NUMELMS(MixBinVolumePairs) - 1].dwMixBin)
            {
                MixBins.dwMixBinCount--;
            }

            hr = CreateSoundBuffer(&dsbd, &m_apKeepAliveBuffers[i], NULL);

            if(SUCCEEDED(hr))
            {
                hr = m_apKeepAliveBuffers[i]->SetBufferData((LPVOID)asSilence, sizeof(asSilence));
            }

            if(SUCCEEDED(hr))
            {
                hr = m_apKeepAliveBuffers[i]->Play(0, 0, DSBPLAY_LOOPING);
            }
        }
    }

#endif // USE_KEEPALIVE_BUFFERS

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsapi.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsapi.h
 *  Content:    DirectSound API objects and entry points.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/06/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __DSAPI_H__
#define __DSAPI_H__


//
// Global critical section
//

EXTERN_C BOOL g_fDirectSoundTestInFinalRelease;

EXTERN_C CRITICAL_SECTION g_DirectSoundTestCriticalSection;

__inline BOOL DirectSoundTestEnterCriticalSection(void)
{
    if(PASSIVE_LEVEL != KeGetCurrentIrql())
    {
        return FALSE;
    }

    EnterCriticalSection(&g_DirectSoundTestCriticalSection); 

    return TRUE;
}

__inline void DirectSoundTestLeaveCriticalSection(void)
{
    LeaveCriticalSection(&g_DirectSoundTestCriticalSection);
}

//
// 3D parameters
//

BEGIN_DEFINE_STRUCT()
    DS3DLISTENER    HrtfParams;       // 3D source parameters
    DSI3DL2LISTENER I3dl2Params;      // I3DL2 source parameters
    DWORD           dwParameterMask;  // 3D source properties that have changed
END_DEFINE_STRUCT(DS3DLISTENERPARAMS);

BEGIN_DEFINE_STRUCT()
    DS3DBUFFER      HrtfParams;       // 3D source parameters
    DSI3DL2BUFFER   I3dl2Params;      // I3DL2 source parameters
    DWORD           dwParameterMask;  // 3D source properties that have changed
END_DEFINE_STRUCT(DS3DSOURCEPARAMS);

#ifdef __cplusplus

//
// Forward declarations
//

class CMcpxAPUTest;

//
// Validation object and corresponding macros
//

#ifdef VALIDATE_PARAMETERS

template <DWORD dwSignature> class CValidObject
{
private:
    const DWORD             m_dwSignature;      // Object signature

public:
    CValidObject(void);
    virtual ~CValidObject(void);

public:
    void __AssertValidObject(LPCSTR pszFile, DWORD dwLine, LPCSTR pszFunction);
};

template <DWORD dwSignature> CValidObject<dwSignature>::CValidObject(void)
    : m_dwSignature(dwSignature)
{
}

template <DWORD dwSignature> CValidObject<dwSignature>::~CValidObject(void)
{
}

template <DWORD dwSignature> void CValidObject<dwSignature>::__AssertValidObject(LPCSTR pszFile, DWORD dwLine, LPCSTR pszFunction)
{
    if(!this)
    {
        DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_ERROR, pszFile, dwLine, pszFunction, DPF_LIBRARY);
        DwDbgPrint("NULL \"this\" pointer (%x)", this);
    }
    else if(m_dwSignature != dwSignature)
    {
        DwDbgSetContext(DPRINTF_DEFAULT, DPFLVL_ERROR, pszFile, dwLine, pszFunction, DPF_LIBRARY);
        DwDbgPrint("Invalid \"this\" pointer (%x != %x)", m_dwSignature, dwSignature);
    }
}

#define _AssertValidObject(fname) \
    __AssertValidObject(__FILE__, __LINE__, fname)

#define AssertValidObject() \
    _AssertValidObject(DPF_FNAME)

#else // VALIDATE_PARAMETERS

#define _AssertValidObject(fname)
#define AssertValidObject()

#endif // VALIDATE_PARAMETERS

//
// Automatic (functon-scope) locking mechanism
//

class CAutoLockTest
{
private:
    BOOL                    m_fLocked;

public:
    CAutoLockTest(void);
    ~CAutoLockTest(void);
};

__inline CAutoLockTest::CAutoLockTest(void)
{
    m_fLocked = (BOOLEAN)DirectSoundTestEnterCriticalSection();
}

__inline CAutoLockTest::~CAutoLockTest(void)
{
    if(m_fLocked)
    {
        DirectSoundTestLeaveCriticalSection();
    }
}

#define AutoLockTest() \
    CAutoLockTest __AutoLockTest

//
// API helper macros
//

#define CHECK_FINAL_RELEASE_HRESULT() \
    if(g_fDirectSoundTestInFinalRelease) \
    { \
        DPF_WARNING("DirectSound is in the final stages of shutting down.  No more API calls are allowed."); \
        return DSERR_GENERIC; \
    }

#define CHECK_FINAL_RELEASE_VOID() \
    if(g_fDirectSoundTestInFinalRelease) \
    { \
        DPF_WARNING("DirectSound is in the final stages of shutting down.  No more API calls are allowed."); \
        return; \
    }

#define ENTER_EXTERNAL_FUNCTION() \
    AutoLockTest();

#define _ENTER_EXTERNAL_METHOD(name) \
    AutoLockTest(); \
    CHECK_FINAL_RELEASE_HRESULT(); \
    _AssertValidObject(name)

#define _ENTER_EXTERNAL_METHOD_VOID(name) \
    AutoLockTest(); \
    CHECK_FINAL_RELEASE_VOID(); \
    _AssertValidObject(name)

#define ENTER_EXTERNAL_METHOD() \
    _ENTER_EXTERNAL_METHOD(DPF_FNAME)

#define ENTER_EXTERNAL_METHOD_VOID() \
    _ENTER_EXTERNAL_METHOD_VOID(DPF_FNAME)

//
// DirectSound settings
//

class CDirectSoundTestSettings
    : public CRefCountTest
{
public:
    DWORD               m_dwSpeakerConfig;                      // Speaker configuration
    DSEFFECTIMAGELOC    m_EffectLocations;                      // Effect locations
    BYTE                m_abMixBinHeadroom[DSMIXBIN_COUNT];     // MixBin headroom

#ifndef MCPX_BOOT_LIB                                           
                                                                
    DS3DLISTENERPARAMS  m_3dParams;                             // 3D parameters

#endif // MCPX_BOOT_LIB

public:
    CDirectSoundTestSettings(void);
    virtual ~CDirectSoundTestSettings(void);

public:
    void SetEffectImageLocations(LPCDSEFFECTIMAGELOC pImageLoc);
};

//
// DirectSound implementation
//

#ifdef VALIDATE_PARAMETERS

class CDirectSoundTest
    : public IDirectSound, public CValidObject<'DSND'>, public CRefCountTest

#else // VALIDATE_PARAMETERS

class CDirectSoundTest
    : public IDirectSound, public CRefCountTest

#endif // VALIDATE_PARAMETERS

{

public:
    static CDirectSoundTest *       m_pDirectSound;                                 // The one-and-only DirectSound object
                                                                                
#ifdef DEBUG                                                                    
                                                                                
    static LPVOID               m_pvEncoderImageData;                           // Encoder image data
    static DWORD                m_dwEncoderImageSize;                           // Encoder image size, in bytes
                                                                                
#endif // DEBUG                                                                 
                                                                                
protected:                                                                      
    CDirectSoundTestSettings *      m_pSettings;                                    // Shared settings object
    CMcpxAPUTest *                  m_pDevice;                                      // Device implementation
    LIST_ENTRY                  m_lst3dVoices;                                  // 3D voice list

#ifdef USE_KEEPALIVE_BUFFERS

    LPDIRECTSOUNDBUFFER         m_apKeepAliveBuffers[USE_KEEPALIVE_BUFFERS];    // Dummy buffers used to keep the mixbins working

#endif // USE_KEEPALIVE_BUFFERS

public:
    CDirectSoundTest(void);
    virtual ~CDirectSoundTest(void);

public:
    // Initialization
    HRESULT STDMETHODCALLTYPE Initialize(void);

    // IUnknown methods
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

};

__inline ULONG CDirectSoundTest::AddRef(void)
{
    _ENTER_EXTERNAL_METHOD("CDirectSoundTest::AddRef");
    return CRefCountTest::AddRef();
}

#ifndef USE_KEEPALIVE_BUFFERS

__inline ULONG CDirectSoundTest::Release(void)
{
    _ENTER_EXTERNAL_METHOD("CDirectSoundTest::Release");
    return CRefCountTest::Release();
}

#endif // USE_KEEPALIVE_BUFFERS



#endif // __cplusplus

#endif // __DSAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dspexeccode.h ===
0x0BF080, 
0x000155, 
0x300600, 
0x310000, 
0x62F400, 
0x000800, 
0x330600, 
0x0BF080, 
0x0000DB, 
0x301800, 
0x310000, 
0x62F400, 
0x000800, 
0x330600, 
0x0BF080, 
0x0000EB, 
0x0BF080, 
0x00009E, 
0x301E00, 
0x61F400, 
0x001560, 
0x62F400, 
0x00B000, 
0x63F400, 
0x000280, 
0x0BF080, 
0x0000EB, 
0x44F400, 
0x0049E2, 
0x0200C4, 
0x240000, 
0x447000, 
0x00007F, 
0x447000, 
0x00007E, 
0x07F432, 
0xFFFFFF, 
0x07F430, 
0x000001, 
0x07F431, 
0x000001, 

0x08F484, 
0x000001, 

0x0BF080, 
0x000160, 
0x44F000, 
0xFFFFB3, 
0x447000, 
0x00007F, 
0x0BF080, 
0x00005C, 
0x44F000, 
0xFFFFB3, 
0x447000, 
0x00007D, 
0x0BF080, 
0x000171, 
0x200013, 
0x54F000, 
0xFFFFB3, 
0x44F000, 
0x00007D, 
0x0C1FF8, 
0x059405, 
0x218E00, 
0x200044, 
0x547000, 
0x00007C, 
0x56F400, 
0x000025, 
0x0BF080, 
0x000126, 
0x56F400, 
0x00001E, 
0x0BF080, 
0x000126, 
0x200013, 
0x54F000, 
0xFFFFB3, 
0x44F000, 
0x00007F, 
0x0C1FF8, 
0x059797, 
0x218E00, 
0x200044, 
0x547000, 
0x00007E, 
0x44F400, 
0x019E10, 
0x0C1FF8, 
0x05978F, 
0x050F8E, 
0x56F400, 
0x000006, 
0x0BF080, 
0x000126, 
0x448400, 
0x56F400, 
0x000000, 
0x200045, 
0x0D104A, 
0x000039, 
0x0A0480, 
0x000084, 
0x60F400, 
0x000080, 
0x44F400, 
0x000F80, 
0x0BF080, 
0x000165, 
0x0BF080, 
0x000169, 
0x05F420, 
0xFFFFFF, 
0x0461A0, 
0x0462A0, 
0x0463A0, 
0x0464A0, 
0x0465A0, 
0x60F400, 
0x000012, 
0x61F400, 
0x002971, 
0x62F400, 
0x000818, 
0x638100, 
0x0BF080, 
0x0000DB, 
0x56F400, 
0x000012, 
0x0BF080, 
0x000126, 
0x0A0481, 
0x00009D, 
0x60F400, 
0x00000C, 
0x56F400, 
0x000080, 
0x448000, 
0x200040, 
0x21D100, 
0x448200, 
0x209200, 
0x638300, 
0x0BF080, 
0x0000DB, 
0x56F400, 
0x00000C, 
0x0BF080, 
0x000126, 
0x44F400, 
0x000000, 
0x440400, 
0x56F400, 
0x000018, 
0x0BF080, 
0x000126, 
0x00000C, 
0x64F400, 
0x000025, 
0x44F400, 
0x008000, 
0x61F400, 
0x000024, 
0x446100, 
0x56F400, 
0x00002C, 
0x62F400, 
0x0000CC, 
0x060690, 
0x000017, 
0x565C00, 
0x0140C0, 
0x000007, 
0x44F400, 
0x0059D2, 
0x445C00, 
0x44F400, 
0x000020, 
0x445C00, 
0x07DA84, 
0x445C00, 
0x44F400, 
0x000000, 
0x445C00, 
0x57E100, 
0x575C00, 
0x0140C8, 
0x000800, 
0x576100, 
0x44F400, 
0x0007FF, 
0x445C00, 
0x56F400, 
0x000025, 
0x0BF080, 
0x0000D2, 
0x0140C0, 
0x000023, 
0x21D400, 
0x44F400, 
0x004000, 
0x445C00, 
0x00000C, 
0x001400, 
0x001440, 
0x001420, 
0x001480, 
0x0014A0, 
0x001460, 

0x0D1080, 
0x000038, 

0x08F497, 
0x000000, 

0x0140C6, 
0x003FFF, 
0x08CE15, 
0x08CE14, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x0059E0, 
0x0200CE, 
0x0A7093, 
0x000002, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x0059E2, 
0x0200CE, 
0x0A7093, 
0x000002, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 

0x08F496, 
0x000001, 
0x0CD604, 
0x000000, 
0x00000C, 
0x08F496, 
0x000002, 
0x0CD624, 
0x000000, 
0x00000C, 
0x08F496, 
0x000003, 
0x0CD603, 
0x000000, 
0x00000C, 
0x08F496, 
0x000002, 
0x0CD624, 
0x000000, 
0x08F496, 
0x000003, 
0x0CD603, 
0x000000, 
0x00000C, 
0x08F496, 
0x000004, 
0x0CD623, 
0x000000, 
0x00000C, 
0x08F496, 
0x000004, 
0x0CD623, 
0x000000, 
0x08F496, 
0x000001, 
0x0CD604, 
0x000000, 
0x00000C, 
0x0CC507, 
0x000000, 
0x08F485, 
0x000080, 
0x00000C, 
0x050BC4, 
0x0140C6, 
0xFFDFFF, 
0x08CE14, 
0x050BCE, 
0x050BD6, 
0x00000C, 
0x050B9D, 
0x0140C6, 
0xFFDFFF, 
0x08CE14, 
0x050BC7, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x005BE2, 
0x0200CE, 
0x56F400, 
0x000020, 
0x02088E, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x005BE0, 
0x0200CE, 
0x56F400, 
0x000020, 
0x02088E, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 

0x08F485, 
0x000FFF, 

0x60F400, 
0x000000, 
0x44F400, 
0x001000, 
0x0BF080, 
0x000165, 
0x0BF080, 
0x000169, 
0x00000C, 
0x0A8581, 
0x000160, 
0x08F485, 
0x000002, 
0x00000C, 
0x200013, 
0x06C420, 
0x565800, 
0x00000C, 
0x60F400, 
0x000000, 
0x44F400, 
0x000800, 
0x200013, 
0x06C420, 
0x5E5800, 
0x00000C, 

0x000000, 
0x00000C,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dspbootsndcode.h ===
0x0BF080, 
0x0000AC, 
0x300000, 
0x44F400, 
0x004000, 
0x445800, 
0x44F400, 
0x080403, 
0x445800, 
0x44F400, 
0x000201, 
0x445800, 
0x44F400, 
0x000C00, 
0x445800, 
0x2E0000, 
0x0BF080, 
0x000029, 
0x0BF080, 
0x000020, 

0x08F484, 
0x000001, 

0x0BF080, 
0x0000B7, 
0x0BF080, 
0x000021, 
0x0BF080, 
0x000022, 
0x2E0000, 
0x0BF080, 
0x00007D, 
0x050FD5, 
0x00000C, 
0x00000C, 
0x65F400, 
0x000004, 
0x66F400, 
0x000204, 
0x0BF080, 
0x0000C8, 
0x00000C, 

0x0D1080, 
0x000038, 

0x08F497, 
0x000000, 

0x0140C6, 
0x003FFF, 
0x08CE15, 
0x08CE14, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x0059E0, 
0x0200CE, 
0x0A7093, 
0x000002, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x0059E2, 
0x0200CE, 
0x0A7093, 
0x000002, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 

0x08F496, 
0x000001, 
0x0CD604, 
0x000000, 
0x00000C, 
0x08F496, 
0x000002, 
0x0CD624, 
0x000000, 
0x00000C, 
0x08F496, 
0x000003, 
0x0CD603, 
0x000000, 
0x00000C, 
0x08F496, 
0x000002, 
0x0CD624, 
0x000000, 
0x08F496, 
0x000003, 
0x0CD603, 
0x000000, 
0x00000C, 
0x08F496, 
0x000004, 
0x0CD623, 
0x000000, 
0x00000C, 
0x08F496, 
0x000004, 
0x0CD623, 
0x000000, 
0x08F496, 
0x000001, 
0x0CD604, 
0x000000, 
0x00000C, 
0x0CC507, 
0x000000, 
0x08F485, 
0x000080, 
0x00000C, 
0x050BC4, 
0x0140C6, 
0xFFDFFF, 
0x08CE14, 
0x050BCE, 
0x050BD6, 
0x00000C, 
0x050B9D, 
0x0140C6, 
0xFFDFFF, 
0x08CE14, 
0x050BC7, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x005BE2, 
0x0200CE, 
0x56F400, 
0x000020, 
0x02088E, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 
0x220E00, 
0x0140C6, 
0x003FFF, 
0x0140C2, 
0x004000, 
0x02008E, 
0x56F400, 
0x005BE0, 
0x0200CE, 
0x56F400, 
0x000020, 
0x02088E, 
0x0A7091, 
0x000003, 
0x0A7092, 
0x000004, 
0x00000C, 

0x08F485, 
0x000FFF, 

0x60F400, 
0x000000, 
0x44F400, 
0x001000, 
0x0BF080, 
0x0000BC, 
0x0BF080, 
0x0000C0, 
0x00000C, 
0x0A8581, 
0x0000B7, 
0x08F485, 
0x000002, 
0x00000C, 
0x200013, 
0x06C420, 
0x565800, 
0x00000C, 
0x60F400, 
0x000000, 
0x44F400, 
0x000800, 
0x200013, 
0x06C420, 
0x5E5800, 
0x00000C, 

0x021594, 
0x0CC4A0, 
0x000025, 
0x0AC460, 
0x021584, 

0x0D1080, 
0x0003DC, 
0x44F400, 
0x00C000, 
0x020584, 
0x44F400, 
0x001560, 
0x46F400, 
0x001560, 
0x0215C4, 
0x021D86, 
0x44F400, 
0x000C00, 
0x45F400, 
0x000C20, 
0x46F400, 
0x000C80, 
0x47F400, 
0x000CA0, 
0x021DC4, 
0x022585, 
0x0225C6, 
0x022D87, 
0x22CE00, 
0x0405B0, 
0x061F90, 
0x000003, 
0x565800, 
0x016080, 
0x0D1080, 
0x000419, 
0x0D1080, 
0x000139, 
0x021594, 
0x0CC482, 
0x000006, 
0x0AC442, 
0x021584, 
0x0D1080, 
0x00013B, 
0x0D1080, 
0x00014D, 

0x00000C, 

0x062090, 
0x000003, 
0x44D800, 
0x445900, 
0x00000C, 
0x062090, 
0x000004, 
0x45E000, 
0x2000A0, 
0x565800, 
0x00000C, 
0x062090, 
0x000005, 
0x45D800, 
0x56E100, 
0x2000A3, 
0x565900, 
0x00000C, 
0x062090, 
0x000005, 
0x44D800, 
0x56E100, 
0x200040, 
0x565900, 
0x00000C, 
0x062090, 
0x000005, 
0x44D800, 
0x56D900, 
0x200040, 
0x565A00, 
0x00000C, 
0x062090, 
0x000004, 
0x56E000, 
0x0C1E48, 
0x565800, 
0x00000C, 
0x062090, 
0x000006, 
0x47D800, 
0x56E100, 
0x2000C3, 
0x0C1E4C, 
0x565900, 
0x00000C, 

0x0D1080, 
0x00000D, 
0x00000C, 
0x2E0000, 
0x0A758E, 
0x0001F0, 
0x0A758E, 
0x0001E1, 
0x56F400, 
0x000001, 
0x0A758E, 
0x0001E0, 
0x00000C, 
0x56F400, 
0xFFFFFF, 
0x0A758E, 
0x0001F0, 
0x2E0000, 
0x0A758E, 
0x0001E1, 
0x0A758E, 
0x0001E0, 
0x00000C, 
0x0D1080, 
0x0000C1, 
0x0D1080, 
0x000003, 
0x00000C, 
0x0A75CE, 
0x0001E0, 
0x014085, 
0x0D104A, 
0x000025, 
0x0A75CE, 
0x0001E1, 
0x014085, 
0x0D104A, 
0x000021, 
0x0140C5, 
0x000100, 
0x0D104A, 
0x000092, 
0x0140C5, 
0x000200, 
0x0D104A, 
0x0000A3, 
0x0A75D0, 
0x0001E4, 
0x0A70D0, 
0x000003, 
0x0A75CF, 
0x0001E3, 
0x0A75C6, 
0x0001E2, 
0x062090, 
0x000006, 
0x21E500, 
0x44E000, 
0x2000A0, 
0x565800, 
0x200058, 
0x0A758F, 
0x0001E3, 
0x0A75CE, 
0x0001E1, 
0x016080, 
0x0A758E, 
0x0001E1, 
0x00000C, 
0x0A75C4, 
0x0001E0, 
0x0CC4A0, 
0x000018, 
0x0CC4A5, 
0x000025, 
0x0CC4AD, 
0x000052, 
0x0CC4B1, 
0x00003B, 
0x0CC4B3, 
0x00007F, 
0x0A75CE, 
0x0001E4, 
0x014780, 
0x0A758E, 
0x0001E4, 
0x0A75CE, 
0x0001E5, 
0x0A75C4, 
0x0001E6, 
0x200040, 
0x0A758E, 
0x0001E5, 
0x0D10C0, 
0x000054, 
0x22AE00, 
0x0140C0, 
0x000046, 
0x0A758E, 
0x0001E7, 
0x0140C0, 
0x000059, 
0x0A758E, 
0x0001E5, 
0x0140C0, 
0x000062, 
0x0A758E, 
0x0001E4, 
0x0D10C0, 
0x000042, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x0A758E, 
0x0001E5, 
0x0140C0, 
0x000085, 
0x0A758E, 
0x0001E4, 
0x0140C0, 
0xFFFF6F, 
0x21D000, 
0x0A75C4, 
0x00004B, 
0x0140C0, 
0x000155, 
0x21D100, 
0x0A758E, 
0x0001E7, 
0x060890, 
0x000004, 
0x56D800, 
0x200040, 
0x565900, 
0x0D10C0, 
0x000028, 
0x22AE00, 
0x0140C0, 
0x0000F3, 
0x0A758E, 
0x0001E5, 
0x0140C0, 
0x0000D9, 
0x0A758E, 
0x0001E4, 
0x015C80, 
0x21D000, 
0x0A758E, 
0x0001E7, 
0x0A75CE, 
0x000058, 
0x565800, 
0x566000, 
0x56F400, 
0x000007, 
0x0D10C0, 
0x000014, 
0x22AE00, 
0x0140C0, 
0x000054, 
0x0A758E, 
0x0001E7, 
0x0140C0, 
0x000067, 
0x0A758E, 
0x0001E5, 
0x0140C0, 
0x0000D9, 
0x0A758E, 
0x0001E4, 
0x56F400, 
0x000007, 
0x0D10C0, 
0x000003, 
0x200013, 
0x0A758E, 
0x0001E6, 
0x56F400, 
0xFF8000, 
0x0A758E, 
0x0001E2, 
0x56F400, 
0x7F8000, 
0x0A758E, 
0x0001E3, 
0x050ED5, 
0x0A75D0, 
0x0001E7, 
0x56D800, 
0x0A7590, 
0x0001E7, 
0x016084, 
0x014085, 
0x202913, 
0x21C500, 
0x0A75D0, 
0x0001E5, 
0x0A75D1, 
0x0001E4, 
0x0D1080, 
0x0002B0, 
0x56F400, 
0x008000, 
0x0A758E, 
0x0001E2, 
0x050EC1, 
0x050A5F, 
0x2E0000, 
0x0A758E, 
0x0001E1, 
0x0A75CE, 
0x0001E0, 
0x200032, 
0x0A758E, 
0x0001E0, 
0x050ECD, 
0x0A75CE, 
0x0001F0, 
0x014085, 
0x0D1049, 
0x00001A, 
0x22AF00, 
0x0140C8, 
0x000063, 
0x21F000, 
0x0140C8, 
0x000177, 
0x21F100, 
0x0140C5, 
0x000150, 
0x0D104A, 
0x000010, 
0x014180, 
0x0A758E, 
0x0001F0, 
0x060690, 
0x000009, 
0x56E100, 
0x57D800, 
0x200014, 
0x21C600, 
0x0141D0, 
0x7C49BA, 
0x200018, 
0x575900, 
0x00000C, 
0x060690, 
0x000003, 
0x44D800, 
0x445900, 
0x56F400, 
0xFFFFFF, 
0x0A758E, 
0x0001F0, 
0x050FD7, 

0x0D1080, 
0x00001C, 
0x0D1080, 
0x00000E, 
0x0D1080, 
0xFFFEFD, 
0x0D1080, 
0x000182, 
0x00000C, 
0x0D1080, 
0x000013, 
0x0D1080, 
0xFFFEF9, 
0x0D1080, 
0x000239, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x0001DA, 
0x21D000, 
0x0140C0, 
0xFFFE89, 
0x21D100, 
0x060690, 
0x000003, 
0x44D900, 
0x445800, 
0x00000C, 
0x00000C, 
0x0D1080, 
0x000154, 
0x05F420, 
0xFFFFFF, 
0x0461A0, 
0x0462A0, 
0x0463A0, 
0x0464A0, 
0x0465A0, 
0x244000, 
0x0A75D0, 
0x000005, 
0x0D1080, 
0xFFFEAF, 
0x0A75D0, 
0x000005, 
0x22AE00, 
0x0140C0, 
0x00006A, 
0x21D100, 
0x0D1080, 
0x00014C, 
0x0D1080, 
0xFFFE20, 
0x0D1080, 
0xFFFEE3, 
0x0A75D1, 
0x00000C, 
0x060490, 
0x000006, 
0x0A75D0, 
0x00000B, 
0x0D1080, 
0xFFFEA8, 
0x22AE00, 
0x0A75D0, 
0x000020, 
0x0A75D1, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x00008F, 
0x21D200, 
0x060490, 
0x000005, 
0x44DA00, 
0x0D1080, 
0xFFFE93, 
0x22AE00, 
0x0140C0, 
0x000059, 
0x21D300, 
0x0A75D0, 
0x000010, 
0x0A75D2, 
0x000024, 
0x3A2000, 
0x060490, 
0x000009, 
0x060290, 
0x000006, 
0x225100, 
0x44DB00, 
0x0D1080, 
0xFFFE82, 
0x000000, 
0x44CA00, 
0x0A75D0, 
0x000019, 
0x0A75D1, 
0x00001A, 
0x0A75D2, 
0x000014, 
0x0D1080, 
0xFFFE86, 
0x0A75D0, 
0x000018, 
0x0D1080, 
0xFFFE82, 
0x0A75D0, 
0x00001C, 
0x0A75D1, 
0x000014, 
0x0D1080, 
0xFFFE75, 
0x0D1080, 
0xFFFE73, 
0x0A75D0, 
0x00001F, 
0x0A75D1, 
0x000014, 
0x0D1080, 
0xFFFE6D, 
0x0A75D0, 
0x00001E, 
0x0D1080, 
0xFFFE69, 
0x0A75D0, 
0x000014, 
0x0A75D1, 
0x000015, 
0x0A75D2, 
0x000016, 
0x0D1080, 
0xFFFE68, 
0x0A75D0, 
0x000016, 
0x0A75C4, 
0x000062, 
0x0D1080, 
0xFFFE4E, 
0x0A75D0, 
0x000014, 
0x0A75C4, 
0x000061, 
0x0D1080, 
0xFFFE48, 
0x0D1080, 
0xFFFE46, 
0x0A75D0, 
0x000028, 
0x0A75D1, 
0x000014, 
0x0D1080, 
0xFFFE4D, 
0x0D1080, 
0xFFFE4B, 
0x0A75D0, 
0x000014, 
0x0A75D1, 
0x000028, 
0x0D1080, 
0xFFFE33, 
0x0D1080, 
0xFFFE31, 
0x0A75D0, 
0x000014, 
0x22AE00, 
0x0140C0, 
0x000082, 
0x21D100, 
0x0D1080, 
0x0000D3, 
0x22AE00, 
0x0140C0, 
0x000085, 
0x21D100, 
0x0D1080, 
0x0000CD, 
0x0A75D0, 
0x000019, 
0x22AE00, 
0x0140C0, 
0x00006D, 
0x21D100, 
0x382000, 
0x390300, 
0x060390, 
0x000005, 
0x0D1080, 
0x0000C1, 
0x44C800, 
0x44C900, 
0x0A75D4, 
0x000010, 
0x22AE00, 
0x0140C0, 
0x00008B, 
0x21D300, 
0x382000, 
0x060490, 
0x000010, 
0x0A75D1, 
0x000024, 
0x062090, 
0x00000B, 
0x223000, 
0x227200, 
0x200013, 
0x060490, 
0x000004, 
0x44C800, 
0x45DA00, 
0x2000A3, 
0x565C00, 
0x44D900, 
0x44D300, 
0x0A75D1, 
0x000010, 
0x060490, 
0x000006, 
0x0A75D0, 
0x000016, 
0x0D1080, 
0xFFFE07, 
0x22AE00, 
0x3B0300, 
0x0A75D0, 
0x000010, 
0x0140C0, 
0x000076, 
0x21D300, 
0x060490, 
0x000005, 
0x227100, 
0x0D1080, 
0x000093, 
0x44CB00, 
0x0A75D0, 
0x000005, 
0x0A75D1, 
0x00000B, 
0x0D1080, 
0xFFFDE2, 
0x0A75D1, 
0x00000C, 
0x0A75D2, 
0x000024, 
0x0A75D3, 
0x000028, 
0x0A75D4, 
0x000020, 
0x22AE00, 
0x0140C0, 
0x0001DA, 
0x21D000, 
0x0A75C6, 
0x0001DE, 
0x0A75C7, 
0x0001DF, 
0x0A75CE, 
0x000069, 
0x014485, 
0x0D104A, 
0x000006, 
0x0D1080, 
0x00003A, 
0x0D10C0, 
0x000006, 
0x0D1080, 
0x00004A, 
0x0A75D4, 
0x000022, 
0x0A75D1, 
0x00000E, 
0x0A75D2, 
0x000026, 
0x22AE00, 
0x0140C0, 
0x0001DC, 
0x21D000, 
0x0A75C6, 
0x0001DE, 
0x0A75C7, 
0x0001DF, 
0x0A75CE, 
0x000069, 
0x014485, 
0x0D104A, 
0x000006, 
0x0D1080, 
0x000021, 
0x0D10C0, 
0x000010, 
0x0D1080, 
0x000031, 
0x0A75D0, 
0x000022, 
0x0A75D1, 
0x000009, 
0x0D1080, 
0xFFFDBA, 
0x0A75D0, 
0x000023, 
0x0A75D1, 
0x00000A, 
0x0D1080, 
0xFFFDB4, 
0x0A75D0, 
0x000020, 
0x0A75D1, 
0x000007, 
0x0D1080, 
0xFFFDAE, 
0x0A75D0, 
0x000021, 
0x0A75D1, 
0x000008, 
0x0D1080, 
0xFFFDA8, 
0x0D1080, 
0x000038, 
0x00000C, 
0x392000, 
0x3A2000, 
0x44D800, 
0x062090, 
0x00000F, 
0x45E900, 
0x44D000, 
0x2000A0, 
0x45D900, 
0x44D800, 
0x2000A3, 
0x45EA00, 
0x2000E3, 
0x45DA00, 
0x2000E3, 
0x45DB00, 
0x2000F3, 
0x0C1D0E, 
0x565C00, 
0x00000C, 
0x3C2000, 
0x3A2000, 
0x392000, 
0x44D800, 
0x20CE00, 
0x200022, 
0x21C600, 
0x062090, 
0x000012, 
0x45E900, 
0x44D000, 
0x2000A8, 
0x45D900, 
0x44D800, 
0x2000A0, 
0x45EA00, 
0x2000EB, 
0x45DA00, 
0x2000E3, 
0x45DB00, 
0x2000FB, 
0x2000F3, 
0x0C1D8F, 
0x0C1D0E, 
0x576C00, 
0x565C00, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x000101, 
0x0D1080, 
0xFFFCEB, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x0D1080, 
0xFFFCDE, 
0x00000C, 
0x0201D6, 
0x020997, 
0x062090, 
0x000007, 
0x020194, 
0x2000D0, 
0x45E000, 
0x2000F2, 
0x02018E, 
0x565800, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x21D000, 
0x380700, 
0x280000, 
0x2C2000, 
0x44F400, 
0x004BD2, 
0x46F400, 
0x00000E, 
0x0D1080, 
0x00005B, 
0x44F400, 
0x004BD0, 
0x46F400, 
0x00001F, 
0x0D1080, 
0x000055, 
0x05F420, 
0xFFFFFF, 
0x380700, 
0x22AE00, 
0x0140C0, 
0x0000A2, 
0x21D000, 
0x022DDE, 
0x564800, 
0x0265DE, 
0x060390, 
0x000004, 
0x564800, 
0x0140C0, 
0x000040, 
0x02359E, 
0x060890, 
0x000003, 
0x564800, 
0x016080, 
0x02559E, 
0x060290, 
0x000003, 
0x564800, 
0x016080, 
0x22AE00, 
0x0140C0, 
0x000104, 
0x21D000, 
0x380700, 
0x022DDE, 
0x061F90, 
0x000003, 
0x564800, 
0x016080, 
0x22AE00, 
0x0140C0, 
0x000101, 
0x21D000, 
0x22AE00, 
0x016A80, 
0x21D100, 
0x44E100, 
0x0201D5, 
0x060D90, 
0x000004, 
0x0210C4, 
0x021885, 
0x54C800, 
0x060490, 
0x000009, 
0x44D900, 
0x45D900, 
0x060290, 
0x000004, 
0x0210C4, 
0x021885, 
0x54C800, 
0x000000, 
0x060A90, 
0x000006, 
0x44D900, 
0x0210C4, 
0x45D900, 
0x021885, 
0x54C800, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x21D000, 
0x22AE00, 
0x016A80, 
0x21D100, 
0x060E90, 
0x000006, 
0x44D900, 
0x0210C4, 
0x45D900, 
0x021885, 
0x54C800, 
0x0D1080, 
0x000011, 
0x00000C, 
0x221100, 
0x06C610, 
0x000008, 
0x0A7190, 
0x000000, 
0x0200C4, 
0x02088C, 
0x021088, 
0x221100, 
0x45C800, 
0x44F400, 
0x004000, 
0x446100, 
0x00000C, 
0x0D1080, 
0x000005, 
0x0D1080, 
0x000048, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x000046, 
0x21D200, 
0x0140C0, 
0x000059, 
0x21D000, 
0x0140C0, 
0x000062, 
0x21D100, 
0x260000, 
0x47F400, 
0x000005, 
0x0D1080, 
0x000060, 
0x22AE00, 
0x0140C0, 
0x000093, 
0x21D200, 
0x22AE00, 
0x0140C0, 
0x00009F, 
0x21D000, 
0x0140C0, 
0x000085, 
0x21D100, 
0x0A75C6, 
0x00004B, 
0x47F400, 
0x000008, 
0x0D1080, 
0x00004F, 
0x22AE00, 
0x0140C0, 
0x000054, 
0x21D200, 
0x0140C0, 
0x000067, 
0x21D000, 
0x0140C0, 
0x0000D9, 
0x21D100, 
0x380700, 
0x390700, 
0x060490, 
0x000006, 
0x45DA00, 
0x0D1080, 
0x000048, 
0x44C800, 
0x44C900, 
0x22AE00, 
0x0140C0, 
0x0000F3, 
0x21D000, 
0x0140C0, 
0x0000D9, 
0x21D100, 
0x380700, 
0x390700, 
0x060290, 
0x000007, 
0x0A75C5, 
0x000058, 
0x0D1080, 
0x000037, 
0x44C800, 
0x44C900, 
0x00000C, 
0x22AE00, 
0x0140C0, 
0x00004C, 
0x21D200, 
0x0140C0, 
0x000053, 
0x21D000, 
0x0140C0, 
0x0000BD, 
0x21D100, 
0x380700, 
0x060490, 
0x000007, 
0x260000, 
0x47F400, 
0x000002, 
0x0D1080, 
0x000018, 
0x44C800, 
0x22AE00, 
0x0140C0, 
0x0000D7, 
0x21D000, 
0x0140C0, 
0x0000D9, 
0x21D100, 
0x22AE00, 
0x0140C0, 
0x00009B, 
0x21D200, 
0x380700, 
0x390700, 
0x060490, 
0x000006, 
0x45DA00, 
0x0D1080, 
0x00000F, 
0x44C800, 
0x44C900, 
0x00000C, 
0x390700, 
0x06C710, 
0x000007, 
0x56DA00, 
0x200050, 
0x21C500, 
0x0D1080, 
0x000004, 
0x44C900, 
0x00000C, 
0x02109F, 
0x20006C, 
0x0140CE, 
0xFFFFFC, 
0x01408D, 
0x0D1041, 
0x000005, 
0x021894, 
0x200048, 
0x014188, 
0x02118F, 
0x00000C, 

0x44F400, 
0x000088, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0x400000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0xC00000, 
0x445800, 
0x44F400, 
0x00008F, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0xCCCCCD, 
0x445800, 
0x44F400, 
0x333333, 
0x445800, 
0x44F400, 
0xCCCCCD, 
0x445800, 
0x44F400, 
0xCCCCCD, 
0x445800, 
0x44F400, 
0x000093, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x0001D0, 
0x445800, 
0x44F400, 
0x000430, 
0x445800, 
0x44F400, 
0x000740, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x0001D0, 
0x445800, 
0x44F400, 
0x000430, 
0x445800, 
0x44F400, 
0x000740, 
0x445800, 
0x44F400, 
0x00009B, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0x00AE00, 
0x445800, 
0x44F400, 
0x00FF80, 
0x445800, 
0x44F400, 
0x00D2C0, 
0x445800, 
0x44F400, 
0x0135C0, 
0x445800, 
0x00000C, 
0x200013, 
0x44F400, 
0x00002A, 
0x22AE00, 
0x200040, 
0x21D000, 
0x44F400, 
0x00C000, 
0x445800, 
0x44F400, 
0x00BB7F, 
0x445800, 
0x44F400, 
0x017B80, 
0x445800, 
0x44F400, 
0x00BB7F, 
0x445800, 
0x44F400, 
0x023700, 
0x445800, 
0x44F400, 
0x00BB7F, 
0x445800, 
0x44F400, 
0x02F280, 
0x445800, 
0x44F400, 
0x00BB7F, 
0x445800, 
0x44F400, 
0x03AE00, 
0x445800, 
0x44F400, 
0x00153F, 
0x445800, 
0x44F400, 
0x03C340, 
0x445800, 
0x44F400, 
0x00132F, 
0x445800, 
0x44F400, 
0x03D670, 
0x445800, 
0x44F400, 
0x00140F, 
0x445800, 
0x44F400, 
0x03EA80, 
0x445800, 
0x44F400, 
0x00167F, 
0x445800, 
0x44F400, 
0x040100, 
0x445800, 
0x44F400, 
0x002B7F, 
0x445800, 
0x44F400, 
0x042C80, 
0x445800, 
0x44F400, 
0x0034AF, 
0x445800, 
0x44F400, 
0x046130, 
0x445800, 
0x44F400, 
0x003FDF, 
0x445800, 
0x44F400, 
0x04A110, 
0x445800, 
0x44F400, 
0x004D6F, 
0x445800, 
0x44F400, 
0x04EE80, 
0x445800, 
0x44F400, 
0x01E8BF, 
0x445800, 
0x44F400, 
0x06D740, 
0x445800, 
0x44F400, 
0x01E8BF, 
0x445800, 
0x44F400, 
0x000540, 
0x445800, 
0x44F400, 
0x000620, 
0x445800, 
0x44F400, 
0x0005D0, 
0x445800, 
0x44F400, 
0x0006B0, 
0x445800, 
0x44F400, 
0x000730, 
0x445800, 
0x44F400, 
0x000830, 
0x445800, 
0x44F400, 
0x001E00, 
0x445800, 
0x44F400, 
0x000FE0, 
0x445800, 
0x44F400, 
0x008D50, 
0x445800, 
0x44F400, 
0x00BB80, 
0x445800, 
0x44F400, 
0x00AB40, 
0x445800, 
0x44F400, 
0x00BA10, 
0x445800, 
0x44F400, 
0x00AB40, 
0x445800, 
0x44F400, 
0x0065C0, 
0x445800, 
0x44F400, 
0x0004C0, 
0x445800, 
0x44F400, 
0x000470, 
0x445800, 
0x44F400, 
0x0004A0, 
0x445800, 
0x44F400, 
0x000520, 
0x445800, 
0x44F400, 
0x01E8C0, 
0x445800, 
0x44F400, 
0x7FFFFF, 
0x445800, 
0x44F400, 
0x800001, 
0x445800, 
0x44F400, 
0x800001, 
0x445800, 
0x44F400, 
0x7FFFFF, 
0x445800, 
0x44F400, 
0x7FFFFF, 
0x445800, 
0x44F400, 
0x7FFFFF, 
0x445800, 
0x44F400, 
0x800001, 
0x445800, 
0x44F400, 
0x800001, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x199999, 
0x445800, 
0x44F400, 
0x001E23, 
0x445800, 
0x44F400, 
0x001B7E, 
0x445800, 
0x44F400, 
0x001C8D, 
0x445800, 
0x44F400, 
0x001FB9, 
0x445800, 
0x44F400, 
0x0108FF, 
0x445800, 
0x44F400, 
0x0108FF, 
0x445800, 
0x44F400, 
0x000002, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x6C5A41, 
0x445800, 
0x44F400, 
0x13A5BF, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x62F77D, 
0x445800, 
0x44F400, 
0x091E2F, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x62F77D, 
0x445800, 
0x44F400, 
0x091E2F, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x62F77D, 
0x445800, 
0x44F400, 
0x091E2F, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x385F2C, 
0x445800, 
0x44F400, 
0x36C675, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x3DADA9, 
0x445800, 
0x44F400, 
0x2FEF6E, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x433C8E, 
0x445800, 
0x44F400, 
0x28FC95, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x48BA8F, 
0x445800, 
0x44F400, 
0x2246D7, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x7E6CD8, 
0x445800, 
0x44F400, 
0x0003E9, 
0x445800, 
0x44F400, 
0x000000, 
0x445800, 
0x44F400, 
0x7E6CD8, 
0x445800, 
0x44F400, 
0x0003E9, 
0x445800, 
0x00000C, 

0x000000,
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\encds.h ===
0xD01B40, 0x0002B3, 0x010160, 0xB9C253, 0x050C40, 0x040C37, 0x048AA7, 0x051884, 0x05B7B1, 0x066A4A, 0x0732AE, 0x081385, 0x090FCC, 0x0A2ADB, 0x0B6873, 0x0CCCCD, 0x0E5CA1, 0x101D3F, 0x12149A, 0x144961, 0x16C311, 0x198A13, 0x1CA7D7, 0x2026F3, 0x241347, 0x287A27, 0x2D6A86, 0x32F52D, 0x392CEE, 0x4026E7, 0x47FACD, 0x50C336, 0x5A9DF8, 0x65AC8C, 0x721483, 0x7FFFFF, 0x607000, 0x00062E, 0x20000B, 0x05A406, 0x44F400, 0x008002, 0x447000, 0x000604, 0x050C05, 0x44F400, 0x000002, 0x447000, 0x000604, 0x44F400, 0x00000A, 0x447000, 0x000600, 0x44F400, 0x00060A, 0x447000, 0x000601, 0x44F400, 0x000610, 0x447000, 0x000602, 0x44F400, 0x000616, 0x447000, 0x000603, 0x44F400, 0x00061C, 0x447000, 0x000605, 0x44F400, 0x000622, 0x447000, 0x000606, 0x44F400, 0x000628, 0x447000, 0x000607, 0x44F400, 0x000000, 0x447000, 0x000608, 0x44F400, 0x000100, 0x447000, 0x000609, 0x60F400, 0x00060A, 0x44F400, 0x000000, 0x445800, 0x44F400, 0x000100, 0x445800, 0x44F400, 0x000200, 0x445800, 0x44F400, 0x000300, 0x445800, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x446000, 0x60F400, 0x000610, 0x44F400, 0x000001, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x240000, 0x446000, 0x60F400, 0x000616, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x446000, 0x60F400, 0x00061C, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0x000500, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x60F400, 0x000622, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x60F400, 0x000628, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x62F013, 0x00062E, 0x021ADC, 0x44F400, 0x000001, 0x200045, 0x202941, 0x44F400, 0x00001F, 0x200045, 0x202741, 0x219800, 0x60F400, 0x000305, 0x07E885, 0x050818, 0x60F413, 0x000600, 0x57F400, 0x000016, 0x0D1080, 0x00001C, 0x56F400, 0x000008, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x00000C, 0x60F400, 0x000000, 0x068092, 0x000005, 0x44D800, 0x46D0A1, 0x5658E9, 0x575800, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000016, 0x20004D, 0x0D104A, 0x000008, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x0D1080, 0x0000B8, 0x56F000, 0x000632, 0x200003, 0x05A406, 0x0D1080, 0x000150, 0x0D1080, 0x00012F, 0x050C03, 0x0D1080, 0x000153, 0x0D1080, 0x000130, 0x56F000, 0x000633, 0x014085, 0x05A417, 0x66F000, 0x00062F, 0x3E0300, 0x60EE00, 0x3E0400, 0x61EE00, 0x66F000, 0x000630, 0x3E0300, 0x70EE00, 0x3E0400, 0x71EE00, 0x46F400, 0x5A827A, 0x62F000, 0x000638, 0x06D210, 0x000005, 0x44E000, 0x44C9D0, 0x2000D3, 0x564800, 0x66F000, 0x00062F, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x3E0100, 0x62EE00, 0x66F000, 0x000634, 0x3E0000, 0x64EE00, 0x3E0200, 0x65EE00, 0x66F000, 0x000630, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x3E0100, 0x72EE00, 0x66F000, 0x000635, 0x3E0000, 0x74EE00, 0x76F400, 0x000002, 0x75EE00, 0x45F400, 0x5A827A, 0x66F000, 0x000638, 0x06D600, 0x000467, 0x44CA00, 0x56C800, 0x57C9A3, 0x564CAB, 0x574D00, 0x61F400, 0x000639, 0x65F000, 0x000687, 0x62F400, 0x00066D, 0x66F000, 0x000634, 0x3E0000, 0x60EE00, 0x221400, 0x66F000, 0x000635, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x00058B, 0x61F400, 0x000649, 0x65F000, 0x000687, 0x62F400, 0x000675, 0x66F000, 0x000634, 0x3E0200, 0x60EE00, 0x221400, 0x66F000, 0x000635, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x00058B, 0x61F400, 0x000659, 0x65F000, 0x000688, 0x62F400, 0x00067D, 0x66F000, 0x00062F, 0x3E0300, 0x60EE00, 0x221400, 0x66F000, 0x000630, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000005, 0x0BF080, 0x00058B, 0x66F000, 0x000634, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x66F000, 0x00062F, 0x3E0300, 0x62EE00, 0x66F000, 0x000635, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x66F000, 0x000630, 0x3E0300, 0x72EE00, 0x45F400, 0x5A827A, 0x64F000, 0x000638, 0x06D400, 0x0004CB, 0x44CA00, 0x56E000, 0x57E1A3, 0x5648AF, 0x574900, 0x0D1080, 0x0000B4, 0x00000C, 0x205800, 0x44D800, 0x447000, 0x00062F, 0x44D800, 0x447000, 0x000630, 0x44D800, 0x447000, 0x000631, 0x57D800, 0x0C1890, 0x001027, 0x507000, 0x000632, 0x0C1890, 0x001019, 0x507000, 0x000633, 0x44D800, 0x447000, 0x000634, 0x44D800, 0x447000, 0x000635, 0x44D800, 0x447000, 0x000636, 0x57D800, 0x0C1890, 0x002024, 0x507000, 0x000637, 0x44D800, 0x447000, 0x000638, 0x00000C, 0xC0958D, 0x000000, 0x7ED4E5, 0xC00000, 0x000000, 0x4FE24A, 0x3F67CC, 0x3F67CC, 0x4FE24A, 0x7FFFFF, 0x855BE8, 0x756638, 0x756638, 0x855BE8, 0x7FFFFF, 0xEA1F92, 0xE2404B, 0xE2404B, 0xEA1F92, 0x7FFFFF, 0x812B1B, 0x7DAC85, 0x7ED594, 0x812A6C, 0x7ED594, 0x4FE24A, 0x3F67CC, 0x579426, 0x55FF7F, 0x579426, 0x4FE24A, 0x3F67CC, 0x579426, 0x55FF7F, 0x579426, 0x823E22, 0x7B876D, 0x7B876D, 0x823E22, 0x7FFFFF, 0xB23B5E, 0x27F74F, 0x27F74F, 0xB23B5E, 0x7FFFFF, 0xC08974, 0x000000, 0x7EED19, 0xC00000, 0x000000, 0x462AF8, 0x378620, 0x378620, 0x462AF8, 0x7FFFFF, 0x84EF9E, 0x763A35, 0x763A35, 0x84EF9E, 0x7FFFFF, 0xE648FE, 0xE4B78A, 0xE4B78A, 0xE648FE, 0x7FFFFF, 0x8112E7, 0x7DDC7F, 0x7EEDAC, 0x811254, 0x7EEDAC, 0x462AF8, 0x378620, 0x511DF3, 0x4EF590, 0x511DF3, 0x462AF8, 0x378620, 0x511DF3, 0x4EF590, 0x511DF3, 0x82101A, 0x7BE2ED, 0x7BE2ED, 0x82101A, 0x7FFFFF, 0xAF2EFC, 0x2C7800, 0x2C7800, 0xAF2EFC, 0x7FFFFF, 0x61F413, 0x000639, 0x064E90, 0x000002, 0x565900, 0x00000C, 0x60F400, 0x0004F4, 0x61F400, 0x000000, 0x065A90, 0x000003, 0x07D884, 0x4C5900, 0x56F000, 0x000637, 0x240000, 0x60F400, 0x00002D, 0x61F445, 0x000041, 0x05A405, 0x60F400, 0x000000, 0x61F400, 0x000014, 0x607000, 0x000687, 0x617000, 0x000688, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000000, 0x384E00, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000001, 0x60F400, 0x000639, 0x384E00, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000002, 0x60F400, 0x000639, 0x384E00, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x000021, 0x57DA00, 0x51D200, 0xF0B900, 0x06DE10, 0x00000B, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D2, 0x200010, 0x10DD09, 0x444C4C, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D2, 0x200010, 0x21C409, 0x444C4C, 0x03F184, 0x555A00, 0x515A00, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dspdma.cpp ===
/************************Object to do DSP memory management*****************\
*                                                                           *
* History:                                                                  *
* 12/21/2000 georgioc(MSFT) - redid page table management, integrated with 
* xbox apu driver
*                                                                           *
\***************************************************************************/

#include "dsoundi.h"
#include "dspdma.h"

#define INVALID_INDEX_VALUE         (~0)


CMcpxDspScratchDmaTest::CMcpxDspScratchDmaTest(BOOL fGpScratch)
{
    m_dwMaxPages = 0;
    m_fGpScratch = fGpScratch;
    memset(&m_ctxFxScratch,0,sizeof(m_ctxFxScratch));

}

CMcpxDspScratchDmaTest::~CMcpxDspScratchDmaTest()
{
    if (m_ctxFxScratch.VirtualAddress && m_ctxFxScratch.Size) {

        MmLockUnlockBufferPages(m_ctxFxScratch.VirtualAddress,m_ctxFxScratch.Size,TRUE);
        POOLFREE(m_ctxFxScratch.VirtualAddress);

    }
}

VOID
CMcpxDspScratchDmaTest::Initialize(DWORD dwReservedPages)
{

    ULONG index = (m_fGpScratch == TRUE) ? (index = MCPX_MEM_GPSCRATCH) : (MCPX_MEM_EPSCRATCH);

    //
    // keep a pointer to the proper alloc contexts
    //

    m_pDmaBufferContext = &CMcpxCoreTest::m_ctxMemory[index];
    m_pSgeTableContext = &CMcpxCoreTest::m_ctxMemory[index+1];

    //
    // the caller passes us an array of ALLOC_CONTEXTs
    // first one is the allocation for the scratch memory itself
    // the second is the allocation for the SGE table describing the scratch space
    //

	m_dwMaxPages = (USHORT) (m_pSgeTableContext->Size / NV_PSGE_SIZE);
    m_dwReservedPages = dwReservedPages;

    //
    // initialize the hw SGE table and our internal page table to point to 
    // DMA allocated memory
    //

    MCP1_PRD *pPrd = (MCP1_PRD *)m_pSgeTableContext->VirtualAddress;

    ULONG bytesRemaining = m_pDmaBufferContext->Size;
    ULONG bytesMapped = 0;
    PVOID currentVa = m_pDmaBufferContext->VirtualAddress;

    //
    // note that all pages are 4k aligned and since the dma buffer is 4k length
    // aligned, all sizes are 4k as well..
    //

    for (ULONG i = 0; i < m_dwMaxPages-dwReservedPages; i++)
    {
        pPrd[i].uAddr = CMcpxCoreTest::MapTransfer(&currentVa,
                                               &bytesRemaining,
                                               &bytesMapped);

        pPrd[i].Control.uValue = 0;
        pPrd[i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

    }

    //
    // Set base address for GP/EP scratch
    //

    //
    // tell the hw that all pages are valid , except the reserved ones
    //
    
    if (m_fGpScratch) {

        MCPX_REG_WRITE(NV_PAPU_GPSADDR, m_pSgeTableContext->PhysicalAddress);    
        MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages);

    } else {

        MCPX_REG_WRITE(NV_PAPU_EPSADDR, m_pSgeTableContext->PhysicalAddress);    
        MCPX_REG_WRITE(NV_PAPU_EPSMAXSGE, m_dwMaxPages);
    }

    return;
}

VOID
CMcpxDspScratchDmaTest::AddPages(
    PMCPX_ALLOC_CONTEXT pContextArray,
    DWORD dwCount,
    PULONG pOffset
    )
{
    DWORD dwPageIndex = m_dwMaxPages - m_dwReservedPages;
    ULONG i;

    ASSERT(dwCount <= m_dwReservedPages);

    m_dwReservedPages -= dwCount;

    MCP1_PRD *pPrd = (MCP1_PRD *)CMcpxCoreTest::m_ctxMemory[MCPX_MEM_GPSCRATCHSGE].VirtualAddress;

    for (i=0;i<dwCount;i++) {

        //
        // update the hw SGE table
        //

        pPrd[dwPageIndex+i].uAddr = pContextArray[i].PhysicalAddress;

        pPrd[dwPageIndex+i].Control.uValue = 0;
        pPrd[dwPageIndex+i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

    }

    //
    // tell the hw that all pages are valid , including the reserved ones
    //
    
    MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages);

    //
    // give them the linear offset into our DMA buffer window
    //

    *pOffset = dwPageIndex*PAGE_SIZE;
    return;

}


VOID
CMcpxDspScratchDmaTest::Copy(ULONG uLinOffset, VOID *pSource, ULONG uSize)
{
    //
    // scratch mem is contigious
    //

    PUCHAR pDest = (PUCHAR)m_pDmaBufferContext->VirtualAddress+uLinOffset;
    memcpy(pDest, pSource, uSize);
}

HRESULT
CMcpxDspScratchDmaTest::AdjustFxScratch(DWORD dwSize)
{

    MCPX_ALLOC_CONTEXT ctx;
    ULONG offset,i;
    DWORD dwPageIndex = m_dwMaxPages-m_dwReservedPages;
    MCP1_PRD *pPrd = (MCP1_PRD *)CMcpxCoreTest::m_ctxMemory[MCPX_MEM_GPSCRATCHSGE].VirtualAddress;
    DWORD dwCount = dwSize/PAGE_SIZE;

    if (dwCount > m_dwReservedPages) {

        DPF_ERROR("Effects Image scratch space usage exceed max (%d) pages",
                  MCPX_HW_MAX_FX_SCRATCH_PAGES);

        return DSERR_OUTOFMEMORY;
    }

    ctx.Size = 0;

    if (m_ctxFxScratch.Size < dwSize) {

        //
        // there is already scratch allocated for FX delay lines
        // If its larger than what we need dont do anything.
        // if its less, free whats there and replace it with a new allocation
        //
    
        memcpy(&ctx,&m_ctxFxScratch,sizeof(m_ctxFxScratch));        

        //
        // allocate a new one
        //

        m_ctxFxScratch.Size = dwSize;
        m_ctxFxScratch.VirtualAddress = POOLALLOC(BYTE, m_ctxFxScratch.Size);
        if (m_ctxFxScratch.VirtualAddress == NULL) {

            return E_OUTOFMEMORY;

        }

        MmLockUnlockBufferPages(m_ctxFxScratch.VirtualAddress,dwSize,FALSE);

    } else {

        return DS_OK;
    }


    for (i=0;i<dwCount;i++) {

        //
        // update the hw SGE table
        //

        pPrd[dwPageIndex+i].uAddr = MmGetPhysicalAddress(i*PAGE_SIZE+(PUCHAR)m_ctxFxScratch.VirtualAddress);
        pPrd[dwPageIndex+i].Control.uValue = 0;
        pPrd[dwPageIndex+i].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;       

    }

    //
    // tell the hw, more pages are now valid...
    //

    MCPX_REG_WRITE(NV_PAPU_GPSMAXSGE, m_dwMaxPages-m_dwReservedPages+dwCount);

    //
    // free old allocation
    //

    if (ctx.Size) {

        MmLockUnlockBufferPages(ctx.VirtualAddress,ctx.Size,TRUE);
        POOLFREE(ctx.VirtualAddress);

    }

    return DS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\epdsp.h ===
#if !defined _EPDSP_H_
#define _EPDSP_H_


// BUGBUG make sure all these stays in sync with whatver dolby does

#define AC3_SUPREXECBASE        0x000
#define AC3_LOADERBASE          0x180
#define AC3_LOADERTABLEBASE     0x100  
#define AC3_DOLBYBASE           0x300

#define AC3_MAX_PROGRAMS        6

#define AC3_HEAPLENGTH            8192  // length in words

typedef struct
{
    // the entries in this table are actually all 24-bit DSP words, but when
    // we store DSP code in system memory, we extend each word to fill 32 bits,
    // so we can store them in U032S.  
    ULONG tableSize;         // table size                  
    ULONG maxProgs;          // number of programs

    struct
    {
        ULONG ptr;
        ULONG size;
    } prog[AC3_MAX_PROGRAMS];

    ULONG pcm_ptr;              // pointer to input PCM buffer
    ULONG pcm_size;             // size of input PCM buffer
    ULONG ltrt_ptr;             // pointer to output Lt/Rt buffer  (Note: actually a FIFO index!!)
    ULONG ltrt_size;            // size of output Lt/Rt buffer
    ULONG ac3_ptr;              // pointer to output AC-3 buffer   (Note: actually a FIFO index!!)
    ULONG ac3_size;             // size of output AC-3 buffer
    ULONG config_ptr;           // pointer to config table
    ULONG config_size;          // size of config table
    ULONG pingpong_offset;      // current pingpong buffer offset
    ULONG reserved1;
    ULONG ac3_zero_fill;        // AC3 zero fill (Note: actually a FIFO index!!)
    ULONG reserved2;
    ULONG ac3_preamble;         // AC3 preamble (Note: actually a FIFO index!!)
    ULONG reserved3;
    ULONG heap_ptr;             // pointer to heap data buffer
    ULONG heap_size;            // size of heap data buffer
} DOLBY_LOADER_TABLE;

typedef struct
{
    ULONG table_size;
    ULONG do_surround_encode;
    ULONG do_game_encode;
	ULONG do_downmix_encode;
    ULONG pcm_sample_rate_code;
    ULONG input_ch_config;
    ULONG lfe_present;
    ULONG ac3_dialnorm;
    ULONG ac3_bandwidth;
    ULONG channel_lpf_enabled;
    ULONG lfe_lpf_enabled;
    ULONG dc_hpf_enabled;
    ULONG dynrng_exists;
    ULONG ac3_dynrng_code;
    ULONG compr_exists;
    ULONG ac3_compr_code;
    ULONG surround_gain_enabled;
    ULONG surround_gain;
    ULONG surround_mode;
	ULONG reserved_1;
	ULONG reserved_2;
	ULONG reserved_3;
	ULONG reserved_4;
	ULONG reserved_5;
} DOLBY_CONFIG_TABLE;

#define DOLBY_LOADER_TABLE_OFFSET(x)    (ULONG)&(((DOLBY_LOADER_TABLE *)0)->x)

class CMcpxEPDspManagerTest 
{
public:
    CMcpxEPDspManagerTest();
    ~CMcpxEPDspManagerTest();

public:
	VOID	Initialize(CMcpxGPDspManagerTest *pGlobalProc);
    
    VOID   AC3SetAnalogOutput(ULONG uOffset, ULONG uSize);   // actually a FIFO index
    VOID   AC3SetDigitalOutput(ULONG uOffset, ULONG uSize);  // actually a FIFO index

    VOID *GetScratchSpaceAddr() { return m_pScratchDma->GetScratchSpaceLinAddr(); }

    DOLBY_CONFIG_TABLE* GetDolbyConfigTable();

    // AC3 functions
    static ULONG AC3GetTotalScratchSize();
    static VOID AC3GetSuperExec(PVOID *ppData, ULONG *pSize, ULONG *pBase);
    static VOID AC3GetLoader(PVOID *ppData, ULONG *pSize, ULONG *pBase);
    static VOID AC3GetProgram(ULONG uIndex, PVOID *ppData, ULONG *pSize);
    
    static PVOID AC3GetInitialConfigTable();
    
    static ULONG AC3GetLoaderTableBase() { return AC3_LOADERTABLEBASE; }
    static ULONG AC3GetProgramBase() { return AC3_DOLBYBASE; }
    static ULONG AC3GetMaxPrograms() { return AC3_MAX_PROGRAMS; }
    static ULONG AC3GetHeapSize() { return AC3_HEAPLENGTH; }

private:
    
    VOID   AC3StartGpInput(ULONG uLinOffset);

    CMcpxDspScratchDmaTest  *m_pScratchDma;
    CMcpxGPDspManagerTest   *m_pGlobalProc;
    PUCHAR               m_pConfigTable;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsoundi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsoundi.h
 *  Content:    DirectSound master internal header file.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  07/28/00    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSOUNDI_H__
#define __DSOUNDI_H__

//
// Put all code and data into a DSOUND section
//

#pragma code_seg("DSOUND")
#pragma data_seg("DSOUND_RW")
#pragma const_seg("DSOUND_RD")
#pragma bss_seg("DSOUND_URW")

//
// Preprocessor definitions
//

#if DBG && !defined(DEBUG)
#define DEBUG
#endif

#if defined(DEBUG) && !defined(VALIDATE_PARAMETERS)
#define VALIDATE_PARAMETERS
#endif

//
// Public includes
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>
#include <pci.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#define NODSOUND
#include <xtl.h>
#undef NODSOUND

#ifdef DSNDVER
#include <dsndver.h>
#endif // DSNDVER

#include <xboxp.h>
#include <dsoundp.h>
#include <stdio.h>
#include <stdarg.h>
#include <stddef.h>

//
// Private includes
//

#include "macros.h"
#include "debug.h"
#include "ntlist.h"
#include "memmgr.h"
#include "format.h"
#include "drvhlp.h"
#include "refcount.h"
#include "heap.h"
#include "ac97.h"
#include "dsp.h"
#include "cipher.h"
#include "dsapi.h"
#include "dsperf.h"
#include "mcpxcore.h"

#endif // __DSOUNDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dspdma.h ===
/************************Object to do DSP memory management*****************\
*                                                                           *
* Module: CScratchDma.h		                                                *
*   Object to handle pages/offsets etc for the scratch memory		        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#ifndef _CSCRATCHDMA_
#define _CSCRATCHDMA_

class CMcpxDspScratchDmaTest
{
public:
    CMcpxDspScratchDmaTest(BOOL fGpScratch);
    CMcpxDspScratchDmaTest::~CMcpxDspScratchDmaTest();


public:
    VOID Initialize(DWORD dwReservedPages);
    VOID Copy(ULONG uLinOffset, VOID *pSource, ULONG uSize);
    VOID Put(ULONG uLinOffset, ULONG dwValue)
    {
        *((PULONG)m_pDmaBufferContext->VirtualAddress+uLinOffset/sizeof(DWORD)) = dwValue;
    }
    
    VOID
    AddPages(
        PMCPX_ALLOC_CONTEXT pContextArray,
        DWORD dwCount,
        PULONG pOffset
        );

    VOID *GetScratchTableLinAddr() { return m_pSgeTableContext->VirtualAddress; }
    VOID *GetScratchSpaceLinAddr() { return m_pDmaBufferContext->VirtualAddress; }
    VOID *GetFxScratchSpaceLinAddr() { return m_ctxFxScratch.VirtualAddress; }

    ULONG GetScratchSpacePhysAddr() { return m_pDmaBufferContext->PhysicalAddress; }
    ULONG GetScratchSpaceSize() { return m_pDmaBufferContext->Size; }
    HRESULT AdjustFxScratch(DWORD dwSize);


private:
    
    DWORD       m_dwMaxPages;
    DWORD       m_dwReservedPages;
    BOOL        m_fGpScratch;

    MCPX_ALLOC_CONTEXT *m_pSgeTableContext;
    MCPX_ALLOC_CONTEXT *m_pDmaBufferContext;
    MCPX_ALLOC_CONTEXT m_ctxFxScratch;

    ULONG        m_uRegOffsetValidPages;
};

//
// scratch queue
//


typedef union _MCPX_DSP_MBOX
{
    struct
    {
        UCHAR    write;
        UCHAR    read;
    } Ptr;

    USHORT uVal;
} MCPX_DSP_MBOX, *PMCPX_DSP_MBOX;


class CMcpxDspScratchQ
{
public:

    CMcpxDspScratchQ(ULONG uBaseOffset, 
                     UCHAR uMaxEntries, 
                     CMcpxCoreTest *pApu, 
                     CMcpxDspScratchDmaTest *pDma);

    UCHAR Start();
    VOID Stop();

    BOOL Read(ULONG *puMethod, ULONG *puData);
    BOOL Write(ULONG uMethod, ULONG uData1, ULONG uData2);

    ULONG GetSize()  { return (3*m_uWrapIndex); }
    ULONG GetOffset() { return m_uBaseOffset; }
    
private:
    UCHAR       GetAvailableSlots();
    VOID        Incr(UCHAR *puIndex);
    
    ULONG           m_uBaseOffset;
    ULONG           m_uRegOffset;
    
    MCPX_DSP_MBOX   m_MailBox;
    CMcpxCoreTest        *m_pApu;
    CMcpxDspScratchDmaTest     *m_pScratchDma;
    ULONG            m_uStartFlag;

    UCHAR           m_uWrapIndex;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\epdsp.cpp ===
#include "dsoundi.h"
#include "dspdma.h"
#include "GPDsp.h"
#include "EPDsp.h"

#pragma const_seg("DOLBY")

const ULONG AC3SuperExec[] = 
{
#include <AC3SuperExec.h>
};

const ULONG AC3Loader[] =
{
#include <AC3Loader.h>
};

const ULONG AC3Dolby1[] =
{
#include <AC3Dolby1.h>
};

const ULONG AC3Dolby2[] =
{
#include <AC3Dolby2.h>
};

const ULONG AC3Dolby3[] =
{
#include <AC3Dolby3.h>
};

const ULONG AC3Dolby4[] =
{
#include <AC3Dolby4.h>
};

const ULONG AC3Dolby5[] =
{
#include <AC3Dolby5.h>
};

const ULONG AC3Dolby6[] =
{
#include <AC3Dolby6.h>
};

const DOLBY_CONFIG_TABLE AC3ConfigTable =
{
    24,         // table size
    1,          // perform dolby surround encode flag
    1,          // perform dolby game encode flag
    0,          // perform downmix
    0,          // ac3 pcm sampling rate code
    7,          // ac3 dolby input channel config code (acmod)
    1,          // lfe channel present flag
    31,         // ac3 dialnorm value
    9,          // ac3 channel bandwidth code
    0,          // channel lpf enabled flag
    1,          // lfe channel lpf enabled flag
    1,          // dc hpf enabled flag
    0,          // dynrng exists flag
    0,          // ac3 dynrng code
    1,          // compr exists flag
    0xEF,       // ac3 compr code
    0,          // dolby surround gain enabled flag
    0x65AC8C,   // dolby surround encoder gain value
    2,          // dolby surround mode. Only used for 2/0 Mode
    0,          // reserved 1
    0,          // reserved 2
    0,          // reserved 3
    0,          // reserved 4
    0           // reserved 5
};


#pragma const_seg("DSOUND_RD")


ULONG
CMcpxEPDspManagerTest::AC3GetTotalScratchSize()
{
    // in bytes
    return (AC3_DOLBYBASE * sizeof(ULONG) + 
            sizeof(AC3Dolby1) + 
            sizeof(AC3Dolby2) + 
            sizeof(AC3Dolby3) + 
            sizeof(AC3Dolby4) +
            sizeof(AC3Dolby5) +
            sizeof(AC3Dolby6) +
            sizeof(DOLBY_CONFIG_TABLE) + 
            AC3_HEAPLENGTH * sizeof(ULONG));

}

VOID
CMcpxEPDspManagerTest::AC3GetSuperExec(PVOID *ppData, ULONG *pSize, ULONG *pBase)
{
    *ppData = (PVOID)AC3SuperExec;
    *pSize = sizeof(AC3SuperExec)/sizeof(DWORD);
    *pBase = AC3_SUPREXECBASE;
}

VOID
CMcpxEPDspManagerTest::AC3GetLoader(PVOID *ppData, ULONG *pSize, ULONG *pBase)
{
    *ppData = (PVOID)AC3Loader;
    *pSize = sizeof(AC3Loader)/sizeof(DWORD);
    *pBase = AC3_LOADERBASE;
}

PVOID 
CMcpxEPDspManagerTest::AC3GetInitialConfigTable()
{
    return (PVOID)&AC3ConfigTable;
}

VOID
CMcpxEPDspManagerTest::AC3GetProgram(ULONG uIndex, PVOID *ppData, ULONG *pSize)
{
    switch(uIndex)
    {
    case 0:
        *ppData = (PVOID)AC3Dolby1;
        *pSize = sizeof(AC3Dolby1)/sizeof(DWORD);
        break;
    case 1:
        *ppData = (PVOID)AC3Dolby2;
        *pSize = sizeof(AC3Dolby2)/sizeof(DWORD);
        break;
    case 2:
        *ppData = (PVOID)AC3Dolby3;
        *pSize = sizeof(AC3Dolby3)/sizeof(DWORD);
        break;
    case 3:
        *ppData = (PVOID)AC3Dolby4;
        *pSize = sizeof(AC3Dolby4)/sizeof(DWORD);
        break;

    case 4:
        *ppData = (PVOID)AC3Dolby5;
        *pSize = sizeof(AC3Dolby5)/sizeof(DWORD);
        break;

    case 5:
        *ppData = (PVOID)AC3Dolby6;
        *pSize = sizeof(AC3Dolby6)/sizeof(DWORD);
        break;

    default:
        *ppData = NULL;
        *pSize = 0;
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// dma manager code
//
///////////////////////////////////////////////////////////////////////////////


CMcpxEPDspManagerTest::CMcpxEPDspManagerTest()
{
    m_pGlobalProc = NULL;
    m_pScratchDma = NULL;
    m_pConfigTable = NULL;
}

CMcpxEPDspManagerTest::~CMcpxEPDspManagerTest()
{
    DELETE(m_pScratchDma);
}

VOID   
CMcpxEPDspManagerTest::Initialize(CMcpxGPDspManagerTest *pGlobalProc)
{
    ASSERT(CMcpxCoreTest::m_ctxMemory[MCPX_MEM_EPSCRATCH].VirtualAddress);
    ASSERT(CMcpxCoreTest::m_ctxMemory[MCPX_MEM_EPSCRATCH].PhysicalAddress);
    ASSERT(CMcpxCoreTest::m_ctxMemory[MCPX_MEM_EPSCRATCH].Size);

    ASSERT(CMcpxCoreTest::m_ctxMemory[MCPX_MEM_EPSCRATCHSGE].VirtualAddress);
    ASSERT(CMcpxCoreTest::m_ctxMemory[MCPX_MEM_EPSCRATCHSGE].PhysicalAddress);
    ASSERT(CMcpxCoreTest::m_ctxMemory[MCPX_MEM_EPSCRATCHSGE].Size);

    m_pGlobalProc = pGlobalProc;

    //
    // allocate the scratch Dma. This must be done AFTER allocating the contexts above
    //

    m_pScratchDma = NEW(CMcpxDspScratchDmaTest(FALSE));
    ASSERT(m_pScratchDma);
    
    //
    // initialize the scratch dma object. We dont need do reserve any pages
    //

    m_pScratchDma->Initialize(0);
    
#ifdef DEBUG
    //
    // check if somebody called DirectSoundLoadEncoder
    // if they did, use their code+data instead of re-creating it here..
    //

    if ((CDirectSoundTest::m_pvEncoderImageData != NULL) &&
        (CDirectSoundTest::m_dwEncoderImageSize != 0)) {

        m_pScratchDma->Copy(0, CDirectSoundTest::m_pvEncoderImageData, CDirectSoundTest::m_dwEncoderImageSize);
           
    } else 
#endif 
    {
        //
        // copy the dolby DSP code to the DMA memory pages
        //

        PVOID pCode;
        ULONG uSize;
        ULONG uBase;
    
        //
        // superexec dsp code
        //

        AC3GetSuperExec(&pCode, &uSize, &uBase);
        m_pScratchDma->Copy(uBase*sizeof(ULONG), (VOID *)pCode, uSize*sizeof(ULONG));

        //
        // loader code, copy to dma scratch space
        //

        AC3GetLoader(&pCode, &uSize, &uBase);
        m_pScratchDma->Copy(uBase*sizeof(ULONG), (VOID *)pCode, uSize*sizeof(ULONG));

        //
        // loader table
        //

        DOLBY_LOADER_TABLE LoaderTable;
    
        LoaderTable.tableSize = sizeof(DOLBY_LOADER_TABLE) / sizeof(ULONG);
        LoaderTable.maxProgs = AC3GetMaxPrograms();

        //
        // now copy the four Dolby encoder programs into system memory so the DSP can
        // DMA them when it needs them.  Keep track of the current offset into the
        // buffer, and update the loader table with the addresses as we go along.
        // NOTE: offset and Sizes are in DWORDS!!!!!
        //

        ULONG uCurrentOffset = AC3GetProgramBase();
    
        ULONG uCnt;
        for (uCnt = 0; uCnt < AC3GetMaxPrograms(); uCnt++)
        {
            AC3GetProgram(uCnt, &pCode, &uSize);
            m_pScratchDma->Copy(uCurrentOffset*sizeof(ULONG), (VOID *)pCode, uSize*sizeof(ULONG));

            //
            // update the loader table
            //

            LoaderTable.prog[uCnt].ptr = uCurrentOffset;
            LoaderTable.prog[uCnt].size = uSize ;
            uCurrentOffset += uSize;
        }

        //
        // now the config table
        //

        ULONG *pConfig = (ULONG *)AC3GetInitialConfigTable();

        //
        // Note: the AC3 config table is actually a DOLBY_CONFIG_TABLE,
        // not a ULONG...  The size is contained in the first word of the
        // table, so we will treat it here as a ULONG array.
        //

        uSize = pConfig[0];

        LoaderTable.config_ptr = uCurrentOffset;
        LoaderTable.config_size = uSize;

        m_pScratchDma->Copy(uCurrentOffset*sizeof(ULONG), (VOID *)pConfig, uSize * sizeof(ULONG));

        //
        // save the config table offset into the scratch space.
        //

        m_pConfigTable = uCurrentOffset*sizeof(ULONG) +  (PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr();

        uCurrentOffset += uSize;

        //Init pingpong buffer offset
        LoaderTable.pingpong_offset = 0;
        LoaderTable.reserved1 = 0;
        LoaderTable.reserved2 = 0;
        LoaderTable.reserved3 = 0;
    
        //
        // now for the heap
        //

        LoaderTable.heap_ptr = uCurrentOffset;
        LoaderTable.heap_size = AC3GetHeapSize();
    
        //
        // copy the table to the offset
        //

        m_pScratchDma->Copy(AC3GetLoaderTableBase()*sizeof(ULONG), (VOID *)&LoaderTable, sizeof(DOLBY_LOADER_TABLE));
    }

    //
    // map the same number of pages into the GP scratch.
    // The GP outputs dolby data to SCRATCH space, not to the normal FIFO output buffers
    // THe EP then reads from the GP scratch buffer...
    //

    AC3StartGpInput(CMcpxCoreTest::m_ctxMemory[MCPX_MEM_EPSCRATCH].Size - (MCPX_HW_AC3_NUM_INPUT_PAGES * PAGE_SIZE));

    return;
}


DOLBY_CONFIG_TABLE*
CMcpxEPDspManagerTest::GetDolbyConfigTable()
{
    return (DOLBY_CONFIG_TABLE*) m_pConfigTable;
}

VOID
CMcpxEPDspManagerTest::AC3StartGpInput(ULONG uLinOffset)
{
    //
    // use the last n pages for ac-3 input from the GP
    //

    MCPX_ALLOC_CONTEXT mem[MCPX_HW_AC3_NUM_INPUT_PAGES];
    ULONG uNumOfPagesForInput = MCPX_HW_AC3_NUM_INPUT_PAGES;
    
    ASSERT(m_pGlobalProc);

    ULONG uOffset = AC3GetLoaderTableBase()*sizeof(ULONG);

#ifdef DEBUG
    //
    // check if somebody called DirectSoundLoadEncoder
    // if they did, use their code+data instead of re-creating it here..
    //

    if ((CDirectSoundTest::m_pvEncoderImageData == NULL) &&
        (CDirectSoundTest::m_dwEncoderImageSize == 0)) 
#endif
    {
        //
        // because we ping pong, here we tell the DSP code to address half the total buffer
        //

        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(pcm_ptr), uLinOffset/sizeof(ULONG));
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(pcm_size), AC3_FRAME_SIZE * AC3_NUM_CHANNELS);
    }

    // program the same pages in the GP
    for (ULONG uCnt = 0; uCnt < uNumOfPagesForInput; uCnt++)
    {
        mem[uCnt].VirtualAddress = (PUCHAR) m_pScratchDma->GetScratchSpaceLinAddr() + uLinOffset;
        mem[uCnt].PhysicalAddress = m_pScratchDma->GetScratchSpacePhysAddr() +uLinOffset ;
        mem[uCnt].Size = PAGE_SIZE;
        uLinOffset += mem[uCnt].Size;
    }
    
    m_pGlobalProc->AC3SetOutputBuffer(mem, uNumOfPagesForInput);
    return;
}


VOID
CMcpxEPDspManagerTest::AC3SetAnalogOutput(ULONG uAnalogFifoIndex, ULONG uSize)
{

    ULONG uOffset = AC3GetLoaderTableBase()*sizeof(ULONG);

    ASSERT(m_pGlobalProc);

#ifdef DEBUG
    //
    // check if somebody called DirectSoundLoadEncoder
    // if they did, use their code+data instead of re-creating it here..
    //

    if ((CDirectSoundTest::m_pvEncoderImageData == NULL) &&
        (CDirectSoundTest::m_dwEncoderImageSize == 0)) 
#endif
    {
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ltrt_ptr), uAnalogFifoIndex);
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ltrt_size), uSize/sizeof(ULONG));
    }

    return;
}

VOID
CMcpxEPDspManagerTest::AC3SetDigitalOutput(ULONG uDigitalFifoIndex, ULONG uSize)
{

    ULONG uOffset = AC3GetLoaderTableBase() * sizeof(ULONG);
    ASSERT(m_pGlobalProc);

#ifdef DEBUG
    //
    // check if somebody called DirectSoundLoadEncoder
    // if they did, use their code+data instead of re-creating it here..
    //

    if ((CDirectSoundTest::m_pvEncoderImageData == NULL) &&
        (CDirectSoundTest::m_dwEncoderImageSize == 0)) 
#endif
    {
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_ptr), uDigitalFifoIndex);
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_zero_fill), 1);
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_preamble), 1);
        m_pScratchDma->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_size), uSize/sizeof(ULONG));
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\format.c ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       format.c
 *  Content:    WAVEFORMATEX helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/10/00    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"


/****************************************************************************
 *
 *  XAudioCreatePcmFormat
 *
 *  Description:
 *      Creates a PCM wave format structure.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      WORD [in]: count of bits per sample.
 *      LPWAVEFORMATEX [out]: format data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "XAudioCreatePcmFormat"

void 
XAudioCreatePcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    WORD                    wBitsPerSample, 
    LPWAVEFORMATEX          pwfx
)
{
    DPF_ENTER();
    
    ASSERT(pwfx);

    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = nChannels;
    pwfx->nSamplesPerSec = nSamplesPerSec;
    pwfx->wBitsPerSample = wBitsPerSample;
    pwfx->nBlockAlign = nChannels * wBitsPerSample / 8;
    pwfx->nAvgBytesPerSec = nSamplesPerSec * pwfx->nBlockAlign;
    pwfx->cbSize = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  XAudioCreateAdpcmFormat
 *
 *  Description:
 *      Creates an Xbox ADPCM wave format structure.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPWAVEFORMATEX [out]: format data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "XAudioCreateAdpcmFormat"

void 
XAudioCreateAdpcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    LPXBOXADPCMWAVEFORMAT   pwfx
)
{
    static const WORD       wSamplesPerBlock    = 64;
    static const WORD       wBitsPerSample      = 4;
    static const WORD       wBytesPerBlock      = 36;
    
    DPF_ENTER();
    
    ASSERT(pwfx);

    pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
    pwfx->wfx.nChannels = nChannels;
    pwfx->wfx.nSamplesPerSec = nSamplesPerSec;
    pwfx->wfx.wBitsPerSample = wBitsPerSample;
    pwfx->wfx.nBlockAlign = nChannels * wBytesPerBlock;
    pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec / wSamplesPerBlock * wBytesPerBlock;
    pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
    pwfx->wSamplesPerBlock = wSamplesPerBlock;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  FmtCreateInternal
 *
 *  Description:
 *      Initializes a DSWAVEFORMAT structure based on a PCMWAVEFORMAT,
 *      WAVEFORMATEX or WAVEFORMATEX derivitave.
 *
 *  Arguments:
 *      LPDSWAVEFORMAT [out]: DirectSound format structure.
 *      LPCWAVEFORMATEX [in]: generic format structure.
 *
 *  Returns:  
 *      DWORD: mixbin assignment mask, if any.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FmtCreateInternal"

DWORD
FmtCreateInternal
(
    LPDSWAVEFORMAT          pDest,
    LPCWAVEFORMATEX         pSource
)
{
    DWORD                   dwChannelMask   = 0;
    
    DPF_ENTER();

    ASSERT(pDest);
    ASSERT(pSource);

    switch(pSource->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            FmtPcmToInternal(pDest, pSource);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            FmtAdpcmToInternal(pDest, (LPCXBOXADPCMWAVEFORMAT)pSource);
            break;

#ifndef MCPX_BOOT_LIB

        case WAVE_FORMAT_EXTENSIBLE:
            dwChannelMask = FmtExtensibleToInternal(pDest, (LPCWAVEFORMATEXTENSIBLE)pSource);
            break;

#endif // MCPX_BOOT_LIB

        default:
            ASSERTMSG("Unexpected format tag");
            break;
    }

    DPF_LEAVE(dwChannelMask);

    return dwChannelMask;
}
            

/****************************************************************************
 *
 *  FmtIsValid
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FmtIsValid"

BOOL
FmtIsValid
(
    LPCWAVEFORMATEX         pwfx
)
{
    BOOL                    fSuccess;
    
    DPF_ENTER();

    ASSERT(pwfx);

    switch(pwfx->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            fSuccess = FmtIsValidPcm(pwfx);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            fSuccess = FmtIsValidAdpcm((LPCXBOXADPCMWAVEFORMAT)pwfx);
            break;

#ifndef MCPX_BOOT_LIB

        case WAVE_FORMAT_EXTENSIBLE:
            fSuccess = FmtIsValidExtensible((LPCWAVEFORMATEXTENSIBLE)pwfx);
            break;

#endif // MCPX_BOOT_LIB

        default:
            DPF_ERROR("Unsupported format tag");
            fSuccess = FALSE;
            break;
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}
            

/****************************************************************************
 *
 *  FmtPcmToInternal
 *
 *  Description:
 *      Initializes a DSWAVEFORMAT structure based on a PCMWAVEFORMAT 
 *      structure.
 *
 *  Arguments:
 *      LPDSWAVEFORMAT [out]: DirectSound format structure.
 *      LPCWAVEFORMATEX [in]: generic format structure.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FmtPcmToInternal"

void
FmtPcmToInternal
(
    LPDSWAVEFORMAT          pDest,
    LPCWAVEFORMATEX         pSource
)
{
    DPF_ENTER();

    ASSERT(pDest);
    ASSERT(pSource);

    ASSERT(pSource->nChannels <= 0xFF);
    ASSERT(pSource->wBitsPerSample <= 0xFF);
    ASSERT(pSource->nBlockAlign <= 0xFF);

    pDest->wFormatTag = WAVE_FORMAT_PCM;
    pDest->nChannels = (BYTE)pSource->nChannels;
    pDest->wBitsPerSample = (BYTE)pSource->wBitsPerSample;
    pDest->nSamplesPerSec = pSource->nSamplesPerSec;
    pDest->nBlockAlign = (BYTE)pSource->nBlockAlign;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  FmtIsValidPcm
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FmtIsValidPcm"

BOOL 
FmtIsValidPcm
(
    LPCWAVEFORMATEX         pwfx
)
{
    BOOL                    fValid  = TRUE;

    DPF_ENTER();

    ASSERT(pwfx);

    if(WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        DPF_ERROR("Format tag not PCM");
        fValid = FALSE;
    }
    
    if((1 != pwfx->nChannels) && (2 != pwfx->nChannels) && (4 != pwfx->nChannels) && (6 != pwfx->nChannels))
    {
        DPF_ERROR("Invalid channel count");
        fValid = FALSE;
    }

    if((8 != pwfx->wBitsPerSample) && (16 != pwfx->wBitsPerSample))
    {
        DPF_ERROR("Invalid sample bit resolution");
        fValid = FALSE;
    }

    if((pwfx->nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->nSamplesPerSec > DSBFREQUENCY_MAX))
    {
        DPF_ERROR("Invalid sampling rate");
        fValid = FALSE;
    }

    if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)
    {
        DPF_ERROR("Bad block alignment");
        fValid = FALSE;
    }

    DPF_LEAVE(fValid);

    return fValid;
}


/****************************************************************************
 *
 *  FmtAdpcmToInternal
 *
 *  Description:
 *      Initializes a DSWAVEFORMAT structure based on an XBOXADPCMWAVEFORMAT 
 *      structure.
 *
 *  Arguments:
 *      LPDSWAVEFORMAT [out]: DirectSound format structure.
 *      LPCXBOXADPCMWAVEFORMAT [in]: generic format structure.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FmtAdpcmToInternal"

void
FmtAdpcmToInternal
(
    LPDSWAVEFORMAT          pDest,
    LPCXBOXADPCMWAVEFORMAT  pSource
)
{
    static const BYTE       wBitsPerSample      = 4;

    DPF_ENTER();

    ASSERT(pDest);
    ASSERT(pSource);

    ASSERT(pSource->wfx.nChannels <= 0xFF);
    ASSERT(pSource->wfx.wBitsPerSample <= 0xFF);
    ASSERT(pSource->wfx.nBlockAlign <= 0xFF);

    pDest->wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
    pDest->nChannels = (BYTE)pSource->wfx.nChannels;
    pDest->wBitsPerSample = (BYTE)wBitsPerSample;
    pDest->nSamplesPerSec = pSource->wfx.nSamplesPerSec;
    pDest->nBlockAlign = (BYTE)pSource->wfx.nBlockAlign;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  FmtIsValidAdpcm
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCXBOXADPCMWAVEFORMAT [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FmtIsValidAdpcm"

BOOL 
FmtIsValidAdpcm
(
    LPCXBOXADPCMWAVEFORMAT  pwfx
)
{
    static const WORD       wSamplesPerBlock    = 64;
    static const WORD       wBitsPerSample      = 4;
    static const WORD       wBytesPerBlock      = 36;
    BOOL                    fValid              = TRUE;

    DPF_ENTER();

    ASSERT(pwfx);

    if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)
    {
        DPF_ERROR("Format tag not XBOX_ADPCM");
        fValid = FALSE;
    }
    
    if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)
    {
        DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->wfx));
        fValid = FALSE;
    }
    
    if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > 2))
    {
        DPF_ERROR("Invalid channel count");
        fValid = FALSE;
    }

    if((pwfx->wfx.nSamplesPerSec < DSBFREQUENCY_MIN) || (pwfx->wfx.nSamplesPerSec > DSBFREQUENCY_MAX))
    {
        DPF_ERROR("Invalid sampling rate");
        fValid = FALSE;
    }

    if(wBitsPerSample != pwfx->wfx.wBitsPerSample)
    {
        DPF_ERROR("Invalid sample bit resolution");
        fValid = FALSE;
    }

    if(wSamplesPerBlock != pwfx->wSamplesPerBlock)
    {
        DPF_ERROR("Invalid samples per block");
        fValid = FALSE;
    }

    if(wBytesPerBlock * pwfx->wfx.nChannels != pwfx->wfx.nBlockAlign)
    {
        DPF_ERROR("Bad block-alignment");
        fValid = FALSE;
    }

    DPF_LEAVE(fValid);

    return fValid;
}


/****************************************************************************
 *
 *  FmtExtensibleToInternal
 *
 *  Description:
 *      Initializes a DSWAVEFORMAT structure based on a WAVEFORMATEXTENSIBLE
 *      structure.
 *
 *  Arguments:
 *      LPDSWAVEFORMAT [out]: DirectSound format structure.
 *      LPCWAVEFORMATEXTENSIBLE [in]: generic format structure.
 *
 *  Returns:  
 *      DWORD: mixbin assignment mask, if any.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "FmtExtensibleToInternal"

DWORD
FmtExtensibleToInternal
(
    LPDSWAVEFORMAT          pDest,
    LPCWAVEFORMATEXTENSIBLE pSource
)
{
    DPF_ENTER();

    ASSERT(pDest);
    ASSERT(pSource);

    if(IsEqualGUID(&pSource->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM))
    {
        FmtPcmToInternal(pDest, &pSource->Format);
    }
    else if(IsEqualGUID(&pSource->SubFormat, &KSDATAFORMAT_SUBTYPE_XBOX_ADPCM))
    {
        FmtAdpcmToInternal(pDest, (LPCXBOXADPCMWAVEFORMAT)&pSource->Format);
    }
    else
    {
        ASSERTMSG("Unexpected subformat");
    }

    DPF_LEAVE(pSource->dwChannelMask);

    return pSource->dwChannelMask;
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  FmtIsValidExtensible
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEXTENSIBLE [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "FmtIsValidExtensible"

BOOL 
FmtIsValidExtensible
(
    LPCWAVEFORMATEXTENSIBLE pwfx
)
{
    BOOL                    fValid  = TRUE;

    DPF_ENTER();

    ASSERT(pwfx);

    if(WAVE_FORMAT_EXTENSIBLE != pwfx->Format.wFormatTag)
    {
        DPF_ERROR("Format tag not EXTENSIBLE");
        fValid = FALSE;
    }
    
    if(sizeof(*pwfx) - sizeof(pwfx->Format) != pwfx->Format.cbSize)
    {
        DPF_ERROR("cbSize not %lu", sizeof(*pwfx) - sizeof(pwfx->Format));
        fValid = FALSE;
    }
    
    if(IsEqualGUID(&pwfx->SubFormat, &KSDATAFORMAT_SUBTYPE_PCM))
    {
        if(!FmtIsValidPcm(&pwfx->Format))
        {
            fValid = FALSE;
        }

        if(pwfx->Samples.wValidBitsPerSample != pwfx->Format.wBitsPerSample)
        {
            DPF_ERROR("wValidBitsPerSample must equal wBitsPerSample");
            fValid = FALSE;
        }

        if(pwfx->Samples.wReserved)
        {
            DPF_ERROR("wReserved must be 0 for SUBTYPE_PCM");
            fValid = FALSE;
        }
    }
    else if(IsEqualGUID(&pwfx->SubFormat, &KSDATAFORMAT_SUBTYPE_XBOX_ADPCM))
    {
        if(!FmtIsValidAdpcm((LPCXBOXADPCMWAVEFORMAT)&pwfx->Format))
        {
            fValid = FALSE;
        }
    }
    else
    {
        DPF_ERROR("Invalid sub-format identifier");
        fValid = FALSE;
    }

    if(pwfx->dwChannelMask & ~SPEAKER_MASK)
    {
        DPF_ERROR("Invalid channel mask");
        fValid = FALSE;
    }

    DPF_LEAVE(fValid);

    return fValid;
}

#endif // MCPX_BOOT_LIB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsperf.h ===
/***************************************************************************
 *
 *  Copyright (C) 8/29/2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsperf.h
 *  Content:    Performance tools.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/29/2001   dereks  Created.
 *
 ****************************************************************************/

#ifndef __DSPERF_H__
#define __DSPERF_H__

#if defined(DEBUG) && !defined(IMPLEMENT_PERF_COUNTERS)
#define IMPLEMENT_PERF_COUNTERS
#endif // IMPLEMENT_PERF_COUNTERS

BEGIN_DEFINE_STRUCT()
    LPCSTR      pszName;
    DWORD       dwFlags;
    LPVOID      pvData;
END_DEFINE_STRUCT(DSPERFCOUNTER);

#ifdef __cplusplus

//
// Performance monitor object
//

class CDirectSoundPerformanceMonitor
{

#ifdef IMPLEMENT_PERF_COUNTERS

private:
    static const DSPERFCOUNTER  m_aCounters[];

#endif // IMPLEMENT_PERF_COUNTERS

public:
    static void RegisterCounters(void);
    static void UnregisterCounters(void);

#ifdef IMPLEMENT_PERF_COUNTERS

protected:
    static HRESULT STDAPICALLTYPE GetFree2dVoices(PLARGE_INTEGER pliData, PLARGE_INTEGER pliUnused);
    static HRESULT STDAPICALLTYPE GetFree3dVoices(PLARGE_INTEGER pliData, PLARGE_INTEGER pliUnused);
    static HRESULT STDAPICALLTYPE GetFreeSGECount(PLARGE_INTEGER pliData, PLARGE_INTEGER pliUnused);
    static HRESULT STDAPICALLTYPE GetFreeGPCycles(PLARGE_INTEGER pliData, PLARGE_INTEGER pliUnused);
    static HRESULT STDAPICALLTYPE GetFreeEPCycles(PLARGE_INTEGER pliData, PLARGE_INTEGER pliUnused);

private:
    static DWORD GetFreeDSPCycles(DWORD dwAddress, DWORD dwSamplesPerClock);

#endif // IMPLEMENT_PERF_COUNTERS

};

#ifndef IMPLEMENT_PERF_COUNTERS

__inline void CDirectSoundPerformanceMonitor::RegisterCounters(void)
{
}

__inline void CDirectSoundPerformanceMonitor::UnregisterCounters(void)
{
}

#endif // IMPLEMENT_PERF_COUNTERS

#endif // __cplusplus

#endif // __DSPERF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\format.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       format.h
 *  Content:    Wave format helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/10/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __FORMAT_H__
#define __FORMAT_H__

//
// Format initialization macros
//

#define INIT_PCM_WAVEFORMAT_EX(channels, frequency, samplebits, containerbits) \
    { \
        WAVE_FORMAT_PCM, \
        (WORD)(channels), \
        (DWORD)(frequency), \
        (DWORD)(frequency) * (DWORD)(channels) * (DWORD)(containerbits) / 8, \
        (WORD)(channels) * (WORD)(containerbits) / 8, \
        (WORD)(samplebits), \
        0 \
    }

#define INIT_PCM_WAVEFORMAT(channels, frequency, samplebits) \
    INIT_PCM_WAVEFORMAT_EX(channels, frequency, samplebits, samplebits)

#define INIT_XBOX_ADPCM_WAVEFORMAT(channels, frequency) \
    { \
        { \
            WAVE_FORMAT_XBOX_ADPCM, \
            (WORD)(channels), \
            (DWORD)(frequency), \
            (DWORD)(frequency) / 64 * 36, \
            (WORD)(channels) * 36, \
            4, \
            2 \
        }, \
        64 \
    }

#define INIT_PCM_WAVEFORMATEXTENSIBLE(channels, frequency, samplebits, containerbits, channelmask) \
    { \
        { \
            WAVE_FORMAT_EXTENSIBLE, \
            (WORD)(channels), \
            (DWORD)(frequency), \
            (DWORD)(frequency) * (DWORD)(channels) * (DWORD)(containerbits) / 8, \
            (WORD)(channels) * (WORD)(containerbits) / 8, \
            (WORD)(samplebits), \
            0 \
        }, \
        (WORD)(containerbits), \
        (DWORD)(channelmask), \
        KSDATAFORMAT_SUBTYPE_PCM \
    }
        
#define INIT_XBOX_ADPCM_WAVEFORMATEXTENSIBLE(channels, frequency, channelmask) \
    { \
        { \
            WAVE_FORMAT_EXTENSIBLE, \
            (WORD)(channels), \
            (DWORD)(frequency), \
            (DWORD)(frequency) / 64 * 36, \
            (WORD)(channels) * 36, \
            4, \
            2 \
        }, \
        64 \
        (DWORD)(channelmask), \
        KSDATAFORMAT_SUBTYPE_XBOX_ADPCM \
    }

//
// DirectSound internal format structure
//

BEGIN_DEFINE_STRUCT()
    WORD    wFormatTag;             // Format tag
    BYTE    nChannels;              // Channel count
    BYTE    wBitsPerSample;         // Count of bits per mono sample
    DWORD   nSamplesPerSec;         // Sampling rate
    DWORD   nBlockAlign;            // Block size of data (32-bit for alignment only)
END_DEFINE_STRUCT(DSWAVEFORMAT);

//
// Wave format helper functions
//

EXTERN_C DWORD FmtCreateInternal(LPDSWAVEFORMAT pDest, LPCWAVEFORMATEX pSource);
EXTERN_C BOOL FmtIsValid(LPCWAVEFORMATEX pwfx);
EXTERN_C void FmtPcmToInternal(LPDSWAVEFORMAT pDest, LPCWAVEFORMATEX pSource);
EXTERN_C BOOL FmtIsValidPcm(LPCWAVEFORMATEX pwfx);
EXTERN_C void FmtAdpcmToInternal(LPDSWAVEFORMAT pDest, LPCXBOXADPCMWAVEFORMAT pSource);
EXTERN_C BOOL FmtIsValidAdpcm(LPCXBOXADPCMWAVEFORMAT pwfx);

#ifndef MCPX_BOOT_LIB

EXTERN_C DWORD FmtExtensibleToInternal(LPDSWAVEFORMAT pDest, LPCWAVEFORMATEXTENSIBLE pSource);
EXTERN_C BOOL FmtIsValidExtensible(LPCWAVEFORMATEXTENSIBLE pwfx);

#endif // MCPX_BOOT_LIB

#endif // __FORMAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\makefile.inc ===
DSP: dsstdfx.bin defaultscratchimg.bin

$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@

dsstdfx.bin defaultscratchimg.bin: dsp\ini\$*.ini
    set _XGPIMAGE_DSP_CODE_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\bin
    set _XGPIMAGE_INI_PATH=%%_NTDRIVE%%%%_NTROOT%%\private\windows\directx\dsound\dsound\dsp\ini
    xgpimage $** $(_NT386TREE)\$*.bin $(SDK_INC_PATH)\$*.h
    copy $(SDK_INC_PATH)\$*.h $(XDK_INC_PATH)\$*.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\heap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       heap.cpp
 *  Content:    Heap implementation objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/24/01    dereks  Created.
 *
 ****************************************************************************/

// #define MCPX_NO_SGE_SHARING

#include "dsoundi.h"

#define DPF_SGE_HEAP DPF_BLAB
#define DPF_MEM_HEAP DPF_BLAB


EXTERN_C DWORD g_dwDirectSoundTestPoolMemoryUsage = 0;
EXTERN_C DWORD g_dwDirectSoundTestPhysicalMemoryUsage = 0;
EXTERN_C DWORD g_dwDirectSoundTestPhysicalMemorySlop = 0;
EXTERN_C DWORD g_dwDirectSoundTestPhysicalMemoryRecovered = 0;


CMcpxSlopMemoryHeapTest *g_pDirectSoundTestSlopMemoryHeap = NULL;


/****************************************************************************
 *
 *  CMcpxBufferSgeHeapTest
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::CMcpxBufferSgeHeapTest"

CMcpxBufferSgeHeapTest::CMcpxBufferSgeHeapTest
(
    void
)
{
    DPF_ENTER();

    InitializeListHead(&m_lstRuns);
    InitializeListHead(&m_lstMarkers);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxBufferSgeHeapTest
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::~CMcpxBufferSgeHeapTest"

CMcpxBufferSgeHeapTest::~CMcpxBufferSgeHeapTest
(
    void
)
{
    DPF_ENTER();

    MEMFREE(m_paMarkers);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      WORD [in]: count of elements managed by the heap.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::Initialize"

HRESULT
CMcpxBufferSgeHeapTest::Initialize
(
    WORD                    nLength
)
{
    HRESULT                 hr;
    DWORD                   i;

    m_nFreeElementCount = nLength;

    //
    // Allocate markers, include one extra marker for slop
    //

    hr = HRFROMP(m_paMarkers = MEMALLOC(SGEHEAPRUNMARKER, nLength + 1));

    //
    // All elements are initially free, so add 1 run marker to the run list
    //

    if(SUCCEEDED(hr))
    {
        m_pLargestFreeRunMarker = CreateMarker(&m_paMarkers[0], 0, nLength, &m_lstRuns);
    }

    //
    // The remaining markers are unused
    //

    if(SUCCEEDED(hr))
    {
        for(i = 1; i < (DWORD)nLength + 1; i++)
        {
            InsertTailListUninit(&m_lstMarkers, &m_paMarkers[i].leListEntry);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  Alloc
 *
 *  Description:
 *      Allocates a run of elements.
 *
 *  Arguments:
 *      LPVOID [in]: buffer.
 *      DWORD [in]: buffer size, in bytes.
 *
 *  Returns:  
 *      LPSGEHEAPRUNMARKER: run marker or NULL if the request could not be
 *                          completed.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::Alloc"

LPSGEHEAPRUNMARKER
CMcpxBufferSgeHeapTest::Alloc
(
    LPVOID                  pvBaseAddress,
    DWORD                   dwBufferSize
)
{
    LPSGEHEAPRUNMARKER      pRunMarker      = NULL;
    PLIST_ENTRY             pleEntry;
    LPSGEHEAPRUNMARKER      pMarkerNode;
    WORD                    nLength;
    CIrql                   irql;
    
    DPF_ENTER();

    //
    // Page-align the buffer address and size
    //

    nLength = (WORD)COMPUTE_PAGES_SPANNED(pvBaseAddress, dwBufferSize);
    pvBaseAddress = (LPVOID)((DWORD)pvBaseAddress & ~(PAGE_SIZE - 1));

    //
    // Check the list for a buffer whose SGEs we can share
    //

    irql.Raise();

#ifndef MCPX_NO_SGE_SHARING

    for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
    {
        AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

        pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

        if(pMarkerNode->dwRefCount)
        {
            if((DWORD)pvBaseAddress == (DWORD)pMarkerNode->pvBaseAddress)
            {
                if(nLength == pMarkerNode->nLength)
                {
                    pRunMarker = pMarkerNode;
                    break;
                }
            }
        }
    }

    if(pRunMarker)
    {
        //
        // We found one, so just AddRef it
        //

        ASSERT(pRunMarker->dwRefCount < MCPX_HW_MAX_VOICES);

        pRunMarker->dwRefCount++;

        DPF_SGE_HEAP("Sharing SGE run %x (ref count %lu)", pRunMarker->nElement, pRunMarker->dwRefCount);
    }
    else

#endif // MCPX_NO_SGE_SHARING

    {
        //
        // Allocate a new run and map it into SGEs.  Note that we're not 
        // setting the run marker's base address until after it's been
        // mapped.  This will prevent us from ever trying to use an unmapped
        // run if a higher IRQL call comes in.
        //
        
        if(pRunMarker = AllocRun(pvBaseAddress, nLength))
        {
            irql.Lower();

            MapBuffer(pRunMarker->nElement, pvBaseAddress, nLength);
        }
    }

    irql.Lower();

    DPF_LEAVE(pRunMarker);

    return pRunMarker;
}


/****************************************************************************
 *
 *  Free
 *
 *  Description:
 *      Frees a previously allocated run.
 *
 *  Arguments:
 *      LPSGEHEAPRUNMARKER [in]: run marker.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::Free"

void
CMcpxBufferSgeHeapTest::Free
(
    LPSGEHEAPRUNMARKER      pRunMarker
)
{
    LPVOID                  pvBaseAddress;
    DWORD                   dnLength;
    CIrql                   irql;
    
    DPF_ENTER();

    irql.Raise();
    
    if(!--pRunMarker->dwRefCount)
    {
        pvBaseAddress = pRunMarker->pvBaseAddress;
        dnLength = pRunMarker->nLength;
        
        FreeRun(pRunMarker);

        irql.Lower();

        UnmapBuffer(pvBaseAddress, dnLength);
    }
    
    irql.Lower();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Alloc
 *
 *  Description:
 *      Allocates a run of elements.
 *
 *  Arguments:
 *      LPVOID [in]: buffer.
 *      WORD [in]: element count.
 *
 *  Returns:  
 *      LPSGEHEAPRUNMARKER: run marker or NULL if the request could not be 
 *                          completed.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::AllocRun"

LPSGEHEAPRUNMARKER
CMcpxBufferSgeHeapTest::AllocRun
(
    LPVOID                  pvBaseAddress,
    WORD                    nLength
)
{
    LPSGEHEAPRUNMARKER      pRunMarker  = NULL;
    LPSGEHEAPRUNMARKER      pMarkerNode;
    PLIST_ENTRY             pleEntry;

    DPF_ENTER();

    //
    // Check the largest available run length to see if we can service
    // the request
    //

    if(m_pLargestFreeRunMarker)
    {
        if(m_pLargestFreeRunMarker->nLength >= nLength)
        {
            //
            // Find a free run that is as close as possible to the requested element
            // count.  This will help to reduce fragmentation.
            //

            for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
            {
                AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

                pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);
            
                if(!pMarkerNode->fAllocated)
                {
                    if(pMarkerNode->nLength >= nLength)
                    {
                        if(!pRunMarker)
                        {
                            pRunMarker = pMarkerNode;
                        }
                        else if(pMarkerNode->nLength < pRunMarker->nLength)
                        {
                            pRunMarker = pMarkerNode;
                        }
                    }
                }
            }

            //
            // If we're using the whole run, just flag it as allocated.  If not,
            // get a free marker from the pool and add it to the list.  We're only
            // using a single list so that runs can be broken and coalesced without
            // having to walk the list.
            //

            if(pRunMarker)
            {
                if(nLength < pRunMarker->nLength)
                {
                    ASSERT(!IsListEmpty(&m_lstMarkers));
            
                    pleEntry = RemoveHeadList(&m_lstMarkers);
                    pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

                    CreateMarker(pMarkerNode, pRunMarker->nElement + nLength, pRunMarker->nLength - nLength, &pRunMarker->leListEntry);

                    pRunMarker->nLength = nLength;

                    DPF_SGE_HEAP("Split SGE run into %x (%lu) and %x (%lu)", pRunMarker->nElement, pRunMarker->nLength, pMarkerNode->nElement, pMarkerNode->nLength);
                }
                else
                {
                    DPF_SGE_HEAP("Allocating SGE run %x (%lu)", pRunMarker->nElement, pRunMarker->nLength);
                }

                pRunMarker->fAllocated = TRUE;
                pRunMarker->pvBaseAddress = pvBaseAddress;
            }

            //
            // Update the free element count and largest run members
            //

            if(pRunMarker)
            {
                ASSERT(m_nFreeElementCount >= pRunMarker->nLength);
                m_nFreeElementCount -= pRunMarker->nLength;

                if(pRunMarker == m_pLargestFreeRunMarker)
                {
                    m_pLargestFreeRunMarker = NULL;
                    
                    for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
                    {
                        AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

                        pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);
            
                        if(!pMarkerNode->fAllocated)
                        {
                            if(!m_pLargestFreeRunMarker)
                            {
                                m_pLargestFreeRunMarker = pMarkerNode;
                            }
                            else if(pMarkerNode->nLength > m_pLargestFreeRunMarker->nLength)
                            {
                                m_pLargestFreeRunMarker = pMarkerNode;
                            }
                        }
                    }
                }                    
            }
        }
    }

    DPF_LEAVE(pRunMarker);

    return pRunMarker;
}


/****************************************************************************
 *
 *  Free
 *
 *  Description:
 *      Frees a previously allocated run.
 *
 *  Arguments:
 *      LPSGEHEAPRUNMARKER [in]: run marker.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::FreeRun"

void
CMcpxBufferSgeHeapTest::FreeRun
(
    LPSGEHEAPRUNMARKER      pRunMarker
)
{
    PLIST_ENTRY             pleEntry;
    LPSGEHEAPRUNMARKER      pMarkerNode;
    
    DPF_ENTER();

    ASSERT(!pRunMarker->fAllocated);

    DPF_SGE_HEAP("Freeing SGE run %x (%lu)", pRunMarker->nElement, pRunMarker->nLength);

    //
    // Update the free element count
    //

    m_nFreeElementCount += pRunMarker->nLength;

    //
    // Coalesce the run with those around it and add it back to the free 
    // marker pool.
    //

    while(TRUE)
    {
        if((pleEntry = pRunMarker->leListEntry.Flink) == &m_lstRuns)
        {
            break;
        }

        pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

        if(pMarkerNode->fAllocated)
        {
            break;
        }

        pRunMarker = CoalesceRuns(pRunMarker, pMarkerNode);
    }

    while(TRUE)
    {
        if((pleEntry = pRunMarker->leListEntry.Blink) == &m_lstRuns)
        {
            break;
        }

        pMarkerNode = CONTAINING_RECORD(pleEntry, SGEHEAPRUNMARKER, leListEntry);

        if(pMarkerNode->fAllocated)
        {
            break;
        }

        pRunMarker = CoalesceRuns(pMarkerNode, pRunMarker);
    }

    //
    // Update the largest run pointer
    //

    if(m_pLargestFreeRunMarker)
    {
        if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)
        {
            m_pLargestFreeRunMarker = pRunMarker;
        }
    }
    else
    {
        m_pLargestFreeRunMarker = pRunMarker;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CoalesceRuns
 *
 *  Description:
 *      Coalesces two adjacent runs.
 *
 *  Arguments:
 *      LPSGEHEAPRUNMARKER [in]: run marker.
 *      LPSGEHEAPRUNMARKER [in]: next run marker in the list (this one will
 *                               be removed).
 *
 *  Returns:  
 *      LPSGEHEAPRUNMARKER: run marker.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::CoalesceRuns"

LPSGEHEAPRUNMARKER
CMcpxBufferSgeHeapTest::CoalesceRuns
(
    LPSGEHEAPRUNMARKER      pRunMarker,
    LPSGEHEAPRUNMARKER      pNextRunMarker
)
{
    DPF_ENTER();

    ASSERT(pRunMarker->nElement + pRunMarker->nLength == pNextRunMarker->nElement);

    AssertValidEntryList(&pRunMarker->leListEntry, ASSERT_IN_LIST);
    AssertValidEntryList(&pNextRunMarker->leListEntry, ASSERT_IN_LIST);

    DPF_SGE_HEAP("Coalescing SGE run %x (%lu) and %x (%lu)", pRunMarker->nElement, pRunMarker->nLength, pNextRunMarker->nElement, pNextRunMarker->nLength);

    pRunMarker->nLength += pNextRunMarker->nLength;

    MoveEntryTailList(&m_lstMarkers, &pNextRunMarker->leListEntry);

    DPF_LEAVE(pRunMarker);

    return pRunMarker;
}


/****************************************************************************
 *
 *  MapBuffer
 *
 *  Description:
 *      Maps a data buffer into SGEs.
 *
 *  Arguments:
 *      DWORD [in]: base SGE index.
 *      LPVOID [in]: data buffer.  This address must be page-aligned.
 *      DWORD [in]: data buffer size, in pages.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::MapBuffer"

void
CMcpxBufferSgeHeapTest::MapBuffer
(
    DWORD                   dwSgeIndex,
    LPVOID                  pvBaseAddress,
    DWORD                   dnLength
)
{
    DWORD                   dwAddress;
    CIrql                   irql;
    
    DPF_ENTER();

    ASSERT(dwSgeIndex < MCPX_HW_MAX_BUFFER_PRDS);
    ASSERT(pvBaseAddress);
    ASSERT(!((DWORD)pvBaseAddress & (PAGE_SIZE - 1)));
    ASSERT(dnLength);

    //
    // Lock the buffer data
    //

    MmLockUnlockBufferPages(pvBaseAddress, dnLength << PAGE_SHIFT, FALSE);

    //
    // Start mapping pages into SGEs
    //

    while(dnLength--)
    {
        dwAddress = MmGetPhysicalAddress(pvBaseAddress);
        ASSERT(!(dwAddress & (PAGE_SIZE - 1)));

        irql.Raise();
        
        MCPX_CHECK_VOICE_FIFO(2);

        MCPX_VOICE_WRITE(SetCurrentInBufSGE, dwSgeIndex);
        MCPX_VOICE_WRITE(SetCurrentInBufSGEOffset, dwAddress);

        irql.Lower();

        pvBaseAddress = (LPBYTE)pvBaseAddress + PAGE_SIZE;
        
        dwSgeIndex++;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  UnmapBuffer
 *
 *  Description:
 *      Unmaps a buffer mapped by MapBuffer.
 *
 *  Arguments:
 *      DWORD [in]: data buffer.  This address must be page-aligned.
 *      DWORD [in]: data buffer size, in pages.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxBufferSgeHeapTest::UnmapBuffer"

void
CMcpxBufferSgeHeapTest::UnmapBuffer
(
    LPVOID                  pvBaseAddress,
    DWORD                   dnLength
)
{
    DPF_ENTER();

    ASSERT(pvBaseAddress);
    ASSERT(!((DWORD)pvBaseAddress & (PAGE_SIZE - 1)));
    ASSERT(dnLength);

    //
    // Unlock the buffer data
    //

    MmLockUnlockBufferPages(pvBaseAddress, dnLength << PAGE_SHIFT, TRUE);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CMcpxSlopMemoryHeap
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeapTest::CMcpxSlopMemoryHeapTest"

const DWORD CMcpxSlopMemoryHeapTest::m_dwUsageThreshold = 64;
DWORD &CMcpxSlopMemoryHeapTest::m_dwAvailable = g_dwDirectSoundTestPhysicalMemorySlop;
DWORD &CMcpxSlopMemoryHeapTest::m_dwUsed = g_dwDirectSoundTestPhysicalMemoryRecovered;

CMcpxSlopMemoryHeapTest::CMcpxSlopMemoryHeapTest
(
    void
)
{
    DPF_ENTER();

    ASSERT(!m_dwAvailable);
    ASSERT(!m_dwUsed);

    ASSERT(!g_pDirectSoundTestSlopMemoryHeap);
    g_pDirectSoundTestSlopMemoryHeap = this;

    InitializeListHead(&m_lstEntries);
    InitializeListHead(&m_lstRuns);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxSlopMemoryHeapTest
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeapTest::~CMcpxSlopMemoryHeapTest"

CMcpxSlopMemoryHeapTest::~CMcpxSlopMemoryHeapTest
(
    void
)
{

#ifdef DEBUG

    LPSLOPRUNMARKER         pMarkerNode;

#endif // DEBUG

    PLIST_ENTRY             pleEntry;
    LPSLOPMEMENTRY          pEntryNode;
    LPVOID                  pvBaseAddress;

    DPF_ENTER();
    AutoIrql();

#ifdef DEBUG

    // 
    // Make sure no memory is still being used
    //
    
    for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
    {
        pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

        ASSERT(!pMarkerNode->fAllocated);
    }

#endif // DEBUG

    //
    // Free the global pointer
    //
    
    ASSERT(this == g_pDirectSoundTestSlopMemoryHeap);
    g_pDirectSoundTestSlopMemoryHeap = NULL;

    //
    // Free memory owned by the heap
    //

    while((pleEntry = RemoveHeadList(&m_lstEntries)) != &m_lstEntries)
    {
        pEntryNode = CONTAINING_RECORD(pleEntry, SLOPMEMENTRY, leListEntry);
        pvBaseAddress = pEntryNode->pvBaseAddress;
        
        PHYSFREE(pvBaseAddress);
    }

    //
    // Reset tracking values
    //

    ASSERT(!m_dwUsed);

    m_dwAvailable = 0;
    m_dwUsed = 0;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AddRun
 *
 *  Description:
 *      Adds a run of slop memory to the heap.
 *
 *  Arguments:
 *      LPVOID [in]: base address.
 *      DWORD [in]: length, in bytes, of the allocation.
 *      DWORD [in]: length, in bytes, of the allocation that's actually being
 *                  used.
 *
 *  Returns:  
 *      BOOL: TRUE if the run was added to the heap.  If the run was added,
 *            the heap now owns the memory, so it should not be freed by the
 *            caller.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeapTest::AddRun"

BOOL
CMcpxSlopMemoryHeapTest::AddRun
(
    LPVOID                  pvBaseAddress,
    DWORD                   nLength,
    DWORD                   nUsed
)
{
    DWORD                   nSlopLength;
    LPSLOPRUNMARKER         pRunMarker;
    LPSLOPMEMENTRY          pEntry;
    BOOL                    fOwned;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Make sure the run is large enough to hold the tracking entry, at least
    // one run marker and still have some space left over for data.
    //

    ASSERT(nLength >= nUsed);
    nSlopLength = nLength - nUsed;

    if(fOwned = (nSlopLength > sizeof(*pEntry) + sizeof(*pRunMarker) + m_dwUsageThreshold))
    {
        //
        // Add the allocation to the entry list so we can free it later.  
        // We'll use the first part of the unused memory as the entry marker
        //

        pEntry = (LPSLOPMEMENTRY)((LPBYTE)pvBaseAddress + nUsed);

        pEntry->pvBaseAddress = pvBaseAddress;

        InsertTailListUninit(&m_lstEntries, &pEntry->leListEntry);

        //
        // Initialize a run marker immediately after the tracking entry and
        // add it to the run list.
        //

        pRunMarker = CreateMarker(pEntry + 1, nSlopLength - sizeof(*pEntry), &m_lstRuns);

        if(m_pLargestFreeRunMarker)
        {
            if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)
            {
                m_pLargestFreeRunMarker = pRunMarker;
            }
        }
        else
        {
            m_pLargestFreeRunMarker = pRunMarker;
        }

        m_dwAvailable += nLength;

        DPF_MEM_HEAP("Added %x to the slop heap (entry %x, run marker %x, length %lu, %lu bytes used for tracking, %lu bytes used for run marker)", pvBaseAddress, pEntry, pRunMarker, nSlopLength, sizeof(*pEntry), sizeof(*pRunMarker));
    }

    DPF_LEAVE(fOwned);

    return fOwned;
}


/****************************************************************************
 *
 *  Alloc
 *
 *  Description:
 *      Allocates memory from the heap.
 *
 *  Arguments:
 *      DWORD [in]: length, in bytes
 *
 *  Returns:  
 *      LPVOID: buffer base address or NULL.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeapTest::Alloc"

LPVOID
CMcpxSlopMemoryHeapTest::Alloc
(
    DWORD                   nLength
)
{
    LPSLOPRUNMARKER         pRunMarker      = NULL;
    LPSLOPRUNMARKER         pMarkerNode;
    PLIST_ENTRY             pleEntry;

    DPF_ENTER();
    AutoIrql();

    //
    // The length must include the space to hold the run marker
    //

    nLength += sizeof(SLOPRUNMARKER);

    //
    // Check the largest available run length to see if we can service
    // the request
    //

    if(m_pLargestFreeRunMarker)
    {
        if(m_pLargestFreeRunMarker->nLength >= nLength)
        {
            //
            // Find a free run that is as close as possible to the requested element
            // count.  This will help to reduce fragmentation.
            //

            for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
            {
                AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

                pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);
            
                if(!pMarkerNode->fAllocated)
                {
                    if(pMarkerNode->nLength >= nLength)
                    {
                        if(!pRunMarker)
                        {
                            pRunMarker = pMarkerNode;
                        }
                        else if(pMarkerNode->nLength < pRunMarker->nLength)
                        {
                            pRunMarker = pMarkerNode;
                        }
                    }
                }
            }

            //
            // If we're using the whole run, just flag it as allocated.  If not,
            // create a new marker from the remaining buffer and add it to the 
            // list.  We're only using a single list so that runs can be broken 
            // and coalesced without having to walk the list.
            //

            if(pRunMarker)
            {
                if(nLength + sizeof(*pRunMarker) + m_dwUsageThreshold < pRunMarker->nLength)
                {
                    pMarkerNode = CreateMarker((LPBYTE)pRunMarker + nLength, pRunMarker->nLength - nLength, &pRunMarker->leListEntry);

                    pRunMarker->nLength = nLength;

                    DPF_MEM_HEAP("Split memory run into %x (%lu) and %x (%lu)", pRunMarker, pRunMarker->nLength, pMarkerNode, pMarkerNode->nLength);
                }
                else
                {
                    DPF_MEM_HEAP("Allocating memory run %x (%lu)", pRunMarker, pRunMarker->nLength);
                }

                pRunMarker->dwSignature = DSOUND_ALLOCATOR_SLOP;
            }

            //
            // Update the largest run member
            //

            if(pRunMarker)
            {
                if(pRunMarker == m_pLargestFreeRunMarker)
                {
                    m_pLargestFreeRunMarker = NULL;
                    
                    for(pleEntry = m_lstRuns.Flink; pleEntry != &m_lstRuns; pleEntry = pleEntry->Flink)
                    {
                        AssertValidEntryList(pleEntry, ASSERT_IN_LIST);

                        pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);
            
                        if(!pMarkerNode->fAllocated)
                        {
                            if(!m_pLargestFreeRunMarker)
                            {
                                m_pLargestFreeRunMarker = pMarkerNode;
                            }
                            else if(pMarkerNode->nLength > m_pLargestFreeRunMarker->nLength)
                            {
                                m_pLargestFreeRunMarker = pMarkerNode;
                            }
                        }
                    }
                }                    
            }

            //
            // Update the amount of memory recovered
            //

            if(pRunMarker)
            {
                m_dwUsed += pRunMarker->nLength;
            }

            //
            // AddRef ourselves so we're always around as long as allocated
            // memory is.
            //

            if(pRunMarker)
            {
                AddRef();
            }
        }
    }

    DPF_LEAVE(pRunMarker ? pRunMarker + 1 : NULL);

    return pRunMarker ? pRunMarker + 1 : NULL;
}


/****************************************************************************
 *
 *  Free
 *
 *  Description:
 *      Frees a previously allocated run.
 *
 *  Arguments:
 *      LPVOID [in]: buffer base address.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeapTest::Free"

void
CMcpxSlopMemoryHeapTest::Free
(
    LPVOID                  pvBaseAddress
)
{
    LPSLOPRUNMARKER         pRunMarker  = (LPSLOPRUNMARKER)pvBaseAddress - 1;
    PLIST_ENTRY             pleEntry;
    LPSLOPRUNMARKER         pMarkerNode;
    
    DPF_ENTER();
    AutoIrql();

    ASSERT(DSOUND_ALLOCATOR_SLOP == pRunMarker->dwSignature);

    DPF_MEM_HEAP("Freeing memory run %x (%lu)", pRunMarker, pRunMarker->nLength);

    //
    // Update the amount of memory recovered
    //

    ASSERT(m_dwUsed >= pRunMarker->nLength);
    m_dwUsed -= pRunMarker->nLength;

    //
    // Reset the run signature so it's flagged as free
    //

    pRunMarker->dwSignature = 0;

    //
    // Coalesce the run with those around it
    //

    while(TRUE)
    {
        if((pleEntry = pRunMarker->leListEntry.Flink) == &m_lstRuns)
        {
            break;
        }

        pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

        if(pMarkerNode->fAllocated)
        {
            break;
        }

        if((LPBYTE)pRunMarker + pRunMarker->nLength != (LPBYTE)pMarkerNode)
        {
            break;
        }

        pRunMarker = CoalesceRuns(pRunMarker, pMarkerNode);
    }

    while(TRUE)
    {
        if((pleEntry = pRunMarker->leListEntry.Blink) == &m_lstRuns)
        {
            break;
        }

        pMarkerNode = CONTAINING_RECORD(pleEntry, SLOPRUNMARKER, leListEntry);

        if(pMarkerNode->fAllocated)
        {
            break;
        }

        if((LPBYTE)pMarkerNode + pMarkerNode->nLength != (LPBYTE)pRunMarker)
        {
            break;
        }

        pRunMarker = CoalesceRuns(pMarkerNode, pRunMarker);
    }

    //
    // Update the largest run pointer
    //

    if(m_pLargestFreeRunMarker)
    {
        if(pRunMarker->nLength > m_pLargestFreeRunMarker->nLength)
        {
            m_pLargestFreeRunMarker = pRunMarker;
        }
    }
    else
    {
        m_pLargestFreeRunMarker = pRunMarker;
    }

    //
    // Release the reference added in Alloc
    //

    Release();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  CoalesceRuns
 *
 *  Description:
 *      Coalesces two adjacent runs.
 *
 *  Arguments:
 *      LPSLOPRUNMARKER [in]: run marker.
 *      LPSLOPRUNMARKER [in]: next run marker in the list (this one will be 
 *                           removed).
 *
 *  Returns:  
 *      LPSLOPRUNMARKER: run marker.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxSlopMemoryHeapTest::CoalesceRuns"

LPSLOPRUNMARKER
CMcpxSlopMemoryHeapTest::CoalesceRuns
(
    LPSLOPRUNMARKER         pRunMarker,
    LPSLOPRUNMARKER         pNextRunMarker
)
{
    DPF_ENTER();

    ASSERT((LPBYTE)pRunMarker + pRunMarker->nLength == (LPBYTE)pNextRunMarker);
    ASSERT(!pRunMarker->fAllocated);
    ASSERT(!pNextRunMarker->fAllocated);

    AssertValidEntryList(&pRunMarker->leListEntry, ASSERT_IN_LIST);
    AssertValidEntryList(&pNextRunMarker->leListEntry, ASSERT_IN_LIST);

    DPF_MEM_HEAP("Coalescing memory run %x (%lu) and %x (%lu)", pRunMarker, pRunMarker->nLength, pNextRunMarker, pNextRunMarker->nLength);

    pRunMarker->nLength += pNextRunMarker->nLength;
    
    RemoveEntryList(&pNextRunMarker->leListEntry);

    DPF_LEAVE(pRunMarker);

    return pRunMarker;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\gpdsp.h ===
#if !defined _GPDSPMANAGER_
#define _GPDSPMANAGER_


typedef struct
{
    union
    {
        struct
        {
            ULONG oper : 1;
            ULONG res  : 15;
            ULONG size : 16;
        } fields;

        ULONG uVal;
    } data1;

    ULONG offset;

} AC3_SET_BUFFER;



///////////////////////////////////////////////////////////////////////////////
//
// Dsp program base class
//
///////////////////////////////////////////////////////////////////////////////


class CMcpxDspImageTest
{
public:
    CMcpxDspImageTest()
    {
        m_pLoader = NULL;
        m_uLoaderSize = 0;
    }
    
    VOID Initialize();

    PVOID       GetLoader() { return m_pLoader; }
    ULONG       GetLoaderSize() { return m_uLoaderSize; }    

protected:
    
    PVOID        m_pLoader;
    ULONG        m_uLoaderSize;

};




class CMcpxGPDspManagerTest
{
public:

    CMcpxGPDspManagerTest();
    ~CMcpxGPDspManagerTest();

public:
    VOID Initialize();

    // debug only
    VOID *GetScratchPage(ULONG uPageNumber);
    VOID AC3SetOutputBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages);
    VOID SetMultipassBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages);

    HRESULT DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPDSEFFECTIMAGEDESC *ppImageDesc);
    HRESULT SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags);
    HRESULT GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize);
    HRESULT GetEffectMap(DWORD dwEffectIndex, LPCDSEFFECTMAP *ppEffectMap);
    VOID CommitChanges(DWORD dwScratchOffset, DWORD dwDataSize);

    VOID RestoreCommandBlock();

protected:

    CMcpxDspScratchDmaTest *GetScratchDma() { return m_pScratchDma; }
    HRESULT     ParseEffectImageInfo(LPCVOID pScratchImage);

private:

    ULONG        m_uAC3BufferOffset;
    ULONG        m_uMultipassBufferOffset;

    CMcpxDspScratchDmaTest     *m_pScratchDma;
    CMcpxDspImageTest          *m_pDspImage; 

    ULONG        m_uPMemOffset;
    ULONG        m_uPMemMaxSize;

    DWORD m_dwCurrentLowestScratchOffset;
    DWORD m_dwStateSizeToCommit;
    LPDSEFFECTIMAGEDESC m_pFxDescriptor;
    HOST_TO_DSP_COMMANDBLOCK m_InitialCmdBlock;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\globals.c ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       globals.c
 *  Content:    Externally exposed DirectSound global variables.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/22/01    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

#ifdef MCPX_BOOT_LIB
#define DSGLOBAL const
#else // MCPX_BOOT_LIB
#define DSGLOBAL const __declspec(selectany)
#endif // MCPX_BOOT_LIB

DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_Mono[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_MONO };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_Stereo[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_STEREO };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_4Channel[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_4CHANNEL };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_6Channel[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_6CHANNEL };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundRequiredMixBinVolumePairs_3D[] = { DSMIXBINVOLUMEPAIRS_REQUIRED_3D };
DSGLOBAL DSMIXBINVOLUMEPAIR DirectSoundDefaultMixBinVolumePairs_3D[] = { DSMIXBINVOLUMEPAIRS_DEFAULT_3D };

DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_Mono = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_Mono),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_Mono
};
        
DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_Stereo = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_Stereo),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_Stereo
};
        
DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_4Channel = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_4Channel),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_4Channel
};
        
DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_6Channel = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_6Channel),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_6Channel
};
        
DSGLOBAL DSMIXBINS DirectSoundRequiredMixBins_3D = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundRequiredMixBinVolumePairs_3D),
    /* lpMixBinVolumePairs  */ DirectSoundRequiredMixBinVolumePairs_3D
};
        
DSGLOBAL DSMIXBINS DirectSoundDefaultMixBins_3D = 
{
    /* dwMixBinCount        */ NUMELMS(DirectSoundDefaultMixBinVolumePairs_3D),
    /* lpMixBinVolumePairs  */ DirectSoundDefaultMixBinVolumePairs_3D
};

#ifndef MCPX_BOOT_LIB
        
DSGLOBAL DS3DBUFFER DirectSoundDefault3DBuffer =
{
    /* dwSize               */ sizeof(DS3DBUFFER),
    /* vPosition            */ { DS3D_DEFAULTPOSITION_X, DS3D_DEFAULTPOSITION_Y, DS3D_DEFAULTPOSITION_Z },
    /* vVelocity            */ { DS3D_DEFAULTVELOCITY_X, DS3D_DEFAULTVELOCITY_Y, DS3D_DEFAULTVELOCITY_Z },
    /* dwInsideConeAngle    */ DS3D_DEFAULTCONEANGLE,
    /* dwOutsideConeAngle   */ DS3D_DEFAULTCONEANGLE,
    /* vConeOrientation     */ { DS3D_DEFAULTCONEORIENT_X, DS3D_DEFAULTCONEORIENT_Y, DS3D_DEFAULTCONEORIENT_Z },
    /* lConeOutsideVolume   */ DS3D_DEFAULTCONEOUTSIDEVOLUME,
    /* flMinDistance        */ DS3D_DEFAULTMINDISTANCE,
    /* flMaxDistance        */ DS3D_DEFAULTMAXDISTANCE,
    /* dwMode               */ DS3DMODE_NORMAL,
    /* flDistanceFactor     */ DS3D_DEFAULTDISTANCEFACTOR,                                                         
    /* flRolloffFactor      */ DS3D_DEFAULTROLLOFFFACTOR,                                                          
    /* flDopplerFactor      */ DS3D_DEFAULTDOPPLERFACTOR                                                           
};

DSGLOBAL DSI3DL2BUFFER DirectSoundDefaultI3DL2Buffer =
{
    /* lDirect              */ DSI3DL2BUFFER_DEFAULTDIRECT,
    /* lDirectHF            */ DSI3DL2BUFFER_DEFAULTDIRECTHF,
    /* lRoom                */ DSI3DL2BUFFER_DEFAULTROOM,
    /* lRoomHF              */ DSI3DL2BUFFER_DEFAULTROOMHF,
    /* flRoomRolloffFactor  */ DSI3DL2BUFFER_DEFAULTROOMROLLOFFFACTOR,
    /* Obstruction          */ { DSI3DL2BUFFER_DEFAULTOBSTRUCTION, DSI3DL2BUFFER_DEFAULTOBSTRUCTIONLFRATIO },
    /* Occlusion            */ { DSI3DL2BUFFER_DEFAULTOCCLUSION, DSI3DL2BUFFER_DEFAULTOCCLUSIONLFRATIO}
};

DSGLOBAL DS3DLISTENER DirectSoundDefault3DListener =
{
    /* dwSize               */ sizeof(DS3DLISTENER),                                                               
    /* vPosition            */ { DS3D_DEFAULTPOSITION_X, DS3D_DEFAULTPOSITION_Y, DS3D_DEFAULTPOSITION_Z },         
    /* vVelocity            */ { DS3D_DEFAULTVELOCITY_X, DS3D_DEFAULTVELOCITY_Y, DS3D_DEFAULTVELOCITY_Z },         
    /* vOrientFront         */ { DS3D_DEFAULTORIENTFRONT_X, DS3D_DEFAULTORIENTFRONT_Y, DS3D_DEFAULTORIENTFRONT_Z },
    /* vOrientTop           */ { DS3D_DEFAULTORIENTTOP_X, DS3D_DEFAULTORIENTTOP_Y, DS3D_DEFAULTORIENTTOP_Z },      
    /* flDistanceFactor     */ DS3D_DEFAULTDISTANCEFACTOR,                                                         
    /* flRolloffFactor      */ DS3D_DEFAULTROLLOFFFACTOR,                                                          
    /* flDopplerFactor      */ DS3D_DEFAULTDOPPLERFACTOR                                                           
};

DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Default = { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Generic = { DSI3DL2_ENVIRONMENT_PRESET_GENERIC };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_PaddedCell = { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Room = { DSI3DL2_ENVIRONMENT_PRESET_ROOM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Bathroom = { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_LivingRoom = { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_StoneRoom = { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Auditorium = { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_ConcertHall = { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Cave = { DSI3DL2_ENVIRONMENT_PRESET_CAVE };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Arena = { DSI3DL2_ENVIRONMENT_PRESET_ARENA };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Hangar = { DSI3DL2_ENVIRONMENT_PRESET_HANGAR };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_CarpetedHallway = { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Hallway = { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_StoneCorridor = { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Alley = { DSI3DL2_ENVIRONMENT_PRESET_ALLEY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Forest = { DSI3DL2_ENVIRONMENT_PRESET_FOREST };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_City = { DSI3DL2_ENVIRONMENT_PRESET_CITY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Mountains = { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Quarry = { DSI3DL2_ENVIRONMENT_PRESET_QUARRY };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Plain = { DSI3DL2_ENVIRONMENT_PRESET_PLAIN };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_ParkingLot = { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_SewerPipe = { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_Underwater = { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER };
DSGLOBAL DSI3DL2LISTENER DirectSoundI3DL2ListenerPreset_NoReverb = { DSI3DL2_ENVIRONMENT_PRESET_NOREVERB };

DSGLOBAL GUID KSDATAFORMAT_SUBTYPE_PCM = { WAVE_FORMAT_PCM, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } };
DSGLOBAL GUID KSDATAFORMAT_SUBTYPE_XBOX_ADPCM = { WAVE_FORMAT_XBOX_ADPCM, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } };

#endif // MCPX_BOOT_LIB
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\heap.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       heap.h
 *  Content:    Generic heap object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/24/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __HEAP_H__
#define __HEAP_H__

// 
// Buffer SGE heap run marker
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY  leListEntry;            // Linked list entry
    WORD        nElement;               // Run element index
    WORD        nLength;                // Run length, in elements
    union
    {
        DWORD   dwRefCount;             // Run reference count
        BOOL    fAllocated;             // Is the run allocated?
    };
    LPVOID      pvBaseAddress;          // Base address of mapped buffer
END_DEFINE_STRUCT(SGEHEAPRUNMARKER);

//
// Slop heap owned memory entry
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY  leListEntry;            // List entry
    LPVOID      pvBaseAddress;          // Base address of allocation
END_DEFINE_STRUCT(SLOPMEMENTRY);

// 
// Unused memory heap run marker
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY  leListEntry;            // Linked list entry
    DWORD       nLength;                // Run length, in bytes (includes marker)
    union
    {
        DWORD   dwSignature;            // Allocation validation signature
        BOOL    fAllocated;             // Is the run allocated?
    };
END_DEFINE_STRUCT(SLOPRUNMARKER);

#ifdef __cplusplus

//
// MCP-X buffer SGE heap
//

class CMcpxBufferSgeHeapTest
{
protected:
    LIST_ENTRY              m_lstRuns;                  // Heap element run list
    LIST_ENTRY              m_lstMarkers;               // Unused markers
    LPSGEHEAPRUNMARKER      m_paMarkers;                // Markers
    DWORD                   m_nFreeElementCount;        // Free element count
    LPSGEHEAPRUNMARKER      m_pLargestFreeRunMarker;    // Largest available run

public:
    CMcpxBufferSgeHeapTest(void);
    virtual ~CMcpxBufferSgeHeapTest(void);

public:
    // Initialization
    HRESULT Initialize(WORD nElementCount);

    // Allocation
    LPSGEHEAPRUNMARKER Alloc(LPVOID pvBuffer, DWORD dwBufferSize);
    void Free(LPSGEHEAPRUNMARKER pMarker);

    // Free element count
    DWORD GetFreeElementCount(void);

protected:
    // Allocation
    LPSGEHEAPRUNMARKER AllocRun(LPVOID pvBaseAddress, WORD nElementCount);
    void FreeRun(LPSGEHEAPRUNMARKER pMarker);
    
    // Garbage collection
    LPSGEHEAPRUNMARKER CoalesceRuns(LPSGEHEAPRUNMARKER pMarker, LPSGEHEAPRUNMARKER pNextMarker);

    // Markers
    LPSGEHEAPRUNMARKER CreateMarker(LPSGEHEAPRUNMARKER pMarker, WORD nElement, WORD nLength, PLIST_ENTRY plePrevEntry);

    // MCPX SGE stuff
    static void MapBuffer(DWORD dwSgeIndex, LPVOID pvBaseAddress, DWORD dwLength);
    static void UnmapBuffer(LPVOID pvBaseAddress, DWORD dwLength);
};

__inline DWORD CMcpxBufferSgeHeapTest::GetFreeElementCount(void)
{
    return m_nFreeElementCount;
}

__inline LPSGEHEAPRUNMARKER CMcpxBufferSgeHeapTest::CreateMarker(LPSGEHEAPRUNMARKER pMarker, WORD nElement, WORD nLength, PLIST_ENTRY plePrevEntry)
{
    InsertHeadListUninit(plePrevEntry, &pMarker->leListEntry);

    pMarker->nElement = nElement;
    pMarker->nLength = nLength;
    pMarker->dwRefCount = 0;
    pMarker->pvBaseAddress = NULL;

    return pMarker;
}

//
// MCP-X slop memory heap
//

class CMcpxSlopMemoryHeapTest
    : public CRefCountTest
{
public:
    static const DWORD      m_dwUsageThreshold;         // Minimum amount of memory the heap will track
    static DWORD &          m_dwAvailable;              // Total amount of memory in the heap
    static DWORD &          m_dwUsed;                   // Amount of memory used

protected:
    LIST_ENTRY              m_lstEntries;               // Allocations
    LIST_ENTRY              m_lstRuns;                  // Heap element run list
    LPSLOPRUNMARKER         m_pLargestFreeRunMarker;    // Largest available run

public:
    CMcpxSlopMemoryHeapTest(void);
    virtual ~CMcpxSlopMemoryHeapTest(void);

public:
    // Slop memory
    BOOL AddRun(LPVOID pvBaseAddress, DWORD dwLength, DWORD dwUsed);

    // Allocation
    LPVOID Alloc(DWORD dwLength);
    void Free(LPVOID pvBuffer);

protected:
    // Garbage collection
    LPSLOPRUNMARKER CoalesceRuns(LPSLOPRUNMARKER pMarker, LPSLOPRUNMARKER pNextMarker);

    // Markers
    LPSLOPRUNMARKER CreateMarker(LPVOID pvBaseAddress, DWORD nLength, PLIST_ENTRY plePrevEntry);
};

__inline LPSLOPRUNMARKER CMcpxSlopMemoryHeapTest::CreateMarker(LPVOID pvBaseAddress, DWORD nLength, PLIST_ENTRY plePrevEntry)
{
    LPSLOPRUNMARKER         pRunMarker  = (LPSLOPRUNMARKER)pvBaseAddress;
    
    ASSERT(nLength > sizeof(*pRunMarker));

    InsertHeadListUninit(plePrevEntry, &pRunMarker->leListEntry);

    pRunMarker->nLength = nLength;
    pRunMarker->dwSignature = 0;

    return pRunMarker;
}

//
// The one and only slop memory heap
//

extern CMcpxSlopMemoryHeapTest *g_pDirectSoundTestSlopMemoryHeap;

#endif // __cplusplus

#endif // __HEAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\macros.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       macros.h
 *  Content:    Misc. helper macros.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ***************************************************************************/

#ifndef __MACROS_H__
#define __MACROS_H__

#define DEFINEPTYPE(name) \
    typedef name *P##name

#define DEFINELPTYPE(name) \
    typedef name *LP##name

#define DEFINELPCTYPE(name) \
    typedef const name *LPC##name

#ifdef __cplusplus                  

#define DEFINEREFTYPE(name)  \
    typedef const name &REF##name

#else // __cplusplus                

#define DEFINEREFTYPE(name) \
    typedef const name *REF##name

#endif // __cplusplus               

#define DEFINETYPEFORMS(name) \
    DEFINEPTYPE(name); DEFINELPTYPE(name); DEFINELPCTYPE(name); DEFINEREFTYPE(name)

#define DEFINETYPE(name, type) \
    typedef type name; DEFINETYPEFORMS(name)
                                    
#define BEGIN_DEFINE_STRUCT() \
    typedef struct {

#define BEGIN_DEFINE_STRUCT_(name) \
    typedef struct name {

#define END_DEFINE_STRUCT(name) \
    } name; DEFINETYPEFORMS(name)

#define BEGIN_DEFINE_UNION() \
    typedef union {

#define BEGIN_DEFINE_UNION_(name) \
    typedef union name {

#define END_DEFINE_UNION(name) \
    } name; DEFINETYPEFORMS(name)

#define BEGIN_DEFINE_ENUM()  \
    typedef enum {

#define BEGIN_DEFINE_ENUM_(name) \
    typedef enum name {

#define END_DEFINE_ENUM(name) \
    } name; DEFINETYPEFORMS(name)

#define END_DEFINE_ENUM_() \
    }

#define DIVUP(a, b) \
    (((a) + ((b) - 1)) / (b))

#define BLOCKALIGN(a, b) \
    (((a) / (b)) * (b))

#define BLOCKALIGNPAD(a, b) \
    (DIVUP(a, b) * (b))

#define MAKEBOOL(a) \
    (!!(a))

#define NUMELMS(a) \
    (sizeof(a) / sizeof((a)[0]))

#define HRESULT_FROM_POINTER(p) \
    ((p) ? S_OK : E_OUTOFMEMORY)

#define HRFROMP(p) \
    HRESULT_FROM_POINTER(p)

#ifdef __cplusplus

#define IS_NULL_GUID(guid) \
    (!&(guid) || IsEqualGUID(guid, GUID_NULL))

#else // __cplusplus

#define IS_NULL_GUID(pguid) \
    (!(pguid) || IsEqualGUID(pguid, &GUID_NULL))

#endif // __cplusplus

#define IS_VALID_HANDLE_VALUE(h) \
    ((h) && (INVALID_HANDLE_VALUE != (h)))

#define CLOSE_HANDLE(h) \
    { \
        if(IS_VALID_HANDLE_VALUE(h)) \
        { \
            CloseHandle(h); \
            (h) = NULL; \
        } \
    }

#define INTERLOCKED_EXCHANGE(a, b) \
    InterlockedExchange((LPLONG)&(a), (LONG)(b))

#define INTERLOCKED_INCREMENT(a) \
    InterlockedIncrement((LPLONG)&(a))

#define INTERLOCKED_DECREMENT(a) \
    InterlockedDecrement((LPLONG)&(a))

#define CHECKRANGE(a, min, max) \
    { \
        if((a) < (min)) \
        { \
            (a) = (min); \
        } \
        else if((a) > (max)) \
        { \
            (a) = (max); \
        } \
    }

DEFINELPCTYPE(LONG);
DEFINELPCTYPE(DWORD);
DEFINEREFTYPE(DS3DLISTENER);
DEFINEREFTYPE(DS3DBUFFER);
DEFINEREFTYPE(D3DXVECTOR3);
DEFINEREFTYPE(XMEDIAPACKET);
DEFINELPCTYPE(XMEDIAPACKET);
DEFINEREFTYPE(DSI3DL2LISTENER);
DEFINEREFTYPE(DSI3DL2BUFFER);

#endif // __MACROS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\mcpapu.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpapu.cpp
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#include "dsoundi.h"

#ifdef DEBUG

EXTERN_C BOOL g_fDirectSoundTestSimulateDeltaPanic;
BOOL g_fDirectSoundTestSimulateDeltaPanic = FALSE;

#endif // DEBUG


/****************************************************************************
 *
 *  CMcpxAPUTest
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::CMcpxAPUTest"

KINTERRUPT CMcpxAPUTest::m_Interrupt;
DWORD CMcpxAPUTest::m_dwDeltaPanicCount = 0;

CMcpxAPUTest::CMcpxAPUTest
(
    CDirectSoundTestSettings *  pSettings
)
:   CMcpxCoreTest(pSettings)
{
    DWORD                   i;
    
    DPF_ENTER();
    
    //
    // Initialize defaults
    //
    
    for(i = 0; i < NUMELMS(m_alstActiveVoices); i++)
    {
        InitializeListHead(&m_alstActiveVoices[i]);
    }

    InitializeListHead(&m_lstPendingInactiveVoices);
    InitializeListHead(&m_lstDeferredCommandsHigh);
    InitializeListHead(&m_lstDeferredCommandsLow);

    m_wFree2dVoiceCount = MCPX_HW_MAX_2D_VOICES;
    m_wFree3dVoiceCount = MCPX_HW_MAX_3D_VOICES;

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxAPUTest
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::~CMcpxAPUTest"

CMcpxAPUTest::~CMcpxAPUTest
(
    void
)
{
    DPF_ENTER();

    DPF_INFO("APU going away...");

    //
    // Shut down the APU
    //

    Terminate();

    //
    // Disconnect the interrupt handler
    //

    if(m_Interrupt.ServiceRoutine)
    {
        KeDisconnectInterrupt(&m_Interrupt);
        m_Interrupt.ServiceRoutine = NULL;
    }

    //
    // Cancel timers
    //

    KeCancelTimer(&m_tmrDeferredCommandsHigh);

    //
    // Clear any pending DPCs
    //

    if(DpcObject == m_dpcInterrupt.Type)
    {
        KeRemoveQueueDpc(&m_dpcInterrupt);
        m_dpcInterrupt.Type = ~m_dpcInterrupt.Type;
    }

    if(DpcObject == m_dpcDeferredCommandsHigh.Type)
    {
        KeRemoveQueueDpc(&m_dpcDeferredCommandsHigh);
        m_dpcDeferredCommandsHigh.Type = ~m_dpcInterrupt.Type;
    }

    //
    // Unregister the shutdown handler
    //

    if(m_HalShutdownData.NotificationRoutine)
    {
        HalRegisterShutdownNotification(&m_HalShutdownData, FALSE);
        m_HalShutdownData.NotificationRoutine = NULL;
    }

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Intializes the object.
 *
 *  Arguments:
 *      CDirectSoundTestSettings * [in]: shared settings object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::Initialize"

HRESULT 
CMcpxAPUTest::Initialize
(
    void
)
{
    ULONG                   ulInterruptVector;
    KIRQL                   irql;
    HRESULT                 hr;
    DWORD                   i;

    //
    // Initialize the APU core
    //

    hr = CMcpxCoreTest::Initialize();

    //
    // Create the buffer SGE heap.  We're only managing 2047 markers because
    // the 2048th is reserved for FXIN buffers.
    //

    if(SUCCEEDED(hr))
    {
        hr = m_SgeHeap.Initialize(MCPX_HW_MAX_BUFFER_PRDS - 1);
    }

    //
    // Set up timers and DPCs
    //
    
	if(SUCCEEDED(hr))
    {
        KeInitializeDpc(&m_dpcInterrupt, ApuInterruptDpcRoutine, this);
        KeInitializeTimer(&m_tmrDeferredCommandsHigh);
        KeInitializeDpc(&m_dpcDeferredCommandsHigh, DeferredCommandDpcRoutine, this);
    }

	//
    // Hook and enable interrupts
    //

    if(SUCCEEDED(hr))
    {
        ulInterruptVector = HalGetInterruptVector(XPCICFG_APU_IRQ, &irql);

        KeInitializeInterrupt(&m_Interrupt, ApuInterruptServiceRoutine, this, ulInterruptVector, irql, LevelSensitive, TRUE);

        if(!KeConnectInterrupt(&m_Interrupt))
        {
            DPF_ERROR("KeConnectInterrupt failed");
            hr = DSERR_GENERIC;
        }
    }

    if(SUCCEEDED(hr))
    {
        MCPX_REG_WRITE(NV_PAPU_ISTS, ~0UL);
    }

    if(SUCCEEDED(hr))
    {
        SetInterruptState(TRUE);
    }

    //
    // Register for HAL shutdown notification
    //

    if(SUCCEEDED(hr))
    {
        m_HalShutdownData.NotificationRoutine = ApuShutdownNotifier;

        HalRegisterShutdownNotification(&m_HalShutdownData, TRUE);
    }

    DPF_LEAVE_HRESULT(hr);

	return hr;
}


/****************************************************************************
 *
 *  Terminate
 *
 *  Description:
 *      Shuts down the APU.  This function assumes that the system is 
 *      rebooting.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::Terminate"

void
CMcpxAPUTest::Terminate
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    DWORD                   i;
    
    DPF_ENTER();
    AutoIrql();

    //
    // Block the idle handler
    //

    BlockIdleHandler();

    //
    // Unblock the idle handler
    //

    UnblockIdleHandler();

    //
    // Shut down the APU core
    //

    Reset();

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ServiceApuInterrupt
 *
 *  Description:
 *      Handles APU interrupts.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE if the interrupt was handled.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::ServiceApuInterrupt"

BOOL
CMcpxAPUTest::ServiceApuInterrupt
(
    void
)
{
    R_INTR                  rInterruptStatus;
    BOOL                    fServiced;

    //
    // Get the pending interrupt
    //
        
    MCPX_REG_READ(NV_PAPU_ISTS, &rInterruptStatus.uValue);

    if(fServiced = MAKEBOOL(rInterruptStatus.General))
    {
        //
        // Clear the interrupt(s)
        //

        MCPX_REG_WRITE(NV_PAPU_ISTS, rInterruptStatus.uValue);

        //
        // Save the interrupt bits
        //

        m_arInterruptStatus[0].uValue |= rInterruptStatus.uValue;

#ifdef DEBUG

        m_arInterruptStatus[0].DeltaPanic |= INTERLOCKED_EXCHANGE(g_fDirectSoundTestSimulateDeltaPanic, 0);

#endif // DEBUG

        //
        // Check for a trap caused by an error or an overridden hardware 
        // method
        //
        
        if(rInterruptStatus.FETrap)
        {
            HandleFETrap();
        }

        //
        // If we got a voice interrupt or a delta panic, schedule a DPC to 
        // handle it
        //

        if(rInterruptStatus.DeltaPanic || rInterruptStatus.FEVoice)
        {
            ScheduleApuInterruptDpc();
        }

        //
        // Read the interrupt mask one more time to make sure all registers are
        // flushed properly
        //

        MCPX_REG_READ(NV_PAPU_ISTS, &rInterruptStatus.uValue);
    }
    
    return fServiced;
}


/****************************************************************************
 *
 *  WaitForMagicWrite
 *
 *  Description:
 *      Waits for the "magic write" to complete.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::WaitForMagicWrite"

void
CMcpxAPUTest::WaitForMagicWrite
(
    void
)
{
    static DWORD            dwMagicWriteValue   = 0;
    DWORD                   dwTimeout           = 100;
    volatile DWORD *        pdwMagicWrite;
    DWORD                   i;

    dwMagicWriteValue++;

    pdwMagicWrite = (volatile DWORD *)m_ctxMemory[MCPX_MEM_MAGICWRITE].VirtualAddress;
    *pdwMagicWrite = ~dwMagicWriteValue;

    SetPrivLockState(TRUE);

    MCPX_REG_WRITE(NV_PAPU_FEMEMADDR, m_ctxMemory[MCPX_MEM_MAGICWRITE].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_FEMEMDATA, dwMagicWriteValue);

    SetPrivLockState(FALSE);

    while(*pdwMagicWrite != dwMagicWriteValue)
    {
        if(!dwTimeout--)
        {
            DPF_ERROR("Magic write not completing!");
            break;
        }

        KeStallExecutionProcessor(1);
    }
}


/****************************************************************************
 *
 *  ServiceApuInterruptDpc
 *
 *  Description:
 *      Handles APU interrupts from a deferred procedure callback.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::ServiceApuInterruptDpc"

void
CMcpxAPUTest::ServiceApuInterruptDpc
(
    void
)
{
    //
    // The DPC will parse the interrupt mask and do processing based on what
    // event was signaled. In ISR-safe fashion, it will read the current 
    // pending interrupt mask twice in the loop. This makes sure the dpc 
    // leaves only when no more ISRs are pending.
    //

    while(TRUE)
    {
        KeSynchronizeExecution(&m_Interrupt, GetInterruptStatusCallback, this);

        if(!m_arInterruptStatus[1].General)
        {
            break;
        }

#ifndef MCPX_BOOT_LIB

        if(m_arInterruptStatus[1].DeltaPanic)
        {
            HandleDeltaPanic();
        }

#endif // MCPX_BOOT_LIB

        if(m_arInterruptStatus[1].FEVoice)
        {
            ServiceVoiceInterrupt();
        }

        m_arInterruptStatus[1].uValue = 0;
    } 
}


/****************************************************************************
 *
 *  ServiceVoiceInterrupt
 *
 *  Description:
 *      Handles APU interrupts from a deferred procedure callback.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::ServiceVoiceInterrupt"

void
CMcpxAPUTest::ServiceVoiceInterrupt
(
    void
)
{
    PLIST_ENTRY             pleEntry;
    DWORD                   dwVoiceList;

    //
    // Wait for the magic write to complete so that all notifiers are 
    // written
    //

    WaitForMagicWrite();

    //
    // Block the idle handler in order to prevent the voice list from
    // being modified.
    //

    BlockIdleHandler();

    //
    // Unblock the idle handler
    //

    UnblockIdleHandler();
}


/****************************************************************************
 *
 *  GetInterruptStatusCallback
 *
 *  Description:
 *      Interrupt synchonization function.
 *
 *  Arguments:
 *      LPVOID [in]: context.
 *
 *  Returns:  
 *      BOOLEAN: TRUE.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::GetInterruptStatusCallback"

BOOLEAN 
CMcpxAPUTest::GetInterruptStatusCallback
(
    LPVOID                  pvContext
)
{
    CMcpxAPUTest *              pThis   = (CMcpxAPUTest *)pvContext;

    pThis->m_arInterruptStatus[1].uValue |= INTERLOCKED_EXCHANGE(pThis->m_arInterruptStatus[0].uValue, 0);

    return TRUE;
}


/****************************************************************************
 *
 *  HandleFETrap
 *
 *  Description:
 *      Handles front-end method traps.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::HandleFETrap"

VOID
CMcpxAPUTest::HandleFETrap
(
    void
)
{
    R_FE_CONTROL            rFeControl;
    DWORD                   dwParam;
    DWORD                   dwMethod;

    DPF_ENTER();

    //
    // Whahoppen?
    //
    
    MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);
    ASSERT(NV_PAPU_FECTL_FEMETHMODE_TRAPPED == rFeControl.Mode);

    MCPX_REG_READ(NV_PAPU_FEDECMETH, &dwMethod);
    MCPX_REG_READ(NV_PAPU_FEDECPARAM, &dwParam);

    dwMethod = MCPX_GET_REG_VALUE(dwMethod, NV_PAPU_FEDECMETH_METH);
    dwParam = MCPX_GET_REG_VALUE(dwParam, NV_PAPU_FEDECPARAM_VALUE);

    switch(rFeControl.TrapReason)
    {
        case NV_PAPU_FECTL_FETRAPREASON_NONE:
            DPF_ERROR("NONE: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED:
            DPF_ERROR("NOT_IMPLEMENTED: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN:
            DPF_ERROR("METHOD_UNKNOWN: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT:
            DPF_ERROR("BAD_ARGUMENT: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET:
            DPF_ERROR("CURRENT_NOT_SET: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET:
            DPF_ERROR("ANTECEDENT_NOT_SET: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE:
            DPF_ERROR("BAD_DATA_TYPE: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER:
            DPF_ERROR("BAD_LIST_POINTER: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D:
            DPF_ERROR("CURRENT_VOICE_NOT_3d: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID:
            DPF_ERROR("CTXPA_INVALID: method %x, param %x", dwMethod, dwParam);
            break;

        case NV_PAPU_FECTL_FETRAPREASON_REQUESTED:
            HandleSoftwareMethod(dwMethod, dwParam);
            break;
        
        default:
            DPF_ERROR("(unknown) %x: method %x, param %x", (DWORD)rFeControl.TrapReason, dwMethod, dwParam);
            break;
    }

    //
    // Snap the FE out of trap mode
    //

    SetFrontEndState(MCPX_FE_STATE_HALTED);
    SetFrontEndState(MCPX_FE_STATE_FREE_RUNNING);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  HandleDeltaPanic
 *
 *  Description:
 *      Handles a delta panic (when the APU output read cursor passes the
 *      write cursor).
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::HandleDeltaPanic"

void
CMcpxAPUTest::HandleDeltaPanic
(
    void
)
{
    PHOST_TO_DSP_COMMANDBLOCK   pCmdBlock;
    BOOL                        fIdle;
    
    DPF_ENTER();

    DPF_WARNING("Delta panic.  You'll hear a glitch while the APU is reset...");
    
    m_dwDeltaPanicCount++;

    //
    // Idle the voice processor
    //

    fIdle = IdleVoiceProcessor(TRUE);

    //
    // Disable interrupts
    //

    SetInterruptState(FALSE);

    //
    // Reset the ACI DMA
    //

    m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Reset();
    m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Reset();

    //
    // Reset the sample counters
    //

    ResetGlobalCounters();

    //
    // Reset the GP command block
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK)((LPBYTE)m_ctxMemory[MCPX_MEM_GPSCRATCH].VirtualAddress + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    pCmdBlock->dwCommandFlags = 0;
    pCmdBlock->dwOffset = 0;

    //
    // Reset the DSPs
    //

    MCPX_REG_WRITE(NV_PAPU_GPRST, 0);
    MCPX_REG_WRITE(NV_PAPU_EPRST, 0);

    SetupDSPs();

    //
    // Tell the GP to re-download it's program
    //

    m_pGpDspManager->RestoreCommandBlock();

    pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_XRAM_STATE | BIT_H2DCB_COMMAND_LOAD_CODE;

    //
    // Clear any remaining delta panic bits in the interrupt status
    //

    m_arInterruptStatus[0].DeltaPanic = FALSE;
    m_arInterruptStatus[1].DeltaPanic = FALSE;

    //
    // Enable interrupts
    //

    SetInterruptState(TRUE);

    //
    // Start the ACI running again
    //

    m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Run();
    m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Run();

    //
    // Restore the VP state
    //

    if(fIdle)
    {
        IdleVoiceProcessor(FALSE);
    }

    DPF_LEAVE_VOID();
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  HandleSoftwareMethod
 *
 *  Description:
 *      Dispatches a software-overridden hardware method.
 *
 *  Arguments:
 *      DWORD [in]: method identifier.
 *      DWORD [in]: method parameter.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxAPUTest::HandleSoftwareMethod"

void
CMcpxAPUTest::HandleSoftwareMethod
(
    DWORD                   dwMethod,
    DWORD                   dwParam
)
{
    DPF_ENTER();

    switch(dwMethod)
    {
        case 0x8000:
            
            //
            // SE2FE_IDLE_VOICE is undocumented since it's an internal method
            //


            break;

        default:
            
            //
            // Huh?
            //

            DPF_ERROR("Unexpected software method:  %x %x", dwMethod, dwParam);

            break;
    }

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\gpdsp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       gpdsp.cpp
 *  Content:    GP dsp manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/2001    georgioc created
 *
 ****************************************************************************/


#include "dsoundi.h"
#include "dspdma.h"
#include "GPDsp.h"

//
// include dsp code words for default execution engine loaded into GP after reset
//

#ifdef MCPX_BOOT_LIB

static ULONG DefaultExec[] = 
{
    #include "dspbootsndcode.h"
};

#else // MCPX_BOOT_LIB
    
static ULONG DefaultExec[] = 
{
    #include "dspexeccode.h"
};

#endif // MCPX_BOOT_LIB


VOID
CMcpxDspImageTest::Initialize()
{
    //
    // initialize all the effects here
    //

    m_pLoader = (PVOID)DefaultExec;
    m_uLoaderSize = sizeof(DefaultExec);
   
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// DSP DMA Manager for the GP
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


CMcpxGPDspManagerTest::CMcpxGPDspManagerTest()
{
    m_pScratchDma = NULL;
    m_pDspImage = NULL;
    m_uPMemMaxSize = NV_PAPU_GPPMEM__SIZE_1;
    m_uPMemOffset = 0;

    m_dwCurrentLowestScratchOffset = MCPX_GLOBAL_PROC_SCRATCH_SIZE;
    m_dwStateSizeToCommit = 0;

}

CMcpxGPDspManagerTest::~CMcpxGPDspManagerTest()
{
    DELETE(m_pScratchDma);
    DELETE(m_pDspImage);
#ifndef MCPX_BOOT_LIB
    DELETE(m_pFxDescriptor);
#endif
}

VOID   
CMcpxGPDspManagerTest::Initialize()
{
    //
    // create the dsp table class that holds the code for all effects + loader
    //

    m_pDspImage = NEW(CMcpxDspImageTest());
    ASSERT(m_pDspImage);

    m_pDspImage->Initialize();

    //
    // allocate the scratch Dma, telling it we are the GP
    //

    m_pScratchDma = NEW(CMcpxDspScratchDmaTest(TRUE));
    ASSERT(m_pScratchDma);

    //
    // initialize scratch space handler
    //

    m_pScratchDma->Initialize(MCPX_HW_AC3_NUM_INPUT_PAGES+MCPX_HW_MULTIPASS_NUM_PAGES+MCPX_HW_MAX_FX_SCRATCH_PAGES);
    
    if (!m_pScratchDma)
    {
        ASSERT(FALSE && "CMcpxDspManager::Initialize - one of the objects could not be constructed\n");
        return;
    }
    
    ULONG uOffset = 0;

    ASSERT(m_pDspImage->GetLoaderSize() < DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // load a default exec program to get the GP pumping data to system memory
    //
    
    m_pScratchDma->Copy(uOffset,
                        (VOID *)m_pDspImage->GetLoader(),
                        m_pDspImage->GetLoaderSize());

    return ;

}

HRESULT CMcpxGPDspManagerTest::DownloadEffectsImage
(
    LPCVOID                 pvImageBuffer, 
    DWORD                   dwImageSize,
    LPDSEFFECTIMAGEDESC *   ppImageDesc
)
{

    HRESULT hr = DS_OK;
#ifndef MCPX_BOOT_LIB

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;

    //
    // do some basic validation of the image
    // this should be the image generated by our XPS2 tool..
    //

    ASSERT(dwImageSize > (DSP_COMMANDBLOCK_SCRATCHOFFSET + sizeof(HOST_TO_DSP_COMMANDBLOCK)));

    //
    // verify that command block is preset for instructing the DSP to download new
    // code and state
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)pvImageBuffer + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    ASSERT(pCmdBlock->dwCommandFlags & BIT_H2DCB_COMMAND_LOAD_CODE);
    ASSERT(pCmdBlock->dwCommandFlags & BIT_H2DCB_COMMAND_LOAD_XRAM_STATE);

    ASSERT(dwImageSize <= MCPX_GLOBAL_PROC_SCRATCH_SIZE);

    //
    // proceed to copy the buffer they passed us into offset 0 of scratch memory
    // first zero out the flags in the command block so the dsp does not attempt
    // to download yet
    //

    PHOST_TO_DSP_COMMANDBLOCK pPrivateCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);
    memset(pPrivateCmdBlock,0,sizeof(HOST_TO_DSP_COMMANDBLOCK));

    //
    // copy their image into two parts: 1st part is the command block, second is the rest
    // we dont copy the flags since we want them 0 in the scratch image
    //

    pPrivateCmdBlock->dwOffset = pCmdBlock->dwOffset;
    pPrivateCmdBlock->dwCodeLength = pCmdBlock->dwCodeLength;
    pPrivateCmdBlock->dwStateOffset = pCmdBlock->dwStateOffset;
    pPrivateCmdBlock->dwStateLength = pCmdBlock->dwStateLength;
    pPrivateCmdBlock->dwDspStatus = pCmdBlock->dwDspStatus;

    m_pScratchDma->Copy(DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK),
                        (PUCHAR)pCmdBlock+sizeof(HOST_TO_DSP_COMMANDBLOCK),
                        dwImageSize - DSP_COMMANDBLOCK_SCRATCHOFFSET - sizeof(HOST_TO_DSP_COMMANDBLOCK));

    //
    // parse FX description array, to be used by the SetEffectData api
    //

    hr = ParseEffectImageInfo(pvImageBuffer);
    if (FAILED(hr)){
        return hr;
    }

    if(ppImageDesc) {
        *ppImageDesc = m_pFxDescriptor;
    }

    //
    // we need to keep a cached version of the command block associated with this image
    // We do this so if the user calls SetEffectData and then a delta panic occurs,
    // we can restore the command block and re-download the original code from the
    // correct offset
    //

    memcpy(&m_InitialCmdBlock,pPrivateCmdBlock,sizeof(m_InitialCmdBlock));

#endif //MCPX_BOOT_LIB

    return hr;


}

VOID CMcpxGPDspManagerTest::RestoreCommandBlock() 
{

    PHOST_TO_DSP_COMMANDBLOCK pPrivateCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    pPrivateCmdBlock->dwCommandFlags = 0;
    memcpy(pPrivateCmdBlock,&m_InitialCmdBlock,sizeof(m_InitialCmdBlock));

}

HRESULT CMcpxGPDspManagerTest::ParseEffectImageInfo(LPCVOID pScratchImage)
{
    DWORD dwValue;
    HRESULT hr = S_OK;

#ifndef MCPX_BOOT_LIB

    //
    // retrieve and cache the FX description array
    // We will use it later when the game calls the UpdateEffectParameters API
    //

    LPDSEFFECTIMAGEDESC pDescriptor;
    UCHAR szKey[8];
    int err;
    DWORD dwFxScratchSize = 0;

    PUCHAR pCodeBlock;
    PUCHAR pKeyBlock;

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    pDescriptor = (LPDSEFFECTIMAGEDESC) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() +
        DSP_COMMANDBLOCK_SCRATCHOFFSET +\
        sizeof(HOST_TO_DSP_COMMANDBLOCK) +\
        (pCmdBlock->dwCodeLength*sizeof(DWORD)) +\
        (pCmdBlock->dwStateLength*sizeof(DWORD)) );


	//
	// initialize descriptor
	//

	DWORD dwDescriptorSize = sizeof(DSEFFECTIMAGEDESC) + 
		sizeof(DSEFFECTMAP)*(pDescriptor->dwEffectCount-1);


    if (m_pFxDescriptor != NULL) {

        DELETE(m_pFxDescriptor);
        
    }

    m_pFxDescriptor = (LPDSEFFECTIMAGEDESC) NEW(BYTE[dwDescriptorSize]);

    if (m_pFxDescriptor == NULL) {
        return E_OUTOFMEMORY;
    }

    //
    // check the scratch space usage for the FX chain
    // adjust our ram allocation if required
    //

    if (FAILED(hr = m_pScratchDma->AdjustFxScratch(pDescriptor->dwTotalScratchSize))){
        return hr;
    }

    //
    // we will have to decode the dsp code words since each one
    // is encrypted, using a different dsp dev supplied key.
    // we do in-place decryption
    //

    pCodeBlock = (PUCHAR)pCmdBlock + sizeof(HOST_TO_DSP_COMMANDBLOCK);
    pKeyBlock = (PUCHAR)pDescriptor + dwDescriptorSize;

    //
    // decode keys used to encrypt block
    //

	XAudiopUtility_GenerateKey(szKey);

	err = XAudiopUtility_Decode(szKey,
		pKeyBlock,
		KEY_SIZE*pDescriptor->dwEffectCount,
		pKeyBlock,
		FALSE);
	
    hr = HRESULT_FROM_WIN32(err);
    if (FAILED(hr)) {
        DPF_ERROR("Keyblock decode failed with hr = %x",hr);
        return hr;
    }

    //
    // we need to convert all offsets in FX description elements
    // from relative (the tool creates relative offsets) to absolute
    // This way the caller can treat the LPVOIDs into State, Ymem, Code
    // as normal virtual memory pointers. 
    //

    for (ULONG i=0;i<pDescriptor->dwEffectCount;i++) {

        //
        // decode key block in place using appropriate key
        //

        err = XAudiopUtility_Decode((pKeyBlock+i*KEY_SIZE),
            pCodeBlock,
            pDescriptor->aEffectMaps[i].dwCodeSize,
            pCodeBlock,
            FALSE);
        
        hr = HRESULT_FROM_WIN32(err);
        if (FAILED(hr)) {
            DPF_ERROR("code block decode failed with hr = %x",hr);
            return hr;
        }

        pCodeBlock += pDescriptor->aEffectMaps[i].dwCodeSize;

        //
        // convert code first
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvCodeSegment;

        //
        // create a P-memory absolute address in bytes
        //

        dwValue -= (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));

        //
        // the fx start after the default engine P-words
        //

        dwValue += m_pDspImage->GetLoaderSize();

        //
        // convert P-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPPMEM_REG_OFFSET;

        pDescriptor->aEffectMaps[i].lpvCodeSegment = (LPVOID)dwValue;

        //
        // do the same for Y memory. The tool creates absolute Ymem addresses
        // so all we need to do is add the register space offset
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvYMemorySegment;

        //
        // convert Y-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPYMEM_REG_OFFSET;
        pDescriptor->aEffectMaps[i].lpvYMemorySegment = (LPVOID)dwValue;

        //
        // now convert X-memory relative address
        //

        dwValue = (DWORD) pDescriptor->aEffectMaps[i].lpvStateSegment;

        //
        // create a X-memory absolute address in bytes
        //

        dwValue -= (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));
        dwValue -= pCmdBlock->dwCodeLength*sizeof(DWORD);
        dwValue += DSP_FX_STATE_XMEMORY_BASE_OFFSET;

        //
        // convert X-memory address to a MCPX base register space address
        //

        dwValue += MCPX_HW_GPXMEM_REG_OFFSET;
        pDescriptor->aEffectMaps[i].lpvStateSegment = (LPVOID)dwValue;

        //
        // finally fixup scratch space offset to point to a real VA, not
        // just a relative scratch offset
        //

        dwValue = (DWORD)pDescriptor->aEffectMaps[i].lpvScratchSegment;
        dwValue += (DWORD) m_pScratchDma->GetFxScratchSpaceLinAddr();

        //
        // subtract the fx delay line base offset
        //

        dwValue -= DSP_FX_DELAY_DATA_SCRATCHOFFSET;

        pDescriptor->aEffectMaps[i].lpvScratchSegment = (LPVOID) dwValue;
        
    }

    memcpy(m_pFxDescriptor,pDescriptor,dwDescriptorSize);

    //
    // the dsp will automagically DMA in the new FX dsp code and state when its done with the
    // current 32 sample block processing...
    //

    pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_CODE | BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;

    volatile DWORD *pdwflags = &pCmdBlock->dwCommandFlags;
    while(*pdwflags != 0);

#endif // MCPX_BOOT_LIB

    return S_OK;

}


HRESULT
CMcpxGPDspManagerTest::SetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPCVOID                 pvData, 
    DWORD                   dwDataSize,
    DWORD                   dwFlags
)
{
    LPCDSEFFECTMAP pFxDesc;
    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
    DWORD dwScratchOffset;
    LPVOID pvXramBuffer;
    HRESULT hr;

    ASSERT(dwDataSize >= sizeof(DWORD));

    //
    // FX offset and size must be dword aligned
    //

    ASSERT(!(dwDataSize & 0x00000003));
    ASSERT(!(dwOffset & 0x00000003));

    //
    // get effect map
    //

    hr = GetEffectMap(dwEffectIndex, &pFxDesc);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // validate fx specific parameters
    //

    ASSERT(pFxDesc->dwStateSize >= (dwOffset+dwDataSize));

    //
    // copy in the data they want to update
    // figure a scratch offset, from the mcpx base register space offset
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // we reverse-engineer the scratch offset we stomped on in SetFxDescriptor..
    // needless to say this is magic so if you plan to change make sure you change
    // xgpimage AND SetFxDescriptor correctly as well
    //

    dwScratchOffset = (DWORD)pFxDesc->lpvStateSegment;
    dwScratchOffset -= MCPX_HW_GPXMEM_REG_OFFSET;
    dwScratchOffset -= DSP_FX_STATE_XMEMORY_BASE_OFFSET;
    dwScratchOffset += (DSP_COMMANDBLOCK_SCRATCHOFFSET+sizeof(HOST_TO_DSP_COMMANDBLOCK));
    dwScratchOffset += pCmdBlock->dwCodeLength*sizeof(DWORD);

    dwScratchOffset += dwOffset;
       
    //
    // copy in the data they want to update
    //

    m_pScratchDma->Copy(dwScratchOffset,
                        (PVOID)pvData,
                        dwDataSize);

    if (dwFlags & DSFX_DEFERRED) {        

        //
        // based on where the offset they are updating is, we might have to update
        // our scratch image to deal with sparse memory pokes. If somebody calls
        // SetEffectData(FALSE) twice but the two memory blocks they are updating are
        // non-contigious, we need to fill in the in between memory with latest state
        // from the dsp. Then at commit time, we can commit one big block all at once
        //

        if (m_dwCurrentLowestScratchOffset != MCPX_GLOBAL_PROC_SCRATCH_SIZE) {

            //
            // this is not the first deferred SetEffectData command
            // so we can go ahead and do the sparse checks
            //

            if ((m_dwCurrentLowestScratchOffset+m_dwStateSizeToCommit) < dwScratchOffset) {
    
                //
                // sparse update, on the high end...
                //
    
                dwDataSize += dwScratchOffset - (m_dwCurrentLowestScratchOffset+m_dwStateSizeToCommit);
    
            } else if (m_dwCurrentLowestScratchOffset > (dwScratchOffset+dwDataSize)){
    
                //
                // sparse update below the last block updated
                //
    
                dwDataSize += m_dwCurrentLowestScratchOffset-(dwScratchOffset+dwDataSize);
    
            }

        }

        m_dwCurrentLowestScratchOffset = min(m_dwCurrentLowestScratchOffset,dwScratchOffset);
        m_dwStateSizeToCommit += dwDataSize;

    } else {

        //
        // if they want to commit now, poke directly the XRAM offset
        //

        pvXramBuffer = (LPVOID) ((DWORD)pFxDesc->lpvStateSegment + dwOffset);
        memcpy(pvXramBuffer,pvData,dwDataSize);
    }

    return DS_OK;

}


HRESULT
CMcpxGPDspManagerTest::GetEffectData
(
    DWORD                   dwEffectIndex, 
    DWORD                   dwOffset, 
    LPVOID                  pvData, 
    DWORD                   dwDataSize
)
{
    LPCDSEFFECTMAP pFxDesc;
    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;
    DWORD dwScratchOffset;
    LPVOID pvXramBuffer;
    HRESULT hr;

    ASSERT(dwDataSize >= sizeof(DWORD));

    //
    // FX offset and size must be dword aligned
    //

    ASSERT(!(dwDataSize & 0x00000003));
    ASSERT(!(dwOffset & 0x00000003));

    //
    // get effect map
    //

    hr = GetEffectMap(dwEffectIndex, &pFxDesc);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // validate fx specific parameters
    //

    ASSERT(pFxDesc->dwStateSize >= (dwOffset+dwDataSize));

    //
    // copy fx data
    //

    pvXramBuffer = (LPVOID) ((DWORD)pFxDesc->lpvStateSegment + dwOffset);
    memcpy(pvData,pvXramBuffer,dwDataSize);

    return DS_OK;

}


HRESULT
CMcpxGPDspManagerTest::GetEffectMap
(
    DWORD                   dwEffectIndex, 
    LPCDSEFFECTMAP *        ppEffectMap
)
{
    DSEFFECTIMAGEDESC* pDescriptor = m_pFxDescriptor;

    ASSERT(pDescriptor);
    ASSERT(ppEffectMap);

    //
    // validate params
    //

    if (dwEffectIndex > pDescriptor->dwEffectCount-1) {

        DPF_ERROR("Zero-based Effect Index (%d) is larger than number of Effects (%d) currently loaded in DSP",
                  dwEffectIndex,
                  pDescriptor->dwEffectCount-1);

        return DSERR_INVALIDCALL;

    }

    //
    // retrieve the effect they want to modify
    //

    *ppEffectMap = &pDescriptor->aEffectMaps[dwEffectIndex];

    return DS_OK;
}


VOID
CMcpxGPDspManagerTest::CommitChanges(DWORD dwScratchOffset,DWORD dwDataSize)
{

    PHOST_TO_DSP_COMMANDBLOCK pCmdBlock;

    if (dwDataSize == 0) {

        //
        // use internal members for deferred state update
        //

        dwDataSize = m_dwStateSizeToCommit;
        dwScratchOffset = m_dwCurrentLowestScratchOffset;

        if ((dwScratchOffset == MCPX_GLOBAL_PROC_SCRATCH_SIZE) ||
            (dwDataSize == 0)) {

            //
            // no changes to commit
            //

            DPF_WARNING("CommitEffectData was called but there were no deferred changes!!");
            return;

        }
    }


    //
    // the caller wants to update internal DSP state with this call
    // set up the command block, to signal the DSP to DMA in the new state
    //

    pCmdBlock = (PHOST_TO_DSP_COMMANDBLOCK) ((PUCHAR)m_pScratchDma->GetScratchSpaceLinAddr() + DSP_COMMANDBLOCK_SCRATCHOFFSET);

    //
    // before we go stomping on the existing command block
    // make sure there is no other pending command
    //

    volatile DWORD *pdwflags = &pCmdBlock->dwCommandFlags;
    while(*pdwflags != 0);

    //
    // create xram offset
    // the original base offset can be calculated from the code size
    // the DSP default engine will add this offset to the base offset where the concatenated state blocks live
    //

    
    pCmdBlock->dwOffset = dwScratchOffset/sizeof(DWORD) - 
        (pCmdBlock->dwCodeLength+sizeof(HOST_TO_DSP_COMMANDBLOCK)/sizeof(DWORD)) -
        (DSP_COMMANDBLOCK_SCRATCHOFFSET/sizeof(DWORD));

    pCmdBlock->dwStateOffset = dwScratchOffset;
    pCmdBlock->dwStateLength = dwDataSize/sizeof(DWORD);

    pCmdBlock->dwCommandFlags = BIT_H2DCB_COMMAND_LOAD_XRAM_STATE;

    //
    // set internal member to signal deferred state updates have been flushed
    //

    m_dwCurrentLowestScratchOffset = MCPX_GLOBAL_PROC_SCRATCH_SIZE;
    m_dwStateSizeToCommit = 0;

}

VOID
CMcpxGPDspManagerTest::AC3SetOutputBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages)
{
    //
    // we need to add these pages to the GP dma table
    //

    m_pScratchDma->AddPages(pMem, uNumOfPages, &m_uAC3BufferOffset);

    return;
}

VOID
CMcpxGPDspManagerTest::SetMultipassBuffer(PMCPX_ALLOC_CONTEXT pMem, ULONG uNumOfPages)
{
    //
    // we need to add these pages to the GP dma table
    //

    m_pScratchDma->AddPages(pMem, uNumOfPages, &m_uMultipassBufferOffset);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\mcpapu.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpapu.h
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created based on NVidia/georgioc code.
 *
 ****************************************************************************/

#ifndef __MCPAPU_H__
#define __MCPAPU_H__

//
// Voice indeces
//

#define MCPX_IS_3D_VOICE(hVoice) \
    ((DWORD)hVoice < MCPX_HW_MAX_3D_VOICES)

#ifdef __cplusplus

//
// Forward declarations
//

class CMcpxVoiceClient;
class CMcpxBuffer;
class CMcpxStream;

//
// Deferred commands.  Command indeces must be numbered from 0 up, and must
// have low-priority commands in the lowest numbers.
//

#define MCPX_DEFERREDCMDF_LOWPRIORITY   0x00000001
#define MCPX_DEFERREDCMDF_SCHEDULED     0x00000002
#define MCPX_DEFERREDCMDF_PERSIST       0x00000004

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY              leListEntry;
    DWORD                   dwFlags;
    CMcpxVoiceClient *      pVoice;
    DWORD                   dwCommand;
    DWORD                   dwContext;
    REFERENCE_TIME          rtTimestamp;
END_DEFINE_STRUCT(MCPX_DEFERRED_COMMAND);

BEGIN_DEFINE_ENUM()
    MCPX_DEFERREDCMD_BUFFER_RELEASERESOURCES = 0,
    MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA,
    MCPX_DEFERREDCMD_BUFFER_PLAY,
    MCPX_DEFERREDCMD_BUFFER_STOP,
    MCPX_DEFERREDCMD_BUFFER_COUNT
END_DEFINE_ENUM_();

#define MCPX_DEFERREDCMD_BUFFER_LOWPRIOCOUNT    (MCPX_DEFERREDCMD_BUFFER_POSITIONDELTA + 1)

BEGIN_DEFINE_ENUM()
    MCPX_DEFERREDCMD_STREAM_RELEASERESOURCES = 0,
    MCPX_DEFERREDCMD_STREAM_COMPLETEPACKETS,
    MCPX_DEFERREDCMD_STREAM_FLUSH,
    MCPX_DEFERREDCMD_STREAM_STOP,
    MCPX_DEFERREDCMD_STREAM_COUNT
END_DEFINE_ENUM_();

#define MCPX_DEFERREDCMD_STREAM_LOWPRIOCOUNT    (MCPX_DEFERREDCMD_STREAM_FLUSH + 1)

//
// Miscelaneous APU state flags
//

#define MCPX_APUSTATE_GPIMAGE           0x00000001

//
// Audio device implementation
//

class CMcpxAPUTest
    : public CRefCountTest, public CMcpxCoreTest

{
    friend class CMcpxVoiceClient;

public:
    WORD                        m_wFree2dVoiceCount;                                    // Count of free 2D voices
    WORD                        m_wFree3dVoiceCount;                                    // Count of free 3D voices
    LIST_ENTRY                  m_lst3dVoices;                                          // List of 3D voices
    CMcpxBufferSgeHeapTest          m_SgeHeap;                                              // Buffer scatter-gather heap object
    DWORD                       m_dwState;                                              // APU state flags
                                                                                        
protected:                                                                              
    volatile DWORD              m_dwVoiceMapLock;                                       // Voice map/list lock count
    LIST_ENTRY                  m_alstActiveVoices[MCPX_VOICELIST_COUNT];               // Active voice list
    LIST_ENTRY                  m_lstPendingInactiveVoices;                             // Pending inactive voice list
    LIST_ENTRY                  m_lstDeferredCommandsHigh;                              // Voice deferred command list (high-priority)
    LIST_ENTRY                  m_lstDeferredCommandsLow;                               // Voice deferred command list (low-priority)
    R_INTR                      m_arInterruptStatus[2];                                 // Status bits from last interrupt received
    KDPC                        m_dpcInterrupt;                                         // Interrupt handler DPC object
    static KINTERRUPT           m_Interrupt;                                            // Interrupt object
    KTIMER                      m_tmrDeferredCommandsHigh;                              // Voice deferred command timer
    KDPC                        m_dpcDeferredCommandsHigh;                              // Voice deferred command DPC
    HAL_SHUTDOWN_REGISTRATION   m_HalShutdownData;                                      // HAL shutdown registration data

private:
    static DWORD                m_dwDeltaPanicCount;                                    // Delta panic counter

public:
    CMcpxAPUTest(CDirectSoundTestSettings *pSettings);
    virtual ~CMcpxAPUTest(void);

public:
    // Initialization
    HRESULT Initialize(void);

    // GP DSP
    HRESULT DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPDSEFFECTIMAGEDESC *ppImageDesc);
    HRESULT SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags);
    HRESULT GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize);
    HRESULT CommitEffectData(void);


    // Synchronization
    void BlockIdleHandler(void);
    void UnblockIdleHandler(void);

    // Deferred voice commands
    BOOL ScheduleDeferredCommand(LPMCPX_DEFERRED_COMMAND pCmd);
    void RemoveDeferredCommand(LPMCPX_DEFERRED_COMMAND pCmd);

    // Work, work, work
    void DoWork(void);

protected:

    // Shutdown
    void Terminate(void);
    
    // Interrupt handlers
    BOOL ServiceApuInterrupt(void);
    void ServiceApuInterruptDpc(void);
    void ServiceVoiceInterrupt(void);
    void WaitForMagicWrite(void);
    void HandleFETrap(void);

#ifndef MCPX_BOOT_LIB

    void HandleDeltaPanic(void);

#endif // MCPX_BOOT_LIB

    void HandleSoftwareMethod(DWORD dwMethod, DWORD dwParam);

    // Interrupt service
    void ScheduleApuInterruptDpc(void);
    void GetInterruptStatus(void);

private:
    static BOOLEAN ApuInterruptServiceRoutine(PKINTERRUPT pInterrupt, LPVOID pvContext);
    static void ApuInterruptDpcRoutine(PKDPC pDpc, LPVOID pvDeferredContext, LPVOID pvSystemContext1, LPVOID pvSystemContext2);
    static BOOLEAN GetInterruptStatusCallback(LPVOID pvContext);
    static void DeferredCommandDpcRoutine(PKDPC pdpc, LPVOID pvDeferredContext, LPVOID pvSystemContext1, LPVOID pvSystemContext2);
    static void ApuShutdownNotifier(PHAL_SHUTDOWN_REGISTRATION pHalShutdownData);
};


__inline HRESULT CMcpxAPUTest::DownloadEffectsImage(LPCVOID pvImageBuffer, DWORD dwImageSize, LPDSEFFECTIMAGEDESC *ppImageDesc)
{
    HRESULT                 hr;
    
    ASSERT(m_pGpDspManager);

    if(SUCCEEDED(hr = m_pGpDspManager->DownloadEffectsImage(pvImageBuffer, dwImageSize, ppImageDesc)))
    {
        m_dwState |= MCPX_APUSTATE_GPIMAGE;
    }
    else
    {
        m_dwState &= ~MCPX_APUSTATE_GPIMAGE;
    }

    return hr;
}

__inline HRESULT CMcpxAPUTest::SetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPCVOID pvData, DWORD dwDataSize, DWORD dwFlags)
{
    ASSERT(m_pGpDspManager);
    ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);

    return m_pGpDspManager->SetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize, dwFlags);
}
    
__inline HRESULT CMcpxAPUTest::GetEffectData(DWORD dwEffectIndex, DWORD dwOffset, LPVOID pvData, DWORD dwDataSize)
{
    ASSERT(m_pGpDspManager);
    ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);

    return m_pGpDspManager->GetEffectData(dwEffectIndex, dwOffset, pvData, dwDataSize);
}
    
__inline HRESULT CMcpxAPUTest::CommitEffectData(void)
{
    ASSERT(m_pGpDspManager);
    ASSERT(m_dwState & MCPX_APUSTATE_GPIMAGE);

    m_pGpDspManager->CommitChanges(0, 0);

    return DS_OK;
}
    
__inline BOOLEAN CMcpxAPUTest::ApuInterruptServiceRoutine(PKINTERRUPT pInterrupt, LPVOID pvContext)
{
    return (BOOLEAN)((CMcpxAPUTest *)pvContext)->ServiceApuInterrupt();
}

__inline void CMcpxAPUTest::ApuInterruptDpcRoutine(PKDPC pDpc, LPVOID pvDeferredContext, LPVOID pvSystemContext1, LPVOID pvSystemContext2)
{
    ((CMcpxAPUTest *)pvDeferredContext)->ServiceApuInterruptDpc();
}

__inline void CMcpxAPUTest::DeferredCommandDpcRoutine(PKDPC pdpc, LPVOID pvDeferredContext, LPVOID pvSystemContext1, LPVOID pvSystemContext2)
{
}

__inline void CMcpxAPUTest::ApuShutdownNotifier(PHAL_SHUTDOWN_REGISTRATION pHalShutdownData)
{
    g_fDirectSoundTestInFinalRelease = TRUE;
    
    CONTAINING_RECORD(pHalShutdownData, CMcpxAPUTest, m_HalShutdownData)->Terminate();
}


__inline void CMcpxAPUTest::BlockIdleHandler(void)
{
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    ASSERT(m_dwVoiceMapLock < ~0UL);
    m_dwVoiceMapLock++;
}

__inline void CMcpxAPUTest::UnblockIdleHandler(void)
{
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    ASSERT(m_dwVoiceMapLock >= 1);
    m_dwVoiceMapLock--;
}

__inline void CMcpxAPUTest::ScheduleApuInterruptDpc(void)
{
    KeInsertQueueDpc(&m_dpcInterrupt, NULL, NULL);
}

#endif // __cplusplus

#endif // __MCPAPU_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\memmgr.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memmgr.h
 *  Content:    DirectSound memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/21/00    dereks  Created.
 *
 ****************************************************************************/

#ifndef __MEMMGR_H__
#define __MEMMGR_H__

#define ENABLE_SLOP_MEMORY_RECOVERY

#if defined(DEBUG) && !defined(TRACK_MEMORY_USAGE) && !defined(MCPX_BOOT_LIB)
#define TRACK_MEMORY_USAGE
#endif // defined(DEBUG) && !defined(TRACK_MEMORY_USAGE) && !defined(MCPX_BOOT_LIB)

BEGIN_DEFINE_ENUM()
    DSOUND_OBJECT_POOL_TAG  = 'boSD',
    DSOUND_DATA_POOL_TAG    = 'adSD'
END_DEFINE_ENUM(DSOUND_POOL_TAG);

BEGIN_DEFINE_ENUM()
    DSOUND_ALLOCATOR_POOL   = 'loop',
    DSOUND_ALLOCATOR_PHYS   = 'syhp',
    DSOUND_ALLOCATOR_SLOP   = 'pols'
END_DEFINE_ENUM(DSOUND_ALLOCATOR_TAG);

//
// Memory management functions
//

#ifdef TRACK_MEMORY_USAGE

EXTERN_C LPVOID DirectSoundTestTrackingPoolAlloc(LPCSTR pszFile, ULONG nLine, LPCSTR pszClass, DSOUND_POOL_TAG nTag, ULONG cbBuffer, BOOL fZeroInit);
EXTERN_C void DirectSoundTestTrackingPoolFree(LPVOID pvBuffer);

EXTERN_C LPVOID DirectSoundTestTrackingPhysicalAlloc(LPCSTR pszFile, ULONG nLine, LPCSTR pszClass, ULONG cbBuffer, ULONG cbAlignment, DWORD dwFlags, BOOL fZeroInit);
EXTERN_C void DirectSoundTestTrackingPhysicalFree(LPVOID pvBuffer);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

EXTERN_C LPVOID DirectSoundTestTrackingMemAlloc(LPCSTR pszFile, ULONG nLine, LPCSTR pszClass, DSOUND_POOL_TAG nTag, ULONG cbBuffer, BOOL fZeroInit);
EXTERN_C void DirectSoundTestTrackingMemFree(LPVOID pvBuffer);

#else // ENABLE_SLOP_MEMORY_RECOVERY

#define DirectSoundTestTrackingMemAlloc DirectSoundTestTrackingPoolAlloc
#define DirectSoundTestTrackingMemFree DirectSoundTestTrackingPoolFree

#endif // ENABLE_SLOP_MEMORY_RECOVERY

#else // TRACK_MEMORY_USAGE

EXTERN_C LPVOID DirectSoundTestPoolAlloc(DSOUND_POOL_TAG nTag, ULONG cbBuffer, BOOL fZeroInit);
EXTERN_C void DirectSoundTestPoolFree(LPVOID pvBuffer);

EXTERN_C LPVOID DirectSoundTestPhysicalAlloc(ULONG cbBuffer, ULONG cbAlignment, DWORD dwFlags, BOOL fZeroInit);
EXTERN_C void DirectSoundTestPhysicalFree(LPVOID pvBuffer);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

EXTERN_C LPVOID DirectSoundTestMemAlloc(DSOUND_POOL_TAG nTag, ULONG cbBuffer, BOOL fZeroInit);
EXTERN_C void DirectSoundTestMemFree(LPVOID pvBuffer);

#else // ENABLE_SLOP_MEMORY_RECOVERY

#define DirectSoundTestMemAlloc DirectSoundTestPoolAlloc
#define DirectSoundTestMemFree DirectSoundTestPoolFree

#endif // ENABLE_SLOP_MEMORY_RECOVERY

#define DirectSoundTestTrackingPoolAlloc(pszFile, nLine, pszClass, nTag, cbBuffer, fZeroInit) \
    DirectSoundTestPoolAlloc(nTag, cbBuffer, fZeroInit)

#define DirectSoundTestTrackingPoolFree(pvBuffer) \
    DirectSoundTestPoolFree(pvBuffer)

#define DirectSoundTestTrackingPhysicalAlloc(pszFile, nLine, pszClass, cbBuffer, cbAlignment, dwFlags, fZeroInit) \
    DirectSoundTestPhysicalAlloc(cbBuffer, cbAlignment, dwFlags, fZeroInit)

#define DirectSoundTestTrackingPhysicalFree(pvBuffer) \
    DirectSoundTestPhysicalFree(pvBuffer)

#define DirectSoundTestTrackingMemAlloc(pszFile, nLine, pszClass, nTag, cbBuffer, fZeroInit) \
    DirectSoundTestMemAlloc(nTag, cbBuffer, fZeroInit)

#define DirectSoundTestTrackingMemFree(pvBuffer) \
    DirectSoundTestMemFree(pvBuffer)

#endif // TRACK_MEMORY_USAGE

//
// Memory management macros
//

#define MEMALLOC(type, count) \
    ((type *)DirectSoundTestTrackingMemAlloc(__FILE__, __LINE__, #type, DSOUND_DATA_POOL_TAG, sizeof(type) * (count), TRUE))

#define MEMALLOC_NOINIT(type, count) \
    ((type *)DirectSoundTestTrackingMemAlloc(__FILE__, __LINE__, #type, DSOUND_DATA_POOL_TAG, sizeof(type) * (count), FALSE))

#define MEMFREE(p) \
    { \
        if(p) \
        { \
            DirectSoundTestTrackingMemFree(p); \
            (p) = NULL; \
        } \
    }

#define POOLALLOC(type, count) \
    ((type *)DirectSoundTestTrackingPoolAlloc(__FILE__, __LINE__, #type, DSOUND_DATA_POOL_TAG, sizeof(type) * (count), TRUE))

#define POOLALLOC_NOINIT(type, count) \
    ((type *)DirectSoundTestTrackingPoolAlloc(__FILE__, __LINE__, #type, DSOUND_DATA_POOL_TAG, sizeof(type) * (count), FALSE))

#define POOLFREE(p) \
    { \
        if(p) \
        { \
            DirectSoundTestTrackingPoolFree(p); \
            (p) = NULL; \
        } \
    }

#define PHYSALLOC(type, count, alignment, flags) \
    ((type *)DirectSoundTestTrackingPhysicalAlloc(__FILE__, __LINE__, #type, sizeof(type) * (count), alignment, flags, TRUE))

#define PHYSALLOC_NOINIT(type, count, alignment, flags) \
    ((type *)DirectSoundTestTrackingPhysicalAlloc(__FILE__, __LINE__, #type, sizeof(type) * (count), alignment, flags, FALSE))

#define PHYSFREE(p) \
    { \
        if(p) \
        { \
            DirectSoundTestTrackingPhysicalFree(p); \
            (p) = NULL; \
        } \
    }

//
// New and delete overrides
//

#ifdef __cplusplus

#ifndef DSOUND_NO_OVERRIDE_NEW_DELETE

static void *__cdecl operator new(size_t cbBuffer) 
{ 
    return DirectSoundTestTrackingMemAlloc("(none)", 0, "(unknown)", DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 
}

static void *__cdecl operator new[](size_t cbBuffer) 
{ 
    return DirectSoundTestTrackingMemAlloc("(none)", 0, "(unknown)", DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE);
}

#ifdef TRACK_MEMORY_USAGE

static void *__cdecl operator new(size_t cbBuffer, LPCSTR pszFile, ULONG nLine, LPCSTR pszClass)
{
    return DirectSoundTestTrackingMemAlloc(pszFile, nLine, pszClass, DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 
}

static void *__cdecl operator new[](size_t cbBuffer, LPCSTR pszFile, ULONG nLine, LPCSTR pszClass)
{
    return DirectSoundTestTrackingMemAlloc(pszFile, nLine, pszClass, DSOUND_OBJECT_POOL_TAG, cbBuffer, TRUE); 
}

#endif // TRACK_MEMORY_USAGE

static void __cdecl operator delete(void *pvBuffer) 
{ 
    DirectSoundTestTrackingMemFree(pvBuffer); 
}

static void __cdecl operator delete[](void *pvBuffer) 
{ 
    DirectSoundTestTrackingMemFree(pvBuffer); 
}

#endif // DSOUND_NO_OVERRIDE_NEW_DELETE

#ifdef TRACK_MEMORY_USAGE

#define NEW(type) \
    new(__FILE__, __LINE__, #type) type

#define NEW_A(type, count) \
    new(__FILE__, __LINE__, #type) type [count]

#else // TRACK_MEMORY_USAGE

#define NEW(type) \
    new type

#define NEW_A(type, count) \
    new type [count]

#endif // TRACK_MEMORY_USAGE

#undef DELETE
#define DELETE(p) \
    { \
        if(p) \
        { \
            delete (p); \
            (p) = NULL; \
        } \
    }

#define DELETE_A(p) \
    { \
        if(p) \
        { \
            delete [] (p); \
            (p) = NULL; \
        } \
    }

#endif // __cplusplus

#endif // __MEMMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\mcpxcore.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpxcore.h
 *  Content:    MCP-X audio device objects.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __MCPXCORE_H__
#define __MCPXCORE_H__

// #define MCPX_LOG_APU_WRITES
// #define MCPX_LOG_APU_READS
// #define MCPX_LOG_VP_WRITES
// #define MCPX_LOG_VOICE_STRUCT_READS
// #define MCPX_LOG_VOICE_STRUCT_WRITES

#include "mcpxhw.h"

DEFINETYPE(MCPX_VOICE_HANDLE, WORD);

#define MCPX_VOICE_HANDLE_INVALID ((MCPX_VOICE_HANDLE)~0UL)

#ifdef __cplusplus

//
// Register value macros
//

#define MCPX_REF_SHIFT(drf) \
    (0 ? drf)

#define MCPX_REF_MASK(drf) \
    ((1 << ((1 ? drf) - (0 ? drf) + 1)) - 1)

#define MCPX_CLEAR_REG_VALUE(arg, drf) \
    ((arg) & ~(MCPX_REF_MASK(drf) << MCPX_REF_SHIFT(drf)))

#define MCPX_MAKE_REG_VALUE(val, drf) \
    ((((DWORD)(val)) & MCPX_REF_MASK(drf)) << MCPX_REF_SHIFT(drf))

#define MCPX_GET_REG_VALUE(arg, drf) \
    (((arg) >> MCPX_REF_SHIFT(drf)) & MCPX_REF_MASK(drf))

#define MCPX_SET_REG_VALUE(arg, val, drf) \
    (MCPX_CLEAR_REG_VALUE(arg, drf) | MCPX_MAKE_REG_VALUE(val, drf))

#define MCPX_DEVICE_BASE(d) \
    (0 ? d)

//
// APU core register access macros
//

#ifdef MCPX_LOG_APU_WRITES
#define DPF_MCPX_APU_WRITE DPF_ABSOLUTE
#else // MCPX_LOG_APU_WRITES
#define DPF_MCPX_APU_WRITE()
#endif // MCPX_LOG_APU_WRITES

#ifdef MCPX_LOG_APU_READS
#define DPF_MCPX_APU_READ DPF_ABSOLUTE
#else // MCPX_LOG_APU_READS
#define DPF_MCPX_APU_READ()
#endif // MCPX_LOG_APU_READS

#define MCPX_REGISTER_ADDRESS(reg) \
    (XPCICFG_APU_MEMORY_REGISTER_BASE_0 + (reg))

#define MCPX_REGISTER(reg) \
    (*(volatile DWORD *)MCPX_REGISTER_ADDRESS(reg))

#define MCPX_REG_WRITE(reg, value) \
    DPF_MCPX_APU_WRITE("APU write: offset %x (%x), value %x", (DWORD)(reg), MCPX_REGISTER_ADDRESS(reg), (DWORD)(value)); \
    MCPX_REGISTER(reg) = (DWORD)(value)

#define MCPX_REG_READ(reg, value) \
    *(value) = MCPX_REGISTER(reg); \
    DPF_MCPX_APU_READ("APU read: offset %x (%x), value %x", (DWORD)(reg), MCPX_REGISTER_ADDRESS(reg), (DWORD)*(value))

//
// VP register access macros
//

#ifdef MCPX_LOG_VP_WRITES
#define DPF_MCPX_VP_WRITE DPF_ABSOLUTE
#else // MCPX_LOG_VP_WRITES
#define DPF_MCPX_VP_WRITE()
#endif // MCPX_LOG_VP_WRITES

#define MCPX_VOICE_PROCESSOR_BASE \
    MCPX_REGISTER_ADDRESS(MCPX_DEVICE_BASE(NV_PAPU_NV1BA0))

#define MCPX_VOICE_REGISTER(reg) \
    (((LPMCPXVPREGSET)MCPX_VOICE_PROCESSOR_BASE)->reg)

#define MCPX_CHECK_VOICE_FIFO_INIT(method_count) \
    ASSERT((method_count) <= PIO_METHOD_QUEUE_CLEAR); \
    while(MCPX_VOICE_REGISTER(PIOFree) / 4 < (DWORD)(method_count)) \
    { \
        DPF_MCPX_VP_WRITE("Waiting for PIO to free up..."); \
    }

#define MCPX_CHECK_VOICE_FIFO(method_count) \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL); \
    MCPX_CHECK_VOICE_FIFO_INIT(method_count)

#define MCPX_VOICE_WRITE(reg, value) \
    DPF_MCPX_VP_WRITE("VP write: " QUOTE1(reg) " (offset %x, address %x), value %x", offsetof(MCPXVPREGSET, reg), &MCPX_VOICE_REGISTER(reg), (DWORD)(value)); \
    MCPX_VOICE_REGISTER(reg) = (DWORD)(value)

//
// Voice data access macros
//

#ifdef MCPX_LOG_VOICE_STRUCT_READS
#define DPF_MCPX_VOICE_STRUCT_READ DPF_ABSOLUTE
#else // MCPX_LOG_VOICE_STRUCT_READS
#define DPF_MCPX_VOICE_STRUCT_READ()
#endif // MCPX_LOG_VOICE_STRUCT_READS

#ifdef MCPX_LOG_VOICE_STRUCT_WRITES
#define DPF_MCPX_VOICE_STRUCT_WRITE DPF_ABSOLUTE
#else // MCPX_LOG_VOICE_STRUCT_WRITES
#define DPF_MCPX_VOICE_STRUCT_WRITE()
#endif // MCPX_LOG_VOICE_STRUCT_WRITES

#define MCPX_VOICE_STRUCT_BASE(voice_index) \
    ((DWORD)(CMcpxCoreTest::m_ctxMemory[MCPX_MEM_VOICE].VirtualAddress) + ((DWORD)(voice_index) * NV_PAVS_SIZE))

#define MCPX_VOICE_STRUCT_OFFSET(voice_index, reg) \
    (MCPX_VOICE_STRUCT_BASE(voice_index) + (reg))

#define MCPX_VOICE_STRUCT(voice_index, reg) \
    (*(volatile DWORD *)MCPX_VOICE_STRUCT_OFFSET(voice_index, reg))

#define MCPX_VOICE_STRUCT_READ(voice_index, reg, value) \
    *(value) = MCPX_VOICE_STRUCT(voice_index, reg)
    DPF_MCPX_VOICE_STRUCT_READ("Voice struct read: voice %x, reg %x, address %x, value %x", (DWORD)(voice_index), (DWORD)(reg), MCPX_VOICE_STRUCT_OFFSET(voice_index, reg), (DWORD)*(value))

#define MCPX_VOICE_STRUCT_WRITE(voice_index, reg, value) \
    MCPX_VOICE_STRUCT(voice_index, reg) = (DWORD)(value); \
    DPF_MCPX_VOICE_STRUCT_WRITE("Voice struct write: voice %x, reg %x, address %x, value %x", (DWORD)(voice_index), (DWORD)(reg), MCPX_VOICE_STRUCT_OFFSET(voice_index, reg), (DWORD)(value))

// 
// MCP-X physical resource descriptor
//

BEGIN_DEFINE_STRUCT()
	PVOID   VirtualAddress;
	ULONG   PhysicalAddress;
	ULONG   Size;
#ifdef ENABLE_SLOP_MEMORY_RECOVERY
    BOOL    fOwned;
#endif // ENABLE_SLOP_MEMORY_RECOVERY
END_DEFINE_STRUCT(MCPX_ALLOC_CONTEXT);

//
// GP output buffers
//

BEGIN_DEFINE_ENUM()
    MCPX_GPOUTPUT_BOOTSOUND = 0,
    MCPX_GPOUTPUT_COUNT
END_DEFINE_ENUM_();

//
// EP output buffers
//

BEGIN_DEFINE_ENUM()
    MCPX_EPOUTPUT_AC97_ANALOG = 0,
    MCPX_EPOUTPUT_AC97_DIGITAL,
    MCPX_EPOUTPUT_COUNT
END_DEFINE_ENUM_();

//
// Front-end states
//

BEGIN_DEFINE_ENUM()
    MCPX_FE_STATE_HALTED,
    MCPX_FE_STATE_FREE_RUNNING,
    MCPX_FE_STATE_ISO,
    MCPX_FE_STATE_NON_ISO,
END_DEFINE_ENUM(MCPX_FE_STATE);

//
// Setup engine states
//

BEGIN_DEFINE_ENUM()
    MCPX_SE_STATE_OFF = 0,
    MCPX_SE_STATE_AC_SYNC,
    MCPX_SE_STATE_SW,
    MCPX_SE_STATE_FREE_RUNNING,
    MCPX_SE_STATE_ISO,
    MCPX_SE_STATE_NON_ISO,
END_DEFINE_ENUM(MCPX_SE_STATE);

//
// APU memory.  The order actually matters, so don't mess with it
//

BEGIN_DEFINE_ENUM()
    MCPX_MEM_GPOUTPUT = 0,
    MCPX_MEM_EPOUTPUT,
    MCPX_MEM_MAGICWRITE,
    MCPX_MEM_VOICE,
    MCPX_MEM_NOTIFIERS,
    MCPX_MEM_INPUTSGE,
    MCPX_MEM_INPUTPRD,
    MCPX_MEM_HRTFTARGET,
    MCPX_MEM_HRTFCURRENT,
    MCPX_MEM_GPOUTPUTSGE,    
    MCPX_MEM_EPOUTPUTSGE,
    MCPX_MEM_GPMULTIPASS,
    MCPX_MEM_GPSCRATCH,
    MCPX_MEM_GPSCRATCHSGE,
    MCPX_MEM_EPSCRATCH,
    MCPX_MEM_EPSCRATCHSGE,
    MCPX_MEM_COUNT,
END_DEFINE_ENUM_();

//
// Voice list identifiers.  Add 1 to this value to get the hardware register 
// equivalent.
//

BEGIN_DEFINE_ENUM()
    MCPX_VOICELIST_2D = 0,
    MCPX_VOICELIST_3D,
    MCPX_VOICELIST_MP,
    MCPX_VOICELIST_COUNT,
    MCPX_VOICELIST_INVALID = 0xFF
END_DEFINE_ENUM_();

//
// Voice notifiers
//

#define MCPX_NOTIFIER_BASE_OFFSET 2
                                        
BEGIN_DEFINE_ENUM()
    MCPX_NOTIFIER_SSLA_DONE = 0,
    MCPX_NOTIFIER_SSLB_DONE,
    MCPX_NOTIFIER_SSLA_GETPOS,
    MCPX_NOTIFIER_VOICE_OFF,
    MCPX_NOTIFIER_COUNT
END_DEFINE_ENUM_();

//
// Forward declarations
//

class CDirectSoundTestSettings;
class CDirectSoundVoiceSettings;
class CDirectSoundBufferSettings;
class CDirectSoundStreamSettings;
class CMcpxGPDspManagerTest;
class CMcpxEPDspManagerTest;

//
// The MCPX APU core object
//

class CMcpxCoreTest
{
public:
    static const DWORD          m_adwGPOutputBufferSizes[MCPX_GPOUTPUT_COUNT];  // GP Output buffer sizes, in bytes
    static const DWORD          m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_COUNT];  // EP Output buffer sizes, in bytes
	static MCPX_ALLOC_CONTEXT   m_ctxMemory[MCPX_MEM_COUNT];                    // APU memory
    CDirectSoundTestSettings *      m_pSettings;                                    // Shared settings object

protected:                      

#ifdef ENABLE_SLOP_MEMORY_RECOVERY
    
    CMcpxSlopMemoryHeapTest *       m_pSlopMemoryHeap;                              // Slop memory heap

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    CMcpxGPDspManagerTest *         m_pGpDspManager;                                // GP DSP manager object

#ifndef MCPX_BOOT_LIB

    CMcpxEPDspManagerTest *         m_pEpDspManager;                                // EP DSP manager object

#endif // MCPX_BOOT_LIB

    CAc97Device                 m_Ac97;                                         // AC97 device object

public:
    CMcpxCoreTest(CDirectSoundTestSettings *pSettings);
    virtual ~CMcpxCoreTest(void);

public:
    // Initialization
    HRESULT Initialize(void);

    // APU component state
    BOOL IdleVoiceProcessor(BOOL fIdle);

    // Utility functions
    static DWORD GetPhysicalMemoryProperties(LPVOID pvBuffer, DWORD dwBufferSize, LPDWORD pdwPageOffset, LPDWORD pdwContiguousLength);
    static DWORD MapTransfer(LPVOID *ppvBuffer, LPDWORD pdwBufferSize, LPDWORD pdwBytesMapped);
    static HRESULT AllocateContext(PMCPX_ALLOC_CONTEXT pContext, DWORD dwAlignment, DWORD dwFlags);

protected:
    // Shutdown
    void Reset(void);

    // APU component state
    void SetInterruptState(BOOL fEnabled);
    void SetPrivLockState(BOOL fLocked);
    void SetFrontEndState(MCPX_FE_STATE nState);
    void SetSetupEngineState(MCPX_SE_STATE nState);
    void ResetGlobalCounters(void);

    // APU setup
    HRESULT AllocateApuMemory(void);
    void SetupFrontEndProcessor(void);
    void SetupVoiceProcessor(void);
    void SetupDSPs(void);
    void SetupGlobalProcessor(void);

#ifndef MCPX_BOOT_LIB

    void SetupEncodeProcessor(void);

#endif // MCPX_BOOT_LIB

    HRESULT SetupAc97(void);
};

__inline void CMcpxCoreTest::SetupDSPs(void)
{
    SetupGlobalProcessor();

#ifndef MCPX_BOOT_LIB

    SetupEncodeProcessor();
    KeStallExecutionProcessor(10 * 1000);

#endif // MCPX_BOOT_LIB

}

//
// MCPX notifier wrapper class
//

class CMcpxNotifierTest
{
private:
    PMCPX_HW_NOTIFICATION       m_paNotifier;       // Base notifier pointer
    DWORD                       m_dwNotifierCount;  // Count of notifiers controlled by this object

public:
    CMcpxNotifierTest(void);

public:
    // Initialization
    void Initialize(DWORD dwBaseNotifierIndex, DWORD dwNotifierCount);
    void Free(void);

    // Notifier status
    BOOL GetStatus(DWORD dwNotifierIndex);
    void SetStatus(DWORD dwNotifierIndex, BOOL fSignaled);
    void Reset(void);
};

__inline CMcpxNotifierTest::CMcpxNotifierTest(void)
{
    Free();
}

__inline void CMcpxNotifierTest::Initialize(DWORD dwBaseNotifierIndex, DWORD dwNotifierCount)
{
    ASSERT(!m_paNotifier);
    ASSERT(!m_dwNotifierCount);

    m_paNotifier = (PMCPX_HW_NOTIFICATION)CMcpxCoreTest::m_ctxMemory[MCPX_MEM_NOTIFIERS].VirtualAddress + dwBaseNotifierIndex;
    m_dwNotifierCount = dwNotifierCount;

    Reset();
}

__inline void CMcpxNotifierTest::Free(void)
{
    m_paNotifier = NULL;
    m_dwNotifierCount = 0;
}

__inline BOOL CMcpxNotifierTest::GetStatus(DWORD dwNotifierIndex)
{
    ASSERT(m_paNotifier);
    ASSERT(dwNotifierIndex < m_dwNotifierCount);
    
    switch(m_paNotifier[dwNotifierIndex].Status)
    {
        case NV1BA0_NOTIFICATION_STATUS_DONE_SUCCESS:
            return TRUE;

        case NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS:
            return FALSE;

        default:
            ASSERTMSG("Unexpected notifier status");
            return FALSE;
    }
}

__inline void CMcpxNotifierTest::SetStatus(DWORD dwNotifierIndex, BOOL fSignaled)
{
    ASSERT(m_paNotifier);
    ASSERT(dwNotifierIndex < m_dwNotifierCount);

    m_paNotifier[dwNotifierIndex].Status = fSignaled ? NV1BA0_NOTIFICATION_STATUS_DONE_SUCCESS : NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS;
}

__inline void CMcpxNotifierTest::Reset(void)
{
    DWORD                   dwNotifierIndex;
    
    ASSERT(m_paNotifier);
    ASSERT(m_dwNotifierCount);

    for(dwNotifierIndex = 0; dwNotifierIndex < m_dwNotifierCount; dwNotifierIndex++)
    {
        m_paNotifier[dwNotifierIndex].Status = NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS;
    }
}

//
// Miscelaneous MCPX includes
//

#include "dspdma.h"
#include "gpdsp.h"
#include "epdsp.h"
#include "mcpapu.h"

#endif // __cplusplus

#endif // __MCPXCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\nv_uep.h ===
#ifndef __NV_EAP_H__
#define __NV_EAP_H__

// software methods for the EP...
#define NV1BAE_PIO_SET_OUTBUF_BA(i)                             (0x00000000+(i)*8) /* -W-4A */
#define NV1BAE_PIO_SET_OUTBUF_BA__SIZE_1                        4 /* */ 
#define NV1BAE_PIO_SET_OUTBUF_BA_ADDRESS                        23:0 /* -W-UF */
#define NV1BAE_PIO_SET_OUTBUF_LEN(i)                            (0x00000004+(i)*8) /* -W-4A */
#define NV1BAE_PIO_SET_OUTBUF_LEN__SIZE_1                       4 /* */ 
#define NV1BAE_PIO_SET_OUTBUF_LEN_VALUE                         23:0 /* -W-UF */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE                       0x00000028 /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_HANDLE                31:0 /* -W-VF */
#define NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA           0x0000002C /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA_HANDLE    31:0 /* -W-VF */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET                0x00000030 /* -W-4R */
#define NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET_PARAMETER      31:12 /* -W-VF */
#define NV1BAE_PIO_SET_STATE                                    0x00000034
#define NV1BAE_PIO_SET_STATE_VALUE                              1:0
#define NV1BAE_PIO_SET_STATE_OFF                                0x00
#define NV1BAE_PIO_SET_STATE_ON                                 0x01
#define NV1BAE_PIO_SET_STATE_DSP_ON                             0x03
#define NV1BAE_PIO_SET_AC3_FIFO                                 0x00000038
#define NV1BAE_PIO_SET_AC3_FIFO_ANALOG_INDEX                    2:0
#define NV1BAE_PIO_SET_AC3_FIFO_DIGITAL_INDEX                   5:3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\memmgr.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memmgr.c
 *  Content:    Pool memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/21/00    dereks  Created.
 *
 ****************************************************************************/

#include "dsoundi.h"

// #define MEM_SIZE_CHECK

DWORD g_dwDirectSoundTestPoolMemoryUsage = 0;
DWORD g_dwDirectSoundTestPhysicalMemoryUsage = 0;
DWORD g_dwDirectSoundTestPhysicalMemorySlop = 0;
DWORD g_dwDirectSoundTestPhysicalMemoryRecovered = 0;

#ifdef TRACK_MEMORY_USAGE

//
// Allocation tracking data
//

BEGIN_DEFINE_STRUCT()
    LIST_ENTRY              leListEntry;
    LPCSTR                  pszFile;
    ULONG                   nLine;
    LPCSTR                  pszClass;
    DSOUND_ALLOCATOR_TAG    nAllocatorTag;
    ULONG                   cbSize;
    LPVOID                  pvBaseAddress;
END_DEFINE_STRUCT(DSMEMTRACK);

LIST_ENTRY g_lstDirectSoundTestMemoryTracking;

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  DirectSoundPoolAlloc
 *
 *  Description:
 *      Allocates pool memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      DWORD [in]: pool tag.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestPoolAlloc"

LPVOID 
DirectSoundTestPoolAlloc
(
    DSOUND_POOL_TAG         nPoolTag,
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{
    static const ULONG      cbLowerThreshold    = 0x20;
    static const DWORD      cbUpperThreshold    = 0xFD8;
    LPVOID                  pvBuffer;

    ASSERT(cbBuffer);

#ifdef MEM_SIZE_CHECK

#pragma TODO("Don't ship with this check turned on")
    
    if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
    {
        ASSERTMSG("Allocating an object larger than the pool threshold");
    }
    else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
    {
        ASSERTMSG("Allocating a buffer smaller than 32 bytes");
    }

#endif

    if(pvBuffer = ExAllocatePoolWithTag(cbBuffer, nPoolTag))
    {
        cbBuffer = ExQueryPoolBlockSize(pvBuffer);
        g_dwDirectSoundTestPoolMemoryUsage += cbBuffer;

        if(fZeroInit)
        {
            ZeroMemory(pvBuffer, cbBuffer);
        }
    }
    else
    {
        DPF_RESOURCE("Out of pool memory");
    }

    return pvBuffer;
}


/****************************************************************************
 *
 *  DirectSoundTestPoolFree
 *
 *  Description:
 *      Frees memory allocated with DirectSoundTestPoolAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestPoolFree"

void 
DirectSoundTestPoolFree
(
    LPVOID                  pvBuffer
)
{
    DWORD                   cbBuffer;

    ASSERT(pvBuffer);

    cbBuffer = ExQueryPoolBlockSize(pvBuffer);

    ASSERT(g_dwDirectSoundTestPoolMemoryUsage >= cbBuffer);
    g_dwDirectSoundTestPoolMemoryUsage -= cbBuffer;

    ExFreePool(pvBuffer);
}


/****************************************************************************
 *
 *  DirectSoundTestPhysicalAlloc
 *
 *  Description:
 *      Allocates physically contiguous memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      ULONG [in]: buffer alignment, in bytes.
 *      DWORD [in]: allocation flags.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: buffer pointer.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestPhysicalAlloc"

LPVOID 
DirectSoundTestPhysicalAlloc
(
    ULONG                   cbBuffer, 
    ULONG                   cbAlignment, 
    DWORD                   dwFlags,
    BOOL                    fZeroInit
)
{
    LPVOID                  pvBuffer;

    ASSERT(cbBuffer);
    ASSERT(dwFlags);
    
    if(pvBuffer = MmAllocateContiguousMemoryEx(cbBuffer, 0, 0xFFFFFFFF, cbAlignment, dwFlags))
    {
        cbBuffer = MmQueryAllocationSize(pvBuffer);
        g_dwDirectSoundTestPhysicalMemoryUsage += cbBuffer;

        if(fZeroInit)
        {
            ZeroMemory(pvBuffer, cbBuffer);
        }
    }
    else
    {
        DPF_RESOURCE("Out of contiguous memory");
    }

    return pvBuffer;
}


/****************************************************************************
 *
 *  DirectSoundTestPhysicalFree
 *
 *  Description:
 *      Frees memory allocated with DirectSoundTestPhysicalAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestPhysicalFree"

void 
DirectSoundTestPhysicalFree
(
    LPVOID                  pvBuffer
)
{
    DWORD                   cbBuffer;

    ASSERT(pvBuffer);

    cbBuffer = MmQueryAllocationSize(pvBuffer);

    ASSERT(g_dwDirectSoundTestPhysicalMemoryUsage >= cbBuffer);
    g_dwDirectSoundTestPhysicalMemoryUsage -= cbBuffer;

    MmFreeContiguousMemory(pvBuffer);
}


/****************************************************************************
 *
 *  DirectSoundTestMemAlloc
 *
 *  Description:
 *      Allocates pool memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      DWORD [in]: pool tag.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestMemAlloc"

LPVOID 
DirectSoundTestMemAlloc
(
    DSOUND_POOL_TAG         nPoolTag,
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{
    static const ULONG      cbLowerThreshold    = 0x20;
    static const DWORD      cbUpperThreshold    = 0xFD8;
    LPVOID                  pvBuffer;

    ASSERT(cbBuffer);

#ifdef MEM_SIZE_CHECK

#pragma TODO("Don't ship with this check turned on")
    
    if((DSOUND_OBJECT_POOL_TAG == nPoolTag) && (cbBuffer >= cbUpperThreshold))
    {
        ASSERTMSG("Allocating an object larger than the pool threshold");
    }
    else if((DSOUND_DATA_POOL_TAG == nPoolTag) && (cbBuffer < cbLowerThreshold))
    {
        ASSERTMSG("Allocating a buffer smaller than 32 bytes");
    }

#endif

    if(g_pDirectSoundTestSlopMemoryHeap)
    {
        if(pvBuffer = g_pDirectSoundTestSlopMemoryHeap->Alloc(cbBuffer))
        {
            ASSERT(DSOUND_ALLOCATOR_SLOP == *((LPDWORD)pvBuffer - 1));

            if(fZeroInit)
            {
                ZeroMemory(pvBuffer, cbBuffer);
            }
        }
    }
    else
    {
        pvBuffer = NULL;
    }

    if(!pvBuffer)
    {
        if(pvBuffer = DirectSoundTestPoolAlloc(nPoolTag, cbBuffer + sizeof(DWORD), fZeroInit))
        {
            *(LPDWORD)pvBuffer = DSOUND_ALLOCATOR_POOL;
            pvBuffer = (LPDWORD)pvBuffer + 1;
        }
    }

    return pvBuffer;
}

#endif // ENABLE_SLOP_MEMORY_RECOVERY


/****************************************************************************
 *
 *  DirectSoundTestMemFree
 *
 *  Description:
 *      Frees memory allocated with DirectSoundTestMemAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestMemFree"

void 
DirectSoundTestMemFree
(
    LPVOID                  pvBuffer
)
{
    LPDWORD                 pdwSignature;
    DWORD                   cbBuffer;

    ASSERT(pvBuffer);

    pdwSignature = (LPDWORD)pvBuffer - 1;
    
    if(DSOUND_ALLOCATOR_POOL == *pdwSignature)
    {
        DirectSoundTestPoolFree(pdwSignature);
    }
    else if(DSOUND_ALLOCATOR_SLOP == *pdwSignature)
    {
        if(g_pDirectSoundTestSlopMemoryHeap)
        {
            g_pDirectSoundTestSlopMemoryHeap->Free(pvBuffer);
        }
        else
        {
            ASSERTMSG("Slop memory heap does not exist");
        }
    }
    else
    {
        ASSERTMSG("Invalid memory free");
    }
}

#endif // ENABLE_SLOP_MEMORY_RECOVERY

#ifdef DEBUG

/****************************************************************************
 *
 *  DirectSoundTestTrackAlloc
 *
 *  Description:
 *      Completes a memory tracking operation by adding the allocation to
 *      the list and fixing up the base pointer.
 *
 *  Arguments:
 *      LPVOID [in]: allocation base address.
 *      LPCSTR [in]: file the allocation comes from.
 *      ULONG [in]: line number the allocation comes from.
 *      LPCSTR [in]: class being allocated.
 *      DWORD [in]: allocator tag.
 *      ULONG [in]: size of allocation.
 *
 *  Returns:  
 *      LPVOID: allocation base address.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestTrackAlloc"

LPVOID
DirectSoundTestTrackAlloc
(
    LPVOID                  pvBaseAddress,
    ULONG                   cbTracking,
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    DSOUND_ALLOCATOR_TAG    nAllocatorTag,
    ULONG                   cbSize
)
{
    LPDSMEMTRACK            pTracking;
    
    ASSERT(pvBaseAddress);
    ASSERT(cbTracking >= sizeof(*pTracking));
    ASSERT(cbSize);
    
    //
    // Because of alignment issues, the base address may be incremented more
    // than sizeof(DSMEMTRACK).  For this reason, we store the tracking data
    // directly behind the allocation, but allocate more than cbSize +
    // sizeof(DSMEMTRACK).
    //

    pTracking = (LPDSMEMTRACK)((LPBYTE)pvBaseAddress + cbTracking - sizeof(*pTracking));

    //
    // Create the tracking info
    //

    pTracking->pszFile = pszFile;
    pTracking->nLine = nLine;
    pTracking->pszClass = pszClass;
    pTracking->nAllocatorTag = nAllocatorTag;
    pTracking->cbSize = cbSize;
    pTracking->pvBaseAddress = pvBaseAddress;

    //
    // Raise IRQL for synchronization
    //

    AutoIrql();

    //
    // Add the allocation to the list
    //

    if(!g_lstDirectSoundTestMemoryTracking.Flink && !g_lstDirectSoundTestMemoryTracking.Blink)
    {
        InitializeListHead(&g_lstDirectSoundTestMemoryTracking);
    }
    
    InsertTailListUninit(&g_lstDirectSoundTestMemoryTracking, &pTracking->leListEntry);

    //
    // Fix up the base address
    //

    return pTracking + 1;
}


/****************************************************************************
 *
 *  DirectSoundTestForgetAlloc
 *
 *  Description:
 *      Removes a tracked allocation from the list.
 *
 *  Arguments:
 *      LPVOID [in]: allocation base address.
 *      DSOUND_ALLOCATOR_TAG [in]: allocator tag.
 *
 *  Returns:  
 *      LPVOID: allocation base address.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestForgetAlloc"

LPVOID
DirectSoundTestForgetAlloc
(
    LPVOID                  pvBaseAddress,
    DSOUND_ALLOCATOR_TAG    nAllocatorTag
)
{
    LPDSMEMTRACK            pTracking   = (LPDSMEMTRACK)pvBaseAddress - 1;

    ASSERT(pvBaseAddress);

    //
    // Assert that the tag matches what we expect
    //

    ASSERT(nAllocatorTag == pTracking->nAllocatorTag);
    
    //
    // Raise IRQL for synchronization
    //

    AutoIrql();

    //
    // Remove the allocation from the list
    //

    RemoveEntryList(&pTracking->leListEntry);

    //
    // Return the proper base address
    //

    return pTracking->pvBaseAddress;
}


/****************************************************************************
 *
 *  DirectSoundTestTrackingPoolAlloc
 *
 *  Description:
 *      Allocates pool memory.
 *
 *  Arguments:
 *      LPCSTR [in]: file the allocation comes from.
 *      ULONG [in]: line number the allocation comes from.
 *      LPCSTR [in]: class being allocated.
 *      ULONG [in]: buffer size, in bytes.
 *      DWORD [in]: pool tag.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestTrackingPoolAlloc"

LPVOID 
DirectSoundTestTrackingPoolAlloc
(
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    DSOUND_POOL_TAG         nPoolTag,
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{
    static const ULONG      cbTracking  = PAGE_SIZE;
    LPVOID                  pvBuffer;
    
    //
    // Do the actual allocation
    //
    
    if(pvBuffer = DirectSoundTestPoolAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))
    {
        //
        // Complete the tracking
        //

        pvBuffer = DirectSoundTestTrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_POOL, cbBuffer);
    }

    return pvBuffer;
}


/****************************************************************************
 *
 *  DirectSoundTestTrackingPoolFree
 *
 *  Description:
 *      Frees memory allocated with DirectSoundTestTrackingPoolAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestTrackingPoolFree"

void 
DirectSoundTestTrackingPoolFree
(
    LPVOID                  pvBuffer
)
{
    //
    // Free tracking information
    //

    pvBuffer = DirectSoundTestForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_POOL);

    //
    // Free memory
    //

    DirectSoundTestPoolFree(pvBuffer);
}


/****************************************************************************
 *
 *  DirectSoundTestTrackingPhysicalAlloc
 *
 *  Description:
 *      Allocates physically contiguous memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      ULONG [in]: buffer alignment, in bytes.
 *      DWORD [in]: allocation flags.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: buffer pointer.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestTrackingPhysicalAlloc"

LPVOID 
DirectSoundTestTrackingPhysicalAlloc
(
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    ULONG                   cbBuffer, 
    ULONG                   cbAlignment, 
    DWORD                   dwFlags,
    BOOL                    fZeroInit
)
{
    ULONG                   cbTracking;
    LPVOID                  pvBuffer;

    //
    // Make sure we allocate enough information for the tracking data
    //

    if(cbAlignment >= sizeof(DSMEMTRACK))
    {
        cbTracking = cbAlignment;
    }
    else
    {
        cbTracking = BLOCKALIGNPAD(sizeof(DSMEMTRACK), cbAlignment);
    }
    
    //
    // Do the actual allocation
    //
    
    if(pvBuffer = DirectSoundTestPhysicalAlloc(cbBuffer + cbTracking, cbAlignment, dwFlags, fZeroInit))
    {
        //
        // Complete the tracking
        //

        pvBuffer = DirectSoundTestTrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_PHYS, cbBuffer);
    }

    return pvBuffer;
}


/****************************************************************************
 *
 *  DirectSoundTestTrackingPhysicalFree
 *
 *  Description:
 *      Frees memory allocated with DirectSoundTestTrackingPhysicalAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestTrackingPhysicalFree"

void 
DirectSoundTestTrackingPhysicalFree
(
    LPVOID                  pvBuffer
)
{
    //
    // Free tracking information
    //

    pvBuffer = DirectSoundTestForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_PHYS);

    //
    // Free memory
    //

    DirectSoundTestPhysicalFree(pvBuffer);
}


/****************************************************************************
 *
 *  DirectSoundTestTrackingMemAlloc
 *
 *  Description:
 *      Allocates pool memory.
 *
 *  Arguments:
 *      ULONG [in]: buffer size, in bytes.
 *      DWORD [in]: pool tag.
 *      BOOL [in]: TRUE to zero-initialize the buffer data.
 *
 *  Returns:  
 *      LPVOID: allocation.
 *
 ****************************************************************************/

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestTrackingMemAlloc"

LPVOID 
DirectSoundTestTrackingMemAlloc
(
    LPCSTR                  pszFile,
    ULONG                   nLine,
    LPCSTR                  pszClass,
    DSOUND_POOL_TAG         nPoolTag,
    ULONG                   cbBuffer,
    BOOL                    fZeroInit
)
{
    static const ULONG      cbTracking  = sizeof(DSMEMTRACK);
    LPVOID                  pvBuffer;
    
    //
    // Do the actual allocation
    //
    
    if(pvBuffer = DirectSoundTestMemAlloc(nPoolTag, cbBuffer + cbTracking, fZeroInit))
    {
        //
        // Complete the tracking
        //

        pvBuffer = DirectSoundTestTrackAlloc(pvBuffer, cbTracking, pszFile, nLine, pszClass, DSOUND_ALLOCATOR_SLOP, cbBuffer);
    }

    return pvBuffer;
}

#endif // ENABLE_SLOP_MEMORY_RECOVERY


/****************************************************************************
 *
 *  DirectSoundTestTrackingMemFree
 *
 *  Description:
 *      Frees memory allocated with DirectSoundTestTrackingMemAlloc.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestTrackingMemFree"

void 
DirectSoundTestTrackingMemFree
(
    LPVOID                  pvBuffer
)
{
    //
    // Free tracking information
    //

    pvBuffer = DirectSoundTestForgetAlloc(pvBuffer, DSOUND_ALLOCATOR_SLOP);

    //
    // Free memory
    //

    DirectSoundTestMemFree(pvBuffer);
}

#endif // ENABLE_SLOP_MEMORY_RECOVERY

#endif // TRACK_MEMORY_USAGE


/****************************************************************************
 *
 *  DirectSoundTestDumpMemoryUsage
 *
 *  Description:
 *      Dumps current memory usage to the debugger.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to assert that there is no memory allocated.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundTestDumpMemoryUsage"

void
DirectSoundTestDumpMemoryUsage
(
    BOOL                    fAssertNone
)
{

#ifdef DEBUG

    static const LPCSTR     pszBanner           = "------------------------------------------------------------------------------";

#ifdef TRACK_MEMORY_USAGE

    PLIST_ENTRY             pleEntry;
    LPDSMEMTRACK            pTracking;

#endif // TRACK_MEMORY_USAGE

    DwDbgSetContext(DPRINTF_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
    DwDbgPrint(pszBanner);
    DwDbgPrint("Begin memory usage dump");
    DwDbgPrint(pszBanner);
    
#ifdef TRACK_MEMORY_USAGE

    //
    // Raise IRQL for synchronization
    //

    AutoIrql();
   
    //
    // Show specifically what allocations are remaining
    //
    
    if(g_lstDirectSoundTestMemoryTracking.Flink)
    {
        if(!IsListEmpty(&g_lstDirectSoundTestMemoryTracking))
        {
            for(pleEntry = g_lstDirectSoundTestMemoryTracking.Flink; pleEntry != &g_lstDirectSoundTestMemoryTracking; pleEntry = pleEntry->Flink)
            {
                AssertValidEntryList(pleEntry, ASSERT_IN_LIST);
            
                pTracking = CONTAINING_RECORD(pleEntry, DSMEMTRACK, leListEntry);

                DwDbgSetContext(DPRINTF_FILELINE, DPFLVL_ABSOLUTE, pTracking->pszFile, pTracking->nLine, DPF_FNAME, DPF_LIBRARY);
                DwDbgPrint("%x (%lu bytes, type %s)", pTracking + 1, pTracking->cbSize, pTracking->pszClass);
            }

            DwDbgSetContext(DPRINTF_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
            DwDbgPrint(pszBanner);
        }
    }

#endif // TRACK_MEMORY_USAGE

    DwDbgSetContext(DPRINTF_LIBRARY, DPFLVL_ABSOLUTE, NULL, 0, DPF_FNAME, DPF_LIBRARY);
    DwDbgPrint("Pool memory used:  %lu", g_dwDirectSoundTestPoolMemoryUsage);
    DwDbgPrint("Physical memory used:  %lu", g_dwDirectSoundTestPhysicalMemoryUsage);
    DwDbgPrint("Physical memory available for recovery:  %lu", g_dwDirectSoundTestPhysicalMemorySlop);
    DwDbgPrint("Physical memory recovered:  %lu", g_dwDirectSoundTestPhysicalMemoryRecovered);
    DwDbgPrint(pszBanner);
    DwDbgPrint("End memory usage dump");
    DwDbgPrint(pszBanner);

    if(g_dwDirectSoundTestPoolMemoryUsage || g_dwDirectSoundTestPhysicalMemoryUsage || g_dwDirectSoundTestPhysicalMemorySlop || g_dwDirectSoundTestPhysicalMemoryRecovered)
    {
        if(fAssertNone)
        {
            __asm int 3
        }

#ifdef TRACK_MEMORY_USAGE

        ASSERT(!IsListEmpty(&g_lstDirectSoundTestMemoryTracking));

#endif // TRACK_MEMORY_USAGE

    }

#ifdef TRACK_MEMORY_USAGE

    else
    {
        ASSERT(IsListEmpty(&g_lstDirectSoundTestMemoryTracking));
    }

#endif // TRACK_MEMORY_USAGE

#endif // DEBUG

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\mcpxcore.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpxcore.cpp
 *  Content:    MCP-X core object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/24/01    dereks  Separated from APU object for kernel ROM bring-up.
 *
 ****************************************************************************/

#include "dsoundi.h"

/****************************************************************************
 *
 *  CMcpxCoreTest
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::CMcpxCoreTest"

const DWORD CMcpxCoreTest::m_adwGPOutputBufferSizes[MCPX_GPOUTPUT_COUNT] =
{
    0x2000  // MCPX_GPOUTPUT_BOOT_SOUND
};

const DWORD CMcpxCoreTest::m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_COUNT] =
{
    0x2000, // MCPX_EPOUTPUT_AC97_ANALOG
    0x4000  // MCPX_EPOUTPUT_AC97_DIGITAL
};

MCPX_ALLOC_CONTEXT CMcpxCoreTest::m_ctxMemory[MCPX_MEM_COUNT];

CMcpxCoreTest::CMcpxCoreTest
(
    CDirectSoundTestSettings *  pSettings
)
{
    DPF_ENTER();

    m_pSettings = ADDREF(pSettings);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  ~CMcpxCoreTest
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::~CMcpxCoreTest"

CMcpxCoreTest::~CMcpxCoreTest
(
    void
)
{
    DWORD                   i;

    DPF_ENTER();

#ifdef MCPX_BOOT_LIB

    Reset();

#else // MCPX_BOOT_LIB

    //
    // We're assuming the derived object already called Reset
    //

#endif // MCPX_BOOT_LIB

    //
    // Free the DSP managers
    //

    DELETE(m_pGpDspManager);

#ifndef MCPX_BOOT_LIB

    DELETE(m_pEpDspManager);

#endif // MCPX_BOOT_LIB

    //
    // Free APU memory
    //

    for(i = 0; i < MCPX_MEM_COUNT; i++)
    {

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

        if(m_ctxMemory[i].fOwned)

#endif // ENABLE_SLOP_MEMORY_RECOVERY

        {
            PHYSFREE(m_ctxMemory[i].VirtualAddress);
        }

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

        else
        {
            m_ctxMemory[i].VirtualAddress = NULL;
        }

#endif // ENABLE_SLOP_MEMORY_RECOVERY

        m_ctxMemory[i].PhysicalAddress = 0;
        m_ctxMemory[i].Size = 0;
    }

    //
    // Release object references
    //

    RELEASE(m_pSettings);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

    RELEASE(m_pSlopMemoryHeap);

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Intializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::Initialize"

HRESULT 
CMcpxCoreTest::Initialize
(
    void
)
{
    HRESULT                 hr;

    DPF_ENTER();

    //
    // Make sure we're in a known good state
    //
    
    Reset();

    //
    // Allocate memory
    //

    hr = AllocateApuMemory();

    //
    // Set up the front-end and voice processor
    //

    if(SUCCEEDED(hr))
    {
        SetupFrontEndProcessor();
        SetupVoiceProcessor();
    }

    //
    // Set up the AC97
    //

    if(SUCCEEDED(hr))
    {
        hr = SetupAc97();
    }

    //
    // Set up the DSPs
    //

    if(SUCCEEDED(hr)) 
    {
        SetupDSPs();
    }    

    //
    // Set up the APU/ACI link
    //

    if(SUCCEEDED(hr))
    {
        SetSetupEngineState(MCPX_SE_STATE_AC_SYNC);
    }

    //
    // Start the ACI channels running
    //

    if(SUCCEEDED(hr))
    {       
        m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Run();
        m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Run();
    }

    DPF_LEAVE_HRESULT(hr);

	return hr;
}


/****************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Resets the APU state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to only do a partial reset.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::Reset"

void
CMcpxCoreTest::Reset
(
    void
)
{
    DPF_ENTER();

    //
    // Shut down the AC'97
    //

    m_Ac97.Terminate();

    //
    // Shut down the APU components
    //

    IdleVoiceProcessor(TRUE);
    SetInterruptState(FALSE);
    SetPrivLockState(TRUE);
    SetFrontEndState(MCPX_FE_STATE_HALTED);
    SetSetupEngineState(MCPX_SE_STATE_OFF);

    MCPX_REG_WRITE(NV_PAPU_TVL2D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_TVL3D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_TVLMP, 0xFFFF);

    MCPX_REG_WRITE(NV_PAPU_CVL2D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_CVL3D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_CVLMP, 0xFFFF);

    MCPX_REG_WRITE(NV_PAPU_NVL2D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_NVL3D, 0xFFFF);
    MCPX_REG_WRITE(NV_PAPU_NVLMP, 0xFFFF);

    MCPX_REG_WRITE(NV_PAPU_GPRST, 0);
    MCPX_REG_WRITE(NV_PAPU_EPRST, 1);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetupFrontEndProcessor
 *
 *  Description:
 *      Sets up the front-end processor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetupFrontEndProcessor"

void
CMcpxCoreTest::SetupFrontEndProcessor
(
    void
)
{
    DWORD                   dwForce[2]      = { 0, 0 };
    DWORD                   dwIgnore[2]     = { 0, 0 };
    R_INTR                  rInterruptMask;
    R_FE_CONTROL            rFeControl;
    R_SE_CONTROL            rSeControl;
    DWORD                   i;

    DPF_ENTER();

    //
    // Setup interrupt masks
    //

    rInterruptMask.uValue = 0;
    rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
    rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_ENABLED;
    rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_ENABLED;
    rInterruptMask.FETrap = NV_PAPU_IEN_FETINTEN_ENABLED;
    rInterruptMask.FENotify = NV_PAPU_IEN_FENINTEN_ENABLED;
    rInterruptMask.FEVoice = NV_PAPU_IEN_FEVINTEN_ENABLED;
    rInterruptMask.FEMethodOverFlow = NV_PAPU_IEN_FEOINTEN_ENABLED;
    rInterruptMask.GPMailbox = NV_PAPU_IEN_GPMINTEN_DISABLED;
    rInterruptMask.GPNotify = NV_PAPU_IEN_GPNINTEN_ENABLED;
    rInterruptMask.EPMailbox = NV_PAPU_IEN_EPMINTEN_DISABLED;
    rInterruptMask.EPNotify = NV_PAPU_IEN_EPNINTEN_ENABLED;

    MCPX_REG_WRITE(NV_PAPU_IEN, rInterruptMask.uValue);

    //
    // Set default FE control bits
    //

    rFeControl.uValue = 0;
    rFeControl.TrapOnNotifier = NV_PAPU_FECTL_FENINT_ENABLED;
    rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
    rFeControl.EnableLock = NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_FECTL, rFeControl.uValue);

    //
    // Set default SE control bits
    //
    
    rSeControl.uValue = 0;
    rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

    MCPX_REG_WRITE(NV_PAPU_SECTL, rSeControl.uValue);

    //
    // We're overriding the internal SE2FE_IDLE_MESSAGE because a couple
    // of things don't work the way they should.  First, the hardware has
    // a race condition that can cause voice list corruption if a VoiceOn
    // method is received with an antecedent voice that has already gone
    // idle.  Second, VoiceRelease causes a PERSIST voice to be removed
    // from the processing list when the envelope completes.  By overriding
    // SE2FE_IDLE_VOICE in software, we can address both of these issues
    //

    dwForce[1] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETFORCE1_SE2FE_IDLE_VOICE);

    MCPX_REG_WRITE(NV_PAPU_FETFORCE0, dwForce[0]);
    MCPX_REG_WRITE(NV_PAPU_FETFORCE1, dwForce[1]);

    //
    // SET_VOICE_TAR_Hrtf has a bug in it that prevents us from setting 
    // a NULL HRTF filter handle (0xFFFF).  This is strictly a parameter
    // validation bug since NULL is a valid value.
    //
    // VoiceOn will cause a BAD_LIST_POINTER trap if the VP isn't idle
    // and we use the INHERIT list type.  We're working around this in
    // CMcpxVoiceClient::ActivateVoice.
    //

    dwIgnore[0] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETIGNORE0_SET_VOICE_TAR_HRTF);
    dwIgnore[0] |= MCPX_MAKE_REG_VALUE(1, NV_PAPU_FETIGNORE0_VOICE_ON);

    MCPX_REG_WRITE(NV_PAPU_FETIGNORE0, dwIgnore[0]);
    MCPX_REG_WRITE(NV_PAPU_FETIGNORE1, dwIgnore[1]);

    //
    // Initialize global counts so we can track how far ahead the output 
    // counter stays from the input
    //

    ResetGlobalCounters();
    
    //
    // Set up boundaries
    //

    MCPX_REG_WRITE(NV_PAPU_FEMAXV, MCPX_HW_MAX_VOICES - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXTV, MCPX_HW_MAX_3D_VOICES - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXHT, MCPX_HW_MAX_3D_VOICES * MCPX_HW_3DFILTERS_PER_VOICE - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXSESSL, MCPX_HW_MAX_SSL_PRDS - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXSESGE, MCPX_HW_MAX_BUFFER_PRDS - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXMB, MCPX_HW_MAX_SUBMIX_BINS);

    MCPX_REG_WRITE(NV_PAPU_FESESSLCTXPA, 0);
    MCPX_REG_WRITE(NV_PAPU_FESESSLMAXOFF, MCPX_MAX_VALID_ADDRESS);

    MCPX_REG_WRITE(NV_PAPU_FESESGECTXPA, 0);
    MCPX_REG_WRITE(NV_PAPU_FESESGEMAXOFF, MCPX_MAX_VALID_ADDRESS);

    MCPX_REG_WRITE(NV_PAPU_FEGPSGECTXPA, 0);
    MCPX_REG_WRITE(NV_PAPU_FEGPSGEMAXOFF, MCPX_MAX_VALID_ADDRESS);

    //
    // Unlock the front end and setup engine
    //

    SetPrivLockState(FALSE);
    SetFrontEndState(MCPX_FE_STATE_FREE_RUNNING);
    SetFrontEndState(MCPX_FE_STATE_ISO);
    SetSetupEngineState(MCPX_SE_STATE_ISO);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  AllocateApuMemory
 *
 *  Description:
 *      Allocates system memory buffers ued by the APU.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::AllocateApuMemory"

HRESULT
CMcpxCoreTest::AllocateApuMemory
(
    void
)
{
    BEGIN_DEFINE_STRUCT()
        DWORD               Size;
        DWORD               Alignment;
    END_DEFINE_STRUCT(MCPX_ALLOC_CTX);

    HRESULT                 hr                      = DS_OK;
    MCPX_ALLOC_CTX          Alloc[MCPX_MEM_COUNT];
    DWORD                   i;

    DPF_ENTER();

    //
    // Calculate allocation sizes and alignment.  We piggy-back the SGE heap
    // run markers on the magic write buffer since the magic write only needs
    // a single DWORD.  When we're building the boot sound, we allocate memory
    // for the I3DL2 reverb in the GP scratch.
    //
    // WARNING: to use some of the slop memory allocated due to alignement
    // restrictions, we're piggybacking some data structures on these
    // buffers.  Use extreme care when changing any of these sizes.
    //

    for(i = 0, Alloc[MCPX_MEM_GPOUTPUT].Size = 0; i < NUMELMS(m_adwGPOutputBufferSizes); i++)
    {
        ASSERT(!(m_adwGPOutputBufferSizes[i] % PAGE_SIZE));
        Alloc[MCPX_MEM_GPOUTPUT].Size += m_adwGPOutputBufferSizes[i];
    }

    Alloc[MCPX_MEM_GPOUTPUT].Alignment = PAGE_SIZE;

    for(i = 0, Alloc[MCPX_MEM_EPOUTPUT].Size = 0; i < NUMELMS(m_adwEPOutputBufferSizes); i++)
    {
        ASSERT(!(m_adwEPOutputBufferSizes[i] % PAGE_SIZE));
        Alloc[MCPX_MEM_EPOUTPUT].Size += m_adwEPOutputBufferSizes[i];
    }

    Alloc[MCPX_MEM_EPOUTPUT].Alignment = PAGE_SIZE;

    Alloc[MCPX_MEM_MAGICWRITE].Size = sizeof(DWORD);
    Alloc[MCPX_MEM_MAGICWRITE].Alignment = PAGE_SIZE;

    Alloc[MCPX_MEM_VOICE].Size = MCPX_HW_MAX_VOICES * NV_PAVS_SIZE;
    Alloc[MCPX_MEM_VOICE].Alignment = 0x8000;

    Alloc[MCPX_MEM_NOTIFIERS].Size = sizeof(MCPX_HW_NOTIFICATION) * MCPX_HW_MAX_NOTIFIERS;
    Alloc[MCPX_MEM_NOTIFIERS].Alignment = 0x4000;

    Alloc[MCPX_MEM_INPUTSGE].Size = MCPX_HW_MAX_BUFFER_PRDS * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_INPUTSGE].Alignment = 0x4000;

    Alloc[MCPX_MEM_INPUTPRD].Size = MCPX_HW_MAX_SSL_PRDS * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_INPUTPRD].Alignment = 0x4000;

    Alloc[MCPX_MEM_HRTFTARGET].Size = MCPX_HW_MAX_3D_VOICES * MCPX_HW_3DFILTERS_PER_VOICE * NV_PAHRTFT_SIZE;
    Alloc[MCPX_MEM_HRTFTARGET].Alignment = 0x4000;

    Alloc[MCPX_MEM_HRTFCURRENT].Size = MCPX_HW_MAX_3D_VOICES * NV_PAHRTFC_SIZE;
    Alloc[MCPX_MEM_HRTFCURRENT].Alignment = 0x4000;

    Alloc[MCPX_MEM_GPOUTPUTSGE].Size = Alloc[MCPX_MEM_GPOUTPUT].Size / PAGE_SIZE * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_GPOUTPUTSGE].Alignment = 0x4000;

    Alloc[MCPX_MEM_EPOUTPUTSGE].Size = Alloc[MCPX_MEM_EPOUTPUT].Size / PAGE_SIZE * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_EPOUTPUTSGE].Alignment = 0x4000;

    Alloc[MCPX_MEM_GPMULTIPASS].Size = MCPX_HW_MULTIPASS_NUM_PAGES * PAGE_SIZE;
    Alloc[MCPX_MEM_GPMULTIPASS].Alignment = 0x4000;

    Alloc[MCPX_MEM_GPSCRATCH].Size = ((MCPX_HW_MULTIPASS_NUM_PAGES + MCPX_HW_AC3_NUM_INPUT_PAGES) * PAGE_SIZE) + MCPX_GLOBAL_PROC_SCRATCH_SIZE;
    Alloc[MCPX_MEM_GPSCRATCH].Alignment = 0x4000;

#ifdef MCPX_BOOT_LIB
         
    Alloc[MCPX_MEM_GPSCRATCH].Size += 0x600000;

#endif // MCPX_BOOT_LIB

    Alloc[MCPX_MEM_GPSCRATCHSGE].Size = (MCPX_HW_MAX_FX_SCRATCH_PAGES + (Alloc[MCPX_MEM_GPSCRATCH].Size / PAGE_SIZE)) * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_GPSCRATCHSGE].Alignment = 0x4000;

    Alloc[MCPX_MEM_EPSCRATCH].Size = ((CMcpxEPDspManagerTest::AC3GetTotalScratchSize() / PAGE_SIZE) + 1 + MCPX_HW_AC3_NUM_INPUT_PAGES) * PAGE_SIZE;
    Alloc[MCPX_MEM_EPSCRATCH].Alignment = 0x4000;

    Alloc[MCPX_MEM_EPSCRATCHSGE].Size = Alloc[MCPX_MEM_EPSCRATCH].Size / PAGE_SIZE * NV_PSGE_SIZE;
    Alloc[MCPX_MEM_EPSCRATCHSGE].Alignment = 0x4000;

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

    //
    // Allocate the heap to track unused physical memory so we can reuse it
    // later
    //

    if(g_pDirectSoundTestSlopMemoryHeap)
    {
        m_pSlopMemoryHeap = ADDREF(g_pDirectSoundTestSlopMemoryHeap);
    }
    else
    {
        hr = HRFROMP(m_pSlopMemoryHeap = NEW(CMcpxSlopMemoryHeapTest));
    }

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    //
    // Allocate APU memory
    //

    for(i = 0; (i < NUMELMS(Alloc)) && SUCCEEDED(hr); i++)
    {
        m_ctxMemory[i].Size = Alloc[i].Size;
        
        hr = AllocateContext(&m_ctxMemory[i], Alloc[i].Alignment, PAGE_READWRITE);

#ifdef ENABLE_SLOP_MEMORY_RECOVERY

        if(SUCCEEDED(hr))
        {
            m_ctxMemory[i].fOwned = !m_pSlopMemoryHeap->AddRun(m_ctxMemory[i].VirtualAddress, BLOCKALIGNPAD(m_ctxMemory[i].Size, PAGE_SIZE), m_ctxMemory[i].Size);
        }

#endif // ENABLE_SLOP_MEMORY_RECOVERY

    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  SetupVoiceProcessor
 *
 *  Description:
 *      Sets up the voice processor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetupVoiceProcessor"

void 
CMcpxCoreTest::SetupVoiceProcessor
(
    void
)
{
    DWORD                   dwHrtfMixBins;
    DWORD                   i;

    DPF_ENTER();
    MCPX_CHECK_VOICE_FIFO_INIT(8);

    //
    // Set up the HW voice data structures to point to themselves
    //

    for(i = 0; i < MCPX_HW_MAX_VOICES; i++) 
    {
        MCPX_VOICE_STRUCT_WRITE(i, NV_PAVS_VOICE_TAR_PITCH_LINK, MCPX_MAKE_REG_VALUE(i, NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE));
    }

    //
    // Program the DMA PRD/SGE lists base addresses
    //

    MCPX_REG_WRITE(NV_PAPU_VPVADDR, m_ctxMemory[MCPX_MEM_VOICE].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_VPHTADDR, m_ctxMemory[MCPX_MEM_HRTFTARGET].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_VPHCADDR, m_ctxMemory[MCPX_MEM_HRTFCURRENT].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_VPSGEADDR, m_ctxMemory[MCPX_MEM_INPUTSGE].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_VPSSLADDR, m_ctxMemory[MCPX_MEM_INPUTPRD].PhysicalAddress);
    MCPX_REG_WRITE(NV_PAPU_FENADDR, m_ctxMemory[MCPX_MEM_NOTIFIERS].PhysicalAddress);

    //
    // Initialize all the global tracking parameters
    //

    MCPX_VOICE_WRITE(SetPitchTracking, MCPX_HW_DEFAULT_TRACKING);
    MCPX_VOICE_WRITE(SetFilterTracking, MCPX_HW_DEFAULT_TRACKING);
    MCPX_VOICE_WRITE(SetVolumeTracking, MCPX_HW_DEFAULT_TRACKING);
    MCPX_VOICE_WRITE(SetHRTFTracking, MCPX_HW_DEFAULT_TRACKING);
    MCPX_VOICE_WRITE(SetITDTracking, MCPX_HW_DEFAULT_TRACKING);

    //
    // Map the GP multipass page into the reserved SGE
    //

    MCPX_VOICE_WRITE(SetCurrentInBufSGE, MCPX_HW_MAX_BUFFER_PRDS - 1);
    MCPX_VOICE_WRITE(SetCurrentInBufSGEOffset, m_ctxMemory[MCPX_MEM_GPMULTIPASS].PhysicalAddress);

    //
    // Set 3D mixbins
    //

    dwHrtfMixBins = MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[0].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN0);
    dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[1].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN1);
    dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[2].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN2);
    dwHrtfMixBins |= MCPX_MAKE_REG_VALUE(DirectSoundRequiredMixBins_3D.lpMixBinVolumePairs[3].dwMixBin, NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN3);

    MCPX_VOICE_WRITE(SetHRTFSubmixes, dwHrtfMixBins);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetupGlobalProcessor
 *
 *  Description:
 *      Sets up the global processor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetupGlobalProcessor"

void 
CMcpxCoreTest::SetupGlobalProcessor
(
    void
)                               
{                               
    DWORD                   adwSgeCounts[MCPX_GPOUTPUT_COUNT];
    DWORD                   dwTotalSgeCount;
    DWORD                   dwSgeOffset;
    DWORD                   dwAddress;
    R_GP_RESET              rReset;
    R_GPDMA_CONFIG          rGpDmaConfig;
    R_GP_CONTROL            rControl;
    DSP_CONTROL             DspControl;
    DWORD                   dwPos;
    DWORD                   i, z;
    MCP1_PRD *              pPrd;

    DPF_ENTER();
    
    //
    // Output buffer SGE table base address for output buffers and input buffers
    //

    MCPX_REG_WRITE(NV_PAPU_GPFADDR, m_ctxMemory[MCPX_MEM_GPOUTPUTSGE].PhysicalAddress);

    //
    // Initialize the get/put pointers
    //

    MCPX_REG_WRITE(NV_PAPU_GPGET, 0);
    MCPX_REG_WRITE(NV_PAPU_GPPUT, 0);

    //
    // Tell the hw how big the output SGE array needs to be
    //

    ASSERT(!(m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress % PAGE_SIZE));
    ASSERT(!(m_ctxMemory[MCPX_MEM_GPOUTPUT].Size % PAGE_SIZE));

    dwTotalSgeCount = m_ctxMemory[MCPX_MEM_GPOUTPUT].Size / PAGE_SIZE;

    ASSERT(!(dwTotalSgeCount & 0xFFFF0000));

	MCPX_REG_WRITE(NV_PAPU_GPFMAXSGE, dwTotalSgeCount - 1);
	MCPX_REG_WRITE(NV_PAPU_FEMAXGPSGE, dwTotalSgeCount - 1);

    MCPX_REG_WRITE(NV_PAPU_GPOFBASE0, 0);
    MCPX_REG_WRITE(NV_PAPU_GPOFEND0,  m_adwGPOutputBufferSizes[0]);

    //
    // Set up the output SGEs
    //

    pPrd = (MCP1_PRD *)m_ctxMemory[MCPX_MEM_GPOUTPUTSGE].VirtualAddress;

    for(i = 0, dwSgeOffset = 0; i < MCPX_GPOUTPUT_COUNT; i++)
    {
        for(z = 0; z < m_adwGPOutputBufferSizes[i] / PAGE_SIZE; z++)
        {
            dwAddress = m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress + ((dwSgeOffset + z) * PAGE_SIZE);
            
            MCPX_CHECK_VOICE_FIFO_INIT(2);
            MCPX_VOICE_WRITE(SetCurrentOutBufSGE, dwSgeOffset + z);
            MCPX_VOICE_WRITE(SetOutBufSGEOffset, dwAddress);

            pPrd[dwSgeOffset + z].uAddr = dwAddress;
            pPrd[dwSgeOffset + z].Control.uValue = 0;
            pPrd[dwSgeOffset + z].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

        }
        
        MCPX_CHECK_VOICE_FIFO_INIT(2);
        MCPX_VOICE_WRITE(SetOutBuf[i].BA, dwSgeOffset * PAGE_SIZE);
        MCPX_VOICE_WRITE(SetOutBuf[i].Len, m_adwGPOutputBufferSizes[i]);

        dwSgeOffset += z;
    }

    //
    // Allocate the scratch space management code and GP DSP code management
    //

    if(!m_pGpDspManager)
    {
        if(!(m_pGpDspManager = NEW(CMcpxGPDspManagerTest)))
        {
            ASSERTMSG("Failed to alloc DSP and scratch classes");
        }

        m_pGpDspManager->Initialize();
    }

    //
    // Take the GP peripherals out of reset, leave DSP core in reset state
    //

    rReset.uValue = 0;
    rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
    rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
    rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
    rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_GPRST, rReset.uValue);

    //
    // Enable the GP
    //

    rControl.Idle = NV_PAPU_GPIDRDY_GPSETIDLE_SET;
    rControl.IntrNotify = NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET;

    MCPX_REG_WRITE(NV_PAPU_GPIDRDY, rControl.uValue);

    //
    // Clear the interrupt status
    //

    MCPX_REG_WRITE(NV_PAPU_GPISTS, 0xFF);

    //
    // Reset the FIFO positions
    //

    MCPX_REG_READ(NV_PAPU_GPOFBASE0, &dwPos);
    MCPX_REG_WRITE(NV_PAPU_GPOFCUR0, dwPos);

    MCPX_REG_READ(NV_PAPU_GPOFBASE1, &dwPos);
    MCPX_REG_WRITE(NV_PAPU_GPOFCUR1, dwPos);

    MCPX_REG_READ(NV_PAPU_GPOFBASE2, &dwPos);
    MCPX_REG_WRITE(NV_PAPU_GPOFCUR2, dwPos);

    MCPX_REG_READ(NV_PAPU_GPOFBASE3, &dwPos);
    MCPX_REG_WRITE(NV_PAPU_GPOFCUR3, dwPos);

    //
    // Now take DSP core out of reset as well
    //

    rReset.DSP = NV_PAPU_GPRST_GPDSPRST_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_GPRST, rReset.uValue);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetupEncodeProcessor
 *
 *  Description:
 *      Sets up the encode processor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#ifndef MCPX_BOOT_LIB

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetupEncodeProcessor"

void 
CMcpxCoreTest::SetupEncodeProcessor
(
    void
)
{
    DWORD                   dwTotalSgeCount;
    DWORD                   dwSgeOffset;
    DWORD                   dwAddress;
    R_GP_RESET              rReset;
    R_GP_CONTROL            rControl;
    MCP1_PRD *              pPrd;
    R_GPDMA_CONFIG          rConfig;
    DOLBY_CONFIG_TABLE *    pTable;
    BOOL                    fInitial;
    DWORD                   i, z;

    DPF_ENTER();

    //
    // take EP out of reset, but leave DSP core in reset
    //

    rReset.uValue = 0;
    rReset.Global = NV_PAPU_EPRST_EPRST_DISABLED;
    rReset.DSP = NV_PAPU_EPRST_EPDSPRST_ENABLED;
    rReset.NMI = NV_PAPU_EPRST_EPNMI_DISABLED;
    rReset.Abort = NV_PAPU_EPRST_EPABORT_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_EPRST, rReset.uValue);

    //
    // setup the scratch space management and dsp download 
    //

    if(fInitial = !m_pEpDspManager)
    {
        if(!(m_pEpDspManager = NEW(CMcpxEPDspManagerTest))) 
        {
            ASSERTMSG("Failed to alloc Dsp and scratch classes");
        }

        m_pEpDspManager->Initialize(m_pGpDspManager);
    }
    
    //
    // Output buffer SGE table base address for output buffers
    //

    MCPX_REG_WRITE(NV_PAPU_EPFADDR, m_ctxMemory[MCPX_MEM_EPOUTPUTSGE].PhysicalAddress);

    //
    // Initialize the get/put pointers
    //

    MCPX_REG_WRITE(NV_PAPU_EPGET, 0);
    MCPX_REG_WRITE(NV_PAPU_EPPUT, 0);

    //
    // Tell the hw how big the output SGE array needs to be
    //

    dwTotalSgeCount = m_ctxMemory[MCPX_MEM_EPOUTPUT].Size / PAGE_SIZE;

    ASSERT(!(dwTotalSgeCount & 0xFFFF0000));
	MCPX_REG_WRITE(NV_PAPU_EPFMAXSGE, dwTotalSgeCount - 1);

    //
    // Set up the actual PRDs (aka SGEs) in the hardware-owned PRD table
    //

    pPrd = (MCP1_PRD *)m_ctxMemory[MCPX_MEM_EPOUTPUTSGE].VirtualAddress;

    for(i = 0, dwSgeOffset = 0; i < MCPX_EPOUTPUT_COUNT; i++)
    {
        for(z = 0; z < m_adwEPOutputBufferSizes[i] / PAGE_SIZE; z++)
        {
            dwAddress = m_ctxMemory[MCPX_MEM_EPOUTPUT].PhysicalAddress + ((dwSgeOffset + z) * PAGE_SIZE);
            
            pPrd[dwSgeOffset + z].uAddr = dwAddress;
            pPrd[dwSgeOffset + z].Control.uValue = 0;
            pPrd[dwSgeOffset + z].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;
        }
        
        MCPX_REG_WRITE(NV_PAPU_EPOFBASE0 + (0x10 * i), dwSgeOffset * PAGE_SIZE);
        MCPX_REG_WRITE(NV_PAPU_EPOFEND0 + (0x10 * i), dwSgeOffset * PAGE_SIZE + m_adwEPOutputBufferSizes[i]); 

        dwSgeOffset += z;
    }

    if(fInitial)
    {
        //
        // update the DSP dolby code loader table with the output buffer offsets
        //

        m_pEpDspManager->AC3SetAnalogOutput(MCPX_EPOUTPUT_AC97_ANALOG, m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_ANALOG]);

        //
        // Now the digital fifo. Its base offset is right after the analog FIFO
        // update the loader table
        //

        m_pEpDspManager->AC3SetDigitalOutput(MCPX_EPOUTPUT_AC97_DIGITAL, m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_DIGITAL]);

        //
        // add the pages used for multipass buffer output from the GP, into the GP scratch
        // we do this here since the EpDspManager->Initialize() needs to run first and add 
        // its AC3 pages at the end of scratch first. It needs to happen in this order
        //

        m_pGpDspManager->SetMultipassBuffer(&m_ctxMemory[MCPX_MEM_GPMULTIPASS], MCPX_HW_MULTIPASS_NUM_PAGES);   

        //
        // based on the speaker config, setup the dolby DSP code to do the right thing
        //

        if(!DSSPEAKER_IS_SURROUND(m_pSettings->m_dwSpeakerConfig))
        {
            pTable = m_pEpDspManager->GetDolbyConfigTable();

            pTable->do_surround_encode = FALSE;
            pTable->do_game_encode = FALSE;

            if(DSSPEAKER_BASIC(m_pSettings->m_dwSpeakerConfig) == DSSPEAKER_MONO) 
            {
                pTable->do_downmix_encode = 1;
            } 
            else 
            {
                pTable->do_downmix_encode = 2;
            }
        }
    }

    //
    // setup cfg reg
    //

    MCPX_REG_WRITE(NV_PAPU_EPDCFG, 0);

    //
    // setup RDY reg
    //

    rControl.uValue = 0;
    rControl.Idle = NV_PAPU_EPIDRDY_EPSETIDLE_SET;
    rControl.IntrNotify = NV_PAPU_EPIDRDY_EPSETNINT_NOT_SET;

    MCPX_REG_WRITE(NV_PAPU_EPIDRDY, rControl.uValue);
    
    //
    // clear the EPISTS bit
    //

    MCPX_REG_WRITE(NV_PAPU_EPISTS, 0xFFFFFFFF);

    //
    // turn EP dsp core on..
    // BUGBUG nvidia writes a 0x1 as the last thing to turn on the EP (??)
    //

    rReset.DSP = NV_PAPU_EPRST_EPDSPRST_DISABLED;
    MCPX_REG_WRITE(NV_PAPU_EPRST,rReset.uValue);

    DPF_LEAVE_VOID();
}

#endif // MCPX_BOOT_LIB


/****************************************************************************
 *
 *  SetupAc97
 *
 *  Description:
 *      Sets up the AC97.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetupAc97"

HRESULT
CMcpxCoreTest::SetupAc97
(
    void
)
{
    HRESULT                 hr              = DS_OK;
    DWORD                   dwBufferAddress;
    LPCDWORD                adwBufferSizes;
    DWORD                   i;

    DPF_ENTER();

#ifndef MCPX_BOOT_LIB

    dwBufferAddress = m_ctxMemory[MCPX_MEM_EPOUTPUT].PhysicalAddress;
    adwBufferSizes = m_adwEPOutputBufferSizes;

#else

    dwBufferAddress = m_ctxMemory[MCPX_MEM_GPOUTPUT].PhysicalAddress;
    adwBufferSizes = m_adwGPOutputBufferSizes;

#endif // MCPX_BOOT_LIB

    //
    // Initialize the AC97
    //

    hr = m_Ac97.Initialize(AC97_OBJECTF_DIRECTISR);

    //
    // Create AC97 output channels.  If Dolby Digital isn't turned on in the
    // speaker config, both the analog and digital channels will read from
    // the analog buffer.
    //

    if(SUCCEEDED(hr))
    {
        hr = m_Ac97.CreateChannel(AC97_CHANNELTYPE_ANALOG);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        m_Ac97.m_apChannels[AC97_CHANNELTYPE_ANALOG]->AttachPacket(dwBufferAddress, adwBufferSizes[AC97_CHANNELTYPE_ANALOG]);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_Ac97.CreateChannel(AC97_CHANNELTYPE_DIGITAL);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->Initialize();
    }

    if(SUCCEEDED(hr))
    {

#ifndef MCPX_BOOT_LIB

        if(DSSPEAKER_IS_AC3(m_pSettings->m_dwSpeakerConfig))
        {
            m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->AttachPacket(dwBufferAddress + adwBufferSizes[AC97_CHANNELTYPE_ANALOG], adwBufferSizes[AC97_CHANNELTYPE_DIGITAL]);
            m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->SetMode(DSAC97_MODE_ENCODED);
        }
        else

#endif // MCPX_BOOT_LIB

        {
            m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->AttachPacket(dwBufferAddress, adwBufferSizes[AC97_CHANNELTYPE_ANALOG]);
            m_Ac97.m_apChannels[AC97_CHANNELTYPE_DIGITAL]->SetMode(DSAC97_MODE_PCM);
        }
    }

    DPF_LEAVE_HRESULT(hr);

	return hr;
}


/****************************************************************************
 *
 *  SetInterruptState
 *
 *  Description:
 *      Sets the APU interrupt state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable interrupts, FALSE to disable.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetInterruptState"

void 
CMcpxCoreTest::SetInterruptState
(
    BOOL                    fEnabled
)
{
    R_INTR                  rInterruptMask;

    DPF_ENTER();
    AutoIrql();

    MCPX_REG_READ(NV_PAPU_IEN, &rInterruptMask.uValue);

    rInterruptMask.General = fEnabled ? NV_PAPU_IEN_GINTEN_ENABLED : NV_PAPU_IEN_GINTEN_DISABLED;

    MCPX_REG_WRITE(NV_PAPU_IEN, rInterruptMask.uValue);

    // DPF_BLAB("Interrupts %s", fEnabled ? "enabled" : "disabled");

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetPrivLockState
 *
 *  Description:
 *      Sets the APU priv lock (?) state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to lock, FALSE to unlock.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetPrivLockState"

void 
CMcpxCoreTest::SetPrivLockState
(
    BOOL                    fLocked
)
{
    DWORD                   dwPrivLock;

    DPF_ENTER();
    AutoIrql();

    MCPX_REG_READ(NV_PAPU_FEPRIVLOCK, &dwPrivLock);

    dwPrivLock = MCPX_SET_REG_VALUE(dwPrivLock, fLocked ? NV_PAPU_FEPRIVLOCK_VALUE_LOCKED : NV_PAPU_FEPRIVLOCK_VALUE_UNLOCKED, NV_PAPU_FEPRIVLOCK_VALUE);

    MCPX_REG_WRITE(NV_PAPU_FEPRIVLOCK, dwPrivLock);

    // DPF_BLAB("Priv lock %s", fLocked ? "locked" : "unlocked");

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetFrontEndState
 *
 *  Description:
 *      Sets the front-end state.
 *
 *  Arguments:
 *      MCPX_FE_STATE [in]: state.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetFrontEndState"

void 
CMcpxCoreTest::SetFrontEndState
(
    MCPX_FE_STATE           nState
)
{
    R_FE_CONTROL            rFeControl;

    DPF_ENTER();
    AutoIrql();

    MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);

    switch(nState) 
    {
        case MCPX_FE_STATE_HALTED:
            // DPF_BLAB("FE state set to HALTED");
            
            rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;

            break;

        case MCPX_FE_STATE_FREE_RUNNING:
            // DPF_BLAB("FE state set to FREE_RUNNING");
            
            rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING;

            break;

        case MCPX_FE_STATE_ISO:
            // DPF_BLAB("FE state set to ISO");
            
            rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_ISO;
            rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_ISO;
            rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_ISO;
            rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_ISO;

            break;

        case MCPX_FE_STATE_NON_ISO:
            // DPF_BLAB("FE state set to NON_ISO");
            
            rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_NON_ISO;
            rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_NON_ISO;
            rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_NON_ISO;
            rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_NON_ISO;

            break;

        default:
            ASSERTMSG("Invalid FE state");

            break;
    }

    MCPX_REG_WRITE(NV_PAPU_FECTL, rFeControl.uValue);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  SetSetupEngineState
 *
 *  Description:
 *      Sets the setup engine state.
 *
 *  Arguments:
 *      MCPX_SE_STATE [in]: state.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::SetSetupEngineState"

void 
CMcpxCoreTest::SetSetupEngineState
(
    MCPX_SE_STATE           nState
)
{
    R_SE_CONTROL            rSeControl;

    DPF_ENTER();
    AutoIrql();

    MCPX_REG_READ(NV_PAPU_SECTL, &rSeControl.uValue);

    switch(nState)
    {
        case MCPX_SE_STATE_OFF:
            // DPF_BLAB("SE state set to OFF");
            
            rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

            break;

        case MCPX_SE_STATE_AC_SYNC:
            // DPF_BLAB("SE state set to AC_SYNC");
            
            rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;

            break;

        case MCPX_SE_STATE_SW:
            // DPF_BLAB("SE state set to SW");
            
            rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_SW;

            break;

        case MCPX_SE_STATE_FREE_RUNNING:
            // DPF_BLAB("SE state set to FREE_RUNNING");
            
            rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;

            break;

        case MCPX_SE_STATE_ISO:
            // DPF_BLAB("SE state set to ISO");
            
            rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_ISO;
            rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_ISO;
            rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_ISO;

            break;

        case MCPX_SE_STATE_NON_ISO:
            // DPF_BLAB("SE state set to NON_ISO");
            
            rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_NON_ISO;
            rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_NON_ISO;
            rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_NON_ISO;

            break;

        default:
            ASSERTMSG("Invalid SE state");

            break;
    }

    MCPX_REG_WRITE(NV_PAPU_SECTL, rSeControl.uValue);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  GetPhysicalMemoryProperties
 *
 *  Description:
 *      Gets the physical address of a memory buffer, the byte offset into 
 *      the first page and the count of physically contiguous bytes in the
 *      buffer.
 *
 *  Arguments:
 *      LPVOID [in]: buffer virtual address.
 *      DWORD [in]: buffer size.
 *      LPDWORD [out]: page offset.
 *      LPDWORD [out]: contiguous length, in bytes.
 *
 *  Returns:  
 *      DWORD: buffer physical address.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::GetPhysicalMemoryProperties"

DWORD
CMcpxCoreTest::GetPhysicalMemoryProperties
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwPageOffset,
    LPDWORD                 pdwContiguousLength
)
{
    DWORD                   dwBasePhysicalAddress;
    DWORD                   dwBasePageOffset;
    DWORD                   dwContiguousLength;
    DWORD                   dwPhysicalAddress;

    DPF_ENTER();

    //
    // Get the base physical address
    //

    dwBasePhysicalAddress = MmGetPhysicalAddress(pvBuffer);

    //
    // Get the base page offset
    //

    dwBasePageOffset = BYTE_OFFSET(pvBuffer);

    if(pdwPageOffset)
    {
        *pdwPageOffset = dwBasePageOffset;
    }

    //
    // Find the count of contiguous bytes in the remaining pages
    //

    if(pdwContiguousLength)
    {
        dwContiguousLength = PAGE_SIZE - dwBasePageOffset; 

        while(dwContiguousLength < dwBufferSize)
        {
            dwPhysicalAddress = MmGetPhysicalAddress((LPBYTE)pvBuffer + dwContiguousLength);
            ASSERT(!(dwPhysicalAddress & (PAGE_SIZE - 1)));

            if(dwBasePhysicalAddress + dwContiguousLength != dwPhysicalAddress)
            {
                break;
            }

            dwContiguousLength += PAGE_SIZE;
        }

        *pdwContiguousLength = min(dwContiguousLength, dwBufferSize);
    }

    DPF_LEAVE(dwBasePhysicalAddress);

    return dwBasePhysicalAddress;
}


/****************************************************************************
 *
 *  MapTransfer
 *
 *  Description:
 *      Replacement for IoMapTransfer.
 *
 *  Arguments:
 *      LPVOID * [in/out]: buffer virtual address.
 *      LPDWORD [in/out]: buffer size, in bytes.
 *      LPDWORD [out]: count of bytes mapped.
 *
 *  Returns:  
 *      DWORD: buffer physical address.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::MapTransfer"

DWORD
CMcpxCoreTest::MapTransfer
(
    LPVOID *                ppvBuffer,
    LPDWORD                 pdwBufferSize,
    LPDWORD                 pdwBytesMapped
)
{
    DWORD                   dwPhysicalAddress;
    DWORD                   dwPageOffset;
    DWORD                   dwBytesMapped;

    DPF_ENTER();

    dwPhysicalAddress = GetPhysicalMemoryProperties(*ppvBuffer, *pdwBufferSize, &dwPageOffset, NULL);

    dwBytesMapped = min(PAGE_SIZE - dwPageOffset, *pdwBufferSize);

    *ppvBuffer = (LPBYTE)*ppvBuffer + dwBytesMapped;
    *pdwBufferSize -= dwBytesMapped;

    if(pdwBytesMapped)
    {
        *pdwBytesMapped = dwBytesMapped;
    }

    DPF_LEAVE(dwPhysicalAddress);

    return dwPhysicalAddress;
}


/****************************************************************************
 *
 *  AllocateContext
 *
 *  Description:
 *      Allocates physically contiguous memory.
 *
 *  Arguments:
 *      PMCPX_ALLOC_CONTEXT [in/out]: allocation context data.
 *      DWORD [in]: allocation size, in bytes.
 *      DWORD [in]: allocation alignment, in bytes.
 *      DWORD [in]: allocation flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::AllocateContext"

HRESULT
CMcpxCoreTest::AllocateContext
(
    PMCPX_ALLOC_CONTEXT     pContext,
    DWORD                   dwAlignment,
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    
    DPF_ENTER();

    ASSERT(!pContext->VirtualAddress);
    ASSERT(!pContext->PhysicalAddress);
    ASSERT(pContext->Size);
    ASSERT(dwAlignment);

    if(SUCCEEDED(hr = HRFROMP(pContext->VirtualAddress = PHYSALLOC(BYTE, pContext->Size, dwAlignment, dwFlags))))
    {
        pContext->PhysicalAddress = MmGetPhysicalAddress(pContext->VirtualAddress);
        ASSERT(!(pContext->PhysicalAddress & (dwAlignment - 1)));
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  ResetGlobalCounters
 *
 *  Description:
 *      Resets the APU global counters.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::ResetGlobalCounters"

void
CMcpxCoreTest::ResetGlobalCounters
(
    void
)
{
    static const DWORD      dwDelta = m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_ANALOG] / 4;

    DPF_ENTER();

    MCPX_REG_WRITE(NV_PAPU_IGSCNT, dwDelta); 
    MCPX_REG_WRITE(NV_PAPU_XGSCNT, 0);
    MCPX_REG_WRITE(NV_PAPU_DGSCNT, dwDelta);
    MCPX_REG_WRITE(NV_PAPU_WGSCNT, dwDelta / 2);
    MCPX_REG_WRITE(NV_PAPU_RGSCNT, dwDelta - 1);
    MCPX_REG_WRITE(NV_PAPU_PGSCNT, 0);

    MCPX_REG_WRITE(NV_PAPU_EGSCNT, 6 * MCPX_HW_EP_STEP_SIZE);
    MCPX_REG_WRITE(NV_PAPU_DEGSCNT, MCPX_HW_EP_STEP_SIZE);
    MCPX_REG_WRITE(NV_PAPU_ECNTSTP, MCPX_HW_EP_STEP_SIZE);

    MCPX_REG_WRITE(NV_PAPU_EPOFCUR0, 1536);
    MCPX_REG_WRITE(NV_PAPU_EPOFCUR1, m_adwEPOutputBufferSizes[MCPX_EPOUTPUT_AC97_ANALOG] + 6144);

    DPF_LEAVE_VOID();
}


/****************************************************************************
 *
 *  IdleVoiceProcessor
 *
 *  Description:
 *      Puts the VP into an idle state, or restores it from one.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to idle, FALSE to run.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "CMcpxCoreTest::IdleVoiceProcessor"

BOOL
CMcpxCoreTest::IdleVoiceProcessor
(
    BOOL                    fIdle
)
{
    DWORD                   dwTimeout   = MCPX_HW_FRAME_LENGTH_US;
    R_FE_CONTROL            rFeControl;
    R_SE_CONTROL            rSeControl;
    CMcpxNotifierTest       Notifier;

    DPF_ENTER();
    AutoIrql();

    if(fIdle)
    {
        //
        // Check the current FE and SE states.  If they're not running, we
        // don't need to idle the VP.
        //

        fIdle = FALSE;
        
        MCPX_REG_READ(NV_PAPU_FECTL, &rFeControl.uValue);
        
        if(NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING == rFeControl.Mode)
        {
            MCPX_REG_READ(NV_PAPU_SECTL, &rSeControl.uValue)
    
            if(NV_PAPU_SECTL_XCNTMODE_OFF != rSeControl.GSCUpdate)
            {
                fIdle = TRUE;
    
                //
                // Turn off the VP
                //
    
                MCPX_CHECK_VOICE_FIFO(1);
                MCPX_VOICE_WRITE(SetProcessorMode, NV1BA0_PIO_SET_MODE_PARAMETER_OFF);

                //
                // Wait for the VP to tell us it's idle
                //

                if(m_ctxMemory[MCPX_MEM_NOTIFIERS].VirtualAddress)
                {
                    Notifier.Initialize(0, 1);
    
                    MCPX_VOICE_WRITE(Synchronize, NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE_WRITE_PE_NOTIFY);

                    while(!Notifier.GetStatus(0))
                    {
                        KeStallExecutionProcessor(1);

                        if(!dwTimeout--)
                        {
                            break;
                        }
                    }

                    Notifier.Reset();
                }
                else
                {
                    KeStallExecutionProcessor(dwTimeout);
                }
            }
        }
    }
    else
    {
        //
        // Turn the VP back on
        //
        
        MCPX_CHECK_VOICE_FIFO(1);
        MCPX_VOICE_WRITE(SetProcessorMode, NV1BA0_PIO_SET_MODE_PARAMETER_RUN);
    }        

    DPF_LEAVE(fIdle);

    return fIdle;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\mcpxhw.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcpxhw.h
 *  Content:    MCP-X hardware definitions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/09/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __MCPXHW_H__
#define __MCPXHW_H__

#include "nv_papu.h"
#include "nv_uap.h"

#define MCPX_HW_PCI_VENDOR_ID 0x10DE
#define MCPX_HW_PCI_DEVICE_ID 0x01B0

//
// DONT CHANGE SCRATCH SIZES WITHOUT CHANGING XGPIMAGE\DSP.h and DSP\INCLUDE\IO.H!!!!!
// dsp code depends on the value for the EP input dma
//

#define MCPX_GLOBAL_PROC_SCRATCH_SIZE              DSP_AUDIO_DATA_SCRATCHOFFSET  

//
// FX can potentially use up to a megabyte of scratch space
//

#define MCPX_HW_MAX_FX_SCRATCH_PAGES               512

//
// DSP memory spaces are addressable from within the mcpx register space
// the offsets fo GP p, x and y mem are below
//

#define MCPX_HW_GPXMEM_REG_OFFSET (XPCICFG_APU_MEMORY_REGISTER_BASE_0+0x30000)
#define MCPX_HW_GPYMEM_REG_OFFSET (XPCICFG_APU_MEMORY_REGISTER_BASE_0+0x36000)
#define MCPX_HW_GPPMEM_REG_OFFSET (XPCICFG_APU_MEMORY_REGISTER_BASE_0+0x3A000)

//
// internal DSP offsets, in words
//
#define MCPX_HW_GPMEMOFSET_MIXBIN00                 0x1400      // VP mixbins are mapped to offset 0x1400 of GP X mem.

#define MCPX_HW_MAX_NOTIFIERS (MCPX_HW_MAX_VOICES * 4 + 2)
#define MCPX_HW_NOTIFIERS_PER_VOICE 4

#define MCPX_SW_DEFAULT_HRTF_HEADROOM 4
#define MCPX_HW_DEFAULT_TRACKING 0xFFF

//
// encode proc output buffer defines
//

#define MCPX_HW_EP_STEP_SIZE    256
#define AC3_BUFFER_COUNT        2      // so we can ping-pong
#define AC3_FRAME_SIZE          MCPX_HW_EP_STEP_SIZE
#define AC3_CONTAINER_SIZE      4
#define AC3_NUM_CHANNELS        6
#define MCPX_HW_AC3_NUM_INPUT_PAGES     (((AC3_BUFFER_COUNT * AC3_FRAME_SIZE * AC3_CONTAINER_SIZE * AC3_NUM_CHANNELS) + PAGE_SIZE-1)  / PAGE_SIZE)

//
// multipass buffer pages
//

#define MCPX_HW_MULTIPASS_NUM_PAGES ((((DSMIXBIN_FXSEND_LAST-DSMIXBIN_FXSEND_FIRST+1)*128)+PAGE_SIZE-1)/PAGE_SIZE)

//
// Misc MCP-X values
//

#define MCPX_MAX_VOICE_CHANNELS             3
                                                
#define MCPX_ALIGN_16K                      0x4000
                                            
#define MCPX_MAX_VALID_ADDRESS              0x8000000
                                            
#define MCPX_BASEFREQ                       48000
#define MCPX_BASEFREQF                      48000.0f
#define MCPX_ONEOVERBASEFREQ                2.0833333333333E-5f
                                            
#define MCPX_HW_MAX_VOICES                  256
#define MCPX_HW_MAX_3D_VOICES               64
#define MCPX_HW_MAX_2D_VOICES               (MCPX_HW_MAX_VOICES - MCPX_HW_MAX_3D_VOICES)

#define MCPX_HW_FIRST_3D_VOICE              0
#define MCPX_HW_FIRST_2D_VOICE              MCPX_HW_MAX_3D_VOICES
                                            
#define MCPX_HW_MAX_PRD_ENTRIES_PER_SSL     16
#define MCPX_HW_SSLS_PER_VOICE              2
#define MCPX_HW_MAX_PRD_ENTRIES_PER_VOICE   (MCPX_HW_MAX_PRD_ENTRIES_PER_SSL * MCPX_HW_SSLS_PER_VOICE)
#define MCPX_HW_MAX_SSL_PRDS                (MCPX_HW_MAX_VOICES * MCPX_HW_MAX_PRD_ENTRIES_PER_VOICE)

#define MCPX_HW_3DFILTERS_PER_VOICE         2

#define MCPX_HW_MAX_SUBMIX_BINS             32

#define MCPX_HW_MAX_BUFFER_PRDS             2048

#define MCPX_HW_FRAME_SIZE_SAMPLES          32
#define MCPX_HW_FRAME_LENGTH_US             667

#define MCPX_HW_MAX_VOICE_MIXBINS           8

///////////////////////////////////////////////////////////////////////////////
//
// list of methods that the RM will write to the
// output Q in the scratch memory, for communication
// with the GP
//
///////////////////////////////////////////////////////////////////////////////

/*
NV_OGP_SET_EFFECT - Method to set an effect in the GP

NV_OGP_SET_EFFECT_INDEX - Index of the effect that has changed.  The GP
whould use this index to access the Effect_Control in the scratch memory
NV_OGP_SET_EFFECT_OPERATION_RESET - A new effect has been requested by the
client.  The GP should pull this effect into the p-mem.  All information
reguired by the GP will be present in the Effect_Control[Index].
NV_OGP_SET_EFFECT_OPERATION_ENABLE - An already loaded effect has been
enabled
NV_OGP_SET_EFFECT_OPERATION_DISABLE - An already loaded effect has been
disabled
NV_OGP_SET_EFFECT_OFFSET - Offset in scratch memory, of the effect control.
This offset need only be accessed on NV_OGP_SET_EFFECT_OPERATION_RESET.
*/

#define NV_OGP_SET_EFFECT                           0x00000001
#define NV_OGP_SET_EFFECT_INDEX                     15:0
#define NV_OGP_SET_EFFECT_OPERATION                 31:16
#define NV_OGP_SET_EFFECT_OPERATION_RESET           0x0
#define NV_OGP_SET_EFFECT_OPERATION_ENABLE          0x1
#define NV_OGP_SET_EFFECT_OPERATION_DISABLE         0x2
#define NV_OGP_SET_EFFECT_OFFSET                    63:32

/*
NV_OGP_SET_AC3_OUTPUT_BUFFER - method to set the AC3 output buffer offset

NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_ENABLE - the buffer described by the size
and offset is valid.  The GP should start putting de-interleaved data in it
NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_DISABLE - a previously configured AC3 output
buffer is not valid, the GP should stop putting data in it
NV_OGP_SET_AC3_OUTPUT_BUFFER_SIZE - buffer size in bytes
NV_OGP_SET_AC3_OUTPUT_BUFFER_OFFSET - offset of the buffer in GP scratch
*/

#define NV_OGP_SET_AC3_OUTPUT_BUFFER                0x00000002
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER           0:0
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_ENABLE    0x1
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_DISABLE   0x0
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_SIZE           31:16
#define NV_OGP_SET_AC3_OUTPUT_BUFFER_OFFSET         63:32

///////////////////////////////////////////////////////////////////////////////
//
// data structures
//
///////////////////////////////////////////////////////////////////////////////

#pragma pack (push, _store_)
#pragma pack (1)

// interrupt registers
typedef union
{
	struct
	{	
		ULONG General		: 1;
		ULONG DeltaWarning : 1;
		ULONG RetriggerEvent : 1;		/* not in INTERRUPT_ENABLE  */
		ULONG DeltaPanic	: 1;
		ULONG FETrap		: 1;
		ULONG FENotify		: 1;
		ULONG FEVoice		: 1;
		ULONG FEMethodOverFlow : 1;
		ULONG GPMailbox	: 1;
		ULONG GPNotify		: 1;
		ULONG EPMailbox	: 1;
		ULONG EPNotify		: 1;
		ULONG				: 21;
	};
	
	ULONG uValue;
} R_INTR;

// front end
typedef union
{
	struct
	{	
		ULONG NotifyISO	: 1;
		ULONG ReadISO		: 1;
		ULONG WriteISO		: 1;
		ULONG TrapOnNotifier : 1;
		ULONG Lock			: 1;
		ULONG Mode			: 3;
		ULONG TrapReason	: 4;
        ULONG PIOClass     : 1;
        ULONG EnableLock   : 1;
		ULONG MethodOrigin : 1;
		ULONG ValidSESSL   : 1;
		ULONG ValidSESGE   : 1;
		ULONG ValidGPSGE   : 1;
		ULONG				: 14;
	};
	
	ULONG uValue;
} R_FE_CONTROL;

// setup engine
typedef union
{
	struct
	{	
		ULONG ReadISO		: 1;
		ULONG WriteISO		: 1;
		ULONG SampleReadISO : 1;
		ULONG GSCUpdate	: 2;
		ULONG DeltaWarn	: 1;
		ULONG Retriggered	: 1;
		ULONG DeltaPanic	: 1;
		ULONG				: 24;
	};
	
	ULONG uValue;
} R_SE_CONTROL;

typedef union
{
	struct
	{	
		ULONG Global   : 1;
		ULONG DSP      : 1;
		ULONG NMI      : 1;
		ULONG Abort   	: 1;
		ULONG          : 28;
	};
	
	ULONG uValue;
} R_GP_RESET;

typedef union
{
	struct
	{	
		ULONG Start		: 1;
		ULONG Ready		: 1;
		ULONG ReqIOC       : 1;
		ULONG ReqEOL   	: 1;
		ULONG ReqErr	    : 1;
		ULONG				: 27;
	};
	
	ULONG uValue;
} R_GPDMA_CONFIG;

typedef union
{
	struct
	{	
		ULONG Idle         : 1;
		ULONG Stopped      : 1;
		ULONG EnableStop   : 1;
		ULONG IntrNotify   : 1;
		ULONG				: 28;
	};
	
	ULONG uValue;
} R_GP_CONTROL;

typedef struct
{
    ULONG  uAddr;

    union
    {
        struct
        {
            ULONG Length   : 16;
            ULONG ContSize : 2;
            ULONG Samples  : 5;
            ULONG Stereo   : 1;
            ULONG Owner    : 1;
            ULONG          : 6;
            ULONG Intr     : 1;
        };

        ULONG uValue;
    }Control;

} MCP1_PRD;

// word format for DSP commands

typedef union
{
    struct
    {
        ULONG nextCommand    : 14;
        ULONG EOL            : 1;
        ULONG                : 17;
    } field;

    ULONG uValue;
} WORD0;

typedef union
{
    struct
    {
        ULONG interleave     : 1;
        ULONG dspToSys       : 1;
        ULONG IOC            : 2;
        ULONG smOffWrBack    : 1;
        ULONG smBufId        : 4;
        ULONG iso            : 1;
        ULONG smDataFormat   : 3;
        ULONG                : 1;
        ULONG increment      : 11;
        ULONG                : 7;
    } field;

    ULONG uValue;
} WORD1;

typedef union
{
    struct
    {
        ULONG count0     : 4;
        ULONG count1     : 10;
        ULONG            : 18;
    } field;

    ULONG uValue;
} WORD2;

typedef union
{
    struct
    {
        ULONG dspStart   : 14;
        ULONG nul        : 1;
        ULONG            : 17;
    } field;

    ULONG uValue;
} WORD3;

typedef union
{
    struct
    {
        ULONG smOffset   : 24;
        ULONG            : 8;
    } field;

    ULONG uValue;
} WORD4;

typedef union
{
    struct
    {
        ULONG smBaseAddr : 24;
        ULONG            : 8;
    } field;

    ULONG uValue;
} WORD5;

typedef union
{
    struct
    {
        ULONG smSizeMinus1   : 24;
        ULONG                : 8;
    } field;

    ULONG uValue;
} WORD6;

typedef struct
{
    WORD0 w0;
    WORD1 w1;
    WORD2 w2;
    WORD3 w3;
} DSP_CONTROL;

#define INCR(x,limit)		(((x) < ((limit)-1))?((x)++):0)
#define DECR(x,limit)		((x)?((x)--):((limit)-1))

#define APU_INVALID_METHOD		0xFFFF

typedef volatile struct _MCPX_HW_NOTIFICATION
{
	ULONG	GSCNT;
	ULONG	CurrentOffset;
	ULONG	Zero;
	UCHAR	Res0;
	UCHAR	SamplesAvailable;       // not in sync
	UCHAR	EnvelopeActive;         // not in sync
	UCHAR	Status;
} MCPX_HW_NOTIFICATION, *PMCPX_HW_NOTIFICATION;

#define NV1BA0_NOTIFICATION_STATUS_DONE_SUCCESS       0x01
#define NV1BA0_NOTIFICATION_STATUS_IN_PROGRESS        0x80

#define LOW16(x)								(USHORT)(0x0000ffff & (ULONG)(x))
#define LOW08(x)								(UCHAR)(0x000000ff & (ULONG)(x))

#define MIN(x,y)								(((x)<(y))?(x):(y))
#define MAX(x,y)								(((x)>(y))?(x):(y))

// codec defines
#define ACI_OFFSET                              0x100
#define MIXER_OFFSET                            0x000

// revision IDs of the hardware
#define REV_MCP1								0xA1

// sizes of various HW structures (in bytes)
// #define SIZEOF_PRD                              8
// #define SIZEOF_VOICE                            128
#define SIZEOF_TARGET_HRTF                      64
#define SIZEOF_CURRENT_HRTF                     96

// all EP methods are in NV_PAPU_NV1BA0 + PIO_EP_OFFSET
#define PIO_EP_OFFSET                           0x8000

// all debug methods are in NV_PAPU_NV1BA0 + PIO_DEBUG_OFFSET
#define PIO_DEBUG_OFFSET                        0x4000

// maximum PIOFree value (formatted for method count -- real max value is 0x80)
#define PIO_METHOD_QUEUE_CLEAR                  0x20

#pragma pack (pop, _store_)

//
// voice processor register defines
//

#define VPPIOFREE DWORD volatile
#define VPPIOINFO DWORD volatile
#define VPDMAPUT DWORD volatile
#define VPDMAGET DWORD volatile
#define VPNOOPERATION DWORD volatile
#define VPSYNCHRONIZE DWORD volatile
#define VPSETTIME DWORD volatile
#define VPSETPROCESSORMODE DWORD volatile
#define VPSETANTECEDENTVOICE DWORD volatile
#define VPVOICEON DWORD volatile
#define VPVOICEOFF DWORD volatile
#define VPVOICERELEASE DWORD volatile
#define VPVOICEPAUSE DWORD volatile
#define VPSETCONTEXTDMANOTIFY DWORD volatile
#define VPGETVOICEPOSITION DWORD volatile
#define VPSETSUBMIXHEADROOM DWORD volatile
#define VPSETHRTFHEADROOM DWORD volatile
#define VPSETHRTFSUBMIX DWORD volatile
#define VPSETHRTFSUBMIXES DWORD volatile
#define VPSETVOLUMETRACKING DWORD volatile
#define VPSETPITCHTRACKING DWORD volatile
#define VPSETHRTFTRACKING DWORD volatile
#define VPSETITDTRACKING DWORD volatile
#define VPSETFILTERTRACKING DWORD volatile
#define VPSETCURRENTVOICE DWORD volatile
#define VPVOICELOCK DWORD volatile
#define VPSETVOICECFGVBIN DWORD volatile
#define VPSETVOICECFGFMT DWORD volatile
#define VPSETVOICECFGENV0 DWORD volatile
#define VPSETVOICECFGENVA DWORD volatile
#define VPSETVOICECFGENV1 DWORD volatile
#define VPSETVOICECFGENVF DWORD volatile
#define VPSETVOICECFGMISC DWORD volatile
#define VPSETVOICETARHRTF DWORD volatile
#define VPSETVOICECFGLFODLY DWORD volatile
#define VPSETVOICESSLA DWORD volatile
#define VPSETVOICESSLB DWORD volatile
#define VPSETVOICECFGBUFBASE DWORD volatile
#define VPSETVOICECFGBUFLBO DWORD volatile
#define VPSETVOICEBUFCBOFRAC DWORD volatile
#define VPSETVOICEBUFCBO DWORD volatile
#define VPSETVOICECFGBUFEBO DWORD volatile
#define VPSETVOICETARVOLA DWORD volatile
#define VPSETVOICETARVOLB DWORD volatile
#define VPSETVOICETARVOLC DWORD volatile
#define VPSETVOICELFOENV DWORD volatile
#define VPSETVOICELFOMOD DWORD volatile
#define VPSETVOICETARFCA DWORD volatile
#define VPSETVOICETARFCB DWORD volatile
#define VPSETVOICETARPITCH DWORD volatile
#define VPSETCURRENTHRTFENTRY DWORD volatile
#define VPSETHRIR DWORD volatile
#define VPSETHRIRX DWORD volatile
#define VPSETCURRENTSSLCONTEXTDMA DWORD volatile
#define VPSETCURRENTSSL DWORD volatile
#define VPSETSSLSEGMENTOFFSET DWORD volatile
#define VPSETSSKSEGMENTLENGTH DWORD volatile
#define VPSETCURRENTINBUFSGECONTEXTDMA DWORD volatile
#define VPSETCURRENTINBUFSGE DWORD volatile
#define VPSETCURRENTINBUFSGEOFFSET DWORD volatile
#define VPSETOUTBUFLEN DWORD volatile
#define VPSETOUTBUFBA DWORD volatile
#define VPSETCURRENTOUTBUFSGE DWORD volatile
#define VPSETCURRENTOUTBUFSGECONTEXTDMA DWORD volatile
#define VPSETOUTBUFSGEOFFSET DWORD volatile

#define VPSETSGEVOICENUMHACK DWORD volatile
#define VPSETSGEFULLLENHACK DWORD volatile
#define VPSETSGEADDRHACK DWORD volatile

#define VPSTARTRMDMA DWORD volatile

BEGIN_DEFINE_STRUCT()

    DWORD Reserved0000[4];                     // 0x0000 - 0x000C
    VPPIOFREE PIOFree;                         // 0x0010
    VPPIOINFO PIOInfo;                         // 0x0014
    DWORD Reserved2[10];                       // 0x0018 - 0x003C
    VPDMAPUT DMAPut;                           // 0x0040
    VPDMAGET DMAGet;                           // 0x0044
    DWORD Reserved0048[46];                    // 0x0048 - 0x00FC
    VPNOOPERATION NoOperation;                 // 0x0100
    VPSYNCHRONIZE Synchronize;                 // 0x0104
    VPSETTIME SetTime;                         // 0x0108
    VPSETPROCESSORMODE SetProcessorMode;       // 0x010C
    DWORD Reserved0110[4];                     // 0x0110 - 0x011C
    VPSETANTECEDENTVOICE SetAntecedentVoice;   // 0x0120
    VPVOICEON VoiceOn;                         // 0x0124
    VPVOICEOFF VoiceOff;                       // 0x0128
    VPVOICERELEASE VoiceRelease;               // 0x012C
    VPGETVOICEPOSITION GetVoicePosition;       // 0x0130
    DWORD Reserved0134[3];                     // 0x0134 - 0x13f
    VPVOICEPAUSE VoicePause;                   // 0x0140
    DWORD Reserved0144[7];                     // 0x0144 - 0x15c
    VPSETCURRENTHRTFENTRY SetCurrentHRTFEntry; // 0x0160
    DWORD Reserved0164[7];                     // 0x0164 - 0x017f
    VPSETCONTEXTDMANOTIFY SetContextDMANotify; // 0x0180
    DWORD Reserved0184[2];                     // 0x0184 - 0x018B
    VPSETCURRENTSSLCONTEXTDMA SetCurrentSSLContextDMA; // 0x018C
    VPSETCURRENTSSL SetCurrentSSL;             // 0x0190
    DWORD Reserved0194[27];                    // 0x0194 - 0x01fc
    VPSETSUBMIXHEADROOM SetSubMixHeadroom[32]; // 0x0200 - 0x027C
    VPSETHRTFHEADROOM SetHRTFHeadroom;         // 0x0280
    DWORD Reserved0284[3];                     // 0x0284 - 0x028C
    VPSETHRTFSUBMIX SetHRTFSubmix[4];          // 0x0290 - 0x029C
    VPSETVOLUMETRACKING SetVolumeTracking;     // 0x02A0
    VPSETPITCHTRACKING SetPitchTracking;       // 0x02A4
    VPSETHRTFTRACKING SetHRTFTracking;         // 0x02A8
    VPSETITDTRACKING SetITDTracking;           // 0x02AC
    VPSETFILTERTRACKING SetFilterTracking;     // 0x02B0
    DWORD Reserved02B4[3];                     // 0x02B4 - 0x02BC
    VPSETHRTFSUBMIXES SetHRTFSubmixes;         // 0x02C0
    DWORD Reserved02C4[13];                    // 0x02C4 - 0x02F4
    VPSETCURRENTVOICE SetCurrentVoice;         // 0x02F8
    VPVOICELOCK VoiceLock;                     // 0x02FC
    VPSETVOICECFGVBIN SetVoiceCfgVBIN;         // 0x0300
    VPSETVOICECFGFMT SetVoiceCfgFMT;           // 0x0304
    VPSETVOICECFGENV0 SetVoiceCfgENV0;         // 0x0308
    VPSETVOICECFGENVA SetVoiceCfgENVA;         // 0x030C
    VPSETVOICECFGENV1 SetVoiceCfgENV1;         // 0x0310
    VPSETVOICECFGENVF SetVoiceCfgENVF;         // 0x0314
    VPSETVOICECFGMISC SetVoiceCfgMISC;         // 0x0318
    VPSETVOICETARHRTF SetVoiceTarHRTF;         // 0x031C
    VPSETVOICESSLA SetVoiceSSLA;               // 0x0320
    DWORD Reserved0324[11];                    // 0x0324 - 0x034C
    VPSETVOICECFGLFODLY SetVoiceCfgLFODLY;     // 0x0350
    DWORD Reserved0354[2];                     // 0x0354 - 0x0358
    VPSETVOICESSLB SetVoiceSSLB;               // 0x035C
    VPSETVOICETARVOLA SetVoiceTarVOLA;         // 0x0360
    VPSETVOICETARVOLB SetVoiceTarVOLB;         // 0x0364
    VPSETVOICETARVOLC SetVoiceTarVOLC;         // 0x0368
    VPSETVOICELFOENV SetVoiceLFOENV;           // 0x036C
    VPSETVOICELFOMOD SetVoiceLFOMOD;           // 0x0370
    VPSETVOICETARFCA SetVoiceTarFCA;           // 0x0374
    VPSETVOICETARFCB SetVoiceTarFCB;           // 0x0378
    VPSETVOICETARPITCH SetVoiceTarPitch;       // 0x037C
    DWORD Reserved0360[8];                     // 0x0380 - 0x039C
    VPSETVOICECFGBUFBASE SetVoiceCfgBufBase;   // 0x03A0
    VPSETVOICECFGBUFLBO SetVoiceCfgBufLBO;     // 0x03A4
    DWORD Reserved03A8[11];                    // 0x03A8 - 0x03D0
    VPSETVOICEBUFCBOFRAC SetVoiceBufCBOFrac;   // 0x03D4
    VPSETVOICEBUFCBO SetVoiceBufCBO;           // 0x03D8
    VPSETVOICECFGBUFEBO SetVoiceCfgBufEBO;     // 0x03DC
    DWORD Reserved03E0[8];                     // 0x03E0 - 0x03FC
    VPSETHRIR SetHRIR[15];                     // 0x0400 - 0x0438
    VPSETHRIRX SetHRIRX;                       // 0x043C
    DWORD Reserved0440[112];                   // 0x0440 - 0x05FC
    struct {
        VPSETSSLSEGMENTOFFSET Offset;          // 0x0600 - 0x07F8
        VPSETSSKSEGMENTLENGTH Length;          // 0x0604 - 0x07FC
    } SetSSLSegment[64];                       // 0x0600 - 0x07FC
    VPSETCURRENTINBUFSGECONTEXTDMA SetCurrentInBufSGEContextDMA; // 0x0800
    VPSETCURRENTINBUFSGE SetCurrentInBufSGE;   // 0x0804
    VPSETCURRENTINBUFSGEOFFSET SetCurrentInBufSGEOffset; // 0x0808
    DWORD Reserved080C[509];                   // 0x080C - 0x0FFC
    struct {
        VPSETOUTBUFBA  BA;                     // 0x1000 - 0x1018
        VPSETOUTBUFLEN Len;                    // 0x1004 - 0x101C
    } SetOutBuf[4];                            // 0x1000 - 0x101C
    DWORD Reserved1020[504];                   // 0x1020 - 0x17FC
    VPSETCURRENTOUTBUFSGE SetCurrentOutBufSGE; // 0x1800
    VPSETCURRENTOUTBUFSGECONTEXTDMA SetCurrentOutBufSGEContextDMA; // 0x1804
    VPSETOUTBUFSGEOFFSET SetOutBufSGEOffset;   // 0x1808

    VPSETSGEVOICENUMHACK  SetSGEVoiceNumHack;  // 0x180c  --- Not a real function (trace use only)
    VPSETSGEFULLLENHACK  SetSGEFullLenHack;    // 0x1810  --- Not a real function (trace use only)
    VPSETSGEADDRHACK  SetSGEAddrHack;          // 0x1814  --- Not a real function (trace use only)

    DWORD Reserved1818[2554];                  // 0x1818 - 0x3fff

END_DEFINE_STRUCT(MCPXVPREGSET);

#endif // __MCPXHW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\ntlist.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ntlist.h
 *  Content:    Overrides of the standard NT list management macros.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __NTLIST_H__
#define __NTLIST_H__

#define IsEntryInList(Entry) \
    (!IsListEmpty(Entry))

//
// Determine if the entry is valid
//

BEGIN_DEFINE_ENUM()
    ASSERT_VALID_ONLY = 0,
    ASSERT_IN_LIST,
    ASSERT_NOT_IN_LIST,
END_DEFINE_ENUM(ASSERT_VALID_ENTRY_LIST);

#ifdef DEBUG

__inline void __AssertValidEntryList(PLIST_ENTRY Entry, ASSERT_VALID_ENTRY_LIST nFlags, LPCSTR pszFile, UINT nLine)
{
    if(!Entry)
    {
        DwDbgAssert(TRUE, "NULL list entry pointer", pszFile, nLine);
    }
    else if(!Entry->Flink || !Entry->Blink)
    {
        DwDbgAssert(TRUE, "List entry contains NULL pointer", pszFile, nLine);
    }
    else if((Entry == Entry->Flink) || (Entry == Entry->Blink))
    {
        if((Entry != Entry->Flink) || (Entry != Entry->Blink))
        {
            DwDbgAssert(TRUE, "List entry partially points to itself", pszFile, nLine);
        }
    }
    else if(ASSERT_IN_LIST == nFlags)
    {
        if(!IsEntryInList(Entry))
        {
            DwDbgAssert(TRUE, "List entry not in list", pszFile, nLine);
        }
    }
    else if(ASSERT_NOT_IN_LIST == nFlags)
    {
        if(IsEntryInList(Entry))
        {
            DwDbgAssert(TRUE, "List entry in list", pszFile, nLine);
        }
    }
}

#define AssertValidEntryList(Entry, nFlags) \
    __AssertValidEntryList(Entry, nFlags, __FILE__, __LINE__)

#else // DEBUG

#define AssertValidEntryList(Entry, nFlags)

#endif // DEBUG

//
// Add an entry to the end of a list or add a node at the position before
// the given node
//

/*
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
*/

#undef InsertTailList
__inline void InsertTailList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;
    
    Entry->Blink->Flink = Entry;
    Entry->Flink->Blink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}    

//
// Add an entry to the end of a list or add a node at the position before
// the given node (no valid node check)
//

__inline void InsertTailListUninit(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}    

//
// Add an entry to the head of a list or add a node at the position after
// the given node
//

/*
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
*/

#undef InsertHeadList
__inline void InsertHeadList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_NOT_IN_LIST);

    Entry->Flink = ListHead->Flink;
    Entry->Blink = ListHead;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}

//
// Add an entry to the head of a list or add a node at the position after
// the given node (no valid node check)
//

__inline void InsertHeadListUninit(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);

    Entry->Flink = ListHead->Flink;
    Entry->Blink = ListHead;
    
    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);
}

//
// Remove an entry from a list
//

/*
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
*/

#undef RemoveEntryList
__inline PLIST_ENTRY RemoveEntryList(PLIST_ENTRY Entry)
{
    AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

    if(IsEntryInList(Entry))
    {
        Entry->Flink->Blink = Entry->Blink;
        Entry->Blink->Flink = Entry->Flink;

        Entry->Flink = Entry->Blink = Entry;
    }

    return Entry;
}

/*
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
*/

#undef RemoveHeadList
#define RemoveHeadList(ListHead) \
    RemoveEntryList((ListHead)->Flink)

/*
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
*/

#undef RemoveTailList
#define RemoveTailList(ListHead) \
    RemoveEntryList((ListHead)->Blink)

//
// Move an entry from one list to the tail of another
//

__inline PLIST_ENTRY MoveEntryTailList(PLIST_ENTRY ListHead, PLIST_ENTRY Entry)
{
    AssertValidEntryList(ListHead, ASSERT_VALID_ONLY);
    AssertValidEntryList(Entry, ASSERT_VALID_ONLY);

    Entry->Flink->Blink = Entry->Blink;
    Entry->Blink->Flink = Entry->Flink;

    Entry->Flink = ListHead;
    Entry->Blink = ListHead->Blink;

    Entry->Flink->Blink = Entry;
    Entry->Blink->Flink = Entry;

    AssertValidEntryList(Entry, ASSERT_IN_LIST);

    return Entry;
}

__inline PLIST_ENTRY MoveHeadTailList(PLIST_ENTRY DestListHead, PLIST_ENTRY SourceListHead)
{
    PLIST_ENTRY             Entry;
    
    AssertValidEntryList(SourceListHead, ASSERT_VALID_ONLY);

    if((Entry = SourceListHead->Flink) != SourceListHead)
    {
        MoveEntryTailList(DestListHead, Entry);
    }
    
    return Entry;
}

#endif // __NTLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\nv_papu.h ===
/*  FILE: nv_papu.h
 *  CREATED: Mon Nov 20 07:59:00 2000
 *
 *  Copyright (c) 2000, by NVIDIA CORP
 *  All Rights Reserved.
 */

 /*** DO NOT EDIT, THIS FILE GENERATED FROM ../../../manuals/dev_apu.ref ***/


#ifndef __NV_PAPU_H__
#define __NV_PAPU_H__


/***********************************************/
/* Macros and constants                        */
/***********************************************/

#ifndef REF_VAL
#define DRF_SHIFT(drf)    ((0?drf) % 32)
#define DRF_MASK(drf)     (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define REF_VAL(drf,v)    (((v)>>DRF_SHIFT(drf))&DRF_MASK(drf))
#define REF_NUM(drf,n)    (((n)&DRF_MASK(drf))<<DRF_SHIFT(drf))
#endif /* !REF_VAL */

/***********************************************/
/*    #defines from the manuals                */
/***********************************************/

#define NV_PAVS                                            0x0000007F:0x00000000 /* RW--D */
#define NV_PAVS_SIZE                                       0x00000080 /* RW--V */
#define NV_PAVS_SIZE_LG2                                   0x7 /* RW--V */
#define NV_PAVS_VOICE_CFG_00                               0x00000000 /* */ 
#define NV_PAVS_VOICE_CFG_VBIN                             0x00000000 /* -W-4R */
#define NV_PAVS_VOICE_CFG_VBIN_V0BIN                       4:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V1BIN                       9:5 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V2BIN                       14:10 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V3BIN                       20:16 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V4BIN                       25:21 /* -W-UF */
#define NV_PAVS_VOICE_CFG_VBIN_V5BIN                       30:26 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT                              0x00000004 /* -W-4R */
#define NV_PAVS_VOICE_CFG_FMT_V6BIN                        4:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT_V7BIN                        9:5 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT_V6PHASE                      10:10 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_V6PHASE_POSITIVE             0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_V6PHASE_NEGATIVE             0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_V7PHASE                      11:11 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_V7PHASE_POSITIVE             0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_V7PHASE_NEGATIVE             0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_GAIN                         12:12 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_GAIN_X1                      0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_GAIN_X2                      0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM                     15:13 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC0_FLT0           0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT0           0x04 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT1           0x05 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT2           0x06 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_HEADROOM_SRC1_FLT3           0x07 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLES_PER_BLOCK            20:16 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT_MULTIPASS_BIN__ALIAS__       20:16 /* -W-UF */
#define NV_PAVS_VOICE_CFG_FMT_MULTIPASS                    21:21 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_MULTIPASS_OFF                0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_MULTIPASS_ON                 0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_LINKED_VOICE                 22:22 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_LINKED_VOICE_OFF             0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_LINKED_VOICE_ON              0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_PERSIST                      23:23 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_PERSIST_OFF                  0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_PERSIST_ON                   0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_DATA_TYPE                    24:24 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_DATA_TYPE_BUFFER             0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_DATA_TYPE_STREAM             0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_LOOP                         25:25 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_LOOP_OFF                     0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_LOOP_ON                      0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX                    26:26 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX_FALSE              0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CLEAR_MIX_TRUE               0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_STEREO                       27:27 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_STEREO_DISABLE               0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_STEREO_ENABLE                0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE                  29:28 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE_U8               0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE_S16              0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE_S24              0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_SAMPLE_SIZE_S32              0x03 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE               31:30 /* -W-VF */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE_B8            0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE_B16           0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM         0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_FMT_CONTAINER_SIZE_B32           0x03 /* -W--V */
#define NV_PAVS_VOICE_CFG_ENV0                             0x00000008 /* -W-4R */
#define NV_PAVS_VOICE_CFG_ENV0_EA_ATTACKRATE               11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV0_EA_DELAYTIME                23:12 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV0_EF_PITCHSCALE               31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVA                             0x0000000C /* -W-4R */
#define NV_PAVS_VOICE_CFG_ENVA_EA_DECAYRATE                11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVA_EA_HOLDTIME                 23:12 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVA_EA_SUSTAINLEVEL             31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV1                             0x00000010 /* -W-4R */
#define NV_PAVS_VOICE_CFG_ENV1_EF_ATTACKRATE               11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV1_EF_DELAYTIME                23:12 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENV1_EF_FCSCALE                  31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVF                             0x00000014 /* -W-4R */
#define NV_PAVS_VOICE_CFG_ENVF_EF_DECAYRATE                11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVF_EF_HOLDTIME                 23:12 /* -W-UF */
#define NV_PAVS_VOICE_CFG_ENVF_EF_SUSTAINLEVEL             31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_MISC                             0x00000018 /* -W-4R */
#define NV_PAVS_VOICE_CFG_MISC_EF_RELEASERATE              11:0 /* -W-UF */
#define NV_PAVS_VOICE_CFG_MISC_LFOA_DELAYMODE              14:14 /* -W-VF */
#define NV_PAVS_VOICE_CFG_MISC_LFOA_DELAYMODE_NORMAL       0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_LFOA_DELAYMODE_DELAY        0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_LFOF_DELAYMODE              15:15 /* -W-VF */
#define NV_PAVS_VOICE_CFG_MISC_LFOF_DELAYMODE_NORMAL       0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_LFOF_DELAYMODE_DELAY        0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE                       17:16 /* -W-VF */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_BYPASS                0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_STEREO_DLS2           0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_STEREO_P_EQ           0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_MONO_DLS2             0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_MONO_P_EQ             0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_MONO_DLS2_P_EQ        0x03 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_THREED_DLS2_I3DL2     0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_THREED_P_EQ_I3DL2     0x02 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_FMODE_THREED_I3DL2          0x03 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_BPQ                         20:18 /* -W-UF */
#define NV_PAVS_VOICE_CFG_MISC_NOTIFY_INTERRUPT            23:23 /* -W-VF */
#define NV_PAVS_VOICE_CFG_MISC_NOTIFY_INTERRUPT_DISABLE    0x00 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_NOTIFY_INTERRUPT_ENABLE     0x01 /* -W--V */
#define NV_PAVS_VOICE_CFG_MISC_V_GSCNT                     31:24 /* -W-UF */
#define NV_PAVS_VOICE_CFG_HRTF_TARGET                      0x0000001C /* -W-4R */
#define NV_PAVS_VOICE_CFG_HRTF_TARGET_HANDLE               15:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSL_START                        0x00000020 /* -W-4R */
#define NV_PAVS_VOICE_CUR_PSL_START_BA                     23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSL_START_SSLA_COUNT             7:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSL_START_SSLA_BASE              23:8 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSL_START_PS_7_0                 31:24 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE                       0x00000024 /* -W-4R */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE_LBO                   23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE_CSI                   7:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE_CSSL                  23:8 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PSH_SAMPLE_PS_15_8               31:24 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLA                             0x00000028 /* -W-4R */
#define NV_PAVS_VOICE_CUR_VOLA_VOLUME6_B3_0                3:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLA_VOLUME0                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLA_VOLUME7_B3_0                19:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLA_VOLUME1                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLB                             0x0000002C /* -W-4R */
#define NV_PAVS_VOICE_CUR_VOLB_VOLUME6_B7_4                3:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLB_VOLUME2                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLB_VOLUME7_B7_4                19:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLB_VOLUME3                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLC                             0x00000030 /* -W-4R */
#define NV_PAVS_VOICE_CUR_VOLC_VOLUME6_B11_8               3:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLC_VOLUME4                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLC_VOLUME7_B11_8               19:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_VOLC_VOLUME5                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_CUR_ECNT                             0x00000034 /* -W-4R */
#define NV_PAVS_VOICE_CUR_ECNT_EACOUNT                     15:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_ECNT_EFCOUNT                     31:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_PRD                              0x00000038 /* -W-4R */
#define NV_PAVS_VOICE_CUR_PRD_ADDRESS                      31:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FCA                              0x0000003C /* -W-4R */
#define NV_PAVS_VOICE_CUR_FCA_FC0                          15:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FCA_FC1                          31:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FCB                              0x00000040 /* -W-4R */
#define NV_PAVS_VOICE_CUR_FCB_FC2                          15:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FCB_FC3                          31:16 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSA                              0x00000044 /* -W-4R */
#define NV_PAVS_VOICE_CUR_FSA_FS0                          23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSA_FS3_B7_0                     31:24 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSB                              0x00000048 /* -W-4R */
#define NV_PAVS_VOICE_CUR_FSB_FS1                          23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSB_FS3_B15_8                    31:24 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSC                              0x0000004C /* -W-4R */
#define NV_PAVS_VOICE_CUR_FSC_FS2                          23:0 /* -W-UF */
#define NV_PAVS_VOICE_CUR_FSC_FS3_B23_16                   31:24 /* -W-UF */
#define NV_PAVS_VOICE_PAR_LFO                              0x00000050 /* -W-4R */
#define NV_PAVS_VOICE_PAR_LFO_LFOALVL                      14:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_LFO_LFOADR                       15:15 /* -W-UF */
#define NV_PAVS_VOICE_PAR_LFO_LFOFLVL                      30:16 /* -W-UF */
#define NV_PAVS_VOICE_PAR_LFO_LFOFDR                       31:31 /* -W-UF */
#define NV_PAVS_VOICE_PAR_STATE                            0x00000054 /* -W-4R */
#define NV_PAVS_VOICE_PAR_STATE_FRACTION                   15:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_STATE_LFOA_DELAYMODE             16:16 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_LFOA_DELAYMODE_NORMAL      0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_LFOA_DELAYMODE_DELAY       0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_LFOF_DELAYMODE             17:17 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_LFOF_DELAYMODE_NORMAL      0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_LFOF_DELAYMODE_DELAY       0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_PAUSED                     18:18 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_PAUSED_NO                  0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_PAUSED_YES                 0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_SSL_INDICATOR              19:19 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_SSL_INDICATOR_A            0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_SSL_INDICATOR_B            0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_NEW_VOICE                  20:20 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_NEW_VOICE_NO               0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_NEW_VOICE_YES              0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE               21:21 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE_NO            0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_ACTIVE_VOICE_YES           0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_VOICE_START                22:22 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_VOICE_START_LOOPED         0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_VOICE_START_FIRSTPASS      0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_PRD_VALID                  23:23 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_PRD_VALID_NO               0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_PRD_VALID_YES              0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR                      27:24 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_OFF                  0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_DELAY                0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_ATTACK               0x02 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_HOLD                 0x03 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_DECAY                0x04 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_SUSTAIN              0x05 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_RELEASE              0x06 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EFCUR_FORCE_RELEASE        0x07 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR                      31:28 /* -W-VF */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_OFF                  0x00 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_DELAY                0x01 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_ATTACK               0x02 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_HOLD                 0x03 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_DECAY                0x04 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_SUSTAIN              0x05 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_RELEASE              0x06 /* -W--V */
#define NV_PAVS_VOICE_PAR_STATE_EACUR_FORCE_RELEASE        0x07 /* -W--V */
#define NV_PAVS_VOICE_PAR_OFFSET                           0x00000058 /* -W-4R */
#define NV_PAVS_VOICE_PAR_OFFSET_CBO                       23:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_OFFSET_CSO                       23:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_OFFSET_EALVL                     31:24 /* -W-UF */
#define NV_PAVS_VOICE_PAR_NEXT                             0x0000005C /* -W-4R */
#define NV_PAVS_VOICE_PAR_NEXT_SSLB_COUNT                  7:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_NEXT_SSLB_BASE                   23:8 /* -W-UF */
#define NV_PAVS_VOICE_PAR_NEXT_EBO                         23:0 /* -W-UF */
#define NV_PAVS_VOICE_PAR_NEXT_EFLVL                       31:24 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLA                             0x00000060 /* -W-4R */
#define NV_PAVS_VOICE_TAR_VOLA_VOLUME6_B3_0                3:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLA_VOLUME0                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLA_VOLUME7_B3_0                19:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLA_VOLUME1                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLB                             0x00000064 /* -W-4R */
#define NV_PAVS_VOICE_TAR_VOLB_VOLUME6_B7_4                3:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLB_VOLUME2                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLB_VOLUME7_B7_4                19:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLB_VOLUME3                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLC                             0x00000068 /* -W-4R */
#define NV_PAVS_VOICE_TAR_VOLC_VOLUME6_B11_8               3:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLC_VOLUME4                     15:4 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLC_VOLUME7_B11_8               19:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_VOLC_VOLUME5                     31:20 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_ENV                          0x0000006C /* -W-4R */
#define NV_PAVS_VOICE_TAR_LFO_ENV_EA_RELEASERATE           11:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_ENV_LFOADLT                  21:12 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_ENV_LFOFDLT                  31:22 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_MOD                          0x00000070 /* -W-4R */
#define NV_PAVS_VOICE_TAR_LFO_MOD_LFOAAM                   7:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_MOD_LFOAFM                   15:8 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_MOD_LFOAFC                   23:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_LFO_MOD_LFOFFM                   31:24 /* -W-UF */
#define NV_PAVS_VOICE_TAR_FCA                              0x00000074 /* -W-4R */
#define NV_PAVS_VOICE_TAR_FCA_FC0                          15:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_FCA_FC1                          31:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_FCB                              0x00000078 /* -W-4R */
#define NV_PAVS_VOICE_TAR_FCB_FC2                          15:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_FCB_FC3                          31:16 /* -W-UF */
#define NV_PAVS_VOICE_TAR_PITCH_LINK                       0x0000007c /* -W-4R */
#define NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE     15:0 /* -W-UF */
#define NV_PAVS_VOICE_TAR_PITCH_LINK_PITCH                 31:16 /* -W-UF */
#define NV_PAHRTFC                                         0x0000035F:0x00000300 /* RW--D */
#define NV_PAHRTFC_SIZE                                    0x00000080 /* RW--V */
#define NV_PAHRTFC_SIZE_LG2                                0x7 /* RW--V */
#define NV_PAHRTFC_HRIR12A(i)                              (0x00000300+(i)*12) /* -W-4A */
#define NV_PAHRTFC_HRIR12A__SIZE_1                         7 /* */ 
#define NV_PAHRTFC_HRIR12A_LEFT0                           11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12A_RIGHT0                          23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12A_LEFT1_B7_0                      31:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12B(i)                              (0x00000304+(i)*12) /* -W-4A */
#define NV_PAHRTFC_HRIR12B__SIZE_1                         7 /* */ 
#define NV_PAHRTFC_HRIR12B_LEFT2                           11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12B_RIGHT2                          23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12B_RIGHT1_B11_8                    27:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12B_LEFT1_B11_8                     31:28 /* -W-UF */
#define NV_PAHRTFC_HRIR12C(i)                              (0x00000308+(i)*12) /* -W-4A */
#define NV_PAHRTFC_HRIR12C__SIZE_1                         7 /* */ 
#define NV_PAHRTFC_HRIR12C_LEFT3                           11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12C_RIGHT3                          23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12C_RIGHT1_B7_0                     31:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12D                                 0x00000354 /* -W-4R */
#define NV_PAHRTFC_HRIR12D_LEFT28                          11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12D_RIGHT28                         23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12D_LEFT29_B7_0                     31:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12E                                 0x00000358 /* -W-4R */
#define NV_PAHRTFC_HRIR12E_LEFT30                          11:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12E_RIGHT30                         23:12 /* -W-UF */
#define NV_PAHRTFC_HRIR12E_RIGHT29_B11_8                   27:24 /* -W-UF */
#define NV_PAHRTFC_HRIR12E_LEFT29_B11_8                    31:28 /* -W-UF */
#define NV_PAHRTFC_HRIR12X                                 0x0000035C /* -W-4R */
#define NV_PAHRTFC_HRIR12X_ITD                             15:0 /* -W-UF */
#define NV_PAHRTFC_HRIR12X_RIGHT29_B7_0                    31:24 /* -W-UF */
#define NV_PAHRTFT                                         0x000003AF:0x00000380 /* RW--D */
#define NV_PAHRTFT_SIZE                                    0x00000040 /* RW--V */
#define NV_PAHRTFT_SIZE_LG2                                0x6 /* RW--V */
#define NV_PAHRTFT_HRIR8A(i)                               (0x00000380+(i)*4) /* -W-4A */
#define NV_PAHRTFT_HRIR8A__SIZE_1                          15 /* */ 
#define NV_PAHRTFT_HRIR8A_LEFT0                            7:0 /* -W-UF */
#define NV_PAHRTFT_HRIR8A_RIGHT0                           15:8 /* -W-UF */
#define NV_PAHRTFT_HRIR8A_LEFT1                            23:16 /* -W-UF */
#define NV_PAHRTFT_HRIR8A_RIGHT1                           31:24 /* -W-UF */
#define NV_PAHRTFT_HRIR8X                                  0x000003BC /* -W-4R */
#define NV_PAHRTFT_HRIR8X_LEFT30                           7:0 /* -W-UF */
#define NV_PAHRTFT_HRIR8X_RIGHT30                          15:8 /* -W-UF */
#define NV_PAHRTFT_HRIR8X_ITD                              31:16 /* -W-UF */
#define NV_PSSL                                            0x00001FFF:0x00001000 /* RW--D */
#define NV_PSSL_SIZE                                       0x00001000 /* RW--V */
#define NV_PSSL_SIZE_LG2                                   0xc /* RW--V */
#define NV_PSSL_PRD_ADDRESS(i)                             (0x00001000+(i)*8) /* -W-4A */
#define NV_PSSL_PRD_ADDRESS__SIZE_1                        512 /* */ 
#define NV_PSSL_PRD_ADDRESS_PARAMETER                      31:0 /* -W-UF */
#define NV_PSSL_PRD_CONTROL(i)                             (0x00001004+(i)*8) /* -W-4A */
#define NV_PSSL_PRD_CONTROL__SIZE_1                        512 /* */ 
#define NV_PSSL_PRD_CONTROL_LENGTH                         15:0 /* -W-UF */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE                 17:16 /* -W-VF */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE_B8              0x00 /* -W--V */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE_B16             0x01 /* -W--V */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE_ADPCM           0x02 /* -W--V */
#define NV_PSSL_PRD_CONTROL_CONTAINER_SIZE_B32             0x03 /* -W--V */
#define NV_PSSL_PRD_CONTROL_SAMPLES_PER_BLOCK              22:18 /* -W-UF */
#define NV_PSSL_PRD_CONTROL_STEREO                         23:23 /* -W-VF */
#define NV_PSSL_PRD_CONTROL_STEREO_NOTOK                   0x00 /* -W--V */
#define NV_PSSL_PRD_CONTROL_STEREO_OK                      0x01 /* -W--V */
#define NV_PSSL_PRD_CONTROL_OWN                            24:24 /* -W-VF */
#define NV_PSSL_PRD_CONTROL_OWN_HW                         0x00 /* -W--V */
#define NV_PSSL_PRD_CONTROL_OWN_NOT_HW                     0x01 /* -W--V */
#define NV_PSSL_PRD_CONTROL_IOC                            31:31 /* -W-VF */
#define NV_PSSL_PRD_CONTROL_IOC_DISABLE                    0x00 /* -W--V */
#define NV_PSSL_PRD_CONTROL_IOC_ENABLE                     0x01 /* -W--V */
#define NV_PSGE_SIZE                                       0x00000008 /* RW--V */
#define NV_PSGE_SIZE_LG2                                   0x3 /* RW--V */
#define NV_PAPU_BITS                                       18:0 /* RW--F */
#define NV_PAPU_W                                          19 /* RW--V */
#define NV_PAPU_SAVED_BITS                                 18:2 /* RW--F */
#define NV_PAPU_SAVED_W                                    17 /* RW--V */
#define NV_PAPU_SUBSPACE_BITS                              18:16 /* RW--F */
#define NV_PAPU_SUBSPACE_PRIV                              0x00000000 /* RW--V */
#define NV_PAPU_SUBSPACE_NV1BA0                            0x00000002 /* RW--V */
#define NV_PAPU_SUBSPACE_GP                                0x00000003 /* RW--V */
#define NV_PAPU_SUBSPACE_NV1BXX                            0x00000004 /* RW--V */
#define NV_PAPU_SUBSPACE_EP                                0x00000005 /* RW--V */
#define NV_PAPU_PRIV_BITS                                  15:0 /* RW--F */
#define NV_PAPU_PRIV_SAVED_BITS                            15:2 /* RW--F */
#define NV_PAPU_PRIV_SAVED_W                               14 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_BITS                          15:12 /* RW--F */
#define NV_PAPU_PRIV_SUBUNIT_CFG                           0x00000000 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_FE                            0x00000001 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_SE                            0x00000002 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_SE_GP                         0x00000003 /* RW--V */
#define NV_PAPU_PRIV_SUBUNIT_SE_EP                         0x00000004 /* RW--V */
#define NV_PAPU_NV1BA0_BITS                                15:0 /* RW--F */
#define NV_PAPU                                            0x0007FFFF:0x00000000 /* RW--D */
#define NV_PAPU_PRIV                                       0x0000FFFF:0x00000000 /* RW--M */
#define NV_PAPU_NV1BA0                                     0x0002FFFF:0x00020000 /* RW--C */
#define NV_PAPU_GP                                         0x0003FFFF:0x00030000 /* RW--M */
#define NV_PAPU_NV1BXX                                     0x0004FFFF:0x00040000 /* RW--C */
#define NV_PAPU_EP                                         0x0005FFFF:0x00050000 /* RW--M */
#define NV_PAPU_ISTS                                       0x00001000 /* RW-4R */
#define NV_PAPU_ISTS_GINTSTS                               0:0 /* R--VF */
#define NV_PAPU_ISTS_GINTSTS_NO_INTR                       0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_GINTSTS_INTR                          0x00000001 /* R---V */
#define NV_PAPU_ISTS_DWINTSTS                              1:1 /* RW-VF */
#define NV_PAPU_ISTS_DWINTSTS_NO_INTR                      0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_DWINTSTS_INTR                         0x00000001 /* R---V */
#define NV_PAPU_ISTS_DWINTSTS_CLR                          0x00000001 /* -W--V */
#define NV_PAPU_ISTS_RTWSTS                                2:2 /* R--VF */
#define NV_PAPU_ISTS_RTWSTS_NO_INTR                        0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_RTWSTS_INTR                           0x00000001 /* R---V */
#define NV_PAPU_ISTS_DPINTSTS                              3:3 /* RW-VF */
#define NV_PAPU_ISTS_DPINTSTS_NO_INTR                      0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_DPINTSTS_INTR                         0x00000001 /* R---V */
#define NV_PAPU_ISTS_DPINTSTS_CLR                          0x00000001 /* -W--V */
#define NV_PAPU_ISTS_FETINTSTS                             4:4 /* RW-VF */
#define NV_PAPU_ISTS_FETINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_FETINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_FETINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_FENINTSTS                             5:5 /* RW-VF */
#define NV_PAPU_ISTS_FENINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_FENINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_FENINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_FEVINTSTS                             6:6 /* RW-VF */
#define NV_PAPU_ISTS_FEVINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_FEVINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_FEVINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_FEOINTSTS                             7:7 /* RW-VF */
#define NV_PAPU_ISTS_FEOINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_FEOINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_FEOINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_GPMINTSTS                             8:8 /* RW-VF */
#define NV_PAPU_ISTS_GPMINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_GPMINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_GPMINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_GPNINTSTS                             9:9 /* RW-VF */
#define NV_PAPU_ISTS_GPNINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_GPNINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_GPNINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_EPMINTSTS                             10:10 /* RW-VF */
#define NV_PAPU_ISTS_EPMINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_EPMINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_EPMINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_EPNINTSTS                             11:11 /* RW-VF */
#define NV_PAPU_ISTS_EPNINTSTS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_ISTS_EPNINTSTS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_ISTS_EPNINTSTS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_ISTS_BITS                                  11:0 /* RW-VF */
#define NV_PAPU_ISTS_MOD_BITS                              11:1 /* RW-VF */
#define NV_PAPU_ISTS_MOD_UPPER_BITS                        11:3 /* RW-VF */
#define NV_PAPU_ISTS_MOD_LOWER_BITS                        1:1 /* RW-VF */
#define NV_PAPU_IEN                                        0x00001004 /* RW-4R */
#define NV_PAPU_IEN_GINTEN                                 0:0 /* R--VF */
#define NV_PAPU_IEN_GINTEN_DISABLED                        0x00000000 /* RWI-V */
#define NV_PAPU_IEN_GINTEN_ENABLED                         0x00000001 /* RW--V */
#define NV_PAPU_IEN_DWINTEN                                1:1 /* RW-VF */
#define NV_PAPU_IEN_DWINTEN_DISABLED                       0x00000000 /* RWI-V */
#define NV_PAPU_IEN_DWINTEN_ENABLED                        0x00000001 /* RW--V */
#define NV_PAPU_IEN_DPINTEN                                3:3 /* RW-VF */
#define NV_PAPU_IEN_DPINTEN_DISABLED                       0x00000000 /* RWI-V */
#define NV_PAPU_IEN_DPINTEN_ENABLED                        0x00000001 /* RW--V */
#define NV_PAPU_IEN_FETINTEN                               4:4 /* RW-VF */
#define NV_PAPU_IEN_FETINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_FETINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_FENINTEN                               5:5 /* RW-VF */
#define NV_PAPU_IEN_FENINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_FENINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_FEVINTEN                               6:6 /* RW-VF */
#define NV_PAPU_IEN_FEVINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_FEVINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_FEOINTEN                               7:7 /* RW-VF */
#define NV_PAPU_IEN_FEOINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_FEOINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_GPMINTEN                               8:8 /* RW-VF */
#define NV_PAPU_IEN_GPMINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_GPMINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_GPNINTEN                               9:9 /* RW-VF */
#define NV_PAPU_IEN_GPNINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_GPNINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_EPMINTEN                               10:10 /* RW-VF */
#define NV_PAPU_IEN_EPMINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_EPMINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_EPNINTEN                               11:11 /* RW-VF */
#define NV_PAPU_IEN_EPNINTEN_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_IEN_EPNINTEN_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_IEN_BITS                                   11:0 /* RW-VF */
#define NV_PAPU_IEN_SETTABLE_MASK                          0x00000ffb /* RW--V */
#define NV_PAPU_ISET                                       0x00001008 /* -W-4R */
#define NV_PAPU_ISET_DWINTSET                              1:1 /* -W-VF */
#define NV_PAPU_ISET_DWINTSET_NO_INTR                      0x00000000 /* -W--V */
#define NV_PAPU_ISET_DWINTSET_INTR                         0x00000001 /* -W--V */
#define NV_PAPU_ISET_DPINTSET                              3:3 /* -W-VF */
#define NV_PAPU_ISET_DPINTSET_NO_INTR                      0x00000000 /* -W--V */
#define NV_PAPU_ISET_DPINTSET_INTR                         0x00000001 /* -W--V */
#define NV_PAPU_ISET_FETINTSET                             4:4 /* -W-VF */
#define NV_PAPU_ISET_FETINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_FETINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_FENINTSET                             5:5 /* -W-VF */
#define NV_PAPU_ISET_FENINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_FENINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_FEVINTSET                             6:6 /* -W-VF */
#define NV_PAPU_ISET_FEVINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_FEVINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_FEOINTSET                             7:7 /* -W-VF */
#define NV_PAPU_ISET_FEOINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_FEOINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_GPMINTSET                             8:8 /* -W-VF */
#define NV_PAPU_ISET_GPMINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_GPMINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_GPNINTSET                             9:9 /* -W-VF */
#define NV_PAPU_ISET_GPNINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_GPNINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_EPMINTSET                             10:10 /* -W-VF */
#define NV_PAPU_ISET_EPMINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_EPMINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_EPNINTSET                             11:11 /* -W-VF */
#define NV_PAPU_ISET_EPNINTSET_NO_INTR                     0x00000000 /* -W--V */
#define NV_PAPU_ISET_EPNINTSET_INTR                        0x00000001 /* -W--V */
#define NV_PAPU_ISET_BITS                                  11:1 /* RW-VF */
#define NV_PAPU_PRIV_FEMAJ_BITS                            11:8 /* RW--F */
#define NV_PAPU_PRIV_FEMAJ_INTR                            0x00000000 /* RW--V */
#define NV_PAPU_PRIV_FEMAJ_METH                            0x00000001 /* RW--V */
#define NV_PAPU_PRIV_FEMAJ_PERF                            0x00000002 /* RW--V */
#define NV_PAPU_PRIV_FEMAJ_INTERNAL                        0x00000003 /* RW--V */
#define NV_PAPU_PRIV_FEMAJ_UMETHFIFO                       0x00000004 /* RW--V */
#define NV_PAPU_PRIV_FEMIN_BITS                            7:0 /* RW--F */
#define NV_PAPU_FECTL                                      0x00001100 /* RW-4R */
#define NV_PAPU_FECTL_FENTYP                               0:0 /* RW-VF */
#define NV_PAPU_FECTL_FENTYP_NON_ISO                       0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FENTYP_ISO                           0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMRTYP                              1:1 /* RW-VF */
#define NV_PAPU_FECTL_FEMRTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEMRTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMWTYP                              2:2 /* RW-VF */
#define NV_PAPU_FECTL_FEMWTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEMWTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FENINT                               3:3 /* RW-VF */
#define NV_PAPU_FECTL_FENINT_DISABLED                      0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FENINT_ENABLED                       0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMETHMODE                           7:5 /* RW-VF */
#define NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING              0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEMETHMODE_HALTED                    0x00000004 /* RW--V */
#define NV_PAPU_FECTL_FEMETHMODE_TRAPPED                   0x00000007 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON                         11:8 /* RW-VF */
#define NV_PAPU_FECTL_FETRAPREASON_NONE                    0x00000000 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED         0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN          0x00000002 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT            0x00000003 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET         0x00000004 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET      0x00000005 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE           0x00000007 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER        0x00000008 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D    0x00000009 /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID           0x0000000a /* RW--V */
#define NV_PAPU_FECTL_FETRAPREASON_REQUESTED               0x0000000f /* RW--V */
#define NV_PAPU_FECTL_FEPIOCLASS                           12:12 /* RW-VF */
#define NV_PAPU_FECTL_FEPIOCLASS_NON_ISO                   0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEPIOCLASS_ISO                       0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMETH_PRIVLOCK                      13:13 /* RW-VF */
#define NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED         0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FEMETH_PRIVLOCK_DISABLED             0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FECVLOCK                             14:14 /* RW-VF */
#define NV_PAPU_FECTL_FECVLOCK_UNLOCKED                    0x00000000 /* RWI-V */
#define NV_PAPU_FECTL_FECVLOCK_LOCKED                      0x00000001 /* RW--V */
#define NV_PAPU_FECTL_FEMETHORIGIN                         15:15 /* R--VF */
#define NV_PAPU_FECTL_FEMETHORIGIN_USER                    0x00000000 /* R---V */
#define NV_PAPU_FECTL_FEMETHORIGIN_INTERNAL                0x00000001 /* R---V */
#define NV_PAPU_FECTL_FESESSLCTXPA_VALID                   16:16 /* R--VF */
#define NV_PAPU_FECTL_FESESSLCTXPA_VALID_NO                0x00000000 /* R-I-V */
#define NV_PAPU_FECTL_FESESSLCTXPA_VALID_YES               0x00000001 /* R---V */
#define NV_PAPU_FECTL_FESESGECTXPA_VALID                   17:17 /* R--VF */
#define NV_PAPU_FECTL_FESESGECTXPA_VALID_NO                0x00000000 /* R-I-V */
#define NV_PAPU_FECTL_FESESGECTXPA_VALID_YES               0x00000001 /* R---V */
#define NV_PAPU_FECTL_FEGPSGECTXPA_VALID                   18:18 /* R--VF */
#define NV_PAPU_FECTL_FEGPSGECTXPA_VALID_NO                0x00000000 /* R-I-V */
#define NV_PAPU_FECTL_FEGPSGECTXPA_VALID_YES               0x00000001 /* R---V */
#define NV_PAPU_FECTL_BITS                                 18:0 /* RW-VF */
#define NV_PAPU_FECTL_WR_BITS                              14:0 /* RW-VF */
#define NV_PAPU_FEMAXV                                     0x00001104 /* RW-4R */
#define NV_PAPU_FEMAXV_VALUE                               15:0 /* RWXUF */
#define NV_PAPU_FEMAXV_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXV_BITS                                15:0 /* RW-VF */
#define NV_PAPU_FEMAXTV                                    0x00001108 /* RW-4R */
#define NV_PAPU_FEMAXTV_VALUE                              15:0 /* RWXUF */
#define NV_PAPU_FEMAXTV_INIT                               0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXTV_BITS                               15:0 /* RW-VF */
#define NV_PAPU_FEAMAXV                                    0x0000110c /* R--4R */
#define NV_PAPU_FEAMAXV_VALUE                              15:0 /* R-XUF */
#define NV_PAPU_FEAMAXV_UNLIMITED                          0x0000ffff /* R---V */
#define NV_PAPU_FEAMAXV_BITS                               15:0 /* R--VF */
#define NV_PAPU_FECV                                       0x00001110 /* RW-4R */
#define NV_PAPU_FECV_VALUE                                 15:0 /* RWXUF */
#define NV_PAPU_FECV_VALUE_NULL                            0x0000ffff /* RWI-V */
#define NV_PAPU_FECV_BITS                                  15:0 /* RW-VF */
#define NV_PAPU_FECVDT                                     0x00001114 /* RW-4R */
#define NV_PAPU_FECVDT_DATA_TYPE                           1:0 /* RWXUF */
#define NV_PAPU_FECVDT_DATA_TYPE_BUFFER                    0x00000000 /* RW--V */
#define NV_PAPU_FECVDT_DATA_TYPE_STREAM                    0x00000001 /* RW--V */
#define NV_PAPU_FECVDT_DATA_TYPE_UNCACHED                  0x00000002 /* RWI-V */
#define NV_PAPU_FECVDT_CONTAINER_SIZE                      3:2 /* RWXUF */
#define NV_PAPU_FECVDT_CONTAINER_SIZE_B8                   0x00000000 /* RWI-V */
#define NV_PAPU_FECVDT_CONTAINER_SIZE_B16                  0x00000001 /* RW--V */
#define NV_PAPU_FECVDT_CONTAINER_SIZE_ADPCM                0x00000002 /* RW--V */
#define NV_PAPU_FECVDT_CONTAINER_SIZE_B32                  0x00000003 /* RW--V */
#define NV_PAPU_FECVDT_BITS                                3:0 /* RW-VF */
#define NV_PAPU_FEAV                                       0x00001118 /* RW-4R */
#define NV_PAPU_FEAV_VALUE                                 15:0 /* RWXUF */
#define NV_PAPU_FEAV_VALUE_NULL                            0x0000ffff /* RWI-V */
#define NV_PAPU_FEAV_LST                                   17:16 /* RWXUF */
#define NV_PAPU_FEAV_LST_INHERIT                           0x00000000 /* RWI-V */
#define NV_PAPU_FEAV_LST_2D_TOP                            0x00000001 /* RW--V */
#define NV_PAPU_FEAV_LST_3D_TOP                            0x00000002 /* RW--V */
#define NV_PAPU_FEAV_LST_MP_TOP                            0x00000003 /* RW--V */
#define NV_PAPU_FEAV_BITS                                  17:0 /* RW-VF */
#define NV_PAPU_FEMAXHT                                    0x0000111c /* RW-4R */
#define NV_PAPU_FEMAXHT_VALUE                              15:0 /* RWXUF */
#define NV_PAPU_FEMAXHT_INIT                               0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXHT_BITS                               15:0 /* RW-VF */
#define NV_PAPU_FECHT                                      0x00001120 /* RW-4R */
#define NV_PAPU_FECHT_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_FECHT_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_FECHT_BITS                                 15:0 /* RW-VF */
#define NV_PAPU_FEMAXSESSL                                 0x00001124 /* RW-4R */
#define NV_PAPU_FEMAXSESSL_VALUE                           15:0 /* RWXUF */
#define NV_PAPU_FEMAXSESSL_INIT                            0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXSESSL_BITS                            15:0 /* RW-VF */
#define NV_PAPU_FECSESSL                                   0x00001128 /* RW-4R */
#define NV_PAPU_FECSESSL_VALUE                             15:0 /* RWXUF */
#define NV_PAPU_FECSESSL_VALUE_NULL                        0x0000ffff /* RWI-V */
#define NV_PAPU_FECSESSL_BITS                              15:0 /* RW-VF */
#define NV_PAPU_FESESSLCTXPA                               0x0000112c /* RW-4R */
#define NV_PAPU_FESESSLCTXPA_VALUE                         31:12 /* RWXUF */
#define NV_PAPU_FESESSLCTXPA_BITS                          31:0 /* RW-VF */
#define NV_PAPU_FESESSLMAXOFF                              0x00001130 /* RW-4R */
#define NV_PAPU_FESESSLMAXOFF_VALUE                        31:12 /* RWXUF */
#define NV_PAPU_FESESSLMAXOFF_BITS                         31:0 /* RW-VF */
#define NV_PAPU_FESESSLPENDOFF                             0x00001134 /* RW-4R */
#define NV_PAPU_FESESSLPENDOFF_VALUE                       31:0 /* RWXUF */
#define NV_PAPU_FESESSLPENDOFF_BITS                        31:0 /* RW-VF */
#define NV_PAPU_FEMAXSESGE                                 0x00001138 /* RW-4R */
#define NV_PAPU_FEMAXSESGE_VALUE                           15:0 /* RWXUF */
#define NV_PAPU_FEMAXSESGE_INIT                            0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXSESGE_BITS                            15:0 /* RW-VF */
#define NV_PAPU_FECSESGE                                   0x0000113c /* RW-4R */
#define NV_PAPU_FECSESGE_VALUE                             15:0 /* RWXUF */
#define NV_PAPU_FECSESGE_VALUE_NULL                        0x0000ffff /* RWI-V */
#define NV_PAPU_FECSESGE_BITS                              15:0 /* RW-VF */
#define NV_PAPU_FESESGECTXPA                               0x00001140 /* RW-4R */
#define NV_PAPU_FESESGECTXPA_VALUE                         31:12 /* RWXUF */
#define NV_PAPU_FESESGECTXPA_BITS                          31:0 /* RW-VF */
#define NV_PAPU_FESESGEMAXOFF                              0x00001144 /* RW-4R */
#define NV_PAPU_FESESGEMAXOFF_VALUE                        31:12 /* RWXUF */
#define NV_PAPU_FESESGEMAXOFF_BITS                         31:0 /* RW-VF */
#define NV_PAPU_FEMAXGPSGE                                 0x00001148 /* RW-4R */
#define NV_PAPU_FEMAXGPSGE_VALUE                           15:0 /* RWXUF */
#define NV_PAPU_FEMAXGPSGE_INIT                            0x00000000 /* RWI-V */
#define NV_PAPU_FEMAXGPSGE_BITS                            15:0 /* RW-VF */
#define NV_PAPU_FECGPSGE                                   0x0000114c /* RW-4R */
#define NV_PAPU_FECGPSGE_VALUE                             15:0 /* RWXUF */
#define NV_PAPU_FECGPSGE_VALUE_NULL                        0x0000ffff /* RWI-V */
#define NV_PAPU_FECGPSGE_BITS                              15:0 /* RW-VF */
#define NV_PAPU_FEGPSGECTXPA                               0x00001150 /* RW-4R */
#define NV_PAPU_FEGPSGECTXPA_VALUE                         31:12 /* RWXUF */
#define NV_PAPU_FEGPSGECTXPA_BITS                          31:0 /* RW-VF */
#define NV_PAPU_FEGPSGEMAXOFF                              0x00001154 /* RW-4R */
#define NV_PAPU_FEGPSGEMAXOFF_VALUE                        31:12 /* RWXUF */
#define NV_PAPU_FEGPSGEMAXOFF_BITS                         31:0 /* RW-VF */
#define NV_PAPU_FEMAXMB                                    0x00001158 /* RW-4R */
#define NV_PAPU_FEMAXMB_VALUE                              5:0 /* RWXUF */
#define NV_PAPU_FEMAXMB_BITS                               5:0 /* RW-VF */
#define NV_PAPU_FENADDR                                    0x0000115c /* RW-4R */
#define NV_PAPU_FENADDR_VALUE                              31:0 /* RWXUF */
#define NV_PAPU_FENADDR_BITS                               31:0 /* RW-VF */
#define NV_PAPU_AVGBW                                      0x00001200 /* R--4R */
#define NV_PAPU_AVGBW_VALUE                                20:0 /* R-XUF */
#define NV_PAPU_AVGBW_BITS                                 20:0 /* R--VF */
#define NV_PAPU_WCBW                                       0x00001204 /* RW-4R */
#define NV_PAPU_WCBW_VALUE                                 20:0 /* RWXUF */
#define NV_PAPU_WCBW_BITS                                  20:0 /* RW-VF */
#define NV_PAPU_CURBW                                      0x00001208 /* R--4R */
#define NV_PAPU_CURBW_VALUE                                20:0 /* R-XUF */
#define NV_PAPU_CURBW_BITS                                 20:0 /* R--VF */
#define NV_PAPU_CNTBW                                      0x0000120c /* R--4R */
#define NV_PAPU_CNTBW_VALUE                                19:0 /* R-XUF */
#define NV_PAPU_CNTBW_BITS                                 19:0 /* R--VF */
#define NV_PAPU_AVGLAT                                     0x00001210 /* R--4R */
#define NV_PAPU_AVGLAT_VALUE                               13:0 /* R-XUF */
#define NV_PAPU_AVGLAT_BITS                                13:0 /* R--VF */
#define NV_PAPU_WCLAT                                      0x00001214 /* RW-4R */
#define NV_PAPU_WCLAT_VALUE                                13:0 /* RWXUF */
#define NV_PAPU_WCLAT_BITS                                 13:0 /* RW-VF */
#define NV_PAPU_CURLAT                                     0x00001218 /* R--4R */
#define NV_PAPU_CURLAT_VALUE                               23:0 /* R-XUF */
#define NV_PAPU_CURLAT_BITS                                23:0 /* R--VF */
#define NV_PAPU_CURLAT_AVGLAT_BITS                         23:10 /* R--VF */
#define NV_PAPU_CNTLAT                                     0x0000121c /* R--4R */
#define NV_PAPU_CNTLAT_VALUE                               9:0 /* R-XUF */
#define NV_PAPU_CNTLAT_VALUE_MAX                           0x000003FF /* R---V */
#define NV_PAPU_CNTLAT_BITS                                9:0 /* R--VF */
#define NV_PAPU_FEDECMETH                                  0x00001300 /* R--4R */
#define NV_PAPU_FEDECMETH_METH                             15:0 /* R-XUF */
#define NV_PAPU_FEDECMETH_PHASE                            23:16 /* R-XUF */
#define NV_PAPU_FEDECMETH_PHASE_LAST                       24:24 /* R-XUF */
#define NV_PAPU_FEDECMETH_PHASE_LAST_FALSE                 0x00000000 /* R-I-V */
#define NV_PAPU_FEDECMETH_PHASE_LAST_TRUE                  0x00000001 /* R---V */
#define NV_PAPU_FEDECMETH_VALID                            25:25 /* R-XUF */
#define NV_PAPU_FEDECMETH_VALID_FALSE                      0x00000000 /* R-I-V */
#define NV_PAPU_FEDECMETH_VALID_TRUE                       0x00000001 /* R---V */
#define NV_PAPU_FEDECMETH_BITS                             25:0 /* R--VF */
#define NV_PAPU_FEDECPARAM                                 0x00001304 /* R--4R */
#define NV_PAPU_FEDECPARAM_VALUE                           31:0 /* R-XUF */
#define NV_PAPU_FEDECPARAM_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FEDECIMMED                                 0x00001308 /* R--4R */
#define NV_PAPU_FEDECIMMED_VALUE                           31:0 /* R-XUF */
#define NV_PAPU_FEDECIMMED_BITS                            31:0 /* R--VF */
#define NV_PAPU_FESCRATCH                                  0x0000130c /* RW-4R */
#define NV_PAPU_FESCRATCH_VALUE                            31:0 /* RWXUF */
#define NV_PAPU_FESCRATCH_BITS                             31:0 /* RW-VF */
#define NV_PAPU_FESCRATCH2                                 0x00001310 /* RW-4R */
#define NV_PAPU_FESCRATCH2_VALUE                           31:0 /* RWXUF */
#define NV_PAPU_FESCRATCH2_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FESCRATCH3                                 0x00001314 /* RW-4R */
#define NV_PAPU_FESCRATCH3_VALUE                           31:0 /* RWXUF */
#define NV_PAPU_FESCRATCH3_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FESCRATCH4                                 0x00001318 /* RW-4R */
#define NV_PAPU_FESCRATCH4_VALUE                           31:0 /* RWXUF */
#define NV_PAPU_FESCRATCH4_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FEMEMADDR                                  0x00001324 /* RW-4R */
#define NV_PAPU_FEMEMADDR_VALUE                            31:0 /* RWXUF */
#define NV_PAPU_FEMEMADDR_BITS                             31:0 /* RW-VF */
#define NV_PAPU_FEMEMSZ                                    0x00001328 /* RW-4R */
#define NV_PAPU_FEMEMSZ_VALUE                              5:0 /* RWXUF */
#define NV_PAPU_FEMEMSZ_BITS                               5:0 /* RW-VF */
#define NV_PAPU_FEMEMISO                                   0x0000132c /* RW-4R */
#define NV_PAPU_FEMEMISO_WR                                0:0 /* RWXUF */
#define NV_PAPU_FEMEMISO_WR_NON_ISO                        0x00000000 /* RWI-V */
#define NV_PAPU_FEMEMISO_WR_ISO                            0x00000001 /* RW--V */
#define NV_PAPU_FEMEMISO_RD                                1:1 /* RWXUF */
#define NV_PAPU_FEMEMISO_RD_NON_ISO                        0x00000000 /* RWI-V */
#define NV_PAPU_FEMEMISO_RD_ISO                            0x00000001 /* RW--V */
#define NV_PAPU_FEMEMISO_BITS                              1:0 /* RW-VF */
#define NV_PAPU_FEMEMWE                                    0x00001330 /* RW-4R */
#define NV_PAPU_FEMEMWE_VALUE                              3:0 /* RWXUF */
#define NV_PAPU_FEMEMWE_VALUE_ALL                          0x0000000f /* RWI-V */
#define NV_PAPU_FEMEMWE_BITS                               3:0 /* RW-VF */
#define NV_PAPU_FEMEMDATA                                  0x00001334 /* RW-4R */
#define NV_PAPU_FEMEMDATA_VALUE                            31:0 /* RWXUF */
#define NV_PAPU_FEMEMDATA_BITS                             31:0 /* RW-VF */
#define NV_PAPU_FESEIDLELINKS                              0x00001338 /* R--4R */
#define NV_PAPU_FESEIDLELINKS_PREV                         15:0 /* R-XUF */
#define NV_PAPU_FESEIDLELINKS_PREV_NULL                    0x0000ffff /* R---V */
#define NV_PAPU_FESEIDLELINKS_NEXT                         31:16 /* R-XUF */
#define NV_PAPU_FESEIDLELINKS_NEXT_NULL                    0x0000ffff /* R---V */
#define NV_PAPU_FESEIDLELINKS_BITS                         31:0 /* R--VF */
#define NV_PAPU_FESENOTIFY                                 0x0000133c /* R--4R */
#define NV_PAPU_FESENOTIFY_VOICE                           15:0 /* R-XUF */
#define NV_PAPU_FESENOTIFY_SSLA_COMPLETE                   16:16 /* R-XUF */
#define NV_PAPU_FESENOTIFY_SSLA_COMPLETE_NO                0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_SSLA_COMPLETE_YES               0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_SSLB_COMPLETE                   17:17 /* R-XUF */
#define NV_PAPU_FESENOTIFY_SSLB_COMPLETE_NO                0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_SSLB_COMPLETE_YES               0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_ENVELOPE_ACTIVE                 18:18 /* R-XUF */
#define NV_PAPU_FESENOTIFY_ENVELOPE_ACTIVE_NO              0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_ENVELOPE_ACTIVE_YES             0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_SAMPLES_ACTIVE                  19:19 /* R-XUF */
#define NV_PAPU_FESENOTIFY_SAMPLES_ACTIVE_NO               0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_SAMPLES_ACTIVE_YES              0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_INTERRUPT_ENABLE                20:20 /* R-XUF */
#define NV_PAPU_FESENOTIFY_INTERRUPT_ENABLE_NO             0x00000000 /* R---V */
#define NV_PAPU_FESENOTIFY_INTERRUPT_ENABLE_YES            0x00000001 /* R---V */
#define NV_PAPU_FESENOTIFY_BITS                            20:0 /* R--VF */
#define NV_PAPU_FEUFIFOCTL                                 0x00001340 /* RW-4R */
#define NV_PAPU_FEUFIFOCTL_COUNT                           5:0 /* RWXUF */
#define NV_PAPU_FEUFIFOCTL_HEAD                            12:8 /* RWXUF */
#define NV_PAPU_FEUFIFOCTL_HEAD_LSB                        8:8 /* RWXUF */
#define NV_PAPU_FEUFIFOCTL_TAIL                            20:16 /* RWXUF */
#define NV_PAPU_FEUFIFOCTL_BITS                            20:0 /* RW-VF */
#define NV_PAPU_FEUFIFOMETH(i)                             (0x00001400+(i)*8) /* -W-4A */
#define NV_PAPU_FEUFIFOMETH__SIZE_1                        32 /* */ 
#define NV_PAPU_FEUFIFOMETH_VALUE                          31:0 /* RWI-V */
#define NV_PAPU_FEUFIFOMETH_BITS                           31:0 /* RW-VF */
#define NV_PAPU_FEUFIFOMETH_ADDR_BITS                      7:0 /* */ 
#define NV_PAPU_FEUFIFOMETH_ADDR_SAVED_BITS                7:2 /* */ 
#define NV_PAPU_FEUFIFOPARAM(i)                            (0x00001404+(i)*8) /* -W-4A */
#define NV_PAPU_FEUFIFOPARAM__SIZE_1                       32 /* */ 
#define NV_PAPU_FEUFIFOPARAM_VALUE                         31:0 /* RWI-V */
#define NV_PAPU_FEUFIFOPARAM_BITS                          31:0 /* RW-VF */
#define NV_PAPU_FETFORCE0                                  0x00001500 /* RW-4R */
#define NV_PAPU_FETFORCE0_NOP                              0:0 /* RWXUF */
#define NV_PAPU_FETFORCE0_SYNCHRONIZE                      1:1 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_TIME                         2:2 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_MODE                         3:3 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_CURRENT_VOICE                4:4 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_ANTECEDENT_VOICE             5:5 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_ON                         6:6 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_OFF                        7:7 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_RELEASE                    8:8 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_PAUSE                      9:9 /* RWXUF */
#define NV_PAPU_FETFORCE0_GET_VOICE_POSITION               10:10 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_SUBMIX_HEADROOM              11:11 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_HRTF_SUBMIXES                12:12 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_HRTF_HEADROOM                13:13 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOLUME_TRACKING              14:14 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_PITCH_TRACKING               15:15 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_HRTF_TRACKING                16:16 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_ITD_TRACKING                 17:17 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_FILTER_TRACKING              18:18 /* RWXUF */
#define NV_PAPU_FETFORCE0_VOICE_LOCK                       19:19 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_CFG_VBIN               20:20 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_CFG_FMT                21:21 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_CFG_OTHER              22:22 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_TAR_HRTF               23:23 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_PAR_LFODLY             24:24 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_SSL                    25:25 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_CFG_BUF                26:26 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_TAR_VOL                27:27 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_LFO                    28:28 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_TAR_FC                 29:29 /* RWXUF */
#define NV_PAPU_FETFORCE0_SET_VOICE_TAR_PITCH              30:30 /* RWXUF */
#define NV_PAPU_FETFORCE0_BITS                             30:0 /* RW-VF */
#define NV_PAPU_FETFORCE1                                  0x00001504 /* RW-4R */
#define NV_PAPU_FETFORCE1_SET_CURRENT_HRTF_ENTRY           0:0 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_HRIR                         1:1 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_HRIR_X                       2:2 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_SSL_CONTEXT_DMA      3:3 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_SSL                  4:4 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_SSL_SEGMENT_OFFSET           5:5 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_SSL_SEGMENT_LENGTH           6:6 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_INBUF_SGE_CONTEXT_DMA 7:7 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_INBUF_SGE            8:8 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_INBUF_SGE_OFFSET     9:9 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA 10:10 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_OUTBUF_SGE           11:11 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_OUTBUF_BA                    12:12 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_OUTBUF_LEN                   13:13 /* RWXUF */
#define NV_PAPU_FETFORCE1_SET_CURRENT_OUTBUF_SGE_OFFSET    14:14 /* RWXUF */
#define NV_PAPU_FETFORCE1_SE2FE_IDLE_VOICE                 15:15 /* RWXUF */
#define NV_PAPU_FETFORCE1_SE2FE_NOTIFY                     16:16 /* RWXUF */
#define NV_PAPU_FETFORCE1_SE2FE_RTINTR                     17:17 /* RWXUF */
#define NV_PAPU_FETFORCE1_UNKNOWN                          18:18 /* RWXUF */
#define NV_PAPU_FETFORCE1_BITS                             18:0 /* RW-VF */
#define NV_PAPU_FETIGNORE0                                 0x00001508 /* RW-4R */
#define NV_PAPU_FETIGNORE0_NOP                             0:0 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SYNCHRONIZE                     1:1 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_TIME                        2:2 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_MODE                        3:3 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_CURRENT_VOICE               4:4 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_ANTECEDENT_VOICE            5:5 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_ON                        6:6 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_OFF                       7:7 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_RELEASE                   8:8 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_PAUSE                     9:9 /* RWXUF */
#define NV_PAPU_FETIGNORE0_GET_VOICE_POSITION              10:10 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_SUBMIX_HEADROOM             11:11 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_HRTF_SUBMIXES               12:12 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_HRTF_HEADROOM               13:13 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOLUME_TRACKING             14:14 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_PITCH_TRACKING              15:15 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_HRTF_TRACKING               16:16 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_ITD_TRACKING                17:17 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_FILTER_TRACKING             18:18 /* RWXUF */
#define NV_PAPU_FETIGNORE0_VOICE_LOCK                      19:19 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_CFG_VBIN              20:20 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_CFG_FMT               21:21 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_CFG_OTHER             22:22 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_TAR_HRTF              23:23 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_PAR_LFODLY            24:24 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_SSL                   25:25 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_CFG_BUF               26:26 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_TAR_VOL               27:27 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_LFO                   28:28 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_TAR_FC                29:29 /* RWXUF */
#define NV_PAPU_FETIGNORE0_SET_VOICE_TAR_PITCH             30:30 /* RWXUF */
#define NV_PAPU_FETIGNORE0_BITS                            30:0 /* RW-VF */
#define NV_PAPU_FETIGNORE1                                 0x0000150c /* RW-4R */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_HRTF_ENTRY          0:0 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_HRIR                        1:1 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_HRIR_X                      2:2 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_SSL_CONTEXT_DMA     3:3 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_SSL                 4:4 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_SSL_SEGMENT_OFFSET          5:5 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_SSL_SEGMENT_LENGTH          6:6 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_INBUF_SGE_CONTEXT_DMA 7:7 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_INBUF_SGE           8:8 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_INBUF_SGE_OFFSET    9:9 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA 10:10 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_OUTBUF_SGE          11:11 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_OUTBUF_BA                   12:12 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_OUTBUF_LEN                  13:13 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SET_CURRENT_OUTBUF_SGE_OFFSET   14:14 /* RWXUF */
#define NV_PAPU_FETIGNORE1_SE2FE_IDLE_VOICE                15:15 /* RWXUF */
#define NV_PAPU_FETIGNORE1_UNKNOWN                         18:18 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_NOT_IMPLEMENTED      22:22 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_METHOD_UNKNOWN       23:23 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_BAD_ARGUMENT         24:24 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_CURRENT_NOT_SET      25:25 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_ANTECEDENT_NOT_SET   26:26 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_BAD_DATA_TYPE        28:28 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_BAD_LIST_POINTER     29:29 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_CURRENT_VOICE_NOT_3D 30:30 /* RWXUF */
#define NV_PAPU_FETIGNORE1_TRAPREASON_CTXPA_INVALID        31:31 /* RWXUF */
#define NV_PAPU_FETIGNORE1_BITS                            31:0 /* RW-VF */
#define NV_PAPU_FEPRIVLOCK                                 0x00001510 /* RW-4R */
#define NV_PAPU_FEPRIVLOCK_VALUE                           0:0 /* RWXUF */
#define NV_PAPU_FEPRIVLOCK_VALUE_UNLOCKED                  0x00000000 /* RWI-V */
#define NV_PAPU_FEPRIVLOCK_VALUE_LOCKED                    0x00000001 /* RW--V */
#define NV_PAPU_FEPRIVLOCK_BITS                            0:0 /* RW-VF */
#define NV_PAPU_SECTL                                      0x00002000 /* RW-4R */
#define NV_PAPU_SECTL_SEPRTYP                              0:0 /* RW-VF */
#define NV_PAPU_SECTL_SEPRTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_SECTL_SEPRTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_SECTL_SEPWTYP                              1:1 /* RW-VF */
#define NV_PAPU_SECTL_SEPWTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_SECTL_SEPWTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_SECTL_SESRTYP                              2:2 /* RW-VF */
#define NV_PAPU_SECTL_SESRTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_SECTL_SESRTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_SECTL_XCNTMODE                             4:3 /* RW-VF */
#define NV_PAPU_SECTL_XCNTMODE_OFF                         0x00000000 /* RWI-V */
#define NV_PAPU_SECTL_XCNTMODE_AC_SYNC                     0x00000001 /* RW--V */
#define NV_PAPU_SECTL_XCNTMODE_SW                          0x00000002 /* RW--V */
#define NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING                0x00000003 /* RW--V */
#define NV_PAPU_STID                                       0x00002004 /* R--4R */
#define NV_PAPU_STID_SESTART                               0:0 /* R--VF */
#define NV_PAPU_STID_SESTART_NOT_STARTING                  0x00000000 /* R-I-V */
#define NV_PAPU_STID_SESTART_STARTING                      0x00000001 /* R---V */
#define NV_PAPU_STID_SEIDLE                                1:1 /* R--VF */
#define NV_PAPU_STID_SEIDLE_IDLE                           0x00000001 /* R-I-V */
#define NV_PAPU_STID_SEIDLE_NOT_IDLE                       0x00000000 /* R---V */
#define NV_PAPU_STID_VPSTART                               2:2 /* R--VF */
#define NV_PAPU_STID_VPSTART_NOT_STARTING                  0x00000000 /* R-I-V */
#define NV_PAPU_STID_VPSTART_STARTING                      0x00000001 /* R---V */
#define NV_PAPU_STID_VPIDLE                                3:3 /* R--VF */
#define NV_PAPU_STID_VPIDLE_IDLE                           0x00000001 /* R-I-V */
#define NV_PAPU_STID_VPIDLE_NOT_IDLE                       0x00000000 /* R---V */
#define NV_PAPU_STID_GPSTART                               4:4 /* R--VF */
#define NV_PAPU_STID_GPSTART_NOT_STARTING                  0x00000000 /* R-I-V */
#define NV_PAPU_STID_GPSTART_STARTING                      0x00000001 /* R---V */
#define NV_PAPU_STID_GPIDLE                                5:5 /* R--VF */
#define NV_PAPU_STID_GPIDLE_IDLE                           0x00000001 /* R-I-V */
#define NV_PAPU_STID_GPIDLE_NOT_IDLE                       0x00000000 /* R---V */
#define NV_PAPU_STID_EPSTART                               6:6 /* R--VF */
#define NV_PAPU_STID_EPSTART_NOT_STARTING                  0x00000000 /* R-I-V */
#define NV_PAPU_STID_EPSTART_STARTING                      0x00000001 /* R---V */
#define NV_PAPU_STID_EPIDLE                                7:7 /* R--VF */
#define NV_PAPU_STID_EPIDLE_IDLE                           0x00000001 /* R-I-V */
#define NV_PAPU_STID_EPIDLE_NOT_IDLE                       0x00000000 /* R---V */
#define NV_PAPU_IGSCNT                                     0x00002008 /* RW-4R */
#define NV_PAPU_IGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_IGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_XGSCNT                                     0x0000200C /* RW-4R */
#define NV_PAPU_XGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_XGSCNT_INIT                                0xFFFFFFFF /* RWI-V */
#define NV_PAPU_DGSCNT                                     0x00002010 /* RW-4R */
#define NV_PAPU_DGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_DGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_WGSCNT                                     0x00002014 /* RW-4R */
#define NV_PAPU_WGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_WGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_RGSCNT                                     0x00002018 /* RW-4R */
#define NV_PAPU_RGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_RGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_PGSCNT                                     0x0000201C /* RW-4R */
#define NV_PAPU_PGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_PGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_EGSCNT                                     0x00002020 /* RW-4R */
#define NV_PAPU_EGSCNT_VALUE                               31:0 /* RWXUF */
#define NV_PAPU_EGSCNT_INIT                                0x00000000 /* RWI-V */
#define NV_PAPU_DEGSCNT                                    0x00002024 /* RW-4R */
#define NV_PAPU_DEGSCNT_VALUE                              31:0 /* RWXUF */
#define NV_PAPU_DEGSCNT_INIT                               0x00000000 /* RWI-V */
#define NV_PAPU_ECNTSTP                                    0x00002028 /* RW-4R */
#define NV_PAPU_ECNTSTP_VALUE                              15:0 /* RWXUF */
#define NV_PAPU_VPVADDR                                    0x0000202C /* RW-4R */
#define NV_PAPU_VPVADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_VPSGEADDR                                  0x00002030 /* RW-4R */
#define NV_PAPU_VPSGEADDR_VALUE                            31:14 /* RWXUF */
#define NV_PAPU_VPSSLADDR                                  0x00002034 /* RW-4R */
#define NV_PAPU_VPSSLADDR_VALUE                            31:14 /* RWXUF */
#define NV_PAPU_VPHTADDR                                   0x00002038 /* RW-4R */
#define NV_PAPU_VPHTADDR_VALUE                             31:14 /* RWXUF */
#define NV_PAPU_VPHCADDR                                   0x0000203C /* RW-4R */
#define NV_PAPU_VPHCADDR_VALUE                             31:14 /* RWXUF */
#define NV_PAPU_GPSADDR                                    0x00002040 /* RW-4R */
#define NV_PAPU_GPSADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_GPFADDR                                    0x00002044 /* RW-4R */
#define NV_PAPU_GPFADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_EPSADDR                                    0x00002048 /* RW-4R */
#define NV_PAPU_EPSADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_EPFADDR                                    0x0000204C /* RW-4R */
#define NV_PAPU_EPFADDR_VALUE                              31:14 /* RWXUF */
#define NV_PAPU_VLOCK                                      0x00002050 /* RW-4R */
#define NV_PAPU_VLOCK_VOICE                                15:0 /* RW-VF */
#define NV_PAPU_VLOCK_REQ                                  16:16 /* RW-VF */
#define NV_PAPU_VLOCK_REQ_LOCK                             0x00000001 /* RW--V */
#define NV_PAPU_VLOCK_REQ_UNLOCK                           0x00000000 /* RWI-V */
#define NV_PAPU_VLOCK_STATUS                               17:17 /* RW-VF */
#define NV_PAPU_VLOCK_STATUS_NOT_IN_PROGRESS               0x00000000 /* RW--V */
#define NV_PAPU_VLOCK_STATUS_IN_PROGRESS                   0x00000001 /* RWI-V */
#define NV_PAPU_TVL2D                                      0x00002054 /* RW-4R */
#define NV_PAPU_TVL2D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_TVL2D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_CVL2D                                      0x00002058 /* RW-4R */
#define NV_PAPU_CVL2D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_CVL2D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_NVL2D                                      0x0000205C /* RW-4R */
#define NV_PAPU_NVL2D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_NVL2D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_TVL3D                                      0x00002060 /* RW-4R */
#define NV_PAPU_TVL3D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_TVL3D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_CVL3D                                      0x00002064 /* RW-4R */
#define NV_PAPU_CVL3D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_CVL3D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_NVL3D                                      0x00002068 /* RW-4R */
#define NV_PAPU_NVL3D_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_NVL3D_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_TVLMP                                      0x0000206C /* RW-4R */
#define NV_PAPU_TVLMP_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_TVLMP_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_CVLMP                                      0x00002070 /* RW-4R */
#define NV_PAPU_CVLMP_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_CVLMP_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_NVLMP                                      0x00002074 /* RW-4R */
#define NV_PAPU_NVLMP_VALUE                                15:0 /* RWXUF */
#define NV_PAPU_NVLMP_VALUE_NULL                           0x0000ffff /* RWI-V */
#define NV_PAPU_ALPHAV                                     0x00002078 /* RW-4R */
#define NV_PAPU_ALPHAV_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_ALPHAP                                     0x0000207C /* RW-4R */
#define NV_PAPU_ALPHAP_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_ALPHAF                                     0x00002080 /* RW-4R */
#define NV_PAPU_ALPHAF_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_ALPHAI                                     0x00002084 /* RW-4R */
#define NV_PAPU_ALPHAI_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_ALPHAH                                     0x00002088 /* RW-4R */
#define NV_PAPU_ALPHAH_VALUE                               11:0 /* RWXUF */
#define NV_PAPU_MIXHRA                                     0x0000208C /* RW-4R */
#define NV_PAPU_MIXHRA_MHR0                                2:0 /* RWXUF */
#define NV_PAPU_MIXHRA_MHR0_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRA_MHR1                                10:8 /* RWXUF */
#define NV_PAPU_MIXHRA_MHR1_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRA_MHR2                                18:16 /* RWXUF */
#define NV_PAPU_MIXHRA_MHR2_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRA_MHR3                                26:24 /* RWXUF */
#define NV_PAPU_MIXHRA_MHR3_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRB                                     0x00002090 /* RW-4R */
#define NV_PAPU_MIXHRB_MHR4                                2:0 /* RWXUF */
#define NV_PAPU_MIXHRB_MHR4_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRB_MHR5                                10:8 /* RWXUF */
#define NV_PAPU_MIXHRB_MHR5_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRB_MHR6                                18:16 /* RWXUF */
#define NV_PAPU_MIXHRB_MHR6_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRB_MHR7                                26:24 /* RWXUF */
#define NV_PAPU_MIXHRB_MHR7_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRC                                     0x00002094 /* RW-4R */
#define NV_PAPU_MIXHRC_MHR8                                2:0 /* RWXUF */
#define NV_PAPU_MIXHRC_MHR8_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRC_MHR9                                10:8 /* RWXUF */
#define NV_PAPU_MIXHRC_MHR9_INIT                           0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRC_MHR10                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRC_MHR10_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRC_MHR11                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRC_MHR11_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRD                                     0x00002098 /* RW-4R */
#define NV_PAPU_MIXHRD_MHR12                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRD_MHR12_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRD_MHR13                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRD_MHR13_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRD_MHR14                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRD_MHR14_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRD_MHR15                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRD_MHR15_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRE                                     0x0000209C /* RW-4R */
#define NV_PAPU_MIXHRE_MHR16                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRE_MHR16_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRE_MHR17                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRE_MHR17_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRE_MHR18                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRE_MHR18_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRE_MHR19                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRF                                     0x000020A0 /* RW-4R */
#define NV_PAPU_MIXHRF_MHR19_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRF_MHR20                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRF_MHR20_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRF_MHR21                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRF_MHR21_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRF_MHR22                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRF_MHR22_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRF_MHR23                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRF_MHR23_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRG                                     0x000020A4 /* RW-4R */
#define NV_PAPU_MIXHRG_MHR24                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRG_MHR24_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRG_MHR25                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRG_MHR25_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRG_MHR26                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRG_MHR26_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRG_MHR27                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRG_MHR27_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRH                                     0x000020A8 /* RW-4R */
#define NV_PAPU_MIXHRH_MHR28                               2:0 /* RWXUF */
#define NV_PAPU_MIXHRH_MHR28_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRH_MHR29                               10:8 /* RWXUF */
#define NV_PAPU_MIXHRH_MHR29_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRH_MHR30                               18:16 /* RWXUF */
#define NV_PAPU_MIXHRH_MHR30_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIXHRH_MHR31                               26:24 /* RWXUF */
#define NV_PAPU_MIXHRH_MHR31_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_MIX3D                                      0x000020AC /* RW-4R */
#define NV_PAPU_MIX3D_SMX3DFL                              4:0 /* RWXUF */
#define NV_PAPU_MIX3D_SMX3DFL_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_MIX3D_SMX3DFR                              12:8 /* RWXUF */
#define NV_PAPU_MIX3D_SMX3DFR_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_MIX3D_SMX3DRL                              20:16 /* RWXUF */
#define NV_PAPU_MIX3D_SMX3DRL_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_MIX3D_SMX3DRR                              28:24 /* RWXUF */
#define NV_PAPU_MIX3D_SMX3DRR_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_TDHR                                       0x000020B0 /* RW-4R */
#define NV_PAPU_TDHR_TDHR                                  2:0 /* RWXUF */
#define NV_PAPU_TDHR_TDHR_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_AVGSESTI                                   0x000020B4 /* RW-4R */
#define NV_PAPU_AVGSESTI_VALUE                             31:0 /* RWXUF */
#define NV_PAPU_WCSESTI                                    0x000020B8 /* RW-4R */
#define NV_PAPU_WCSESTI_VALUE                              31:0 /* RWXUF */
#define NV_PAPU_CURSESTI                                   0x000020BC /* RW-4R */
#define NV_PAPU_CURSESTI_VALUE                             31:0 /* RWXUF */
#define NV_PAPU_CNTSESTI                                   0x000020C0 /* RW-4R */
#define NV_PAPU_CNTSESTI_VALUE                             7:0 /* RWXUF */
#define NV_PAPU_AVGGPSTI                                   0x000020C4 /* RW-4R */
#define NV_PAPU_AVGGPSTI_VALUE                             31:0 /* RWXUF */
#define NV_PAPU_WCGPSTI                                    0x000020C8 /* RW-4R */
#define NV_PAPU_WCGPSTI_VALUE                              31:0 /* RWXUF */
#define NV_PAPU_CURGPSTI                                   0x000020CC /* RW-4R */
#define NV_PAPU_CURGPSTI_VALUE                             31:0 /* RWXUF */
#define NV_PAPU_CNTGPSTI                                   0x000020D0 /* RW-4R */
#define NV_PAPU_CNTGPSTI_VALUE                             7:0 /* RWXUF */
#define NV_PAPU_GPSMAXSGE                                  0x000020D4 /* RW-4R */
#define NV_PAPU_GPSMAXSGE_VALUE                            15:0 /* RWXUF */
#define NV_PAPU_GPSMAXSGE_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_GPSMAXSGE_BITS                             15:0 /* RW-VF */
#define NV_PAPU_GPFMAXSGE                                  0x000020D8 /* RW-4R */
#define NV_PAPU_GPFMAXSGE_VALUE                            15:0 /* RWXUF */
#define NV_PAPU_GPFMAXSGE_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_GPFMAXSGE_BITS                             15:0 /* RW-VF */
#define NV_PAPU_EPSMAXSGE                                  0x000020DC /* RW-4R */
#define NV_PAPU_EPSMAXSGE_VALUE                            15:0 /* RWXUF */
#define NV_PAPU_EPSMAXSGE_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_EPSMAXSGE_BITS                             15:0 /* RW-VF */
#define NV_PAPU_EPFMAXSGE                                  0x000020E0 /* RW-4R */
#define NV_PAPU_EPFMAXSGE_VALUE                            15:0 /* RWXUF */
#define NV_PAPU_EPFMAXSGE_INIT                             0x00000000 /* RWI-V */
#define NV_PAPU_EPFMAXSGE_BITS                             15:0 /* RW-VF */
#define NV_PAPU_GPNADDR                                    0x00003004 /* RW-4R */
#define NV_PAPU_GPNADDR_VALUE                              31:12 /* RWXUF */
#define NV_PAPU_GPCADDR                                    0x00003014 /* RW-4R */
#define NV_PAPU_GPCADDR_VALUE                              31:12 /* RWXUF */
#define NV_PAPU_GPOFBASE0                                  0x00003024 /* RW-4R */
#define NV_PAPU_GPOFBASE0_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPOFBASE1                                  0x00003034 /* RW-4R */
#define NV_PAPU_GPOFBASE1_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPOFBASE2                                  0x00003044 /* RW-4R */
#define NV_PAPU_GPOFBASE2_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPOFBASE3                                  0x00003054 /* RW-4R */
#define NV_PAPU_GPOFBASE3_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPOFEND0                                   0x00003028 /* RW-4R */
#define NV_PAPU_GPOFEND0_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPOFEND1                                   0x00003038 /* RW-4R */
#define NV_PAPU_GPOFEND1_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPOFEND2                                   0x00003048 /* RW-4R */
#define NV_PAPU_GPOFEND2_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPOFEND3                                   0x00003058 /* RW-4R */
#define NV_PAPU_GPOFEND3_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPOFCUR0                                   0x0000302C /* RW-4R */
#define NV_PAPU_GPOFCUR0_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPOFCUR1                                   0x0000303C /* RW-4R */
#define NV_PAPU_GPOFCUR1_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPOFCUR2                                   0x0000304C /* RW-4R */
#define NV_PAPU_GPOFCUR2_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPOFCUR3                                   0x0000305C /* RW-4R */
#define NV_PAPU_GPOFCUR3_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPIFBASE0                                  0x00003064 /* RW-4R */
#define NV_PAPU_GPIFBASE0_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPIFBASE1                                  0x00003074 /* RW-4R */
#define NV_PAPU_GPIFBASE1_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_GPIFEND0                                   0x00003068 /* RW-4R */
#define NV_PAPU_GPIFEND0_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPIFEND1                                   0x00003078 /* RW-4R */
#define NV_PAPU_GPIFEND1_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_GPIFCUR0                                   0x0000306C /* RW-4R */
#define NV_PAPU_GPIFCUR0_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPIFCUR1                                   0x0000307C /* RW-4R */
#define NV_PAPU_GPIFCUR1_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPNADDR                                    0x00004004 /* RW-4R */
#define NV_PAPU_EPNADDR_VALUE                              31:12 /* RWXUF */
#define NV_PAPU_EPCADDR                                    0x00004014 /* RW-4R */
#define NV_PAPU_EPCADDR_VALUE                              31:12 /* RWXUF */
#define NV_PAPU_EPOFBASE0                                  0x00004024 /* RW-4R */
#define NV_PAPU_EPOFBASE0_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPOFBASE1                                  0x00004034 /* RW-4R */
#define NV_PAPU_EPOFBASE1_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPOFBASE2                                  0x00004044 /* RW-4R */
#define NV_PAPU_EPOFBASE2_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPOFBASE3                                  0x00004054 /* RW-4R */
#define NV_PAPU_EPOFBASE3_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPOFEND0                                   0x00004028 /* RW-4R */
#define NV_PAPU_EPOFEND0_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPOFEND1                                   0x00004038 /* RW-4R */
#define NV_PAPU_EPOFEND1_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPOFEND2                                   0x00004048 /* RW-4R */
#define NV_PAPU_EPOFEND2_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPOFEND3                                   0x00004058 /* RW-4R */
#define NV_PAPU_EPOFEND3_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPOFCUR0                                   0x0000402C /* RW-4R */
#define NV_PAPU_EPOFCUR0_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPOFCUR1                                   0x0000403C /* RW-4R */
#define NV_PAPU_EPOFCUR1_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPOFCUR2                                   0x0000404C /* RW-4R */
#define NV_PAPU_EPOFCUR2_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPOFCUR3                                   0x0000405C /* RW-4R */
#define NV_PAPU_EPOFCUR3_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPIFBASE0                                  0x00004064 /* RW-4R */
#define NV_PAPU_EPIFBASE0_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPIFBASE1                                  0x00004074 /* RW-4R */
#define NV_PAPU_EPIFBASE1_VALUE                            23:8 /* RWXUF */
#define NV_PAPU_EPIFEND0                                   0x00004068 /* RW-4R */
#define NV_PAPU_EPIFEND0_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPIFEND1                                   0x00004078 /* RW-4R */
#define NV_PAPU_EPIFEND1_VALUE                             23:8 /* RWXUF */
#define NV_PAPU_EPIFCUR0                                   0x0000406C /* RW-4R */
#define NV_PAPU_EPIFCUR0_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_EPIFCUR1                                   0x0000407C /* RW-4R */
#define NV_PAPU_EPIFCUR1_VALUE                             23:2 /* RWXUF */
#define NV_PAPU_GPXMEM(i)                                  (0x30000+4*(i)) /* RW--M */
#define NV_PAPU_GPXMEM__SIZE_1                             0x1000 /* */ 
#define NV_PAPU_GPMIXBUF(i)                                (0x35000+4*(i)) /* R---M */
#define NV_PAPU_GPMIXBUF__SIZE_1                           0x0400 /* */ 
#define NV_PAPU_GPYMEM(i)                                  (0x36000+4*(i)) /* RW--M */
#define NV_PAPU_GPYMEM__SIZE_1                             0x0800 /* */ 
#define NV_PAPU_GPPMEM(i)                                  (0x3A000+4*(i)) /* RW--M */
#define NV_PAPU_GPPMEM__SIZE_1                             0x1000 /* */ 
#define NV_PAPU_GPRST                                      0x0003FFFC /* RW-4R */
#define NV_PAPU_GPRST_GPRST                                0:0 /* RW-VF */
#define NV_PAPU_GPRST_GPRST_ENABLED                        0x00000000 /* RWI-V */
#define NV_PAPU_GPRST_GPRST_DISABLED                       0x00000001 /* RW--V */
#define NV_PAPU_GPRST_GPDSPRST                             1:1 /* RW-VF */
#define NV_PAPU_GPRST_GPDSPRST_ENABLED                     0x00000000 /* RWI-V */
#define NV_PAPU_GPRST_GPDSPRST_DISABLED                    0x00000001 /* RW--V */
#define NV_PAPU_GPRST_GPNMI                                2:2 /* -W-VF */
#define NV_PAPU_GPRST_GPNMI_DISABLED                       0x00000000 /* -WI-V */
#define NV_PAPU_GPRST_GPNMI_ENABLED                        0x00000001 /* -W--V */
#define NV_PAPU_GPRST_GPABORT                              3:3 /* -W-VF */
#define NV_PAPU_GPRST_GPABORT_DISABLED                     0x00000000 /* -WI-V */
#define NV_PAPU_GPRST_GPABORT_ENABLED                      0x00000001 /* -W--V */
#define NV_PAPU_GPCTLG                                     0x0003FF28 /* RW-4R */
#define NV_PAPU_GPCTLG_GPSTYP                              0:0 /* RW-VF */
#define NV_PAPU_GPCTLG_GPSTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLG_GPSTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_GPCTLG_SPARE                               23:1 /* RW-UF */
#define NV_PAPU_GPCTLG_SPARE_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT                                   0x0003FF20 /* RW-4R */
#define NV_PAPU_GPCTLOUT_GD0FMT                            1:0 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD0FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD0FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD0FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD0FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLOUT_GP0TYP                            2:2 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GP0TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GP0TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD0SIZ                            4:3 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD0SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD0SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD0SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1FMT                            6:5 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD1FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD1FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLOUT_GP1TYP                            7:7 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GP1TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GP1TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1SIZ                            9:8 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD1SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD1SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD1SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2FMT                            11:10 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD2FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD2FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLOUT_GP2TYP                            12:12 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GP2TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GP2TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2SIZ                            14:13 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD2SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD2SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD2SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3FMT                            16:15 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD3FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD3FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLOUT_GP3TYP                            17:17 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GP3TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GP3TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3SIZ                            19:18 /* RW-VF */
#define NV_PAPU_GPCTLOUT_GD3SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLOUT_GD3SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLOUT_GD3SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLOUT_SPARE                             23:20 /* RW-UF */
#define NV_PAPU_GPCTLOUT_SPARE_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN                                    0x0003FF24 /* RW-4R */
#define NV_PAPU_GPCTLIN_GDI0FMT                            1:0 /* RW-VF */
#define NV_PAPU_GPCTLIN_GDI0FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GDI0FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI0FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI0FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLIN_GPI0TYP                            2:2 /* RW-VF */
#define NV_PAPU_GPCTLIN_GPI0TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GPI0TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI0SIZ                            4:3 /* RW-VF */
#define NV_PAPU_GPCTLIN_GDI0SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GDI0SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI0SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1FMT                            6:5 /* RW-VF */
#define NV_PAPU_GPCTLIN_GDI1FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GDI1FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_GPCTLIN_GPI1TYP                            7:7 /* RW-VF */
#define NV_PAPU_GPCTLIN_GPI1TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GPI1TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1SIZ                            9:8 /* RW-VF */
#define NV_PAPU_GPCTLIN_GDI1SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_GPCTLIN_GDI1SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_GPCTLIN_GDI1SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_GPCTLIN_SPARE                              23:10 /* RW-UF */
#define NV_PAPU_GPCTLIN_SPARE_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_GPMBO                                      0x0003FF08 /* RW-4R */
#define NV_PAPU_GPMBO_VALUE                                23:0 /* RWXUF */
#define NV_PAPU_GPMBI                                      0x0003FF0C /* RW-4R */
#define NV_PAPU_GPMBI_VALUE                                23:0 /* RWXUF */
#define NV_PAPU_GPGET                                      0x0003FF00 /* RW-4R */
#define NV_PAPU_GPGET_VALUE                                11:2 /* RWXUF */
#define NV_PAPU_GPPUT                                      0x0003FF04 /* RW-4R */
#define NV_PAPU_GPPUT_VALUE                                11:2 /* RWXUF */
#define NV_PAPU_GPIDRDY                                    0x0003FF10 /* RW-4R */
#define NV_PAPU_GPIDRDY_GPSETIDLE                          0:0 /* RW-VF */
#define NV_PAPU_GPIDRDY_GPSETIDLE_NOT_SET                  0x00000000 /* -WI-V */
#define NV_PAPU_GPIDRDY_GPSETIDLE_SET                      0x00000001 /* RW--V */
#define NV_PAPU_GPIDRDY_GPSTOPPED                          1:1 /* RW-VF */
#define NV_PAPU_GPIDRDY_GPSTOPPED_NOT_SET                  0x00000000 /* RWI-V */
#define NV_PAPU_GPIDRDY_GPSTOPPED_SET                      0x00000001 /* RW--V */
#define NV_PAPU_GPIDRDY_GPSTOP_ENABLE                      2:2 /* -W-VF */
#define NV_PAPU_GPIDRDY_GPSTOP_NOT_ENABLED                 0x00000000 /* -WI-V */
#define NV_PAPU_GPIDRDY_GPSTOP_ENABLED                     0x00000001 /* -W--V */
#define NV_PAPU_GPIDRDY_GPSETNINT                          3:3 /* -W-VF */
#define NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET                  0x00000000 /* -WI-V */
#define NV_PAPU_GPIDRDY_GPSETNINT_SET                      0x00000001 /* -W--V */
#define NV_PAPU_GPT0CFG                                    0x0003FEC0 /* RW-4R */
#define NV_PAPU_GPT0CFG_GPT0RUN                            0:0 /* RW-VF */
#define NV_PAPU_GPT0CFG_GPT0RUN_IDLE                       0x00000000 /* RWI-V */
#define NV_PAPU_GPT0CFG_GPT0RUN_RUN                        0x00000001 /* RW--V */
#define NV_PAPU_GPT0CFG_GPT0DSTP                           1:1 /* RW-VF */
#define NV_PAPU_GPT0CFG_GPT0DSTP_RUN                       0x00000000 /* RWI-V */
#define NV_PAPU_GPT0CFG_GPT0DSTP_HOLD                      0x00000001 /* RW--V */
#define NV_PAPU_GPT1CFG                                    0x0003FED0 /* RW-4R */
#define NV_PAPU_GPT1CFG_GPT1RUN                            0:0 /* RW-VF */
#define NV_PAPU_GPT1CFG_GPT1RUN_IDLE                       0x00000000 /* RWI-V */
#define NV_PAPU_GPT1CFG_GPT1RUN_RUN                        0x00000001 /* RW--V */
#define NV_PAPU_GPT1CFG_GPT1DSTP                           1:1 /* RW-VF */
#define NV_PAPU_GPT1CFG_GPT1DSTP_RUN                       0x00000000 /* RWI-V */
#define NV_PAPU_GPT1CFG_GPT1DSTP_HOLD                      0x00000001 /* RW--V */
#define NV_PAPU_GPT0CTL                                    0x0003FEC4 /* RW-4R */
#define NV_PAPU_GPT0CTL_GPT0ACT                            1:0 /* -W-VF */
#define NV_PAPU_GPT0CTL_GPT0ACT_NOP                        0x00000000 /* -WI-V */
#define NV_PAPU_GPT0CTL_GPT0ACT_STZERO                     0x00000001 /* -W--V */
#define NV_PAPU_GPT0CTL_GPT0ACT_STCUR                      0x00000002 /* -W--V */
#define NV_PAPU_GPT0CTL_GPT0ACT_STOP                       0x00000003 /* -W--V */
#define NV_PAPU_GPT0CTL_GPT0ST                             2:2 /* R--VF */
#define NV_PAPU_GPT0CTL_GPT0ST_STOP                        0x00000000 /* R-I-V */
#define NV_PAPU_GPT0CTL_GPT0ST_RUN                         0x00000001 /* R---V */
#define NV_PAPU_GPT1CTL                                    0x0003FED4 /* RW-4R */
#define NV_PAPU_GPT1CTL_GPT1ACT                            1:0 /* -W-VF */
#define NV_PAPU_GPT1CTL_GPT1ACT_NOP                        0x00000000 /* -WI-V */
#define NV_PAPU_GPT1CTL_GPT1ACT_STZERO                     0x00000001 /* -W--V */
#define NV_PAPU_GPT1CTL_GPT1ACT_STCUR                      0x00000002 /* -W--V */
#define NV_PAPU_GPT1CTL_GPT1ACT_STOP                       0x00000003 /* -W--V */
#define NV_PAPU_GPT1CTL_GPT1ST                             2:2 /* R--VF */
#define NV_PAPU_GPT1CTL_GPT1ST_STOP                        0x00000000 /* R-I-V */
#define NV_PAPU_GPT1CTL_GPT1ST_RUN                         0x00000001 /* R---V */
#define NV_PAPU_GPT0TCNT                                   0x0003FEC8 /* RW-4R */
#define NV_PAPU_GPT0TCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_GPT1TCNT                                   0x0003FED8 /* RW-4R */
#define NV_PAPU_GPT1TCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_GPT0CCNT                                   0x0003FECC /* RW-4R */
#define NV_PAPU_GPT0CCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_GPT1CCNT                                   0x0003FEDC /* RW-4R */
#define NV_PAPU_GPT1CCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_GPISTS                                     0x0003FF14 /* RW-4R */
#define NV_PAPU_GPISTS_GPSTRTSTS                           0:0 /* RW-VF */
#define NV_PAPU_GPISTS_GPSTRTSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPSTRTSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPSTRTSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPABRTSTS                           1:1 /* RW-VF */
#define NV_PAPU_GPISTS_GPABRTSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPABRTSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPABRTSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPPUTSTS                            2:2 /* RW-VF */
#define NV_PAPU_GPISTS_GPPUTSTS_NO_INTR                    0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPPUTSTS_INTR                       0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPPUTSTS_CLR                        0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPMBISTS                            3:3 /* RW-VF */
#define NV_PAPU_GPISTS_GPMBISTS_NO_INTR                    0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPMBISTS_INTR                       0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPMBISTS_CLR                        0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPD1STS                             4:4 /* R--VF */
#define NV_PAPU_GPISTS_GPD1STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPD1STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPD1STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPD2STS                             5:5 /* RW-VF */
#define NV_PAPU_GPISTS_GPD2STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPD2STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPD2STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPD3STS                             6:6 /* RW-VF */
#define NV_PAPU_GPISTS_GPD3STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPD3STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPD3STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPDEOLSTS                           7:7 /* RW-VF */
#define NV_PAPU_GPISTS_GPDEOLSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPDEOLSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPDEOLSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPT0STS                             8:8 /* RW-VF */
#define NV_PAPU_GPISTS_GPT0STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPT0STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPT0STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPT1STS                             9:9 /* RW-VF */
#define NV_PAPU_GPISTS_GPT1STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPT1STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPT1STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_GPISTS_GPDERRSTS                           10:10 /* RW-VF */
#define NV_PAPU_GPISTS_GPDERRSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_GPISTS_GPDERRSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_GPISTS_GPDERRSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_GPHDRV(i)                                  (0x0003FE40+(i)*4) /* R--4A */
#define NV_PAPU_GPHDRV__SIZE_1                             32 /* */ 
#define NV_PAPU_GPHDRV_MHR                                 2:0 /* R--UF */
#define NV_PAPU_GPHDRV_VLD                                 3:3 /* R--UF */
#define NV_PAPU_GPHDRV_VLD_INVALID                         0x00000000 /* R-I-V */
#define NV_PAPU_GPHDRV_VLD_VALID                           0x00000001 /* R---V */
#define NV_PAPU_GPGSCNT                                    0x0003FF18 /* R--4R */
#define NV_PAPU_GPGSCNT_GSCNT                              23:0 /* R--UF */
#define NV_PAPU_GPDCFG                                     0x0003FF5C /* RW-4R */
#define NV_PAPU_GPDCFG_GPDASTRT                            0:0 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDASTRT_DISABLED                   0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDASTRT_ENABLED                    0x00000001 /* RW--V */
#define NV_PAPU_GPDCFG_GPDARDY                             1:1 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDARDY_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDARDY_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_GPDCFG_GPDIOCR                             2:2 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDIOCR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDIOCR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_GPDCFG_GPDEOLR                             3:3 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDEOLR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDEOLR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_GPDCFG_GPDERRR                             4:4 /* RW-VF */
#define NV_PAPU_GPDCFG_GPDERRR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_GPDCFG_GPDERRR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_GPDCTL                                     0x0003FF58 /* RW-4R */
#define NV_PAPU_GPDCTL_GPDACT                              2:0 /* RW-VF */
#define NV_PAPU_GPDCTL_GPDACT_NOP                          0x00000000 /* RWI-V */
#define NV_PAPU_GPDCTL_GPDACT_START                        0x00000001 /* -W--V */
#define NV_PAPU_GPDCTL_GPDACT_STOP                         0x00000002 /* -W--V */
#define NV_PAPU_GPDCTL_GPDACT_FREEZE                       0x00000003 /* -W--V */
#define NV_PAPU_GPDCTL_GPDACT_UNFREEZE                     0x00000004 /* -W--V */
#define NV_PAPU_GPDCTL_GPDFRZ                              3:3 /* R--VF */
#define NV_PAPU_GPDCTL_GPDFRZ_NOT_FROZE                    0x00000000 /* R-I-V */
#define NV_PAPU_GPDCTL_GPDFRZ_FROZE                        0x00000001 /* R---V */
#define NV_PAPU_GPDCTL_GPDRUN                              4:4 /* R--VF */
#define NV_PAPU_GPDCTL_GPDRUN_NOT_RUN                      0x00000000 /* R-I-V */
#define NV_PAPU_GPDCTL_GPDRUN_RUNNING                      0x00000001 /* R---V */
#define NV_PAPU_GPDCTL_GPDSTP                              5:5 /* R--VF */
#define NV_PAPU_GPDCTL_GPDSTP_NOT_STOP                     0x00000000 /* R-I-V */
#define NV_PAPU_GPDCTL_GPDFRZ_STOPPED                      0x00000001 /* R---V */
#define NV_PAPU_GPDSPT                                     0x0003FF54 /* RW-4R */
#define NV_PAPU_GPDSPT_GPDSBPT                             13:0 /* RW-VF */
#define NV_PAPU_GPDSPT_GPDSBPT_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_GPDSPT_GPDEOL                              14:14 /* RW-VF */
#define NV_PAPU_GPDSPT_GPDEOL_EOL                          0x00000001 /* RWI-V */
#define NV_PAPU_GPDSPT_GPDEOL_NOT_EOL                      0x00000000 /* RW--V */
#define NV_PAPU_GPNSPT                                     0x0003FF50 /* RW-4R */
#define NV_PAPU_GPNSPT_GPNSBPT                             13:0 /* RW-VF */
#define NV_PAPU_GPNSPT_GPNSBPT_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_GPNSPT_GPNEOL                              14:14 /* RW-VF */
#define NV_PAPU_GPNSPT_GPNEOL_NOT_EOL                      0x00000000 /* RWI-V */
#define NV_PAPU_GPNSPT_GPNEOL_EOL                          0x00000001 /* RW--V */
#define NV_PAPU_GPDBASE(i)                                 (0x0003FF30+(i)*8) /* RW-4A */
#define NV_PAPU_GPDBASE__SIZE_1                            4 /* */ 
#define NV_PAPU_GPDBASE_BASE                               23:0 /* R--UF */
#define NV_PAPU_GPDSIZE(i)                                 (0x0003FF34+(i)*8) /* RW-4A */
#define NV_PAPU_GPDSIZE__SIZE_1                            4 /* */ 
#define NV_PAPU_GPDSIZE_SIZE                               23:0 /* R--UF */
#define NV_PAPU_GPDDEBUG                                   0x0003FF2C /* R--4R */
#define NV_PAPU_GPDDEBUG_PBADBLK                           13:0 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLSMBUFID                        14:14 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLSMBUFID_NOT_ILL                0x00000000 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLSMBUFID_ILL                    0x00000001 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLSMDATAFMT                      15:15 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLSMDATAFMT_NOT_ILL              0x00000000 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLSMDATAFMT_ILL                  0x00000001 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLCOUNT                          16:16 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLCOUNT_NOT_ILL                  0x00000000 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLCOUNT_ILL                      0x00000001 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLDSPADDR                        17:17 /* R--VF */
#define NV_PAPU_GPDDEBUG_ILLDSPADDR_NOT_ILL                0x00000000 /* R---V */
#define NV_PAPU_GPDDEBUG_ILLDSPADDR_ILL                    0x00000001 /* R---V */
#define NV_PAPU_EPXMEM(i)                                  (0x50000+4*(i)) /* RW--M */
#define NV_PAPU_EPXMEM__SIZE_1                             0x0C00 /* */ 
#define NV_PAPU_EPYMEM(i)                                  (0x56000+4*(i)) /* RW--M */
#define NV_PAPU_EPYMEM__SIZE_1                             0x0100 /* */ 
#define NV_PAPU_EPPMEM(i)                                  (0x5A000+4*(i)) /* RW--M */
#define NV_PAPU_EPPMEM__SIZE_1                             0x1000 /* */ 
#define NV_PAPU_EPRST                                      0x0005FFFC /* RW-4R */
#define NV_PAPU_EPRST_EPRST                                0:0 /* RW-VF */
#define NV_PAPU_EPRST_EPRST_ENABLED                        0x00000000 /* RWI-V */
#define NV_PAPU_EPRST_EPRST_DISABLED                       0x00000001 /* RW--V */
#define NV_PAPU_EPRST_EPDSPRST                             1:1 /* RW-VF */
#define NV_PAPU_EPRST_EPDSPRST_ENABLED                     0x00000000 /* RWI-V */
#define NV_PAPU_EPRST_EPDSPRST_DISABLED                    0x00000001 /* RW--V */
#define NV_PAPU_EPRST_EPNMI                                2:2 /* -W-VF */
#define NV_PAPU_EPRST_EPNMI_DISABLED                       0x00000000 /* -WI-V */
#define NV_PAPU_EPRST_EPNMI_ENABLED                        0x00000001 /* -W--V */
#define NV_PAPU_EPRST_EPABORT                              3:3 /* -W-VF */
#define NV_PAPU_EPRST_EPABORT_DISABLED                     0x00000000 /* -WI-V */
#define NV_PAPU_EPRST_EPABORT_ENABLED                      0x00000001 /* -W--V */
#define NV_PAPU_EPCTLG                                     0x0005FF28 /* RW-4R */
#define NV_PAPU_EPCTLG_EPSTYP                              0:0 /* RW-VF */
#define NV_PAPU_EPCTLG_EPSTYP_NON_ISO                      0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLG_EPSTYP_ISO                          0x00000001 /* RW--V */
#define NV_PAPU_EPCTLG_SPARE                               23:1 /* RW-UF */
#define NV_PAPU_EPCTLG_SPARE_INIT                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT                                   0x0005FF20 /* RW-4R */
#define NV_PAPU_EPCTLOUT_ED0FMT                            1:0 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED0FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED0FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED0FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED0FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLOUT_EP0TYP                            2:2 /* RW-VF */
#define NV_PAPU_EPCTLOUT_EP0TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_EP0TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED0SIZ                            4:3 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED0SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED0SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED0SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1FMT                            6:5 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED1FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED1FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLOUT_EP1TYP                            7:7 /* RW-VF */
#define NV_PAPU_EPCTLOUT_EP1TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_EP1TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1SIZ                            9:8 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED1SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED1SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED1SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2FMT                            11:10 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED2FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED2FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLOUT_EP2TYP                            12:12 /* RW-VF */
#define NV_PAPU_EPCTLOUT_EP2TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_EP2TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2SIZ                            14:13 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED2SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED2SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED2SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3FMT                            16:15 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED3FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED3FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLOUT_EP3TYP                            17:17 /* RW-VF */
#define NV_PAPU_EPCTLOUT_EP3TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_EP3TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3SIZ                            19:18 /* RW-VF */
#define NV_PAPU_EPCTLOUT_ED3SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLOUT_ED3SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLOUT_ED3SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLOUT_SPARE                             23:20 /* RW-UF */
#define NV_PAPU_EPCTLOUT_SPARE_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN                                    0x0005FF24 /* RW-4R */
#define NV_PAPU_EPCTLIN_EDI0FMT                            1:0 /* RW-VF */
#define NV_PAPU_EPCTLIN_EDI0FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EDI0FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI0FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI0FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLIN_EPI0TYP                            2:2 /* RW-VF */
#define NV_PAPU_EPCTLIN_EPI0TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EPI0TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI0SIZ                            4:3 /* RW-VF */
#define NV_PAPU_EPCTLIN_EDI0SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EDI0SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI0SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1FMT                            6:5 /* RW-VF */
#define NV_PAPU_EPCTLIN_EDI1FMT_MONO                       0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EDI1FMT_STEREO                     0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1FMT_QUAD                       0x00000002 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1FMT_HEX                        0x00000003 /* RW--V */
#define NV_PAPU_EPCTLIN_EPI1TYP                            7:7 /* RW-VF */
#define NV_PAPU_EPCTLIN_EPI1TYP_NON_ISO                    0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EPI1TYP_ISO                        0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1SIZ                            9:8 /* RW-VF */
#define NV_PAPU_EPCTLIN_EDI1SIZ_8                          0x00000000 /* RWI-V */
#define NV_PAPU_EPCTLIN_EDI1SIZ_16                         0x00000001 /* RW--V */
#define NV_PAPU_EPCTLIN_EDI1SIZ_32                         0x00000002 /* RW--V */
#define NV_PAPU_EPCTLIN_SPARE                              23:10 /* RW-UF */
#define NV_PAPU_EPCTLIN_SPARE_INIT                         0x00000000 /* RWI-V */
#define NV_PAPU_EPMBO                                      0x0005FF08 /* RW-4R */
#define NV_PAPU_EPMBO_VALUE                                23:0 /* RWXUF */
#define NV_PAPU_EPMBI                                      0x0005FF0C /* RW-4R */
#define NV_PAPU_EPMBI_VALUE                                23:0 /* RWXUF */
#define NV_PAPU_EPGET                                      0x0005FF00 /* RW-4R */
#define NV_PAPU_EPGET_VALUE                                11:2 /* RWXUF */
#define NV_PAPU_EPPUT                                      0x0005FF04 /* RW-4R */
#define NV_PAPU_EPPUT_VALUE                                11:2 /* RWXUF */
#define NV_PAPU_EPIDRDY                                    0x0005FF10 /* RW-4R */
#define NV_PAPU_EPIDRDY_EPSETIDLE                          0:0 /* RW-VF */
#define NV_PAPU_EPIDRDY_EPSETIDLE_NOT_SET                  0x00000000 /* RWI-V */
#define NV_PAPU_EPIDRDY_EPSETIDLE_SET                      0x00000001 /* -W--V */
#define NV_PAPU_EPIDRDY_EPSTOPPED                          1:1 /* RW-VF */
#define NV_PAPU_EPIDRDY_EPSTOPPED_NOT_SET                  0x00000000 /* RWI-V */
#define NV_PAPU_EPIDRDY_EPSTOPPED_SET                      0x00000001 /* RW--V */
#define NV_PAPU_EPIDRDY_EPSTOP_ENABLE                      2:2 /* -W-VF */
#define NV_PAPU_EPIDRDY_EPSTOP_NOT_ENABLED                 0x00000000 /* -WI-V */
#define NV_PAPU_EPIDRDY_EPSTOP_ENABLED                     0x00000001 /* -W--V */
#define NV_PAPU_EPIDRDY_EPSETNINT                          3:3 /* -W-VF */
#define NV_PAPU_EPIDRDY_EPSETNINT_NOT_SET                  0x00000000 /* -WI-V */
#define NV_PAPU_EPIDRDY_EPSETNINT_SET                      0x00000001 /* -W--V */
#define NV_PAPU_EPT0CFG                                    0x0005FEC0 /* RW-4R */
#define NV_PAPU_EPT0CFG_EPT0RUN                            0:0 /* RW-VF */
#define NV_PAPU_EPT0CFG_EPT0RUN_IDLE                       0x00000000 /* RWI-V */
#define NV_PAPU_EPT0CFG_EPT0RUN_RUN                        0x00000001 /* RW--V */
#define NV_PAPU_EPT0CFG_EPT0DSTP                           1:1 /* RW-VF */
#define NV_PAPU_EPT0CFG_EPT0DSTP_RUN                       0x00000000 /* RWI-V */
#define NV_PAPU_EPT0CFG_EPT0DSTP_HOLD                      0x00000001 /* RW--V */
#define NV_PAPU_EPT1CFG                                    0x0005FED0 /* RW-4R */
#define NV_PAPU_EPT1CFG_EPT1RUN                            0:0 /* RW-VF */
#define NV_PAPU_EPT1CFG_EPT1RUN_IDLE                       0x00000000 /* RWI-V */
#define NV_PAPU_EPT1CFG_EPT1RUN_RUN                        0x00000001 /* RW--V */
#define NV_PAPU_EPT1CFG_EPT1DSTP                           1:1 /* RW-VF */
#define NV_PAPU_EPT1CFG_EPT1DSTP_RUN                       0x00000000 /* RWI-V */
#define NV_PAPU_EPT1CFG_EPT1DSTP_HOLD                      0x00000001 /* RW--V */
#define NV_PAPU_EPT0CTL                                    0x0005FEC4 /* RW-4R */
#define NV_PAPU_EPT0CTL_EPT0ACT                            1:0 /* -W-VF */
#define NV_PAPU_EPT0CTL_EPT0ACT_NOP                        0x00000000 /* -WI-V */
#define NV_PAPU_EPT0CTL_EPT0ACT_STZERO                     0x00000001 /* -W--V */
#define NV_PAPU_EPT0CTL_EPT0ACT_STCUR                      0x00000002 /* -W--V */
#define NV_PAPU_EPT0CTL_EPT0ACT_STOP                       0x00000003 /* -W--V */
#define NV_PAPU_EPT0CTL_EPT0ST                             2:2 /* R--VF */
#define NV_PAPU_EPT0CTL_EPT0ST_STOP                        0x00000000 /* R-I-V */
#define NV_PAPU_EPT0CTL_EPT0ST_RUN                         0x00000001 /* R---V */
#define NV_PAPU_EPT1CTL                                    0x0005FED4 /* RW-4R */
#define NV_PAPU_EPT1CTL_EPT1ACT                            1:0 /* -W-VF */
#define NV_PAPU_EPT1CTL_EPT1ACT_NOP                        0x00000000 /* -WI-V */
#define NV_PAPU_EPT1CTL_EPT1ACT_STZERO                     0x00000001 /* -W--V */
#define NV_PAPU_EPT1CTL_EPT1ACT_STCUR                      0x00000002 /* -W--V */
#define NV_PAPU_EPT1CTL_EPT1ACT_STOP                       0x00000003 /* -W--V */
#define NV_PAPU_EPT1CTL_EPT1ST                             2:2 /* R--VF */
#define NV_PAPU_EPT1CTL_EPT1ST_STOP                        0x00000000 /* R-I-V */
#define NV_PAPU_EPT1CTL_EPT1ST_RUN                         0x00000001 /* R---V */
#define NV_PAPU_EPT0TCNT                                   0x0005FEC8 /* RW-4R */
#define NV_PAPU_EPT0TCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_EPT1TCNT                                   0x0005FED8 /* RW-4R */
#define NV_PAPU_EPT1TCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_EPT0CCNT                                   0x0005FECC /* RW-4R */
#define NV_PAPU_EPT0CCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_EPT1CCNT                                   0x0005FEDC /* RW-4R */
#define NV_PAPU_EPT1CCNT_VALUE                             23:0 /* RWXUF */
#define NV_PAPU_EPISTS                                     0x0005FF14 /* RW-4R */
#define NV_PAPU_EPISTS_EPSTRTSTS                           0:0 /* RW-VF */
#define NV_PAPU_EPISTS_EPSTRTSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPSTRTSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPSTRTSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPABRTSTS                           1:1 /* RW-VF */
#define NV_PAPU_EPISTS_EPABRTSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPABRTSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPABRTSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPPUTSTS                            2:2 /* RW-VF */
#define NV_PAPU_EPISTS_EPPUTSTS_NO_INTR                    0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPPUTSTS_INTR                       0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPPUTSTS_CLR                        0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPMBISTS                            3:3 /* RW-VF */
#define NV_PAPU_EPISTS_EPMBISTS_NO_INTR                    0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPMBISTS_INTR                       0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPMBISTS_CLR                        0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPD1STS                             4:4 /* R--VF */
#define NV_PAPU_EPISTS_EPD1STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPD1STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPD1STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPD2STS                             5:5 /* RW-VF */
#define NV_PAPU_EPISTS_EPD2STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPD2STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPD2STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPD3STS                             6:6 /* RW-VF */
#define NV_PAPU_EPISTS_EPD3STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPD3STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPD3STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPDEOLSTS                           7:7 /* RW-VF */
#define NV_PAPU_EPISTS_EPDEOLSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPDEOLSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPDEOLSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPT0STS                             8:8 /* RW-VF */
#define NV_PAPU_EPISTS_EPT0STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPT0STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPT0STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPT1STS                             9:9 /* RW-VF */
#define NV_PAPU_EPISTS_EPT1STS_NO_INTR                     0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPT1STS_INTR                        0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPT1STS_CLR                         0x00000001 /* -W--V */
#define NV_PAPU_EPISTS_EPDERRSTS                           10:10 /* RW-VF */
#define NV_PAPU_EPISTS_EPDERRSTS_NO_INTR                   0x00000000 /* R-I-V */
#define NV_PAPU_EPISTS_EPDERRSTS_INTR                      0x00000001 /* R---V */
#define NV_PAPU_EPISTS_EPDERRSTS_CLR                       0x00000001 /* -W--V */
#define NV_PAPU_EPGSCNT                                    0x0005FF18 /* R--4R */
#define NV_PAPU_EPGSCNT_GSCNT                              23:0 /* R--UF */
#define NV_PAPU_EPDCFG                                     0x0005FF5C /* RW-4R */
#define NV_PAPU_EPDCFG_EPDASTRT                            0:0 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDASTRT_DISABLED                   0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDASTRT_ENABLED                    0x00000001 /* RW--V */
#define NV_PAPU_EPDCFG_EPDARDY                             1:1 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDARDY_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDARDY_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_EPDCFG_EPDIOCR                             2:2 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDIOCR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDIOCR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_EPDCFG_EPDEOLR                             3:3 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDEOLR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDEOLR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_EPDCFG_EPDERRR                             4:4 /* RW-VF */
#define NV_PAPU_EPDCFG_EPDERRR_DISABLED                    0x00000000 /* RWI-V */
#define NV_PAPU_EPDCFG_EPDERRR_ENABLED                     0x00000001 /* RW--V */
#define NV_PAPU_EPDCTL                                     0x0005FF58 /* RW-4R */
#define NV_PAPU_EPDCTL_EPDACT                              2:0 /* RW-VF */
#define NV_PAPU_EPDCTL_EPDACT_NOP                          0x00000000 /* RWI-V */
#define NV_PAPU_EPDCTL_EPDACT_START                        0x00000001 /* -W--V */
#define NV_PAPU_EPDCTL_EPDACT_STOP                         0x00000002 /* -W--V */
#define NV_PAPU_EPDCTL_EPDACT_FREEZE                       0x00000003 /* -W--V */
#define NV_PAPU_EPDCTL_EPDACT_UNFREEZE                     0x00000004 /* -W--V */
#define NV_PAPU_EPDCTL_EPDFRZ                              3:3 /* R--VF */
#define NV_PAPU_EPDCTL_EPDFRZ_NOT_FROZE                    0x00000000 /* R-I-V */
#define NV_PAPU_EPDCTL_EPDFRZ_FROZE                        0x00000001 /* R---V */
#define NV_PAPU_EPDCTL_EPDRUN                              4:4 /* R--VF */
#define NV_PAPU_EPDCTL_EPDRUN_NOT_RUN                      0x00000000 /* R-I-V */
#define NV_PAPU_EPDCTL_EPDRUN_RUNNING                      0x00000001 /* R---V */
#define NV_PAPU_EPDCTL_EPDSTP                              5:5 /* R--VF */
#define NV_PAPU_EPDCTL_EPDSTP_NOT_STOP                     0x00000000 /* R-I-V */
#define NV_PAPU_EPDCTL_EPDFRZ_STOPPED                      0x00000001 /* R---V */
#define NV_PAPU_EPDSPT                                     0x0005FF54 /* RW-4R */
#define NV_PAPU_EPDSPT_EPDSBPT                             13:0 /* RW-VF */
#define NV_PAPU_EPDSPT_EPDSBPT_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_EPDSPT_EPDEOL                              14:14 /* RW-VF */
#define NV_PAPU_EPDSPT_EPDEOL_EOL                          0x00000001 /* RWI-V */
#define NV_PAPU_EPDSPT_EPDEOL_NOT_EOL                      0x00000000 /* RW--V */
#define NV_PAPU_EPNSPT                                     0x0005FF50 /* RW-4R */
#define NV_PAPU_EPNSPT_EPNSBPT                             13:0 /* RW-VF */
#define NV_PAPU_EPNSPT_EPNSBPT_INIT                        0x00000000 /* RWI-V */
#define NV_PAPU_EPNSPT_EPNEOL                              14:14 /* RW-VF */
#define NV_PAPU_EPNSPT_EPNEOL_EOL                          0x00000001 /* RWI-V */
#define NV_PAPU_EPNSPT_EPNEOL_NOT_EOL                      0x00000000 /* RW--V */
#define NV_PAPU_EPDBASE(i)                                 (0x0005FF30+(i)*8) /* RW-4A */
#define NV_PAPU_EPDBASE__SIZE_1                            4 /* */ 
#define NV_PAPU_EPDBASE_BASE                               23:0 /* R--UF */
#define NV_PAPU_EPDSIZE(i)                                 (0x0005FF34+(i)*8) /* RW-4A */
#define NV_PAPU_EPDSIZE__SIZE_1                            4 /* */ 
#define NV_PAPU_EPDSIZE_SIZE                               23:0 /* R--UF */
#define NV_PAPU_EPDDEBUG                                   0x0005FF2C /* R--4R */
#define NV_PAPU_EPDDEBUG_PBADBLK                           13:0 /* R--VF */
#define NV_PAPU_EPDDEBUG_ILLSMBUFID                        14:14 /* R--VF */
#define NV_PAPU_EPDDEBUG_ILLSMBUFID_NOT_ILL                0x00000000 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLSMBUFID_ILL                    0x00000001 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLSMDATAFMT                      15:15 /* R--VF */
#define NV_PAPU_EPDDEBUG_ILLSMDATAFMT_NOT_ILL              0x00000000 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLSMDATAFMT_ILL                  0x00000001 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLCOUNT                          16:16 /* R--VF */
#define NV_PAPU_EPDDEBUG_ILLCOUNT_NOT_ILL                  0x00000000 /* R---V */
#define NV_PAPU_EPDDEBUG_ILLCOUNT_ILL                      0x00000001 /* R---V */

#endif /* __NV_PAPU_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\encdsnorm.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 01/10/01, 11:04:13
;	Program info
;	  Program number: 1
;	  Revision number: 1.51
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 659 words
;	  Checksum: $4D63EB

		dc	$D01B40,$000293,$010133,$4D63EB,$607000,$00062E,$20000B,$05A406
		dc	$44F400,$008002,$447000,$000604,$050C05,$44F400,$000002,$447000
		dc	$000604,$44F400,$00000A,$447000,$000600,$44F400,$00060A,$447000
		dc	$000601,$44F400,$000610,$447000,$000602,$44F400,$000616,$447000
		dc	$000603,$44F400,$00061C,$447000,$000605,$44F400,$000622,$447000
		dc	$000606,$44F400,$000628,$447000,$000607,$44F400,$000000,$447000
		dc	$000608,$44F400,$000100,$447000,$000609,$60F400,$00060A,$44F400
		dc	$000000,$445800,$44F400,$000100,$445800,$44F400,$000200,$445800
		dc	$44F400,$000300,$445800,$44F400,$000400,$445800,$44F400,$FFFFFF
		dc	$446000,$60F400,$000610,$44F400,$000001,$445800,$445800,$445800
		dc	$445800,$445800,$240000,$446000,$60F400,$000616,$44F400,$FFFFFF
		dc	$445800,$445800,$445800,$445800,$445800,$446000,$60F400,$00061C
		dc	$44F400,$000400,$445800,$44F400,$FFFFFF,$445800,$44F400,$000500
		dc	$445800,$44F400,$FFFFFF,$445800,$44F400,$FFFFFF,$445800,$44F400
		dc	$FFFFFF,$445800,$60F400,$000622,$44F400,$000001,$445800,$240000
		dc	$445800,$44F400,$000001,$445800,$240000,$445800,$240000,$445800
		dc	$240000,$445800,$60F400,$000628,$44F400,$FFFFFF,$445800,$445800
		dc	$445800,$445800,$445800,$445800,$56F400,$000005,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000005,$60F400,$000100
		dc	$70F400,$000100,$390100,$0D0180,$56F400,$000005,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$56F400,$000005,$60F400,$000300
		dc	$70F400,$000100,$390300,$0D0180,$56F400,$000005,$60F400,$000400
		dc	$70F400,$000100,$390400,$0D0180,$62F000,$00062E,$024295,$023ADE
		dc	$200003,$052018,$60F413,$000600,$57F400,$000016,$0D1080,$00001C
		dc	$56F400,$000006,$60F400,$000400,$70F400,$000100,$390000,$0D0180
		dc	$56F400,$000006,$60F400,$000500,$70F400,$000100,$390100,$0D0180
		dc	$00000C,$60F400,$000000,$068092,$000005,$44D800,$46D0A1,$5658E9
		dc	$575800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0,$0465A0
		dc	$0466A0,$00F3B8,$44F400,$000016,$20004D,$0D104A,$000008,$300000
		dc	$56F400,$000000,$57F400,$FFFFFF,$00000C,$0D1080,$0000B8,$56F000
		dc	$000632,$200003,$05A406,$0D1080,$00015A,$0D1080,$000139,$050C03
		dc	$0D1080,$00015D,$0D1080,$00013A,$56F000,$000633,$014085,$05A417
		dc	$66F000,$00062F,$3E0300,$60EE00,$3E0400,$61EE00,$66F000,$000630
		dc	$3E0300,$70EE00,$3E0400,$71EE00,$46F400,$5A827A,$62F000,$000638
		dc	$06D210,$000005,$44E000,$44C9D0,$2000D3,$564800,$66F000,$00062F
		dc	$3E0000,$60EE00,$3E0200,$61EE00,$3E0100,$62EE00,$66F000,$000634
		dc	$3E0000,$64EE00,$3E0200,$65EE00,$66F000,$000630,$3E0000,$70EE00
		dc	$3E0200,$71EE00,$3E0100,$72EE00,$66F000,$000635,$3E0000,$74EE00
		dc	$76F400,$000002,$75EE00,$45F400,$5A827A,$66F000,$000638,$06D600
		dc	$00043D,$44CA00,$56C800,$57C9A3,$564CAB,$574D00,$61F400,$000639
		dc	$65F000,$00068D,$62F400,$000671,$66F000,$000634,$3E0000,$60EE00
		dc	$221400,$66F000,$000635,$70EE00,$231C00,$50F000,$000638,$00000A
		dc	$211E00,$72F400,$000004,$0BF080,$00056B,$61F400,$000649,$65F000
		dc	$00068D,$62F400,$000679,$66F000,$000634,$3E0200,$60EE00,$221400
		dc	$66F000,$000635,$70EE00,$231C00,$50F000,$000638,$00000A,$211E00
		dc	$72F400,$000004,$0BF080,$00056B,$61F400,$000659,$65F000,$00068E
		dc	$62F400,$000681,$66F000,$00062F,$3E0300,$60EE00,$221400,$66F000
		dc	$000630,$70EE00,$231C00,$50F000,$000638,$00000A,$211E00,$72F400
		dc	$000006,$0BF080,$00056B,$66F000,$000634,$3E0000,$60EE00,$3E0200
		dc	$61EE00,$66F000,$00062F,$3E0300,$62EE00,$66F000,$000635,$3E0000
		dc	$70EE00,$3E0200,$71EE00,$66F000,$000630,$3E0300,$72EE00,$45F400
		dc	$5A827A,$64F000,$000638,$06D400,$0004A1,$44CA00,$56E000,$57E1A3
		dc	$5648AF,$574900,$0D1080,$0000BE,$00000C,$205800,$44D800,$447000
		dc	$00062F,$44D800,$447000,$000630,$44D800,$447000,$000631,$57D800
		dc	$0C1890,$001027,$507000,$000632,$0C1890,$001019,$507000,$000633
		dc	$44D800,$447000,$000634,$44D800,$447000,$000635,$44D800,$447000
		dc	$000636,$57D800,$0C1890,$002024,$507000,$000637,$44D800,$447000
		dc	$000638,$00000C,$A2DD74,$3AE54D,$C51AB3,$5D228C,$800000,$CAE85F
		dc	$47C25A,$47C25A,$CAE85F,$7FFFFF,$855BE8,$756638,$756638,$855BE8
		dc	$7FFFFF,$EA1F92,$E2404B,$E2404B,$EA1F92,$7FFFFF,$812B1B,$7DAC85
		dc	$7ED594,$812A6C,$7ED594,$C48FCE,$1B99D0,$092E48,$092E5B,$092E6E
		dc	$CAE85F,$47C25A,$1768D5,$1768BD,$1768A5,$CAE85F,$47C25A,$1768D5
		dc	$1768BD,$1768A5,$823E22,$7B876D,$7B876D,$823E22,$7FFFFF,$B23B5E
		dc	$27F74F,$27F74F,$B23B5E,$7FFFFF,$A062D3,$3FC327,$C03CD9,$5F9D2D
		dc	$800000,$C37356,$4A2F0E,$4A2F0E,$C37356,$7FFFFF,$84EF9E,$763A35
		dc	$763A35,$84EF9E,$7FFFFF,$E648FE,$E4B78A,$E4B78A,$E648FE,$7FFFFF
		dc	$8112E7,$7DDC7F,$7EEDAC,$811254,$7EEDAC,$BFB2BF,$204D6F,$07ECAA
		dc	$07ECBB,$07ECCD,$C37356,$4A2F0E,$1448F5,$1448DE,$1448C8,$C37356
		dc	$4A2F0E,$1448F5,$1448DE,$1448C8,$82101A,$7BE2ED,$7BE2ED,$82101A
		dc	$7FFFFF,$AF2EFC,$2C7800,$2C7800,$AF2EFC,$7FFFFF,$61F413,$000639
		dc	$065490,$000002,$565900,$00000C,$60F400,$0004CA,$61F400,$000000
		dc	$066490,$000003,$07D884,$4C5900,$56F000,$000637,$240000,$60F400
		dc	$000032,$61F445,$000046,$05A405,$60F400,$000000,$61F400,$000014
		dc	$607000,$00068D,$617000,$00068E,$00000C,$56F400,$00000C,$57F400
		dc	$000000,$385400,$0BF080,$000180,$00000C,$56F400,$00000C,$57F400
		dc	$000001,$60F400,$000639,$385400,$390000,$0BF080,$000180,$00000C
		dc	$56F400,$00000C,$57F400,$000002,$60F400,$000639,$385400,$390000
		dc	$0BF080,$000180,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600
		dc	$06DA10,$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4
		dc	$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09
		dc	$444C4C,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2
		dc	$200010,$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000
		dc	$239800,$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\encds_passthru133.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 01/11/01, 16:55:53
;	Program info
;	  Program number: 1
;	  Revision number: 1.3
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 503 words
;	  Checksum: $E65DF2

		dc	$D01B40,$0001F7,$010103,$E65DF2,$56F400,$000005,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000005,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$60F400,$000000,$61F400,$000400
		dc	$060091,$000003,$44D800,$445900,$60F400,$000200,$61F400,$000500
		dc	$060091,$000003,$44D800,$445900,$56F400,$000006,$60F400,$000400
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000006,$60F400,$000500
		dc	$70F400,$000100,$390100,$0D0180,$00000C,$60F400,$000000,$068092
		dc	$000005,$44D800,$46D0A1,$5658E9,$575800,$00000C,$05F420,$FFFFFF
		dc	$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000016
		dc	$20004D,$0D104A,$000008,$300000,$56F400,$000000,$57F400,$FFFFFF
		dc	$00000C,$0D1080,$0000B8,$56F000,$000632,$200003,$05A406,$0D1080
		dc	$00015A,$0D1080,$000139,$050C03,$0D1080,$00015D,$0D1080,$00013A
		dc	$56F000,$000633,$014085,$05A417,$66F000,$00062F,$3E0300,$60EE00
		dc	$3E0400,$61EE00,$66F000,$000630,$3E0300,$70EE00,$3E0400,$71EE00
		dc	$46F400,$5A827A,$62F000,$000638,$06D210,$000005,$44E000,$44C9D0
		dc	$2000D3,$564800,$66F000,$00062F,$3E0000,$60EE00,$3E0200,$61EE00
		dc	$3E0100,$62EE00,$66F000,$000634,$3E0000,$64EE00,$3E0200,$65EE00
		dc	$66F000,$000630,$3E0000,$70EE00,$3E0200,$71EE00,$3E0100,$72EE00
		dc	$66F000,$000635,$3E0000,$74EE00,$76F400,$000002,$75EE00,$45F400
		dc	$5A827A,$66F000,$000638,$06D600,$0003A1,$44CA00,$56C800,$57C9A3
		dc	$564CAB,$574D00,$61F400,$000639,$65F000,$00068D,$62F400,$000671
		dc	$66F000,$000634,$3E0000,$60EE00,$221400,$66F000,$000635,$70EE00
		dc	$231C00,$50F000,$000638,$00000A,$211E00,$72F400,$000004,$0BF080
		dc	$0004CF,$61F400,$000649,$65F000,$00068D,$62F400,$000679,$66F000
		dc	$000634,$3E0200,$60EE00,$221400,$66F000,$000635,$70EE00,$231C00
		dc	$50F000,$000638,$00000A,$211E00,$72F400,$000004,$0BF080,$0004CF
		dc	$61F400,$000659,$65F000,$00068E,$62F400,$000681,$66F000,$00062F
		dc	$3E0300,$60EE00,$221400,$66F000,$000630,$70EE00,$231C00,$50F000
		dc	$000638,$00000A,$211E00,$72F400,$000006,$0BF080,$0004CF,$66F000
		dc	$000634,$3E0000,$60EE00,$3E0200,$61EE00,$66F000,$00062F,$3E0300
		dc	$62EE00,$66F000,$000635,$3E0000,$70EE00,$3E0200,$71EE00,$66F000
		dc	$000630,$3E0300,$72EE00,$45F400,$5A827A,$64F000,$000638,$06D400
		dc	$000405,$44CA00,$56E000,$57E1A3,$5648AF,$574900,$0D1080,$0000BE
		dc	$00000C,$205800,$44D800,$447000,$00062F,$44D800,$447000,$000630
		dc	$44D800,$447000,$000631,$57D800,$0C1890,$001027,$507000,$000632
		dc	$0C1890,$001019,$507000,$000633,$44D800,$447000,$000634,$44D800
		dc	$447000,$000635,$44D800,$447000,$000636,$57D800,$0C1890,$002024
		dc	$507000,$000637,$44D800,$447000,$000638,$00000C,$A2DD74,$3AE54D
		dc	$C51AB3,$5D228C,$800000,$CAE85F,$47C25A,$47C25A,$CAE85F,$7FFFFF
		dc	$855BE8,$756638,$756638,$855BE8,$7FFFFF,$EA1F92,$E2404B,$E2404B
		dc	$EA1F92,$7FFFFF,$812B1B,$7DAC85,$7ED594,$812A6C,$7ED594,$C48FCE
		dc	$1B99D0,$092E48,$092E5B,$092E6E,$CAE85F,$47C25A,$1768D5,$1768BD
		dc	$1768A5,$CAE85F,$47C25A,$1768D5,$1768BD,$1768A5,$823E22,$7B876D
		dc	$7B876D,$823E22,$7FFFFF,$B23B5E,$27F74F,$27F74F,$B23B5E,$7FFFFF
		dc	$A062D3,$3FC327,$C03CD9,$5F9D2D,$800000,$C37356,$4A2F0E,$4A2F0E
		dc	$C37356,$7FFFFF,$84EF9E,$763A35,$763A35,$84EF9E,$7FFFFF,$E648FE
		dc	$E4B78A,$E4B78A,$E648FE,$7FFFFF,$8112E7,$7DDC7F,$7EEDAC,$811254
		dc	$7EEDAC,$BFB2BF,$204D6F,$07ECAA,$07ECBB,$07ECCD,$C37356,$4A2F0E
		dc	$1448F5,$1448DE,$1448C8,$C37356,$4A2F0E,$1448F5,$1448DE,$1448C8
		dc	$82101A,$7BE2ED,$7BE2ED,$82101A,$7FFFFF,$AF2EFC,$2C7800,$2C7800
		dc	$AF2EFC,$7FFFFF,$61F413,$000639,$065490,$000002,$565900,$00000C
		dc	$60F400,$00042E,$61F400,$000000,$066490,$000003,$07D884,$4C5900
		dc	$56F000,$000637,$240000,$60F400,$000032,$61F445,$000046,$05A405
		dc	$60F400,$000000,$61F400,$000014,$607000,$00068D,$617000,$00068E
		dc	$00000C,$56F400,$00000C,$57F400,$000000,$385400,$0BF080,$000180
		dc	$00000C,$56F400,$00000C,$57F400,$000001,$60F400,$000639,$385400
		dc	$390000,$0BF080,$000180,$00000C,$56F400,$00000C,$57F400,$000002
		dc	$60F400,$000639,$385400,$390000,$0BF080,$000180,$00000C,$71F400
		dc	$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021,$57DA00,$51D200
		dc	$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409,$444C4C,$03F184
		dc	$555A00,$515A00,$22D400,$229000,$239800,$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\nv_uap.h ===
/*  FILE: nv_uap.h
 *  CREATED: Mon Nov 20 21:05:43 2000
 *
 *  Copyright (c) 2000, by NVIDIA CORP
 *  All Rights Reserved.
 */

 /*** DO NOT EDIT, THIS FILE GENERATED FROM ../../../manuals/usr_audio_proc.ref ***/


#ifndef __NV_UAP_H__
#define __NV_UAP_H__


/***********************************************/
/* Macros and constants                        */
/***********************************************/

#ifndef REF_VAL
#define DRF_SHIFT(drf)    ((0?drf) % 32)
#define DRF_MASK(drf)     (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define REF_VAL(drf,v)    (((v)>>DRF_SHIFT(drf))&DRF_MASK(drf))
#define REF_NUM(drf,n)    (((n)&DRF_MASK(drf))<<DRF_SHIFT(drf))
#endif /* !REF_VAL */

/***********************************************/
/*    #defines from the manuals                */
/***********************************************/

#define NV1BA0_PIO_FREE                                    0x00000010 /* R--4R */
#define NV1BA0_PIO_FREE_COUNT                              11:2 /* R-X4F */
#define NV1BA0_PIO_FREE_COUNT_FIFO_FULL                    0x00 /* R---V */
#define NV1BA0_PIO_INFO                                    0x00000014 /* R--4R */
#define NV1BA0_PIO_INFO_PIO                                0:0 /* R-X4F */
#define NV1BA0_PIO_INFO_PIO_EMPTY_AND_IDLE                 0x00 /* R---V */
#define NV1BA0_PIO_INFO_PIO_BUSY                           0x01 /* R---V */
#define NV1BA0_PIO_INFO_DMA                                1:1 /* R-X4F */
#define NV1BA0_PIO_INFO_DMA_EMPTY_AND_IDLE                 0x00 /* R---V */
#define NV1BA0_PIO_INFO_DMA_BUSY                           0x01 /* R---V */
#define NV1BA0_CHANNEL_DMA_PUT                             0x00000040 /* -W-4R */
#define NV1BA0_CHANNEL_DMA_PUT_OFFSET                      11:2 /* -WXUF */
#define NV1BA0_CHANNEL_DMA_GET                             0x00000044 /* R--4R */
#define NV1BA0_CHANNEL_DMA_GET_OFFSET                      11:2 /* R-X4F */
#define NV1BA0_PIO_NOP                                     0x00000100 /* -W-4R */
#define NV1BA0_PIO_NOP_PARAMETER                           31:0 /* -W-VF */
#define NV1BA0_PIO_NOTIFICATION_STATUS_DONE_SUCCESS        0x00000001 /* -W--V */
#define NV1BA0_PIO_SYNCHRONIZE                             0x00000104 /* -W-4R */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER                   31:0 /* -W-VF */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER_NO_OPERATION      0x00000000 /* -W--V */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE     0x00000001 /* -W--V */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE_WRITE_PE_NOTIFY 0x00000002 /* -W--V */
#define NV1BA0_PIO_SYNCHRONIZE_PARAMETER_WAIT_FOR_IDLE_WRITE_PE_NOTIFY_AWAKEN 0x00000003 /* -W--V */
#define NV1BA0_PIO_SET_TIME                                0x00000108 /* -W-4R */
#define NV1BA0_PIO_SET_TIME_VALUE                          31:0 /* -W-UF */
#define NV1BA0_PIO_SET_MODE                                0x0000010C /* -W-4R */
#define NV1BA0_PIO_SET_MODE_PARAMETER                      31:0 /* -W-VF */
#define NV1BA0_PIO_SET_MODE_PARAMETER_OFF                  0x00000000 /* -W--V */
#define NV1BA0_PIO_SET_MODE_PARAMETER_RUN                  0x00000001 /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE                    0x00000120 /* -W-4R */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE             15:0 /* -W-VF */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_HANDLE_NULL        0xFFFF /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST               17:16 /* -W-VF */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_INHERIT       0x00 /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_2D_TOP        0x01 /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_3D_TOP        0x02 /* -W--V */
#define NV1BA0_PIO_SET_ANTECEDENT_VOICE_LIST_MP_TOP        0x03 /* -W--V */
#define NV1BA0_PIO_VOICE_ON                                0x00000124 /* -W-4R */
#define NV1BA0_PIO_VOICE_ON_HANDLE                         15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_ON_ENVF                           27:24 /* -W-VF */
#define NV1BA0_PIO_VOICE_ON_ENVF_DISABLE                   0x00 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVF_DELAY                     0x01 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVF_ATTACK                    0x02 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVF_HOLD                      0x03 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVA                           31:28 /* -W-VF */
#define NV1BA0_PIO_VOICE_ON_ENVA_DISABLE                   0x00 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVA_DELAY                     0x01 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVA_ATTACK                    0x02 /* -W--V */
#define NV1BA0_PIO_VOICE_ON_ENVA_HOLD                      0x03 /* -W--V */
#define NV1BA0_PIO_VOICE_OFF                               0x00000128 /* -W-4R */
#define NV1BA0_PIO_VOICE_OFF_HANDLE                        15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_RELEASE                           0x0000012C /* -W-4R */
#define NV1BA0_PIO_VOICE_RELEASE_HANDLE                    15:0 /* -W-VF */
#define NV1BA0_PIO_GET_VOICE_POSITION                      0x00000130 /* -W-4R */
#define NV1BA0_PIO_GET_VOICE_POSITION_HANDLE               15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_PAUSE                             0x00000140 /* -W-4R */
#define NV1BA0_PIO_VOICE_PAUSE_HANDLE                      15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_PAUSE_ACTION                      18:18 /* -W-VF */
#define NV1BA0_PIO_VOICE_PAUSE_ACTION_RESUME               0x00 /* -W--V */
#define NV1BA0_PIO_VOICE_PAUSE_ACTION_STOP                 0x01 /* -W--V */
#define NV1BA0_PIO_SET_CONTEXT_DMA_NOTIFY                  0x00000180 /* -W-4R */
#define NV1BA0_PIO_SET_CONTEXT_DMA_NOTIFY_HANDLE           31:0 /* -W-VF */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM(i)                  (0x00000200+(i)*4) /* -W-4A */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM__SIZE_1             32 /* */ 
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT              2:0 /* -W-VF */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_ZEROBITS     0x00 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_ONEBIT       0x01 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_TWOBITS      0x02 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_THREEBITS    0x03 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_FOURBITS     0x04 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_FIVEBITS     0x05 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_SIXBITS      0x06 /* -W--V */
#define NV1BA0_PIO_SET_SUBMIX_HEADROOM_AMOUNT_SEVENBITS    0x07 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM                       0x00000280 /* -W-4R */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT                2:0 /* -W-VF */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_ZEROBITS       0x00 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_ONEBIT         0x01 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_TWOBITS        0x02 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_THREEBITS      0x03 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_FOURBITS       0x04 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_FIVEBITS       0x05 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_SIXBITS        0x06 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_HEADROOM_AMOUNT_SEVENBITS      0x07 /* -W--V */
#define NV1BA0_PIO_SET_HRTF_SUBMIX(i)                      (0x00000290+(i)*4) /* -W-4A */
#define NV1BA0_PIO_SET_HRTF_SUBMIX__SIZE_1                 4 /* */ 
#define NV1BA0_PIO_SET_HRTF_SUBMIX_BIN                     4:0 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES                       0x000002C0 /* -W-4R */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN0                  4:0 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN1                  12:8 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN2                  20:16 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_SUBMIXES_BIN3                  28:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOLUME_TRACKING                     0x000002A0 /* -W-4R */
#define NV1BA0_PIO_SET_VOLUME_TRACKING_PARAMETER           11:0 /* -W-UF */
#define NV1BA0_PIO_SET_PITCH_TRACKING                      0x000002A4 /* -W-4R */
#define NV1BA0_PIO_SET_PITCH_TRACKING_PARAMETER            11:0 /* -W-UF */
#define NV1BA0_PIO_SET_HRTF_TRACKING                       0x000002A8 /* -W-4R */
#define NV1BA0_PIO_SET_HRTF_TRACKING_PARAMETER             11:0 /* -W-UF */
#define NV1BA0_PIO_SET_ITD_TRACKING                        0x000002AC /* -W-4R */
#define NV1BA0_PIO_SET_ITD_TRACKING_PARAMETER              11:0 /* -W-UF */
#define NV1BA0_PIO_SET_FILTER_TRACKING                     0x000002B0 /* -W-4R */
#define NV1BA0_PIO_SET_FILTER_TRACKING_PARAMETER           11:0 /* -W-UF */
#define NV1BA0_PIO_SET_CURRENT_VOICE                       0x000002F8 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_VOICE_HANDLE                15:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_LOCK                              0x000002FC /* -W-4R */
#define NV1BA0_PIO_VOICE_LOCK_PARAMETER                    7:0 /* -W-VF */
#define NV1BA0_PIO_VOICE_LOCK_PARAMETER_OFF                0x00000000 /* -W--V */
#define NV1BA0_PIO_VOICE_LOCK_PARAMETER_ON                 0x00000001 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN                      0x00000300 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V0BIN                4:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V1BIN                9:5 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V2BIN                14:10 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V3BIN                20:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V4BIN                25:21 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_VBIN_V5BIN                30:26 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT                       0x00000304 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V6BIN                 4:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V7BIN                 9:5 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V6PHASE               10:10 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V6PHASE_POSITIVE      0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V6PHASE_NEGATIVE      0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V7PHASE               11:11 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V7PHASE_POSITIVE      0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_V7PHASE_NEGATIVE      0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_GAIN                  12:12 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_GAIN_X1               0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_GAIN_X2               0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM              15:13 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC0_FLT0    0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC0_FLT1    0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC0_FLT2    0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC0_FLT3    0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC1_FLT0    0x04 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC1_FLT1    0x05 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC1_FLT2    0x06 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_SRC1_FLT3    0x07 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS0   0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS1   0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS2   0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS3   0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS4   0x04 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS5   0x05 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS6   0x06 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_HEADROOM_MULTIPASS7   0x07 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLES_PER_BLOCK     20:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS_BIN__ALIAS__ 20:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS             21:21 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS_OFF         0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_MULTIPASS_ON          0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LINKED_VOICE          22:22 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LINKED_VOICE_OFF      0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LINKED_VOICE_ON       0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST               23:23 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_OFF           0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_PERSIST_ON            0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE             24:24 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE_BUFFER      0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_DATA_TYPE_STREAM      0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP                  25:25 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_OFF              0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_LOOP_ON               0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CLEAR_MIX             26:26 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CLEAR_MIX_FALSE       0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CLEAR_MIX_TRUE        0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO                27:27 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO_DISABLE        0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_STEREO_ENABLE         0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE           29:28 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_U8        0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S16       0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S24       0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_SAMPLE_SIZE_S32       0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE        31:30 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B8     0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B16    0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_ADPCM  0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_FMT_CONTAINER_SIZE_B32    0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV0                      0x00000308 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV0_EA_ATTACKRATE        11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV0_EA_DELAYTIME         23:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV0_EF_PITCHSCALE        31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVA                      0x0000030C /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_DECAYRATE         11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_HOLDTIME          23:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVA_EA_SUSTAINLEVEL      31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV1                      0x00000310 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_ATTACKRATE        11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_DELAYTIME         23:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENV1_EF_FCSCALE           31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVF                      0x00000314 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_DECAYRATE         11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_HOLDTIME          23:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_ENVF_EF_SUSTAINLEVEL      31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC                      0x00000318 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_EF_RELEASERATE       11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOA_DELAYMODE       14:14 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOA_DELAYMODE_NORMAL 0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOA_DELAYMODE_DELAY 0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOF_DELAYMODE       15:15 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOF_DELAYMODE_NORMAL 0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_LFOF_DELAYMODE_DELAY 0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE                17:16 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_BYPASS         0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_STEREO_DLS2    0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_STEREO_P_EQ    0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_STEREO_BYPASS  0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_MONO_DLS2      0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_MONO_P_EQ      0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_MONO_DLS2_P_EQ 0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_THREED_DLS2_I3DL2 0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_THREED_P_EQ_I3DL2 0x02 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_FMODE_THREED_I3DL2   0x03 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_BPQ                  20:18 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT     23:23 /* -W-VF */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT_DISABLE 0x00 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_NOTIFY_INTERRUPT_ENABLE 0x01 /* -W--V */
#define NV1BA0_PIO_SET_VOICE_CFG_MISC_V_GSCNT              31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_HRTF                      0x0000031C /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_HRTF_HANDLE               15:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY                    0x00000350 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOADLY            14:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOADR             15:15 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOFDLY            30:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_PAR_LFODLY_LFOFDR             31:31 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_SSL_A                         0x00000320 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_SSL_A_COUNT                   7:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_SSL_A_BASE                    23:8 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_SSL_B                         0x0000035C /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_SSL_B_COUNT                   7:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_SSL_B_BASE                    23:8 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_BASE                  0x000003A0 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_BASE_OFFSET           23:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_LBO                   0x000003A4 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_LBO_OFFSET            23:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_BUF_CBOFRAC                   0x000003D4 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_BUF_CBOFRAC_FRACTION          15:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_BUF_CBO                       0x000003D8 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_BUF_CBO_OFFSET                23:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_EBO                   0x000003DC /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_CFG_BUF_EBO_OFFSET            23:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA                      0x00000360 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME6_B3_0         3:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME0              15:4 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME7_B3_0         19:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLA_VOLUME1              31:20 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB                      0x00000364 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME6_B7_4         3:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME2              15:4 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME7_B7_4         19:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLB_VOLUME3              31:20 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC                      0x00000368 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME6_B11_8        3:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME4              15:4 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME7_B11_8        19:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_VOLC_VOLUME5              31:20 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_ENV                       0x0000036C /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_LFO_ENV_EA_RELEASERATE        11:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_ENV_LFOADLT               21:12 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_ENV_LFOFDLT               31:22 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD                       0x00000370 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAAM                7:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAFM                15:8 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOAFC                23:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_LFO_MOD_LFOFFM                31:24 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_FCA                       0x00000374 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_FCA_FC0                   15:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_FCA_FC1                   31:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_FCB                       0x00000378 /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_FCB_FC2                   15:0 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_FCB_FC3                   31:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_PITCH                     0x0000037c /* -W-4R */
#define NV1BA0_PIO_SET_VOICE_TAR_PITCH_STEP                31:16 /* -W-UF */
#define NV1BA0_PIO_SET_VOICE_TAR_PITCH_STEP_SMAX           0x00001fff /* -W--V */
#define NV1BA0_PIO_SET_CURRENT_HRTF_ENTRY                  0x00000160 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_HRTF_ENTRY_HANDLE           15:0 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR(i)                             (0x00000400+(i)*4) /* -W-4A */
#define NV1BA0_PIO_SET_HRIR__SIZE_1                        15 /* */ 
#define NV1BA0_PIO_SET_HRIR_LEFT0                          7:0 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_RIGHT0                         15:8 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_LEFT1                          23:16 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_RIGHT1                         31:24 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_X                              0x0000043C /* -W-4R */
#define NV1BA0_PIO_SET_HRIR_X_LEFT30                       7:0 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_X_RIGHT30                      15:8 /* -W-VF */
#define NV1BA0_PIO_SET_HRIR_X_ITD                          31:16 /* -W-SF */
#define NV1BA0_PIO_SET_HRIR_X_ITD_SMIN                     0x0000ac01 /* RW--V */
#define NV1BA0_PIO_SET_HRIR_X_ITD_SMAX                     0x000053ff /* RW--V */
#define NV1BA0_PIO_SET_CURRENT_SSL_CONTEXT_DMA             0x0000018C /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_SSL_CONTEXT_DMA_HANDLE      31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_SSL                         0x00000190 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_SSL_BASE_PAGE               21:6 /* -W-VF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET(i)               (0x00000600+(i)*8) /* -W-4A */
#define NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET__SIZE_1          64 /* */ 
#define NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET_PARAMETER        31:0 /* -W-VF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH(i)               (0x00000604+(i)*8) /* -W-4A */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH__SIZE_1          64 /* */ 
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_PARAMETER        15:0 /* -W-UF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE   17:16 /* -W-VF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B8 0x00 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B16 0x01 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_ADPCM 0x02 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_CONTAINER_SIZE_B32 0x03 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_SAMPLES_PER_BLOCK 22:18 /* -W-UF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO           23:23 /* -W-VF */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO_NOTOK     0x00 /* -W--V */
#define NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH_STEREO_OK        0x01 /* -W--V */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_CONTEXT_DMA       0x00000800 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_CONTEXT_DMA_HANDLE 31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE                   0x00000804 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_HANDLE            31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_OFFSET            0x00000808 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_INBUF_SGE_OFFSET_PARAMETER  31:12 /* -W-VF */
#define NV1BA0_PIO_SET_OUTBUF_BA(i)                        (0x00001000+(i)*8) /* -W-4A */
#define NV1BA0_PIO_SET_OUTBUF_BA__SIZE_1                   4 /* */ 
#define NV1BA0_PIO_SET_OUTBUF_BA_ADDRESS                   22:8 /* -W-UF */
#define NV1BA0_PIO_SET_OUTBUF_LEN(i)                       (0x00001004+(i)*8) /* -W-4A */
#define NV1BA0_PIO_SET_OUTBUF_LEN__SIZE_1                  4 /* */ 
#define NV1BA0_PIO_SET_OUTBUF_LEN_VALUE                    22:8 /* -W-UF */
#define NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE                  0x00001800 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_HANDLE           31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA      0x00001804 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA_HANDLE 31:0 /* -W-VF */
#define NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET           0x00001808 /* -W-4R */
#define NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET_PARAMETER 31:12 /* -W-VF */
#define NV1BA0_DMA_NOP                                     0x00000100 /* -W-4R */
#define NV1BA0_DMA_NOP_PARAMETER                           31:0 /* -W-VF */

#endif /* __NV_UAP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\eputil.h ===
;*******************************************************************
;
;    EpUtil.h		Global header file for Encode Audio Processor   
;
;
;       Modified by Ethan Brodsky
;		Based on EpUtil.h Written by Gints Klimanis, September 2000
;
;
;******************************************************************        

kFrameLength	equ		32
kPCValue		equ		0
kCounter		equ		0

; ==============================================================
; EP Address Map 
; ==============================================================
; Relative to EPBase (24 bit words (3 bytes) in 32-bit containers (4 bytes))
;     0x0000 - 0x2FFC   EP DSP X-Memory 3K Words (24 lsbits of Dword)     
;     0x6000 - 0x63FC   EP DSP Y-Memory 256 Words (24 lsbits of Dword) 
;     0xA000 - 0xDFFC   EP DSP P-Memory 4K Words (24 lsbits of Dword) 
;     0xFE00 - 0xFFF8   EP DSP Peripheral Registers
;     0xFFFC            EP DSP Reset
;
; Peripheral registers (Control,Status) mapped to upper 128 words
; of X-memory (0xFFFF80 to 0xFFFFFF) so they can be accessed with movep 
;
; EP DSP memory addresses 24-bit words
; System memory address    8-bit words 

kEPMemory_Base		equ $000000
kEPMemory_Base_XRAM	equ (kEPMemory_Base+$000000)
kEPMemory_Base_YRAM	equ (kEPMemory_Base+$001800)
kEPMemory_Base_PRAM	equ (kEPMemory_Base+$002800)

kEPMemory_Size_XRAM	equ 3072
kEPMemory_Size_YRAM	equ 256
kEPMemory_Size_PRAM	equ 4096

kEPMemory_Base_BootROM			equ $FF0000	; X-memory, 128 words
;kEPMemory_Base_PeripheralRegisters	equ $FFFF80	; X-memory, to 0xFFFFFF

INTERRUPT_TABLE_BASE 		equ $FF0000

; VBA at $FF0000 (requires 256 word alignment).  
; The vector table is exactly where the power-up reset starts fetching instructions.
; The first interrupt vector is hardware RESET.
; Only needs up to $24 (36d) .. $44 (68d) interrupts or so, not full 256 word table.

INTERRUPT_REGISTER		equ $FFFFC5	; Interrupt request/clear register
kAbortFrameBit		equ		0			; Bit 0
kStartFrameBit		equ		1			
kPutUpdateBit		equ		2
kMailInUpdateBit	equ		3
kDMAComplete1Bit	equ		4
kDMAComplete2Bit	equ		5
kDMAComplete3Bit	equ		6	
kDMAEndOfListBit	equ		7
kTimer1Bit			equ		8
kTimer2Bit			equ		9
kDMAErrorBit		equ		10
kAddressErrorBit	equ		11

; ==============================================================
;  FIFO stuff  
; ==============================================================
FIFOOUT_CONTROL_REGISTER	equ		$FFFFC8
FIFOIN_CONTROL_REGISTER		equ		$FFFFC9
SAMPLE_CONTROL_REGISTER		equ		$FFFFCA

kFIFO_Channels1			equ	$0
kFIFO_Channels2			equ	$1
kFIFO_Channels4			equ	$2
kFIFO_Channels6			equ	$3

kFIFO_SampleFormat08	equ	$0
kFIFO_SampleFormat16	equ	$1
kFIFO_SampleFormat24	equ	$2
kFIFO_SampleFormat32	equ	$3

; Output FIFO Configuration word:  
;   Bits 4:3  Sample Format = 10  (24-bits, 3 byte words ??)
;   Bits   2  Iso Bit       = 0 
;   Bits 1:0  # channels    = 2    (Stereo)
; 10-0-10 = $12
kFifoOut0_DefaultWord	equ	$12	

; Current Value is bits 23:2  (22 bits)	(from dev_apu.ref)
NV_PAPU_EPOFCUR0  equ	$0000302C 
NV_PAPU_EPOFCUR1  equ	$0000303C 
NV_PAPU_EPOFCUR2  equ	$0000304C 
NV_PAPU_EPOFCUR3  equ	$0000305C 

; End Value is bits 23:8  (16 bits) (from dev_apu.ref)
NV_PAPU_EPOFEND0  equ	$00003028 
NV_PAPU_EPOFEND1  equ	$00003038 
NV_PAPU_EPOFEND2  equ	$00003048 
NV_PAPU_EPOFEND3  equ	$00003058 

; Base Value is bits 23:8 (16 bits) (from dev_apu.ref)
NV_PAPU_EPOFBASE0  equ	$00003024 
NV_PAPU_EPOFBASE1  equ	$00003034 
NV_PAPU_EPOFBASE2  equ	$00003044 
NV_PAPU_EPOFBASE3  equ	$00003054 

; ==============================================================
;  Command stuff		Bits 11:2  offset in 4KB circular buffer
; ==============================================================
kEPMemory_Base_CommandCue		equ $FFF000		; Top 4KByte page

COMMAND_GET_REGISTER 		equ $FFFFC0	; Ptr to next read location
COMMAND_PUT_REGISTER 		equ $FFFFC1	; Ptr to 1st empty write location


MAILBOX_OUT                 equ $ffffC2
MAILBOX_IN                  equ $ffffC3

TIMER1_CONFIG               equ $FFFFB0
TIMER2_CONFIG               equ $FFFFB4

TIMER1_CONTROL              equ $FFFFB1
TIMER2_CONTROL              equ $FFFFB5

TIMER1_TERMINAL_COUNT       equ $ffffB2
TIMER2_TERMINAL_COUNT       equ $ffffB6

TIMER1_COUNT                equ $ffffB3
TIMER2_COUNT                equ $ffffB7



; ==============================================================
;  Processing control
; ==============================================================
PROCESSING_CONTROL_REGISTER		equ $FFFFC4	
kProcessingControl_SetIdleBit				equ 0		; Bit 0
kProcessingControl_NotifyInterruptBit		equ 1		

; ==============================================================
;  Global Sample Count Register		Bits 23:0
; ==============================================================
GLOBAL_SAMPLE_COUNT_REGISTER		equ $FFFFC6	

;************************************************************
; EPClearInterruptRegister	Clear  EP register
;************************************************************
EPClearInterruptRegister macro
      	movep    #$FFF,x:INTERRUPT_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end EPClearInterruptRegister ----

;************************************************************
; EPClearProcessingControlRegister	Clear  EP register
;************************************************************
EPClearProcessingControlRegister macro
      	movep    #$3,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"	
	endm
; ---- end EPClearProcessingControlRegister ----

;************************************************************
; EPClearSampleControlRegister	Clear  EP register
;************************************************************
EPClearSampleControlRegister macro
      	movep    #$0,x:SAMPLE_CONTROL_REGISTER	 
	endm
; ---- end EPClearSampleControlRegister ----

;************************************************************
; EPSetIdleBit		Assert EP Idle signal (Bit 0)
;************************************************************
EPSetIdleBit macro
	movep    #1,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end EPSetIdleBit ----

;************************************************************
; EPClearStartFrameBit		Start Frame (Bit 1)
;************************************************************
EPClearStartFrameBit macro
	movep    #2,x:INTERRUPT_REGISTER  ; "Write-1-To-Clear-One"	
	endm
; ---- end EPClearStartFrameBit ----

;************************************************************
; EPClearDataRAM	 Zero-fill X and Y memories
;************************************************************
EPClearDataRAM macro
	jsr	 EPClearXRAM
	jsr	 EPClearYRAM
	endm
; ---- end EPClearDataRAM ----

;************************************************************
; EPWritePC	 For IKOS debug, write Program Counter value to memory
;************************************************************
EPWritePC macro
	move	#0,r5
	lra		r5,x0	; yep, here's the PC relative address PC+0
	move	x0,a
	nop				; to avoid warnings
	dec		a
	nop				; to avoid warnings
	move	a,y:kCounter
	endm
; ---- end EPWritePC ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\nv_ugp.h ===
#ifndef __NV_UGP_H__
#define __NV_UGP_H__

// Gp interface methods for a MCP1 client
// The client will use NV1BA0_CHANNEL_DMA_PUT to put the functions in the commandQ.
// methods are 32 bits.  data is 32 bits

// Address in GP DSP PMEM to place offset of shared EP/GP AC3 output buffer
#define NV_AUDGP_DSP_AC3_OFFSET_ADDR            0x28
#define NV_AUDGP_DSP_GPCOMMANDNODE_OFFSET_ADDR  0x29	// GP Command Node Base Address

// METHOD: SetContextDmaDspBlock - sets context DMA for memory holding the DSP data
// DATA(32) : Context DMA handle
//#define NV_AUDGP_SET_CONTEXT_DMA_DSP_BLOCK               0x0000000
//#define NV_AUDGP_SET_CONTEXT_DMA_DSP_BLOCK_HANDLE        31:0

// METHOD: ReadDSPBlock  read one block from scratch memory
// DATA(32): block ID  (code, module list, state block)
// DATA(32): block byte address
// DATA(32): block byte size
#define NV_AUDGP_READ_DSP_BLOCK                    0x00000001
#define NV_AUDGP_READ_DSP_BLOCK_ID					31:0
#define NV_AUDGP_READ_DSP_BLOCK_ADDRESS				31:0
#define NV_AUDGP_READ_DSP_BLOCK_SIZE				31:0

// METHOD: WriteDSPBlock  write one block to scratch memory
// DATA(32): block ID  (code, module list, state block)
// DATA(32): block byte address
// DATA(32): block byte size
#define NV_AUDGP_WRITE_DSP_BLOCK                    0x00000002
#define NV_AUDGP_WRITE_DSP_BLOCK_ID					31:0
#define NV_AUDGP_WRITE_DSP_BLOCK_ADDRESS			31:0
#define NV_AUDGP_WRITE_DSP_BLOCK_SIZE				31:0

#define NV_AUDGP_DSP_BLOCK_ID_COMMAND_NODE         0x0
#define NV_AUDGP_DSP_BLOCK_ID_MODULE_LIST          0x1
#define NV_AUDGP_DSP_BLOCK_ID_STATE_XRAM           0x2
#define NV_AUDGP_DSP_BLOCK_ID_STATE_YRAM           0x3
#define NV_AUDGP_DSP_BLOCK_ID_CODE                 0x4
#define NV_AUDGP_DSP_BLOCK_ID_STATE_LARGE          0x5

// Some DSP block byte addresses (set in command node)
#define NV_AUDGP_DSP_BLOCK_ID_COMMAND_NODE_OFFSET    19000	// $ 4A38
#define NV_AUDGP_DSP_BLOCK_ID_MODULE_LIST_OFFSET     19100	// $ 4A9C
#define NV_AUDGP_DSP_BLOCK_ID_STATE_XRAM_OFFSET      19500	// $ 4C2C
#define NV_AUDGP_DSP_BLOCK_ID_STATE_YRAM_OFFSET      31788	// $ 7C2C
#define NV_AUDGP_DSP_BLOCK_ID_CODE_OFFSET			 39980	// $ 9C2C
#define NV_AUDGP_DSP_BLOCK_ID_STATE_LARGE_OFFSET     56464	// $ DC90

/*
METHOD: RouteEffect
DATA(32):   effect instance id
            Bit identifying if the effect is the source, or destination,
            Effect Pin 
            Mixer buffer ID
            enable or disable data connection
*/
//#define NV_AUDGP_ROUTE_EFFECT                           0x00000003
#define NV_AUDGP_ROUTE_EFFECT_FILLER                    7:0	// was effectID
#define NV_AUDGP_ROUTE_EFFECT_ORIENTATION               8:8
#define NV_AUDGP_ROUTE_EFFECT_ORIENTATION_SOURCE        0x0
#define NV_AUDGP_ROUTE_EFFECT_ORIENTATION_DEST          0x1
#define NV_AUDGP_ROUTE_EFFECT_PIN                       12:9
#define NV_AUDGP_ROUTE_EFFECT_BUFFER_ID                 20:13
#define NV_AUDGP_ROUTE_EFFECT_CONNECTION                21:21
#define NV_AUDGP_ROUTE_EFFECT_CONNECTION_ENABLE         0x0
#define NV_AUDGP_ROUTE_EFFECT_CONNECTION_DISABLE        0x1

typedef union _routeEffect
{
    struct
    {
        U032 stuf           : 8;	// Filler material
        U032 orientation    : 1;
        U032 pin            : 4;
        U032 bufid          : 8;
        U032 connection     : 1;
        U032                : 10;
    };

	U032 effectID;
    U032 uValue;
} STRUCT_ROUTE_EFFECT;

/*
METHOD: RouteToFIFO - Connects either an effect or buffer to a FIFO 
DATA(32) :  source type (effect or buffer)
            source id (if effect then effect ID, else buffer ID)
            source pin (only used if source type = effect, in which case it's the effect pin)
            fifo type (input fifo, or output fifo) - configure with NV_AUDGP_CONFIGURE_XXX_FIFO
            fifo pin
            connection enable or disable
*/
//#define NV_AUDGP_ROUTE_TO_FIFO                      0x00000004
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_TYPE          0:0
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_TYPE_EFFECT   0x0
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_TYPE_BUFFER   0x1
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_ID            8:1
#define NV_AUDGP_ROUTE_TO_FIFO_SOURCE_PIN           12:9
#define NV_AUDGP_ROUTE_TO_FIFO_TYPE                 13:13
#define NV_AUDGP_ROUTE_TO_FIFO_TYPE_INPUT           0x0
#define NV_AUDGP_ROUTE_TO_FIFO_TYPE_OUTPUT          0x1
#define NV_AUDGP_ROUTE_TO_FIFO_NUMBER               15:14
#define NV_AUDGP_ROUTE_TO_FIFO_PIN                  19:16
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_0                0x0
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_1                0x1
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_2                0x2
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_3                0x3
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_4                0x4
#define NV_AUDGP_ROUTE_TO_FIFO_PIN_5                0x5
#define NV_AUDGP_ROUTE_TO_FIFO_CONNECTION           20:20
#define NV_AUDGP_ROUTE_TO_FIFO_CONNECTION_ENABLE    0x0
#define NV_AUDGP_ROUTE_TO_FIFO_CONNECTION_DISABLE   0x1

typedef union _routeEffectToFifo
{
    struct
    {
        U032 sourceType : 1;
        U032 sourceID   : 8;
        U032 sourcePin  : 4;
        U032 fifoType   : 1;
        U032 fifoNum    : 2;
        U032 fifoPin    : 4; 
        U032 connection : 1;
        U032            : 11;
    };

    U032 uValue;
} STRUCT_ROUTE_TO_FIFO;

/* 
METHOD: GetMixerBuffer - Reserves a mixer buffer ID to used for connecting/routing effects.
This ID is used in RouteEffect calls, and is returned in a notifier as a 8-bit identifier.
DATA(32): Allocate HW mix bin, or a SW mix bin (mix bin in the DSP/scratch memory)
Return(8) : Mixer buffer ID
*/
#define NV_AUDGP_GET_MIX_BUFFER                         0x0000000B
#define NV_AUDGP_GET_MIX_BUFFER_TYPE                    1:0
#define NV_AUDGP_GET_MIX_BUFFER_TYPE_HW                 0x0
#define NV_AUDGP_GET_MIX_BUFFER_TYPE_SW                 0x1
#define NV_AUDGP_GET_MIX_BUFFER_TYPE_DONT_CARE          0x2

/* 
METHOD: FreeMixerBuffer - Frees an allocated mix buffer
DATA(32): ID of buffer to free
*/
#define NV_AUDGP_FREE_MIX_BUFFER                        0x0000000C
#define NV_AUDGP_FREE_MIX_BUFFER_ID                     7:0

/*
METHOD: SetContextDmaNotifier - Sets the context DMA for the GP notifier
DATA(32): Handle returned from AllocContextDma
*/
#define NV_AUDGP_SET_CONTEXT_DMA_NOTIFIER               0x0000000D
#define NV_AUDGP_SET_CONTEXT_DMA_NOTIFIER_VALUE         31:0

/*
METHOD: ConfigureOutputFIFO(i) - configure the output fifo - do this before you point an
effect to it.
DATA(32) : Data format
            If the data transfers are isochronous
            Data size and container size where
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_8_8       =  8-bit data in 8-bit container(always in blocks of 4)
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_16_16     = 16-bit data in 16-bit container (always in blocks of two)
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_24_32_MSB = 24 bit data in 32-bit container (msb justified)
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_24_32_LSB = 24-bit data in 32-bit container (lsb justified)
            NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_32_32     = 32 bit data in 32-bit container
*/
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO(i)               (0x00000010+(i))
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT           1:0
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT_MONO      0x0
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT_STEREO    0x1
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT_QUAD      0x2
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_FORMAT_HEX       0x3
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_TYPE             2:2
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_TYPE_NONISO      0x0
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_TYPE_ISO         0x1
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE             5:3
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_8_8         0x0
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_16_16       0x1
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_24_32_MSB   0x2
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_24_32_LSB   0x3
#define NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_32_32       0x4

// METHOD: ConfigureInputFIFO(i) - configure the input fifo
#define NV_AUDGP_CONFIGURE_INPUT_FIFO(i)                (0x00000014+(i))
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT            1:0
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT_MONO       0x0
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT_STEREO     0x1
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT_QUAD       0x2
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_FORMAT_HEX        0x3
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_TYPE              2:2
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_TYPE_NONISO       0x0
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_TYPE_ISO          0x1
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE              5:3
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_8_8          0x0
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_16_16        0x1
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_24_32_MSB    0x2
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_24_32_LSB    0x3
#define NV_AUDGP_CONFIGURE_INPUT_FIFO_SIZE_32_32        0x4



typedef union _configureFifo
{
    struct
    {
        U032 format         : 2;
        U032 type           : 1;
        U032 size           : 3;
        U032                : 26;
    };

    U032 uValue;
} STRUCT_CONFIGURE_FIFO;


// METHOD: AllocScratchMemory - Used to allocate scratch memory
// DATA(32) : Number of bytes to allocate
// Return(32) : Offset into scratch memory
#define NV_AUDGP_ALLOC_SCRATCH_MEMORY                   0x00000017
#define NV_AUDGP_ALLOC_SCRATCH_MEMORY_BYTES             31:0

// METHOD: FreeScratchMemory - Used to free allocated scratch memory
// DATA(32) : Offset into scratch memory
// DATA(32) : Number of bytes to free
#define NV_AUDGP_FREE_SCRATCH_MEMORY                    0x00000018
#define NV_AUDGP_FREE_SCRATCH_MEMORY_OFFSET             31:0
#define NV_AUDGP_FREE_SCRATCH_MEMORY_SIZE               31:0

// METHOD: SetScratchMemory - Used to set scratch memory to a value
// DATA(32) : Offset into scratch memory
// DATA(32) : Number of DWORDS to set
// DATA(32) : Value to set memory
#define NV_AUDGP_SET_SCRATCH_MEMORY                     0x00000019
#define NV_AUDGP_SET_SCRATCH_MEMORY_OFFSET              31:0
#define NV_AUDGP_SET_SCRATCH_MEMORY_SIZE				31:0
#define NV_AUDGP_SET_SCRATCH_MEMORY_VALUE               31:0

// METHOD: ReadScratchMemory  read blocks to scratch memory
// DATA(32): block system memory byte address offset
// DATA(32): block byte size
#define NV_AUDGP_READ_SCRATCH_MEMORY                 0x0000001A
#define NV_AUDGP_READ_SCRATCH_MEMORY_OFFSET				31:0
#define NV_AUDGP_READ_SCRATCH_MEMORY_ADDRESS			31:0
#define NV_AUDGP_READ_SCRATCH_MEMORY_SIZE				31:0

// METHOD: WriteScratchMemory  write blocks to scratch memory
// DATA(32): block system memory byte address offset
// DATA(32): block byte size
#define NV_AUDGP_WRITE_SCRATCH_MEMORY                 0x0000001B
#define NV_AUDGP_WRITE_SCRATCH_MEMORY_OFFSET			31:0
#define NV_AUDGP_WRITE_SCRATCH_MEMORY_ADDRESS			31:0
#define NV_AUDGP_WRITE_SCRATCH_MEMORY_SIZE				31:0

/*
METHOD: SetCallbackTimer - sets the callback timer at which the callback registered
                           by the client in AUDIO_INIT_DEVICE.pISRFn is called
DATA(32) : callback control field
*/

#define NV_AUDGP_SET_CALLBACK_TIMER                     0x00000020
#define NV_AUDGP_SET_CALLBACK_TIMER_OPERATION           0:0
#define NV_AUDGP_SET_CALLBACK_TIMER_OPERATION_STOP      0x0
#define NV_AUDGP_SET_CALLBACK_TIMER_OPERATION_START     0x1
#define NV_AUDGP_SET_CALLBACK_TIMER_TYPE                1:1
#define NV_AUDGP_SET_CALLBACK_TIMER_TYPE_1_SHOT         0x0
#define NV_AUDGP_SET_CALLBACK_TIMER_TYPE_PERIODIC       0x1
#define NV_AUDGP_SET_CALLBACK_TIMER_OPERATION_INTERVAL  18:2        /* time interval in milliseconds */
                                                                    /* finer resolution sacrificed for performance */

typedef union _callbackTimer
{
    struct
    {
        U032 op             : 1;
        U032 type           : 1;
        U032 interval       : 18;
        U032                : 12;
    };
    
    U032 uValue;
} STRUCT_SET_TIMER;

/*
METHOD: SetCallbackTimerServiceContext - sets the service context for the above timer
DATA(32) : value
*/

/*
i'm holding this off till we get a good case to set service context out here
instead of in AUDIO_INIT_DEVICE.pServiceContext

#define NV_AUDGP_SET_CALLBACK_TIMER_SERVICE_CONTEXT         0x00000021 
#define NV_AUDGP_SET_CALLBACK_TIMER_SERVICE_CONTEXT_VALUE   31:0
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\ldr_tab.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			ldr_tab.asm
;												
;   Contents:		Loader Table for System Memory addresses for X-Box
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/13/2000 8:30:42 AM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'Loader Table'

	section	Loader_Table

;**** include files ***********

	nolist
	include 'ldr_sip.inc'
	list

;**** program code ************

	xdef	LdrTable

	org		p(101):					; Loader Table runtime counter is 101

LdrTable		ds		LDR_TABLE_SIZE

; ******************************************************************

	endsec		; Loader_Table

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\refcount.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       refcount.h
 *  Content:    Basic reference-counting class.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  08/06/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __REFCOUNT_H__
#define __REFCOUNT_H__

#ifdef __cplusplus

class CRefCountTest
{
protected:
    DWORD                   m_dwRefCount;

public:
    CRefCountTest(DWORD dwInitialRefCount = 1);
    virtual ~CRefCountTest(void);

public:
    virtual DWORD STDMETHODCALLTYPE AddRef(void);
    virtual DWORD STDMETHODCALLTYPE Release(void);
};

__inline CRefCountTest::CRefCountTest(DWORD dwInitialRefCount)
    : m_dwRefCount(dwInitialRefCount)
{
}

__inline CRefCountTest::~CRefCountTest(void)
{
    ASSERT(!m_dwRefCount);
}

__inline DWORD CRefCountTest::AddRef(void)
{
    ASSERT(m_dwRefCount < ~0UL);
    return ++m_dwRefCount;
}

__inline DWORD CRefCountTest::Release(void)
{
    ASSERT(m_dwRefCount);

    if(m_dwRefCount > 0)
    {
        if(!--m_dwRefCount)
        {
            delete this;
            return 0;
        }
    }

    return m_dwRefCount;
}

template <class type> type *__AddRef(type *p)
{
    if(p)
    {
        p->AddRef();
    }

    return p;
}

#define ADDREF(p) \
    __AddRef(p)

#define RELEASE(p) \
    { \
        if(p) \
        { \
            (p)->Release(); \
            (p) = NULL; \
        } \
    }

#endif // __cplusplus

#endif // __REFCOUNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\encds.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 08/07/01, 13:33:26
;	Program info
;	  Program number: 1
;	  Revision number: 1.96
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 691 words
;	  Checksum: $B9C253

		dc	$D01B40,$0002B3,$010160,$B9C253,$050C40,$040C37,$048AA7,$051884
		dc	$05B7B1,$066A4A,$0732AE,$081385,$090FCC,$0A2ADB,$0B6873,$0CCCCD
		dc	$0E5CA1,$101D3F,$12149A,$144961,$16C311,$198A13,$1CA7D7,$2026F3
		dc	$241347,$287A27,$2D6A86,$32F52D,$392CEE,$4026E7,$47FACD,$50C336
		dc	$5A9DF8,$65AC8C,$721483,$7FFFFF,$607000,$00062E,$20000B,$05A406
		dc	$44F400,$008002,$447000,$000604,$050C05,$44F400,$000002,$447000
		dc	$000604,$44F400,$00000A,$447000,$000600,$44F400,$00060A,$447000
		dc	$000601,$44F400,$000610,$447000,$000602,$44F400,$000616,$447000
		dc	$000603,$44F400,$00061C,$447000,$000605,$44F400,$000622,$447000
		dc	$000606,$44F400,$000628,$447000,$000607,$44F400,$000000,$447000
		dc	$000608,$44F400,$000100,$447000,$000609,$60F400,$00060A,$44F400
		dc	$000000,$445800,$44F400,$000100,$445800,$44F400,$000200,$445800
		dc	$44F400,$000300,$445800,$44F400,$000400,$445800,$44F400,$FFFFFF
		dc	$446000,$60F400,$000610,$44F400,$000001,$445800,$445800,$445800
		dc	$445800,$445800,$240000,$446000,$60F400,$000616,$44F400,$FFFFFF
		dc	$445800,$445800,$445800,$445800,$445800,$446000,$60F400,$00061C
		dc	$44F400,$000400,$445800,$44F400,$FFFFFF,$445800,$44F400,$000500
		dc	$445800,$44F400,$FFFFFF,$445800,$44F400,$FFFFFF,$445800,$44F400
		dc	$FFFFFF,$445800,$60F400,$000622,$44F400,$000001,$445800,$240000
		dc	$445800,$44F400,$000001,$445800,$240000,$445800,$240000,$445800
		dc	$240000,$445800,$60F400,$000628,$44F400,$FFFFFF,$445800,$445800
		dc	$445800,$445800,$445800,$445800,$56F400,$000007,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000007,$60F400,$000100
		dc	$70F400,$000100,$390100,$0D0180,$56F400,$000007,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$56F400,$000007,$60F400,$000300
		dc	$70F400,$000100,$390300,$0D0180,$56F400,$000007,$60F400,$000400
		dc	$70F400,$000100,$390400,$0D0180,$62F013,$00062E,$021ADC,$44F400
		dc	$000001,$200045,$202941,$44F400,$00001F,$200045,$202741,$219800
		dc	$60F400,$000305,$07E885,$050818,$60F413,$000600,$57F400,$000016
		dc	$0D1080,$00001C,$56F400,$000008,$60F400,$000400,$70F400,$000100
		dc	$390000,$0D0180,$56F400,$000008,$60F400,$000500,$70F400,$000100
		dc	$390100,$0D0180,$00000C,$60F400,$000000,$068092,$000005,$44D800
		dc	$46D0A1,$5658E9,$575800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0
		dc	$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000016,$20004D,$0D104A
		dc	$000008,$300000,$56F400,$000000,$57F400,$FFFFFF,$00000C,$0D1080
		dc	$0000B8,$56F000,$000632,$200003,$05A406,$0D1080,$000150,$0D1080
		dc	$00012F,$050C03,$0D1080,$000153,$0D1080,$000130,$56F000,$000633
		dc	$014085,$05A417,$66F000,$00062F,$3E0300,$60EE00,$3E0400,$61EE00
		dc	$66F000,$000630,$3E0300,$70EE00,$3E0400,$71EE00,$46F400,$5A827A
		dc	$62F000,$000638,$06D210,$000005,$44E000,$44C9D0,$2000D3,$564800
		dc	$66F000,$00062F,$3E0000,$60EE00,$3E0200,$61EE00,$3E0100,$62EE00
		dc	$66F000,$000634,$3E0000,$64EE00,$3E0200,$65EE00,$66F000,$000630
		dc	$3E0000,$70EE00,$3E0200,$71EE00,$3E0100,$72EE00,$66F000,$000635
		dc	$3E0000,$74EE00,$76F400,$000002,$75EE00,$45F400,$5A827A,$66F000
		dc	$000638,$06D600,$000467,$44CA00,$56C800,$57C9A3,$564CAB,$574D00
		dc	$61F400,$000639,$65F000,$000687,$62F400,$00066D,$66F000,$000634
		dc	$3E0000,$60EE00,$221400,$66F000,$000635,$70EE00,$231C00,$50F000
		dc	$000638,$00000A,$211E00,$72F400,$000004,$0BF080,$00058B,$61F400
		dc	$000649,$65F000,$000687,$62F400,$000675,$66F000,$000634,$3E0200
		dc	$60EE00,$221400,$66F000,$000635,$70EE00,$231C00,$50F000,$000638
		dc	$00000A,$211E00,$72F400,$000004,$0BF080,$00058B,$61F400,$000659
		dc	$65F000,$000688,$62F400,$00067D,$66F000,$00062F,$3E0300,$60EE00
		dc	$221400,$66F000,$000630,$70EE00,$231C00,$50F000,$000638,$00000A
		dc	$211E00,$72F400,$000005,$0BF080,$00058B,$66F000,$000634,$3E0000
		dc	$60EE00,$3E0200,$61EE00,$66F000,$00062F,$3E0300,$62EE00,$66F000
		dc	$000635,$3E0000,$70EE00,$3E0200,$71EE00,$66F000,$000630,$3E0300
		dc	$72EE00,$45F400,$5A827A,$64F000,$000638,$06D400,$0004CB,$44CA00
		dc	$56E000,$57E1A3,$5648AF,$574900,$0D1080,$0000B4,$00000C,$205800
		dc	$44D800,$447000,$00062F,$44D800,$447000,$000630,$44D800,$447000
		dc	$000631,$57D800,$0C1890,$001027,$507000,$000632,$0C1890,$001019
		dc	$507000,$000633,$44D800,$447000,$000634,$44D800,$447000,$000635
		dc	$44D800,$447000,$000636,$57D800,$0C1890,$002024,$507000,$000637
		dc	$44D800,$447000,$000638,$00000C,$C0958D,$000000,$7ED4E5,$C00000
		dc	$000000,$4FE24A,$3F67CC,$3F67CC,$4FE24A,$7FFFFF,$855BE8,$756638
		dc	$756638,$855BE8,$7FFFFF,$EA1F92,$E2404B,$E2404B,$EA1F92,$7FFFFF
		dc	$812B1B,$7DAC85,$7ED594,$812A6C,$7ED594,$4FE24A,$3F67CC,$579426
		dc	$55FF7F,$579426,$4FE24A,$3F67CC,$579426,$55FF7F,$579426,$823E22
		dc	$7B876D,$7B876D,$823E22,$7FFFFF,$B23B5E,$27F74F,$27F74F,$B23B5E
		dc	$7FFFFF,$C08974,$000000,$7EED19,$C00000,$000000,$462AF8,$378620
		dc	$378620,$462AF8,$7FFFFF,$84EF9E,$763A35,$763A35,$84EF9E,$7FFFFF
		dc	$E648FE,$E4B78A,$E4B78A,$E648FE,$7FFFFF,$8112E7,$7DDC7F,$7EEDAC
		dc	$811254,$7EEDAC,$462AF8,$378620,$511DF3,$4EF590,$511DF3,$462AF8
		dc	$378620,$511DF3,$4EF590,$511DF3,$82101A,$7BE2ED,$7BE2ED,$82101A
		dc	$7FFFFF,$AF2EFC,$2C7800,$2C7800,$AF2EFC,$7FFFFF,$61F413,$000639
		dc	$064E90,$000002,$565900,$00000C,$60F400,$0004F4,$61F400,$000000
		dc	$065A90,$000003,$07D884,$4C5900,$56F000,$000637,$240000,$60F400
		dc	$00002D,$61F445,$000041,$05A405,$60F400,$000000,$61F400,$000014
		dc	$607000,$000687,$617000,$000688,$00000C,$56F400,$00000E,$57F400
		dc	$000000,$384E00,$0BF080,$000180,$00000C,$56F400,$00000E,$57F400
		dc	$000001,$60F400,$000639,$384E00,$390000,$0BF080,$000180,$00000C
		dc	$56F400,$00000E,$57F400,$000002,$60F400,$000639,$384E00,$390000
		dc	$0BF080,$000180,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600
		dc	$06DA10,$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4
		dc	$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09
		dc	$444C4C,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2
		dc	$200010,$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000
		dc	$239800,$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\dmautil.h ===
;*******************************************************************
;
;    DMAUtil.h		DMA header file for Global/Encode Audio Processor   
;
;
;		Written by Gints Klimanis
;
;******************************************************************        

; ==============================================================
;  DMA Engine stuff
; ==============================================================

kDMANode_MaxSize	equ		7	
kDMANode_Size		equ		6	
kDMANode_EOL		equ		$004000		; Bit 14 = Eol
kDMANode_EOLMask	equ		$003fff		; Will Clear Eol bit

DMA_CONTROL_REGISTER 		equ $FFFFD6	; Address of DMA control register
kDMA_ActionRequest_Start    	equ 1		 
kDMA_ActionRequest_Stop    		equ 2		 
kDMA_ActionRequest_Freeze    	equ 3		 
kDMA_ActionRequest_UnFreeze   	equ 4		 
kDMA_ActionRequest_Abort		equ 5
	 
kDMA_FrozenBit		equ		3	
kDMA_RunningBit		equ		4
kDMA_StoppedBit		equ		5

DMA_CONFIGURATION_REGISTER	equ $FFFFD7	; Address of DMA configuration register
kDMA_AutoStartBit		equ		0			; Bit 0
kDMA_AutoRdyBit			equ		1
kDMA_IocRequireClrBit	equ		2
kDMA_EolRequireClrBit	equ		3
kDMA_ErrRequireClrBit	equ		4

kDMASampleFormat_08bits		equ		0
kDMASampleFormat_16bits		equ		1
kDMASampleFormat_24msbits	equ		2
kDMASampleFormat_32bits		equ		3
kDMASampleFormat_24lsbits	equ		6

DMA_NEXT_BLOCK_CONTROL_REGISTER		equ $FFFFD4 ; Bit 14 eol, Bits 13:0  Head of List Address
												; Alter only in Idle State or frozen bit asserted
DMA_START_BLOCK_CONTROL_REGISTER	equ $FFFFD5	; Bit 14 e0l, Bits 13:0  Head of List Address

; *********** DMA Read/Write Words **************
; 
; dspBaseAddress = $000000 (0)
; blockSize      = $000000 (0)

; ---- Word 0
; eol         = $1 (1) 
; nextCmd     = $000000 (0)

; ---- Word 1
; interleave  = $0 ( 0) (bit    :0)
; rdDspMem    = $0 ( 0) (bit    :1)(DSP Memory <- System Memory)
; IOC         = $0 ( 0) (bit   3:2)
; smPtrWrBk   = $0 ( 0) (bit     4)
; smBufID     = $F (15) (bit   8:5)
; iso         = $0 ( 0) (bit     9)
; smDataFmt   = $6 ( 6) (bit 12:10)
; >>>>> CONTROLBITS = $19E0
; incr        = $1 ( 1) 

; ---- Word 1 without smDataFmt
; interleave  = $0 ( 0) (bit    :0)
; rdDspMem    = $0 ( 0) (bit    :1)(DSP Memory <- System Memory)
; IOC         = $0 ( 0) (bit   3:2)
; smPtrWrBk   = $0 ( 0) (bit     4)
; smBufID     = $F (15) (bit   8:5)
; iso         = $0 ( 0) (bit     9)
; smDataFmt   = $0 ( 0) (bit 12:10)
; >>>>> CONTROLBITS = $01E0
; incr        = $1 ( 1) 

; ---- Word 2
; Count1      = $0000 (0)
; Count0      = $0000 (0)

; ---- Word 3
; Nul         = $0 (0)
; PDspStart   = $000000 (0)

; ---- Word 4
; smOffset      = $000000 (0)

; ---- Word 5 (Used in circular buffers)
; smBaseAddress = $000000 (0)

; ---- Word 6 (Used in circular buffers)
; smSizeMinus1  = $000000 (0)

; >>>>>> Only need Words 0..4
;
;  Generated by dmawords.exe

DMA_BASE_READ0	equ	$004000
DMA_BASE_READ1	equ	$0059E0
DMA_BASE_READ1_ISO	equ	$005BE0
DMA_BASE_READ2	equ	$000000
DMA_BASE_READ3	equ	$000000
DMA_BASE_READ4	equ	$000000
DMA_BASE_READ5	equ	$000000

DMA_BASE_WRITE0	equ	DMA_BASE_READ0
DMA_BASE_WRITE1	equ	$0059E2
DMA_BASE_WRITE1_ISO	equ	$005BE2
DMA_BASE_WRITE2	equ	DMA_BASE_READ2
DMA_BASE_WRITE3	equ	DMA_BASE_READ3
DMA_BASE_WRITE4	equ	DMA_BASE_READ4
DMA_BASE_WRITE5	equ	DMA_BASE_READ5

DMA_BASE_WRITEFIFO1 equ $004402       ; 16-bit output, write to FIFO
DMA_BASE_WRITEFIFO2 equ $000403       ; 16-bit output, write to FIFO, Interleaved

DMA_BASE_WRITEFIFO1_ISO equ $004602       ; 16-bit output, write to FIFO    0000 0000 0100 0110 0000 0010
DMA_BASE_WRITEFIFO2_ISO equ $000603       ; 16-bit output, write to FIFO, Interleaved

DMA_BASE_WRITEFIFO_DATA_ISO equ $005A02  ; 0000 0000 0101 1010 0000 0010

DMA_NODE_EOL0	equ	$004000
DMA_NODE_EOL1	equ	$000000
DMA_NODE_EOL2	equ	$000000
DMA_NODE_EOL3	equ	$000000
DMA_NODE_EOL4	equ	$000000
DMA_NODE_EOL5	equ	$000000

;************************************************************
; GPClearDMAConfigRegister	Clear  register
;************************************************************
GPClearDMAConfigRegister macro
      	movep    #>0,x:DMA_CONFIGURATION_REGISTER	
	endm
; ---- end GPClearDMAConfigRegister ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\encds.h ===
0xD01B40, 0x0002BD, 0x010151, 0x5E46E5, 0x050C40, 0x040C37, 0x048AA7, 0x051884, 0x05B7B1, 0x066A4A, 0x0732AE, 0x081385, 0x090FCC, 0x0A2ADB, 0x0B6873, 0x0CCCCD, 0x0E5CA1, 0x101D3F, 0x12149A, 0x144961, 0x16C311, 0x198A13, 0x1CA7D7, 0x2026F3, 0x241347, 0x287A27, 0x2D6A86, 0x32F52D, 0x392CEE, 0x4026E7, 0x47FACD, 0x50C336, 0x5A9DF8, 0x65AC8C, 0x721483, 0x7FFFFF, 0x607000, 0x00062E, 0x20000B, 0x05A406, 0x44F400, 0x008002, 0x447000, 0x000604, 0x050C05, 0x44F400, 0x000002, 0x447000, 0x000604, 0x44F400, 0x00000A, 0x447000, 0x000600, 0x44F400, 0x00060A, 0x447000, 0x000601, 0x44F400, 0x000610, 0x447000, 0x000602, 0x44F400, 0x000616, 0x447000, 0x000603, 0x44F400, 0x00061C, 0x447000, 0x000605, 0x44F400, 0x000622, 0x447000, 0x000606, 0x44F400, 0x000628, 0x447000, 0x000607, 0x44F400, 0x000000, 0x447000, 0x000608, 0x44F400, 0x000100, 0x447000, 0x000609, 0x60F400, 0x00060A, 0x44F400, 0x000000, 0x445800, 0x44F400, 0x000100, 0x445800, 0x44F400, 0x000200, 0x445800, 0x44F400, 0x000300, 0x445800, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x446000, 0x60F400, 0x000610, 0x44F400, 0x000001, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x240000, 0x446000, 0x60F400, 0x000616, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x446000, 0x60F400, 0x00061C, 0x44F400, 0x000400, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0x000500, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x44F400, 0xFFFFFF, 0x445800, 0x60F400, 0x000622, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x44F400, 0x000001, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x240000, 0x445800, 0x60F400, 0x000628, 0x44F400, 0xFFFFFF, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x445800, 0x56F400, 0x000007, 0x60F400, 0x000000, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000100, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000200, 0x70F400, 0x000100, 0x390200, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000300, 0x70F400, 0x000100, 0x390300, 0x0D0180, 0x56F400, 0x000007, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390400, 0x0D0180, 0x62F013, 0x00062E, 0x021ADC, 0x44F400, 0x000001, 0x200045, 0x202941, 0x44F400, 0x00001F, 0x200045, 0x202741, 0x219800, 0x60F400, 0x000305, 0x07E885, 0x050818, 0x60F413, 0x000600, 0x57F400, 0x000016, 0x0D1080, 0x00001C, 0x56F400, 0x000008, 0x60F400, 0x000400, 0x70F400, 0x000100, 0x390000, 0x0D0180, 0x56F400, 0x000008, 0x60F400, 0x000500, 0x70F400, 0x000100, 0x390100, 0x0D0180, 0x00000C, 0x60F400, 0x000000, 0x068092, 0x000005, 0x44D800, 0x46D0A1, 0x5658E9, 0x575800, 0x00000C, 0x05F420, 0xFFFFFF, 0x0461A0, 0x0462A0, 0x0464A0, 0x0465A0, 0x0466A0, 0x00F3B8, 0x44F400, 0x000016, 0x20004D, 0x0D104A, 0x000008, 0x300000, 0x56F400, 0x000000, 0x57F400, 0xFFFFFF, 0x00000C, 0x0D1080, 0x0000B8, 0x56F000, 0x000632, 0x200003, 0x05A406, 0x0D1080, 0x00015A, 0x0D1080, 0x000139, 0x050C03, 0x0D1080, 0x00015D, 0x0D1080, 0x00013A, 0x56F000, 0x000633, 0x014085, 0x05A417, 0x66F000, 0x00062F, 0x3E0300, 0x60EE00, 0x3E0400, 0x61EE00, 0x66F000, 0x000630, 0x3E0300, 0x70EE00, 0x3E0400, 0x71EE00, 0x46F400, 0x5A827A, 0x62F000, 0x000638, 0x06D210, 0x000005, 0x44E000, 0x44C9D0, 0x2000D3, 0x564800, 0x66F000, 0x00062F, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x3E0100, 0x62EE00, 0x66F000, 0x000634, 0x3E0000, 0x64EE00, 0x3E0200, 0x65EE00, 0x66F000, 0x000630, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x3E0100, 0x72EE00, 0x66F000, 0x000635, 0x3E0000, 0x74EE00, 0x76F400, 0x000002, 0x75EE00, 0x45F400, 0x5A827A, 0x66F000, 0x000638, 0x06D600, 0x000467, 0x44CA00, 0x56C800, 0x57C9A3, 0x564CAB, 0x574D00, 0x61F400, 0x000639, 0x65F000, 0x00068D, 0x62F400, 0x000671, 0x66F000, 0x000634, 0x3E0000, 0x60EE00, 0x221400, 0x66F000, 0x000635, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x000595, 0x61F400, 0x000649, 0x65F000, 0x00068D, 0x62F400, 0x000679, 0x66F000, 0x000634, 0x3E0200, 0x60EE00, 0x221400, 0x66F000, 0x000635, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000004, 0x0BF080, 0x000595, 0x61F400, 0x000659, 0x65F000, 0x00068E, 0x62F400, 0x000681, 0x66F000, 0x00062F, 0x3E0300, 0x60EE00, 0x221400, 0x66F000, 0x000630, 0x70EE00, 0x231C00, 0x50F000, 0x000638, 0x00000A, 0x211E00, 0x72F400, 0x000006, 0x0BF080, 0x000595, 0x66F000, 0x000634, 0x3E0000, 0x60EE00, 0x3E0200, 0x61EE00, 0x66F000, 0x00062F, 0x3E0300, 0x62EE00, 0x66F000, 0x000635, 0x3E0000, 0x70EE00, 0x3E0200, 0x71EE00, 0x66F000, 0x000630, 0x3E0300, 0x72EE00, 0x45F400, 0x5A827A, 0x64F000, 0x000638, 0x06D400, 0x0004CB, 0x44CA00, 0x56E000, 0x57E1A3, 0x5648AF, 0x574900, 0x0D1080, 0x0000BE, 0x00000C, 0x205800, 0x44D800, 0x447000, 0x00062F, 0x44D800, 0x447000, 0x000630, 0x44D800, 0x447000, 0x000631, 0x57D800, 0x0C1890, 0x001027, 0x507000, 0x000632, 0x0C1890, 0x001019, 0x507000, 0x000633, 0x44D800, 0x447000, 0x000634, 0x44D800, 0x447000, 0x000635, 0x44D800, 0x447000, 0x000636, 0x57D800, 0x0C1890, 0x002024, 0x507000, 0x000637, 0x44D800, 0x447000, 0x000638, 0x00000C, 0xA2DD74, 0x3AE54D, 0xC51AB3, 0x5D228C, 0x800000, 0xCAE85F, 0x47C25A, 0x47C25A, 0xCAE85F, 0x7FFFFF, 0x855BE8, 0x756638, 0x756638, 0x855BE8, 0x7FFFFF, 0xEA1F92, 0xE2404B, 0xE2404B, 0xEA1F92, 0x7FFFFF, 0x812B1B, 0x7DAC85, 0x7ED594, 0x812A6C, 0x7ED594, 0xC48FCE, 0x1B99D0, 0x092E48, 0x092E5B, 0x092E6E, 0xCAE85F, 0x47C25A, 0x1768D5, 0x1768BD, 0x1768A5, 0xCAE85F, 0x47C25A, 0x1768D5, 0x1768BD, 0x1768A5, 0x823E22, 0x7B876D, 0x7B876D, 0x823E22, 0x7FFFFF, 0xB23B5E, 0x27F74F, 0x27F74F, 0xB23B5E, 0x7FFFFF, 0xA062D3, 0x3FC327, 0xC03CD9, 0x5F9D2D, 0x800000, 0xC37356, 0x4A2F0E, 0x4A2F0E, 0xC37356, 0x7FFFFF, 0x84EF9E, 0x763A35, 0x763A35, 0x84EF9E, 0x7FFFFF, 0xE648FE, 0xE4B78A, 0xE4B78A, 0xE648FE, 0x7FFFFF, 0x8112E7, 0x7DDC7F, 0x7EEDAC, 0x811254, 0x7EEDAC, 0xBFB2BF, 0x204D6F, 0x07ECAA, 0x07ECBB, 0x07ECCD, 0xC37356, 0x4A2F0E, 0x1448F5, 0x1448DE, 0x1448C8, 0xC37356, 0x4A2F0E, 0x1448F5, 0x1448DE, 0x1448C8, 0x82101A, 0x7BE2ED, 0x7BE2ED, 0x82101A, 0x7FFFFF, 0xAF2EFC, 0x2C7800, 0x2C7800, 0xAF2EFC, 0x7FFFFF, 0x61F413, 0x000639, 0x065490, 0x000002, 0x565900, 0x00000C, 0x60F400, 0x0004F4, 0x61F400, 0x000000, 0x066490, 0x000003, 0x07D884, 0x4C5900, 0x56F000, 0x000637, 0x240000, 0x60F400, 0x000032, 0x61F445, 0x000046, 0x05A405, 0x60F400, 0x000000, 0x61F400, 0x000014, 0x607000, 0x00068D, 0x617000, 0x00068E, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000000, 0x385400, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000001, 0x60F400, 0x000639, 0x385400, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x56F400, 0x00000E, 0x57F400, 0x000002, 0x60F400, 0x000639, 0x385400, 0x390000, 0x0BF080, 0x000180, 0x00000C, 0x71F400, 0xFFFFFE, 0x75F400, 0xFFFFFC, 0x229600, 0x06DA10, 0x000021, 0x57DA00, 0x51D200, 0xF0B900, 0x06DE10, 0x00000B, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xD0A1E2, 0x4549D2, 0x200010, 0x10DD09, 0x444C4C, 0x45E1D4, 0xF039D6, 0xF0A8E6, 0xF4A1D2, 0x4459E2, 0xF0A1E2, 0x4559D2, 0x200010, 0x21C409, 0x444C4C, 0x03F184, 0x555A00, 0x515A00, 0x22D400, 0x229000, 0x239800, 0x0460A4, 0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\llef13.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 06/24/01, 11:42:44
;	Program info
;	  Program number: 2
;	  Revision number: 1.64
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2116 words
;	  Checksum: $73202C

		dc	$D01B40,$000844,$020140,$73202C,$447000,$00095F,$607000,$000962
		dc	$20000B,$05A407,$0508DF,$0D1080,$0007BA,$0D1080,$0007ED,$050C05
		dc	$0D1080,$0007C0,$0D1080,$0007DA,$0508D9,$62F000,$000962,$60F400
		dc	$000FC2,$0A72D8,$000004,$240000,$447000,$000960,$5EE800,$0212DF
		dc	$20000B,$05A402,$014180,$547000,$000961,$44F000,$000960,$050952
		dc	$050811,$44F000,$000960,$0D1080,$0007E4,$56F000,$000960,$014180
		dc	$44F000,$000961,$547000,$000960,$200045,$0597D0,$0D1080,$0007A8
		dc	$00000C,$56F000,$000960,$44F000,$00095F,$0C1940,$008020,$547000
		dc	$00093D,$56F000,$000960,$200003,$05245A,$62F000,$000962,$60F400
		dc	$00094D,$44F400,$000080,$060690,$000002,$445800,$02129E,$0212D4
		dc	$0C1940,$00101B,$547000,$000930,$44F413,$000012,$0C1940,$005021
		dc	$547000,$000934,$021ADE,$022A94,$0C1940,$001021,$0222D4,$0C1940
		dc	$001022,$022294,$0C1940,$001023,$547000,$000935,$200013,$0242D4
		dc	$0C1940,$00201A,$547000,$000941,$021A94,$447000,$000942,$200013
		dc	$0232D4,$0C1940,$001018,$022AD4,$0C1940,$001019,$547000,$00093E
		dc	$023A94,$447000,$000940,$023294,$447000,$00093F,$60F413,$00092C
		dc	$57F400,$000010,$0D1080,$0002A9,$44F400,$000000,$200045,$057400
		dc	$00000C,$30001B,$0D1080,$0002A1,$00000C,$44F400,$000015,$447000
		dc	$00092C,$44F400,$00094D,$447000,$00092D,$44F400,$000959,$447000
		dc	$00092E,$44F400,$000953,$447000,$00092F,$44F400,$00FFFF,$447000
		dc	$000933,$44F400,$000941,$447000,$000936,$240000,$447000,$000931
		dc	$447000,$000932,$447000,$000937,$447000,$000938,$447000,$000939
		dc	$447000,$00093A,$447000,$00093B,$447000,$00093C,$60F400,$000947
		dc	$44F400,$000000,$445800,$44F400,$000002,$445800,$44F400,$000003
		dc	$445800,$44F400,$000004,$445800,$44F400,$000001,$445800,$44F400
		dc	$000005,$445800,$60F400,$000959,$44F400,$000001,$060690,$000002
		dc	$445800,$60F400,$000953,$44F400,$00FFFF,$060690,$000002,$445800
		dc	$00000C,$62F000,$000962,$45F400,$000003,$021296,$2000E0,$62F400
		dc	$000F92,$210E00,$200040,$60F400,$000080,$219A00,$70F400,$000100
		dc	$56F400,$000005,$79EA00,$0D0180,$200003,$052400,$00000C,$230800
		dc	$00000A,$04C8A0,$0461A0,$0464A0,$0465A0,$0004F8,$230E00,$200022
		dc	$219800,$221400,$044811,$223500,$5FE000,$4FE100,$5EE078,$06D810
		dc	$000009,$45D919,$200016,$8F8000,$8AB868,$4FE119,$200016,$CF1C00
		dc	$CA1D78,$230E00,$223022,$219800,$221400,$044811,$223500,$5FE000
		dc	$4FE100,$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868
		dc	$4FE119,$200016,$CF1C00,$CA1D78,$223000,$221400,$044811,$223500
		dc	$5FE000,$45E100,$5EE06C,$06D810,$000009,$4FD919,$200016,$8F8000
		dc	$8AB878,$45E119,$200016,$CF1C00,$CA1D6C,$230E00,$3A0222,$223000
		dc	$219900,$221100,$233200,$221400,$66F400,$000F52,$204900,$223500
		dc	$045A18,$231C00,$231D00,$205200,$5FE000,$F4C100,$4CDE00,$4FD9AE
		dc	$5EE0BF,$06DA10,$000020,$06D210,$000007,$8F8016,$45E1EE,$8AB8CB
		dc	$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016,$8AA8EE,$45E1CB,$CF0C16
		dc	$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016,$45E1AE,$8AB8BF,$CF1C16
		dc	$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE,$F4C1BF,$4CDE00,$CF0C16
		dc	$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032,$21B900,$219A00,$0CCD80
		dc	$FFFFCA,$380200,$221400,$231C00,$235200,$66F400,$000F52,$045811
		dc	$231900,$223500,$231D00,$205200,$5FE000,$F4C100,$4CDE00,$4FC9AE
		dc	$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16,$06D210,$000010
		dc	$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$F4C1BF,$4CDE00,$CF0C16
		dc	$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16,$4FC9EA
		dc	$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF,$05F420,$00FFFF,$574C16
		dc	$0461A0,$564D00,$0464A0,$0465A0,$00F3B8,$00000C,$71F400,$FFFFFE
		dc	$75F400,$FFFFFC,$229600,$06DA10,$00001A,$F0B900,$06DE10,$00000A
		dc	$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D3,$10DD00
		dc	$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D3
		dc	$564C00,$03F18E,$22D400,$229000,$239800,$0460A4,$00000C,$71F400
		dc	$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021,$57DA00,$51D200
		dc	$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409,$444C4C,$03F184
		dc	$555A00,$515A00,$22D400,$229000,$239800,$0460A4,$00000C,$44C800
		dc	$2000A0,$44C814,$200011,$06DE10,$000005,$180CA0,$44C8BA,$200014
		dc	$200011,$182400,$2000BA,$00000C,$46C813,$2000E1,$06DE10,$000003
		dc	$46C800,$564CE1,$566400,$00000C,$394000,$233D00,$204900,$204D00
		dc	$045112,$045516,$06D910,$000004,$46D900,$B0B200,$445600,$38FF00
		dc	$231C00,$204100,$204500,$044812,$044C16,$380200,$72F400,$FFFFFE
		dc	$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5659C8,$D088EB
		dc	$063F90,$000005,$D5CAD4,$575DF3,$5659C8,$D088EB,$575D00,$204000
		dc	$204400,$387F00,$231A00,$231C00,$231E00,$204100,$204500,$204000
		dc	$204A00,$204400,$204E00,$380200,$72F400,$FFFFFE,$3C0200,$76F400
		dc	$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8,$D088EB,$063F90,$000005
		dc	$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00,$00000C,$F1C000,$4DDA00
		dc	$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006,$F1C0A7,$4DDA00,$4ED8C8
		dc	$565CEB,$5F64B0,$2000A7,$565C00,$00000C,$F1C000,$4DDA00,$4EE1C8
		dc	$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB,$5F65B0,$06DA10,$00000A
		dc	$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0,$44D9A7,$5F64C8,$565CEB
		dc	$5F65B0,$2000A7,$565D00,$00000C,$F1C000,$4DDA00,$4EC8A8,$2000BB
		dc	$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00,$4EC8A8,$564CBB,$574DE0
		dc	$2000C7,$564C00,$00000C,$F1C100,$4DDA00,$4EE1A8,$4EE0BB,$44C8E0
		dc	$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7,$06DA10,$00000B,$F1C100
		dc	$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0
		dc	$574DC7,$564C00,$00000C,$56D800,$06D910,$000007,$0C1E01,$20003E
		dc	$23A403,$02A048,$56D800,$575900,$205000,$00000C,$46F400,$000001
		dc	$23AE00,$223555,$05A40D,$22B400,$06DC10,$000009,$56F400,$7FFFFF
		dc	$06DD10,$000004,$44DC00,$200045,$027040,$544D00,$223500,$234F00
		dc	$56E20B,$052406,$44F400,$00000F,$200045,$027040,$546200,$218500
		dc	$06DC10,$000004,$56E500,$218564,$544D00,$223500,$238759,$45F400
		dc	$000002,$56E500,$45F465,$FFFFFE,$057417,$45F465,$000002,$059411
		dc	$204D58,$20007D,$05744D,$0597D6,$56E500,$45F465,$FFFFFE,$057413
		dc	$45F465,$000002,$059406,$204D58,$20007D,$057442,$0597CB,$05A7D5
		dc	$20455C,$05A40D,$56E500,$200054,$544D00,$56E500,$45F450,$000002
		dc	$544500,$050FC0,$45F454,$000002,$546500,$050FC7,$234E00,$204D03
		dc	$05A407,$56E200,$200054,$546200,$56E500,$200050,$546500,$56E200
		dc	$200054,$546200,$56E500,$45F450,$000002,$546558,$050F8B,$223500
		dc	$45E200,$06DC10,$000005,$56E500,$200060,$218500,$544D00,$23AE00
		dc	$223555,$05A409,$22B400,$06DC10,$000006,$44CD00,$06DD10,$000002
		dc	$445C00,$000000,$00000C,$44F000,$000B41,$56F000,$000B97,$200045
		dc	$05A413,$209600,$60F400,$000180,$61F400,$000241,$56F400,$000BA5
		dc	$22C400,$200040,$219200,$71E200,$06D910,$000005,$44D900,$56E000
		dc	$0C1E48,$545800,$050C10,$56F000,$000B7E,$200003,$05A40C,$60F400
		dc	$000235,$61F400,$0002F6,$390700,$06D910,$000005,$44D900,$56E000
		dc	$0C1E48,$545800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0
		dc	$0465A0,$0466A0,$00F3B8,$44F400,$000000,$20004D,$05A40C,$44F400
		dc	$000010,$20004D,$0D104A,$000011,$300000,$56F400,$000000,$57F400
		dc	$FFFFFF,$00000C,$200013,$567000,$000912,$300000,$56F400,$000000
		dc	$57F400,$000608,$00000C,$05085C,$0D1080,$000096,$56F000,$000B96
		dc	$200003,$057453,$0D1080,$0000C4,$56F000,$000B96,$200003,$05744D
		dc	$0D1080,$00016E,$0D1080,$0001B1,$0D1080,$0001F4,$240000,$447000
		dc	$00092B,$56F000,$000B41,$44F000,$000B97,$200045,$05A409,$0D1080
		dc	$000146,$0D1080,$00021B,$557000,$00092B,$0D1080,$000303,$0D1080
		dc	$00031B,$0D1080,$00032A,$0D1080,$000385,$0D1080,$000341,$56F000
		dc	$000B41,$200003,$0D100A,$00042C,$0D1080,$00038E,$0D1080,$0003BB
		dc	$0D1080,$0003D6,$0D1080,$FFFF81,$200013,$21101B,$00000C,$205800
		dc	$44D800,$447000,$000B42,$44D800,$447000,$000B43,$44D800,$447000
		dc	$000B44,$57D800,$0C1890,$002024,$507000,$000B7B,$0C1890,$00101B
		dc	$507000,$000B7E,$0C1890,$003018,$507000,$000B7D,$44D800,$447000
		dc	$000B45,$44D800,$447000,$000B46,$44D800,$447000,$000B47,$57D800
		dc	$0C1890,$006020,$507000,$000B7C,$57D800,$0C1890,$001023,$507000
		dc	$00023D,$0C1890,$001022,$507000,$00023E,$0C1890,$001021,$507000
		dc	$00023F,$0C1890,$004018,$507000,$000240,$61D800,$380600,$204800
		dc	$57D900,$0C1890,$00201A,$507000,$000B4E,$57D900,$015F8E,$577000
		dc	$000B49,$57D800,$0C1890,$008018,$507000,$000B41,$0C1890,$008020
		dc	$507000,$000B40,$57D800,$0C1890,$001018,$507000,$000B4C,$0C1890
		dc	$001019,$507000,$000B4A,$57D800,$577000,$000B4B,$57E000,$577000
		dc	$000B4D,$00000C,$44F400,$000000,$447000,$000B96,$56F000,$000240
		dc	$44F400,$000009,$200045,$202741,$547000,$000240,$56F000,$000B49
		dc	$44F400,$00001F,$45F445,$000000,$202741,$200065,$202961,$547000
		dc	$000B49,$56F000,$000B7D,$44F400,$000007,$45F445,$000006,$05A414
		dc	$44F465,$000003,$05A411,$45F445,$000002,$05A40E,$44F465,$000004
		dc	$05A40B,$45F445,$000005,$05A408,$44F465,$000001,$05A405,$44F400
		dc	$000002,$447000,$000B96,$547000,$000B7D,$00000C,$56F000,$000912
		dc	$44F400,$020765,$200045,$052406,$56F000,$000B40,$200003,$05A45E
		dc	$00000C,$60F413,$0004FD,$060690,$000003,$545800,$545800,$60F413
		dc	$0005A8,$060590,$000002,$545800,$60F413,$00057B,$062890,$000002
		dc	$545800,$60F413,$0005AE,$065A90,$000002,$545800,$60F413,$000608
		dc	$060590,$000002,$545800,$60F413,$00060D,$060590,$000002,$545800
		dc	$60F413,$000509,$061090,$000002,$545800,$60F413,$000519,$060890
		dc	$000002,$545800,$60F413,$000521,$063C90,$000002,$545800,$60F413
		dc	$00055D,$061E90,$000002,$545800,$60F413,$000612,$060093,$000002
		dc	$545800,$44F400,$020765,$447000,$000912,$44F400,$000000,$447000
		dc	$000B96,$61F400,$000FC2,$71F000,$000B7D,$44F000,$000B7E,$5EE900
		dc	$547040,$000B97,$547000,$000B98,$44F01B,$000B97,$2D0513,$2C024D
		dc	$05945A,$44F01B,$000B98,$2D0613,$2C024D,$059455,$56F000,$000B7C
		dc	$200023,$547000,$000B99,$44F01B,$000B7B,$2D0313,$2C044D,$05944B
		dc	$44F01B,$000B99,$2D1313,$2C034D,$059446,$56F000,$000B7C,$0140C4
		dc	$000024,$21DA00,$44F000,$000B7B,$46F400,$000006,$2344D0,$0C1D2E
		dc	$44F440,$000F4C,$200040,$219100,$5EE100,$21CF22,$218422,$200022
		dc	$577040,$000B9A,$218500,$21E46C,$46F400,$000008,$21A7D0,$5070E8
		dc	$000B9D,$457000,$000B9B,$5170B0,$000B9E,$477000,$000B9C,$507000
		dc	$000B9F,$050C03,$547000,$000B96,$00000C,$56F400,$000914,$44F000
		dc	$000B41,$200040,$219100,$56E100,$0C1E01,$44F43E,$000001,$20004C
		dc	$20291B,$45F403,$000003,$02A068,$20006D,$027068,$56F400,$000B61
		dc	$44F000,$000B41,$200040,$219000,$556000,$00000C,$44F000,$000B7D
		dc	$46F400,$000006,$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040
		dc	$219400,$56F000,$000B44,$4CE400,$200040,$219100,$05E120,$56F000
		dc	$000B42,$4CE400,$200040,$219100,$56F000,$000B43,$4CE400,$200040
		dc	$219200,$44F400,$000100,$46E200,$2000D0,$240022,$210600,$2400D0
		dc	$46E200,$2400D2,$0C1D2E,$44E140,$200040,$219000,$70E200,$64F400
		dc	$0002FD,$3C0100,$3EFF00,$45F400,$3FF7CF,$56F000,$00023F,$200003
		dc	$05A40F,$56F000,$000B41,$44F432,$0004FD,$200040,$219100,$47F400
		dc	$000347,$57D900,$51D100,$0D04E7,$555900,$516100,$050C02,$0D04F4
		dc	$05F420,$00FFFF,$00000C,$56F000,$000B41,$44F000,$000B97,$200045
		dc	$05A44D,$56F000,$00023D,$200003,$05A45B,$60F400,$0002FD,$221400
		dc	$380100,$231C00,$44F000,$000B41,$46F400,$00000C,$44F4D0,$000521
		dc	$0C1D2E,$200040,$219100,$44F000,$000B41,$46F400,$000006,$44F4D0
		dc	$00055D,$0C1D2E,$200040,$219200,$56F000,$000240,$0140C4,$000007
		dc	$21DA00,$234400,$46F400,$00000F,$44F4D0,$000814,$0C1D2E,$200040
		dc	$219500,$3A0300,$3EFF00,$0D049E,$050C13,$56F000,$00023E,$200003
		dc	$05A40F,$60F400,$0002FD,$221400,$380100,$231C00,$61F400,$000509
		dc	$62F400,$000519,$65F400,$000800,$3A0400,$3EFF00,$0D04BF,$00000C
		dc	$44F000,$000B7D,$46F400,$000006,$44F0D0,$000B41,$0C1D2E,$44F440
		dc	$000F92,$200040,$219100,$4CE100,$447000,$000913,$61F400,$0002FD
		dc	$200013,$44D91B,$060091,$000004,$200047,$029040,$44D98A,$60F400
		dc	$0005A8,$70F000,$000B41,$200032,$44E826,$566847,$029040,$21C700
		dc	$56F400,$000914,$44F000,$000B41,$200040,$219000,$476000,$0C1C91
		dc	$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A,$0C1D2E,$200040
		dc	$219000,$555800,$516000,$00000C,$60F400,$0002FD,$64F400,$0003FD
		dc	$380100,$231C00,$44F000,$000B41,$46F400,$000008,$44F4D0,$00057B
		dc	$0C1D2E,$200040,$219100,$65F400,$0008A2,$3A0200,$3EFF00,$0D049E
		dc	$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040
		dc	$219000,$380E00,$61F400,$0003FD,$204800,$060490,$000009,$200013
		dc	$064090,$000004,$44D900,$200047,$029040,$200026,$565800,$44F000
		dc	$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000
		dc	$380800,$57F400,$000002,$204800,$380600,$060290,$00000B,$221100
		dc	$044812,$06CD10,$000006,$44DA00,$56DA00,$200045,$029040,$565900
		dc	$20402A,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E
		dc	$200040,$219000,$380600,$62F400,$0008AF,$390200,$45F41B,$000001
		dc	$20A600,$060390,$00000D,$221100,$4FDA00,$204900,$44D100,$06C610
		dc	$000004,$44C9C0,$44D145,$027068,$20CE00,$204832,$218600,$44F000
		dc	$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000
		dc	$380200,$44F400,$003200,$56E800,$200045,$20291B,$44F000,$000B41
		dc	$46F400,$000002,$44F4D0,$00091A,$0C1D2E,$200040,$219100,$56F400
		dc	$000608,$44F000,$000B41,$200040,$219000,$44E100,$46F400,$7FFFFF
		dc	$44E0D0,$200045,$20291B,$56F400,$000926,$44F000,$000B41,$200040
		dc	$219000,$556000,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE
		dc	$0C1D2E,$200040,$219000,$380600,$62F400,$0008AC,$390200,$20A61B
		dc	$060390,$00000D,$221100,$4FDA00,$204900,$44D100,$06C610,$000004
		dc	$44C9C0,$44D145,$027068,$20CE00,$204832,$218600,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380200
		dc	$44F400,$003200,$56E800,$200045,$20291B,$44F000,$000B41,$46F400
		dc	$000002,$44F4D0,$00091A,$0C1D2E,$200040,$219100,$56F400,$000608
		dc	$44F000,$000B41,$200040,$219000,$44E100,$46F400,$400000,$46E0D0
		dc	$446055,$20291B,$56F400,$000B7F,$44F000,$000B41,$200040,$219000
		dc	$556000,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E
		dc	$200040,$219000,$380600,$20AE00,$060390,$00000A,$221100,$219900
		dc	$221200,$204900,$44D900,$445A00,$44D900,$445A00,$204832,$00000C
		dc	$56F400,$000B7F,$44F000,$000B41,$200040,$219000,$56F400,$00060D
		dc	$44F000,$000B41,$200040,$219100,$56F400,$000B84,$44F000,$000B41
		dc	$200040,$219200,$44E01B,$56E100,$45F442,$000001,$02A068,$576200
		dc	$446100,$00000C,$60F400,$0002FD,$44F000,$000B41,$46F400,$000080
		dc	$44F4D0,$000612,$0C1D2E,$200040,$219100,$64F400,$0008B2,$65F400
		dc	$000000,$0D04FC,$00000C,$56F000,$00092B,$200003,$05A40E,$60F400
		dc	$000000,$61F400,$000040,$221400,$223500,$62F400,$000AB2,$66F400
		dc	$000AF2,$3A3F00,$0D054D,$050C0A,$60F400,$000000,$221400,$62F400
		dc	$0009B2,$66F400,$000A32,$3A7F00,$0D053E,$00000C,$0500A0,$0461A0
		dc	$56F000,$00092B,$200003,$05A415,$60F400,$000000,$61F400,$000040
		dc	$64F400,$0003FD,$65F400,$0004FC,$62F400,$000AB2,$66F400,$000AF2
		dc	$382000,$231900,$3A3F00,$3C0300,$75F400,$FFFFFD,$0D0573,$050C11
		dc	$60F400,$000000,$64F400,$0003FD,$65F400,$0004FC,$62F400,$0009B2
		dc	$66F400,$000A32,$384000,$3A7F00,$3C0200,$75F400,$FFFFFE,$0D0564
		dc	$05F420,$00FFFF,$0461A0,$56F000,$000B41,$44F000,$000B97,$60F445
		dc	$0003FD,$05A408,$61F400,$000180,$06B590,$000003,$44D800,$445900
		dc	$050C07,$61F400,$000235,$060790,$000003,$44D800,$445900,$00000C
		dc	$56F000,$00092B,$200003,$05A40A,$60F400,$000000,$384000,$0D03EF
		dc	$60F400,$000040,$384000,$0D03EF,$050C05,$60F400,$000000,$388000
		dc	$0D03EF,$00000C,$56F000,$000B97,$44F000,$000B41,$45F445,$000001
		dc	$05A403,$05080D,$050C03,$457000,$000B8F,$60F400,$000B7F,$61F400
		dc	$0005A3,$060590,$000003,$44D800,$445900,$00000C,$290300,$70F000
		dc	$000B41,$60F400,$000B7F,$56E800,$014185,$05A410,$60F400,$000926
		dc	$56E800,$014185,$05A40B,$56F000,$000B40,$014085,$05A406,$60F400
		dc	$0005A3,$56E800,$014185,$05A402,$290200,$60F400,$000B8A,$516800
		dc	$00000C,$3D1800,$44F000,$000B41,$56F000,$000B97,$60F445,$000180
		dc	$05A40C,$209600,$61F400,$000241,$56F400,$000BA5,$22C400,$200040
		dc	$219200,$71E200,$0D058B,$050C0A,$56F000,$000B7E,$60F403,$000235
		dc	$05A405,$61F400,$0002F6,$390700,$0D058B,$00000C,$44F000,$000B41
		dc	$56F000,$000B97,$61F445,$000241,$05A459,$56F400,$000B8A,$44F000
		dc	$000B41,$200040,$219000,$56F400,$000BA5,$44F000,$000B41,$200040
		dc	$219200,$56E000,$71E200,$219400,$223600,$56F400,$000B5C,$44F000
		dc	$000B41,$200040,$219000,$56F400,$000B91,$44F000,$000B41,$200040
		dc	$219200,$232E00,$014184,$0B74C4,$000F16,$218500,$47F4AD,$000001
		dc	$0B74C4,$000F12,$21E600,$209DD0,$0C1D2E,$46F465,$2AAAAB,$202978
		dc	$556000,$21A500,$21BCE9,$0C1D82,$200010,$200065,$202978,$556200
		dc	$223200,$205900,$3A0000,$0D0596,$050C11,$56F000,$000B7E,$60F403
		dc	$000B8F,$05A40C,$61F400,$0002F6,$390700,$223600,$223200,$205900
		dc	$3A0000,$3C0600,$7DF000,$000F13,$0D0596,$00000C,$56F000,$000240
		dc	$0C1D04,$21C700,$46F400,$000003,$2000B0,$0C1D2E,$0140C0,$000049
		dc	$21C600,$61F400,$000BA0,$62F400,$000BA5,$45F000,$000B97,$06C510
		dc	$000003,$475900,$465A00,$57F400,$000001,$56F000,$000B40,$200003
		dc	$05A402,$20001B,$577000,$000B90,$00000C,$56F400,$00000D,$57F400
		dc	$000000,$70F400,$000416,$0BF080,$000180,$200003,$052400,$00000C
		dc	$56F400,$00000D,$57F400,$000001,$60F400,$0004FD,$70F400,$000416
		dc	$390000,$0BF080,$000180,$200003,$052400,$00000C,$56F400,$00000D
		dc	$57F400,$000002,$60F400,$0004FD,$70F400,$000416,$390000,$0BF080
		dc	$000180,$200003,$052400,$00000C,$56F400,$000014,$57F400,$000001
		dc	$390000,$70F400,$000080,$60F400,$000B40,$0BF080,$000180,$200003
		dc	$052400,$00000C,$56F400,$000010,$57F400,$000000,$70F400,$000390
		dc	$0BF080,$000180,$200003,$052400,$56F400,$000011,$57F400,$000000
		dc	$70F400,$000390,$0BF080,$000180,$200003,$052400,$00000C,$447000
		dc	$000963,$56F000,$000B97,$200045,$052407,$71F400,$000389,$380700
		dc	$60F400,$000235,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000180
		dc	$211900,$56F400,$000010,$57F400,$000002,$0BF080,$000180,$200003
		dc	$052400,$44F000,$000963,$56F000,$000B97,$200045,$052407,$71F400
		dc	$000389,$380700,$60F400,$0002F6,$050C07,$46F400,$0000B5,$20D8D0
		dc	$60F422,$000241,$211900,$56F400,$000011,$57F400,$000002,$0BF080
		dc	$000180,$200003,$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\llef13break.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 01/05/01, 09:15:05
;	Program info
;	  Program number: 2
;	  Revision number: 1.4
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2049 words
;	  Checksum: $9BD1DF

		dc	$D01B40,$000801,$020104,$9BD1DF,$447000,$00095F,$607000,$000962
		dc	$050C00,$20000B,$05A407,$0508D9,$0D1080,$000776,$0D1080,$0007A9
		dc	$050C05,$0D1080,$00077C,$0D1080,$000796,$0508D3,$62F000,$000962
		dc	$60F400,$000FC2,$0A72D8,$000004,$240000,$447000,$000960,$5EE800
		dc	$0212DF,$20000B,$05A402,$014180,$547000,$000961,$44F000,$000960
		dc	$05094C,$050811,$44F000,$000960,$0D1080,$0007A0,$56F000,$000960
		dc	$014180,$44F000,$000961,$547000,$000960,$200045,$0597D0,$0D1080
		dc	$000764,$00000C,$56F000,$000960,$44F000,$00095F,$0C1940,$008020
		dc	$547000,$00093D,$56F000,$000960,$200003,$052454,$62F000,$000962
		dc	$60F400,$00094D,$44F400,$000080,$060690,$000002,$445800,$02129E
		dc	$0212D4,$0C1940,$00101B,$547000,$000930,$44F413,$000012,$0C1940
		dc	$005021,$547000,$000934,$021ADE,$022A94,$0C1940,$001021,$0222D4
		dc	$0C1940,$001022,$022294,$0C1940,$001023,$547000,$000935,$021A94
		dc	$447000,$000942,$200013,$0232D4,$0C1940,$001018,$022AD4,$0C1940
		dc	$001019,$547000,$00093E,$023A94,$447000,$000940,$023294,$447000
		dc	$00093F,$60F413,$00092C,$57F400,$000010,$0D1080,$0002A9,$44F400
		dc	$000000,$200045,$057400,$00000C,$30001B,$0D1080,$0002A1,$00000C
		dc	$44F400,$000015,$447000,$00092C,$44F400,$00094D,$447000,$00092D
		dc	$44F400,$000959,$447000,$00092E,$44F400,$000953,$447000,$00092F
		dc	$44F400,$00FFFF,$447000,$000933,$44F400,$000941,$447000,$000936
		dc	$240000,$447000,$000931,$447000,$000932,$447000,$000937,$447000
		dc	$000938,$447000,$000939,$447000,$00093A,$447000,$00093B,$447000
		dc	$00093C,$60F400,$000947,$44F400,$000000,$445800,$44F400,$000002
		dc	$445800,$44F400,$000003,$445800,$44F400,$000004,$445800,$44F400
		dc	$000001,$445800,$44F400,$000005,$445800,$60F400,$000959,$44F400
		dc	$000001,$060690,$000002,$445800,$60F400,$000953,$44F400,$00FFFF
		dc	$060690,$000002,$445800,$00000C,$62F000,$000962,$45F400,$000003
		dc	$021296,$2000E0,$62F400,$000F92,$210E00,$200040,$60F400,$000080
		dc	$219A00,$70F400,$000100,$56F400,$000005,$79EA00,$0D0180,$200003
		dc	$052400,$00000C,$230800,$00000A,$04C8A0,$0461A0,$0464A0,$0465A0
		dc	$0004F8,$230E00,$200022,$219800,$221400,$044811,$223500,$5FE000
		dc	$4FE100,$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868
		dc	$4FE119,$200016,$CF1C00,$CA1D78,$230E00,$223022,$219800,$221400
		dc	$044811,$223500,$5FE000,$4FE100,$5EE078,$06D810,$000009,$45D919
		dc	$200016,$8F8000,$8AB868,$4FE119,$200016,$CF1C00,$CA1D78,$223000
		dc	$221400,$044811,$223500,$5FE000,$45E100,$5EE06C,$06D810,$000009
		dc	$4FD919,$200016,$8F8000,$8AB878,$45E119,$200016,$CF1C00,$CA1D6C
		dc	$230E00,$3A0222,$223000,$219900,$221100,$233200,$221400,$66F400
		dc	$000F52,$204900,$223500,$045A18,$231C00,$231D00,$205200,$5FE000
		dc	$F4C100,$4CDE00,$4FD9AE,$5EE0BF,$06DA10,$000020,$06D210,$000007
		dc	$8F8016,$45E1EE,$8AB8CB,$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016
		dc	$8AA8EE,$45E1CB,$CF0C16,$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016
		dc	$45E1AE,$8AB8BF,$CF1C16,$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE
		dc	$F4C1BF,$4CDE00,$CF0C16,$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032
		dc	$21B900,$219A00,$0CCD80,$FFFFCA,$380200,$221400,$231C00,$235200
		dc	$66F400,$000F52,$045811,$231900,$223500,$231D00,$205200,$5FE000
		dc	$F4C100,$4CDE00,$4FC9AE,$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB
		dc	$CF0C16,$06D210,$000010,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE
		dc	$F4C1BF,$4CDE00,$CF0C16,$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE
		dc	$45E1CB,$CF0C16,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF
		dc	$05F420,$00FFFF,$574C16,$0461A0,$564D00,$0464A0,$0465A0,$00F3B8
		dc	$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$00001A
		dc	$F0B900,$06DE10,$00000A,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D3,$10DD00,$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2
		dc	$4459E2,$F0A1E2,$4559D3,$564C00,$03F18E,$22D400,$229000,$239800
		dc	$0460A4,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10
		dc	$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4,$F039D6
		dc	$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09,$444C4C
		dc	$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010
		dc	$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000,$239800
		dc	$0460A4,$00000C,$44C800,$2000A0,$44C814,$200011,$06DE10,$000005
		dc	$180CA0,$44C8BA,$200014,$200011,$182400,$2000BA,$00000C,$46C813
		dc	$2000E1,$06DE10,$000003,$46C800,$564CE1,$566400,$00000C,$394000
		dc	$233D00,$204900,$204D00,$045112,$045516,$06D910,$000004,$46D900
		dc	$B0B200,$445600,$38FF00,$231C00,$204100,$204500,$044812,$044C16
		dc	$380200,$72F400,$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4
		dc	$2000F3,$5659C8,$D088EB,$063F90,$000005,$D5CAD4,$575DF3,$5659C8
		dc	$D088EB,$575D00,$204000,$204400,$387F00,$231A00,$231C00,$231E00
		dc	$204100,$204500,$204000,$204A00,$204400,$204E00,$380200,$72F400
		dc	$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8
		dc	$D088EB,$063F90,$000005,$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00
		dc	$00000C,$F1C000,$4DDA00,$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006
		dc	$F1C0A7,$4DDA00,$4ED8C8,$565CEB,$5F64B0,$2000A7,$565C00,$00000C
		dc	$F1C000,$4DDA00,$4EE1C8,$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB
		dc	$5F65B0,$06DA10,$00000A,$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0
		dc	$44D9A7,$5F64C8,$565CEB,$5F65B0,$2000A7,$565D00,$00000C,$F1C000
		dc	$4DDA00,$4EC8A8,$2000BB,$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00
		dc	$4EC8A8,$564CBB,$574DE0,$2000C7,$564C00,$00000C,$F1C100,$4DDA00
		dc	$4EE1A8,$4EE0BB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7
		dc	$06DA10,$00000B,$F1C100,$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7
		dc	$4EE1B8,$565CAB,$44C9E0,$574DC7,$564C00,$00000C,$56D800,$06D910
		dc	$000007,$0C1E01,$20003E,$23A403,$02A048,$56D800,$575900,$205000
		dc	$00000C,$46F400,$000001,$23AE00,$223555,$05A40D,$22B400,$06DC10
		dc	$000009,$56F400,$7FFFFF,$06DD10,$000004,$44DC00,$200045,$027040
		dc	$544D00,$223500,$234F00,$56E20B,$052406,$44F400,$00000F,$200045
		dc	$027040,$546200,$218500,$06DC10,$000004,$56E500,$218564,$544D00
		dc	$223500,$238759,$45F400,$000002,$56E500,$45F465,$FFFFFE,$057417
		dc	$45F465,$000002,$059411,$204D58,$20007D,$05744D,$0597D6,$56E500
		dc	$45F465,$FFFFFE,$057413,$45F465,$000002,$059406,$204D58,$20007D
		dc	$057442,$0597CB,$05A7D5,$20455C,$05A40D,$56E500,$200054,$544D00
		dc	$56E500,$45F450,$000002,$544500,$050FC0,$45F454,$000002,$546500
		dc	$050FC7,$234E00,$204D03,$05A407,$56E200,$200054,$546200,$56E500
		dc	$200050,$546500,$56E200,$200054,$546200,$56E500,$45F450,$000002
		dc	$546558,$050F8B,$223500,$45E200,$06DC10,$000005,$56E500,$200060
		dc	$218500,$544D00,$23AE00,$223555,$05A409,$22B400,$06DC10,$000006
		dc	$44CD00,$06DD10,$000002,$445C00,$000000,$00000C,$44F000,$000B41
		dc	$56F000,$000B94,$200045,$05A413,$209600,$60F400,$000180,$61F400
		dc	$000241,$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$06D910
		dc	$000005,$44D900,$56E000,$0C1E48,$545800,$050C10,$56F000,$000B7B
		dc	$200003,$05A40C,$60F400,$000235,$61F400,$0002F6,$390700,$06D910
		dc	$000005,$44D900,$56E000,$0C1E48,$545800,$00000C,$05F420,$FFFFFF
		dc	$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000000
		dc	$20004D,$05A40C,$44F400,$000010,$20004D,$0D104A,$000011,$300000
		dc	$56F400,$000000,$57F400,$FFFFFF,$00000C,$200013,$567000,$000912
		dc	$300000,$56F400,$000000,$57F400,$000608,$00000C,$050856,$0D1080
		dc	$00008C,$56F000,$000B93,$200003,$05744D,$0D1080,$000136,$0D1080
		dc	$000179,$0D1080,$0001BC,$240000,$447000,$00092B,$56F000,$000B41
		dc	$44F000,$000B94,$200045,$05A409,$0D1080,$00010E,$0D1080,$0001E3
		dc	$557000,$00092B,$0D1080,$0002CB,$0D1080,$0002E3,$0D1080,$0002F2
		dc	$0D1080,$00034D,$0D1080,$000309,$56F000,$000B41,$200003,$0D100A
		dc	$0003F4,$0D1080,$000356,$0D1080,$000383,$0D1080,$00039E,$0D1080
		dc	$FFFF87,$200013,$21101B,$00000C,$205800,$44D800,$447000,$000B42
		dc	$44D800,$447000,$000B43,$44D800,$447000,$000B44,$57D800,$0C1890
		dc	$002024,$507000,$000B78,$0C1890,$00101B,$507000,$000B7B,$0C1890
		dc	$003018,$507000,$000B7A,$44D800,$447000,$000B45,$44D800,$447000
		dc	$000B46,$44D800,$447000,$000B47,$57D800,$0C1890,$006020,$507000
		dc	$000B79,$57D800,$0C1890,$001023,$507000,$00023D,$0C1890,$001022
		dc	$507000,$00023E,$0C1890,$001021,$507000,$00023F,$0C1890,$004018
		dc	$507000,$000240,$61D800,$380600,$204800,$205900,$57D900,$015F8E
		dc	$577000,$000B49,$57D800,$0C1890,$008018,$507000,$000B41,$0C1890
		dc	$008020,$507000,$000B40,$57D800,$0C1890,$001018,$507000,$000B4C
		dc	$0C1890,$001019,$507000,$000B4A,$57D800,$577000,$000B4B,$57E000
		dc	$577000,$000B4D,$00000C,$56F000,$000912,$44F400,$020765,$200045
		dc	$052406,$56F000,$000B40,$200003,$05A45E,$00000C,$60F413,$0004FD
		dc	$060690,$000003,$545800,$545800,$60F413,$0005A8,$060590,$000002
		dc	$545800,$60F413,$00057B,$062890,$000002,$545800,$60F413,$0005AE
		dc	$065A90,$000002,$545800,$60F413,$000608,$060590,$000002,$545800
		dc	$60F413,$00060D,$060590,$000002,$545800,$60F413,$000509,$061090
		dc	$000002,$545800,$60F413,$000519,$060890,$000002,$545800,$60F413
		dc	$000521,$063C90,$000002,$545800,$60F413,$00055D,$061E90,$000002
		dc	$545800,$60F413,$000612,$060093,$000002,$545800,$44F400,$020765
		dc	$447000,$000912,$44F400,$000000,$447000,$000B93,$61F400,$000FC2
		dc	$71F000,$000B7A,$44F000,$000B7B,$5EE900,$547040,$000B94,$547000
		dc	$000B95,$44F01B,$000B94,$2D0513,$2C024D,$05945A,$44F01B,$000B95
		dc	$2D0613,$2C024D,$059455,$56F000,$000B79,$200023,$547000,$000B96
		dc	$44F01B,$000B78,$2D0313,$2C044D,$05944B,$44F01B,$000B96,$2D1313
		dc	$2C034D,$059446,$56F000,$000B79,$0140C4,$000024,$21DA00,$44F000
		dc	$000B78,$46F400,$000006,$2344D0,$0C1D2E,$44F440,$000F4C,$200040
		dc	$219100,$5EE100,$21CF22,$218422,$200022,$577040,$000B97,$218500
		dc	$21E46C,$46F400,$000008,$21A7D0,$5070E8,$000B9A,$457000,$000B98
		dc	$5170B0,$000B9B,$477000,$000B99,$507000,$000B9C,$050C03,$547000
		dc	$000B93,$00000C,$56F400,$000914,$44F000,$000B41,$200040,$219100
		dc	$56E100,$0C1E01,$44F43E,$000001,$20004C,$20291B,$45F403,$000003
		dc	$02A068,$20006D,$027068,$56F400,$000B5E,$44F000,$000B41,$200040
		dc	$219000,$556000,$00000C,$44F000,$000B7A,$46F400,$000006,$44F0D0
		dc	$000B41,$0C1D2E,$44F440,$000F92,$200040,$219400,$56F000,$000B44
		dc	$4CE400,$200040,$219100,$05E120,$56F000,$000B42,$4CE400,$200040
		dc	$219100,$56F000,$000B43,$4CE400,$200040,$219200,$44F400,$000100
		dc	$46E200,$2000D0,$240022,$210600,$2400D0,$46E200,$2400D2,$0C1D2E
		dc	$44E140,$200040,$219000,$70E200,$64F400,$0002FD,$3C0100,$3EFF00
		dc	$45F400,$3FF7CF,$56F000,$00023F,$200003,$05A40F,$56F000,$000B41
		dc	$44F432,$0004FD,$200040,$219100,$47F400,$000347,$57D900,$51D100
		dc	$0D04E2,$555900,$516100,$050C02,$0D04EF,$05F420,$00FFFF,$00000C
		dc	$56F000,$000B41,$44F000,$000B94,$200045,$05A44D,$56F000,$00023D
		dc	$200003,$05A45B,$60F400,$0002FD,$221400,$380100,$231C00,$44F000
		dc	$000B41,$46F400,$00000C,$44F4D0,$000521,$0C1D2E,$200040,$219100
		dc	$44F000,$000B41,$46F400,$000006,$44F4D0,$00055D,$0C1D2E,$200040
		dc	$219200,$56F000,$000240,$0140C4,$000007,$21DA00,$234400,$46F400
		dc	$00000F,$44F4D0,$000814,$0C1D2E,$200040,$219500,$3A0300,$3EFF00
		dc	$0D0499,$050C13,$56F000,$00023E,$200003,$05A40F,$60F400,$0002FD
		dc	$221400,$380100,$231C00,$61F400,$000509,$62F400,$000519,$65F400
		dc	$000800,$3A0400,$3EFF00,$0D04BA,$00000C,$44F000,$000B7A,$46F400
		dc	$000006,$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040,$219100
		dc	$4CE100,$447000,$000913,$61F400,$0002FD,$200013,$44D91B,$060091
		dc	$000004,$200047,$029040,$44D98A,$60F400,$0005A8,$70F000,$000B41
		dc	$200032,$44E826,$566847,$029040,$21C700,$56F400,$000914,$44F000
		dc	$000B41,$200040,$219000,$476000,$0C1C91,$44F000,$000B41,$46F400
		dc	$000002,$44F4D0,$00091A,$0C1D2E,$200040,$219000,$555800,$516000
		dc	$00000C,$60F400,$0002FD,$64F400,$0003FD,$380100,$231C00,$44F000
		dc	$000B41,$46F400,$000008,$44F4D0,$00057B,$0C1D2E,$200040,$219100
		dc	$65F400,$0008A2,$3A0200,$3EFF00,$0D0499,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380E00,$61F400
		dc	$0003FD,$204800,$060490,$000009,$200013,$064090,$000004,$44D900
		dc	$200047,$029040,$200026,$565800,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380800,$57F400,$000002
		dc	$204800,$380600,$060290,$00000B,$221100,$044812,$06CD10,$000006
		dc	$44DA00,$56DA00,$200045,$029040,$565900,$20402A,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$62F400,$0008AF,$390200,$45F41B,$000001,$20A600,$060390,$00000D
		dc	$221100,$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145
		dc	$027068,$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200
		dc	$56E800,$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0
		dc	$00091A,$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41
		dc	$200040,$219000,$44E100,$46F400,$7FFFFF,$44E0D0,$200045,$20291B
		dc	$56F400,$000926,$44F000,$000B41,$200040,$219000,$556000,$44F000
		dc	$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000
		dc	$380600,$62F400,$0008AC,$390200,$20A61B,$060390,$00000D,$221100
		dc	$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068
		dc	$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800
		dc	$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A
		dc	$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040
		dc	$219000,$44E100,$46F400,$400000,$46E0D0,$446055,$20291B,$56F400
		dc	$000B7C,$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$20AE00,$060390,$00000A,$221100,$219900,$221200,$204900,$44D900
		dc	$445A00,$44D900,$445A00,$204832,$00000C,$56F400,$000B7C,$44F000
		dc	$000B41,$200040,$219000,$56F400,$00060D,$44F000,$000B41,$200040
		dc	$219100,$56F400,$000B81,$44F000,$000B41,$200040,$219200,$44E01B
		dc	$56E100,$45F442,$000001,$02A068,$576200,$446100,$00000C,$60F400
		dc	$0002FD,$44F000,$000B41,$46F400,$000080,$44F4D0,$000612,$0C1D2E
		dc	$200040,$219100,$64F400,$0008B2,$65F400,$000000,$0D04F7,$00000C
		dc	$56F000,$00092B,$200003,$05A40E,$60F400,$000000,$61F400,$000040
		dc	$221400,$223500,$62F400,$000AB2,$66F400,$000AF2,$3A3F00,$0D0548
		dc	$050C0A,$60F400,$000000,$221400,$62F400,$0009B2,$66F400,$000A32
		dc	$3A7F00,$0D0539,$00000C,$0500A0,$0461A0,$56F000,$00092B,$200003
		dc	$05A415,$60F400,$000000,$61F400,$000040,$64F400,$0003FD,$65F400
		dc	$0004FC,$62F400,$000AB2,$66F400,$000AF2,$382000,$231900,$3A3F00
		dc	$3C0300,$75F400,$FFFFFD,$0D056E,$050C11,$60F400,$000000,$64F400
		dc	$0003FD,$65F400,$0004FC,$62F400,$0009B2,$66F400,$000A32,$384000
		dc	$3A7F00,$3C0200,$75F400,$FFFFFE,$0D055F,$05F420,$00FFFF,$0461A0
		dc	$56F000,$000B41,$44F000,$000B94,$60F445,$0003FD,$05A408,$61F400
		dc	$000180,$06B590,$000003,$44D800,$445900,$050C07,$61F400,$000235
		dc	$060790,$000003,$44D800,$445900,$00000C,$56F000,$00092B,$200003
		dc	$05A40A,$60F400,$000000,$384000,$0D03EA,$60F400,$000040,$384000
		dc	$0D03EA,$050C05,$60F400,$000000,$388000,$0D03EA,$00000C,$56F000
		dc	$000B94,$44F000,$000B41,$45F445,$000001,$05A403,$05080D,$050C03
		dc	$457000,$000B8C,$60F400,$000B7C,$61F400,$0005A3,$060590,$000003
		dc	$44D800,$445900,$00000C,$290300,$70F000,$000B41,$60F400,$000B7C
		dc	$56E800,$014185,$05A410,$60F400,$000926,$56E800,$014185,$05A40B
		dc	$56F000,$000B40,$014085,$05A406,$60F400,$0005A3,$56E800,$014185
		dc	$05A402,$290200,$60F400,$000B87,$516800,$00000C,$3D1800,$44F000
		dc	$000B41,$56F000,$000B94,$60F445,$000180,$05A40C,$209600,$61F400
		dc	$000241,$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$0D0586
		dc	$050C0A,$56F000,$000B7B,$60F403,$000235,$05A405,$61F400,$0002F6
		dc	$390700,$0D0586,$00000C,$44F000,$000B41,$56F000,$000B94,$61F445
		dc	$000241,$05A459,$56F400,$000B87,$44F000,$000B41,$200040,$219000
		dc	$56F400,$000BA2,$44F000,$000B41,$200040,$219200,$56E000,$71E200
		dc	$219400,$223600,$56F400,$000B59,$44F000,$000B41,$200040,$219000
		dc	$56F400,$000B8E,$44F000,$000B41,$200040,$219200,$232E00,$014184
		dc	$0B74C4,$000F16,$218500,$47F4AD,$000001,$0B74C4,$000F12,$21E600
		dc	$209DD0,$0C1D2E,$46F465,$2AAAAB,$202978,$556000,$21A500,$21BCE9
		dc	$0C1D82,$200010,$200065,$202978,$556200,$223200,$205900,$3A0000
		dc	$0D0591,$050C11,$56F000,$000B7B,$60F403,$000B8C,$05A40C,$61F400
		dc	$0002F6,$390700,$223600,$223200,$205900,$3A0000,$3C0600,$7DF000
		dc	$000F13,$0D0591,$00000C,$56F000,$000240,$0C1D04,$21C700,$46F400
		dc	$000003,$2000B0,$0C1D2E,$0140C0,$000049,$21C600,$61F400,$000B9D
		dc	$62F400,$000BA2,$45F000,$000B94,$06C510,$000003,$475900,$465A00
		dc	$57F400,$000001,$56F000,$000B40,$200003,$05A402,$20001B,$577000
		dc	$000B8D,$00000C,$56F400,$00000A,$57F400,$000000,$70F400,$000416
		dc	$0BF080,$000180,$200003,$052400,$00000C,$56F400,$00000A,$57F400
		dc	$000001,$60F400,$0004FD,$70F400,$000416,$390000,$0BF080,$000180
		dc	$200003,$052400,$00000C,$56F400,$00000A,$57F400,$000002,$60F400
		dc	$0004FD,$70F400,$000416,$390000,$0BF080,$000180,$200003,$052400
		dc	$00000C,$56F400,$000011,$57F400,$000001,$390000,$70F400,$000080
		dc	$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C,$56F400
		dc	$00000D,$57F400,$000000,$70F400,$000390,$0BF080,$000180,$200003
		dc	$052400,$56F400,$00000E,$57F400,$000000,$70F400,$000390,$0BF080
		dc	$000180,$200003,$052400,$00000C,$447000,$000963,$56F000,$000B94
		dc	$200045,$052407,$71F400,$000389,$380700,$60F400,$000235,$050C07
		dc	$46F400,$0000B5,$20D8D0,$60F422,$000180,$211900,$56F400,$00000D
		dc	$57F400,$000002,$0BF080,$000180,$200003,$052400,$44F000,$000963
		dc	$56F000,$000B94,$200045,$052407,$71F400,$000389,$380700,$60F400
		dc	$0002F6,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000241,$211900
		dc	$56F400,$00000E,$57F400,$000002,$0BF080,$000180,$200003,$052400
		dc	$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\llef13yrom.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 01/04/01, 19:12:36
;	Program info
;	  Program number: 2
;	  Revision number: 1.4
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2058 words
;	  Checksum: $090400

		dc	$D01B40,$00080A,$020104,$090400,$447000,$00095F,$607000,$000962
		dc	$20000B,$05A407,$0508D9,$0D1080,$000780,$0D1080,$0007B3,$050C05
		dc	$0D1080,$000786,$0D1080,$0007A0,$0508D3,$62F000,$000962,$60F400
		dc	$000FC2,$0A72D8,$000004,$240000,$447000,$000960,$5EE800,$0212DF
		dc	$20000B,$05A402,$014180,$547000,$000961,$44F000,$000960,$05094C
		dc	$050811,$44F000,$000960,$0D1080,$0007AA,$56F000,$000960,$014180
		dc	$44F000,$000961,$547000,$000960,$200045,$0597D0,$0D1080,$00076E
		dc	$00000C,$56F000,$000960,$44F000,$00095F,$0C1940,$008020,$547000
		dc	$00093D,$56F000,$000960,$200003,$052454,$62F000,$000962,$60F400
		dc	$00094D,$44F400,$000080,$060690,$000002,$445800,$02129E,$0212D4
		dc	$0C1940,$00101B,$547000,$000930,$44F413,$000012,$0C1940,$005021
		dc	$547000,$000934,$021ADE,$022A94,$0C1940,$001021,$0222D4,$0C1940
		dc	$001022,$022294,$0C1940,$001023,$547000,$000935,$021A94,$447000
		dc	$000942,$200013,$0232D4,$0C1940,$001018,$022AD4,$0C1940,$001019
		dc	$547000,$00093E,$023A94,$447000,$000940,$023294,$447000,$00093F
		dc	$60F413,$00092C,$57F400,$000010,$0D1080,$0002A9,$44F400,$000000
		dc	$200045,$057400,$00000C,$30001B,$0D1080,$0002A1,$00000C,$44F400
		dc	$000015,$447000,$00092C,$44F400,$00094D,$447000,$00092D,$44F400
		dc	$000959,$447000,$00092E,$44F400,$000953,$447000,$00092F,$44F400
		dc	$00FFFF,$447000,$000933,$44F400,$000941,$447000,$000936,$240000
		dc	$447000,$000931,$447000,$000932,$447000,$000937,$447000,$000938
		dc	$447000,$000939,$447000,$00093A,$447000,$00093B,$447000,$00093C
		dc	$60F400,$000947,$44F400,$000000,$445800,$44F400,$000002,$445800
		dc	$44F400,$000003,$445800,$44F400,$000004,$445800,$44F400,$000001
		dc	$445800,$44F400,$000005,$445800,$60F400,$000959,$44F400,$000001
		dc	$060690,$000002,$445800,$60F400,$000953,$44F400,$00FFFF,$060690
		dc	$000002,$445800,$00000C,$62F000,$000962,$45F400,$000003,$021296
		dc	$2000E0,$62F400,$000F92,$210E00,$200040,$60F400,$000080,$219A00
		dc	$70F400,$000100,$56F400,$000005,$79EA00,$0D0180,$200003,$052400
		dc	$00000C,$230800,$00000A,$04C8A0,$0461A0,$0464A0,$0465A0,$0004F8
		dc	$230E00,$200022,$219800,$221400,$044811,$223500,$5FE000,$4FE100
		dc	$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868,$4FE119
		dc	$200016,$CF1C00,$CA1D78,$230E00,$223022,$219800,$221400,$044811
		dc	$223500,$5FE000,$4FE100,$5EE078,$06D810,$000009,$45D919,$200016
		dc	$8F8000,$8AB868,$4FE119,$200016,$CF1C00,$CA1D78,$223000,$221400
		dc	$044811,$223500,$5FE000,$45E100,$5EE06C,$06D810,$000009,$4FD919
		dc	$200016,$8F8000,$8AB878,$45E119,$200016,$CF1C00,$CA1D6C,$230E00
		dc	$3A0222,$223000,$219900,$221100,$233200,$221400,$66F400,$000F52
		dc	$204900,$223500,$045A18,$231C00,$231D00,$205200,$5FE000,$F4C100
		dc	$4CDE00,$4FD9AE,$5EE0BF,$06DA10,$000020,$06D210,$000007,$8F8016
		dc	$45E1EE,$8AB8CB,$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016,$8AA8EE
		dc	$45E1CB,$CF0C16,$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016,$45E1AE
		dc	$8AB8BF,$CF1C16,$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE,$F4C1BF
		dc	$4CDE00,$CF0C16,$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032,$21B900
		dc	$219A00,$0CCD80,$FFFFCA,$380200,$221400,$231C00,$235200,$66F400
		dc	$000F52,$045811,$231900,$223500,$231D00,$205200,$5FE000,$F4C100
		dc	$4CDE00,$4FC9AE,$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16
		dc	$06D210,$000010,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$F4C1BF
		dc	$4CDE00,$CF0C16,$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE,$45E1CB
		dc	$CF0C16,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF,$05F420
		dc	$00FFFF,$574C16,$0461A0,$564D00,$0464A0,$0465A0,$00F3B8,$00000C
		dc	$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$00001A,$F0B900
		dc	$06DE10,$00000A,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2
		dc	$4549D3,$10DD00,$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$F0A1E2,$4559D3,$564C00,$03F18E,$22D400,$229000,$239800,$0460A4
		dc	$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021
		dc	$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4
		dc	$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409
		dc	$444C4C,$03F184,$555A00,$515A00,$22D400,$229000,$239800,$0460A4
		dc	$00000C,$44C800,$2000A0,$44C814,$200011,$06DE10,$000005,$180CA0
		dc	$44C8BA,$200014,$200011,$182400,$2000BA,$00000C,$46C813,$2000E1
		dc	$06DE10,$000003,$46C800,$564CE1,$566400,$00000C,$394000,$233D00
		dc	$204900,$204D00,$045112,$045516,$06D910,$000004,$46D900,$B0B200
		dc	$445600,$38FF00,$231C00,$204100,$204500,$044812,$044C16,$380200
		dc	$72F400,$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3
		dc	$5659C8,$D088EB,$063F90,$000005,$D5CAD4,$575DF3,$5659C8,$D088EB
		dc	$575D00,$204000,$204400,$387F00,$231A00,$231C00,$231E00,$204100
		dc	$204500,$204000,$204A00,$204400,$204E00,$380200,$72F400,$FFFFFE
		dc	$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8,$D088EB
		dc	$063F90,$000005,$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00,$00000C
		dc	$F1C000,$4DDA00,$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006,$F1C0A7
		dc	$4DDA00,$4ED8C8,$565CEB,$5F64B0,$2000A7,$565C00,$00000C,$F1C000
		dc	$4DDA00,$4EE1C8,$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB,$5F65B0
		dc	$06DA10,$00000A,$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0,$44D9A7
		dc	$5F64C8,$565CEB,$5F65B0,$2000A7,$565D00,$00000C,$F1C000,$4DDA00
		dc	$4EC8A8,$2000BB,$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00,$4EC8A8
		dc	$564CBB,$574DE0,$2000C7,$564C00,$00000C,$F1C100,$4DDA00,$4EE1A8
		dc	$4EE0BB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7,$06DA10
		dc	$00000B,$F1C100,$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7,$4EE1B8
		dc	$565CAB,$44C9E0,$574DC7,$564C00,$00000C,$56D800,$06D910,$000007
		dc	$0C1E01,$20003E,$23A403,$02A048,$56D800,$575900,$205000,$00000C
		dc	$46F400,$000001,$23AE00,$223555,$05A40D,$22B400,$06DC10,$000009
		dc	$56F400,$7FFFFF,$06DD10,$000004,$44DC00,$200045,$027040,$544D00
		dc	$223500,$234F00,$56E20B,$052406,$44F400,$00000F,$200045,$027040
		dc	$546200,$218500,$06DC10,$000004,$56E500,$218564,$544D00,$223500
		dc	$238759,$45F400,$000002,$56E500,$45F465,$FFFFFE,$057417,$45F465
		dc	$000002,$059411,$204D58,$20007D,$05744D,$0597D6,$56E500,$45F465
		dc	$FFFFFE,$057413,$45F465,$000002,$059406,$204D58,$20007D,$057442
		dc	$0597CB,$05A7D5,$20455C,$05A40D,$56E500,$200054,$544D00,$56E500
		dc	$45F450,$000002,$544500,$050FC0,$45F454,$000002,$546500,$050FC7
		dc	$234E00,$204D03,$05A407,$56E200,$200054,$546200,$56E500,$200050
		dc	$546500,$56E200,$200054,$546200,$56E500,$45F450,$000002,$546558
		dc	$050F8B,$223500,$45E200,$06DC10,$000005,$56E500,$200060,$218500
		dc	$544D00,$23AE00,$223555,$05A409,$22B400,$06DC10,$000006,$44CD00
		dc	$06DD10,$000002,$445C00,$000000,$00000C,$44F000,$000B41,$56F000
		dc	$000B94,$200045,$05A413,$209600,$60F400,$000180,$61F400,$000241
		dc	$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$06D910,$000005
		dc	$44D900,$56E000,$0C1E48,$545800,$050C10,$56F000,$000B7B,$200003
		dc	$05A40C,$60F400,$000235,$61F400,$0002F6,$390700,$06D910,$000005
		dc	$44D900,$56E000,$0C1E48,$545800,$00000C,$05F420,$FFFFFF,$0461A0
		dc	$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000000,$20004D
		dc	$05A40C,$44F400,$000010,$20004D,$0D104A,$000011,$300000,$56F400
		dc	$000000,$57F400,$FFFFFF,$00000C,$200013,$567000,$000912,$300000
		dc	$56F400,$000000,$57F400,$000608,$00000C,$050856,$0D1080,$00008C
		dc	$56F000,$000B93,$200003,$05744D,$0D1080,$000136,$0D1080,$000179
		dc	$0D1080,$0001BC,$240000,$447000,$00092B,$56F000,$000B41,$44F000
		dc	$000B94,$200045,$05A409,$0D1080,$00010E,$0D1080,$0001E3,$557000
		dc	$00092B,$0D1080,$0002CB,$0D1080,$0002E3,$0D1080,$0002F2,$0D1080
		dc	$00034D,$0D1080,$000309,$56F000,$000B41,$200003,$0D100A,$0003FE
		dc	$0D1080,$000356,$0D1080,$000383,$0D1080,$00039E,$0D1080,$FFFF87
		dc	$200013,$21101B,$00000C,$205800,$44D800,$447000,$000B42,$44D800
		dc	$447000,$000B43,$44D800,$447000,$000B44,$57D800,$0C1890,$002024
		dc	$507000,$000B78,$0C1890,$00101B,$507000,$000B7B,$0C1890,$003018
		dc	$507000,$000B7A,$44D800,$447000,$000B45,$44D800,$447000,$000B46
		dc	$44D800,$447000,$000B47,$57D800,$0C1890,$006020,$507000,$000B79
		dc	$57D800,$0C1890,$001023,$507000,$00023D,$0C1890,$001022,$507000
		dc	$00023E,$0C1890,$001021,$507000,$00023F,$0C1890,$004018,$507000
		dc	$000240,$61D800,$380600,$204800,$205900,$57D900,$015F8E,$577000
		dc	$000B49,$57D800,$0C1890,$008018,$507000,$000B41,$0C1890,$008020
		dc	$507000,$000B40,$57D800,$0C1890,$001018,$507000,$000B4C,$0C1890
		dc	$001019,$507000,$000B4A,$57D800,$577000,$000B4B,$57E000,$577000
		dc	$000B4D,$00000C,$56F000,$000912,$44F400,$020765,$200045,$052406
		dc	$56F000,$000B40,$200003,$05A45E,$00000C,$60F413,$0004FD,$060690
		dc	$000003,$545800,$545800,$60F413,$0005A8,$060590,$000002,$545800
		dc	$60F413,$00057B,$062890,$000002,$545800,$60F413,$0005AE,$065A90
		dc	$000002,$545800,$60F413,$000608,$060590,$000002,$545800,$60F413
		dc	$00060D,$060590,$000002,$545800,$60F413,$000509,$061090,$000002
		dc	$545800,$60F413,$000519,$060890,$000002,$545800,$60F413,$000521
		dc	$063C90,$000002,$545800,$60F413,$00055D,$061E90,$000002,$545800
		dc	$60F413,$000612,$060093,$000002,$545800,$44F400,$020765,$447000
		dc	$000912,$44F400,$000000,$447000,$000B93,$61F400,$000FC2,$71F000
		dc	$000B7A,$44F000,$000B7B,$5EE900,$547040,$000B94,$547000,$000B95
		dc	$44F01B,$000B94,$2D0513,$2C024D,$05945A,$44F01B,$000B95,$2D0613
		dc	$2C024D,$059455,$56F000,$000B79,$200023,$547000,$000B96,$44F01B
		dc	$000B78,$2D0313,$2C044D,$05944B,$44F01B,$000B96,$2D1313,$2C034D
		dc	$059446,$56F000,$000B79,$0140C4,$000024,$21DA00,$44F000,$000B78
		dc	$46F400,$000006,$2344D0,$0C1D2E,$44F440,$000F4C,$200040,$219100
		dc	$5EE100,$21CF22,$218422,$200022,$577040,$000B97,$218500,$21E46C
		dc	$46F400,$000008,$21A7D0,$5070E8,$000B9A,$457000,$000B98,$5170B0
		dc	$000B9B,$477000,$000B99,$507000,$000B9C,$050C03,$547000,$000B93
		dc	$00000C,$56F400,$000914,$44F000,$000B41,$200040,$219100,$56E100
		dc	$0C1E01,$44F43E,$000001,$20004C,$20291B,$45F403,$000003,$02A068
		dc	$20006D,$027068,$56F400,$000B5E,$44F000,$000B41,$200040,$219000
		dc	$556000,$00000C,$44F000,$000B7A,$46F400,$000006,$44F0D0,$000B41
		dc	$0C1D2E,$44F440,$000F92,$200040,$219400,$56F000,$000B44,$4CE400
		dc	$200040,$219100,$05E120,$56F000,$000B42,$4CE400,$200040,$219100
		dc	$56F000,$000B43,$4CE400,$200040,$219200,$44F400,$000100,$46E200
		dc	$2000D0,$240022,$210600,$2400D0,$46E200,$2400D2,$0C1D2E,$44E140
		dc	$200040,$219000,$70E200,$64F400,$0002FD,$3C0100,$3EFF00,$45F400
		dc	$3FF7CF,$56F000,$00023F,$200003,$05A40F,$56F000,$000B41,$44F432
		dc	$0004FD,$200040,$219100,$47F400,$000347,$57D900,$51D100,$0D04E1
		dc	$555900,$516100,$050C02,$0D04EE,$05F420,$00FFFF,$00000C,$56F000
		dc	$000B41,$44F000,$000B94,$200045,$05A44D,$56F000,$00023D,$200003
		dc	$05A45B,$60F400,$0002FD,$221400,$380100,$231C00,$44F000,$000B41
		dc	$46F400,$00000C,$44F4D0,$000521,$0C1D2E,$200040,$219100,$44F000
		dc	$000B41,$46F400,$000006,$44F4D0,$00055D,$0C1D2E,$200040,$219200
		dc	$56F000,$000240,$0140C4,$000007,$21DA00,$234400,$46F400,$00000F
		dc	$44F4D0,$000814,$0C1D2E,$200040,$219500,$3A0300,$3EFF00,$0D0498
		dc	$050C13,$56F000,$00023E,$200003,$05A40F,$60F400,$0002FD,$221400
		dc	$380100,$231C00,$61F400,$000509,$62F400,$000519,$65F400,$000800
		dc	$3A0400,$3EFF00,$0D04B9,$00000C,$44F000,$000B7A,$46F400,$000006
		dc	$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040,$219100,$4CE100
		dc	$447000,$000913,$61F400,$0002FD,$200013,$44D91B,$060091,$000004
		dc	$200047,$029040,$44D98A,$60F400,$0005A8,$70F000,$000B41,$200032
		dc	$44E826,$566847,$029040,$21C700,$56F400,$000914,$44F000,$000B41
		dc	$200040,$219000,$476000,$0C1C91,$44F000,$000B41,$46F400,$000002
		dc	$44F4D0,$00091A,$0C1D2E,$200040,$219000,$555800,$516000,$00000C
		dc	$60F400,$0002FD,$64F400,$0003FD,$380100,$231C00,$44F000,$000B41
		dc	$46F400,$000008,$44F4D0,$00057B,$0C1D2E,$200040,$219100,$65F400
		dc	$0008A2,$3A0200,$3EFF00,$0D0498,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380E00,$61F400,$0003FD
		dc	$204800,$060490,$000009,$200013,$064090,$000004,$44D900,$200047
		dc	$029040,$200026,$565800,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380800,$57F400,$000002,$204800
		dc	$380600,$060290,$00000B,$221100,$044812,$06CD10,$000006,$44DA00
		dc	$56DA00,$200045,$029040,$565900,$20402A,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600,$62F400
		dc	$0008AF,$390200,$45F41B,$000001,$20A600,$060390,$00000D,$221100
		dc	$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068
		dc	$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800
		dc	$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A
		dc	$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040
		dc	$219000,$44E100,$46F400,$7FFFFF,$44E0D0,$200045,$20291B,$56F400
		dc	$000926,$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$62F400,$0008AC,$390200,$20A61B,$060390,$00000D,$221100,$4FDA00
		dc	$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068,$20CE00
		dc	$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE
		dc	$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800,$200045
		dc	$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A,$0C1D2E
		dc	$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040,$219000
		dc	$44E100,$46F400,$400000,$46E0D0,$446055,$20291B,$56F400,$000B7C
		dc	$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600,$20AE00
		dc	$060390,$00000A,$221100,$219900,$221200,$204900,$44D900,$445A00
		dc	$44D900,$445A00,$204832,$00000C,$56F400,$000B7C,$44F000,$000B41
		dc	$200040,$219000,$56F400,$00060D,$44F000,$000B41,$200040,$219100
		dc	$56F400,$000B81,$44F000,$000B41,$200040,$219200,$44E01B,$56E100
		dc	$45F442,$000001,$02A068,$576200,$446100,$00000C,$60F400,$0002FD
		dc	$44F000,$000B41,$46F400,$000080,$44F4D0,$000612,$0C1D2E,$200040
		dc	$219100,$64F400,$0008B2,$65F400,$000000,$0D04F6,$00000C,$56F000
		dc	$00092B,$200003,$05A40E,$60F400,$000000,$61F400,$000040,$221400
		dc	$223500,$62F400,$000AB2,$66F400,$000AF2,$3A3F00,$0D0547,$050C0A
		dc	$60F400,$000000,$221400,$62F400,$0009B2,$66F400,$000A32,$3A7F00
		dc	$0D0538,$00000C,$0500A0,$0461A0,$56F000,$00092B,$200003,$05A415
		dc	$60F400,$000000,$61F400,$000040,$64F400,$0003FD,$65F400,$0004FC
		dc	$62F400,$000AB2,$66F400,$000AF2,$382000,$231900,$3A3F00,$3C0300
		dc	$75F400,$FFFFFD,$0D056D,$050C11,$60F400,$000000,$64F400,$0003FD
		dc	$65F400,$0004FC,$62F400,$0009B2,$66F400,$000A32,$384000,$3A7F00
		dc	$3C0200,$75F400,$FFFFFE,$0D055E,$05F420,$00FFFF,$0461A0,$56F000
		dc	$000B41,$44F000,$000B94,$60F445,$0003FD,$05A408,$61F400,$000180
		dc	$06B590,$000003,$44D800,$445900,$050C07,$61F400,$000235,$060790
		dc	$000003,$44D800,$445900,$00000C,$56F000,$00092B,$200003,$05A40A
		dc	$60F400,$000000,$384000,$0D03E9,$60F400,$000040,$384000,$0D03E9
		dc	$050C05,$60F400,$000000,$388000,$0D03E9,$00000C,$56F000,$000B94
		dc	$44F000,$000B41,$45F445,$000001,$05A403,$05080D,$050C03,$457000
		dc	$000B8C,$60F400,$000B7C,$61F400,$0005A3,$060590,$000003,$44D800
		dc	$445900,$00000C,$290300,$70F000,$000B41,$60F400,$000B7C,$56E800
		dc	$014185,$05A410,$60F400,$000926,$56E800,$014185,$05A40B,$56F000
		dc	$000B40,$014085,$05A406,$60F400,$0005A3,$56E800,$014185,$05A402
		dc	$290200,$60F400,$000B87,$516800,$00000C,$3D1800,$44F000,$000B41
		dc	$56F000,$000B94,$60F445,$000180,$05A40C,$209600,$61F400,$000241
		dc	$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$0D0585,$050C0A
		dc	$56F000,$000B7B,$60F403,$000235,$05A405,$61F400,$0002F6,$390700
		dc	$0D0585,$00000C,$000000,$000000,$000000,$000000,$000000,$000000
		dc	$320000,$06FF9F,$000002,$5EDA00,$44F000,$000B41,$56F000,$000B94
		dc	$61F445,$000241,$05A459,$56F400,$000B87,$44F000,$000B41,$200040
		dc	$219000,$56F400,$000BA2,$44F000,$000B41,$200040,$219200,$56E000
		dc	$71E200,$219400,$223600,$56F400,$000B59,$44F000,$000B41,$200040
		dc	$219000,$56F400,$000B8E,$44F000,$000B41,$200040,$219200,$232E00
		dc	$014184,$0B74C4,$000F16,$218500,$47F4AD,$000001,$0B74C4,$000F12
		dc	$21E600,$209DD0,$0C1D2E,$46F465,$2AAAAB,$202978,$556000,$21A500
		dc	$21BCE9,$0C1D82,$200010,$200065,$202978,$556200,$223200,$205900
		dc	$3A0000,$0D0590,$050C11,$56F000,$000B7B,$60F403,$000B8C,$05A40C
		dc	$61F400,$0002F6,$390700,$223600,$223200,$205900,$3A0000,$3C0600
		dc	$7DF000,$000F13,$0D0590,$00000C,$56F000,$000240,$0C1D04,$21C700
		dc	$46F400,$000003,$2000B0,$0C1D2E,$0140C0,$000049,$21C600,$61F400
		dc	$000B9D,$62F400,$000BA2,$45F000,$000B94,$06C510,$000003,$475900
		dc	$465A00,$57F400,$000001,$56F000,$000B40,$200003,$05A402,$20001B
		dc	$577000,$000B8D,$00000C,$56F400,$00000A,$57F400,$000000,$70F400
		dc	$000416,$0BF080,$000180,$200003,$052400,$00000C,$56F400,$00000A
		dc	$57F400,$000001,$60F400,$0004FD,$70F400,$000416,$390000,$0BF080
		dc	$000180,$200003,$052400,$00000C,$56F400,$00000A,$57F400,$000002
		dc	$60F400,$0004FD,$70F400,$000416,$390000,$0BF080,$000180,$200003
		dc	$052400,$00000C,$56F400,$000011,$57F400,$000001,$390000,$70F400
		dc	$000080,$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C
		dc	$56F400,$00000D,$57F400,$000000,$70F400,$000390,$0BF080,$000180
		dc	$200003,$052400,$56F400,$00000E,$57F400,$000000,$70F400,$000390
		dc	$0BF080,$000180,$200003,$052400,$00000C,$447000,$000963,$56F000
		dc	$000B94,$200045,$052407,$71F400,$000389,$380700,$60F400,$000235
		dc	$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000180,$211900,$56F400
		dc	$00000D,$57F400,$000002,$0BF080,$000180,$200003,$052400,$44F000
		dc	$000963,$56F000,$000B94,$200045,$052407,$71F400,$000389,$380700
		dc	$60F400,$0002F6,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000241
		dc	$211900,$56F400,$00000E,$57F400,$000002,$0BF080,$000180,$200003
		dc	$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\ldr_sip.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			ldr_sip.inc
;												
;   Contents:		Loader Software Interface Protocol (SIP) for 
;					Dolby Game Encoder
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	8/16/2000 12:07:45 PM		jmw
;	Created.
;
;
; ******************************************************************

;	Loader system equates

LDR_HDR_SIZE		equ		4		; program header size

;	Buffer ID equates

LID_MIN				equ		0		; min valid ID
LID_MAX				equ		31		; max valid ID

LID_LOADER_INIT		equ		0		; Loader initialization request

LID_PROG_DSURRE		equ		1		; Dolby Surround Encoder program
LID_PROG_DGAME1		equ		2		; Dolby Game Encoder #1 program
LID_PROG_DGAME2		equ		3		; Dolby Game Encoder #2 program
LID_PROG_DGAME3		equ		4		; Dolby Game Encoder #3 program
LID_PROG_DMMONO		equ		5	   	; Dolby Mono Downmix program
LID_PROG_DMSTEREO	equ		6	   	; Dolby Stereo Downmix program

LID_MAX_PROG		equ		6		; max valid program ID

LID_BUF_PCM			equ		7		; Input PCM buffer
LID_BUF_LTRT		equ		8		; Output Lt/Rt buffer
LID_BUF_AC3			equ		9		; Output AC-3 buffer

LID_CONFIG_LIST		equ		10		; system configuration data		

LID_PING_PONG		equ		11		; NVIDIA ping pong Loader ID
LID_AC3_ZEROS		equ		12
LID_AC3_PREAMBLE	equ		13
LID_BUF_DATA		equ		14		; Output data buffer base

LDR_NUM_DATA		equ		(LID_MAX-LID_BUF_DATA+1)	; max # data buffers

;	Loader table equates

LDR_TABLE_SIZE		equ		((LID_MAX+1)*2)			; DSP loader table size
LDR_SYSTABLE_SIZE	equ		((LID_BUF_DATA+1)*2)	; SysMem loader table size
LDR_HEAP_ADDR		equ		(LID_BUF_DATA*2)		; heap address offset
LDR_HEAP_SIZE		equ		((LID_BUF_DATA*2)+1)	; heap size offset
LDR_PINGPONG_OFFSET equ     (LID_PING_PONG*2)

;	Action equates

LDR_ACT_MIN			equ		0		; min valid action

LDR_ACT_ALLOC		equ		0		; allocate data buffer
LDR_ACT_TO_DSPX		equ		1		; copy to DSP x:
LDR_ACT_FROM_DSPX	equ		2		; copy from DSP x:
LDR_ACT_TO_DSPY		equ		3		; copy to DSP y:
LDR_ACT_FROM_DSPY	equ		4		; copy from DSP y:
LDR_ACT_TO_DSPP		equ		5		; copy to DSP p:
LDR_ACT_FROM_DSPP	equ		6		; copy from DSP p:

LDR_ACT_MAX			equ		6		; max valid action

;	PCM offset equates

LDR_OFF_PCM_L		equ		0		; left PCM offset
LDR_OFF_PCM_C		equ		1		; center PCM offset
LDR_OFF_PCM_R		equ		2		; right PCM offset
LDR_OFF_PCM_LS		equ		3		; left surround PCM offset
LDR_OFF_PCM_RS		equ		4		; right surround PCM offset
LDR_OFF_PCM_LFE		equ		5		; LFE PCM offset

LDR_OFF_PCM_LT		equ		0		; left total PCM offset
LDR_OFF_PCM_RT		equ		1		; right total PCM offset

;	Error codes

LDR_ERR_NONE		equ		0		; no error
LDR_ERR_ID			equ		1		; invalid buffer ID
LDR_ERR_ACTION		equ		2		; invalid action
LDR_ERR_LENGTH		equ		3		; invalid length/offset combination
LDR_ERR_ALLOC		equ		4		; buffer allocation error
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\sehelper.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			sehelper.asm
;												
;   Contents:		Helper Functions for SuperExec
;					Only used for simulator version.
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/12/2000 3:49:54 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'SuperExec Helper Fcns'

	section	SuperExecHelper
	
;**** include files ************************************************

	nolist
	include 'mot_equ.inc'
	list

;**** external references ******************************************

	xdef	CopyInFilesToSysMem
	xdef	Copy6ChInFileToSysMem

	xdef	CopySysMemToOutputFiles
	xdef	CopySysMemToAC3OutputFile

;**** equates ******************************************************

simulator_l_pcm_input		equ		$ef0000		; DSP chip locations for simulator
simulator_r_pcm_input		equ		$ef0001		; These will not be needed in NVIDIA
simulator_c_pcm_input		equ		$ef0002		; implementation
simulator_ls_pcm_input  	equ		$ef0003		;
simulator_rs_pcm_input  	equ		$ef0004		;

BLOCK_LEN					equ		256
AC3_BLOCK0_OFFSET			equ		(3072-1280-290)
AC3WORDSPERFRAME			equ		1280

;**** data *********************************************************

	mode rel
	org	p(202):

;*******************************************************************
;*
;*	Subroutine Name:	CopyInFilesToSysMem
;*																								
;*  Description:		Copies Input data to Simulated X-Box System memory
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
CopyInFilesToSysMem:

	move	#SYSMEMPCMBASE,r1
	
	dor		#BLOCK_LEN,l_loop
		move	x:simulator_l_pcm_input,a
		move	a,x:(r1)+
l_loop:

	dor		#BLOCK_LEN,c_loop
		move	x:simulator_c_pcm_input,a
		move	a,x:(r1)+
c_loop:

	dor		#BLOCK_LEN,r_loop
		move	x:simulator_r_pcm_input,a
		move	a,x:(r1)+
r_loop:

	dor		#BLOCK_LEN,ls_loop
		move	x:simulator_ls_pcm_input,a
		move	a,x:(r1)+
ls_loop:

	dor		#BLOCK_LEN,rs_loop
		move	x:simulator_rs_pcm_input,a
		move	a,x:(r1)+
rs_loop:

	rts


;*******************************************************************
;*
;*	Subroutine Name:	CopySysMemToOutputFiles
;*																								
;*  Description:		Copies simulated X-Box Sys Mem to Output debug files
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
CopySysMemToOutputFiles:

	move	#SYSMEMLTRTBASE,r0
	move	#SYSMEMLTRTBASE+BLOCK_LEN,r1

	dor		#BLOCK_LEN,outcopy
		movep	x:(r0)+,x:M_TX00
		movep	x:(r1)+,x:M_TX00
outcopy:

	rts


;*******************************************************************
;*
;*	Subroutine Name:	Copy6ChInFileToSysMem
;*																								
;*  Description:		Copies a single 6-channel block of Input data 
;*						to Simulated X-Box System memory
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
Copy6ChInFileToSysMem:

	move	#SYSMEMPCMBASE,r0
	move	#BLOCK_LEN,n1

	dor		#BLOCK_LEN,loop_6ch
		move	r0,r1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		move	(r0)+
loop_6ch:

	rts

;*******************************************************************
;*
;*	Subroutine Name:	CopySysMemToAC3OutputFile
;*																								
;*  Description:		Copies simulated X-Box Sys Mem to Output debug files
;*
;*	Input:				n0 - number of words to copy
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************

CopySysMemToAC3OutputFile:

	move	#SYSMEMAC3BASE+AC3_BLOCK0_OFFSET,r0
	
	dor		#AC3WORDSPERFRAME,outcopyAC3
	movep	x:(r0)+,x:M_TX00
outcopyAC3:

	rts

;******************************************************************************

	endsec	; SuperExecHelper
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\se_sip.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			se_sip.inc
;												
;   Contents:		Super Exec Configuration Software Interface Protocol (SIP)
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/14/2000 10:08:08 AM		jmw
;	Created.
;
;
; ******************************************************************

;**** SuperExec input parameter list equates ****

SE_IN_SIZE			equ		0		; input parameter list size
SE_IN_DO_SURROUND	equ		1		; do Dolby Surround Encoder flag
SE_IN_DO_GAME		equ		2		; do Dolby Game Encoder flag
SE_IN_DO_DOWNMIX	equ		3		; do Dolby Downmix (1 for Mono, 2 for Stereo)
SE_IN_FSCODE		equ		4		; PCM sampling rate code
SE_IN_ACMODE		equ		5		; input channel configuration
SE_IN_LFE			equ		6		; low frequency effects channel present flag
SE_IN_DIALNORM		equ		7		; dialnorm setting
SE_IN_BW			equ		8		; manual channel bandwidth
SE_IN_LPF			equ		9		; channel LPF enabled flag
SE_IN_LFELPF		equ		10		; LFE LPF flag
SE_IN_HPF			equ		11		; DC HPF flag
SE_IN_DYNRNGE		equ		12		; dynrng exists flag
SE_IN_DYNRNG		equ		13		; AC-3 dynamic range code
SE_IN_COMPRE		equ		14		; compr exists flag
SE_IN_COMPR			equ		15		; AC-3 compression code
SE_IN_SURR_GE		equ		16		; Dolby Surround gain enabled flag
SE_IN_SURR_GAIN		equ		17		; Dolby Surround gain
SE_IN_DSURMOD		equ		18		; Dolby Surround Mode.  Only used for 2/0 Mode
SE_IN_RESERVED_1	equ		19
SE_IN_RESERVED_2	equ		20
SE_IN_RESERVED_3	equ		21
SE_IN_RESERVED_4	equ		22
SE_IN_RESERVED_5	equ		23

SE_IN_MAX			equ		24		; maximum input parameter list size
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\sysmem.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			sysmem.asm
;												
;   Contents:		Game Encoder System memory Simulator
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/9/2000 5:46:11 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'System Memory'

	section	Sysmem

;**** include files ************************************************

	nolist
	include 'ldr_sip.inc'
	include 'se_sip.inc'
	list

;**** equates ******************************************************

SYSMEM_HEAP_SIZE		equ		8192
AC3_OUT_BUFF_SIZE		equ		3072
PCM_LTRT_OUT_BUFF_SIZE	equ		512
PCM_IN_BUFF_SIZE		equ		1536

;**** program code *************************************************

	org		x(100):

SysLdrTable:
	dc		LDR_SYSTABLE_SIZE		; table size
	dc		LID_MAX_PROG			; number of programs
	dc		prog_1_ptr				; pointer to program #1
	dc		prog_1_size				; size of program #1
	dc		prog_2_ptr				; pointer to program #2
	dc		prog_2_size				; size of program #2
	dc		prog_3_ptr				; pointer to program #3
	dc		prog_3_size				; size of program #3
	dc		prog_4_ptr				; pointer to program #4
	dc		prog_4_size				; size of program #4
	dc		pcm_ptr					; pointer to input PCM buffer
	dc		pcm_size				; size of input PCM buffer
	dc		ltrt_ptr				; pointer to output Lt/Rt buffer
	dc		ltrt_size				; size of output Lt/Rt buffer
	dc		ac3_ptr					; pointer to output AC-3 buffer
	dc		ac3_size				; size of output AC-3 buffer
	dc		config_ptr				; configuration data pointer
	dc		config_size				; configuration data size
	dc		heap_ptr				; pointer to heap data buffer
	dc		heap_size				; size of heap data buffer

prog_1_ptr:
	nolist
	include 'encds.asm'				; Dolby Surround Program Code
	list
prog_1_size	equ		(*)-prog_1_ptr

prog_2_ptr:
	nolist
	include 'llef13.asm'			; Game Encoder Fcn 1 Program Code
	list
prog_2_size	equ		(*)-prog_2_ptr

prog_3_ptr:
	nolist
	include 'llef23.asm'			; Game Encoder Fcn 2 Program Code
	list
prog_3_size	equ		(*)-prog_3_ptr

prog_4_ptr:
	nolist
	include 'llef33.asm'			; Game Encoder Fcn 3 Program Code
	list
prog_4_size	equ		(*)-prog_4_ptr

	org		x(101):

pcm_ptr		ds		PCM_IN_BUFF_SIZE		; PCM Input Buffer
pcm_size	equ		(*)-pcm_ptr

	org		x(102):

ltrt_ptr	ds		PCM_LTRT_OUT_BUFF_SIZE	; PCM Lt/Rt Output Buuffer
ltrt_size	equ		(*)-ltrt_ptr

	org		x(103):

ac3_ptr		bsc		AC3_OUT_BUFF_SIZE,0		; AC-3 Output Buffer
ac3_size	equ		(*)-ac3_ptr

	org		x(104):

config_ptr:
	nolist
	include 'lleconfg.asm'					; System Configuration data
	list
config_size	equ		(*)-config_ptr

	org		x(105):

heap_ptr	ds		SYSMEM_HEAP_SIZE		; Heap
heap_size	equ		(*)-heap_ptr

	org		y(301):
	nolist	
	include 'lleyrom.asm'					; Game Encoder ROM
	list	

;**** program code *************************************************

	endsec	; Sysmem
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\lleconfg.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			lleconfg.asm
;												
;   Contents:		System memory simulation of configuration data
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/14/2000 10:51:57 AM		jmw
;	Created.
;
;
; ******************************************************************

	IF		@DEF('RTSYS')

;	Dolby's Cagent 6 Development hardware

	dc		SE_IN_MAX		; input parameter list size
	dc		0				; do Dolby Surround Encoder flag
	dc		1				; do Dolby Game Encoder flag
	dc		0				; PCM sampling rate code
	dc		3				; input channel configuration
	dc		1				; low frequency effects channel present flag
	dc		16				; dialnorm setting 
	dc		5				; manual channel bandwidth 
	dc		0				; channel LPF enabled flag 
	dc		0				; LFE LPF flag 
	dc		0				; DC HPF flag
	dc		0				; dynrng exists flag
	dc		$0				; AC-3 dynamic range code 
	dc		1				; compr exists flag
	dc		$ef				; AC-3 compression code ($ef = -6dB in RF mode) 
	dc		1				; Surround gain enabled
	dc		0.562341325		; Surround gain: 0.562341325 = -5 dB, 0.177827941 = -15dB
	dc		$02				; Dolby Surround mode in 2/0 Mode (dsurmod)

	ELSE

;	NVIDIA hardware and Motorola Simulator

	dc		SE_IN_MAX		; input parameter list size
	dc		0				; do Dolby Surround Encoder flag
	dc		1				; do Dolby Game Encoder flag
	dc		0				; PCM sampling rate code
	dc		7				; input channel configuration
	dc		1				; low frequency effects channel present flag
	dc		16				; dialnorm setting 
	dc		9				; manual channel bandwidth 
	dc		1				; channel LPF enabled flag 
	dc		1				; LFE LPF flag 
	dc		1				; DC HPF flag 
	dc		0				; dynrng exists flag
	dc		$0				; AC-3 dynamic range code 
	dc		0				; compr exists flag
	dc		$ef				; AC-3 compression code 
	dc		1				; Surround gain enabled
	dc		0.562341325		; Surround gain: 0.562341325 = -5 dB, 0.177827941 = -15dB 
	dc		$02				; Dolby Surround mode in 2/0 Mode (dsurmod)

	ENDIF	; @DEF('RTSYS')
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\dmautil.h ===
;*******************************************************************
;
;    DMAUtil.h		DMA header file for Global/Encode Audio Processor   
;
;
;		Written by Gints Klimanis
;
;******************************************************************        

; ==============================================================
;  DMA Engine stuff
; ==============================================================

kDMANode_MaxSize	equ		7	
kDMANode_Size		equ		6	
kDMANode_EOL		equ		$004000		; Bit 14 = Eol
kDMANode_EOLMask	equ		$003fff		; Will Clear Eol bit

DMA_CONTROL_REGISTER 		equ $FFFFD6	; Address of DMA control register
kDMA_ActionRequest_Start    	equ 1		 
kDMA_ActionRequest_Stop    		equ 2		 
kDMA_ActionRequest_Freeze    	equ 3		 
kDMA_ActionRequest_UnFreeze   	equ 4		 
kDMA_ActionRequest_Abort		equ 5
	 
kDMA_FrozenBit		equ		3	
kDMA_RunningBit		equ		4
kDMA_StoppedBit		equ		5

DMA_CONFIGURATION_REGISTER	equ $FFFFD7	; Address of DMA configuration register
kDMA_AutoStartBit		equ		0			; Bit 0
kDMA_AutoRdyBit			equ		1
kDMA_IocRequireClrBit	equ		2
kDMA_EolRequireClrBit	equ		3
kDMA_ErrRequireClrBit	equ		4

kDMASampleFormat_08bits		equ		0
kDMASampleFormat_16bits		equ		1
kDMASampleFormat_24msbits	equ		2
kDMASampleFormat_32bits		equ		3
kDMASampleFormat_24lsbits	equ		6

DMA_NEXT_BLOCK_CONTROL_REGISTER		equ $FFFFD4 ; Bit 14 eol, Bits 13:0  Head of List Address
												; Alter only in Idle State or frozen bit asserted
DMA_START_BLOCK_CONTROL_REGISTER	equ $FFFFD5	; Bit 14 e0l, Bits 13:0  Head of List Address

; *********** DMA Read/Write Words **************
; 
; dspBaseAddress = $000000 (0)
; blockSize      = $000000 (0)

; ---- Word 0
; eol         = $1 (1) 
; nextCmd     = $000000 (0)

; ---- Word 1
; interleave  = $0 ( 0) (bit    :0)
; rdDspMem    = $0 ( 0) (bit    :1)(DSP Memory <- System Memory)
; IOC         = $0 ( 0) (bit   3:2)
; smPtrWrBk   = $0 ( 0) (bit     4)
; smBufID     = $F (15) (bit   8:5)
; iso         = $0 ( 0) (bit     9)
; smDataFmt   = $6 ( 6) (bit 12:10)
; >>>>> CONTROLBITS = $19E0
; incr        = $1 ( 1) 

; ---- Word 1 without smDataFmt
; interleave  = $0 ( 0) (bit    :0)
; rdDspMem    = $0 ( 0) (bit    :1)(DSP Memory <- System Memory)
; IOC         = $0 ( 0) (bit   3:2)
; smPtrWrBk   = $0 ( 0) (bit     4)
; smBufID     = $F (15) (bit   8:5)
; iso         = $0 ( 0) (bit     9)
; smDataFmt   = $0 ( 0) (bit 12:10)
; >>>>> CONTROLBITS = $01E0
; incr        = $1 ( 1) 

; ---- Word 2
; Count1      = $0000 (0)
; Count0      = $0000 (0)

; ---- Word 3
; Nul         = $0 (0)
; PDspStart   = $000000 (0)

; ---- Word 4
; smOffset      = $000000 (0)

; ---- Word 5 (Used in circular buffers)
; smBaseAddress = $000000 (0)

; ---- Word 6 (Used in circular buffers)
; smSizeMinus1  = $000000 (0)

; >>>>>> Only need Words 0..4
;
;  Generated by dmawords.exe

DMA_BASE_READ0	equ	$004000
DMA_BASE_READ1	equ	$0059E0
DMA_BASE_READ1_ISO	equ	$005BE0
DMA_BASE_READ2	equ	$000000
DMA_BASE_READ3	equ	$000000
DMA_BASE_READ4	equ	$000000
DMA_BASE_READ5	equ	$000000

DMA_BASE_WRITE0	equ	DMA_BASE_READ0
DMA_BASE_WRITE1	equ	$0059E2
DMA_BASE_WRITE1_ISO	equ	$005BE2
DMA_BASE_WRITE2	equ	DMA_BASE_READ2
DMA_BASE_WRITE3	equ	DMA_BASE_READ3
DMA_BASE_WRITE4	equ	DMA_BASE_READ4
DMA_BASE_WRITE5	equ	DMA_BASE_READ5

DMA_BASE_WRITEFIFO1 equ $004402       ; 16-bit output, write to FIFO
DMA_BASE_WRITEFIFO2 equ $000403       ; 16-bit output, write to FIFO, Interleaved

DMA_BASE_WRITEFIFO1_ISO equ $004602       ; 16-bit output, write to FIFO
DMA_BASE_WRITEFIFO2_ISO equ $000603       ; 16-bit output, write to FIFO, Interleaved

DMA_NODE_EOL0	equ	$004000
DMA_NODE_EOL1	equ	$000000
DMA_NODE_EOL2	equ	$000000
DMA_NODE_EOL3	equ	$000000
DMA_NODE_EOL4	equ	$000000
DMA_NODE_EOL5	equ	$000000

;************************************************************
; GPClearDMAConfigRegister	Clear  register
;************************************************************
GPClearDMAConfigRegister macro
      	movep    #>0,x:DMA_CONFIGURATION_REGISTER	
	endm
; ---- end GPClearDMAConfigRegister ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\encds.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 01/10/01, 11:04:13
;	Program info
;	  Program number: 1
;	  Revision number: 1.51
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 659 words
;	  Checksum: $4D63EB

		dc	$D01B40,$000293,$010133,$4D63EB,$607000,$00062E,$20000B,$05A406
		dc	$44F400,$008002,$447000,$000604,$050C05,$44F400,$000002,$447000
		dc	$000604,$44F400,$00000A,$447000,$000600,$44F400,$00060A,$447000
		dc	$000601,$44F400,$000610,$447000,$000602,$44F400,$000616,$447000
		dc	$000603,$44F400,$00061C,$447000,$000605,$44F400,$000622,$447000
		dc	$000606,$44F400,$000628,$447000,$000607,$44F400,$000000,$447000
		dc	$000608,$44F400,$000100,$447000,$000609,$60F400,$00060A,$44F400
		dc	$000000,$445800,$44F400,$000100,$445800,$44F400,$000200,$445800
		dc	$44F400,$000300,$445800,$44F400,$000400,$445800,$44F400,$FFFFFF
		dc	$446000,$60F400,$000610,$44F400,$000001,$445800,$445800,$445800
		dc	$445800,$445800,$240000,$446000,$60F400,$000616,$44F400,$FFFFFF
		dc	$445800,$445800,$445800,$445800,$445800,$446000,$60F400,$00061C
		dc	$44F400,$000400,$445800,$44F400,$FFFFFF,$445800,$44F400,$000500
		dc	$445800,$44F400,$FFFFFF,$445800,$44F400,$FFFFFF,$445800,$44F400
		dc	$FFFFFF,$445800,$60F400,$000622,$44F400,$000001,$445800,$240000
		dc	$445800,$44F400,$000001,$445800,$240000,$445800,$240000,$445800
		dc	$240000,$445800,$60F400,$000628,$44F400,$FFFFFF,$445800,$445800
		dc	$445800,$445800,$445800,$445800,$56F400,$000005,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000005,$60F400,$000100
		dc	$70F400,$000100,$390100,$0D0180,$56F400,$000005,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$56F400,$000005,$60F400,$000300
		dc	$70F400,$000100,$390300,$0D0180,$56F400,$000005,$60F400,$000400
		dc	$70F400,$000100,$390400,$0D0180,$62F000,$00062E,$024295,$023ADE
		dc	$200003,$052018,$60F413,$000600,$57F400,$000016,$0D1080,$00001C
		dc	$56F400,$000006,$60F400,$000400,$70F400,$000100,$390000,$0D0180
		dc	$56F400,$000006,$60F400,$000500,$70F400,$000100,$390100,$0D0180
		dc	$00000C,$60F400,$000000,$068092,$000005,$44D800,$46D0A1,$5658E9
		dc	$575800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0,$0465A0
		dc	$0466A0,$00F3B8,$44F400,$000016,$20004D,$0D104A,$000008,$300000
		dc	$56F400,$000000,$57F400,$FFFFFF,$00000C,$0D1080,$0000B8,$56F000
		dc	$000632,$200003,$05A406,$0D1080,$00015A,$0D1080,$000139,$050C03
		dc	$0D1080,$00015D,$0D1080,$00013A,$56F000,$000633,$014085,$05A417
		dc	$66F000,$00062F,$3E0300,$60EE00,$3E0400,$61EE00,$66F000,$000630
		dc	$3E0300,$70EE00,$3E0400,$71EE00,$46F400,$5A827A,$62F000,$000638
		dc	$06D210,$000005,$44E000,$44C9D0,$2000D3,$564800,$66F000,$00062F
		dc	$3E0000,$60EE00,$3E0200,$61EE00,$3E0100,$62EE00,$66F000,$000634
		dc	$3E0000,$64EE00,$3E0200,$65EE00,$66F000,$000630,$3E0000,$70EE00
		dc	$3E0200,$71EE00,$3E0100,$72EE00,$66F000,$000635,$3E0000,$74EE00
		dc	$76F400,$000002,$75EE00,$45F400,$5A827A,$66F000,$000638,$06D600
		dc	$00043D,$44CA00,$56C800,$57C9A3,$564CAB,$574D00,$61F400,$000639
		dc	$65F000,$00068D,$62F400,$000671,$66F000,$000634,$3E0000,$60EE00
		dc	$221400,$66F000,$000635,$70EE00,$231C00,$50F000,$000638,$00000A
		dc	$211E00,$72F400,$000004,$0BF080,$00056B,$61F400,$000649,$65F000
		dc	$00068D,$62F400,$000679,$66F000,$000634,$3E0200,$60EE00,$221400
		dc	$66F000,$000635,$70EE00,$231C00,$50F000,$000638,$00000A,$211E00
		dc	$72F400,$000004,$0BF080,$00056B,$61F400,$000659,$65F000,$00068E
		dc	$62F400,$000681,$66F000,$00062F,$3E0300,$60EE00,$221400,$66F000
		dc	$000630,$70EE00,$231C00,$50F000,$000638,$00000A,$211E00,$72F400
		dc	$000006,$0BF080,$00056B,$66F000,$000634,$3E0000,$60EE00,$3E0200
		dc	$61EE00,$66F000,$00062F,$3E0300,$62EE00,$66F000,$000635,$3E0000
		dc	$70EE00,$3E0200,$71EE00,$66F000,$000630,$3E0300,$72EE00,$45F400
		dc	$5A827A,$64F000,$000638,$06D400,$0004A1,$44CA00,$56E000,$57E1A3
		dc	$5648AF,$574900,$0D1080,$0000BE,$00000C,$205800,$44D800,$447000
		dc	$00062F,$44D800,$447000,$000630,$44D800,$447000,$000631,$57D800
		dc	$0C1890,$001027,$507000,$000632,$0C1890,$001019,$507000,$000633
		dc	$44D800,$447000,$000634,$44D800,$447000,$000635,$44D800,$447000
		dc	$000636,$57D800,$0C1890,$002024,$507000,$000637,$44D800,$447000
		dc	$000638,$00000C,$A2DD74,$3AE54D,$C51AB3,$5D228C,$800000,$CAE85F
		dc	$47C25A,$47C25A,$CAE85F,$7FFFFF,$855BE8,$756638,$756638,$855BE8
		dc	$7FFFFF,$EA1F92,$E2404B,$E2404B,$EA1F92,$7FFFFF,$812B1B,$7DAC85
		dc	$7ED594,$812A6C,$7ED594,$C48FCE,$1B99D0,$092E48,$092E5B,$092E6E
		dc	$CAE85F,$47C25A,$1768D5,$1768BD,$1768A5,$CAE85F,$47C25A,$1768D5
		dc	$1768BD,$1768A5,$823E22,$7B876D,$7B876D,$823E22,$7FFFFF,$B23B5E
		dc	$27F74F,$27F74F,$B23B5E,$7FFFFF,$A062D3,$3FC327,$C03CD9,$5F9D2D
		dc	$800000,$C37356,$4A2F0E,$4A2F0E,$C37356,$7FFFFF,$84EF9E,$763A35
		dc	$763A35,$84EF9E,$7FFFFF,$E648FE,$E4B78A,$E4B78A,$E648FE,$7FFFFF
		dc	$8112E7,$7DDC7F,$7EEDAC,$811254,$7EEDAC,$BFB2BF,$204D6F,$07ECAA
		dc	$07ECBB,$07ECCD,$C37356,$4A2F0E,$1448F5,$1448DE,$1448C8,$C37356
		dc	$4A2F0E,$1448F5,$1448DE,$1448C8,$82101A,$7BE2ED,$7BE2ED,$82101A
		dc	$7FFFFF,$AF2EFC,$2C7800,$2C7800,$AF2EFC,$7FFFFF,$61F413,$000639
		dc	$065490,$000002,$565900,$00000C,$60F400,$0004CA,$61F400,$000000
		dc	$066490,$000003,$07D884,$4C5900,$56F000,$000637,$240000,$60F400
		dc	$000032,$61F445,$000046,$05A405,$60F400,$000000,$61F400,$000014
		dc	$607000,$00068D,$617000,$00068E,$00000C,$56F400,$00000C,$57F400
		dc	$000000,$385400,$0BF080,$000180,$00000C,$56F400,$00000C,$57F400
		dc	$000001,$60F400,$000639,$385400,$390000,$0BF080,$000180,$00000C
		dc	$56F400,$00000C,$57F400,$000002,$60F400,$000639,$385400,$390000
		dc	$0BF080,$000180,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600
		dc	$06DA10,$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4
		dc	$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09
		dc	$444C4C,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2
		dc	$200010,$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000
		dc	$239800,$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\encdsnorm.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 01/10/01, 11:04:13
;	Program info
;	  Program number: 1
;	  Revision number: 1.51
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 659 words
;	  Checksum: $4D63EB

		dc	$D01B40,$000293,$010133,$4D63EB,$607000,$00062E,$20000B,$05A406
		dc	$44F400,$008002,$447000,$000604,$050C05,$44F400,$000002,$447000
		dc	$000604,$44F400,$00000A,$447000,$000600,$44F400,$00060A,$447000
		dc	$000601,$44F400,$000610,$447000,$000602,$44F400,$000616,$447000
		dc	$000603,$44F400,$00061C,$447000,$000605,$44F400,$000622,$447000
		dc	$000606,$44F400,$000628,$447000,$000607,$44F400,$000000,$447000
		dc	$000608,$44F400,$000100,$447000,$000609,$60F400,$00060A,$44F400
		dc	$000000,$445800,$44F400,$000100,$445800,$44F400,$000200,$445800
		dc	$44F400,$000300,$445800,$44F400,$000400,$445800,$44F400,$FFFFFF
		dc	$446000,$60F400,$000610,$44F400,$000001,$445800,$445800,$445800
		dc	$445800,$445800,$240000,$446000,$60F400,$000616,$44F400,$FFFFFF
		dc	$445800,$445800,$445800,$445800,$445800,$446000,$60F400,$00061C
		dc	$44F400,$000400,$445800,$44F400,$FFFFFF,$445800,$44F400,$000500
		dc	$445800,$44F400,$FFFFFF,$445800,$44F400,$FFFFFF,$445800,$44F400
		dc	$FFFFFF,$445800,$60F400,$000622,$44F400,$000001,$445800,$240000
		dc	$445800,$44F400,$000001,$445800,$240000,$445800,$240000,$445800
		dc	$240000,$445800,$60F400,$000628,$44F400,$FFFFFF,$445800,$445800
		dc	$445800,$445800,$445800,$445800,$56F400,$000005,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000005,$60F400,$000100
		dc	$70F400,$000100,$390100,$0D0180,$56F400,$000005,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$56F400,$000005,$60F400,$000300
		dc	$70F400,$000100,$390300,$0D0180,$56F400,$000005,$60F400,$000400
		dc	$70F400,$000100,$390400,$0D0180,$62F000,$00062E,$024295,$023ADE
		dc	$200003,$052018,$60F413,$000600,$57F400,$000016,$0D1080,$00001C
		dc	$56F400,$000006,$60F400,$000400,$70F400,$000100,$390000,$0D0180
		dc	$56F400,$000006,$60F400,$000500,$70F400,$000100,$390100,$0D0180
		dc	$00000C,$60F400,$000000,$068092,$000005,$44D800,$46D0A1,$5658E9
		dc	$575800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0,$0465A0
		dc	$0466A0,$00F3B8,$44F400,$000016,$20004D,$0D104A,$000008,$300000
		dc	$56F400,$000000,$57F400,$FFFFFF,$00000C,$0D1080,$0000B8,$56F000
		dc	$000632,$200003,$05A406,$0D1080,$00015A,$0D1080,$000139,$050C03
		dc	$0D1080,$00015D,$0D1080,$00013A,$56F000,$000633,$014085,$05A417
		dc	$66F000,$00062F,$3E0300,$60EE00,$3E0400,$61EE00,$66F000,$000630
		dc	$3E0300,$70EE00,$3E0400,$71EE00,$46F400,$5A827A,$62F000,$000638
		dc	$06D210,$000005,$44E000,$44C9D0,$2000D3,$564800,$66F000,$00062F
		dc	$3E0000,$60EE00,$3E0200,$61EE00,$3E0100,$62EE00,$66F000,$000634
		dc	$3E0000,$64EE00,$3E0200,$65EE00,$66F000,$000630,$3E0000,$70EE00
		dc	$3E0200,$71EE00,$3E0100,$72EE00,$66F000,$000635,$3E0000,$74EE00
		dc	$76F400,$000002,$75EE00,$45F400,$5A827A,$66F000,$000638,$06D600
		dc	$00043D,$44CA00,$56C800,$57C9A3,$564CAB,$574D00,$61F400,$000639
		dc	$65F000,$00068D,$62F400,$000671,$66F000,$000634,$3E0000,$60EE00
		dc	$221400,$66F000,$000635,$70EE00,$231C00,$50F000,$000638,$00000A
		dc	$211E00,$72F400,$000004,$0BF080,$00056B,$61F400,$000649,$65F000
		dc	$00068D,$62F400,$000679,$66F000,$000634,$3E0200,$60EE00,$221400
		dc	$66F000,$000635,$70EE00,$231C00,$50F000,$000638,$00000A,$211E00
		dc	$72F400,$000004,$0BF080,$00056B,$61F400,$000659,$65F000,$00068E
		dc	$62F400,$000681,$66F000,$00062F,$3E0300,$60EE00,$221400,$66F000
		dc	$000630,$70EE00,$231C00,$50F000,$000638,$00000A,$211E00,$72F400
		dc	$000006,$0BF080,$00056B,$66F000,$000634,$3E0000,$60EE00,$3E0200
		dc	$61EE00,$66F000,$00062F,$3E0300,$62EE00,$66F000,$000635,$3E0000
		dc	$70EE00,$3E0200,$71EE00,$66F000,$000630,$3E0300,$72EE00,$45F400
		dc	$5A827A,$64F000,$000638,$06D400,$0004A1,$44CA00,$56E000,$57E1A3
		dc	$5648AF,$574900,$0D1080,$0000BE,$00000C,$205800,$44D800,$447000
		dc	$00062F,$44D800,$447000,$000630,$44D800,$447000,$000631,$57D800
		dc	$0C1890,$001027,$507000,$000632,$0C1890,$001019,$507000,$000633
		dc	$44D800,$447000,$000634,$44D800,$447000,$000635,$44D800,$447000
		dc	$000636,$57D800,$0C1890,$002024,$507000,$000637,$44D800,$447000
		dc	$000638,$00000C,$A2DD74,$3AE54D,$C51AB3,$5D228C,$800000,$CAE85F
		dc	$47C25A,$47C25A,$CAE85F,$7FFFFF,$855BE8,$756638,$756638,$855BE8
		dc	$7FFFFF,$EA1F92,$E2404B,$E2404B,$EA1F92,$7FFFFF,$812B1B,$7DAC85
		dc	$7ED594,$812A6C,$7ED594,$C48FCE,$1B99D0,$092E48,$092E5B,$092E6E
		dc	$CAE85F,$47C25A,$1768D5,$1768BD,$1768A5,$CAE85F,$47C25A,$1768D5
		dc	$1768BD,$1768A5,$823E22,$7B876D,$7B876D,$823E22,$7FFFFF,$B23B5E
		dc	$27F74F,$27F74F,$B23B5E,$7FFFFF,$A062D3,$3FC327,$C03CD9,$5F9D2D
		dc	$800000,$C37356,$4A2F0E,$4A2F0E,$C37356,$7FFFFF,$84EF9E,$763A35
		dc	$763A35,$84EF9E,$7FFFFF,$E648FE,$E4B78A,$E4B78A,$E648FE,$7FFFFF
		dc	$8112E7,$7DDC7F,$7EEDAC,$811254,$7EEDAC,$BFB2BF,$204D6F,$07ECAA
		dc	$07ECBB,$07ECCD,$C37356,$4A2F0E,$1448F5,$1448DE,$1448C8,$C37356
		dc	$4A2F0E,$1448F5,$1448DE,$1448C8,$82101A,$7BE2ED,$7BE2ED,$82101A
		dc	$7FFFFF,$AF2EFC,$2C7800,$2C7800,$AF2EFC,$7FFFFF,$61F413,$000639
		dc	$065490,$000002,$565900,$00000C,$60F400,$0004CA,$61F400,$000000
		dc	$066490,$000003,$07D884,$4C5900,$56F000,$000637,$240000,$60F400
		dc	$000032,$61F445,$000046,$05A405,$60F400,$000000,$61F400,$000014
		dc	$607000,$00068D,$617000,$00068E,$00000C,$56F400,$00000C,$57F400
		dc	$000000,$385400,$0BF080,$000180,$00000C,$56F400,$00000C,$57F400
		dc	$000001,$60F400,$000639,$385400,$390000,$0BF080,$000180,$00000C
		dc	$56F400,$00000C,$57F400,$000002,$60F400,$000639,$385400,$390000
		dc	$0BF080,$000180,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600
		dc	$06DA10,$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4
		dc	$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09
		dc	$444C4C,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2
		dc	$200010,$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000
		dc	$239800,$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\encds_passthru133.asm ===
;	File info
;	  File name: encds.asm
;	  Build date: 01/11/01, 16:55:53
;	Program info
;	  Program number: 1
;	  Revision number: 1.3
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 503 words
;	  Checksum: $E65DF2

		dc	$D01B40,$0001F7,$010103,$E65DF2,$56F400,$000005,$60F400,$000000
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000005,$60F400,$000200
		dc	$70F400,$000100,$390200,$0D0180,$60F400,$000000,$61F400,$000400
		dc	$060091,$000003,$44D800,$445900,$60F400,$000200,$61F400,$000500
		dc	$060091,$000003,$44D800,$445900,$56F400,$000006,$60F400,$000400
		dc	$70F400,$000100,$390000,$0D0180,$56F400,$000006,$60F400,$000500
		dc	$70F400,$000100,$390100,$0D0180,$00000C,$60F400,$000000,$068092
		dc	$000005,$44D800,$46D0A1,$5658E9,$575800,$00000C,$05F420,$FFFFFF
		dc	$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000016
		dc	$20004D,$0D104A,$000008,$300000,$56F400,$000000,$57F400,$FFFFFF
		dc	$00000C,$0D1080,$0000B8,$56F000,$000632,$200003,$05A406,$0D1080
		dc	$00015A,$0D1080,$000139,$050C03,$0D1080,$00015D,$0D1080,$00013A
		dc	$56F000,$000633,$014085,$05A417,$66F000,$00062F,$3E0300,$60EE00
		dc	$3E0400,$61EE00,$66F000,$000630,$3E0300,$70EE00,$3E0400,$71EE00
		dc	$46F400,$5A827A,$62F000,$000638,$06D210,$000005,$44E000,$44C9D0
		dc	$2000D3,$564800,$66F000,$00062F,$3E0000,$60EE00,$3E0200,$61EE00
		dc	$3E0100,$62EE00,$66F000,$000634,$3E0000,$64EE00,$3E0200,$65EE00
		dc	$66F000,$000630,$3E0000,$70EE00,$3E0200,$71EE00,$3E0100,$72EE00
		dc	$66F000,$000635,$3E0000,$74EE00,$76F400,$000002,$75EE00,$45F400
		dc	$5A827A,$66F000,$000638,$06D600,$0003A1,$44CA00,$56C800,$57C9A3
		dc	$564CAB,$574D00,$61F400,$000639,$65F000,$00068D,$62F400,$000671
		dc	$66F000,$000634,$3E0000,$60EE00,$221400,$66F000,$000635,$70EE00
		dc	$231C00,$50F000,$000638,$00000A,$211E00,$72F400,$000004,$0BF080
		dc	$0004CF,$61F400,$000649,$65F000,$00068D,$62F400,$000679,$66F000
		dc	$000634,$3E0200,$60EE00,$221400,$66F000,$000635,$70EE00,$231C00
		dc	$50F000,$000638,$00000A,$211E00,$72F400,$000004,$0BF080,$0004CF
		dc	$61F400,$000659,$65F000,$00068E,$62F400,$000681,$66F000,$00062F
		dc	$3E0300,$60EE00,$221400,$66F000,$000630,$70EE00,$231C00,$50F000
		dc	$000638,$00000A,$211E00,$72F400,$000006,$0BF080,$0004CF,$66F000
		dc	$000634,$3E0000,$60EE00,$3E0200,$61EE00,$66F000,$00062F,$3E0300
		dc	$62EE00,$66F000,$000635,$3E0000,$70EE00,$3E0200,$71EE00,$66F000
		dc	$000630,$3E0300,$72EE00,$45F400,$5A827A,$64F000,$000638,$06D400
		dc	$000405,$44CA00,$56E000,$57E1A3,$5648AF,$574900,$0D1080,$0000BE
		dc	$00000C,$205800,$44D800,$447000,$00062F,$44D800,$447000,$000630
		dc	$44D800,$447000,$000631,$57D800,$0C1890,$001027,$507000,$000632
		dc	$0C1890,$001019,$507000,$000633,$44D800,$447000,$000634,$44D800
		dc	$447000,$000635,$44D800,$447000,$000636,$57D800,$0C1890,$002024
		dc	$507000,$000637,$44D800,$447000,$000638,$00000C,$A2DD74,$3AE54D
		dc	$C51AB3,$5D228C,$800000,$CAE85F,$47C25A,$47C25A,$CAE85F,$7FFFFF
		dc	$855BE8,$756638,$756638,$855BE8,$7FFFFF,$EA1F92,$E2404B,$E2404B
		dc	$EA1F92,$7FFFFF,$812B1B,$7DAC85,$7ED594,$812A6C,$7ED594,$C48FCE
		dc	$1B99D0,$092E48,$092E5B,$092E6E,$CAE85F,$47C25A,$1768D5,$1768BD
		dc	$1768A5,$CAE85F,$47C25A,$1768D5,$1768BD,$1768A5,$823E22,$7B876D
		dc	$7B876D,$823E22,$7FFFFF,$B23B5E,$27F74F,$27F74F,$B23B5E,$7FFFFF
		dc	$A062D3,$3FC327,$C03CD9,$5F9D2D,$800000,$C37356,$4A2F0E,$4A2F0E
		dc	$C37356,$7FFFFF,$84EF9E,$763A35,$763A35,$84EF9E,$7FFFFF,$E648FE
		dc	$E4B78A,$E4B78A,$E648FE,$7FFFFF,$8112E7,$7DDC7F,$7EEDAC,$811254
		dc	$7EEDAC,$BFB2BF,$204D6F,$07ECAA,$07ECBB,$07ECCD,$C37356,$4A2F0E
		dc	$1448F5,$1448DE,$1448C8,$C37356,$4A2F0E,$1448F5,$1448DE,$1448C8
		dc	$82101A,$7BE2ED,$7BE2ED,$82101A,$7FFFFF,$AF2EFC,$2C7800,$2C7800
		dc	$AF2EFC,$7FFFFF,$61F413,$000639,$065490,$000002,$565900,$00000C
		dc	$60F400,$00042E,$61F400,$000000,$066490,$000003,$07D884,$4C5900
		dc	$56F000,$000637,$240000,$60F400,$000032,$61F445,$000046,$05A405
		dc	$60F400,$000000,$61F400,$000014,$607000,$00068D,$617000,$00068E
		dc	$00000C,$56F400,$00000C,$57F400,$000000,$385400,$0BF080,$000180
		dc	$00000C,$56F400,$00000C,$57F400,$000001,$60F400,$000639,$385400
		dc	$390000,$0BF080,$000180,$00000C,$56F400,$00000C,$57F400,$000002
		dc	$60F400,$000639,$385400,$390000,$0BF080,$000180,$00000C,$71F400
		dc	$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021,$57DA00,$51D200
		dc	$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409,$444C4C,$03F184
		dc	$555A00,$515A00,$22D400,$229000,$239800,$0460A4,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\mot_equ.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			mot_equ.inc
;												
;   Contents:		EQUATES for 56301 registers and ports
;					Reference: 56301 Specifications Revision 3.00
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/19/2000 8:49:01 PM		jmw
;	Copied.
;
;
; ******************************************************************

	page	132,55,0,0,0
	opt	mex

ioequ   ident   1,0

;------------------------------------------------------------------------
;
;       EQUATES for I/O Port Programming
;
;------------------------------------------------------------------------

;       Register Addresses

M_DATH   EQU     $FFFFCF         ; Port B (host) GPIO data Register
M_DIRH   EQU     $FFFFCE         ; Port B (host) GPIO direction Register

M_PCRC   EQU     $FFFFBF         ; Port C (ESSI0) Control Register
M_PRRC   EQU     $FFFFBE         ; Port C (ESSI0) Direction Register
M_PDRC   EQU     $FFFFBD         ; Port C (ESSI0) GPIO Data Register

M_PCRD   EQU     $FFFFAF         ; Port D (ESSI1) Control register
M_PRRD   EQU     $FFFFAE         ; Port D (ESSI1) Direction Data Register
M_PDRD   EQU     $FFFFAD         ; Port D (ESSI1) GPIO Data Register

M_PCRE   EQU     $FFFF9F         ; Port E (SCI) Control register
M_PRRE   EQU     $FFFF9E         ; Port E (SCI) Direction Register
M_PDRE   EQU     $FFFF9D         ; Port E (SCI) Data Register

M_OGDB   EQU     $FFFFFC         ; OnCE GDB Register 

;------------------------------------------------------------------------
;
;       EQUATES for Host Interface
;
;------------------------------------------------------------------------

;       Register Addresses
 
M_DTXS   EQU     $FFFFCD         ; DSP SLAVE TRANSMIT DATA FIFO (DTXS)
M_DTXM   EQU     $FFFFCC         ; DSP MASTER TRANSMIT DATA FIFO (DTXM)
M_DRXR   EQU     $FFFFCB         ; DSP RECEIVE DATA FIFO (DRXR)
M_DPSR   EQU     $FFFFCA         ; DSP PCI STATUS REGISTER (DPSR)
M_DSR    EQU     $FFFFC9         ; DSP STATUS REGISTER (DSR)
M_DPAR   EQU     $FFFFC8         ; DSP PCI ADDRESS REGISTER (DPAR)
M_DPMC   EQU     $FFFFC7         ; DSP PCI MASTER CONTROL REGISTER (DPMC)
M_DPCR   EQU     $FFFFC6         ; DSP PCI CONTROL REGISTER (DPCR)
M_DCTR   EQU     $FFFFC5         ; DSP CONTROL REGISTER (DCTR)    
 
;       Host Control Register Bit Flags

M_HCIE   EQU     0               ; Host Command Interrupt Enable
M_STIE   EQU     1               ; Slave Transmit Interrupt Enable
M_SRIE   EQU     2               ; Slave Receive Interrupt Enable
M_HF35   EQU     $38             ; Host Flags 5-3 Mask
M_HF3    EQU     3               ; Host Flag 3
M_HF4    EQU     4               ; Host Flag 4
M_HF5    EQU     5               ; Host Flag 5
M_HINT   EQU     6               ; Host Interrupt A
M_HDSM   EQU     13              ; Host Data Strobe Mode
M_HRWP   EQU     14              ; Host RD/WR Polarity
M_HTAP   EQU     15              ; Host Transfer Acknowledge Polarity
M_HDRP   EQU     16              ; Host Dma Request Polarity
M_HRSP   EQU     17              ; Host Reset Polarity
M_HIRP   EQU     18              ; Host Interrupt  Request Polarity
M_HIRC   EQU     19              ; Host Interupt Request Control
M_HM0    EQU     20              ; Host Interface Mode
M_HM1    EQU     21              ; Host Interface Mode
M_HM2    EQU     22              ; Host Interface Mode
M_HM     EQU     $700000         ; Host Interface Mode Mask

;       Host PCI Control Register Bit Flags

M_PMTIE  EQU     1               ; PCI Master Transmit         Interrupt Enable
M_PMRIE  EQU     2               ; PCI Master Receive          Interrupt Enable
M_PMAIE  EQU     4               ; PCI Master Address          Interrupt Enable
M_PPEIE  EQU     5               ; PCI Parity Error            Interrupt Enable
M_PTAIE  EQU     7               ; PCI Transaction Abort       Interrupt Enable
M_PTTIE  EQU     9               ; PCI Transaction Termination Interrupt Enable
M_PTCIE  EQU     12              ; PCI Transfer Complete       Interrupt Enable
M_CLRT   EQU     14              ; Clear Transmitter
M_MTT    EQU     15              ; Master Transfer Terminate
M_SERF   EQU     16              ; HSERR~ Force
M_MACE   EQU     18              ; Master Access Counter Enable
M_MWSD   EQU     19              ; Master Wait States Disable
M_RBLE   EQU     20              ; Receive Buffer Lock Enable
M_IAE    EQU     21              ; Insert Address Enable 

;       Host PCI Master Control Register Bit Flags

M_ARH    EQU     $00ffff         ; DSP PCI Transaction Address (High)
M_BL     EQU     $3f0000         ; PCI Data Burst Length
M_FC     EQU     $c00000         ; Data Transfer Format Control

;       Host PCI Address Register Bit Flags

M_ARL    EQU     $00ffff         ; DSP PCI Transaction Address (Low)
M_C      EQU     $0f0000         ; PCI Bus Command
M_BE     EQU     $f00000         ; PCI Byte Enables

;       DSP Status Register Bit Flags
 
M_HCP    EQU     0               ; Host Command pending
M_STRQ   EQU     1               ; Slave Transmit Data Request
M_SRRQ   EQU     2               ; Slave Receive Data Request
M_HF02   EQU     $38             ; Host Flag 0-2 Mask
M_HF0    EQU     3               ; Host Flag 0
M_HF1    EQU     4               ; Host Flag 1
M_HF2    EQU     5               ; Host Flag 2

;       DSP PCI Status Register Bit Flags

M_MWS    EQU    0               ; PCI Master Wait States
M_MTRQ   EQU    1               ; PCI Master Transmit Data Request
M_MRRQ   EQU    2               ; PCI Master Receive Data Request
M_MARQ   EQU    4               ; PCI Master Address Request
M_APER   EQU    5               ; PCI Address Parity Error
M_DPER   EQU    6               ; PCI Data Parity Error
M_MAB    EQU    7               ; PCI Master Abort
M_TAB    EQU    8               ; PCI Target Abort
M_TDIS   EQU    9               ; PCI Target Disconnect
M_TRTY   EQU    10              ; PCI Target Retry
M_TO     EQU    11              ; PCI Time Out Termination
M_RDC    EQU    $3F0000         ; Remaining Data Count Mask (RDC5-RDC0)
M_RDC0   EQU    16              ; Remaining Data Count  0
M_RDC1   EQU    17              ; Remaining Data Count  1
M_RDC2   EQU    18              ; Remaining Data Count  2
M_RDC3   EQU    19              ; Remaining Data Count  3
M_RDC4   EQU    20              ; Remaining Data Count  4
M_RDC5   EQU    21              ; Remaining Data Count  5
M_HACT   EQU    23              ; Hi32 Active


;------------------------------------------------------------------------
;
;       EQUATES for Serial Communications Interface (SCI)
;
;------------------------------------------------------------------------

;       Register Addresses

M_STXH   EQU     $FFFF97         ; SCI Transmit Data Register (high)
M_STXM   EQU     $FFFF96         ; SCI Transmit Data Register (middle)
M_STXL   EQU     $FFFF95         ; SCI Transmit Data Register (low)
M_SRXH   EQU     $FFFF9A         ; SCI Receive Data Register (high)
M_SRXM   EQU     $FFFF99         ; SCI Receive Data Register (middle)
M_SRXL   EQU     $FFFF98         ; SCI Receive Data Register (low)
M_STXA   EQU     $FFFF94         ; SCI Transmit Address Register
M_SCR    EQU     $FFFF9C         ; SCI Control Register
M_SSR    EQU     $FFFF93         ; SCI Status Register
M_SCCR   EQU     $FFFF9B         ; SCI Clock Control Register

;       SCI Control Register Bit Flags

M_WDS    EQU     $7              ; Word Select Mask (WDS0-WDS3)
M_WDS0   EQU     0               ; Word Select 0
M_WDS1   EQU     1               ; Word Select 1
M_WDS2   EQU     2               ; Word Select 2
M_SSFTD  EQU     3               ; SCI Shift Direction 
M_SBK    EQU     4               ; Send Break
M_WAKE   EQU     5               ; Wakeup Mode Select
M_RWU    EQU     6               ; Receiver Wakeup Enable
M_WOMS   EQU     7               ; Wired-OR Mode Select
M_SCRE   EQU     8               ; SCI Receiver Enable
M_SCTE   EQU     9               ; SCI Transmitter Enable
M_ILIE   EQU     10              ; Idle Line Interrupt Enable
M_SCRIE  EQU     11              ; SCI Receive Interrupt Enable
M_SCTIE  EQU     12              ; SCI Transmit Interrupt Enable
M_TMIE   EQU     13              ; Timer Interrupt Enable
M_TIR    EQU     14              ; Timer Interrupt Rate
M_SCKP   EQU     15              ; SCI Clock Polarity
M_REIE   EQU     16              ; SCI Error Interrupt Enable (REIE)

;       SCI Status Register Bit Flags

M_TRNE   EQU     0               ; Transmitter Empty
M_TDRE   EQU     1               ; Transmit Data Register Empty
M_RDRF   EQU     2               ; Receive Data Register Full
M_IDLE   EQU     3               ; Idle Line Flag
M_OR     EQU     4               ; Overrun Error Flag 
M_PE     EQU     5               ; Parity Error
M_FE     EQU     6               ; Framing Error Flag
M_R8     EQU     7               ; Received Bit 8 (R8) Address

;       SCI Clock Control Register 

M_CD     EQU     $FFF            ; Clock Divider Mask (CD0-CD11)
M_COD    EQU     12              ; Clock Out Divider
M_SCP    EQU     13              ; Clock Prescaler
M_RCM    EQU     14              ; Receive Clock Mode Source Bit
M_TCM    EQU     15              ; Transmit Clock Source Bit

;------------------------------------------------------------------------
;
;       EQUATES for Enhanced Synchronous Serial Interface (ESSI)
;
;------------------------------------------------------------------------

;
;       Register Addresses Of ESSI0 
M_TX00   EQU     $FFFFBC         ; ESSI0 Transmit Data Register 0
M_TX01   EQU     $FFFFBB         ; ESSIO Transmit Data Register 1
M_TX02   EQU     $FFFFBA         ; ESSIO Transmit Data Register 2
M_TSR0   EQU     $FFFFB9         ; ESSI0 Time Slot Register
M_RX0    EQU     $FFFFB8         ; ESSI0 Receive Data Register
M_SSISR0 EQU     $FFFFB7         ; ESSI0 Status Register
M_CRB0   EQU     $FFFFB6         ; ESSI0 Control Register B
M_CRA0   EQU     $FFFFB5         ; ESSI0 Control Register A
M_TSMA0  EQU     $FFFFB4         ; ESSI0 Transmit Slot Mask Register A
M_TSMB0  EQU     $FFFFB3         ; ESSI0 Transmit Slot Mask Register B
M_RSMA0  EQU     $FFFFB2         ; ESSI0 Receive Slot Mask Register A
M_RSMB0  EQU     $FFFFB1         ; ESSI0 Receive Slot Mask Register B

;       Register Addresses Of ESSI1                                        
M_TX10   EQU     $FFFFAC         ; ESSI1 Transmit Data Register 0
M_TX11   EQU     $FFFFAB         ; ESSI1 Transmit Data Register 1
M_TX12   EQU     $FFFFAA         ; ESSI1 Transmit Data Register 2
M_TSR1   EQU     $FFFFA9         ; ESSI1 Time Slot Register
M_RX1    EQU     $FFFFA8         ; ESSI1 Receive Data Register
M_SSISR1 EQU     $FFFFA7         ; ESSI1 Status Register
M_CRB1   EQU     $FFFFA6         ; ESSI1 Control Register B
M_CRA1   EQU     $FFFFA5         ; ESSI1 Control Register A
M_TSMA1  EQU     $FFFFA4         ; ESSI1 Transmit Slot Mask Register A
M_TSMB1  EQU     $FFFFA3         ; ESSI1 Transmit Slot Mask Register B
M_RSMA1  EQU     $FFFFA2         ; ESSI1 Receive Slot Mask Register A
M_RSMB1  EQU     $FFFFA1         ; ESSI1 Receive Slot Mask Register B

;       ESSI Control Register A Bit Flags

M_PM     EQU     $FF             ; Prescale Modulus Select Mask (PM0-PM7)              
M_PSR    EQU     11              ; Prescaler Range       
M_DC     EQU     $1F000          ; Frame Rate Divider Control Mask (DC0-DC7)
M_ALC    EQU     18	         ; Alignment Control (ALC)
M_WL     EQU     $380000         ; Word Length Control Mask (WL0-WL7)
M_SSC1   EQU     22	         ; Select SC1 as TR #0 drive enable (SSC1)

;       ESSI Control Register B Bit Flags                                   

M_OF     EQU     $3              ; Serial Output Flag Mask
M_OF0    EQU     0               ; Serial Output Flag 0                     
M_OF1    EQU     1               ; Serial Output Flag 1                     
M_SCD    EQU     $1C             ; Serial Control Direction Mask            
M_SCD0   EQU     2               ; Serial Control 0 Direction                
M_SCD1   EQU     3               ; Serial Control 1 Direction               
M_SCD2   EQU     4               ; Serial Control 2 Direction               
M_SCKD   EQU     5               ; Clock Source Direction
M_SHFD   EQU     6               ; Shift Direction                          
M_FSL    EQU     $180            ; Frame Sync Length Mask (FSL0-FSL1)
M_FSL0   EQU     7               ; Frame Sync Length 0
M_FSL1   EQU     8               ; Frame Sync Length 1
M_FSR    EQU     9               ; Frame Sync Relative Timing
M_FSP    EQU     10              ; Frame Sync Polarity
M_CKP    EQU     11              ; Clock Polarity                           
M_SYN    EQU     12              ; Sync/Async Control                       
M_MOD    EQU     13              ; ESSI Mode Select
M_SSTE   EQU     $1C000          ; ESSI Transmit enable Mask                  
M_SSTE2  EQU     14              ; ESSI Transmit #2 Enable                   
M_SSTE1  EQU     15              ; ESSI Transmit #1 Enable                    
M_SSTE0  EQU     16              ; ESSI Transmit #0 Enable                    
M_SSRE   EQU     17              ; ESSI Receive Enable                       
M_SSTIE  EQU     18              ; ESSI Transmit Interrupt Enable            
M_SSRIE  EQU     19              ; ESSI Receive Interrupt Enable              
M_STLIE  EQU     20              ; ESSI Transmit Last Slot Interrupt Enable 
M_SRLIE  EQU     21              ; ESSI Receive Last Slot Interrupt Enable 
M_STEIE  EQU     22              ; ESSI Transmit Error Interrupt Enable 
M_SREIE  EQU     23              ; ESSI Receive Error Interrupt Enable              

;       ESSI Status Register Bit Flags                                       

M_IF     EQU     $3              ; Serial Input Flag Mask           
M_IF0    EQU     0               ; Serial Input Flag 0                      
M_IF1    EQU     1               ; Serial Input Flag 1                      
M_TFS    EQU     2               ; Transmit Frame Sync Flag                 
M_RFS    EQU     3               ; Receive Frame Sync Flag                  
M_TUE    EQU     4               ; Transmitter Underrun Error FLag          
M_ROE    EQU     5               ; Receiver Overrun Error Flag              
M_TDE    EQU     6               ; Transmit Data Register Empty             
M_RDF    EQU     7               ; Receive Data Register Full

;       ESSI Transmit Slot Mask Register A

M_SSTSA  EQU     $FFFF           ; ESSI Transmit Slot Bits Mask A (TS0-TS15)

;       ESSI Transmit Slot Mask Register B

M_SSTSB  EQU     $FFFF           ; ESSI Transmit Slot Bits Mask B (TS16-TS31)

;       ESSI Receive Slot Mask Register A

M_SSRSA  EQU     $FFFF           ; ESSI Receive Slot Bits Mask A (RS0-RS15)
 
;       ESSI Receive Slot Mask Register B

M_SSRSB  EQU     $FFFF           ; ESSI Receive Slot Bits Mask B (RS16-RS31)

              

;------------------------------------------------------------------------
;
;       EQUATES for Exception Processing                                    
;
;------------------------------------------------------------------------


;       Register Addresses

M_IPRC   EQU     $FFFFFF         ; Interrupt Priority Register Core
M_IPRP   EQU     $FFFFFE         ; Interrupt Priority Register Peripheral

;       Interrupt Priority Register Core (IPRC) 

M_IAL    EQU     $7              ; IRQA Mode Mask
M_IAL0   EQU     0               ; IRQA Mode Interrupt Priority Level (low)
M_IAL1   EQU     1               ; IRQA Mode Interrupt Priority Level (high)
M_IAL2   EQU     2               ; IRQA Mode Trigger Mode
M_IBL    EQU     $38             ; IRQB Mode Mask
M_IBL0   EQU     3               ; IRQB Mode Interrupt Priority Level (low)
M_IBL1   EQU     4               ; IRQB Mode Interrupt Priority Level (high)
M_IBL2   EQU     5               ; IRQB Mode Trigger Mode
M_ICL    EQU     $1C0            ; IRQC Mode Mask
M_ICL0   EQU     6               ; IRQC Mode Interrupt Priority Level (low)
M_ICL1   EQU     7               ; IRQC Mode Interrupt Priority Level (high)
M_ICL2   EQU     8               ; IRQC Mode Trigger Mode
M_IDL    EQU     $E00            ; IRQD Mode Mask
M_IDL0   EQU     9               ; IRQD Mode Interrupt Priority Level (low)
M_IDL1   EQU     10              ; IRQD Mode Interrupt Priority Level (high)
M_IDL2   EQU     11              ; IRQD Mode Trigger Mode
M_D0L    EQU     $3000           ; DMA0 Interrupt priority Level Mask
M_D0L0   EQU     12              ; DMA0 Interrupt Priority Level (low)
M_D0L1   EQU     13              ; DMA0 Interrupt Priority Level (high)
M_D1L    EQU     $C000           ; DMA1 Interrupt Priority Level Mask
M_D1L0   EQU     14              ; DMA1 Interrupt Priority Level (low)
M_D1L1   EQU     15              ; DMA1 Interrupt Priority Level (high)
M_D2L    EQU     $30000          ; DMA2 Interrupt priority Level Mask
M_D2L0   EQU     16              ; DMA2 Interrupt Priority Level (low)
M_D2L1   EQU     17              ; DMA2 Interrupt Priority Level (high)
M_D3L    EQU     $C0000          ; DMA3 Interrupt Priority Level Mask
M_D3L0   EQU     18              ; DMA3 Interrupt Priority Level (low)
M_D3L1   EQU     19              ; DMA3 Interrupt Priority Level (high)
M_D4L    EQU     $300000         ; DMA4 Interrupt priority Level Mask
M_D4L0   EQU     20              ; DMA4 Interrupt Priority Level (low)
M_D4L1   EQU     21              ; DMA4 Interrupt Priority Level (high)
M_D5L    EQU     $C00000         ; DMA5 Interrupt priority Level Mask
M_D5L0   EQU     22              ; DMA5 Interrupt Priority Level (low)
M_D5L1   EQU     23              ; DMA5 Interrupt Priority Level (high)


;       Interrupt Priority Register Peripheral (IPRP)

M_HPL    EQU     $3              ; Host Interrupt Priority Level Mask
M_HPL0   EQU     0               ; Host Interrupt Priority Level (low)
M_HPL1   EQU     1               ; Host Interrupt Priority Level (high)
M_S0L    EQU     $C              ; ESSI0 Interrupt Priority Level Mask
M_S0L0   EQU     2               ; ESSI0 Interrupt Priority Level (low)
M_S0L1   EQU     3               ; ESSI0 Interrupt Priority Level (high)
M_S1L    EQU     $30             ; ESSI1 Interrupt Priority Level Mask
M_S1L0   EQU     4               ; ESSI1 Interrupt Priority Level (low)
M_S1L1   EQU     5               ; ESSI1 Interrupt Priority Level (high)
M_SCL    EQU     $C0             ; SCI  Interrupt Priority Level  Mask       
M_SCL0   EQU     6               ; SCI  Interrupt Priority Level  (low)
M_SCL1   EQU     7               ; SCI  Interrupt Priority Level  (high)
M_T0L    EQU     $300            ; TIMER Interrupt Priority Level Mask
M_T0L0   EQU     8               ; TIMER Interrupt Priority Level (low)
M_T0L1   EQU     9               ; TIMER Interrupt Priority Level (high)


;------------------------------------------------------------------------
;
;       EQUATES for TIMER 
;
;------------------------------------------------------------------------

;       Register Addresses Of TIMER0

M_TCSR0  EQU     $FFFF8F         ; TIMER0 Control/Status Register            
M_TLR0	 EQU	 $FFFF8E	 ; TIMER0 Load Reg   
M_TCPR0  EQU     $FFFF8D         ; TIMER0 Compare Register
M_TCR0	 EQU	 $FFFF8C 	 ; TIMER0 Count Register

;       Register Addresses Of TIMER1

M_TCSR1  EQU     $FFFF8B         ; TIMER1 Control/Status Register            
M_TLR1	 EQU	 $FFFF8A	 ; TIMER1 Load Reg   
M_TCPR1  EQU     $FFFF89         ; TIMER1 Compare Register
M_TCR1	 EQU	 $FFFF88	 ; TIMER1 Count Register


;       Register Addresses Of TIMER2

M_TCSR2  EQU     $FFFF87         ; TIMER2 Control/Status Register            
M_TLR2	 EQU	 $FFFF86	 ; TIMER2 Load Reg   
M_TCPR2  EQU     $FFFF85         ; TIMER2 Compare Register
M_TCR2	 EQU	 $FFFF84	 ; TIMER2 Count Register
M_TPLR	 EQU	 $FFFF83	 ; TIMER Prescaler Load Register
M_TPCR	 EQU	 $FFFF82	 ; TIMER Prescalar Count Register


;       Timer Control/Status Register Bit Flags                                        

M_TE     EQU     0               ; Timer Enable 
M_TOIE   EQU     1               ; Timer Overflow Interrupt Enable
M_TCIE   EQU     2               ; Timer Compare Interrupt Enable
M_TC     EQU     $F0             ; Timer Control Mask (TC0-TC3)
M_INV    EQU     8               ; Inverter Bit
M_TRM    EQU     9               ; Timer Restart Mode 
M_DIR    EQU     11              ; Direction Bit
M_DI     EQU     12              ; Data Input
M_DO     EQU     13              ; Data Output
M_PCE	 EQU	 15		 ; Prescaled Clock Enable
M_TOF    EQU     20              ; Timer Overflow Flag
M_TCF    EQU     21              ; Timer Compare Flag 

;       Timer Prescaler Register Bit Flags                                        

M_PS	EQU	 $600000 	 ; Prescaler Source Mask
M_PS0	EQU	 21
M_PS1	EQU	 22

;	Timer Control Bits
M_TC0    EQU     4               ; Timer Control 0
M_TC1    EQU     5               ; Timer Control 1
M_TC2    EQU     6               ; Timer Control 2
M_TC3    EQU     7               ; Timer Control 3


;------------------------------------------------------------------------
;
;       EQUATES for Direct Memory Access (DMA)                                 
;
;------------------------------------------------------------------------

;       Register Addresses Of DMA
M_DSTR	 EQU	$FFFFF4		; DMA Status Register
M_DOR0   EQU     $FFFFF3         ; DMA Offset Register 0
M_DOR1   EQU     $FFFFF2         ; DMA Offset Register 1
M_DOR2   EQU     $FFFFF1         ; DMA Offset Register 2
M_DOR3   EQU     $FFFFF0         ; DMA Offset Register 3


;       Register Addresses Of DMA0

M_DSR0   EQU     $FFFFEF         ; DMA0 Source Address Register
M_DDR0   EQU     $FFFFEE         ; DMA0 Destination Address Register 
M_DCO0   EQU     $FFFFED         ; DMA0 Counter
M_DCR0   EQU     $FFFFEC         ; DMA0 Control Register 

;       Register Addresses Of DMA1

M_DSR1   EQU     $FFFFEB         ; DMA1 Source Address Register
M_DDR1   EQU     $FFFFEA         ; DMA1 Destination Address Register 
M_DCO1   EQU     $FFFFE9         ; DMA1 Counter
M_DCR1   EQU     $FFFFE8         ; DMA1 Control Register

;       Register Addresses Of DMA2

M_DSR2   EQU     $FFFFE7         ; DMA2 Source Address Register
M_DDR2   EQU     $FFFFE6         ; DMA2 Destination Address Register 
M_DCO2   EQU     $FFFFE5         ; DMA2 Counter
M_DCR2   EQU     $FFFFE4         ; DMA2 Control Register
 
;       Register Addresses Of DMA4

M_DSR3   EQU     $FFFFE3         ; DMA3 Source Address Register
M_DDR3   EQU     $FFFFE2         ; DMA3 Destination Address Register 
M_DCO3   EQU     $FFFFE1         ; DMA3 Counter
M_DCR3   EQU     $FFFFE0         ; DMA3 Control Register

;       Register Addresses Of DMA4


M_DSR4   EQU     $FFFFDF         ; DMA4 Source Address Register
M_DDR4   EQU     $FFFFDE         ; DMA4 Destination Address Register 
M_DCO4   EQU     $FFFFDD         ; DMA4 Counter
M_DCR4   EQU     $FFFFDC         ; DMA4 Control Register 

;       Register Addresses Of DMA5

M_DSR5   EQU     $FFFFDB         ; DMA5 Source Address Register
M_DDR5   EQU     $FFFFDA         ; DMA5 Destination Address Register 
M_DCO5   EQU     $FFFFD9         ; DMA5 Counter
M_DCR5   EQU     $FFFFD8         ; DMA5 Control Register

;	DMA Control Register

M_DSS	 EQU	$3		; DMA Source Space Mask (DSS0-Dss1)
M_DSS0	 EQU	0		; DMA Source Memory space 0
M_DSS1	 EQU	1		; DMA Source Memory space 1	
M_DDS	 EQU	$C		; DMA Destination Space Mask (DDS-DDS1)
M_DDS0	 EQU	2		; DMA Destination Memory Space 0
M_DDS1	 EQU	3		; DMA Destination Memory Space 1
M_DAM	 EQU	$3f0		; DMA Address Mode Mask (DAM5-DAM0)
M_DAM0 	 EQU	4		; DMA Address Mode 0
M_DAM1 	 EQU	5		; DMA Address Mode 1
M_DAM2 	 EQU	6		; DMA Address Mode 2
M_DAM3 	 EQU	7		; DMA Address Mode 3
M_DAM4 	 EQU	8		; DMA Address Mode 4
M_DAM5 	 EQU	9		; DMA Address Mode 5
M_D3D	 EQU 	10		; DMA Three Dimensional Mode
M_DRS	 EQU	$F800		; DMA Request Source Mask (DRS0-DRS4)
M_DCON	 EQU	16		; DMA Continuous Mode
M_DPR	 EQU	$60000		; DMA Channel Priority
M_DPR0	 EQU	17		; DMA Channel Priority Level (low)
M_DPR1	 EQU	18		; DMA Channel Priority Level (high)
M_DTM	 EQU	$380000		; DMA Transfer Mode Mask (DTM2-DTM0)
M_DTM0	 EQU	19		; DMA Transfer Mode 0
M_DTM1	 EQU	20		; DMA Transfer Mode 1
M_DTM2	 EQU	21		; DMA Transfer Mode 2
M_DIE	 EQU	22		; DMA Interrupt Enable bit
M_DE	 EQU	23		; DMA Channel Enable bit 

;       DMA Status Register

M_DTD	 EQU	$3F		; Channel Transfer Done Status MASK (DTD0-DTD5)
M_DTD0   EQU     0               ; DMA Channel Transfer Done Status 0
M_DTD1   EQU     1               ; DMA Channel Transfer Done Status 1
M_DTD2   EQU     2               ; DMA Channel Transfer Done Status 2
M_DTD3   EQU     3               ; DMA Channel Transfer Done Status 3
M_DTD4   EQU     4               ; DMA Channel Transfer Done Status 4
M_DTD5   EQU     5               ; DMA Channel Transfer Done Status 5
M_DACT	 EQU	 8		 ; DMA Active State
M_DCH	 EQU	 $E00		 ; DMA Active Channel Mask (DCH0-DCH2)
M_DCH0	 EQU	 9		 ; DMA Active Channel 0
M_DCH1	 EQU	 10		 ; DMA Active Channel 1
M_DCH2	 EQU	 11	 	 ; DMA Active Channel 2


;------------------------------------------------------------------------
;
;       EQUATES for Phase Locked Loop (PLL) 
;
;------------------------------------------------------------------------

;       Register Addresses Of PLL

M_PCTL   EQU     $FFFFFD         ; PLL Control Register

;       PLL Control Register

M_MF     EQU     $FFF            ; Multiplication Factor Bits Mask (MF0-MF11)
M_DF     EQU     $7000           ; Division Factor Bits Mask (DF0-DF2)
M_XTLR   EQU     15              ; XTAL Range select bit
M_XTLD   EQU     16              ; XTAL Disable Bit
M_PSTP   EQU     17              ; STOP Processing State Bit 
M_PEN    EQU     18              ; PLL Enable Bit
M_PCOD   EQU     19              ; PLL Clock Output Disable Bit
M_PD	 EQU	$F00000		; PreDivider Factor Bits Mask (PD0-PD3)


;------------------------------------------------------------------------
;
;       EQUATES for BIU 
;
;------------------------------------------------------------------------

;       Register Addresses Of BIU


M_BCR    EQU     $FFFFFB         ; Bus Control Register
M_DCR    EQU     $FFFFFA         ; DRAM Control Register
M_AAR0   EQU     $FFFFF9         ; Address Attribute Register 0 
M_AAR1   EQU     $FFFFF8         ; Address Attribute Register 1 
M_AAR2   EQU     $FFFFF7         ; Address Attribute Register 2 
M_AAR3   EQU     $FFFFF6         ; Address Attribute Register 3 
M_IDR	 EQU	$FFFFF5		; ID Register

;       Bus Control Register

M_BA0W   EQU     $1F             ; Area 0 Wait Control Mask (BA0W0-BA0W4)
M_BA1W   EQU     $3E0            ; Area 1 Wait Control Mask (BA1W0-BA14)
M_BA2W   EQU     $1C00           ; Area 2 Wait Control Mask (BA2W0-BA2W2)
M_BA3W   EQU     $E000           ; Area 3 Wait Control Mask (BA3W0-BA3W3)
M_BDFW   EQU     $1F0000         ; Default Area Wait Control Mask (BDFW0-BDFW4)
M_BBS    EQU     21              ; Bus State
M_BLH    EQU     22              ; Bus Lock Hold
M_BRH    EQU     23              ; Bus Request Hold

;       DRAM Control Register

M_BCW    EQU     $3              ; In Page Wait States Bits Mask (BCW0-BCW1)
M_BRW    EQU     $C              ; Out Of Page Wait States Bits Mask (BRW0-BRW1)
M_BPS    EQU     $300            ; DRAM Page Size Bits Mask (BPS0-BPS1)
M_BPLE   EQU     11              ; Page Logic Enable
M_BME    EQU     12              ; Mastership Enable
M_BRE    EQU     13              ; Refresh Enable
M_BSTR   EQU     14              ; Software Triggered Refresh
M_BRF    EQU     $7F8000         ; Refresh Rate Bits Mask (BRF0-BRF7)
M_BRP    EQU     23              ; Refresh prescaler

;       Address Attribute Registers

M_BAT    EQU     $3              ; External Access Type and Pin Definition Bits Mask (BAT0-BAT1)
M_BAAP   EQU     2               ; Address Attribute Pin Polarity
M_BPEN   EQU     3               ; Program Space Enable
M_BXEN   EQU     4               ; X Data Space Enable
M_BYEN   EQU     5               ; Y Data Space Enable
M_BAM    EQU     6               ; Address Muxing
M_BPAC 	 EQU	 7		 ; Packing Enable
M_BNC    EQU     $F00            ; Number of Address Bits to Compare Mask (BNC0-BNC3)
M_BAC    EQU     $FFF000         ; Address to Compare Bits Mask (BAC0-BAC11)

;       control and status bits in SR

M_CP	EQU	$c00000          ; mask for CORE-DMA priority bits in SR
M_CA    equ     0                ; Carry
M_V     equ     1                ; Overflow      
M_Z     equ     2                ; Zero
M_N     equ     3                ; Negative      
M_U     equ     4                ; Unnormalized
M_E     equ     5                ; Extension     
M_L     equ     6                ; Limit
M_S     equ     7                ; Scaling Bit   
M_I0    equ     8                ; Interupt Mask Bit 0
M_I1    equ     9                ; Interupt Mask Bit 1
M_S0    equ     10               ; Scaling Mode Bit 0
M_S1    equ     11               ; Scaling Mode Bit 1
M_SC    equ     13               ; Sixteen_Bit Compatibility
M_DM    equ     14               ; Double Precision Multiply
M_LF    equ     15               ; DO-Loop Flag
M_FV    equ     16               ; DO-Forever Flag
M_SA    equ     17               ; Sixteen-Bit Arithmetic
M_CE    equ     19               ; Instruction Cache Enable
M_SM    equ     20               ; Arithmetic Saturation
M_RM    equ     21               ; Rounding Mode
M_CP0	EQU	22               ; bit 0 of priority bits in SR
M_CP1   EQU     23               ; bit 1 of priority bits in SR

;       control and status bits in OMR
M_CDP	EQU	$300             ; mask for CORE-DMA priority bits in OMR
M_MA    equ     0                ; Operating Mode A
M_MB   equ      1                ; Operating Mode B
M_MC    equ     2                ; Operating Mode C
M_MD    equ     3                ; Operating Mode D
M_EBD   equ     4                ; External Bus Disable bit in OMR
M_SD    equ     6                ; Stop Delay  
M_CDP0	EQU	8                ; bit 0 of priority bits in OMR
M_CDP1	EQU	9                ; bit 1 of priority bits in OMR
M_BEN   EQU     10               ; Burst Enable 
M_TAS   EQU     11               ; TA Synchronize Select
M_BRT   EQU     12               ; Bus Release Timing 
M_XYS   equ     16               ; Stack Extension space select bit in OMR.
M_EUN   equ     17               ; Extensed stack UNderflow flag in OMR.
M_EOV   equ     18               ; Extended stack OVerflow flag in OMR.
M_WRP   equ     19               ; Extended WRaP flag in OMR.
M_SEN   equ     20               ; Stack Extension Enable bit in OMR.




;*********************************************************************************
;
;     EQUATES for 56301 interrupts
;     Reference: 56301 Specifications Revision 3.00 
;
;     Last update: August   16 1994
;
;*********************************************************************************

	page	132,55,0,0,0
	opt	mex

intequ  ident   1,0

	if	@DEF(I_VEC)
	;leave user definition as is.
	else
I_VEC	equ	$0
	endif

;------------------------------------------------------------------------
; Non-Maskable interrupts
;------------------------------------------------------------------------
I_RESET  EQU  I_VEC+$00   ; Hardware RESET
I_STACK  EQU  I_VEC+$02   ; Stack Error
I_ILL    EQU  I_VEC+$04   ; Illegal Instruction
I_DBG    EQU  I_VEC+$06   ; Debug Request      
I_TRAP   EQU  I_VEC+$08   ; Trap
I_NMI    EQU  I_VEC+$0A   ; Non Maskable Interrupt

;------------------------------------------------------------------------
; Interrupt Request Pins
;------------------------------------------------------------------------
I_IRQA   EQU  I_VEC+$10   ; IRQA
I_IRQB   EQU  I_VEC+$12   ; IRQB
I_IRQC   EQU  I_VEC+$14   ; IRQC
I_IRQD   EQU  I_VEC+$16   ; IRQD

;------------------------------------------------------------------------
; DMA Interrupts
;------------------------------------------------------------------------
I_DMA0   EQU  I_VEC+$18   ; DMA Channel 0
I_DMA1   EQU  I_VEC+$1A   ; DMA Channel 1
I_DMA2   EQU  I_VEC+$1C   ; DMA Channel 2
I_DMA3   EQU  I_VEC+$1E   ; DMA Channel 3
I_DMA4   EQU  I_VEC+$20   ; DMA Channel 4
I_DMA5   EQU  I_VEC+$22   ; DMA Channel 5

;------------------------------------------------------------------------
; Timer Interrupts
;------------------------------------------------------------------------
I_TIM0C  EQU  I_VEC+$24   ; TIMER 0 compare
I_TIM0OF EQU  I_VEC+$26   ; TIMER 0 overflow
I_TIM1C  EQU  I_VEC+$28   ; TIMER 1 compare
I_TIM1OF EQU  I_VEC+$2A   ; TIMER 1 overflow
I_TIM2C  EQU  I_VEC+$2C   ; TIMER 2 compare
I_TIM2OF EQU  I_VEC+$2E   ; TIMER 2 overflow

;------------------------------------------------------------------------
; ESSI Interrupts
;------------------------------------------------------------------------
I_SI0RD  EQU  I_VEC+$30   ; ESSI0 Receive Data
I_SI0RDE EQU  I_VEC+$32   ; ESSI0 Receive Data With Exception Status
I_SI0RLS EQU  I_VEC+$34   ; ESSI0 Receive last slot
I_SI0TD  EQU  I_VEC+$36   ; ESSI0 Transmit data
I_SI0TDE EQU  I_VEC+$38   ; ESSI0 Transmit Data With Exception Status
I_SI0TLS EQU  I_VEC+$3A   ; ESSI0 Transmit last slot
I_SI1RD  EQU  I_VEC+$40   ; ESSI1 Receive Data
I_SI1RDE EQU  I_VEC+$42   ; ESSI1 Receive Data With Exception Status
I_SI1RLS EQU  I_VEC+$44   ; ESSI1 Receive last slot
I_SI1TD  EQU  I_VEC+$46   ; ESSI1 Transmit data
I_SI1TDE EQU  I_VEC+$48   ; ESSI1 Transmit Data With Exception Status
I_SI1TLS EQU  I_VEC+$4A   ; ESSI1 Transmit last slot

;------------------------------------------------------------------------
; SCI Interrupts
;------------------------------------------------------------------------
I_SCIRD  EQU  I_VEC+$50   ; SCI Receive Data 
I_SCIRDE EQU  I_VEC+$52   ; SCI Receive Data With Exception Status
I_SCITD  EQU  I_VEC+$54   ; SCI Transmit Data
I_SCIIL  EQU  I_VEC+$56   ; SCI Idle Line
I_SCITM  EQU  I_VEC+$58   ; SCI Timer

;------------------------------------------------------------------------
; HOST Interrupts
;------------------------------------------------------------------------
I_HPTT   EQU  I_VEC+$60   ; Host PCI Transaction Termination
I_HPTA   EQU  I_VEC+$62   ; Host PCI Transaction Abort
I_HPPE   EQU  I_VEC+$64   ; Host PCI Parity Error
I_HPTC   EQU  I_VEC+$66   ; Host PCI Transfer Complete
I_HPMR   EQU  I_VEC+$68   ; Host PCI Master Receive
I_HSR    EQU  I_VEC+$6A   ; Host Slave Receive
I_HPMT   EQU  I_VEC+$6C   ; Host PCI Master Transmit
I_HST    EQU  I_VEC+$6E   ; Host Slave Transmit
I_HPMA   EQU  I_VEC+$70   ; Host PCI Master Address
I_HCNMI  EQU  I_VEC+$72   ; Host Command/Host NMI (Default)

;------------------------------------------------------------------------
; INTERRUPT ENDING ADDRESS
;------------------------------------------------------------------------
I_INTEND EQU  I_VEC+$FF   ; last address of interrupt vector space
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\llef23.asm ===
;	File info
;	  File name: llef23.asm
;	  Build date: 06/24/01, 11:42:47
;	Program info
;	  Program number: 3
;	  Revision number: 1.64
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 1618 words
;	  Checksum: $8C0B87

		dc	$D01B40,$000652,$030140,$8C0B87,$20000B,$0D1002,$00064B,$0D1080
		dc	$00063B,$57F400,$000010,$300000,$0D1080,$000233,$44F400,$000000
		dc	$200045,$057400,$0D1080,$00063F,$00000C,$46F461,$000010,$230700
		dc	$06D910,$00000A,$50D97C,$057407,$21E478,$0C1E46,$0C1E90,$21E449
		dc	$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F461,$000010,$230700
		dc	$50D97C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$46F400,$000010,$230700,$06D910,$00000D
		dc	$56D900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449
		dc	$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400,$000010,$230700
		dc	$06D910,$00000D,$5ED900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400
		dc	$000010,$230700,$56D900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400
		dc	$000010,$230700,$5ED900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$61F400
		dc	$000D12,$46F400,$0000FF,$06D810,$00000E,$0C1C90,$200056,$51D800
		dc	$219900,$0C1D91,$4CE900,$20004B,$0C1C90,$200056,$219900,$0C1D91
		dc	$4CE900,$20004B,$0C1E91,$21AE00,$0C1C11,$00000C,$61F41B,$000E12
		dc	$46F400,$0000FF,$204800,$06D810,$00000D,$21AE5E,$44F800,$21B900
		dc	$0C1ED0,$200042,$4CE900,$200043,$218F56,$219900,$0C1ED1,$4CE900
		dc	$20004B,$0C1E91,$21AE00,$0C1C11,$00000C,$000418,$000418,$000418
		dc	$00042A,$00042A,$00042A,$000425,$000442,$000442,$000442,$000442
		dc	$000442,$000442,$000442,$000442,$000442,$000442,$000442,$000442
		dc	$000442,$00044E,$00044E,$00044E,$00045F,$00045F,$00045F,$00045F
		dc	$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F
		dc	$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F
		dc	$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$00045F,$22B100
		dc	$231900,$204800,$204900,$45F41B,$000040,$51F400,$000C00,$44D801
		dc	$06DC10,$000003,$44D8A6,$505901,$240000,$447000,$000492,$240000
		dc	$447000,$000491,$231000,$22B800,$74F400,$0003A5,$65F400,$000B32
		dc	$44F000,$000B7B,$46F400,$000032,$2244D0,$0C1D2E,$44F440,$000C1C
		dc	$200040,$219600,$390100,$0B72CE,$000F1A,$23C400,$220745,$027040
		dc	$232474,$57E844,$205800,$45E800,$05A40D,$47F400,$0000D1,$06CC10
		dc	$000009,$21EE6C,$029060,$20582E,$45E82B,$21BD7D,$4CED00,$202F40
		dc	$21CF00,$225400,$44F461,$000100,$07EC94,$47F044,$000491,$0AE480
		dc	$57700D,$000493,$05F408,$20EE6D,$05F458,$0140C4,$000040,$202913
		dc	$218700,$050C53,$47F400,$000180,$050C50,$218600,$23CE00,$014785
		dc	$05A40D,$20CE00,$20000D,$05F408,$20EE6D,$05F408,$0140C4,$000040
		dc	$202913,$218700,$050C03,$47F400,$000180,$44F000,$000493,$56F04D
		dc	$000492,$557000,$000493,$059404,$232E00,$717000,$000492,$200003
		dc	$05A414,$050C1E,$20000D,$05F408,$20EE6D,$05F41A,$0140C4,$000040
		dc	$202913,$218700,$050C15,$47F400,$000140,$050C12,$200071,$0140C4
		dc	$000080,$202913,$218700,$050C0C,$44F001,$00048F,$44F044,$00048E
		dc	$547001,$00048B,$477044,$000491,$547074,$00048A,$050C1B,$56F000
		dc	$00048B,$44F000,$00048D,$44F044,$00048F,$218601,$45F044,$00048A
		dc	$44F055,$00048C,$029050,$547061,$00048B,$44F044,$00048E,$218601
		dc	$477044,$000491,$44F055,$00048B,$029050,$547074,$00048A,$200045
		dc	$029040,$44F000,$000490,$4EDE4C,$0C1C85,$202914,$200055,$029050
		dc	$546A00,$220E00,$23C400,$205A45,$0596D7,$00000C,$56F000,$0004B7
		dc	$44F003,$0004A2,$05A407,$20EE00,$240064,$06CC10,$000002,$445900
		dc	$050C4D,$64F400,$000CBA,$66F400,$0004A5,$57DA00,$46F04C,$0004BF
		dc	$20005C,$20291B,$0140CE,$001FE0,$5EDD58,$200075,$027070,$21C564
		dc	$014184,$219E00,$56D800,$46F414,$00003F,$202913,$0C1ECA,$200055
		dc	$027050,$219C00,$06DE10,$00000B,$56D800,$7EEC14,$202913,$0C1ECA
		dc	$765955,$027050,$219C00,$56EE00,$014180,$546E00,$7EEC00,$765900
		dc	$56EE00,$014180,$546E71,$200065,$057799,$00000C,$60F400,$000B68
		dc	$70F000,$000B40,$57E800,$44F000,$000B7A,$20004C,$20000B,$05140C
		dc	$200013,$567000,$000B66,$567000,$000B67,$567000,$0004A4,$567000
		dc	$000B6E,$0D10C0,$000027,$200013,$21D800,$44F000,$000B70,$200045
		dc	$059404,$56F400,$000009,$21D800,$200005,$05F409,$200013,$567000
		dc	$000B66,$567000,$000B67,$567000,$0004A4,$050C13,$56F400,$000001
		dc	$567000,$000B66,$21EE00,$230400,$200044,$0C1C06,$280000,$567000
		dc	$000B67,$0C1D06,$230400,$200040,$567000,$0004A4,$21C400,$20004C
		dc	$56F000,$000B40,$44F400,$000005,$200045,$052413,$56F000,$000B9F
		dc	$44F000,$000B7A,$200044,$44F000,$000B53,$200044,$21D900,$577000
		dc	$000B6E,$200003,$059404,$200005,$05F402,$050C03,$232400,$208F00
		dc	$56F000,$000B70,$200003,$05F40A,$44F400,$000001,$447000,$000B66
		dc	$44F000,$000B67,$200040,$567000,$000B67,$00000C,$221100,$22B200
		dc	$46F469,$000002,$06D810,$000005,$56C900,$218F14,$200050,$545A00
		dc	$234E00,$234432,$230440,$240044,$05A404,$06CC10,$000002,$445A00
		dc	$22B000,$229100,$65F400,$000D0D,$75F400,$FFFFFE,$06DA10,$000007
		dc	$F0B800,$F0B8D0,$D0B8D2,$2000D2,$200022,$585900,$00000C,$05F420
		dc	$FFFFFF,$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400
		dc	$000000,$20004D,$05A40C,$44F400,$000010,$20004D,$0D104A,$00000F
		dc	$300000,$56F400,$000000,$57F400,$FFFFFF,$00000C,$200013,$300000
		dc	$56F400,$000000,$57F400,$000608,$00000C,$56F000,$000B96,$200003
		dc	$05741E,$56F000,$000B40,$2E0003,$052402,$014180,$567000,$000B89
		dc	$0D1080,$00038B,$44F400,$0007B0,$447000,$000B72,$0D1080,$000014
		dc	$56F000,$000B40,$2E0003,$052403,$0D1080,$000353,$0D1080,$00009D
		dc	$56F000,$000B96,$200003,$052403,$0D1080,$00019C,$200013,$21101B
		dc	$00000C,$00000C,$44F400,$000001,$447000,$000B6F,$56F01B,$000B40
		dc	$200003,$052402,$000009,$517000,$0004C0,$300200,$310100,$320100
		dc	$350200,$0B70C4,$000C08,$447000,$00048D,$0B71C4,$000C04,$447000
		dc	$00048C,$0B72C4,$000C14,$447000,$00048F,$0B75C4,$000C18,$447000
		dc	$000490,$360000,$44F000,$000B97,$06C410,$00004E,$280100,$507000
		dc	$0004C0,$300400,$0B70C4,$000C0C,$447000,$00048E,$44F400,$FF8000
		dc	$447000,$00048A,$44F400,$FF8000,$447000,$00048B,$22C400,$46F400
		dc	$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040,$219000,$22C400,$46F400
		dc	$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040,$219500,$22C400,$46F400
		dc	$000032,$44F4D0,$000000,$0C1D2E,$200040,$219A00,$380000,$56F400
		dc	$000BA5,$22C400,$200040,$219100,$74E100,$76E100,$320000,$667000
		dc	$000B41,$0D03D7,$66F000,$000B41,$56F400,$0004C1,$22C400,$200040
		dc	$219000,$626000,$56F400,$000494,$22C400,$200040,$219000,$44F000
		dc	$00048A,$446000,$56F400,$000499,$22C400,$200040,$219000,$44F000
		dc	$00048B,$446000,$205E00,$56F000,$000B7E,$200003,$05A41C,$280100
		dc	$507000,$0004C0,$300400,$0B70C4,$000C0C,$447000,$00048E,$44F400
		dc	$FF8000,$447000,$00048A,$44F400,$FF8000,$447000,$00048B,$60F400
		dc	$000483,$65F400,$000483,$72F400,$0004B8,$380000,$3C0700,$3E0700
		dc	$320000,$0D03D7,$00000C,$56F000,$000B40,$200003,$052404,$240000
		dc	$447000,$000B6E,$340000,$20001B,$44F000,$000B97,$06C410,$000003
		dc	$014188,$014188,$014188,$56F000,$000B7D,$200003,$052402,$014188
		dc	$56F000,$000B4A,$44F403,$000008,$05A402,$200048,$014188,$56F000
		dc	$000B89,$200003,$05A402,$014188,$56F000,$000B7D,$014285,$052407
		dc	$014188,$56F000,$000B40,$44F403,$000004,$202A48,$44F000,$000B97
		dc	$06C410,$000002,$014288,$56F000,$000B7E,$200003,$05A402,$014188
		dc	$56F400,$000B8A,$240000,$200040,$219000,$44F000,$000B97,$06C410
		dc	$000006,$56D800,$200003,$05A402,$014688,$000000,$60F400,$000B8A
		dc	$61F400,$000B91,$46F400,$000007,$44F000,$000B97,$06C410,$00000A
		dc	$56D800,$44D903,$05A406,$014488,$2000D0,$0C1D2E,$200018,$014288
		dc	$000000,$56F000,$000B7E,$200003,$05A408,$56F000,$000B8F,$44F403
		dc	$00000E,$05A403,$014488,$200048,$014188,$56F000,$000B90,$200003
		dc	$05A406,$014288,$014288,$014288,$014288,$014388,$014188,$56F000
		dc	$000B6F,$200003,$05A40E,$014688,$44F000,$000B97,$06C410,$000003
		dc	$014488,$014388,$56F000,$000B7E,$200003,$05A403,$014488,$014388
		dc	$014188,$014188,$21E71B,$56F000,$000B40,$0140C5,$000003,$0D1042
		dc	$00000D,$21E779,$014988,$21E779,$014188,$014188,$56F000,$000B40
		dc	$0140C5,$000003,$052402,$016F88,$014788,$0C1EC7,$557000,$000B70
		dc	$0C1E87,$21E479,$200048,$557000,$000B71,$56F000,$000B40,$200003
		dc	$052407,$20001B,$014188,$014188,$015088,$557000,$000B53,$56F000
		dc	$000B40,$200003,$05248C,$57F000,$000B51,$44F000,$000B53,$200048
		dc	$44F000,$000B9A,$46F400,$000008,$2000D0,$210E00,$200014,$547000
		dc	$000B52,$56F000,$000B53,$44F000,$000B9F,$200045,$057485,$44F41B
		dc	$155555,$56F000,$000B52,$0140C4,$00002F,$218500,$2000A8,$21AF00
		dc	$44F000,$000B71,$20004D,$05F458,$21A500,$44F400,$000006,$2000A0
		dc	$0C1D2E,$44F036,$000B52,$200040,$0140C4,$00002F,$21C700,$0140C8
		dc	$000001,$56F400,$000B68,$240000,$200040,$219000,$20F800,$06D810
		dc	$000002,$575800,$0140CC,$000001,$56F400,$000006,$200074,$200003
		dc	$05F405,$21D800,$06D810,$000002,$575800,$56F400,$000B68,$44F400
		dc	$000003,$200040,$219000,$56E000,$016F80,$566000,$56F400,$000B68
		dc	$240000,$200040,$219000,$70F000,$000B40,$56E800,$44F000,$000B71
		dc	$200044,$566800,$00000C,$44F400,$000001,$447000,$000B96,$00000C
		dc	$0D1080,$000023,$200003,$05A41B,$0D1080,$FFFDA2,$56F400,$000005
		dc	$44F000,$000B40,$200045,$05F417,$56F400,$000B68,$44F000,$000B40
		dc	$200040,$0140C0,$000001,$21D000,$56D000,$44D800,$200040,$44F000
		dc	$000B7A,$45F044,$0004A4,$200064,$566000,$050C05,$0D1080,$000158
		dc	$0D1080,$FFFD86,$00000C,$45F400,$FFFF90,$457000,$00049F,$0D1080
		dc	$00007C,$44F400,$000008,$447000,$00049E,$240000,$447000,$0004B5
		dc	$50F000,$00049E,$00000A,$507000,$00049E,$0D1080,$000087,$20000B
		dc	$059409,$44F400,$000001,$447000,$0004B5,$44F000,$00049F,$447000
		dc	$0004B6,$56F000,$0004B5,$200003,$05A40F,$56F400,$000010,$21C400
		dc	$567000,$0004A0,$56F000,$00049F,$567000,$0004A1,$200040,$200022
		dc	$567000,$00049F,$050C0E,$56F400,$FFFF10,$21C400,$567000,$0004A1
		dc	$56F000,$00049F,$567000,$0004A0,$200040,$200022,$567000,$00049F
		dc	$0D1080,$000043,$0D1080,$00005A,$20000B,$05940E,$44F000,$00049F
		dc	$447000,$0004A1,$44F400,$000001,$447000,$0004B5,$44F000,$00049F
		dc	$447000,$0004B6,$050C05,$44F000,$00049F,$447000,$0004A0,$56F000
		dc	$0004A0,$44F000,$0004A1,$21C644,$0140C5,$000001,$052408,$0D1080
		dc	$000128,$44F400,$000001,$447000,$0004B5,$050C1B,$200051,$200040
		dc	$200022,$200045,$057404,$208E00,$014180,$050C05,$200055,$059403
		dc	$20CE00,$014184,$547000,$00049F,$56F000,$00049E,$014184,$547000
		dc	$00049E,$057787,$56F000,$0004B5,$014185,$052403,$0D1080,$000109
		dc	$56F000,$0004B5,$00000C,$56F000,$00049F,$0140C0,$0000F0,$0C1C08
		dc	$218400,$2C0000,$0C1D08,$218600,$60F400,$000B73,$62F400,$000B79
		dc	$64F400,$000B74,$3C0500,$70F000,$000B97,$229500,$445800,$465A00
		dc	$06D810,$000002,$465D00,$00000C,$70F000,$000B40,$60F400,$000B68
		dc	$57E800,$21FA00,$56F000,$0004C0,$200003,$05A545,$56F400,$000001
		dc	$567000,$0004B7,$56F400,$000000,$44F000,$000B73,$200045,$05A404
		dc	$240000,$447000,$0004B7,$46F400,$000000,$60F400,$000B74,$44F000
		dc	$000B97,$06C410,$000008,$56D800,$200055,$05A404,$200013,$567000
		dc	$0004B7,$000000,$56F000,$000B7E,$200003,$05A408,$56F000,$000B79
		dc	$200055,$05A404,$200013,$567000,$0004B7,$300700,$0B70C4,$000CB2
		dc	$447000,$0004BF,$60F413,$0004A5,$061090,$000002,$565800,$360000
		dc	$44F000,$000B97,$06C410,$000036,$56F400,$000B74,$22C400,$200040
		dc	$219000,$56F000,$000B73,$44E000,$014F84,$0C1D08,$200040,$0C1D04
		dc	$547000,$0004A2,$56F400,$000BA5,$22C400,$200040,$219000,$250000
		dc	$47E000,$22C400,$46F400,$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040
		dc	$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72,$0C1D2E,$200040
		dc	$219100,$22C400,$46F400,$000032,$44F4D0,$000000,$0C1D2E,$200040
		dc	$219200,$65F400,$000F1A,$667000,$000B41,$0D0486,$66F000,$000B41
		dc	$205E00,$56F000,$000B7E,$200003,$05A417,$56F000,$000B73,$44F000
		dc	$000B79,$014F84,$0C1D08,$200040,$0C1D04,$547000,$0004A2,$250000
		dc	$47F400,$000007,$60F400,$000483,$61F400,$000B39,$62F400,$0004B8
		dc	$65F400,$000F1A,$0D0486,$60F400,$0004A6,$66F41B,$000CFB,$44D800
		dc	$47F413,$D55555,$20E800,$4EDEC6,$218413,$44D8DA,$20E800,$4EDEC6
		dc	$218400,$F0D8DA,$44D8DA,$47F413,$C00000,$20E800,$4EDEC6,$218400
		dc	$2000DA,$F0D800,$060A90,$000002,$F0D8DA,$2000DA,$0C1DAE,$567000
		dc	$000B7A,$050C02,$050C00,$44F01B,$000B7A,$234F00,$20004C,$21FA00
		dc	$20000B,$051402,$050C03,$0D1080,$FFFC33,$00000C,$60F41B,$000B7A
		dc	$576000,$60F400,$000B73,$62F400,$000B79,$64F400,$000B74,$70F000
		dc	$000B97,$229500,$576000,$576200,$06D810,$000002,$575D00,$360000
		dc	$44F000,$000B97,$06C410,$000012,$22C400,$46F400,$0000B5,$44F0D0
		dc	$000B72,$0C1D2E,$200040,$219000,$56F400,$000BA5,$22C400,$200040
		dc	$219200,$066210,$000002,$575800,$205E00,$56F000,$000B7E,$200003
		dc	$05A406,$60F400,$000B39,$060790,$000002,$575800,$00000C,$44F000
		dc	$0004B6,$447000,$00049F,$0D1080,$FFFEF8,$050A0F,$00000C,$20001B
		dc	$015088,$015088,$014288,$014688,$014588,$014388,$014388,$56F000
		dc	$000B7D,$014185,$05A404,$014186,$05A402,$014288,$56F000,$000B7D
		dc	$014486,$05A402,$014288,$56F000,$000B7D,$014285,$052402,$014288
		dc	$014188,$014588,$014188,$56F000,$000B4C,$44F403,$000008,$05A402
		dc	$200048,$014188,$014188,$014188,$014188,$014188,$014188,$014188
		dc	$577000,$000B51,$00000C,$360000,$44F000,$000B97,$06C410,$000034
		dc	$56F400,$000B8A,$22C400,$200040,$219000,$56E000,$219203,$05A44B
		dc	$22C400,$46F400,$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040,$219000
		dc	$56F400,$000B5C,$22C400,$200040,$219100,$70E100,$0B72D9,$000F12
		dc	$56F400,$000B91,$22C400,$200040,$219100,$72E100,$45D800,$22C400
		dc	$46F400,$0000B5,$44F4D0,$0007B0,$0C1D2E,$200040,$219500,$455D00
		dc	$22C400,$46F400,$00001F,$44F4D0,$000000,$0C1D2E,$200040,$219400
		dc	$4D5C00,$0D051E,$205E00,$56F000,$000B7E,$200003,$05A413,$56F000
		dc	$000B8F,$200003,$05A40F,$60F400,$000483,$380600,$79F000,$000F13
		dc	$3A0200,$45D800,$65F400,$000B39,$455D00,$64F400,$00009B,$4D5C00
		dc	$0D051E,$00000C,$56F400,$000011,$57F400,$000001,$70F400,$000390
		dc	$390000,$60F400,$0000FA,$0BF080,$000180,$200003,$052400,$00000C
		dc	$00000C,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\llef33.asm ===
;	File info
;	  File name: llef33.asm
;	  Build date: 06/24/01, 11:42:50
;	Program info
;	  Program number: 4
;	  Revision number: 1.64
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 1747 words
;	  Checksum: $0FC709

		dc	$D01B40,$0006D3,$040140,$0FC709,$447000,$0000FB,$20000B,$05A403
		dc	$0D1080,$0006C0,$0D1080,$00066C,$57F000,$0000FB,$60F40B,$00001F
		dc	$052412,$240000,$447000,$000B4F,$447000,$000B50,$44F400,$F87200
		dc	$445800,$44F400,$4E1F00,$445800,$44F400,$000100,$445800,$44F400
		dc	$500000,$445800,$56F000,$000B4F,$44F003,$000B50,$05A402,$445800
		dc	$57F400,$000010,$0D1080,$0001A6,$44F400,$000000,$200045,$057400
		dc	$205800,$56D800,$57F000,$0000FB,$44F40B,$000004,$202A40,$57F000
		dc	$000B4F,$44F40B,$000001,$202240,$240000,$250000,$60F400,$00001F
		dc	$0CCC80,$000007,$0ACC40,$219800,$44F400,$000001,$45E800,$447000
		dc	$000B4F,$457000,$000B50,$218400,$56F000,$0000FB,$0D1080,$000636
		dc	$00000C,$46F461,$000010,$230700,$06D910,$00000A,$50D97C,$057407
		dc	$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500
		dc	$00000C,$46F461,$000010,$230700,$50D97C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400
		dc	$000010,$230700,$06D910,$00000D,$56D900,$0C1E6E,$20AC7C,$057407
		dc	$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500
		dc	$00000C,$46F400,$000010,$230700,$06D910,$00000D,$5ED900,$0C1E6E
		dc	$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$46F400,$000010,$230700,$56D900,$0C1E6E
		dc	$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$46F400,$000010,$230700,$5ED900,$0C1E6E
		dc	$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$61F400,$000D12,$46F400,$0000FF,$06D810
		dc	$00000E,$0C1C90,$200056,$51D800,$219900,$0C1D91,$4CE900,$20004B
		dc	$0C1C90,$200056,$219900,$0C1D91,$4CE900,$20004B,$0C1E91,$21AE00
		dc	$0C1C11,$00000C,$61F41B,$000E12,$46F400,$0000FF,$204800,$06D810
		dc	$00000D,$21AE5E,$44F800,$21B900,$0C1ED0,$200042,$4CE900,$200043
		dc	$218F56,$219900,$0C1ED1,$4CE900,$20004B,$0C1E91,$21AE00,$0C1C11
		dc	$00000C,$000479,$0003FA,$000417,$000434,$00043B,$000454,$00045B
		dc	$00045E,$000461,$000464,$000467,$00046A,$00046D,$000470,$000473
		dc	$000476,$74F400,$0003E1,$06D810,$000086,$64DD00,$56E000,$07EC96
		dc	$218500,$0AE680,$44F400,$000003,$62F4A0,$000005,$72F040,$000002
		dc	$234F22,$39010B,$546A00,$052404,$607000,$00000D,$050C0E,$66F400
		dc	$000D0A,$232400,$39024D,$05A409,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2
		dc	$00000D,$0C1D24,$390000,$506600,$717013,$000002,$050CC3,$44F400
		dc	$000005,$62F4A0,$000008,$72F040,$000003,$234F22,$39010B,$546A00
		dc	$052404,$607000,$00000E,$050C0E,$66F400,$000D0D,$232400,$39024D
		dc	$05A409,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000E,$0C1D20,$390000
		dc	$506600,$717013,$000003,$050C86,$44F400,$000007,$2000A0,$200040
		dc	$0C1D38,$0C1C10,$050C5F,$44F400,$00000B,$62F4A0,$00000B,$72F040
		dc	$000004,$234F22,$39010B,$66F400,$000D10,$546A00,$052404,$607000
		dc	$00000F,$050C08,$F0DA00,$F0DAD0,$66F0D2,$00000F,$0C1D20,$390000
		dc	$506600,$717013,$000004,$050C46,$44F400,$00000F,$2000A0,$200040
		dc	$0C1D36,$0C1C10,$050C1F,$56F400,$040000,$050C1B,$56F400,$020000
		dc	$050C18,$56F400,$010000,$050C15,$56F400,$008000,$050C12,$56F400
		dc	$004000,$050C0F,$56F400,$002000,$050C0C,$56F400,$001000,$050C09
		dc	$56F400,$000800,$050C06,$56F400,$000400,$050C03,$56F400,$000100
		dc	$200060,$565800,$00000C,$0004C6,$0004B2,$0004A8,$0004BB,$00049E
		dc	$0004BB,$0004BB,$0004BB,$0004BB,$0004BB,$0004BB,$0004BB,$0004BB
		dc	$0004BB,$0004BB,$0004BB,$62F000,$000B55,$05F022,$000B47,$56F000
		dc	$000B56,$45F000,$000B57,$46F400,$000010,$74F400,$00047B,$06D810
		dc	$00002F,$64DD00,$07EC96,$0B74C7,$000CFA,$0AE680,$57F000,$000004
		dc	$01418C,$557000,$000004,$052443,$390200,$717000,$000004,$050C14
		dc	$57F000,$000003,$01418C,$557000,$000003,$052419,$390300,$717000
		dc	$000003,$050C0A,$57F000,$000002,$01418C,$557000,$000002,$05240F
		dc	$390300,$717000,$000002,$200069,$50E07C,$057407,$21E478,$0C1E46
		dc	$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$21A500,$205800,$547000
		dc	$000B56,$457000,$000B57,$627000,$000B55,$05F422,$00FFFF,$00000C
		dc	$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8
		dc	$44F400,$000000,$20004D,$05A40C,$44F400,$000010,$20004D,$0D104A
		dc	$00000F,$300000,$56F400,$000000,$57F400,$FFFFFF,$00000C,$200013
		dc	$300000,$56F400,$000000,$57F400,$000608,$00000C,$56F000,$000B96
		dc	$200003,$057458,$607000,$000B45,$607000,$000B55,$45F400,$0007B0
		dc	$457000,$000B72,$56F000,$000B40,$240003,$052409,$447000,$000B56
		dc	$447000,$000B57,$447000,$000B9D,$0D1080,$00008C,$0D1080,$000129
		dc	$0D1080,$00019E,$0D1080,$000366,$56F000,$000B40,$014585,$052403
		dc	$0D1080,$000393,$56F000,$000B55,$44F000,$000B45,$200044,$547000
		dc	$000B58,$0D1080,$0003D0,$56F000,$000B40,$014585,$05A40B,$44F000
		dc	$000B58,$45F400,$000010,$44F0A0,$000B9D,$0C1D2E,$200040,$567000
		dc	$000B9D,$0D1080,$000008,$00000C,$44F400,$000100,$447000,$000010
		dc	$00000C,$56F000,$000B96,$200003,$05F407,$44F013,$000B45,$447000
		dc	$000B55,$547000,$000B9A,$60F400,$000011,$44F400,$00000D,$445800
		dc	$56F000,$000B55,$44F000,$000B45,$200044,$545800,$44F000,$000B55
		dc	$445800,$240000,$445800,$445800,$445800,$445800,$44F413,$000009
		dc	$447000,$00001E,$44F000,$00001E,$0C1940,$004018,$545800,$240000
		dc	$445800,$20001B,$200013,$0C1EDF,$21A400,$0C1940,$008020,$20001B
		dc	$0C1EDF,$21A400,$0C1940,$008018,$545800,$57F013,$000B7D,$45F40B
		dc	$000080,$052407,$20001B,$0C1CA1,$200068,$21A400,$0C1940,$008020
		dc	$20001B,$0C1CA1,$200068,$21A400,$0C1940,$008018,$545800,$57F013
		dc	$000B7D,$20000B,$052407,$20001B,$0C1CA1,$200068,$21A400,$0C1940
		dc	$008020,$0C1CA1,$200068,$21A400,$0C1940,$008018,$545800,$200013
		dc	$545800,$60F400,$000011,$56F000,$000B96,$57F400,$000608,$00000C
		dc	$62F000,$000B45,$05F022,$000B47,$57F400,$000010,$250000,$44F400
		dc	$000B77,$447000,$000000,$44F400,$000000,$447000,$000B54,$61F400
		dc	$000000,$381000,$0D0393,$61F400,$000B54,$381000,$0D0393,$61F400
		dc	$000B7B,$380200,$0D0393,$61F400,$000B7C,$380600,$0D0393,$280400
		dc	$507000,$00001E,$61F400,$00001E,$380500,$0D0393,$280000,$507000
		dc	$00001E,$61F400,$00001E,$380300,$0D0393,$61F400,$000B7D,$380300
		dc	$0D0393,$56F000,$000B7D,$014185,$05A40A,$014186,$05A408,$280000
		dc	$507000,$00001E,$61F400,$00001E,$380200,$0D0393,$56F000,$000B7D
		dc	$014486,$05A408,$280000,$507000,$00001E,$61F400,$00001E,$380200
		dc	$0D0393,$56F000,$000B7D,$014285,$052405,$61F400,$000B4E,$380200
		dc	$0D0393,$61F400,$000B7E,$380100,$0D0393,$61F400,$000B49,$380500
		dc	$0D0393,$61F400,$000B4C,$380100,$0D0393,$56F000,$000B4C,$200003
		dc	$05A405,$61F400,$000B4D,$380800,$0D0393,$280000,$507000,$00001E
		dc	$61F400,$00001E,$380100,$0D0393,$280000,$507000,$00001E,$61F400
		dc	$00001E,$380100,$0D0393,$280000,$507000,$00001E,$61F400,$00001E
		dc	$380100,$0D0393,$280100,$507000,$00001E,$61F400,$00001E,$380100
		dc	$0D0393,$200013,$567000,$00001E,$61F400,$00001E,$380100,$0D0393
		dc	$200013,$567000,$00001E,$61F400,$00001E,$380100,$0D0393,$200013
		dc	$507000,$00001E,$61F400,$00001E,$380100,$0D0393,$457000,$000B56
		dc	$577000,$000B57,$627000,$000B55,$05F422,$00FFFF,$00000C,$200013
		dc	$567000,$000002,$567000,$000003,$567000,$000004,$360000,$44F000
		dc	$000B97,$06C410,$00001D,$56F400,$000BA5,$22C400,$200040,$219000
		dc	$70E000,$22C400,$46F400,$0000B5,$44F4D0,$000100,$0C1D2E,$200040
		dc	$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72,$0C1D2E,$200040
		dc	$219500,$667000,$000B41,$0D03F1,$66F000,$000B41,$205E00,$56F000
		dc	$000B7E,$200003,$05A407,$380700,$60F400,$000489,$65F400,$000B39
		dc	$0D03F1,$57F000,$000002,$20000B,$05A414,$62F400,$000005,$66F400
		dc	$000D0A,$224E00,$44F410,$000001,$01438C,$21D03E,$06CD10,$000002
		dc	$445800,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000D,$0C1D24,$506600
		dc	$57F000,$000003,$20000B,$05A414,$62F400,$000008,$66F400,$000D0D
		dc	$224E00,$44F410,$000002,$01438C,$21D03E,$06CD10,$000002,$445800
		dc	$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000E,$0C1D20,$506600,$57F000
		dc	$000004,$20000B,$05A413,$62F400,$00000B,$66F400,$000D10,$224E00
		dc	$44F410,$000005,$01428C,$21D03E,$06CD10,$000002,$445800,$F0DA00
		dc	$F0DAD0,$66F0D2,$00000F,$0C1D20,$506600,$00000C,$62F000,$000B55
		dc	$05F022,$000B47,$57F000,$000B57,$45F000,$000B56,$61F400,$000B7F
		dc	$71F000,$000B97,$380100,$0D036F,$61F400,$000B84,$71F000,$000B97
		dc	$380100,$0D036F,$61F400,$000B4A,$380100,$0D0393,$56F000,$000B4A
		dc	$200003,$05A405,$61F400,$000B4B,$380800,$0D0393,$200013,$567000
		dc	$00001E,$61F400,$000B89,$380100,$0D0393,$56F900,$200003,$05A405
		dc	$61F400,$00001E,$380100,$0D0393,$56F000,$000B7D,$0140C5,$000002
		dc	$052412,$44F400,$000010,$447000,$00001E,$56F000,$000B40,$200003
		dc	$052406,$61F400,$00001E,$380500,$0D0393,$050C05,$61F400,$00001E
		dc	$380100,$0D0393,$61F400,$000B8A,$71F000,$000B97,$380200,$0D036F
		dc	$56F000,$000B7E,$200003,$05A405,$61F400,$000B8F,$380100,$0D0393
		dc	$360000,$44F000,$000B97,$06C410,$000011,$56F400,$000B8A,$22C400
		dc	$200040,$219100,$56E100,$200003,$05A408,$56F400,$000BA0,$22C400
		dc	$200040,$219100,$380600,$0D0393,$205E00,$360000,$44F000,$000B97
		dc	$06C410,$000023,$56F400,$000B8A,$22C400,$200040,$219100,$56E100
		dc	$200003,$05A41A,$22C400,$46F400,$00001F,$44F4D0,$000000,$0C1D2E
		dc	$200040,$219100,$380400,$0D03A3,$56F400,$000B91,$22C400,$200040
		dc	$219000,$71E000,$380700,$0D0381,$56F400,$000B61,$22C400,$200040
		dc	$219100,$380200,$0D0393,$205E00,$56F000,$000B7E,$200003,$05A40C
		dc	$56F000,$000B8F,$200003,$05A408,$61F400,$00009B,$380400,$0D03A3
		dc	$390200,$380700,$0D0381,$61F400,$000B90,$380100,$0D0393,$56F900
		dc	$200003,$05A449,$56F400,$000002,$567000,$00001E,$61F400,$00001E
		dc	$380200,$0D0393,$56F400,$000001,$567000,$00001E,$61F400,$00001E
		dc	$380200,$0D0393,$56F400,$000001,$567000,$00001E,$61F400,$00001E
		dc	$380200,$0D0393,$56F400,$000002,$567000,$00001E,$61F400,$00001E
		dc	$380200,$0D0393,$56F400,$000007,$567000,$00001E,$61F400,$00001E
		dc	$380300,$0D0393,$61F400,$000B6F,$380100,$0D0393,$56F900,$200003
		dc	$05A44A,$61F400,$000B73,$380600,$0D0393,$360000,$44F000,$000B97
		dc	$06C410,$000011,$56F400,$000B74,$22C400,$200040,$219100,$380400
		dc	$0D0393,$56F400,$000004,$567000,$00001E,$61F400,$00001E,$380300
		dc	$0D0393,$205E00,$56F000,$000B7E,$200003,$05A40D,$61F400,$000B79
		dc	$380400,$0D0393,$56F400,$000004,$567000,$00001E,$61F400,$00001E
		dc	$380300,$0D0393,$61F413,$00001E,$566100,$380100,$0D0393,$050C01
		dc	$56F000,$000B40,$014385,$052455,$224E00,$44F000,$000B45,$46F444
		dc	$000010,$21C700,$21EE00,$44F436,$000010,$200040,$21C400,$47F0B0
		dc	$000B9D,$0C1D2E,$200040,$44F070,$000B67,$21C741,$0C1D06,$18B000
		dc	$000B9E,$44F054,$000B7A,$200044,$200074,$200003,$05F41A,$014780
		dc	$44F000,$000B67,$0C1C06,$21C441,$200040,$567000,$000B67,$0140C5
		dc	$0001FF,$05F402,$00000C,$56F000,$000B71,$21C441,$0C1D06,$21C441
		dc	$200040,$567000,$000B71,$60F400,$000B6C,$56E000,$200044,$566000
		dc	$61F400,$000B66,$380100,$0D0393,$56F900,$200003,$05A501,$61F400
		dc	$000B67,$380900,$0D0393,$56F000,$000B70,$200003,$05F49F,$44F400
		dc	$000001,$447000,$000B5B,$61F413,$00001E,$566100,$380100,$0D0393
		dc	$240000,$447000,$00001E,$61F400,$00001E,$380100,$0D0393,$56F000
		dc	$000B5B,$014180,$567000,$000B5B,$56F000,$000B40,$014385,$052441
		dc	$240000,$447000,$00001E,$21EE00,$015085,$05A40B,$44F000,$000B5B
		dc	$200040,$21E400,$567000,$000B5B,$61F400,$00001E,$209800,$0D0393
		dc	$224E00,$567000,$000B59,$61F400,$00001E,$381000,$0D0393,$61F400
		dc	$00001E,$381000,$0D0393,$56F000,$000B5B,$016080,$567000,$000B5B
		dc	$240000,$447000,$00001E,$56F000,$000B70,$0C1D06,$44F000,$000B5B
		dc	$200044,$0C1C06,$06CC10,$00000A,$61F400,$00001E,$380800,$0D0393
		dc	$56F000,$000B5B,$014880,$567000,$000B5B,$56F000,$000B70,$0C1D06
		dc	$44F000,$000B5B,$200044,$61F400,$00001E,$219800,$0D0393,$56F000
		dc	$000B67,$44F000,$000B70,$200044,$050C0F,$56F000,$000B67,$2E0003
		dc	$05F40B,$240000,$447000,$00001E,$61F400,$00001E,$380800,$0D0393
		dc	$56F000,$000B67,$014184,$200003,$05A40B,$06CC10,$000009,$200013
		dc	$567000,$000010,$61F400,$000010,$380800,$0D0361,$000000,$457000
		dc	$000B56,$577000,$000B57,$627000,$000B55,$05F422,$00FFFF,$00000C
		dc	$390100,$717000,$000002,$717000,$000003,$717000,$000004,$360000
		dc	$44F000,$000B97,$06C410,$00001D,$56F400,$000BA5,$22C400,$200040
		dc	$219000,$70E000,$22C400,$46F400,$0000B5,$44F4D0,$000100,$0C1D2E
		dc	$200040,$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72,$0C1D2E
		dc	$200040,$219500,$667000,$000B41,$0D048B,$66F000,$000B41,$205E00
		dc	$56F000,$000B7E,$200003,$05A407,$380700,$60F400,$000489,$65F400
		dc	$000B39,$0D048B,$00000C,$62F000,$000B55,$05F022,$000B47,$57F000
		dc	$000B57,$45F000,$000B56,$240000,$447000,$00001E,$56F000,$000B6E
		dc	$015085,$059409,$015084,$547000,$000B6E,$61F400,$00001E,$381000
		dc	$0D0393,$050FD5,$200003,$05A405,$61F400,$00001E,$219800,$0D0393
		dc	$200013,$567000,$000001,$567000,$00001E,$61F400,$00001E,$380100
		dc	$0D0393,$61F400,$000001,$380100,$0D0393,$61F400,$00001E,$381000
		dc	$0D0393,$457000,$000B56,$577000,$000B57,$627000,$000B55,$05F422
		dc	$00FFFF,$56F000,$000B55,$44F000,$000B45,$200044,$21C400,$45F400
		dc	$000010,$2000A0,$0C1D2E,$44F000,$000B9D,$200040,$567000,$000B9D
		dc	$00000C,$56F000,$000B40,$014085,$052410,$60F000,$000B45,$205800
		dc	$05F020,$000B47,$56F000,$000B58,$014184,$21D81B,$0D03B3,$557000
		dc	$000B5A,$05F420,$00FFFF,$050CDA,$014185,$05A403,$014285,$05240F
		dc	$60F000,$000B45,$05F020,$000B47,$70F01B,$000B58,$55F000,$000B5A
		dc	$0D03B3,$557000,$000B5A,$05F420,$00FFFF,$050CC8,$014385,$052482
		dc	$56F000,$000B59,$44F000,$000B45,$200044,$014180,$21D800,$209000
		dc	$05F020,$000B47,$55F000,$000B5A,$0D03B3,$0C1E91,$61F000,$000B59
		dc	$556100,$0C1C91,$44F000,$000B9D,$250800,$2000A0,$44F000,$000B9B
		dc	$21C441,$200044,$230400,$200044,$209A00,$21D800,$56F000,$000B59
		dc	$014180,$21D000,$0D03CA,$56F000,$000B59,$014180,$21D000,$0C1E91
		dc	$556000,$0C1C91,$56F000,$000B55,$44F000,$000B45,$200044,$234400
		dc	$200044,$230400,$200044,$21D800,$56F000,$000B45,$200040,$234400
		dc	$200040,$21D000,$20001B,$0D03B3,$557000,$000B5A,$05F420,$00FFFF
		dc	$050C45,$014485,$05240F,$05F020,$000B47,$60F000,$000B45,$70F000
		dc	$000B58,$57F000,$000B5A,$0D03B3,$557000,$000B5A,$05F420,$00FFFF
		dc	$050C15,$014585,$052413,$05F020,$000B47,$60F000,$000B45,$70F000
		dc	$000B58,$57F000,$000B5A,$0D03B3,$56F000,$000B55,$014184,$21D000
		dc	$0C1E91,$556000,$0C1C91,$05F420,$00FFFF,$00000C,$56F400,$000010
		dc	$57F400,$000001,$70F400,$000390,$390000,$60F400,$000100,$0BF080
		dc	$000180,$200003,$052400,$00000C,$547000,$0000FD,$447000,$0000FE
		dc	$607000,$0000FF,$200003,$052410,$56F400,$00000A,$70F400,$0005DA
		dc	$390000,$0BF080,$000180,$200003,$052400,$56F000,$0000FD,$60F000
		dc	$0000FF,$44F000,$0000FE,$45F403,$0005DA,$052403,$457000,$000B48
		dc	$209800,$56F000,$000B48,$219940,$547000,$000B48,$56F400,$000007
		dc	$57F400,$000002,$0BF080,$000180,$200003,$052400,$56F000,$0000FD
		dc	$014585,$052409,$56F400,$00000A,$70F400,$000122,$71F400,$000ADE
		dc	$0BF080,$000180,$56F400,$000014,$57F400,$000002,$390000,$70F400
		dc	$000080,$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C
		dc	$56F400,$000014,$57F400,$000000,$70F400,$000080,$0BF080,$000180
		dc	$200003,$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\ldr_tab.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			ldr_tab.asm
;												
;   Contents:		Loader Table for System Memory addresses for X-Box
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/13/2000 8:30:42 AM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'Loader Table'

	section	Loader_Table

;**** include files ***********

	nolist
	include 'ldr_sip.inc'
	list

;**** program code ************

	xdef	LdrTable

	org		p(101):					; Loader Table runtime counter is 101

LdrTable		ds		LDR_TABLE_SIZE

; ******************************************************************

	endsec		; Loader_Table

	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\lleconfg.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			lleconfg.asm
;												
;   Contents:		System memory simulation of configuration data
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/14/2000 10:51:57 AM		jmw
;	Created.
;
;
; ******************************************************************

	IF		@DEF('RTSYS')

;	Dolby's Cagent 6 Development hardware

	dc		SE_IN_MAX		; input parameter list size
	dc		0				; do Dolby Surround Encoder flag
	dc		1				; do Dolby Game Encoder flag
	dc		0				; PCM sampling rate code
	dc		3				; input channel configuration
	dc		1				; low frequency effects channel present flag
	dc		16				; dialnorm setting 
	dc		5				; manual channel bandwidth 
	dc		0				; channel LPF enabled flag 
	dc		0				; LFE LPF flag 
	dc		0				; DC HPF flag
	dc		0				; dynrng exists flag
	dc		$0				; AC-3 dynamic range code 
	dc		1				; compr exists flag
	dc		$ef				; AC-3 compression code ($ef = -6dB in RF mode) 
	dc		1				; Surround gain enabled
	dc		0.562341325		; Surround gain: 0.562341325 = -5 dB, 0.177827941 = -15dB
	dc		$02				; Dolby Surround mode in 2/0 Mode (dsurmod)

	ELSE

;	NVIDIA hardware and Motorola Simulator

	dc		SE_IN_MAX		; input parameter list size
	dc		0				; do Dolby Surround Encoder flag
	dc		1				; do Dolby Game Encoder flag
	dc		0				; PCM sampling rate code
	dc		7				; input channel configuration
	dc		1				; low frequency effects channel present flag
	dc		16				; dialnorm setting 
	dc		9				; manual channel bandwidth 
	dc		1				; channel LPF enabled flag 
	dc		1				; LFE LPF flag 
	dc		1				; DC HPF flag 
	dc		0				; dynrng exists flag
	dc		$0				; AC-3 dynamic range code 
	dc		0				; compr exists flag
	dc		$ef				; AC-3 compression code 
	dc		1				; Surround gain enabled
	dc		0.562341325		; Surround gain: 0.562341325 = -5 dB, 0.177827941 = -15dB 
	dc		$02				; Dolby Surround mode in 2/0 Mode (dsurmod)

	ENDIF	; @DEF('RTSYS')
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\lleyrom.asm ===
dc	$80B652
	dc	$7E94D5
	dc	$081251
	dc	$F7EE67
	dc	$081251
	dc	$805361
	dc	$7F6007
	dc	$1C8662
	dc	$E37CFE
	dc	$1C8662
	dc	$808C65
	dc	$7EEB1C
	dc	$010B74
	dc	$FEF67B
	dc	$010B74
	dc	$801DB0
	dc	$7FCD25
	dc	$1142D5
	dc	$EEC16A
	dc	$1142D5
	dc	$FFD43D
	dc	$119829
	dc	$26DA06
	dc	$21C64D
	dc	$26DA06
	dc	$159B58
	dc	$55B759
	dc	$605766
	dc	$201F9E
	dc	$605766
	dc	$1FA4D2
	dc	$774339
	dc	$687FE3
	dc	$30FF87
	dc	$687FE3
	dc	$0B0E75
	dc	$1251AB
	dc	$35486E
	dc	$1EEEDC
	dc	$35486E
	dc	$251CD5
	dc	$57319E
	dc	$4C080D
	dc	$449C2A
	dc	$4C080D
	dc	$30C7F7
	dc	$77ADA6
	dc	$74AE92
	dc	$360AEE
	dc	$74AE92
	dc	$16C3AB
	dc	$14ACB7
	dc	$39D4BB
	dc	$27454B
	dc	$39D4BB
	dc	$3441F9
	dc	$5978D5
	dc	$536EAE
	dc	$4D7C52
	dc	$536EAE
	dc	$40ECCE
	dc	$7843E0
	dc	$763244
	dc	$44C8FA
	dc	$763244
	dc	$230D4D
	dc	$18EE97
	dc	$420FC8
	dc	$2D74D1
	dc	$420FC8
	dc	$42D5AD
	dc	$5C8EC1
	dc	$5AD851
	dc	$5644BD
	dc	$5AD851
	dc	$4FC627
	dc	$7902EE
	dc	$72771E
	dc	$5779E0
	dc	$72771E
	dc	$300690
	dc	$1F7818
	dc	$47C4B6
	dc	$37FDE7
	dc	$47C4B6
	dc	$509D22
	dc	$6073ED
	dc	$6215CE
	dc	$5EC14B
	dc	$6215CE
	dc	$5D0C75
	dc	$79E730
	dc	$756077
	dc	$6220C1
	dc	$756077
	dc	$3DCBB1
	dc	$28CEA4
	dc	$4D2AF1
	dc	$450812
	dc	$4D2AF1
	dc	$5D56F0
	dc	$6526DF
	dc	$6906E1
	dc	$66CA75
	dc	$6906E1
	dc	$687E85
	dc	$7AEC6C
	dc	$7A76E9
	dc	$68F757
	dc	$7A76E9
	dc	$4C781F
	dc	$35A91E
	dc	$5738EF
	dc	$5013BE
	dc	$5738EF
	dc	$68BA93
	dc	$6AA314
	dc	$6FAFD0
	dc	$6E5C4D
	dc	$6FAFD0
	dc	$71E246
	dc	$7C0DD3
	dc	$7A3EE3
	dc	$72EB44
	dc	$7A3EE3
	dc	$5C2288
	dc	$4701E7
	dc	$612530
	dc	$5E7E4C
	dc	$612530
	dc	$72788D
	dc	$70DFBD
	dc	$75B679
	dc	$7515A8
	dc	$75B679
	dc	$790593
	dc	$7D4612
	dc	$7CCFFF
	dc	$78205F
	dc	$7CCFFF
	dc	$6CD503
	dc	$5E2F5B
	dc	$6E5E78
	dc	$6D8E38
	dc	$6E5E78
	dc	$7A3B64
	dc	$77CE50
	dc	$7B18F9
	dc	$7AEBEE
	dc	$7B18F9
	dc	$7DBF1C
	dc	$7E8F57
	dc	$7DC387
	dc	$7C7BEB
	dc	$7DC387
	dc	$52680A
	dc	$3D2546
	dc	$27E5C9
	dc	$12A305
	dc	$47C84B
	dc	$328588
	dc	$1D42C4
	dc	$CD7DE9
	dc	$17E153
	dc	$2CD213
	dc	$D36808
	dc	$2CD213
	dc	$BF3A00
	dc	$47D461
	dc	$3B1618
	dc	$C6A2F1
	dc	$3B1618
	dc	$0CCCCD
	dc	$09999A
	dc	$066666
	dc	$333333
	dc	$200000
	dc	$133333
	dc	$000475
	dc	$0007FE
	dc	$000C02
	dc	$0010A3
	dc	$0015F5
	dc	$001C08
	dc	$0022ED
	dc	$002AB5
	dc	$003371
	dc	$003D32
	dc	$00480A
	dc	$00540D
	dc	$00614B
	dc	$006FDA
	dc	$007FCD
	dc	$009138
	dc	$00A431
	dc	$00B8CC
	dc	$00CF1F
	dc	$00E741
	dc	$010148
	dc	$011D4B
	dc	$013B61
	dc	$015BA2
	dc	$017E25
	dc	$01A302
	dc	$01CA51
	dc	$01F42C
	dc	$0220A9
	dc	$024FE2
	dc	$0281F0
	dc	$02B6EA
	dc	$02EEE9
	dc	$032A07
	dc	$03685A
	dc	$03A9FC
	dc	$03EF04
	dc	$04378A
	dc	$0483A5
	dc	$04D36D
	dc	$0526F7
	dc	$057E5B
	dc	$05D9AE
	dc	$063904
	dc	$069C74
	dc	$070410
	dc	$076FEB
	dc	$07E01A
	dc	$0854AC
	dc	$08CDB3
	dc	$094B40
	dc	$09CD61
	dc	$0A5425
	dc	$0ADF98
	dc	$0B6FC8
	dc	$0C04BF
	dc	$0C9E87
	dc	$0D3D2A
	dc	$0DE0AE
	dc	$0E891A
	dc	$0F3674
	dc	$0FE8C0
	dc	$109FFF
	dc	$115C34
	dc	$121D5D
	dc	$12E37B
	dc	$13AE89
	dc	$147E84
	dc	$155366
	dc	$162D27
	dc	$170BBF
	dc	$17EF23
	dc	$18D748
	dc	$19C421
	dc	$1AB59F
	dc	$1BABB2
	dc	$1CA648
	dc	$1DA54F
	dc	$1EA8B0
	dc	$1FB058
	dc	$20BC2D
	dc	$21CC18
	dc	$22DFFD
	dc	$23F7C2
	dc	$251348
	dc	$263272
	dc	$275520
	dc	$287B31
	dc	$29A482
	dc	$2AD0F1
	dc	$2C0059
	dc	$2D3294
	dc	$2E677C
	dc	$2F9EE8
	dc	$30D8B1
	dc	$3214AC
	dc	$3352B0
	dc	$349290
	dc	$35D422
	dc	$371738
	dc	$385BA5
	dc	$39A13B
	dc	$3AE7CC
	dc	$3C2F2A
	dc	$3D7725
	dc	$3EBF8D
	dc	$400834
	dc	$4150E9
	dc	$42997D
	dc	$43E1C0
	dc	$452981
	dc	$467092
	dc	$47B6C3
	dc	$48FBE3
	dc	$4A3FC6
	dc	$4B823B
	dc	$4CC316
	dc	$4E0228
	dc	$4F3F45
	dc	$507A40
	dc	$51B2EF
	dc	$52E925
	dc	$541CBA
	dc	$554D85
	dc	$567B5E
	dc	$57A61D
	dc	$58CD9E
	dc	$59F1BB
	dc	$5B1252
	dc	$5C2F3F
	dc	$5D4863
	dc	$5E5D9D
	dc	$5F6ED0
	dc	$607BDE
	dc	$6184AD
	dc	$628923
	dc	$638927
	dc	$6484A3
	dc	$657B81
	dc	$666DAF
	dc	$675B19
	dc	$6843B1
	dc	$692767
	dc	$6A062D
	dc	$6ADFF9
	dc	$6BB4C2
	dc	$6C847D
	dc	$6D4F27
	dc	$6E14B8
	dc	$6ED52F
	dc	$6F9089
	dc	$7046C6
	dc	$70F7E9
	dc	$71A3F3
	dc	$724AEA
	dc	$72ECD3
	dc	$7389B6
	dc	$74219D
	dc	$74B490
	dc	$75429B
	dc	$75CBCC
	dc	$765031
	dc	$76CFD8
	dc	$774AD3
	dc	$77C132
	dc	$783308
	dc	$78A068
	dc	$790968
	dc	$796E1C
	dc	$79CE9A
	dc	$7A2AF9
	dc	$7A8350
	dc	$7AD7B8
	dc	$7B2849
	dc	$7B751D
	dc	$7BBE4C
	dc	$7C03F1
	dc	$7C4625
	dc	$7C8504
	dc	$7CC0A8
	dc	$7CF92C
	dc	$7D2EAA
	dc	$7D613E
	dc	$7D9101
	dc	$7DBE10
	dc	$7DE883
	dc	$7E1076
	dc	$7E3603
	dc	$7E5943
	dc	$7E7A4F
	dc	$7E9942
	dc	$7EB633
	dc	$7ED13A
	dc	$7EEA6F
	dc	$7F01EA
	dc	$7F17C0
	dc	$7F2C08
	dc	$7F3ED7
	dc	$7F5043
	dc	$7F605E
	dc	$7F6F3C
	dc	$7F7CF1
	dc	$7F898E
	dc	$7F9525
	dc	$7F9FC6
	dc	$7FA982
	dc	$7FB268
	dc	$7FBA86
	dc	$7FC1EB
	dc	$7FC8A4
	dc	$7FCEBE
	dc	$7FD443
	dc	$7FD941
	dc	$7FDDC2
	dc	$7FE1CF
	dc	$7FE572
	dc	$7FE8B4
	dc	$7FEB9E
	dc	$7FEE36
	dc	$7FF086
	dc	$7FF293
	dc	$7FF463
	dc	$7FF5FD
	dc	$7FF765
	dc	$7FF8A1
	dc	$7FF9B6
	dc	$7FFAA7
	dc	$7FFB79
	dc	$7FFC2F
	dc	$7FFCCB
	dc	$7FFD52
	dc	$7FFDC6
	dc	$7FFE28
	dc	$7FFE7B
	dc	$7FFEC2
	dc	$7FFEFD
	dc	$7FFF2F
	dc	$7FFF58
	dc	$7FFF7B
	dc	$7FFF97
	dc	$7FFFAE
	dc	$7FFFC0
	dc	$7FFFCF
	dc	$7FFFDB
	dc	$7FFFE4
	dc	$7FFFEC
	dc	$7FFFF1
	dc	$7FFFF6
	dc	$7FFFF9
	dc	$7FFFFB
	dc	$7FFFFD
	dc	$7FFFFE
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$80000A
	dc	$80031F
	dc	$800B24
	dc	$801818
	dc	$8029FA
	dc	$8040C9
	dc	$805C86
	dc	$807D2E
	dc	$80A2C1
	dc	$80CD3C
	dc	$80FC9F
	dc	$8130E8
	dc	$816A14
	dc	$81A821
	dc	$81EB0E
	dc	$8232D6
	dc	$827F79
	dc	$82D0F2
	dc	$83273E
	dc	$83825B
	dc	$83E244
	dc	$8446F7
	dc	$84B06E
	dc	$851EA6
	dc	$85919B
	dc	$860949
	dc	$8685AA
	dc	$8706BA
	dc	$878C74
	dc	$8816D3
	dc	$88A5D1
	dc	$89396A
	dc	$89D196
	dc	$8A6E51
	dc	$8B0F94
	dc	$8BB55A
	dc	$8C5F9B
	dc	$8D0E51
	dc	$8DC176
	dc	$8E7902
	dc	$8F34EF
	dc	$8FF535
	dc	$90B9CC
	dc	$9182AE
	dc	$924FD3
	dc	$932132
	dc	$93F6C3
	dc	$94D07F
	dc	$95AE5D
	dc	$969054
	dc	$97765B
	dc	$98606A
	dc	$994E78
	dc	$9A407C
	dc	$9B366B
	dc	$9C303E
	dc	$9D2DE9
	dc	$9E2F64
	dc	$9F34A4
	dc	$A03DA0
	dc	$A14A4C
	dc	$A25AA0
	dc	$A36E8F
	dc	$A48610
	dc	$A5A118
	dc	$A6BF9C
	dc	$A7E191
	dc	$A906EC
	dc	$AA2FA0
	dc	$AB5BA4
	dc	$AC8AEB
	dc	$ADBD6A
	dc	$AEF315
	dc	$B02BDF
	dc	$B167BE
	dc	$B2A6A4
	dc	$B3E886
	dc	$B52D56
	dc	$B67509
	dc	$B7BF92
	dc	$B90CE4
	dc	$BA5CF2
	dc	$BBAFB0
	dc	$BD050F
	dc	$BE5D04
	dc	$BFB780
	dc	$C11477
	dc	$C273DB
	dc	$C3D59F
	dc	$C539B4
	dc	$C6A00D
	dc	$C8089D
	dc	$C97355
	dc	$CAE027
	dc	$CC4F05
	dc	$CDBFE2
	dc	$CF32AF
	dc	$D0A75D
	dc	$D21DDF
	dc	$D39625
	dc	$D51022
	dc	$D68BC7
	dc	$D80904
	dc	$D987CD
	dc	$DB0810
	dc	$DC89C1
	dc	$DE0CD0
	dc	$DF912D
	dc	$E116CB
	dc	$E29D9A
	dc	$E4258B
	dc	$E5AE8F
	dc	$E73896
	dc	$E8C392
	dc	$EA4F74
	dc	$EBDC2B
	dc	$ED69AA
	dc	$EEF7DF
	dc	$F086BD
	dc	$F21634
	dc	$F3A634
	dc	$F536AD
	dc	$F6C792
	dc	$F858D1
	dc	$F9EA5B
	dc	$FB7C22
	dc	$FD0E16
	dc	$FEA026
	dc	$FFCDBC
	dc	$FE3BA0
	dc	$FCA995
	dc	$FB17AC
	dc	$F985F3
	dc	$F7F479
	dc	$F6634F
	dc	$F4D284
	dc	$F34228
	dc	$F1B249
	dc	$F022F7
	dc	$EE9442
	dc	$ED0638
	dc	$EB78EA
	dc	$E9EC67
	dc	$E860BD
	dc	$E6D5FD
	dc	$E54C35
	dc	$E3C374
	dc	$E23BCB
	dc	$E0B547
	dc	$DF2FF7
	dc	$DDABEC
	dc	$DC2933
	dc	$DAA7DD
	dc	$D927F6
	dc	$D7A98F
	dc	$D62CB7
	dc	$D4B17B
	dc	$D337EA
	dc	$D1C013
	dc	$D04A05
	dc	$CED5CE
	dc	$CD637C
	dc	$CBF31D
	dc	$CA84C1
	dc	$C91874
	dc	$C7AE45
	dc	$C64641
	dc	$C4E078
	dc	$C37CF6
	dc	$C21BC9
	dc	$C0BCFF
	dc	$BF60A5
	dc	$BE06C9
	dc	$BCAF79
	dc	$BB5AC0
	dc	$BA08AE
	dc	$B8B94D
	dc	$B76CAC
	dc	$B622D8
	dc	$B4DBDC
	dc	$B397C6
	dc	$B256A2
	dc	$B1187D
	dc	$AFDD62
	dc	$AEA55F
	dc	$AD707E
	dc	$AC3ECC
	dc	$AB1054
	dc	$A9E523
	dc	$A8BD44
	dc	$A798C2
	dc	$A677A8
	dc	$A55A02
	dc	$A43FDB
	dc	$A3293D
	dc	$A21634
	dc	$A106C9
	dc	$9FFB08
	dc	$9EF2FA
	dc	$9DEEAB
	dc	$9CEE23
	dc	$9BF16C
	dc	$9AF892
	dc	$9A039C
	dc	$991295
	dc	$982586
	dc	$973C78
	dc	$965774
	dc	$957683
	dc	$9499AD
	dc	$93C0FB
	dc	$92EC75
	dc	$921C24
	dc	$91500F
	dc	$90883F
	dc	$8FC4BB
	dc	$8F058B
	dc	$8E4AB6
	dc	$8D9443
	dc	$8CE239
	dc	$8C349F
	dc	$8B8B7D
	dc	$8AE6D7
	dc	$8A46B5
	dc	$89AB1E
	dc	$891416
	dc	$8881A3
	dc	$87F3CC
	dc	$876A96
	dc	$86E606
	dc	$866621
	dc	$85EAED
	dc	$85746D
	dc	$8502A6
	dc	$84959E
	dc	$842D57
	dc	$83C9D7
	dc	$836B20
	dc	$831138
	dc	$82BC20
	dc	$826BDC
	dc	$822070
	dc	$81D9DE
	dc	$819829
	dc	$815B54
	dc	$812360
	dc	$80F051
	dc	$80C228
	dc	$8098E6
	dc	$80748E
	dc	$805521
	dc	$803A9F
	dc	$80250B
	dc	$801464
	dc	$8008AD
	dc	$8001E4
	dc	$800027
	dc	$800C7E
	dc	$802C8F
	dc	$806056
	dc	$80A7CB
	dc	$8102E4
	dc	$817191
	dc	$81F3C3
	dc	$828964
	dc	$83325F
	dc	$83EE98
	dc	$84BDF3
	dc	$85A04F
	dc	$86958B
	dc	$879D7F
	dc	$88B804
	dc	$89E4EE
	dc	$8B240E
	dc	$8C7533
	dc	$8DD82A
	dc	$8F4CBB
	dc	$90D2AD
	dc	$9269C4
	dc	$9411C1
	dc	$95CA62
	dc	$979365
	dc	$996C81
	dc	$9B5570
	dc	$9D4DE4
	dc	$9F5590
	dc	$A16C24
	dc	$A3914E
	dc	$A5C4B8
	dc	$A8060D
	dc	$AA54F3
	dc	$ACB10E
	dc	$AF1A03
	dc	$B18F70
	dc	$B410F7
	dc	$B69E33
	dc	$B936C0
	dc	$BBDA37
	dc	$BE8830
	dc	$C14042
	dc	$C40201
	dc	$C6CD00
	dc	$C9A0D2
	dc	$CC7D05
	dc	$CF612B
	dc	$D24CCF
	dc	$D53F80
	dc	$D838C8
	dc	$DB3833
	dc	$DE3D49
	dc	$E14795
	dc	$E4569D
	dc	$E769E9
	dc	$EA80FF
	dc	$ED9B67
	dc	$F0B8A4
	dc	$F3D83C
	dc	$F6F9B5
	dc	$FA1C91
	dc	$FD4056
	dc	$FF9B78
	dc	$FC7756
	dc	$F953C0
	dc	$F63130
	dc	$F31025
	dc	$EFF117
	dc	$ECD484
	dc	$E9BAE5
	dc	$E6A4B6
	dc	$E39270
	dc	$E0848B
	dc	$DD7B82
	dc	$DA77CB
	dc	$D779DE
	dc	$D48231
	dc	$D19138
	dc	$CEA769
	dc	$CBC535
	dc	$C8EB10
	dc	$C61969
	dc	$C350AF
	dc	$C09151
	dc	$BDDBBB
	dc	$BB3059
	dc	$B88F92
	dc	$B5F9D0
	dc	$B36F78
	dc	$B0F0EF
	dc	$AE7E96
	dc	$AC18CF
	dc	$A9BFF9
	dc	$A7746F
	dc	$A5368C
	dc	$A306AA
	dc	$A0E51E
	dc	$9ED23C
	dc	$9CCE56
	dc	$9AD9BC
	dc	$98F4BC
	dc	$971F9F
	dc	$955AAE
	dc	$93A62F
	dc	$920266
	dc	$906F92
	dc	$8EEDF3
	dc	$8D7DC4
	dc	$8C1F3C
	dc	$8AD294
	dc	$8997FD
	dc	$886FA8
	dc	$8759C3
	dc	$865679
	dc	$8565F2
	dc	$848852
	dc	$83BDBD
	dc	$830651
	dc	$82622B
	dc	$81D163
	dc	$815411
	dc	$80EA47
	dc	$809416
	dc	$80518B
	dc	$8022B1
	dc	$80078E
	dc	$000040
	dc	$00003F
	dc	$00003E
	dc	$00003D
	dc	$00003C
	dc	$00003B
	dc	$00003A
	dc	$000039
	dc	$000038
	dc	$000037
	dc	$000036
	dc	$000035
	dc	$000034
	dc	$000034
	dc	$000033
	dc	$000032
	dc	$000031
	dc	$000030
	dc	$00002F
	dc	$00002F
	dc	$00002E
	dc	$00002D
	dc	$00002C
	dc	$00002C
	dc	$00002B
	dc	$00002A
	dc	$000029
	dc	$000029
	dc	$000028
	dc	$000027
	dc	$000026
	dc	$000026
	dc	$000025
	dc	$000024
	dc	$000024
	dc	$000023
	dc	$000023
	dc	$000022
	dc	$000021
	dc	$000021
	dc	$000020
	dc	$000020
	dc	$00001F
	dc	$00001E
	dc	$00001E
	dc	$00001D
	dc	$00001D
	dc	$00001C
	dc	$00001C
	dc	$00001B
	dc	$00001B
	dc	$00001A
	dc	$00001A
	dc	$000019
	dc	$000019
	dc	$000018
	dc	$000018
	dc	$000017
	dc	$000017
	dc	$000016
	dc	$000016
	dc	$000015
	dc	$000015
	dc	$000015
	dc	$000014
	dc	$000014
	dc	$000013
	dc	$000013
	dc	$000013
	dc	$000012
	dc	$000012
	dc	$000012
	dc	$000011
	dc	$000011
	dc	$000011
	dc	$000010
	dc	$000010
	dc	$000010
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$00003F
	dc	$000053
	dc	$000067
	dc	$00007B
	dc	$00000F
	dc	$000011
	dc	$000013
	dc	$000015
	dc	$000080
	dc	$000100
	dc	$000180
	dc	$000200
	dc	$000280
	dc	$000300
	dc	$000380
	dc	$000400
	dc	$000540
	dc	$0004D8
	dc	$000478
	dc	$000410
	dc	$000000
	dc	$000700
	dc	$000900
	dc	$000B00
	dc	$0004D0
	dc	$0004D0
	dc	$000440
	dc	$000400
	dc	$0003E0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000370
	dc	$000360
	dc	$000360
	dc	$000350
	dc	$000350
	dc	$000340
	dc	$000340
	dc	$000330
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000310
	dc	$000340
	dc	$000390
	dc	$0003E0
	dc	$000420
	dc	$000460
	dc	$000490
	dc	$0004A0
	dc	$000460
	dc	$000440
	dc	$000440
	dc	$000520
	dc	$000800
	dc	$000840
	dc	$000840
	dc	$0004F0
	dc	$0004F0
	dc	$000460
	dc	$000410
	dc	$0003E0
	dc	$0003D0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000370
	dc	$000360
	dc	$000360
	dc	$000350
	dc	$000350
	dc	$000340
	dc	$000340
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000320
	dc	$000350
	dc	$000390
	dc	$0003E0
	dc	$000420
	dc	$000450
	dc	$0004A0
	dc	$000490
	dc	$000460
	dc	$000440
	dc	$000480
	dc	$000630
	dc	$000840
	dc	$000840
	dc	$000580
	dc	$000580
	dc	$0004B0
	dc	$000450
	dc	$000420
	dc	$0003F0
	dc	$0003E0
	dc	$0003D0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000360
	dc	$000350
	dc	$000340
	dc	$000330
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000310
	dc	$000330
	dc	$000350
	dc	$0003C0
	dc	$000410
	dc	$000470
	dc	$0004A0
	dc	$000460
	dc	$000440
	dc	$000450
	dc	$0004E0
	dc	$0002F0
	dc	$0002B0
	dc	$000270
	dc	$000230
	dc	$0001F0
	dc	$000170
	dc	$0000F0
	dc	$FFF800
	dc	$000000
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000002
	dc	$000002
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000004
	dc	$000004
	dc	$000005
	dc	$000005
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$000000
	dc	$000005
	dc	$000007
	dc	$000003
	dc	$000007
	dc	$000004
	dc	$000005
	dc	$000006
	dc	$000007
	dc	$000008
	dc	$000009
	dc	$00000A
	dc	$00000B
	dc	$00000C
	dc	$00000E
	dc	$000010
	dc	$000009
	dc	$000003
	dc	$000001
	dc	$000019
	dc	$000005
	dc	$000001
	dc	$00000B
	dc	$000001
	dc	$000000
	dc	$008005
	dc	$00800F
	dc	$00000A
	dc	$00801B
	dc	$00001E
	dc	$000014
	dc	$008011
	dc	$008033
	dc	$000036
	dc	$00003C
	dc	$008039
	dc	$000028
	dc	$00802D
	dc	$008027
	dc	$000022
	dc	$008063
	dc	$000066
	dc	$00006C
	dc	$008069
	dc	$000078
	dc	$00807D
	dc	$008077
	dc	$000072
	dc	$000050
	dc	$008055
	dc	$00805F
	dc	$00005A
	dc	$00804B
	dc	$00004E
	dc	$000044
	dc	$008041
	dc	$0080C3
	dc	$0000C6
	dc	$0000CC
	dc	$0080C9
	dc	$0000D8
	dc	$0080DD
	dc	$0080D7
	dc	$0000D2
	dc	$0000F0
	dc	$0080F5
	dc	$0080FF
	dc	$0000FA
	dc	$0080EB
	dc	$0000EE
	dc	$0000E4
	dc	$0080E1
	dc	$0000A0
	dc	$0080A5
	dc	$0080AF
	dc	$0000AA
	dc	$0080BB
	dc	$0000BE
	dc	$0000B4
	dc	$0080B1
	dc	$008093
	dc	$000096
	dc	$00009C
	dc	$008099
	dc	$000088
	dc	$00808D
	dc	$008087
	dc	$000082
	dc	$008183
	dc	$000186
	dc	$00018C
	dc	$008189
	dc	$000198
	dc	$00819D
	dc	$008197
	dc	$000192
	dc	$0001B0
	dc	$0081B5
	dc	$0081BF
	dc	$0001BA
	dc	$0081AB
	dc	$0001AE
	dc	$0001A4
	dc	$0081A1
	dc	$0001E0
	dc	$0081E5
	dc	$0081EF
	dc	$0001EA
	dc	$0081FB
	dc	$0001FE
	dc	$0001F4
	dc	$0081F1
	dc	$0081D3
	dc	$0001D6
	dc	$0001DC
	dc	$0081D9
	dc	$0001C8
	dc	$0081CD
	dc	$0081C7
	dc	$0001C2
	dc	$000140
	dc	$008145
	dc	$00814F
	dc	$00014A
	dc	$00815B
	dc	$00015E
	dc	$000154
	dc	$008151
	dc	$008173
	dc	$000176
	dc	$00017C
	dc	$008179
	dc	$000168
	dc	$00816D
	dc	$008167
	dc	$000162
	dc	$008123
	dc	$000126
	dc	$00012C
	dc	$008129
	dc	$000138
	dc	$00813D
	dc	$008137
	dc	$000132
	dc	$000110
	dc	$008115
	dc	$00811F
	dc	$00011A
	dc	$00810B
	dc	$00010E
	dc	$000104
	dc	$008101
	dc	$008303
	dc	$000306
	dc	$00030C
	dc	$008309
	dc	$000318
	dc	$00831D
	dc	$008317
	dc	$000312
	dc	$000330
	dc	$008335
	dc	$00833F
	dc	$00033A
	dc	$00832B
	dc	$00032E
	dc	$000324
	dc	$008321
	dc	$000360
	dc	$008365
	dc	$00836F
	dc	$00036A
	dc	$00837B
	dc	$00037E
	dc	$000374
	dc	$008371
	dc	$008353
	dc	$000356
	dc	$00035C
	dc	$008359
	dc	$000348
	dc	$00834D
	dc	$008347
	dc	$000342
	dc	$0003C0
	dc	$0083C5
	dc	$0083CF
	dc	$0003CA
	dc	$0083DB
	dc	$0003DE
	dc	$0003D4
	dc	$0083D1
	dc	$0083F3
	dc	$0003F6
	dc	$0003FC
	dc	$0083F9
	dc	$0003E8
	dc	$0083ED
	dc	$0083E7
	dc	$0003E2
	dc	$0083A3
	dc	$0003A6
	dc	$0003AC
	dc	$0083A9
	dc	$0003B8
	dc	$0083BD
	dc	$0083B7
	dc	$0003B2
	dc	$000390
	dc	$008395
	dc	$00839F
	dc	$00039A
	dc	$00838B
	dc	$00038E
	dc	$000384
	dc	$008381
	dc	$000280
	dc	$008285
	dc	$00828F
	dc	$00028A
	dc	$00829B
	dc	$00029E
	dc	$000294
	dc	$008291
	dc	$0082B3
	dc	$0002B6
	dc	$0002BC
	dc	$0082B9
	dc	$0002A8
	dc	$0082AD
	dc	$0082A7
	dc	$0002A2
	dc	$0082E3
	dc	$0002E6
	dc	$0002EC
	dc	$0082E9
	dc	$0002F8
	dc	$0082FD
	dc	$0082F7
	dc	$0002F2
	dc	$0002D0
	dc	$0082D5
	dc	$0082DF
	dc	$0002DA
	dc	$0082CB
	dc	$0002CE
	dc	$0002C4
	dc	$0082C1
	dc	$008243
	dc	$000246
	dc	$00024C
	dc	$008249
	dc	$000258
	dc	$00825D
	dc	$008257
	dc	$000252
	dc	$000270
	dc	$008275
	dc	$00827F
	dc	$00027A
	dc	$00826B
	dc	$00026E
	dc	$000264
	dc	$008261
	dc	$000220
	dc	$008225
	dc	$00822F
	dc	$00022A
	dc	$00823B
	dc	$00023E
	dc	$000234
	dc	$008231
	dc	$008213
	dc	$000216
	dc	$00021C
	dc	$008219
	dc	$000208
	dc	$00820D
	dc	$008207
	dc	$000202
	dc	$000000
	dc	$007F81
	dc	$00FF02
	dc	$008083
	dc	$007E01
	dc	$000180
	dc	$008103
	dc	$00FE82
	dc	$00FC02
	dc	$008383
	dc	$000300
	dc	$007C81
	dc	$008203
	dc	$00FD82
	dc	$007D01
	dc	$000280
	dc	$007801
	dc	$000780
	dc	$008703
	dc	$00F882
	dc	$000600
	dc	$007981
	dc	$00F902
	dc	$008683
	dc	$008403
	dc	$00FB82
	dc	$007B01
	dc	$000480
	dc	$00FA02
	dc	$008583
	dc	$000500
	dc	$007A81
	dc	$00F002
	dc	$008F83
	dc	$000F00
	dc	$007081
	dc	$008E03
	dc	$00F182
	dc	$007101
	dc	$000E80
	dc	$000C00
	dc	$007381
	dc	$00F302
	dc	$008C83
	dc	$007201
	dc	$000D80
	dc	$008D03
	dc	$00F282
	dc	$008803
	dc	$00F782
	dc	$007701
	dc	$000880
	dc	$00F602
	dc	$008983
	dc	$000900
	dc	$007681
	dc	$007401
	dc	$000B80
	dc	$008B03
	dc	$00F482
	dc	$000A00
	dc	$007581
	dc	$00F502
	dc	$008A83
	dc	$006001
	dc	$001F80
	dc	$009F03
	dc	$00E082
	dc	$001E00
	dc	$006181
	dc	$00E102
	dc	$009E83
	dc	$009C03
	dc	$00E382
	dc	$006301
	dc	$001C80
	dc	$00E202
	dc	$009D83
	dc	$001D00
	dc	$006281
	dc	$001800
	dc	$006781
	dc	$00E702
	dc	$009883
	dc	$006601
	dc	$001980
	dc	$009903
	dc	$00E682
	dc	$00E402
	dc	$009B83
	dc	$001B00
	dc	$006481
	dc	$009A03
	dc	$00E582
	dc	$006501
	dc	$001A80
	dc	$009003
	dc	$00EF82
	dc	$006F01
	dc	$001080
	dc	$00EE02
	dc	$009183
	dc	$001100
	dc	$006E81
	dc	$006C01
	dc	$001380
	dc	$009303
	dc	$00EC82
	dc	$001200
	dc	$006D81
	dc	$00ED02
	dc	$009283
	dc	$00E802
	dc	$009783
	dc	$001700
	dc	$006881
	dc	$009603
	dc	$00E982
	dc	$006901
	dc	$001680
	dc	$001400
	dc	$006B81
	dc	$00EB02
	dc	$009483
	dc	$006A01
	dc	$001580
	dc	$009503
	dc	$00EA82
	dc	$00C002
	dc	$00BF83
	dc	$003F00
	dc	$004081
	dc	$00BE03
	dc	$00C182
	dc	$004101
	dc	$003E80
	dc	$003C00
	dc	$004381
	dc	$00C302
	dc	$00BC83
	dc	$004201
	dc	$003D80
	dc	$00BD03
	dc	$00C282
	dc	$00B803
	dc	$00C782
	dc	$004701
	dc	$003880
	dc	$00C602
	dc	$00B983
	dc	$003900
	dc	$004681
	dc	$004401
	dc	$003B80
	dc	$00BB03
	dc	$00C482
	dc	$003A00
	dc	$004581
	dc	$00C502
	dc	$00BA83
	dc	$003000
	dc	$004F81
	dc	$00CF02
	dc	$00B083
	dc	$004E01
	dc	$003180
	dc	$00B103
	dc	$00CE82
	dc	$00CC02
	dc	$00B383
	dc	$003300
	dc	$004C81
	dc	$00B203
	dc	$00CD82
	dc	$004D01
	dc	$003280
	dc	$004801
	dc	$003780
	dc	$00B703
	dc	$00C882
	dc	$003600
	dc	$004981
	dc	$00C902
	dc	$00B683
	dc	$00B403
	dc	$00CB82
	dc	$004B01
	dc	$003480
	dc	$00CA02
	dc	$00B583
	dc	$003500
	dc	$004A81
	dc	$00A003
	dc	$00DF82
	dc	$005F01
	dc	$002080
	dc	$00DE02
	dc	$00A183
	dc	$002100
	dc	$005E81
	dc	$005C01
	dc	$002380
	dc	$00A303
	dc	$00DC82
	dc	$002200
	dc	$005D81
	dc	$00DD02
	dc	$00A283
	dc	$00D802
	dc	$00A783
	dc	$002700
	dc	$005881
	dc	$00A603
	dc	$00D982
	dc	$005901
	dc	$002680
	dc	$002400
	dc	$005B81
	dc	$00DB02
	dc	$00A483
	dc	$005A01
	dc	$002580
	dc	$00A503
	dc	$00DA82
	dc	$005001
	dc	$002F80
	dc	$00AF03
	dc	$00D082
	dc	$002E00
	dc	$005181
	dc	$00D102
	dc	$00AE83
	dc	$00AC03
	dc	$00D382
	dc	$005301
	dc	$002C80
	dc	$00D202
	dc	$00AD83
	dc	$002D00
	dc	$005281
	dc	$002800
	dc	$005781
	dc	$00D702
	dc	$00A883
	dc	$005601
	dc	$002980
	dc	$00A903
	dc	$00D682
	dc	$00D402
	dc	$00AB83
	dc	$002B00
	dc	$005481
	dc	$00AA03
	dc	$00D582
	dc	$005501
	dc	$002A80
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000004
	dc	$000000
	dc	$800000
	dc	$C00000
	dc	$E00000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$000006
	dc	$000007
	dc	$000008
	dc	$000009
	dc	$00000A
	dc	$00000B
	dc	$00000C
	dc	$00000D
	dc	$00000E
	dc	$00000F
	dc	$000010
	dc	$000011
	dc	$000012
	dc	$000013
	dc	$000014
	dc	$000015
	dc	$000016
	dc	$000017
	dc	$000018
	dc	$000019
	dc	$00001A
	dc	$00001B
	dc	$00001C
	dc	$00001F
	dc	$000022
	dc	$000025
	dc	$000028
	dc	$00002B
	dc	$00002E
	dc	$000031
	dc	$000037
	dc	$00003D
	dc	$000043
	dc	$000049
	dc	$00004F
	dc	$000055
	dc	$000061
	dc	$00006D
	dc	$000079
	dc	$000085
	dc	$00009D
	dc	$0000B5
	dc	$0000CD
	dc	$0000E5
	dc	$0000FD
	dc	$000500
	dc	$000500
	dc	$000571
	dc	$000572
	dc	$000780
	dc	$000780
	dc	$800000
	dc	$000000
	dc	$A57D86
	dc	$5A827A
	dc	$89BE51
	dc	$30FBC5
	dc	$CF043B
	dc	$7641AF
	dc	$8275A1
	dc	$18F8B8
	dc	$B8E313
	dc	$6A6D99
	dc	$959267
	dc	$471CED
	dc	$E70748
	dc	$7D8A5F
	dc	$809DC9
	dc	$0C8BD3
	dc	$AECC33
	dc	$62F202
	dc	$8F1D34
	dc	$3C56BA
	dc	$DAD7F4
	dc	$7A7D05
	dc	$8582FB
	dc	$25280C
	dc	$C3A946
	dc	$70E2CC
	dc	$9D0DFE
	dc	$5133CD
	dc	$F3742D
	dc	$7F6237
	dc	$802778
	dc	$0647D9
	dc	$AA0A5B
	dc	$5ED77D
	dc	$8C4A14
	dc	$36BA20
	dc	$D4E0CB
	dc	$788484
	dc	$83D604
	dc	$1F19F9
	dc	$BE31E2
	dc	$6DCA0D
	dc	$99307F
	dc	$4C3FE0
	dc	$ED37F0
	dc	$7E9D56
	dc	$8162AA
	dc	$12C810
	dc	$B3C020
	dc	$66CF81
	dc	$9235F3
	dc	$41CE1E
	dc	$E0E607
	dc	$7C29FC
	dc	$877B7C
	dc	$2B1F35
	dc	$C945E0
	dc	$73B5EC
	dc	$A12883
	dc	$55F5A5
	dc	$F9B827
	dc	$7FD888
	dc	$000000
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000001
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000003
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000005
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$000002
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000003
	dc	$000004
	dc	$000004
	dc	$000005
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\loader.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			loader.asm
;												
;   Contents:		Loader for Dolby Game Encoder
;
;	Author:			jmw
;											
;	Revision:		1.00b
;											
;	History:
;
;		Rev 1.00	10/11/2000 7:23:25 AM		jmw
;	          Created.
;               Rev 1.00b       12/11/2000 4:11:12 PM           Ethan Brodsky
;        	  brought DMA code over from Dolby/v1.20 package
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'Dolby Loader'

	section	Loader

;**** include files ************************************************

	nolist
	include 'ldr_sip.inc'
	include 'eputil.h'    ; EP constants
	include 'dmautil.h'   ; DMA constants
	list

;**** equates ******************************************************



	DEFINE	PREAMBLE	'1'		; Enable AC3 SPDIF Preamble
	DEFINE	ZEROFILL	'1'		; Enable AC3 SPDIF Zero Fill

ROM_BASE        equ             $800
ROM_SIZE        equ             $800
XRAM_BUFFER     equ             $400



;**** program code *************************************************

	xref	LdrTable


	org		p(100):				; Loader Runtime Counter is 100

;******************************************************************************
;*										  
;*   Subroutine Name:	Loader
;*								  
;*   Description:		Loader
;*										      
;*   Input:				a	- Buffer ID word
;*						b	- Loader action
;*						r0	- DSP memory address
;*						n0	- number of words to transfer
;*						n1	- System memory offset
;*
;*   Output:			a	- error return code: nonzero if error
;*
;*   Modifies:			
;*
;*	 Locals:			
;*
;*	 Stack Space Used:	
;*										      
;******************************************************************************

loader:

	cmp		#LID_LOADER_INIT,a		; loader init request?
	beq		<loader_init		    ; if so, go init the loader

	cmp		#LID_PING_PONG,a		; should we toggle the PCM input ping pong
	beq		<toggle_ping_pong

        bra             <done

;***********************************************************************
;	Data storage for loader variables

temp                    dc          0
dmaNode	                dc	    0
dmaNode1                dc	    0
dmaNode2	            dc	    0
dmaNode3	            dc	    0
dmaNode4	            dc	    0
dmaNode5	            dc	    0
dmaNode6	            dc	    0
prev_time                   dc      0
elapsed_time                dc      0


;***********************************************************************
;	Toggle ping pong buffer on PCM input

toggle_ping_pong:

        ; first read the EP boot rom into xram offset

        move    #>XRAM_BUFFER,r0
        move    #>ROM_BASE,r4

        dor     #ROM_SIZE,CopyRomLoop

        move    y:(r4)+,x0
        move    x0,x:(r0)+

CopyRomLoop

        ; now that the rom contents are in ram, DMA them into FIFO0
        move    #>XRAM_BUFFER,r0     
        move    #>ROM_SIZE,n0
        move    #>0,r1
        jsr     CopyDSPXToSys


	bra		<done					; exit


;***********************************************************************
;	Exit points

done:

	clr		a						; no error status
	rts
												  


;***********************************************************************
;	Loader initialization code
;		Copies loader table from system memory to DSP memory
;		Clears dynamic table entries
;		Initializes local heap variables

loader_init:
	clr	a #LdrTable+LDR_HEAP_ADDR,r0		; set up pointer
	dor	#LDR_NUM_DATA*2,clrlp
	move	a,p:(r0)+						; clear table value
clrlp:


	bsr	DMAInit					; one-time DMA initialization
	
	bra	<done					; exit

;******************************************************************************
;*										  
;*   Subroutine Name:	CopySysToDSPX
;*								  
;*   Description:	Copy from System Memory to DSP x: space
;*										      
;*   Input:		r0 	- DSP address (x:)
;*			n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopySysToDSPX:
	IF		@DEF('RTSYS')
	jsr		set_timing
	ENDIF

; Note: Dolby-only testing code
;	dor		n0,systoxlp
;	move	x:(r1)+,x0
;	move	x0,x:(r0)+
;systoxlp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_XRAM,a 		; adjust DSP address for X base
	move	a1,r0
	
	jsr	DMANewNode_Read			; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)

	IF		@DEF('RTSYS')
	jsr		clr_timing
	ENDIF
	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopyDSPXToSys
;*								  
;*   Description:	Copy from DSP x: space to System Memory
;*										      
;*   Input:		r0 	- DSP address (x:)
;*			n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopyDSPXToSys:
	IF		@DEF('RTSYS')
	jsr		set_timing
	ENDIF
	
; Note: Dolby-only testing code
;	dor		n0,xtosyslp
;	move	x:(r0)+,x0
;	move	x0,x:(r1)+
;xtosyslp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_XRAM,a 		; adjust DSP address for X base
	move	a1,r0
	
	jsr	DMANewNode_Write		; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)
        
	IF		@DEF('RTSYS')
	jsr		clr_timing
	ENDIF
	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopyDSPXToFIFO
;*								  
;*   Description:	Copy from DSP x: space to FIFO
;*									      
;*   Input:		r0 	- DSP address (x:)
;*			n0	- number of words to copy
;*			r1	- FIFO index
;*										      
;******************************************************************************

CopyDSPXToFIFO:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_XRAM,a 		; adjust DSP address for X base
	move	a1,r0
	
	jsr	DMANewNode_WriteFIFO		; create DMA node

CopyDSPXToFIFOStart:
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)
        
	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopySysToDSPY
;*								  
;*   Description:	Copy from System Memory to DSP y: space
;*		       							      
;*   Input:	 	r0 	- DSP address (y:)
;*			n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopySysToDSPY:

; Note: Dolby-only testing code
;	dor		n0,systoylp
;	move	x:(r1)+,x0
;	move	x0,y:(r0)+
;systoylp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_YRAM,a 		; adjust DSP address for Y base
	move	a1,r0
	
	jsr	DMANewNode_Read			; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)

	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopyDSPYToSys
;*								  
;*   Description:	Copy from DSP y: space to System Memory
;*										      
;*   Input:		r0 	- DSP address (y:)
;*	   		n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopyDSPYToSys:

; Note: Dolby-only testing code
;	dor		n0,ytosyslp
;	move	y:(r0)+,x0
;	move	x0,x:(r1)+
;ytosyslp:


	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_YRAM,a 		; adjust DSP address for Y base
	move	a1,r0
	
	jsr	DMANewNode_Write		; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)

	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopySysToDSPP
;*								  
;*   Description:	Copy from System Memory to DSP p: space
;*										      
;*   Input:	 	r0 	- DSP address (p:)
;*			n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopySysToDSPP:

; Note: Dolby-only testing code
;	dor		n0,systoplp
;	move	x:(r1)+,x0
;	move	x0,p:(r0)+
;	nop
;systoplp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_PRAM,a 		; adjust DSP address for Y base
	move	a1,r0
	
	jsr	DMANewNode_Read			; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)

	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopyDSPPToSys
;*								  
;*   Description:	Copy from DSP p: space to System Memory
;*										      
;*   Input:	       	r0 	- DSP address (p:)
;*		  	n0	- number of words to copy
;*		       	r1	- System Memory address
;*										      
;******************************************************************************

CopyDSPPToSys:
	
; Note: Dolby-only testing code
;	dor		n0,ptosyslp
;	move	p:(r0)+,x0
;	move	x0,x:(r1)+
;ptosyslp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_PRAM,a 		; adjust DSP address for Y base
	move	a1,r0
	
	jsr	DMANewNode_Write		; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)
	rts
	
	
;************************************************************
; DMANewNode_Read
;
;	This DMA Read node is configured for the System
;	Memory -> DSP transfer
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r4	node DSP PRAM address
;			r0	DSP Memory address
;			r1	System Memory address
;           n0      Length
;************************************************************
DMANewNode_Read

	jsr 	DMAWaitForIdle			    ; Wait fro DMA to be idle

; Word0
	move	r4,r5			; r5 <- copy of node base 
	
	move	r4,a1
	and		#>kDMANode_EOLMask,a	; Clear reserved upper bits
	or		#>kDMANode_EOL,a 	; set EOL bit
	
    movem   a1,p:(r5)+		; Link to itself			
; Word1
    move    #>DMA_BASE_READ1_ISO,a1
    ;move    #>DMA_BASE_READ1,a1
	movem	a1,p:(r5)+
; Word2
	movem	n0,p:(r5)+		; Length       	
; Word3
	movem	r0,p:(r5)+		; DSP RAM address (System memory space)	
; Word4						
	move	r1,a
	lsl		#2,a					
	movem	a1,p:(r5)+		; System memory address


 	rts
; ---- end DMANewNode_Read


;************************************************************
; DMANewNode_Write     	
;
;	This DMA Write node is configured for the DSP -> SM
;	transfer 
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r4	node DSP PRAM address
;			r0	DSP Memory address 
;			r1	System Memory address
;			n0	Length
;************************************************************
DMANewNode_Write	

	jsr 	DMAWaitForIdle			    ; Wait fro DMA to be idle

; Word0
	move	r4,r5			; r5 <- copy of node base 
	
	move	r4,a1
	and		#>kDMANode_EOLMask,a	; Clear reserved upper bits
	or		#>kDMANode_EOL,a	; set EOL bit
    	
; Word0
	move    a1,p:(r5)+		; Link to itself			

; Word1
    	move    #>DMA_BASE_WRITE1_ISO,a1
        ;move    #>DMA_BASE_WRITE1,a1
	movem	a1,p:(r5)+			
; Word2
	movem	n0,p:(r5)+		; Length
; Word3
	movem	r0,p:(r5)+		; DSP RAM address (System memory space)	
; Word4	
	move	r1,a
	lsl		#2,a					
	movem	a1,p:(r5)+		; System memory address

 	rts
; ---- end DMANewNode_Write ----

;************************************************************
; DMANewNode_WriteFIFO
;
;	This DMA Write node is configured for the DSP -> FIFO
;	transfer 
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r4	node DSP PRAM address
;			r0	DSP Memory address 
;			r1	FIFO number
;			n0	Length
;			n4  NULL output flag
;************************************************************
DMANewNode_WriteFIFO

	jsr 	DMAWaitForIdle			    ; Wait fro DMA to be idle

; Word0
	move	r4,r5			; r5 <- copy of node base 
	
	move	r4,a1
	and		#>kDMANode_EOLMask,a	; Clear reserved upper bits
	or		#>kDMANode_EOL,a	; Set EOL bit
    	
	move    a1,p:(r5)+		; Link to itself			

; Word1
        ;move    #>DMA_BASE_WRITEFIFO1_ISO,a1 	; start with "write to FIFO/16-bit" control word
        move #>DMA_BASE_WRITEFIFO_DATA_ISO,a1
        move	r1,b			; FIFO index from r1
        lsl	#5,b			; shift FIFO index smBufId bits
        move	b,x1
	or	x1,a			; put FIFO index into control word
	movem	a1,p:(r5)+		; write control word
; Word2
	movem	n0,p:(r5)+			
; Word3
	move	n4,a			; Null Flag
        lsl	#14,a
	move	r0,x0
	add	x0,a			; Add DSP Address
	movem	a1,p:(r5)+		; DSP RAM address (System memory space)	
; Word4 is no longer used

 	rts
; ---- end DMANewNode_WriteFIFO ----


;************************************************************
; DMANewNode_WriteFIFOInterleaved
;
;	This DMA Write node is configured for the DSP -> FIFO
;	transfer 
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r4	node DSP PRAM address
;			r0	DSP Memory address 
;			r1	FIFO number
;			n0	Length
;			n2  Channels per block
;			n4  NULL output flag
;************************************************************
DMANewNode_WriteFIFOInterleaved

	jsr 	DMAWaitForIdle			    ; Wait fro DMA to be idle

; Word0
	move	r4,r5			; r5 <- copy of node base 
	
	move	r4,a1
	and 	#>kDMANode_EOLMask,a	; Clear reserved upper bits
	or		#>kDMANode_EOL,a	; Set EOL bit
	move    a1,p:(r5)+		; Link to itself			

; Word1
    move    #>DMA_BASE_WRITEFIFO2_ISO,a1 	; start with "write to FIFO/16-bit interleaved" control word
    ;move    #>DMA_BASE_WRITEFIFO2,a1
	move	r1,b			; FIFO index from r1
    lsl	    #5,b			; shift FIFO index smBufId bits
	move	b,x1
	or	    x1,a			; put FIFO index into control word

	move	n0,b			; Set Incr value
    lsl	    #14,b			; shift incr value bits (Increment by size of a single channel buffer)
	move	b,x1
	or	    x1,a			; put FIFO index into control word
	movem	a1,p:(r5)+		; write control word
; Word2
	move	n0,b			; Set Length value
    lsl	    #4,b			; shift Length bits (Increment by size of a single channel buffer)
	move	n2,x1
	add		x1,b			; Add samples per block
	movem	b1,p:(r5)+		; write control word
; Word3
	move	n4,a			; Null Flag
    lsl	    #14,a
	move	r0,x0
	add		x0,a			; Add DSP Address
	movem	a1,p:(r5)+		; DSP RAM address (System memory space)	
; Word4 is no longer used

 	rts
; ---- end DMANewNode_WriteFIFO ----





;************************************************************
; DMAWaitForStop	
;
;		Alters DMA Running state 
;************************************************************
DMAWaitForIdle 


; Wait for DMA engine to enter Idle state: 0 = Idle, 1 = Running
	jset 	#kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAWaitForIdle

; Clear DMA EndofList, Bit 7
	movep    #$80,x:INTERRUPT_REGISTER	; "Write-1-To-Clear-One" 

 	rts
; ---- end DMAStopAndFreeze ----

;************************************************************
; DMAStart
;
;		Alters DMA Running state 
;************************************************************
DMAStart 


; Write "run" command
    movep    #>kDMA_ActionRequest_Start,x:DMA_CONTROL_REGISTER	

; Wait for DMA engine to enter Running state: 0 = Idle, 1 = Running
DMAUnFreezeAndStart_WaitForStart
;	jset	#kDMAErrorBit,x:INTERRUPT_REGISTER,DMAError
	jclr 	#kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAUnFreezeAndStart_WaitForStart

 	rts
; ---- end DMAUnFreezeAndStart ----

;************************************************************
; DMAWaitForEOL		Wait for DMA EOL interrupt and clear register bit
;************************************************************
DMAWaitForEOL 

; Poll for DMA EOL interrupt
DMAWaitForEOL_Poll
	jset	#kDMAErrorBit,x:INTERRUPT_REGISTER,DMAError
	jclr 	#kDMAEndOfListBit,x:INTERRUPT_REGISTER,DMAWaitForEOL_Poll

; Clear DMA EndofList, Bit 7
	movep    #$80,x:INTERRUPT_REGISTER	; "Write-1-To-Clear-One" 

    ;debug_wait


 	rts
; ---- end DMAWaitForEOL ----

;************************************************************
; DMAStartNodeP_Wait	
;
;	Replace start block, initiate transfer and Wait for
;				completion
;
;	This function assumes a single DMA node that is
;	setup as the EOL block.
;
;	Parameters:  	 r4	next node DSP PRAM address
;************************************************************
DMAStartNodeP_Wait 
	
	move	r4,a
	add		#kEPMemory_Base_PRAM,a			; block is in PRAM 
	movep	a,x:DMA_NEXT_BLOCK_CONTROL_REGISTER
	
	jsr 	DMAStart			        ; Start transfer
	
    clr     b
    move    n5,b
    cmp     #0,b
    beq     DMAStartNodeP_NoWait

	jsr 	DMAWaitForEOL				; Wait for completion

DMAStartNodeP_NoWait
 	rts
; ---- end DMAStartNodeX_Wait ----


;******************************************************************************
;*
;*   Subroutine Name:	DMAInit             
;*
;*   Description:		Inits the EP for DMA (based on Gints' GP code)
;*
;******************************************************************************
;
;

DMAInit:
	;GPClearInterruptRegister
	movep    #$FFF,x:INTERRUPT_REGISTER	 ; "Write-1-To-Clear-One"
	
	;GPClearProcessingControlRegister
	movep    #$1,x:PROCESSING_CONTROL_REGISTER	 ; "Set Idle bit"	

	;GPClearSampleControlRegister
	movep    #$0,x:SAMPLE_CONTROL_REGISTER	 
	
	;abort any DMA transfers
;    movep    #>kDMA_ActionRequest_Abort,x:DMA_CONTROL_REGISTER

    move    #$4000,x0	
	move    x0,x:DMA_START_BLOCK_CONTROL_REGISTER
	move    x0,x:DMA_NEXT_BLOCK_CONTROL_REGISTER

	;GPClearDMAConfigRegister 
	movep    #>0,x:DMA_CONFIGURATION_REGISTER

	rts


DMAError
	bra	DMAError




;** Loader Status

;status_active	dc	0
;status_ID		dc	-1
;status_action	dc	-1
;status_dspaddr	dc	-1
;status_length	dc	-1
;status_sysaddr	dc	-1
;status_wait		dc	0

	endsec
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\ldr_sip.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			ldr_sip.inc
;												
;   Contents:		Loader Software Interface Protocol (SIP) for 
;					Dolby Game Encoder
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	8/16/2000 12:07:45 PM		jmw
;	Created.
;
;
; ******************************************************************

;	Loader system equates

LDR_HDR_SIZE		equ		4		; program header size

;	Buffer ID equates

LID_MIN				equ		0		; min valid ID
LID_MAX				equ		31		; max valid ID

LID_LOADER_INIT		equ		0		; Loader initialization request

LID_PROG_DSURRE		equ		1		; Dolby Surround Encoder program
LID_PROG_DGAME1		equ		2		; Dolby Game Encoder #1 program
LID_PROG_DGAME2		equ		3		; Dolby Game Encoder #2 program
LID_PROG_DGAME3		equ		4		; Dolby Game Encoder #3 program

LID_MAX_PROG		equ		4		; max valid program ID

LID_BUF_PCM			equ		5		; Input PCM buffer
LID_BUF_LTRT		equ		6		; Output Lt/Rt buffer
LID_BUF_AC3			equ		7		; Output AC-3 buffer

LID_CONFIG_LIST		equ		8		; system configuration data		

LID_PING_PONG		equ		9		; NVIDIA ping pong Loader ID
LID_AC3_ZEROS		equ		10
LID_AC3_PREAMBLE	equ		11
LID_BUF_DATA		equ		12		; Output data buffer base

LDR_NUM_DATA		equ		(LID_MAX-LID_BUF_DATA+1)	; max # data buffers

;	Loader table equates

LDR_TABLE_SIZE		equ		((LID_MAX+1)*2)			; DSP loader table size
LDR_SYSTABLE_SIZE	equ		((LID_BUF_DATA+1)*2)	; SysMem loader table size
LDR_HEAP_ADDR		equ		(LID_BUF_DATA*2)		; heap address offset
LDR_HEAP_SIZE		equ		((LID_BUF_DATA*2)+1)	; heap size offset
LDR_PINGPONG_OFFSET equ     (LID_PING_PONG*2)

;	Action equates

LDR_ACT_MIN			equ		0		; min valid action

LDR_ACT_ALLOC		equ		0		; allocate data buffer
LDR_ACT_TO_DSPX		equ		1		; copy to DSP x:
LDR_ACT_FROM_DSPX	equ		2		; copy from DSP x:
LDR_ACT_TO_DSPY		equ		3		; copy to DSP y:
LDR_ACT_FROM_DSPY	equ		4		; copy from DSP y:
LDR_ACT_TO_DSPP		equ		5		; copy to DSP p:
LDR_ACT_FROM_DSPP	equ		6		; copy from DSP p:

LDR_ACT_MAX			equ		6		; max valid action

;	PCM offset equates

LDR_OFF_PCM_L		equ		0		; left PCM offset
LDR_OFF_PCM_C		equ		1		; center PCM offset
LDR_OFF_PCM_R		equ		2		; right PCM offset
LDR_OFF_PCM_LS		equ		3		; left surround PCM offset
LDR_OFF_PCM_RS		equ		4		; right surround PCM offset
LDR_OFF_PCM_LFE		equ		5		; LFE PCM offset

LDR_OFF_PCM_LT		equ		0		; left total PCM offset
LDR_OFF_PCM_RT		equ		1		; right total PCM offset

;	Error codes

LDR_ERR_NONE		equ		0		; no error
LDR_ERR_ID			equ		1		; invalid buffer ID
LDR_ERR_ACTION		equ		2		; invalid action
LDR_ERR_LENGTH		equ		3		; invalid length/offset combination
LDR_ERR_ALLOC		equ		4		; buffer allocation error
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\suprexec.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			Suprexec.asm
;												
;   Contents:		Superexec for Dolby Game Encoder
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	8/16/2000 3:51:37 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'Dolby Super Exec'

	section	SuperExec

;**** include files ************************************************

	nolist
	include 'ldr_sip.inc'
	include	'se_sip.inc'
	include 'eputil.h'        
	list

;**** Development Switches *****************************************

	IF			@DEF('SIM_XBOX_SYS_MEM') 	
 		DEFINE		TRASH_DSP_MEMORY	   	'1'		; Overwrite DSP memory each block
	ENDIF

;*** Switches (leave defined for X-Box) ****************************

	DEFINE		PERF_COUNTERS                       '1'
	DEFINE		INFINITE_LOOP_IF_TIME_OVERRUN		'1'
	;DEFINE		ERRHALT								'1'		; Halt on loader error	

;**** Development External References ******************************

	IF		@DEF('RTSYS')						; Dolby development HW only
		xref	rt_init,rt_input,rt_output
	ENDIF

	IF		@DEF('SIM_XBOX_SYS_MEM')			; Motorola simulator only
		xref	CopyInFilesToSysMem
		xref	CopySysMemToOutputFiles
		xref	Copy6ChInFileToSysMem
		xref	CopySysMemToAC3OutputFile
	ENDIF

;**** equates ******************************************************


;MAX_EP_CYCLES		  		equ		1060000 ;200mhz
;MAX_EP_CYCLES		  		equ		850000  ;160mhz
MAX_EP_CYCLES		  		equ     708000  ;133mhz

STACK_EXTSZ					equ		32		; stack extension size
CONFIG_SIZE					equ		32		; config data size
SE_NUM_BLOCKS				equ		6		; number of blocks per frame (6)
PMEMSIZE					equ		$001000	; p: is 4k words
YMEMSIZE					equ		$000100	; y: is 256 words
TRASHWORD					equ		$ffffff	; overwrite memory with this word

MONO_DNMIX_CODE				equ		$000001	; 
STEREO_DNMIX_CODE			equ		$000002	;

;	IF	@DEF('PERF_COUNTERS')
;MAX_TIMES_IGNORE_TIMER_AFTER_REBOOT		equ		0
;	ENDIF	; 	IF	@DEF('PERF_COUNTERS')

;*******************************************************************
;	Super Exec sets up stack extension at top of x: RAM.
	
	mode	rel
	org		x(201):					; place stack at top of RAM.

stack_ext	ds	STACK_EXTSZ			; stack extension

;*******************************************************************
; 	Config List from System. Place immediately below stack extension.

	mode	rel
	org		x(204):

config_list		ds	CONFIG_SIZE

;;;;; Note: Interrupt vectors are in ROM on nVidia system

;**** code *********************************************************
;	Start Program Code Here.

	mode	rel
	org		p(202):

SuperExec:

	bra		<SEStart				; skip over local variables

;	Local Variables

supexec_blknum	    dc		0 			; to sync all functions to same block.
surr_reset	    	dc		1 			; surround reset flag - init to one (!)
game_reset	    	dc		1 			; game encoder reset flag - init to one (!)

	IF @DEF('PERF_COUNTERS')
elapsed_time        dc      0
prev_time           dc      0
suprexec_temp	    dc	    $cccccc		; $cccccc is no time overflow, $bbbbbb if exceed 5.33 ms.
count               dc      0			; allows algorithm to exceed 5.33 ms during reboot only.
	ENDIF	; IF @DEF('PERF_COUNTERS')

;*******************************************************************
;	Start SuperExec Program Code.  

SEStart:

	IF @DEF('PERF_COUNTERS')
        ; init timer variables

        move    #0,x0
        move    x0,p:elapsed_time
        move    x0,p:prev_time

        ; setup timer registers

        movep   #$FFFFFF,x:TIMER1_TERMINAL_COUNT
        movep   #1,x:TIMER1_CONFIG

        ; start the timer from 0
        movep   #1,x:TIMER1_CONTROL
	ENDIF	; IF @DEF('PERF_COUNTERS')


;	Enable Stack extension.

	movec	#0,sp					; reset the stack pointer
	movec	#stack_ext,ep			; init extension pointer register
	movec	#STACK_EXTSZ,sz			; init stack size register
	bset	#20,omr					; enable stack extension

;	Enable any counters, etc. at reset.
	
	clr		a					   	; a0 = 0
	move	a0,p:supexec_blknum		; start with block zero at reset
	inc		a					   	; a0 = 1
	move	a0,p:surr_reset			; explicitly set reset flag
	move	a0,p:game_reset			; explicitly set reset flag

;	Initialize the loader

	move	#>LID_LOADER_INIT,a		; Packet ID
	jsr	LOADERBASE				; Call the Loader



;	Clear the start frame bit
	EPClearStartFrameBit

	
;*******************************************************************
;	Enter Endless Loop to process each of the four possible Functions
;	in series.	Note that we might not process the function; it depends upon
;	the corresponding flag in the config_list.

;	1. Dolby Surround OR Downmix Function if Surround Not Enabled
;	2. Dolby Game Encoder Function 1
;	3. Dolby Game Encoder Function 2
;	4. Dolby Game Encoder Function 3

SELoop:

	IF @DEF('PERF_COUNTERS')
        move    p:count,a
        add     #1,a
        move    a,p:count
	ENDIF	; 	IF @DEF('PERF_COUNTERS')

; Write the idle bit
	EPSetIdleBit

;	Wait for Start Frame bit.
	clr     a
waitframe:
	add     #1,a
	jclr 	#kStartFrameBit,x:INTERRUPT_REGISTER,waitframe

	IF @DEF('PERF_COUNTERS')
        ;***********************************************************************
        move    x:TIMER1_COUNT,x0
        movem   x0,p:prev_time
        ;***********************************************************************
    ENDIF	; IF @DEF('PERF_COUNTERS')


ClearStartFrameBit:
; Clear GP Start Block (bit 1)
	EPClearStartFrameBit	


;	Increment the ping-pong for pcm input

	move	#>LID_PING_PONG,a					; Packet ID
	jsr    	LOADERBASE							; Call the Loader


	IF @DEF('PERF_COUNTERS')
        ;***********************************************************************
		;
		; This section checks to see if we exceed time limit,
		; and if we did, it enters INFINITE LOOP (a VERY HARD CRASH).
		;
        move    x:TIMER1_COUNT,a	; calculate time algorithm took to run
        movem   p:prev_time,x0
        sub     x0,a        
        movem   a1,p:elapsed_time	; save it in elapsed time
        
        move    #MAX_EP_CYCLES,x0	; compare elapsed time to max allowed
        cmpu    x0,a
        blt     <SELoop				; if algoithm did NOT exceed, keep processing.

;        move    p:count,a			; if algorithm DID exceed, check if this happened
;									; immediately after chip rebooted. 
;        cmp     #>MAX_TIMES_IGNORE_TIMER_AFTER_REBOOT,a
;        blt     <SELoop				; If it did, ignore.

        move    #$bbbbbb,x0			; MAJOR FAILURE!  Algorithm exceed 5.33 ms allowed time.
        move    x0,p:suprexec_temp	; write tag to indicate failure.
		
		IF	@DEF('INFINITE_LOOP_IF_TIME_OVERRUN')
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		bra		<*					; HARD CRASH - INFINITE LOOP to isolate problem during debugging.
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		ENDIF	; IF @DEF('INFINITE_LOOP_IF_TIME_OVERRUN')

        IF      @DEF('ERRHALT')
        bra     <*
        ENDIF
        ;***********************************************************************
	ENDIF	; 	IF @DEF('PERF_COUNTERS')


        ; stop here
	;bra	<SELoop
        bra     <*
		
         
	
;*******************************************************************
	endsec		; SuperExec
	end			; end of file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\eputil.h ===
;*******************************************************************
;
;    EpUtil.h		Global header file for Encode Audio Processor   
;
;
;       Modified by Ethan Brodsky
;		Based on EpUtil.h Written by Gints Klimanis, September 2000
;
;
;******************************************************************        

kFrameLength	equ		32
kPCValue		equ		0
kCounter		equ		0

; ==============================================================
; EP Address Map 
; ==============================================================
; Relative to EPBase (24 bit words (3 bytes) in 32-bit containers (4 bytes))
;     0x0000 - 0x2FFC   EP DSP X-Memory 3K Words (24 lsbits of Dword)     
;     0x6000 - 0x63FC   EP DSP Y-Memory 256 Words (24 lsbits of Dword) 
;     0xA000 - 0xDFFC   EP DSP P-Memory 4K Words (24 lsbits of Dword) 
;     0xFE00 - 0xFFF8   EP DSP Peripheral Registers
;     0xFFFC            EP DSP Reset
;
; Peripheral registers (Control,Status) mapped to upper 128 words
; of X-memory (0xFFFF80 to 0xFFFFFF) so they can be accessed with movep 
;
; EP DSP memory addresses 24-bit words
; System memory address    8-bit words 

kEPMemory_Base		equ $000000
kEPMemory_Base_XRAM	equ (kEPMemory_Base+$000000)
kEPMemory_Base_YRAM	equ (kEPMemory_Base+$001800)
kEPMemory_Base_PRAM	equ (kEPMemory_Base+$002800)

kEPMemory_Size_XRAM	equ 3072
kEPMemory_Size_YRAM	equ 256
kEPMemory_Size_PRAM	equ 4096

kEPMemory_Base_BootROM			equ $FF0000	; X-memory, 128 words
;kEPMemory_Base_PeripheralRegisters	equ $FFFF80	; X-memory, to 0xFFFFFF

INTERRUPT_TABLE_BASE 		equ $FF0000

; VBA at $FF0000 (requires 256 word alignment).  
; The vector table is exactly where the power-up reset starts fetching instructions.
; The first interrupt vector is hardware RESET.
; Only needs up to $24 (36d) .. $44 (68d) interrupts or so, not full 256 word table.

INTERRUPT_REGISTER		equ $FFFFC5	; Interrupt request/clear register
kAbortFrameBit		equ		0			; Bit 0
kStartFrameBit		equ		1			
kPutUpdateBit		equ		2
kMailInUpdateBit	equ		3
kDMAComplete1Bit	equ		4
kDMAComplete2Bit	equ		5
kDMAComplete3Bit	equ		6	
kDMAEndOfListBit	equ		7
kTimer1Bit			equ		8
kTimer2Bit			equ		9
kDMAErrorBit		equ		10
kAddressErrorBit	equ		11

; ==============================================================
;  FIFO stuff  
; ==============================================================
FIFOOUT_CONTROL_REGISTER	equ		$FFFFC8
FIFOIN_CONTROL_REGISTER		equ		$FFFFC9
SAMPLE_CONTROL_REGISTER		equ		$FFFFCA

kFIFO_Channels1			equ	$0
kFIFO_Channels2			equ	$1
kFIFO_Channels4			equ	$2
kFIFO_Channels6			equ	$3

kFIFO_SampleFormat08	equ	$0
kFIFO_SampleFormat16	equ	$1
kFIFO_SampleFormat24	equ	$2
kFIFO_SampleFormat32	equ	$3

; Output FIFO Configuration word:  
;   Bits 4:3  Sample Format = 10  (24-bits, 3 byte words ??)
;   Bits   2  Iso Bit       = 0 
;   Bits 1:0  # channels    = 2    (Stereo)
; 10-0-10 = $12
kFifoOut0_DefaultWord	equ	$12	

; Current Value is bits 23:2  (22 bits)	(from dev_apu.ref)
NV_PAPU_EPOFCUR0  equ	$0000302C 
NV_PAPU_EPOFCUR1  equ	$0000303C 
NV_PAPU_EPOFCUR2  equ	$0000304C 
NV_PAPU_EPOFCUR3  equ	$0000305C 

; End Value is bits 23:8  (16 bits) (from dev_apu.ref)
NV_PAPU_EPOFEND0  equ	$00003028 
NV_PAPU_EPOFEND1  equ	$00003038 
NV_PAPU_EPOFEND2  equ	$00003048 
NV_PAPU_EPOFEND3  equ	$00003058 

; Base Value is bits 23:8 (16 bits) (from dev_apu.ref)
NV_PAPU_EPOFBASE0  equ	$00003024 
NV_PAPU_EPOFBASE1  equ	$00003034 
NV_PAPU_EPOFBASE2  equ	$00003044 
NV_PAPU_EPOFBASE3  equ	$00003054 

; ==============================================================
;  Command stuff		Bits 11:2  offset in 4KB circular buffer
; ==============================================================
kEPMemory_Base_CommandCue		equ $FFF000		; Top 4KByte page

COMMAND_GET_REGISTER 		equ $FFFFC0	; Ptr to next read location
COMMAND_PUT_REGISTER 		equ $FFFFC1	; Ptr to 1st empty write location


MAILBOX_OUT                 equ $ffffC2
MAILBOX_IN                  equ $ffffC3

TIMER1_COUNT                equ $ffffB3
TIMER2_COUNT                equ $ffffB7


; ==============================================================
;  Processing control
; ==============================================================
PROCESSING_CONTROL_REGISTER		equ $FFFFC4	
kProcessingControl_SetIdleBit				equ 0		; Bit 0
kProcessingControl_NotifyInterruptBit		equ 1		

; ==============================================================
;  Global Sample Count Register		Bits 23:0
; ==============================================================
GLOBAL_SAMPLE_COUNT_REGISTER		equ $FFFFC6	

;************************************************************
; EPClearInterruptRegister	Clear  EP register
;************************************************************
EPClearInterruptRegister macro
      	movep    #$FFF,x:INTERRUPT_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end EPClearInterruptRegister ----

;************************************************************
; EPClearProcessingControlRegister	Clear  EP register
;************************************************************
EPClearProcessingControlRegister macro
      	movep    #$3,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"	
	endm
; ---- end EPClearProcessingControlRegister ----

;************************************************************
; EPClearSampleControlRegister	Clear  EP register
;************************************************************
EPClearSampleControlRegister macro
      	movep    #$0,x:SAMPLE_CONTROL_REGISTER	 
	endm
; ---- end EPClearSampleControlRegister ----

;************************************************************
; EPSetIdleBit		Assert EP Idle signal (Bit 0)
;************************************************************
EPSetIdleBit macro
	movep    #1,x:PROCESSING_CONTROL_REGISTER	 ; "Write-1-To-Clear-One"
	endm
; ---- end EPSetIdleBit ----

;************************************************************
; EPClearStartFrameBit		Start Frame (Bit 1)
;************************************************************
EPClearStartFrameBit macro
	movep    #2,x:INTERRUPT_REGISTER  ; "Write-1-To-Clear-One"	
	endm
; ---- end EPClearStartFrameBit ----

;************************************************************
; EPClearDataRAM	 Zero-fill X and Y memories
;************************************************************
EPClearDataRAM macro
	jsr	 EPClearXRAM
	jsr	 EPClearYRAM
	endm
; ---- end EPClearDataRAM ----

;************************************************************
; EPWritePC	 For IKOS debug, write Program Counter value to memory
;************************************************************
EPWritePC macro
	move	#0,r5
	lra		r5,x0	; yep, here's the PC relative address PC+0
	move	x0,a
	nop				; to avoid warnings
	dec		a
	nop				; to avoid warnings
	move	a,y:kCounter
	endm
; ---- end EPWritePC ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\llef13.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 01/10/01, 11:04:55
;	Program info
;	  Program number: 2
;	  Revision number: 1.51
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2100 words
;	  Checksum: $5A7702

		dc	$D01B40,$000834,$020133,$5A7702,$447000,$00095F,$607000,$000962
		dc	$20000B,$05A407,$0508DF,$0D1080,$0007AA,$0D1080,$0007DD,$050C05
		dc	$0D1080,$0007B0,$0D1080,$0007CA,$0508D9,$62F000,$000962,$60F400
		dc	$000FC2,$0A72D8,$000004,$240000,$447000,$000960,$5EE800,$0212DF
		dc	$20000B,$05A402,$014180,$547000,$000961,$44F000,$000960,$050952
		dc	$050811,$44F000,$000960,$0D1080,$0007D4,$56F000,$000960,$014180
		dc	$44F000,$000961,$547000,$000960,$200045,$0597D0,$0D1080,$000798
		dc	$00000C,$56F000,$000960,$44F000,$00095F,$0C1940,$008020,$547000
		dc	$00093D,$56F000,$000960,$200003,$05245A,$62F000,$000962,$60F400
		dc	$00094D,$44F400,$000080,$060690,$000002,$445800,$02129E,$0212D4
		dc	$0C1940,$00101B,$547000,$000930,$44F413,$000012,$0C1940,$005021
		dc	$547000,$000934,$021ADE,$022A94,$0C1940,$001021,$0222D4,$0C1940
		dc	$001022,$022294,$0C1940,$001023,$547000,$000935,$200013,$0242D4
		dc	$0C1940,$00201A,$547000,$000941,$021A94,$447000,$000942,$200013
		dc	$0232D4,$0C1940,$001018,$022AD4,$0C1940,$001019,$547000,$00093E
		dc	$023A94,$447000,$000940,$023294,$447000,$00093F,$60F413,$00092C
		dc	$57F400,$000010,$0D1080,$0002A9,$44F400,$000000,$200045,$057400
		dc	$00000C,$30001B,$0D1080,$0002A1,$00000C,$44F400,$000015,$447000
		dc	$00092C,$44F400,$00094D,$447000,$00092D,$44F400,$000959,$447000
		dc	$00092E,$44F400,$000953,$447000,$00092F,$44F400,$00FFFF,$447000
		dc	$000933,$44F400,$000941,$447000,$000936,$240000,$447000,$000931
		dc	$447000,$000932,$447000,$000937,$447000,$000938,$447000,$000939
		dc	$447000,$00093A,$447000,$00093B,$447000,$00093C,$60F400,$000947
		dc	$44F400,$000000,$445800,$44F400,$000002,$445800,$44F400,$000003
		dc	$445800,$44F400,$000004,$445800,$44F400,$000001,$445800,$44F400
		dc	$000005,$445800,$60F400,$000959,$44F400,$000001,$060690,$000002
		dc	$445800,$60F400,$000953,$44F400,$00FFFF,$060690,$000002,$445800
		dc	$00000C,$62F000,$000962,$45F400,$000003,$021296,$2000E0,$62F400
		dc	$000F92,$210E00,$200040,$60F400,$000080,$219A00,$70F400,$000100
		dc	$56F400,$000005,$79EA00,$0D0180,$200003,$052400,$00000C,$230800
		dc	$00000A,$04C8A0,$0461A0,$0464A0,$0465A0,$0004F8,$230E00,$200022
		dc	$219800,$221400,$044811,$223500,$5FE000,$4FE100,$5EE078,$06D810
		dc	$000009,$45D919,$200016,$8F8000,$8AB868,$4FE119,$200016,$CF1C00
		dc	$CA1D78,$230E00,$223022,$219800,$221400,$044811,$223500,$5FE000
		dc	$4FE100,$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868
		dc	$4FE119,$200016,$CF1C00,$CA1D78,$223000,$221400,$044811,$223500
		dc	$5FE000,$45E100,$5EE06C,$06D810,$000009,$4FD919,$200016,$8F8000
		dc	$8AB878,$45E119,$200016,$CF1C00,$CA1D6C,$230E00,$3A0222,$223000
		dc	$219900,$221100,$233200,$221400,$66F400,$000F52,$204900,$223500
		dc	$045A18,$231C00,$231D00,$205200,$5FE000,$F4C100,$4CDE00,$4FD9AE
		dc	$5EE0BF,$06DA10,$000020,$06D210,$000007,$8F8016,$45E1EE,$8AB8CB
		dc	$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016,$8AA8EE,$45E1CB,$CF0C16
		dc	$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016,$45E1AE,$8AB8BF,$CF1C16
		dc	$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE,$F4C1BF,$4CDE00,$CF0C16
		dc	$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032,$21B900,$219A00,$0CCD80
		dc	$FFFFCA,$380200,$221400,$231C00,$235200,$66F400,$000F52,$045811
		dc	$231900,$223500,$231D00,$205200,$5FE000,$F4C100,$4CDE00,$4FC9AE
		dc	$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16,$06D210,$000010
		dc	$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$F4C1BF,$4CDE00,$CF0C16
		dc	$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16,$4FC9EA
		dc	$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF,$05F420,$00FFFF,$574C16
		dc	$0461A0,$564D00,$0464A0,$0465A0,$00F3B8,$00000C,$71F400,$FFFFFE
		dc	$75F400,$FFFFFC,$229600,$06DA10,$00001A,$F0B900,$06DE10,$00000A
		dc	$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D3,$10DD00
		dc	$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D3
		dc	$564C00,$03F18E,$22D400,$229000,$239800,$0460A4,$00000C,$71F400
		dc	$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021,$57DA00,$51D200
		dc	$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409,$444C4C,$03F184
		dc	$555A00,$515A00,$22D400,$229000,$239800,$0460A4,$00000C,$44C800
		dc	$2000A0,$44C814,$200011,$06DE10,$000005,$180CA0,$44C8BA,$200014
		dc	$200011,$182400,$2000BA,$00000C,$46C813,$2000E1,$06DE10,$000003
		dc	$46C800,$564CE1,$566400,$00000C,$394000,$233D00,$204900,$204D00
		dc	$045112,$045516,$06D910,$000004,$46D900,$B0B200,$445600,$38FF00
		dc	$231C00,$204100,$204500,$044812,$044C16,$380200,$72F400,$FFFFFE
		dc	$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5659C8,$D088EB
		dc	$063F90,$000005,$D5CAD4,$575DF3,$5659C8,$D088EB,$575D00,$204000
		dc	$204400,$387F00,$231A00,$231C00,$231E00,$204100,$204500,$204000
		dc	$204A00,$204400,$204E00,$380200,$72F400,$FFFFFE,$3C0200,$76F400
		dc	$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8,$D088EB,$063F90,$000005
		dc	$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00,$00000C,$F1C000,$4DDA00
		dc	$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006,$F1C0A7,$4DDA00,$4ED8C8
		dc	$565CEB,$5F64B0,$2000A7,$565C00,$00000C,$F1C000,$4DDA00,$4EE1C8
		dc	$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB,$5F65B0,$06DA10,$00000A
		dc	$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0,$44D9A7,$5F64C8,$565CEB
		dc	$5F65B0,$2000A7,$565D00,$00000C,$F1C000,$4DDA00,$4EC8A8,$2000BB
		dc	$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00,$4EC8A8,$564CBB,$574DE0
		dc	$2000C7,$564C00,$00000C,$F1C100,$4DDA00,$4EE1A8,$4EE0BB,$44C8E0
		dc	$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7,$06DA10,$00000B,$F1C100
		dc	$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0
		dc	$574DC7,$564C00,$00000C,$56D800,$06D910,$000007,$0C1E01,$20003E
		dc	$23A403,$02A048,$56D800,$575900,$205000,$00000C,$46F400,$000001
		dc	$23AE00,$223555,$05A40D,$22B400,$06DC10,$000009,$56F400,$7FFFFF
		dc	$06DD10,$000004,$44DC00,$200045,$027040,$544D00,$223500,$234F00
		dc	$56E20B,$052406,$44F400,$00000F,$200045,$027040,$546200,$218500
		dc	$06DC10,$000004,$56E500,$218564,$544D00,$223500,$238759,$45F400
		dc	$000002,$56E500,$45F465,$FFFFFE,$057417,$45F465,$000002,$059411
		dc	$204D58,$20007D,$05744D,$0597D6,$56E500,$45F465,$FFFFFE,$057413
		dc	$45F465,$000002,$059406,$204D58,$20007D,$057442,$0597CB,$05A7D5
		dc	$20455C,$05A40D,$56E500,$200054,$544D00,$56E500,$45F450,$000002
		dc	$544500,$050FC0,$45F454,$000002,$546500,$050FC7,$234E00,$204D03
		dc	$05A407,$56E200,$200054,$546200,$56E500,$200050,$546500,$56E200
		dc	$200054,$546200,$56E500,$45F450,$000002,$546558,$050F8B,$223500
		dc	$45E200,$06DC10,$000005,$56E500,$200060,$218500,$544D00,$23AE00
		dc	$223555,$05A409,$22B400,$06DC10,$000006,$44CD00,$06DD10,$000002
		dc	$445C00,$000000,$00000C,$44F000,$000B41,$56F000,$000B97,$200045
		dc	$05A413,$209600,$60F400,$000180,$61F400,$000241,$56F400,$000BA5
		dc	$22C400,$200040,$219200,$71E200,$06D910,$000005,$44D900,$56E000
		dc	$0C1E48,$545800,$050C10,$56F000,$000B7E,$200003,$05A40C,$60F400
		dc	$000235,$61F400,$0002F6,$390700,$06D910,$000005,$44D900,$56E000
		dc	$0C1E48,$545800,$00000C,$05F420,$FFFFFF,$0461A0,$0462A0,$0464A0
		dc	$0465A0,$0466A0,$00F3B8,$44F400,$000000,$20004D,$05A40C,$44F400
		dc	$000010,$20004D,$0D104A,$000011,$300000,$56F400,$000000,$57F400
		dc	$FFFFFF,$00000C,$200013,$567000,$000912,$300000,$56F400,$000000
		dc	$57F400,$000608,$00000C,$050857,$050911,$0D1080,$0000B9,$56F000
		dc	$000B96,$200003,$05744D,$0D1080,$000163,$0D1080,$0001A6,$0D1080
		dc	$0001E9,$240000,$447000,$00092B,$56F000,$000B41,$44F000,$000B97
		dc	$200045,$05A409,$0D1080,$00013B,$0D1080,$000210,$557000,$00092B
		dc	$0D1080,$0002F8,$0D1080,$000310,$0D1080,$00031F,$0D1080,$00037A
		dc	$0D1080,$000336,$56F000,$000B41,$200003,$0D100A,$000421,$0D1080
		dc	$000383,$0D1080,$0003B0,$0D1080,$0003CB,$0D1080,$FFFF86,$200013
		dc	$21101B,$00000C,$205800,$44D800,$447000,$000B42,$44D800,$447000
		dc	$000B43,$44D800,$447000,$000B44,$57D800,$0C1890,$002024,$507000
		dc	$000B7B,$0C1890,$00101B,$507000,$000B7E,$0C1890,$003018,$507000
		dc	$000B7D,$44D800,$447000,$000B45,$44D800,$447000,$000B46,$44D800
		dc	$447000,$000B47,$57D800,$0C1890,$006020,$507000,$000B7C,$57D800
		dc	$0C1890,$001023,$507000,$00023D,$0C1890,$001022,$507000,$00023E
		dc	$0C1890,$001021,$507000,$00023F,$0C1890,$004018,$507000,$000240
		dc	$61D800,$380600,$204800,$57D900,$0C1890,$00201A,$507000,$000B4E
		dc	$57D900,$015F8E,$577000,$000B49,$57D800,$0C1890,$008018,$507000
		dc	$000B41,$0C1890,$008020,$507000,$000B40,$57D800,$0C1890,$001018
		dc	$507000,$000B4C,$0C1890,$001019,$507000,$000B4A,$57D800,$577000
		dc	$000B4B,$57E000,$577000,$000B4D,$00000C,$56F000,$000240,$44F400
		dc	$000009,$200045,$202741,$547000,$000240,$56F000,$000B49,$44F400
		dc	$00001F,$45F445,$000000,$202741,$200065,$202961,$547000,$000B49
		dc	$56F000,$000B7D,$44F400,$000007,$45F445,$000006,$05A40D,$44F465
		dc	$000003,$05A40A,$45F445,$000002,$05A407,$44F465,$000001,$05A404
		dc	$200045,$05A402,$208E00,$547000,$000B7D,$00000C,$56F000,$000912
		dc	$44F400,$020765,$200045,$052406,$56F000,$000B40,$200003,$05A45E
		dc	$00000C,$60F413,$0004FD,$060690,$000003,$545800,$545800,$60F413
		dc	$0005A8,$060590,$000002,$545800,$60F413,$00057B,$062890,$000002
		dc	$545800,$60F413,$0005AE,$065A90,$000002,$545800,$60F413,$000608
		dc	$060590,$000002,$545800,$60F413,$00060D,$060590,$000002,$545800
		dc	$60F413,$000509,$061090,$000002,$545800,$60F413,$000519,$060890
		dc	$000002,$545800,$60F413,$000521,$063C90,$000002,$545800,$60F413
		dc	$00055D,$061E90,$000002,$545800,$60F413,$000612,$060093,$000002
		dc	$545800,$44F400,$020765,$447000,$000912,$44F400,$000000,$447000
		dc	$000B96,$61F400,$000FC2,$71F000,$000B7D,$44F000,$000B7E,$5EE900
		dc	$547040,$000B97,$547000,$000B98,$44F01B,$000B97,$2D0513,$2C024D
		dc	$05945A,$44F01B,$000B98,$2D0613,$2C024D,$059455,$56F000,$000B7C
		dc	$200023,$547000,$000B99,$44F01B,$000B7B,$2D0313,$2C044D,$05944B
		dc	$44F01B,$000B99,$2D1313,$2C034D,$059446,$56F000,$000B7C,$0140C4
		dc	$000024,$21DA00,$44F000,$000B7B,$46F400,$000006,$2344D0,$0C1D2E
		dc	$44F440,$000F4C,$200040,$219100,$5EE100,$21CF22,$218422,$200022
		dc	$577040,$000B9A,$218500,$21E46C,$46F400,$000008,$21A7D0,$5070E8
		dc	$000B9D,$457000,$000B9B,$5170B0,$000B9E,$477000,$000B9C,$507000
		dc	$000B9F,$050C03,$547000,$000B96,$00000C,$56F400,$000914,$44F000
		dc	$000B41,$200040,$219100,$56E100,$0C1E01,$44F43E,$000001,$20004C
		dc	$20291B,$45F403,$000003,$02A068,$20006D,$027068,$56F400,$000B61
		dc	$44F000,$000B41,$200040,$219000,$556000,$00000C,$44F000,$000B7D
		dc	$46F400,$000006,$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040
		dc	$219400,$56F000,$000B44,$4CE400,$200040,$219100,$05E120,$56F000
		dc	$000B42,$4CE400,$200040,$219100,$56F000,$000B43,$4CE400,$200040
		dc	$219200,$44F400,$000100,$46E200,$2000D0,$240022,$210600,$2400D0
		dc	$46E200,$2400D2,$0C1D2E,$44E140,$200040,$219000,$70E200,$64F400
		dc	$0002FD,$3C0100,$3EFF00,$45F400,$3FF7CF,$56F000,$00023F,$200003
		dc	$05A40F,$56F000,$000B41,$44F432,$0004FD,$200040,$219100,$47F400
		dc	$000347,$57D900,$51D100,$0D04E7,$555900,$516100,$050C02,$0D04F4
		dc	$05F420,$00FFFF,$00000C,$56F000,$000B41,$44F000,$000B97,$200045
		dc	$05A44D,$56F000,$00023D,$200003,$05A45B,$60F400,$0002FD,$221400
		dc	$380100,$231C00,$44F000,$000B41,$46F400,$00000C,$44F4D0,$000521
		dc	$0C1D2E,$200040,$219100,$44F000,$000B41,$46F400,$000006,$44F4D0
		dc	$00055D,$0C1D2E,$200040,$219200,$56F000,$000240,$0140C4,$000007
		dc	$21DA00,$234400,$46F400,$00000F,$44F4D0,$000814,$0C1D2E,$200040
		dc	$219500,$3A0300,$3EFF00,$0D049E,$050C13,$56F000,$00023E,$200003
		dc	$05A40F,$60F400,$0002FD,$221400,$380100,$231C00,$61F400,$000509
		dc	$62F400,$000519,$65F400,$000800,$3A0400,$3EFF00,$0D04BF,$00000C
		dc	$44F000,$000B7D,$46F400,$000006,$44F0D0,$000B41,$0C1D2E,$44F440
		dc	$000F92,$200040,$219100,$4CE100,$447000,$000913,$61F400,$0002FD
		dc	$200013,$44D91B,$060091,$000004,$200047,$029040,$44D98A,$60F400
		dc	$0005A8,$70F000,$000B41,$200032,$44E826,$566847,$029040,$21C700
		dc	$56F400,$000914,$44F000,$000B41,$200040,$219000,$476000,$0C1C91
		dc	$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A,$0C1D2E,$200040
		dc	$219000,$555800,$516000,$00000C,$60F400,$0002FD,$64F400,$0003FD
		dc	$380100,$231C00,$44F000,$000B41,$46F400,$000008,$44F4D0,$00057B
		dc	$0C1D2E,$200040,$219100,$65F400,$0008A2,$3A0200,$3EFF00,$0D049E
		dc	$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040
		dc	$219000,$380E00,$61F400,$0003FD,$204800,$060490,$000009,$200013
		dc	$064090,$000004,$44D900,$200047,$029040,$200026,$565800,$44F000
		dc	$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000
		dc	$380800,$57F400,$000002,$204800,$380600,$060290,$00000B,$221100
		dc	$044812,$06CD10,$000006,$44DA00,$56DA00,$200045,$029040,$565900
		dc	$20402A,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E
		dc	$200040,$219000,$380600,$62F400,$0008AF,$390200,$45F41B,$000001
		dc	$20A600,$060390,$00000D,$221100,$4FDA00,$204900,$44D100,$06C610
		dc	$000004,$44C9C0,$44D145,$027068,$20CE00,$204832,$218600,$44F000
		dc	$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000
		dc	$380200,$44F400,$003200,$56E800,$200045,$20291B,$44F000,$000B41
		dc	$46F400,$000002,$44F4D0,$00091A,$0C1D2E,$200040,$219100,$56F400
		dc	$000608,$44F000,$000B41,$200040,$219000,$44E100,$46F400,$7FFFFF
		dc	$44E0D0,$200045,$20291B,$56F400,$000926,$44F000,$000B41,$200040
		dc	$219000,$556000,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE
		dc	$0C1D2E,$200040,$219000,$380600,$62F400,$0008AC,$390200,$20A61B
		dc	$060390,$00000D,$221100,$4FDA00,$204900,$44D100,$06C610,$000004
		dc	$44C9C0,$44D145,$027068,$20CE00,$204832,$218600,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380200
		dc	$44F400,$003200,$56E800,$200045,$20291B,$44F000,$000B41,$46F400
		dc	$000002,$44F4D0,$00091A,$0C1D2E,$200040,$219100,$56F400,$000608
		dc	$44F000,$000B41,$200040,$219000,$44E100,$46F400,$400000,$46E0D0
		dc	$446055,$20291B,$56F400,$000B7F,$44F000,$000B41,$200040,$219000
		dc	$556000,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E
		dc	$200040,$219000,$380600,$20AE00,$060390,$00000A,$221100,$219900
		dc	$221200,$204900,$44D900,$445A00,$44D900,$445A00,$204832,$00000C
		dc	$56F400,$000B7F,$44F000,$000B41,$200040,$219000,$56F400,$00060D
		dc	$44F000,$000B41,$200040,$219100,$56F400,$000B84,$44F000,$000B41
		dc	$200040,$219200,$44E01B,$56E100,$45F442,$000001,$02A068,$576200
		dc	$446100,$00000C,$60F400,$0002FD,$44F000,$000B41,$46F400,$000080
		dc	$44F4D0,$000612,$0C1D2E,$200040,$219100,$64F400,$0008B2,$65F400
		dc	$000000,$0D04FC,$00000C,$56F000,$00092B,$200003,$05A40E,$60F400
		dc	$000000,$61F400,$000040,$221400,$223500,$62F400,$000AB2,$66F400
		dc	$000AF2,$3A3F00,$0D054D,$050C0A,$60F400,$000000,$221400,$62F400
		dc	$0009B2,$66F400,$000A32,$3A7F00,$0D053E,$00000C,$0500A0,$0461A0
		dc	$56F000,$00092B,$200003,$05A415,$60F400,$000000,$61F400,$000040
		dc	$64F400,$0003FD,$65F400,$0004FC,$62F400,$000AB2,$66F400,$000AF2
		dc	$382000,$231900,$3A3F00,$3C0300,$75F400,$FFFFFD,$0D0573,$050C11
		dc	$60F400,$000000,$64F400,$0003FD,$65F400,$0004FC,$62F400,$0009B2
		dc	$66F400,$000A32,$384000,$3A7F00,$3C0200,$75F400,$FFFFFE,$0D0564
		dc	$05F420,$00FFFF,$0461A0,$56F000,$000B41,$44F000,$000B97,$60F445
		dc	$0003FD,$05A408,$61F400,$000180,$06B590,$000003,$44D800,$445900
		dc	$050C07,$61F400,$000235,$060790,$000003,$44D800,$445900,$00000C
		dc	$56F000,$00092B,$200003,$05A40A,$60F400,$000000,$384000,$0D03EF
		dc	$60F400,$000040,$384000,$0D03EF,$050C05,$60F400,$000000,$388000
		dc	$0D03EF,$00000C,$56F000,$000B97,$44F000,$000B41,$45F445,$000001
		dc	$05A403,$05080D,$050C03,$457000,$000B8F,$60F400,$000B7F,$61F400
		dc	$0005A3,$060590,$000003,$44D800,$445900,$00000C,$290300,$70F000
		dc	$000B41,$60F400,$000B7F,$56E800,$014185,$05A410,$60F400,$000926
		dc	$56E800,$014185,$05A40B,$56F000,$000B40,$014085,$05A406,$60F400
		dc	$0005A3,$56E800,$014185,$05A402,$290200,$60F400,$000B8A,$516800
		dc	$00000C,$3D1800,$44F000,$000B41,$56F000,$000B97,$60F445,$000180
		dc	$05A40C,$209600,$61F400,$000241,$56F400,$000BA5,$22C400,$200040
		dc	$219200,$71E200,$0D058B,$050C0A,$56F000,$000B7E,$60F403,$000235
		dc	$05A405,$61F400,$0002F6,$390700,$0D058B,$00000C,$44F000,$000B41
		dc	$56F000,$000B97,$61F445,$000241,$05A459,$56F400,$000B8A,$44F000
		dc	$000B41,$200040,$219000,$56F400,$000BA5,$44F000,$000B41,$200040
		dc	$219200,$56E000,$71E200,$219400,$223600,$56F400,$000B5C,$44F000
		dc	$000B41,$200040,$219000,$56F400,$000B91,$44F000,$000B41,$200040
		dc	$219200,$232E00,$014184,$0B74C4,$000F16,$218500,$47F4AD,$000001
		dc	$0B74C4,$000F12,$21E600,$209DD0,$0C1D2E,$46F465,$2AAAAB,$202978
		dc	$556000,$21A500,$21BCE9,$0C1D82,$200010,$200065,$202978,$556200
		dc	$223200,$205900,$3A0000,$0D0596,$050C11,$56F000,$000B7E,$60F403
		dc	$000B8F,$05A40C,$61F400,$0002F6,$390700,$223600,$223200,$205900
		dc	$3A0000,$3C0600,$7DF000,$000F13,$0D0596,$00000C,$56F000,$000240
		dc	$0C1D04,$21C700,$46F400,$000003,$2000B0,$0C1D2E,$0140C0,$000049
		dc	$21C600,$61F400,$000BA0,$62F400,$000BA5,$45F000,$000B97,$06C510
		dc	$000003,$475900,$465A00,$57F400,$000001,$56F000,$000B40,$200003
		dc	$05A402,$20001B,$577000,$000B90,$00000C,$56F400,$00000D,$57F400
		dc	$000000,$70F400,$000416,$0BF080,$000180,$200003,$052400,$00000C
		dc	$56F400,$00000D,$57F400,$000001,$60F400,$0004FD,$70F400,$000416
		dc	$390000,$0BF080,$000180,$200003,$052400,$00000C,$56F400,$00000D
		dc	$57F400,$000002,$60F400,$0004FD,$70F400,$000416,$390000,$0BF080
		dc	$000180,$200003,$052400,$00000C,$56F400,$000014,$57F400,$000001
		dc	$390000,$70F400,$000080,$60F400,$000B40,$0BF080,$000180,$200003
		dc	$052400,$00000C,$56F400,$000010,$57F400,$000000,$70F400,$000390
		dc	$0BF080,$000180,$200003,$052400,$56F400,$000011,$57F400,$000000
		dc	$70F400,$000390,$0BF080,$000180,$200003,$052400,$00000C,$447000
		dc	$000963,$56F000,$000B97,$200045,$052407,$71F400,$000389,$380700
		dc	$60F400,$000235,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000180
		dc	$211900,$56F400,$000010,$57F400,$000002,$0BF080,$000180,$200003
		dc	$052400,$44F000,$000963,$56F000,$000B97,$200045,$052407,$71F400
		dc	$000389,$380700,$60F400,$0002F6,$050C07,$46F400,$0000B5,$20D8D0
		dc	$60F422,$000241,$211900,$56F400,$000011,$57F400,$000002,$0BF080
		dc	$000180,$200003,$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\llef13break.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 01/05/01, 09:15:05
;	Program info
;	  Program number: 2
;	  Revision number: 1.4
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2049 words
;	  Checksum: $9BD1DF

		dc	$D01B40,$000801,$020104,$9BD1DF,$447000,$00095F,$607000,$000962
		dc	$050C00,$20000B,$05A407,$0508D9,$0D1080,$000776,$0D1080,$0007A9
		dc	$050C05,$0D1080,$00077C,$0D1080,$000796,$0508D3,$62F000,$000962
		dc	$60F400,$000FC2,$0A72D8,$000004,$240000,$447000,$000960,$5EE800
		dc	$0212DF,$20000B,$05A402,$014180,$547000,$000961,$44F000,$000960
		dc	$05094C,$050811,$44F000,$000960,$0D1080,$0007A0,$56F000,$000960
		dc	$014180,$44F000,$000961,$547000,$000960,$200045,$0597D0,$0D1080
		dc	$000764,$00000C,$56F000,$000960,$44F000,$00095F,$0C1940,$008020
		dc	$547000,$00093D,$56F000,$000960,$200003,$052454,$62F000,$000962
		dc	$60F400,$00094D,$44F400,$000080,$060690,$000002,$445800,$02129E
		dc	$0212D4,$0C1940,$00101B,$547000,$000930,$44F413,$000012,$0C1940
		dc	$005021,$547000,$000934,$021ADE,$022A94,$0C1940,$001021,$0222D4
		dc	$0C1940,$001022,$022294,$0C1940,$001023,$547000,$000935,$021A94
		dc	$447000,$000942,$200013,$0232D4,$0C1940,$001018,$022AD4,$0C1940
		dc	$001019,$547000,$00093E,$023A94,$447000,$000940,$023294,$447000
		dc	$00093F,$60F413,$00092C,$57F400,$000010,$0D1080,$0002A9,$44F400
		dc	$000000,$200045,$057400,$00000C,$30001B,$0D1080,$0002A1,$00000C
		dc	$44F400,$000015,$447000,$00092C,$44F400,$00094D,$447000,$00092D
		dc	$44F400,$000959,$447000,$00092E,$44F400,$000953,$447000,$00092F
		dc	$44F400,$00FFFF,$447000,$000933,$44F400,$000941,$447000,$000936
		dc	$240000,$447000,$000931,$447000,$000932,$447000,$000937,$447000
		dc	$000938,$447000,$000939,$447000,$00093A,$447000,$00093B,$447000
		dc	$00093C,$60F400,$000947,$44F400,$000000,$445800,$44F400,$000002
		dc	$445800,$44F400,$000003,$445800,$44F400,$000004,$445800,$44F400
		dc	$000001,$445800,$44F400,$000005,$445800,$60F400,$000959,$44F400
		dc	$000001,$060690,$000002,$445800,$60F400,$000953,$44F400,$00FFFF
		dc	$060690,$000002,$445800,$00000C,$62F000,$000962,$45F400,$000003
		dc	$021296,$2000E0,$62F400,$000F92,$210E00,$200040,$60F400,$000080
		dc	$219A00,$70F400,$000100,$56F400,$000005,$79EA00,$0D0180,$200003
		dc	$052400,$00000C,$230800,$00000A,$04C8A0,$0461A0,$0464A0,$0465A0
		dc	$0004F8,$230E00,$200022,$219800,$221400,$044811,$223500,$5FE000
		dc	$4FE100,$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868
		dc	$4FE119,$200016,$CF1C00,$CA1D78,$230E00,$223022,$219800,$221400
		dc	$044811,$223500,$5FE000,$4FE100,$5EE078,$06D810,$000009,$45D919
		dc	$200016,$8F8000,$8AB868,$4FE119,$200016,$CF1C00,$CA1D78,$223000
		dc	$221400,$044811,$223500,$5FE000,$45E100,$5EE06C,$06D810,$000009
		dc	$4FD919,$200016,$8F8000,$8AB878,$45E119,$200016,$CF1C00,$CA1D6C
		dc	$230E00,$3A0222,$223000,$219900,$221100,$233200,$221400,$66F400
		dc	$000F52,$204900,$223500,$045A18,$231C00,$231D00,$205200,$5FE000
		dc	$F4C100,$4CDE00,$4FD9AE,$5EE0BF,$06DA10,$000020,$06D210,$000007
		dc	$8F8016,$45E1EE,$8AB8CB,$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016
		dc	$8AA8EE,$45E1CB,$CF0C16,$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016
		dc	$45E1AE,$8AB8BF,$CF1C16,$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE
		dc	$F4C1BF,$4CDE00,$CF0C16,$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032
		dc	$21B900,$219A00,$0CCD80,$FFFFCA,$380200,$221400,$231C00,$235200
		dc	$66F400,$000F52,$045811,$231900,$223500,$231D00,$205200,$5FE000
		dc	$F4C100,$4CDE00,$4FC9AE,$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB
		dc	$CF0C16,$06D210,$000010,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE
		dc	$F4C1BF,$4CDE00,$CF0C16,$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE
		dc	$45E1CB,$CF0C16,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF
		dc	$05F420,$00FFFF,$574C16,$0461A0,$564D00,$0464A0,$0465A0,$00F3B8
		dc	$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$00001A
		dc	$F0B900,$06DE10,$00000A,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$D0A1E2,$4549D3,$10DD00,$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2
		dc	$4459E2,$F0A1E2,$4559D3,$564C00,$03F18E,$22D400,$229000,$239800
		dc	$0460A4,$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10
		dc	$000021,$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4,$F039D6
		dc	$F0A8E6,$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09,$444C4C
		dc	$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010
		dc	$21C409,$444C4C,$03F184,$555A00,$515A00,$22D400,$229000,$239800
		dc	$0460A4,$00000C,$44C800,$2000A0,$44C814,$200011,$06DE10,$000005
		dc	$180CA0,$44C8BA,$200014,$200011,$182400,$2000BA,$00000C,$46C813
		dc	$2000E1,$06DE10,$000003,$46C800,$564CE1,$566400,$00000C,$394000
		dc	$233D00,$204900,$204D00,$045112,$045516,$06D910,$000004,$46D900
		dc	$B0B200,$445600,$38FF00,$231C00,$204100,$204500,$044812,$044C16
		dc	$380200,$72F400,$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4
		dc	$2000F3,$5659C8,$D088EB,$063F90,$000005,$D5CAD4,$575DF3,$5659C8
		dc	$D088EB,$575D00,$204000,$204400,$387F00,$231A00,$231C00,$231E00
		dc	$204100,$204500,$204000,$204A00,$204400,$204E00,$380200,$72F400
		dc	$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8
		dc	$D088EB,$063F90,$000005,$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00
		dc	$00000C,$F1C000,$4DDA00,$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006
		dc	$F1C0A7,$4DDA00,$4ED8C8,$565CEB,$5F64B0,$2000A7,$565C00,$00000C
		dc	$F1C000,$4DDA00,$4EE1C8,$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB
		dc	$5F65B0,$06DA10,$00000A,$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0
		dc	$44D9A7,$5F64C8,$565CEB,$5F65B0,$2000A7,$565D00,$00000C,$F1C000
		dc	$4DDA00,$4EC8A8,$2000BB,$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00
		dc	$4EC8A8,$564CBB,$574DE0,$2000C7,$564C00,$00000C,$F1C100,$4DDA00
		dc	$4EE1A8,$4EE0BB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7
		dc	$06DA10,$00000B,$F1C100,$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7
		dc	$4EE1B8,$565CAB,$44C9E0,$574DC7,$564C00,$00000C,$56D800,$06D910
		dc	$000007,$0C1E01,$20003E,$23A403,$02A048,$56D800,$575900,$205000
		dc	$00000C,$46F400,$000001,$23AE00,$223555,$05A40D,$22B400,$06DC10
		dc	$000009,$56F400,$7FFFFF,$06DD10,$000004,$44DC00,$200045,$027040
		dc	$544D00,$223500,$234F00,$56E20B,$052406,$44F400,$00000F,$200045
		dc	$027040,$546200,$218500,$06DC10,$000004,$56E500,$218564,$544D00
		dc	$223500,$238759,$45F400,$000002,$56E500,$45F465,$FFFFFE,$057417
		dc	$45F465,$000002,$059411,$204D58,$20007D,$05744D,$0597D6,$56E500
		dc	$45F465,$FFFFFE,$057413,$45F465,$000002,$059406,$204D58,$20007D
		dc	$057442,$0597CB,$05A7D5,$20455C,$05A40D,$56E500,$200054,$544D00
		dc	$56E500,$45F450,$000002,$544500,$050FC0,$45F454,$000002,$546500
		dc	$050FC7,$234E00,$204D03,$05A407,$56E200,$200054,$546200,$56E500
		dc	$200050,$546500,$56E200,$200054,$546200,$56E500,$45F450,$000002
		dc	$546558,$050F8B,$223500,$45E200,$06DC10,$000005,$56E500,$200060
		dc	$218500,$544D00,$23AE00,$223555,$05A409,$22B400,$06DC10,$000006
		dc	$44CD00,$06DD10,$000002,$445C00,$000000,$00000C,$44F000,$000B41
		dc	$56F000,$000B94,$200045,$05A413,$209600,$60F400,$000180,$61F400
		dc	$000241,$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$06D910
		dc	$000005,$44D900,$56E000,$0C1E48,$545800,$050C10,$56F000,$000B7B
		dc	$200003,$05A40C,$60F400,$000235,$61F400,$0002F6,$390700,$06D910
		dc	$000005,$44D900,$56E000,$0C1E48,$545800,$00000C,$05F420,$FFFFFF
		dc	$0461A0,$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000000
		dc	$20004D,$05A40C,$44F400,$000010,$20004D,$0D104A,$000011,$300000
		dc	$56F400,$000000,$57F400,$FFFFFF,$00000C,$200013,$567000,$000912
		dc	$300000,$56F400,$000000,$57F400,$000608,$00000C,$050856,$0D1080
		dc	$00008C,$56F000,$000B93,$200003,$05744D,$0D1080,$000136,$0D1080
		dc	$000179,$0D1080,$0001BC,$240000,$447000,$00092B,$56F000,$000B41
		dc	$44F000,$000B94,$200045,$05A409,$0D1080,$00010E,$0D1080,$0001E3
		dc	$557000,$00092B,$0D1080,$0002CB,$0D1080,$0002E3,$0D1080,$0002F2
		dc	$0D1080,$00034D,$0D1080,$000309,$56F000,$000B41,$200003,$0D100A
		dc	$0003F4,$0D1080,$000356,$0D1080,$000383,$0D1080,$00039E,$0D1080
		dc	$FFFF87,$200013,$21101B,$00000C,$205800,$44D800,$447000,$000B42
		dc	$44D800,$447000,$000B43,$44D800,$447000,$000B44,$57D800,$0C1890
		dc	$002024,$507000,$000B78,$0C1890,$00101B,$507000,$000B7B,$0C1890
		dc	$003018,$507000,$000B7A,$44D800,$447000,$000B45,$44D800,$447000
		dc	$000B46,$44D800,$447000,$000B47,$57D800,$0C1890,$006020,$507000
		dc	$000B79,$57D800,$0C1890,$001023,$507000,$00023D,$0C1890,$001022
		dc	$507000,$00023E,$0C1890,$001021,$507000,$00023F,$0C1890,$004018
		dc	$507000,$000240,$61D800,$380600,$204800,$205900,$57D900,$015F8E
		dc	$577000,$000B49,$57D800,$0C1890,$008018,$507000,$000B41,$0C1890
		dc	$008020,$507000,$000B40,$57D800,$0C1890,$001018,$507000,$000B4C
		dc	$0C1890,$001019,$507000,$000B4A,$57D800,$577000,$000B4B,$57E000
		dc	$577000,$000B4D,$00000C,$56F000,$000912,$44F400,$020765,$200045
		dc	$052406,$56F000,$000B40,$200003,$05A45E,$00000C,$60F413,$0004FD
		dc	$060690,$000003,$545800,$545800,$60F413,$0005A8,$060590,$000002
		dc	$545800,$60F413,$00057B,$062890,$000002,$545800,$60F413,$0005AE
		dc	$065A90,$000002,$545800,$60F413,$000608,$060590,$000002,$545800
		dc	$60F413,$00060D,$060590,$000002,$545800,$60F413,$000509,$061090
		dc	$000002,$545800,$60F413,$000519,$060890,$000002,$545800,$60F413
		dc	$000521,$063C90,$000002,$545800,$60F413,$00055D,$061E90,$000002
		dc	$545800,$60F413,$000612,$060093,$000002,$545800,$44F400,$020765
		dc	$447000,$000912,$44F400,$000000,$447000,$000B93,$61F400,$000FC2
		dc	$71F000,$000B7A,$44F000,$000B7B,$5EE900,$547040,$000B94,$547000
		dc	$000B95,$44F01B,$000B94,$2D0513,$2C024D,$05945A,$44F01B,$000B95
		dc	$2D0613,$2C024D,$059455,$56F000,$000B79,$200023,$547000,$000B96
		dc	$44F01B,$000B78,$2D0313,$2C044D,$05944B,$44F01B,$000B96,$2D1313
		dc	$2C034D,$059446,$56F000,$000B79,$0140C4,$000024,$21DA00,$44F000
		dc	$000B78,$46F400,$000006,$2344D0,$0C1D2E,$44F440,$000F4C,$200040
		dc	$219100,$5EE100,$21CF22,$218422,$200022,$577040,$000B97,$218500
		dc	$21E46C,$46F400,$000008,$21A7D0,$5070E8,$000B9A,$457000,$000B98
		dc	$5170B0,$000B9B,$477000,$000B99,$507000,$000B9C,$050C03,$547000
		dc	$000B93,$00000C,$56F400,$000914,$44F000,$000B41,$200040,$219100
		dc	$56E100,$0C1E01,$44F43E,$000001,$20004C,$20291B,$45F403,$000003
		dc	$02A068,$20006D,$027068,$56F400,$000B5E,$44F000,$000B41,$200040
		dc	$219000,$556000,$00000C,$44F000,$000B7A,$46F400,$000006,$44F0D0
		dc	$000B41,$0C1D2E,$44F440,$000F92,$200040,$219400,$56F000,$000B44
		dc	$4CE400,$200040,$219100,$05E120,$56F000,$000B42,$4CE400,$200040
		dc	$219100,$56F000,$000B43,$4CE400,$200040,$219200,$44F400,$000100
		dc	$46E200,$2000D0,$240022,$210600,$2400D0,$46E200,$2400D2,$0C1D2E
		dc	$44E140,$200040,$219000,$70E200,$64F400,$0002FD,$3C0100,$3EFF00
		dc	$45F400,$3FF7CF,$56F000,$00023F,$200003,$05A40F,$56F000,$000B41
		dc	$44F432,$0004FD,$200040,$219100,$47F400,$000347,$57D900,$51D100
		dc	$0D04E2,$555900,$516100,$050C02,$0D04EF,$05F420,$00FFFF,$00000C
		dc	$56F000,$000B41,$44F000,$000B94,$200045,$05A44D,$56F000,$00023D
		dc	$200003,$05A45B,$60F400,$0002FD,$221400,$380100,$231C00,$44F000
		dc	$000B41,$46F400,$00000C,$44F4D0,$000521,$0C1D2E,$200040,$219100
		dc	$44F000,$000B41,$46F400,$000006,$44F4D0,$00055D,$0C1D2E,$200040
		dc	$219200,$56F000,$000240,$0140C4,$000007,$21DA00,$234400,$46F400
		dc	$00000F,$44F4D0,$000814,$0C1D2E,$200040,$219500,$3A0300,$3EFF00
		dc	$0D0499,$050C13,$56F000,$00023E,$200003,$05A40F,$60F400,$0002FD
		dc	$221400,$380100,$231C00,$61F400,$000509,$62F400,$000519,$65F400
		dc	$000800,$3A0400,$3EFF00,$0D04BA,$00000C,$44F000,$000B7A,$46F400
		dc	$000006,$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040,$219100
		dc	$4CE100,$447000,$000913,$61F400,$0002FD,$200013,$44D91B,$060091
		dc	$000004,$200047,$029040,$44D98A,$60F400,$0005A8,$70F000,$000B41
		dc	$200032,$44E826,$566847,$029040,$21C700,$56F400,$000914,$44F000
		dc	$000B41,$200040,$219000,$476000,$0C1C91,$44F000,$000B41,$46F400
		dc	$000002,$44F4D0,$00091A,$0C1D2E,$200040,$219000,$555800,$516000
		dc	$00000C,$60F400,$0002FD,$64F400,$0003FD,$380100,$231C00,$44F000
		dc	$000B41,$46F400,$000008,$44F4D0,$00057B,$0C1D2E,$200040,$219100
		dc	$65F400,$0008A2,$3A0200,$3EFF00,$0D0499,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380E00,$61F400
		dc	$0003FD,$204800,$060490,$000009,$200013,$064090,$000004,$44D900
		dc	$200047,$029040,$200026,$565800,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380800,$57F400,$000002
		dc	$204800,$380600,$060290,$00000B,$221100,$044812,$06CD10,$000006
		dc	$44DA00,$56DA00,$200045,$029040,$565900,$20402A,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$62F400,$0008AF,$390200,$45F41B,$000001,$20A600,$060390,$00000D
		dc	$221100,$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145
		dc	$027068,$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200
		dc	$56E800,$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0
		dc	$00091A,$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41
		dc	$200040,$219000,$44E100,$46F400,$7FFFFF,$44E0D0,$200045,$20291B
		dc	$56F400,$000926,$44F000,$000B41,$200040,$219000,$556000,$44F000
		dc	$000B41,$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000
		dc	$380600,$62F400,$0008AC,$390200,$20A61B,$060390,$00000D,$221100
		dc	$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068
		dc	$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800
		dc	$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A
		dc	$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040
		dc	$219000,$44E100,$46F400,$400000,$46E0D0,$446055,$20291B,$56F400
		dc	$000B7C,$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$20AE00,$060390,$00000A,$221100,$219900,$221200,$204900,$44D900
		dc	$445A00,$44D900,$445A00,$204832,$00000C,$56F400,$000B7C,$44F000
		dc	$000B41,$200040,$219000,$56F400,$00060D,$44F000,$000B41,$200040
		dc	$219100,$56F400,$000B81,$44F000,$000B41,$200040,$219200,$44E01B
		dc	$56E100,$45F442,$000001,$02A068,$576200,$446100,$00000C,$60F400
		dc	$0002FD,$44F000,$000B41,$46F400,$000080,$44F4D0,$000612,$0C1D2E
		dc	$200040,$219100,$64F400,$0008B2,$65F400,$000000,$0D04F7,$00000C
		dc	$56F000,$00092B,$200003,$05A40E,$60F400,$000000,$61F400,$000040
		dc	$221400,$223500,$62F400,$000AB2,$66F400,$000AF2,$3A3F00,$0D0548
		dc	$050C0A,$60F400,$000000,$221400,$62F400,$0009B2,$66F400,$000A32
		dc	$3A7F00,$0D0539,$00000C,$0500A0,$0461A0,$56F000,$00092B,$200003
		dc	$05A415,$60F400,$000000,$61F400,$000040,$64F400,$0003FD,$65F400
		dc	$0004FC,$62F400,$000AB2,$66F400,$000AF2,$382000,$231900,$3A3F00
		dc	$3C0300,$75F400,$FFFFFD,$0D056E,$050C11,$60F400,$000000,$64F400
		dc	$0003FD,$65F400,$0004FC,$62F400,$0009B2,$66F400,$000A32,$384000
		dc	$3A7F00,$3C0200,$75F400,$FFFFFE,$0D055F,$05F420,$00FFFF,$0461A0
		dc	$56F000,$000B41,$44F000,$000B94,$60F445,$0003FD,$05A408,$61F400
		dc	$000180,$06B590,$000003,$44D800,$445900,$050C07,$61F400,$000235
		dc	$060790,$000003,$44D800,$445900,$00000C,$56F000,$00092B,$200003
		dc	$05A40A,$60F400,$000000,$384000,$0D03EA,$60F400,$000040,$384000
		dc	$0D03EA,$050C05,$60F400,$000000,$388000,$0D03EA,$00000C,$56F000
		dc	$000B94,$44F000,$000B41,$45F445,$000001,$05A403,$05080D,$050C03
		dc	$457000,$000B8C,$60F400,$000B7C,$61F400,$0005A3,$060590,$000003
		dc	$44D800,$445900,$00000C,$290300,$70F000,$000B41,$60F400,$000B7C
		dc	$56E800,$014185,$05A410,$60F400,$000926,$56E800,$014185,$05A40B
		dc	$56F000,$000B40,$014085,$05A406,$60F400,$0005A3,$56E800,$014185
		dc	$05A402,$290200,$60F400,$000B87,$516800,$00000C,$3D1800,$44F000
		dc	$000B41,$56F000,$000B94,$60F445,$000180,$05A40C,$209600,$61F400
		dc	$000241,$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$0D0586
		dc	$050C0A,$56F000,$000B7B,$60F403,$000235,$05A405,$61F400,$0002F6
		dc	$390700,$0D0586,$00000C,$44F000,$000B41,$56F000,$000B94,$61F445
		dc	$000241,$05A459,$56F400,$000B87,$44F000,$000B41,$200040,$219000
		dc	$56F400,$000BA2,$44F000,$000B41,$200040,$219200,$56E000,$71E200
		dc	$219400,$223600,$56F400,$000B59,$44F000,$000B41,$200040,$219000
		dc	$56F400,$000B8E,$44F000,$000B41,$200040,$219200,$232E00,$014184
		dc	$0B74C4,$000F16,$218500,$47F4AD,$000001,$0B74C4,$000F12,$21E600
		dc	$209DD0,$0C1D2E,$46F465,$2AAAAB,$202978,$556000,$21A500,$21BCE9
		dc	$0C1D82,$200010,$200065,$202978,$556200,$223200,$205900,$3A0000
		dc	$0D0591,$050C11,$56F000,$000B7B,$60F403,$000B8C,$05A40C,$61F400
		dc	$0002F6,$390700,$223600,$223200,$205900,$3A0000,$3C0600,$7DF000
		dc	$000F13,$0D0591,$00000C,$56F000,$000240,$0C1D04,$21C700,$46F400
		dc	$000003,$2000B0,$0C1D2E,$0140C0,$000049,$21C600,$61F400,$000B9D
		dc	$62F400,$000BA2,$45F000,$000B94,$06C510,$000003,$475900,$465A00
		dc	$57F400,$000001,$56F000,$000B40,$200003,$05A402,$20001B,$577000
		dc	$000B8D,$00000C,$56F400,$00000A,$57F400,$000000,$70F400,$000416
		dc	$0BF080,$000180,$200003,$052400,$00000C,$56F400,$00000A,$57F400
		dc	$000001,$60F400,$0004FD,$70F400,$000416,$390000,$0BF080,$000180
		dc	$200003,$052400,$00000C,$56F400,$00000A,$57F400,$000002,$60F400
		dc	$0004FD,$70F400,$000416,$390000,$0BF080,$000180,$200003,$052400
		dc	$00000C,$56F400,$000011,$57F400,$000001,$390000,$70F400,$000080
		dc	$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C,$56F400
		dc	$00000D,$57F400,$000000,$70F400,$000390,$0BF080,$000180,$200003
		dc	$052400,$56F400,$00000E,$57F400,$000000,$70F400,$000390,$0BF080
		dc	$000180,$200003,$052400,$00000C,$447000,$000963,$56F000,$000B94
		dc	$200045,$052407,$71F400,$000389,$380700,$60F400,$000235,$050C07
		dc	$46F400,$0000B5,$20D8D0,$60F422,$000180,$211900,$56F400,$00000D
		dc	$57F400,$000002,$0BF080,$000180,$200003,$052400,$44F000,$000963
		dc	$56F000,$000B94,$200045,$052407,$71F400,$000389,$380700,$60F400
		dc	$0002F6,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000241,$211900
		dc	$56F400,$00000E,$57F400,$000002,$0BF080,$000180,$200003,$052400
		dc	$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\sehelper.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			sehelper.asm
;												
;   Contents:		Helper Functions for SuperExec
;					Only used for simulator version.
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/12/2000 3:49:54 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'SuperExec Helper Fcns'

	section	SuperExecHelper
	
;**** include files ************************************************

	nolist
	include 'mot_equ.inc'
	list

;**** external references ******************************************

	xdef	CopyInFilesToSysMem
	xdef	Copy6ChInFileToSysMem

	xdef	CopySysMemToOutputFiles
	xdef	CopySysMemToAC3OutputFile

;**** equates ******************************************************

simulator_l_pcm_input		equ		$ef0000		; DSP chip locations for simulator
simulator_r_pcm_input		equ		$ef0001		; These will not be needed in NVIDIA
simulator_c_pcm_input		equ		$ef0002		; implementation
simulator_ls_pcm_input  	equ		$ef0003		;
simulator_rs_pcm_input  	equ		$ef0004		;

BLOCK_LEN					equ		256
AC3_BLOCK0_OFFSET			equ		(3072-1280-290)
AC3WORDSPERFRAME			equ		1280

;**** data *********************************************************

	mode rel
	org	p(202):

;*******************************************************************
;*
;*	Subroutine Name:	CopyInFilesToSysMem
;*																								
;*  Description:		Copies Input data to Simulated X-Box System memory
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
CopyInFilesToSysMem:

	move	#SYSMEMPCMBASE,r1
	
	dor		#BLOCK_LEN,l_loop
		move	x:simulator_l_pcm_input,a
		move	a,x:(r1)+
l_loop:

	dor		#BLOCK_LEN,c_loop
		move	x:simulator_c_pcm_input,a
		move	a,x:(r1)+
c_loop:

	dor		#BLOCK_LEN,r_loop
		move	x:simulator_r_pcm_input,a
		move	a,x:(r1)+
r_loop:

	dor		#BLOCK_LEN,ls_loop
		move	x:simulator_ls_pcm_input,a
		move	a,x:(r1)+
ls_loop:

	dor		#BLOCK_LEN,rs_loop
		move	x:simulator_rs_pcm_input,a
		move	a,x:(r1)+
rs_loop:

	rts


;*******************************************************************
;*
;*	Subroutine Name:	CopySysMemToOutputFiles
;*																								
;*  Description:		Copies simulated X-Box Sys Mem to Output debug files
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
CopySysMemToOutputFiles:

	move	#SYSMEMLTRTBASE,r0
	move	#SYSMEMLTRTBASE+BLOCK_LEN,r1

	dor		#BLOCK_LEN,outcopy
		movep	x:(r0)+,x:M_TX00
		movep	x:(r1)+,x:M_TX00
outcopy:

	rts


;*******************************************************************
;*
;*	Subroutine Name:	Copy6ChInFileToSysMem
;*																								
;*  Description:		Copies a single 6-channel block of Input data 
;*						to Simulated X-Box System memory
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************
Copy6ChInFileToSysMem:

	move	#SYSMEMPCMBASE,r0
	move	#BLOCK_LEN,n1

	dor		#BLOCK_LEN,loop_6ch
		move	r0,r1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		movep	x:M_RX0,x:(r1)+n1
		move	(r0)+
loop_6ch:

	rts

;*******************************************************************
;*
;*	Subroutine Name:	CopySysMemToAC3OutputFile
;*																								
;*  Description:		Copies simulated X-Box Sys Mem to Output debug files
;*
;*	Input:				n0 - number of words to copy
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************

CopySysMemToAC3OutputFile:

	move	#SYSMEMAC3BASE+AC3_BLOCK0_OFFSET,r0
	
	dor		#AC3WORDSPERFRAME,outcopyAC3
	movep	x:(r0)+,x:M_TX00
outcopyAC3:

	rts

;******************************************************************************

	endsec	; SuperExecHelper
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\llef33.asm ===
;	File info
;	  File name: llef33.asm
;	  Build date: 01/10/01, 11:05:04
;	Program info
;	  Program number: 4
;	  Revision number: 1.51
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 1745 words
;	  Checksum: $F8A1F2

		dc	$D01B40,$0006D1,$040133,$F8A1F2,$447000,$000551,$20000B,$05A403
		dc	$0D1080,$0006BE,$0D1080,$000635,$57F000,$000551,$60F40B,$000451
		dc	$052406,$240000,$447000,$000B4F,$447000,$000B50,$56F000,$000B4F
		dc	$44F003,$000B50,$05A402,$445800,$57F400,$000010,$0D1080,$00017F
		dc	$44F400,$000000,$200045,$057400,$205800,$56D800,$57F000,$000B4F
		dc	$44F40B,$000001,$202240,$240000,$250000,$60F400,$000451,$0CCC80
		dc	$000007,$0ACC40,$219800,$44F400,$000001,$45E800,$447000,$000B4F
		dc	$457000,$000B50,$218400,$56F000,$000551,$0D1080,$00062A,$00000C
		dc	$46F461,$000010,$230700,$06D910,$00000A,$50D97C,$057407,$21E478
		dc	$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C
		dc	$46F461,$000010,$230700,$50D97C,$057407,$21E478,$0C1E46,$0C1E90
		dc	$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400,$000010
		dc	$230700,$06D910,$00000D,$56D900,$0C1E6E,$20AC7C,$057407,$21E478
		dc	$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C
		dc	$46F400,$000010,$230700,$56D900,$0C1E6E,$20AC7C,$057407,$21E478
		dc	$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68,$0C1E4E,$218500,$00000C
		dc	$61F400,$000D12,$46F400,$0000FF,$06D810,$00000E,$0C1C90,$200056
		dc	$51D800,$219900,$0C1D91,$4CE900,$20004B,$0C1C90,$200056,$219900
		dc	$0C1D91,$4CE900,$20004B,$0C1E91,$21AE00,$0C1C11,$00000C,$61F41B
		dc	$000E12,$46F400,$0000FF,$204800,$06D810,$00000D,$21AE5E,$44F800
		dc	$21B900,$0C1ED0,$200042,$4CE900,$200043,$218F56,$219900,$0C1ED1
		dc	$4CE900,$20004B,$0C1E91,$21AE00,$0C1C11,$00000C,$000446,$0003C7
		dc	$0003E4,$000401,$000408,$000421,$000428,$00042B,$00042E,$000431
		dc	$000434,$000437,$00043A,$00043D,$000440,$000443,$74F400,$0003AE
		dc	$06D810,$000086,$64DD00,$56E000,$07EC96,$218500,$0AE680,$44F400
		dc	$000003,$62F4A0,$000005,$72F040,$000002,$234F22,$39010B,$546A00
		dc	$052404,$607000,$00000D,$050C0E,$66F400,$000D0A,$232400,$39024D
		dc	$05A409,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000D,$0C1D24,$390000
		dc	$506600,$717013,$000002,$050CC3,$44F400,$000005,$62F4A0,$000008
		dc	$72F040,$000003,$234F22,$39010B,$546A00,$052404,$607000,$00000E
		dc	$050C0E,$66F400,$000D0D,$232400,$39024D,$05A409,$F0DA00,$F0DAD0
		dc	$F0DAD2,$66F0D2,$00000E,$0C1D20,$390000,$506600,$717013,$000003
		dc	$050C86,$44F400,$000007,$2000A0,$200040,$0C1D38,$0C1C10,$050C5F
		dc	$44F400,$00000B,$62F4A0,$00000B,$72F040,$000004,$234F22,$39010B
		dc	$66F400,$000D10,$546A00,$052404,$607000,$00000F,$050C08,$F0DA00
		dc	$F0DAD0,$66F0D2,$00000F,$0C1D20,$390000,$506600,$717013,$000004
		dc	$050C46,$44F400,$00000F,$2000A0,$200040,$0C1D36,$0C1C10,$050C1F
		dc	$56F400,$040000,$050C1B,$56F400,$020000,$050C18,$56F400,$010000
		dc	$050C15,$56F400,$008000,$050C12,$56F400,$004000,$050C0F,$56F400
		dc	$002000,$050C0C,$56F400,$001000,$050C09,$56F400,$000800,$050C06
		dc	$56F400,$000400,$050C03,$56F400,$000100,$200060,$565800,$00000C
		dc	$000493,$00047F,$000475,$000488,$00046B,$000488,$000488,$000488
		dc	$000488,$000488,$000488,$000488,$000488,$000488,$000488,$000488
		dc	$62F000,$000B55,$05F022,$000B47,$56F000,$000B56,$45F000,$000B57
		dc	$46F400,$000010,$74F400,$000448,$06D810,$00002F,$64DD00,$07EC96
		dc	$0B74C7,$000CFA,$0AE680,$57F000,$000004,$01418C,$557000,$000004
		dc	$052443,$390200,$717000,$000004,$050C14,$57F000,$000003,$01418C
		dc	$557000,$000003,$052419,$390300,$717000,$000003,$050C0A,$57F000
		dc	$000002,$01418C,$557000,$000002,$05240F,$390300,$717000,$000002
		dc	$200069,$50E07C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58
		dc	$0C1E68,$0C1E4E,$21A500,$205800,$547000,$000B56,$457000,$000B57
		dc	$627000,$000B55,$05F422,$00FFFF,$00000C,$05F420,$FFFFFF,$0461A0
		dc	$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000000,$20004D
		dc	$05A40C,$44F400,$000010,$20004D,$0D104A,$00000F,$300000,$56F400
		dc	$000000,$57F400,$FFFFFF,$00000C,$200013,$300000,$56F400,$000000
		dc	$57F400,$000608,$00000C,$607000,$000B45,$607000,$000B55,$45F400
		dc	$00001F,$457000,$000B72,$56F000,$000B40,$240003,$052409,$447000
		dc	$000B56,$447000,$000B57,$447000,$000B9D,$0D1080,$00008C,$0D1080
		dc	$000129,$0D1080,$00019E,$0D1080,$000366,$56F000,$000B40,$014585
		dc	$052403,$0D1080,$000393,$56F000,$000B55,$44F000,$000B45,$200044
		dc	$547000,$000B58,$0D1080,$0003D0,$56F000,$000B40,$014585,$05A40B
		dc	$44F000,$000B58,$45F400,$000010,$44F0A0,$000B9D,$0C1D2E,$200040
		dc	$567000,$000B9D,$0D1080,$000008,$00000C,$44F400,$000100,$447000
		dc	$000010,$00000C,$56F000,$000B96,$200003,$05F407,$44F013,$000B45
		dc	$447000,$000B55,$547000,$000B9A,$60F400,$000011,$44F400,$00000D
		dc	$445800,$56F000,$000B55,$44F000,$000B45,$200044,$545800,$44F000
		dc	$000B55,$445800,$240000,$445800,$445800,$445800,$445800,$44F413
		dc	$000009,$447000,$00001E,$44F000,$00001E,$0C1940,$004018,$545800
		dc	$240000,$445800,$20001B,$200013,$0C1EDF,$21A400,$0C1940,$008020
		dc	$20001B,$0C1EDF,$21A400,$0C1940,$008018,$545800,$57F013,$000B7D
		dc	$45F40B,$000080,$052407,$20001B,$0C1CA1,$200068,$21A400,$0C1940
		dc	$008020,$20001B,$0C1CA1,$200068,$21A400,$0C1940,$008018,$545800
		dc	$57F013,$000B7D,$20000B,$052407,$20001B,$0C1CA1,$200068,$21A400
		dc	$0C1940,$008020,$0C1CA1,$200068,$21A400,$0C1940,$008018,$545800
		dc	$200013,$545800,$60F400,$000011,$56F000,$000B96,$57F400,$000608
		dc	$00000C,$62F000,$000B45,$05F022,$000B47,$57F400,$000010,$250000
		dc	$44F400,$000B77,$447000,$000000,$44F400,$000000,$447000,$000B54
		dc	$61F400,$000000,$381000,$0D0370,$61F400,$000B54,$381000,$0D0370
		dc	$61F400,$000B7B,$380200,$0D0370,$61F400,$000B7C,$380600,$0D0370
		dc	$280000,$507000,$00001E,$61F400,$00001E,$380500,$0D0370,$280000
		dc	$507000,$00001E,$61F400,$00001E,$380300,$0D0370,$61F400,$000B7D
		dc	$380300,$0D0370,$56F000,$000B7D,$014185,$05A40A,$014186,$05A408
		dc	$280000,$507000,$00001E,$61F400,$00001E,$380200,$0D0370,$56F000
		dc	$000B7D,$014486,$05A408,$280000,$507000,$00001E,$61F400,$00001E
		dc	$380200,$0D0370,$56F000,$000B7D,$014285,$052405,$61F400,$000B4E
		dc	$380200,$0D0370,$61F400,$000B7E,$380100,$0D0370,$61F400,$000B49
		dc	$380500,$0D0370,$61F400,$000B4C,$380100,$0D0370,$56F000,$000B4C
		dc	$200003,$05A405,$61F400,$000B4D,$380800,$0D0370,$280000,$507000
		dc	$00001E,$61F400,$00001E,$380100,$0D0370,$280000,$507000,$00001E
		dc	$61F400,$00001E,$380100,$0D0370,$280000,$507000,$00001E,$61F400
		dc	$00001E,$380100,$0D0370,$280100,$507000,$00001E,$61F400,$00001E
		dc	$380100,$0D0370,$200013,$567000,$00001E,$61F400,$00001E,$380100
		dc	$0D0370,$200013,$567000,$00001E,$61F400,$00001E,$380100,$0D0370
		dc	$200013,$507000,$00001E,$61F400,$00001E,$380100,$0D0370,$457000
		dc	$000B56,$577000,$000B57,$627000,$000B55,$05F422,$00FFFF,$00000C
		dc	$200013,$567000,$000002,$567000,$000003,$567000,$000004,$360000
		dc	$44F000,$000B97,$06C410,$00001D,$56F400,$000BA5,$22C400,$200040
		dc	$219000,$70E000,$22C400,$46F400,$0000B5,$44F4D0,$00055A,$0C1D2E
		dc	$200040,$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72,$0C1D2E
		dc	$200040,$219500,$667000,$000B41,$0D03BE,$66F000,$000B41,$205E00
		dc	$56F000,$000B7E,$200003,$05A407,$380700,$60F400,$0008E3,$65F400
		dc	$0003A8,$0D03BE,$57F000,$000002,$20000B,$05A414,$62F400,$000005
		dc	$66F400,$000D0A,$224E00,$44F410,$000001,$01438C,$21D03E,$06CD10
		dc	$000002,$445800,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000D,$0C1D24
		dc	$506600,$57F000,$000003,$20000B,$05A414,$62F400,$000008,$66F400
		dc	$000D0D,$224E00,$44F410,$000002,$01438C,$21D03E,$06CD10,$000002
		dc	$445800,$F0DA00,$F0DAD0,$F0DAD2,$66F0D2,$00000E,$0C1D20,$506600
		dc	$57F000,$000004,$20000B,$05A413,$62F400,$00000B,$66F400,$000D10
		dc	$224E00,$44F410,$000005,$01428C,$21D03E,$06CD10,$000002,$445800
		dc	$F0DA00,$F0DAD0,$66F0D2,$00000F,$0C1D20,$506600,$00000C,$62F000
		dc	$000B55,$05F022,$000B47,$57F000,$000B57,$45F000,$000B56,$61F400
		dc	$000B7F,$71F000,$000B97,$380100,$0D035E,$61F400,$000B84,$71F000
		dc	$000B97,$380100,$0D035E,$61F400,$000B4A,$380100,$0D0370,$56F000
		dc	$000B4A,$200003,$05A405,$61F400,$000B4B,$380800,$0D0370,$200013
		dc	$567000,$00001E,$61F400,$000B89,$380100,$0D0370,$56F900,$200003
		dc	$05A405,$61F400,$00001E,$380100,$0D0370,$56F000,$000B7D,$0140C5
		dc	$000002,$052412,$44F400,$000010,$447000,$00001E,$56F000,$000B40
		dc	$200003,$052406,$61F400,$00001E,$380500,$0D0370,$050C05,$61F400
		dc	$00001E,$380100,$0D0370,$61F400,$000B8A,$71F000,$000B97,$380200
		dc	$0D035E,$56F000,$000B7E,$200003,$05A405,$61F400,$000B8F,$380100
		dc	$0D0370,$360000,$44F000,$000B97,$06C410,$000011,$56F400,$000B8A
		dc	$22C400,$200040,$219100,$56E100,$200003,$05A408,$56F400,$000BA0
		dc	$22C400,$200040,$219100,$380600,$0D0370,$205E00,$360000,$44F000
		dc	$000B97,$06C410,$000023,$56F400,$000B8A,$22C400,$200040,$219100
		dc	$56E100,$200003,$05A41A,$22C400,$46F400,$00001F,$44F4D0,$0003AF
		dc	$0C1D2E,$200040,$219100,$380400,$0D0370,$56F400,$000B91,$22C400
		dc	$200040,$219000,$71E000,$380700,$0D035E,$56F400,$000B61,$22C400
		dc	$200040,$219100,$380200,$0D0370,$205E00,$56F000,$000B7E,$200003
		dc	$05A40C,$56F000,$000B8F,$200003,$05A408,$61F400,$00044A,$380400
		dc	$0D0370,$390200,$380700,$0D035E,$61F400,$000B90,$380100,$0D0370
		dc	$56F900,$200003,$05A449,$56F400,$000002,$567000,$00001E,$61F400
		dc	$00001E,$380200,$0D0370,$56F400,$000001,$567000,$00001E,$61F400
		dc	$00001E,$380200,$0D0370,$56F400,$000001,$567000,$00001E,$61F400
		dc	$00001E,$380200,$0D0370,$56F400,$000002,$567000,$00001E,$61F400
		dc	$00001E,$380200,$0D0370,$56F400,$000007,$567000,$00001E,$61F400
		dc	$00001E,$380300,$0D0370,$61F400,$000B6F,$380100,$0D0370,$56F900
		dc	$200003,$05A44A,$61F400,$000B73,$380600,$0D0370,$360000,$44F000
		dc	$000B97,$06C410,$000011,$56F400,$000B74,$22C400,$200040,$219100
		dc	$380400,$0D0370,$56F400,$000004,$567000,$00001E,$61F400,$00001E
		dc	$380300,$0D0370,$205E00,$56F000,$000B7E,$200003,$05A40D,$61F400
		dc	$000B79,$380400,$0D0370,$56F400,$000004,$567000,$00001E,$61F400
		dc	$00001E,$380300,$0D0370,$61F413,$00001E,$566100,$380100,$0D0370
		dc	$050C01,$56F000,$000B40,$014385,$052455,$224E00,$44F000,$000B45
		dc	$46F444,$000010,$21C700,$21EE00,$44F436,$000010,$200040,$21C400
		dc	$47F0B0,$000B9D,$0C1D2E,$200040,$44F070,$000B67,$21C741,$0C1D06
		dc	$18B000,$000B9E,$44F054,$000B7A,$200044,$200074,$200003,$05F41A
		dc	$014780,$44F000,$000B67,$0C1C06,$21C441,$200040,$567000,$000B67
		dc	$0140C5,$0001FF,$05F402,$00000C,$56F000,$000B71,$21C441,$0C1D06
		dc	$21C441,$200040,$567000,$000B71,$60F400,$000B6C,$56E000,$200044
		dc	$566000,$61F400,$000B66,$380100,$0D0370,$56F900,$200003,$05A501
		dc	$61F400,$000B67,$380900,$0D0370,$56F000,$000B70,$200003,$05F49F
		dc	$44F400,$000001,$447000,$000B5B,$61F413,$00001E,$566100,$380100
		dc	$0D0370,$240000,$447000,$00001E,$61F400,$00001E,$380100,$0D0370
		dc	$56F000,$000B5B,$014180,$567000,$000B5B,$56F000,$000B40,$014385
		dc	$052441,$240000,$447000,$00001E,$21EE00,$015085,$05A40B,$44F000
		dc	$000B5B,$200040,$21E400,$567000,$000B5B,$61F400,$00001E,$209800
		dc	$0D0370,$224E00,$567000,$000B59,$61F400,$00001E,$381000,$0D0370
		dc	$61F400,$00001E,$381000,$0D0370,$56F000,$000B5B,$016080,$567000
		dc	$000B5B,$240000,$447000,$00001E,$56F000,$000B70,$0C1D06,$44F000
		dc	$000B5B,$200044,$0C1C06,$06CC10,$00000A,$61F400,$00001E,$380800
		dc	$0D0370,$56F000,$000B5B,$014880,$567000,$000B5B,$56F000,$000B70
		dc	$0C1D06,$44F000,$000B5B,$200044,$61F400,$00001E,$219800,$0D0370
		dc	$56F000,$000B67,$44F000,$000B70,$200044,$050C0F,$56F000,$000B67
		dc	$2E0003,$05F40B,$240000,$447000,$00001E,$61F400,$00001E,$380800
		dc	$0D0370,$56F000,$000B67,$014184,$200003,$05A40B,$06CC10,$000009
		dc	$200013,$567000,$000010,$61F400,$000010,$380800,$0D0350,$000000
		dc	$457000,$000B56,$577000,$000B57,$627000,$000B55,$05F422,$00FFFF
		dc	$00000C,$390100,$717000,$000002,$717000,$000003,$717000,$000004
		dc	$360000,$44F000,$000B97,$06C410,$00001D,$56F400,$000BA5,$22C400
		dc	$200040,$219000,$70E000,$22C400,$46F400,$0000B5,$44F4D0,$00055A
		dc	$0C1D2E,$200040,$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72
		dc	$0C1D2E,$200040,$219500,$667000,$000B41,$0D0458,$66F000,$000B41
		dc	$205E00,$56F000,$000B7E,$200003,$05A407,$380700,$60F400,$0008E3
		dc	$65F400,$0003A8,$0D0458,$00000C,$62F000,$000B55,$05F022,$000B47
		dc	$57F000,$000B57,$45F000,$000B56,$240000,$447000,$00001E,$56F000
		dc	$000B6E,$015085,$059409,$015084,$547000,$000B6E,$61F400,$00001E
		dc	$381000,$0D0370,$050FD5,$200003,$05A405,$61F400,$00001E,$219800
		dc	$0D0370,$200013,$567000,$000001,$567000,$00001E,$61F400,$00001E
		dc	$380100,$0D0370,$61F400,$000001,$380100,$0D0370,$61F400,$00001E
		dc	$381000,$0D0370,$457000,$000B56,$577000,$000B57,$627000,$000B55
		dc	$05F422,$00FFFF,$56F000,$000B55,$44F000,$000B45,$200044,$21C400
		dc	$45F400,$000010,$2000A0,$0C1D2E,$44F000,$000B9D,$200040,$567000
		dc	$000B9D,$00000C,$56F000,$000B40,$014085,$052410,$60F000,$000B45
		dc	$205800,$05F020,$000B47,$56F000,$000B58,$014184,$21D81B,$0D0380
		dc	$557000,$000B5A,$05F420,$00FFFF,$050CDA,$014185,$05A403,$014285
		dc	$05240F,$60F000,$000B45,$05F020,$000B47,$70F01B,$000B58,$55F000
		dc	$000B5A,$0D0380,$557000,$000B5A,$05F420,$00FFFF,$050CC8,$014385
		dc	$052482,$56F000,$000B59,$44F000,$000B45,$200044,$014180,$21D800
		dc	$209000,$05F020,$000B47,$55F000,$000B5A,$0D0380,$0C1E91,$61F000
		dc	$000B59,$556100,$0C1C91,$44F000,$000B9D,$250800,$2000A0,$44F000
		dc	$000B9B,$21C441,$200044,$230400,$200044,$209A00,$21D800,$56F000
		dc	$000B59,$014180,$21D000,$0D0397,$56F000,$000B59,$014180,$21D000
		dc	$0C1E91,$556000,$0C1C91,$56F000,$000B55,$44F000,$000B45,$200044
		dc	$234400,$200044,$230400,$200044,$21D800,$56F000,$000B45,$200040
		dc	$234400,$200040,$21D000,$20001B,$0D0380,$557000,$000B5A,$05F420
		dc	$00FFFF,$050C45,$014485,$05240F,$05F020,$000B47,$60F000,$000B45
		dc	$70F000,$000B58,$57F000,$000B5A,$0D0380,$557000,$000B5A,$05F420
		dc	$00FFFF,$050C15,$014585,$052413,$05F020,$000B47,$60F000,$000B45
		dc	$70F000,$000B58,$57F000,$000B5A,$0D0380,$56F000,$000B55,$014184
		dc	$21D000,$0C1E91,$556000,$0C1C91,$05F420,$00FFFF,$00000C,$56F400
		dc	$000010,$57F400,$000001,$70F400,$000390,$390000,$60F400,$00055A
		dc	$0BF080,$000180,$200003,$052400,$56F400,$000012,$57F400,$000001
		dc	$70F400,$000390,$390000,$60F400,$00001F,$0BF080,$000180,$200003
		dc	$052400,$56F400,$000013,$57F400,$000001,$70F400,$0000A2,$390000
		dc	$60F400,$0003AF,$0BF080,$000180,$200003,$052400,$00000C,$547000
		dc	$000553,$447000,$000554,$607000,$000555,$200003,$05244B,$56F400
		dc	$00000A,$70F400,$0005DA,$390000,$0BF080,$000180,$200003,$052400
		dc	$60F400,$000556,$44F400,$F87200,$445800,$44F400,$4E1F00,$445800
		dc	$44F400,$000100,$445800,$44F400,$500000,$445800,$56F400,$00000B
		dc	$60F400,$000556,$380400,$71F400,$0005DA,$57F400,$000002,$0BF080
		dc	$000180,$200003,$052400,$56F000,$000553,$60F000,$000555,$44F000
		dc	$000554,$45F403,$0005DE,$052403,$457000,$000B48,$209800,$56F000
		dc	$000B48,$219940,$547000,$000B48,$56F400,$000007,$57F400,$000002
		dc	$0BF080,$000180,$200003,$052400,$56F000,$000553,$014585,$052409
		dc	$56F400,$00000A,$70F400,$000122,$71F400,$000ADE,$0BF080,$000180
		dc	$56F400,$000014,$57F400,$000002,$390000,$70F400,$000080,$60F400
		dc	$000B40,$0BF080,$000180,$200003,$052400,$00000C,$56F400,$000014
		dc	$57F400,$000000,$70F400,$000080,$0BF080,$000180,$200003,$052400
		dc	$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\llef13yrom.asm ===
;	File info
;	  File name: llef13.asm
;	  Build date: 01/04/01, 19:12:36
;	Program info
;	  Program number: 2
;	  Revision number: 1.4
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 2058 words
;	  Checksum: $090400

		dc	$D01B40,$00080A,$020104,$090400,$447000,$00095F,$607000,$000962
		dc	$20000B,$05A407,$0508D9,$0D1080,$000780,$0D1080,$0007B3,$050C05
		dc	$0D1080,$000786,$0D1080,$0007A0,$0508D3,$62F000,$000962,$60F400
		dc	$000FC2,$0A72D8,$000004,$240000,$447000,$000960,$5EE800,$0212DF
		dc	$20000B,$05A402,$014180,$547000,$000961,$44F000,$000960,$05094C
		dc	$050811,$44F000,$000960,$0D1080,$0007AA,$56F000,$000960,$014180
		dc	$44F000,$000961,$547000,$000960,$200045,$0597D0,$0D1080,$00076E
		dc	$00000C,$56F000,$000960,$44F000,$00095F,$0C1940,$008020,$547000
		dc	$00093D,$56F000,$000960,$200003,$052454,$62F000,$000962,$60F400
		dc	$00094D,$44F400,$000080,$060690,$000002,$445800,$02129E,$0212D4
		dc	$0C1940,$00101B,$547000,$000930,$44F413,$000012,$0C1940,$005021
		dc	$547000,$000934,$021ADE,$022A94,$0C1940,$001021,$0222D4,$0C1940
		dc	$001022,$022294,$0C1940,$001023,$547000,$000935,$021A94,$447000
		dc	$000942,$200013,$0232D4,$0C1940,$001018,$022AD4,$0C1940,$001019
		dc	$547000,$00093E,$023A94,$447000,$000940,$023294,$447000,$00093F
		dc	$60F413,$00092C,$57F400,$000010,$0D1080,$0002A9,$44F400,$000000
		dc	$200045,$057400,$00000C,$30001B,$0D1080,$0002A1,$00000C,$44F400
		dc	$000015,$447000,$00092C,$44F400,$00094D,$447000,$00092D,$44F400
		dc	$000959,$447000,$00092E,$44F400,$000953,$447000,$00092F,$44F400
		dc	$00FFFF,$447000,$000933,$44F400,$000941,$447000,$000936,$240000
		dc	$447000,$000931,$447000,$000932,$447000,$000937,$447000,$000938
		dc	$447000,$000939,$447000,$00093A,$447000,$00093B,$447000,$00093C
		dc	$60F400,$000947,$44F400,$000000,$445800,$44F400,$000002,$445800
		dc	$44F400,$000003,$445800,$44F400,$000004,$445800,$44F400,$000001
		dc	$445800,$44F400,$000005,$445800,$60F400,$000959,$44F400,$000001
		dc	$060690,$000002,$445800,$60F400,$000953,$44F400,$00FFFF,$060690
		dc	$000002,$445800,$00000C,$62F000,$000962,$45F400,$000003,$021296
		dc	$2000E0,$62F400,$000F92,$210E00,$200040,$60F400,$000080,$219A00
		dc	$70F400,$000100,$56F400,$000005,$79EA00,$0D0180,$200003,$052400
		dc	$00000C,$230800,$00000A,$04C8A0,$0461A0,$0464A0,$0465A0,$0004F8
		dc	$230E00,$200022,$219800,$221400,$044811,$223500,$5FE000,$4FE100
		dc	$5EE078,$06D810,$000009,$45D919,$200016,$8F8000,$8AB868,$4FE119
		dc	$200016,$CF1C00,$CA1D78,$230E00,$223022,$219800,$221400,$044811
		dc	$223500,$5FE000,$4FE100,$5EE078,$06D810,$000009,$45D919,$200016
		dc	$8F8000,$8AB868,$4FE119,$200016,$CF1C00,$CA1D78,$223000,$221400
		dc	$044811,$223500,$5FE000,$45E100,$5EE06C,$06D810,$000009,$4FD919
		dc	$200016,$8F8000,$8AB878,$45E119,$200016,$CF1C00,$CA1D6C,$230E00
		dc	$3A0222,$223000,$219900,$221100,$233200,$221400,$66F400,$000F52
		dc	$204900,$223500,$045A18,$231C00,$231D00,$205200,$5FE000,$F4C100
		dc	$4CDE00,$4FD9AE,$5EE0BF,$06DA10,$000020,$06D210,$000007,$8F8016
		dc	$45E1EE,$8AB8CB,$CF1C16,$4FD9AE,$CA1DBF,$204900,$8F8016,$8AA8EE
		dc	$45E1CB,$CF0C16,$4FD9EA,$CA0DCF,$06D210,$000007,$8F8016,$45E1AE
		dc	$8AB8BF,$CF1C16,$4FD9EA,$CA1DCF,$204900,$8F8016,$8AA8AE,$F4C1BF
		dc	$4CDE00,$CF0C16,$4FD9AE,$CA0DBF,$232F00,$234E2A,$200032,$21B900
		dc	$219A00,$0CCD80,$FFFFCA,$380200,$221400,$231C00,$235200,$66F400
		dc	$000F52,$045811,$231900,$223500,$231D00,$205200,$5FE000,$F4C100
		dc	$4CDE00,$4FC9AE,$5EE0BF,$200016,$8F8000,$8AA8EE,$45E1CB,$CF0C16
		dc	$06D210,$000010,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$F4C1BF
		dc	$4CDE00,$CF0C16,$4FC9AE,$CA0DBF,$200016,$8F8000,$8AA8EE,$45E1CB
		dc	$CF0C16,$4FC9EA,$CA0DCF,$200016,$8F8000,$8AA8AE,$2000BF,$05F420
		dc	$00FFFF,$574C16,$0461A0,$564D00,$0464A0,$0465A0,$00F3B8,$00000C
		dc	$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$00001A,$F0B900
		dc	$06DE10,$00000A,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2,$D0A1E2
		dc	$4549D3,$10DD00,$444C00,$45E1D4,$F039D6,$F0A8E6,$F4A1D2,$4459E2
		dc	$F0A1E2,$4559D3,$564C00,$03F18E,$22D400,$229000,$239800,$0460A4
		dc	$00000C,$71F400,$FFFFFE,$75F400,$FFFFFC,$229600,$06DA10,$000021
		dc	$57DA00,$51D200,$F0B900,$06DE10,$00000B,$45E1D4,$F039D6,$F0A8E6
		dc	$F4A1D2,$4459E2,$D0A1E2,$4549D2,$200010,$10DD09,$444C4C,$45E1D4
		dc	$F039D6,$F0A8E6,$F4A1D2,$4459E2,$F0A1E2,$4559D2,$200010,$21C409
		dc	$444C4C,$03F184,$555A00,$515A00,$22D400,$229000,$239800,$0460A4
		dc	$00000C,$44C800,$2000A0,$44C814,$200011,$06DE10,$000005,$180CA0
		dc	$44C8BA,$200014,$200011,$182400,$2000BA,$00000C,$46C813,$2000E1
		dc	$06DE10,$000003,$46C800,$564CE1,$566400,$00000C,$394000,$233D00
		dc	$204900,$204D00,$045112,$045516,$06D910,$000004,$46D900,$B0B200
		dc	$445600,$38FF00,$231C00,$204100,$204500,$044812,$044C16,$380200
		dc	$72F400,$FFFFFE,$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3
		dc	$5659C8,$D088EB,$063F90,$000005,$D5CAD4,$575DF3,$5659C8,$D088EB
		dc	$575D00,$204000,$204400,$387F00,$231A00,$231C00,$231E00,$204100
		dc	$204500,$204000,$204A00,$204400,$204E00,$380200,$72F400,$FFFFFE
		dc	$3C0200,$76F400,$FFFFFE,$D08800,$D5CAD4,$2000F3,$5679C8,$D088EB
		dc	$063F90,$000005,$D5CAD4,$5F7DF3,$5679C8,$D088EB,$5F7D00,$00000C
		dc	$F1C000,$4DDA00,$4ED8C8,$2000EB,$5F64B0,$06DA10,$000006,$F1C0A7
		dc	$4DDA00,$4ED8C8,$565CEB,$5F64B0,$2000A7,$565C00,$00000C,$F1C000
		dc	$4DDA00,$4EE1C8,$2000EB,$4ED8B0,$44D9A7,$5F64C8,$565CEB,$5F65B0
		dc	$06DA10,$00000A,$F1C0A7,$4DDA00,$4EE1C8,$565DEB,$4ED8B0,$44D9A7
		dc	$5F64C8,$565CEB,$5F65B0,$2000A7,$565D00,$00000C,$F1C000,$4DDA00
		dc	$4EC8A8,$2000BB,$574DE0,$06DA10,$000006,$F1C0C7,$4DDA00,$4EC8A8
		dc	$564CBB,$574DE0,$2000C7,$564C00,$00000C,$F1C100,$4DDA00,$4EE1A8
		dc	$4EE0BB,$44C8E0,$5755C7,$4EE1B8,$565CAB,$44C9E0,$574DC7,$06DA10
		dc	$00000B,$F1C100,$4DDA00,$4EE1A8,$C80CBB,$44C8E0,$5755C7,$4EE1B8
		dc	$565CAB,$44C9E0,$574DC7,$564C00,$00000C,$56D800,$06D910,$000007
		dc	$0C1E01,$20003E,$23A403,$02A048,$56D800,$575900,$205000,$00000C
		dc	$46F400,$000001,$23AE00,$223555,$05A40D,$22B400,$06DC10,$000009
		dc	$56F400,$7FFFFF,$06DD10,$000004,$44DC00,$200045,$027040,$544D00
		dc	$223500,$234F00,$56E20B,$052406,$44F400,$00000F,$200045,$027040
		dc	$546200,$218500,$06DC10,$000004,$56E500,$218564,$544D00,$223500
		dc	$238759,$45F400,$000002,$56E500,$45F465,$FFFFFE,$057417,$45F465
		dc	$000002,$059411,$204D58,$20007D,$05744D,$0597D6,$56E500,$45F465
		dc	$FFFFFE,$057413,$45F465,$000002,$059406,$204D58,$20007D,$057442
		dc	$0597CB,$05A7D5,$20455C,$05A40D,$56E500,$200054,$544D00,$56E500
		dc	$45F450,$000002,$544500,$050FC0,$45F454,$000002,$546500,$050FC7
		dc	$234E00,$204D03,$05A407,$56E200,$200054,$546200,$56E500,$200050
		dc	$546500,$56E200,$200054,$546200,$56E500,$45F450,$000002,$546558
		dc	$050F8B,$223500,$45E200,$06DC10,$000005,$56E500,$200060,$218500
		dc	$544D00,$23AE00,$223555,$05A409,$22B400,$06DC10,$000006,$44CD00
		dc	$06DD10,$000002,$445C00,$000000,$00000C,$44F000,$000B41,$56F000
		dc	$000B94,$200045,$05A413,$209600,$60F400,$000180,$61F400,$000241
		dc	$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$06D910,$000005
		dc	$44D900,$56E000,$0C1E48,$545800,$050C10,$56F000,$000B7B,$200003
		dc	$05A40C,$60F400,$000235,$61F400,$0002F6,$390700,$06D910,$000005
		dc	$44D900,$56E000,$0C1E48,$545800,$00000C,$05F420,$FFFFFF,$0461A0
		dc	$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000000,$20004D
		dc	$05A40C,$44F400,$000010,$20004D,$0D104A,$000011,$300000,$56F400
		dc	$000000,$57F400,$FFFFFF,$00000C,$200013,$567000,$000912,$300000
		dc	$56F400,$000000,$57F400,$000608,$00000C,$050856,$0D1080,$00008C
		dc	$56F000,$000B93,$200003,$05744D,$0D1080,$000136,$0D1080,$000179
		dc	$0D1080,$0001BC,$240000,$447000,$00092B,$56F000,$000B41,$44F000
		dc	$000B94,$200045,$05A409,$0D1080,$00010E,$0D1080,$0001E3,$557000
		dc	$00092B,$0D1080,$0002CB,$0D1080,$0002E3,$0D1080,$0002F2,$0D1080
		dc	$00034D,$0D1080,$000309,$56F000,$000B41,$200003,$0D100A,$0003FE
		dc	$0D1080,$000356,$0D1080,$000383,$0D1080,$00039E,$0D1080,$FFFF87
		dc	$200013,$21101B,$00000C,$205800,$44D800,$447000,$000B42,$44D800
		dc	$447000,$000B43,$44D800,$447000,$000B44,$57D800,$0C1890,$002024
		dc	$507000,$000B78,$0C1890,$00101B,$507000,$000B7B,$0C1890,$003018
		dc	$507000,$000B7A,$44D800,$447000,$000B45,$44D800,$447000,$000B46
		dc	$44D800,$447000,$000B47,$57D800,$0C1890,$006020,$507000,$000B79
		dc	$57D800,$0C1890,$001023,$507000,$00023D,$0C1890,$001022,$507000
		dc	$00023E,$0C1890,$001021,$507000,$00023F,$0C1890,$004018,$507000
		dc	$000240,$61D800,$380600,$204800,$205900,$57D900,$015F8E,$577000
		dc	$000B49,$57D800,$0C1890,$008018,$507000,$000B41,$0C1890,$008020
		dc	$507000,$000B40,$57D800,$0C1890,$001018,$507000,$000B4C,$0C1890
		dc	$001019,$507000,$000B4A,$57D800,$577000,$000B4B,$57E000,$577000
		dc	$000B4D,$00000C,$56F000,$000912,$44F400,$020765,$200045,$052406
		dc	$56F000,$000B40,$200003,$05A45E,$00000C,$60F413,$0004FD,$060690
		dc	$000003,$545800,$545800,$60F413,$0005A8,$060590,$000002,$545800
		dc	$60F413,$00057B,$062890,$000002,$545800,$60F413,$0005AE,$065A90
		dc	$000002,$545800,$60F413,$000608,$060590,$000002,$545800,$60F413
		dc	$00060D,$060590,$000002,$545800,$60F413,$000509,$061090,$000002
		dc	$545800,$60F413,$000519,$060890,$000002,$545800,$60F413,$000521
		dc	$063C90,$000002,$545800,$60F413,$00055D,$061E90,$000002,$545800
		dc	$60F413,$000612,$060093,$000002,$545800,$44F400,$020765,$447000
		dc	$000912,$44F400,$000000,$447000,$000B93,$61F400,$000FC2,$71F000
		dc	$000B7A,$44F000,$000B7B,$5EE900,$547040,$000B94,$547000,$000B95
		dc	$44F01B,$000B94,$2D0513,$2C024D,$05945A,$44F01B,$000B95,$2D0613
		dc	$2C024D,$059455,$56F000,$000B79,$200023,$547000,$000B96,$44F01B
		dc	$000B78,$2D0313,$2C044D,$05944B,$44F01B,$000B96,$2D1313,$2C034D
		dc	$059446,$56F000,$000B79,$0140C4,$000024,$21DA00,$44F000,$000B78
		dc	$46F400,$000006,$2344D0,$0C1D2E,$44F440,$000F4C,$200040,$219100
		dc	$5EE100,$21CF22,$218422,$200022,$577040,$000B97,$218500,$21E46C
		dc	$46F400,$000008,$21A7D0,$5070E8,$000B9A,$457000,$000B98,$5170B0
		dc	$000B9B,$477000,$000B99,$507000,$000B9C,$050C03,$547000,$000B93
		dc	$00000C,$56F400,$000914,$44F000,$000B41,$200040,$219100,$56E100
		dc	$0C1E01,$44F43E,$000001,$20004C,$20291B,$45F403,$000003,$02A068
		dc	$20006D,$027068,$56F400,$000B5E,$44F000,$000B41,$200040,$219000
		dc	$556000,$00000C,$44F000,$000B7A,$46F400,$000006,$44F0D0,$000B41
		dc	$0C1D2E,$44F440,$000F92,$200040,$219400,$56F000,$000B44,$4CE400
		dc	$200040,$219100,$05E120,$56F000,$000B42,$4CE400,$200040,$219100
		dc	$56F000,$000B43,$4CE400,$200040,$219200,$44F400,$000100,$46E200
		dc	$2000D0,$240022,$210600,$2400D0,$46E200,$2400D2,$0C1D2E,$44E140
		dc	$200040,$219000,$70E200,$64F400,$0002FD,$3C0100,$3EFF00,$45F400
		dc	$3FF7CF,$56F000,$00023F,$200003,$05A40F,$56F000,$000B41,$44F432
		dc	$0004FD,$200040,$219100,$47F400,$000347,$57D900,$51D100,$0D04E1
		dc	$555900,$516100,$050C02,$0D04EE,$05F420,$00FFFF,$00000C,$56F000
		dc	$000B41,$44F000,$000B94,$200045,$05A44D,$56F000,$00023D,$200003
		dc	$05A45B,$60F400,$0002FD,$221400,$380100,$231C00,$44F000,$000B41
		dc	$46F400,$00000C,$44F4D0,$000521,$0C1D2E,$200040,$219100,$44F000
		dc	$000B41,$46F400,$000006,$44F4D0,$00055D,$0C1D2E,$200040,$219200
		dc	$56F000,$000240,$0140C4,$000007,$21DA00,$234400,$46F400,$00000F
		dc	$44F4D0,$000814,$0C1D2E,$200040,$219500,$3A0300,$3EFF00,$0D0498
		dc	$050C13,$56F000,$00023E,$200003,$05A40F,$60F400,$0002FD,$221400
		dc	$380100,$231C00,$61F400,$000509,$62F400,$000519,$65F400,$000800
		dc	$3A0400,$3EFF00,$0D04B9,$00000C,$44F000,$000B7A,$46F400,$000006
		dc	$44F0D0,$000B41,$0C1D2E,$44F440,$000F92,$200040,$219100,$4CE100
		dc	$447000,$000913,$61F400,$0002FD,$200013,$44D91B,$060091,$000004
		dc	$200047,$029040,$44D98A,$60F400,$0005A8,$70F000,$000B41,$200032
		dc	$44E826,$566847,$029040,$21C700,$56F400,$000914,$44F000,$000B41
		dc	$200040,$219000,$476000,$0C1C91,$44F000,$000B41,$46F400,$000002
		dc	$44F4D0,$00091A,$0C1D2E,$200040,$219000,$555800,$516000,$00000C
		dc	$60F400,$0002FD,$64F400,$0003FD,$380100,$231C00,$44F000,$000B41
		dc	$46F400,$000008,$44F4D0,$00057B,$0C1D2E,$200040,$219100,$65F400
		dc	$0008A2,$3A0200,$3EFF00,$0D0498,$44F000,$000B41,$46F400,$000012
		dc	$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380E00,$61F400,$0003FD
		dc	$204800,$060490,$000009,$200013,$064090,$000004,$44D900,$200047
		dc	$029040,$200026,$565800,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380800,$57F400,$000002,$204800
		dc	$380600,$060290,$00000B,$221100,$044812,$06CD10,$000006,$44DA00
		dc	$56DA00,$200045,$029040,$565900,$20402A,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600,$62F400
		dc	$0008AF,$390200,$45F41B,$000001,$20A600,$060390,$00000D,$221100
		dc	$4FDA00,$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068
		dc	$20CE00,$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0
		dc	$0005AE,$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800
		dc	$200045,$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A
		dc	$0C1D2E,$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040
		dc	$219000,$44E100,$46F400,$7FFFFF,$44E0D0,$200045,$20291B,$56F400
		dc	$000926,$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41
		dc	$46F400,$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600
		dc	$62F400,$0008AC,$390200,$20A61B,$060390,$00000D,$221100,$4FDA00
		dc	$204900,$44D100,$06C610,$000004,$44C9C0,$44D145,$027068,$20CE00
		dc	$204832,$218600,$44F000,$000B41,$46F400,$000012,$44F4D0,$0005AE
		dc	$0C1D2E,$200040,$219000,$380200,$44F400,$003200,$56E800,$200045
		dc	$20291B,$44F000,$000B41,$46F400,$000002,$44F4D0,$00091A,$0C1D2E
		dc	$200040,$219100,$56F400,$000608,$44F000,$000B41,$200040,$219000
		dc	$44E100,$46F400,$400000,$46E0D0,$446055,$20291B,$56F400,$000B7C
		dc	$44F000,$000B41,$200040,$219000,$556000,$44F000,$000B41,$46F400
		dc	$000012,$44F4D0,$0005AE,$0C1D2E,$200040,$219000,$380600,$20AE00
		dc	$060390,$00000A,$221100,$219900,$221200,$204900,$44D900,$445A00
		dc	$44D900,$445A00,$204832,$00000C,$56F400,$000B7C,$44F000,$000B41
		dc	$200040,$219000,$56F400,$00060D,$44F000,$000B41,$200040,$219100
		dc	$56F400,$000B81,$44F000,$000B41,$200040,$219200,$44E01B,$56E100
		dc	$45F442,$000001,$02A068,$576200,$446100,$00000C,$60F400,$0002FD
		dc	$44F000,$000B41,$46F400,$000080,$44F4D0,$000612,$0C1D2E,$200040
		dc	$219100,$64F400,$0008B2,$65F400,$000000,$0D04F6,$00000C,$56F000
		dc	$00092B,$200003,$05A40E,$60F400,$000000,$61F400,$000040,$221400
		dc	$223500,$62F400,$000AB2,$66F400,$000AF2,$3A3F00,$0D0547,$050C0A
		dc	$60F400,$000000,$221400,$62F400,$0009B2,$66F400,$000A32,$3A7F00
		dc	$0D0538,$00000C,$0500A0,$0461A0,$56F000,$00092B,$200003,$05A415
		dc	$60F400,$000000,$61F400,$000040,$64F400,$0003FD,$65F400,$0004FC
		dc	$62F400,$000AB2,$66F400,$000AF2,$382000,$231900,$3A3F00,$3C0300
		dc	$75F400,$FFFFFD,$0D056D,$050C11,$60F400,$000000,$64F400,$0003FD
		dc	$65F400,$0004FC,$62F400,$0009B2,$66F400,$000A32,$384000,$3A7F00
		dc	$3C0200,$75F400,$FFFFFE,$0D055E,$05F420,$00FFFF,$0461A0,$56F000
		dc	$000B41,$44F000,$000B94,$60F445,$0003FD,$05A408,$61F400,$000180
		dc	$06B590,$000003,$44D800,$445900,$050C07,$61F400,$000235,$060790
		dc	$000003,$44D800,$445900,$00000C,$56F000,$00092B,$200003,$05A40A
		dc	$60F400,$000000,$384000,$0D03E9,$60F400,$000040,$384000,$0D03E9
		dc	$050C05,$60F400,$000000,$388000,$0D03E9,$00000C,$56F000,$000B94
		dc	$44F000,$000B41,$45F445,$000001,$05A403,$05080D,$050C03,$457000
		dc	$000B8C,$60F400,$000B7C,$61F400,$0005A3,$060590,$000003,$44D800
		dc	$445900,$00000C,$290300,$70F000,$000B41,$60F400,$000B7C,$56E800
		dc	$014185,$05A410,$60F400,$000926,$56E800,$014185,$05A40B,$56F000
		dc	$000B40,$014085,$05A406,$60F400,$0005A3,$56E800,$014185,$05A402
		dc	$290200,$60F400,$000B87,$516800,$00000C,$3D1800,$44F000,$000B41
		dc	$56F000,$000B94,$60F445,$000180,$05A40C,$209600,$61F400,$000241
		dc	$56F400,$000BA2,$22C400,$200040,$219200,$71E200,$0D0585,$050C0A
		dc	$56F000,$000B7B,$60F403,$000235,$05A405,$61F400,$0002F6,$390700
		dc	$0D0585,$00000C,$000000,$000000,$000000,$000000,$000000,$000000
		dc	$320000,$06FF9F,$000002,$5EDA00,$44F000,$000B41,$56F000,$000B94
		dc	$61F445,$000241,$05A459,$56F400,$000B87,$44F000,$000B41,$200040
		dc	$219000,$56F400,$000BA2,$44F000,$000B41,$200040,$219200,$56E000
		dc	$71E200,$219400,$223600,$56F400,$000B59,$44F000,$000B41,$200040
		dc	$219000,$56F400,$000B8E,$44F000,$000B41,$200040,$219200,$232E00
		dc	$014184,$0B74C4,$000F16,$218500,$47F4AD,$000001,$0B74C4,$000F12
		dc	$21E600,$209DD0,$0C1D2E,$46F465,$2AAAAB,$202978,$556000,$21A500
		dc	$21BCE9,$0C1D82,$200010,$200065,$202978,$556200,$223200,$205900
		dc	$3A0000,$0D0590,$050C11,$56F000,$000B7B,$60F403,$000B8C,$05A40C
		dc	$61F400,$0002F6,$390700,$223600,$223200,$205900,$3A0000,$3C0600
		dc	$7DF000,$000F13,$0D0590,$00000C,$56F000,$000240,$0C1D04,$21C700
		dc	$46F400,$000003,$2000B0,$0C1D2E,$0140C0,$000049,$21C600,$61F400
		dc	$000B9D,$62F400,$000BA2,$45F000,$000B94,$06C510,$000003,$475900
		dc	$465A00,$57F400,$000001,$56F000,$000B40,$200003,$05A402,$20001B
		dc	$577000,$000B8D,$00000C,$56F400,$00000A,$57F400,$000000,$70F400
		dc	$000416,$0BF080,$000180,$200003,$052400,$00000C,$56F400,$00000A
		dc	$57F400,$000001,$60F400,$0004FD,$70F400,$000416,$390000,$0BF080
		dc	$000180,$200003,$052400,$00000C,$56F400,$00000A,$57F400,$000002
		dc	$60F400,$0004FD,$70F400,$000416,$390000,$0BF080,$000180,$200003
		dc	$052400,$00000C,$56F400,$000011,$57F400,$000001,$390000,$70F400
		dc	$000080,$60F400,$000B40,$0BF080,$000180,$200003,$052400,$00000C
		dc	$56F400,$00000D,$57F400,$000000,$70F400,$000390,$0BF080,$000180
		dc	$200003,$052400,$56F400,$00000E,$57F400,$000000,$70F400,$000390
		dc	$0BF080,$000180,$200003,$052400,$00000C,$447000,$000963,$56F000
		dc	$000B94,$200045,$052407,$71F400,$000389,$380700,$60F400,$000235
		dc	$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000180,$211900,$56F400
		dc	$00000D,$57F400,$000002,$0BF080,$000180,$200003,$052400,$44F000
		dc	$000963,$56F000,$000B94,$200045,$052407,$71F400,$000389,$380700
		dc	$60F400,$0002F6,$050C07,$46F400,$0000B5,$20D8D0,$60F422,$000241
		dc	$211900,$56F400,$00000E,$57F400,$000002,$0BF080,$000180,$200003
		dc	$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\sysmem.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			sysmem.asm
;												
;   Contents:		Game Encoder System memory Simulator
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/9/2000 5:46:11 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'System Memory'

	section	Sysmem

;**** include files ************************************************

	nolist
	include 'ldr_sip.inc'
	include 'se_sip.inc'
	list

;**** equates ******************************************************

SYSMEM_HEAP_SIZE		equ		8192
AC3_OUT_BUFF_SIZE		equ		3072
PCM_LTRT_OUT_BUFF_SIZE	equ		512
PCM_IN_BUFF_SIZE		equ		1536

;**** program code *************************************************

	org		x(100):

SysLdrTable:
	dc		LDR_SYSTABLE_SIZE		; table size
	dc		LID_MAX_PROG			; number of programs
	dc		prog_1_ptr				; pointer to program #1
	dc		prog_1_size				; size of program #1
	dc		prog_2_ptr				; pointer to program #2
	dc		prog_2_size				; size of program #2
	dc		prog_3_ptr				; pointer to program #3
	dc		prog_3_size				; size of program #3
	dc		prog_4_ptr				; pointer to program #4
	dc		prog_4_size				; size of program #4
	dc		pcm_ptr					; pointer to input PCM buffer
	dc		pcm_size				; size of input PCM buffer
	dc		ltrt_ptr				; pointer to output Lt/Rt buffer
	dc		ltrt_size				; size of output Lt/Rt buffer
	dc		ac3_ptr					; pointer to output AC-3 buffer
	dc		ac3_size				; size of output AC-3 buffer
	dc		config_ptr				; configuration data pointer
	dc		config_size				; configuration data size
	dc		heap_ptr				; pointer to heap data buffer
	dc		heap_size				; size of heap data buffer

prog_1_ptr:
	nolist
	include 'encds.asm'				; Dolby Surround Program Code
	list
prog_1_size	equ		(*)-prog_1_ptr

prog_2_ptr:
	nolist
	include 'llef13.asm'			; Game Encoder Fcn 1 Program Code
	list
prog_2_size	equ		(*)-prog_2_ptr

prog_3_ptr:
	nolist
	include 'llef23.asm'			; Game Encoder Fcn 2 Program Code
	list
prog_3_size	equ		(*)-prog_3_ptr

prog_4_ptr:
	nolist
	include 'llef33.asm'			; Game Encoder Fcn 3 Program Code
	list
prog_4_size	equ		(*)-prog_4_ptr

	org		x(101):

pcm_ptr		ds		PCM_IN_BUFF_SIZE		; PCM Input Buffer
pcm_size	equ		(*)-pcm_ptr

	org		x(102):

ltrt_ptr	ds		PCM_LTRT_OUT_BUFF_SIZE	; PCM Lt/Rt Output Buuffer
ltrt_size	equ		(*)-ltrt_ptr

	org		x(103):

ac3_ptr		bsc		AC3_OUT_BUFF_SIZE,0		; AC-3 Output Buffer
ac3_size	equ		(*)-ac3_ptr

	org		x(104):

config_ptr:
	nolist
	include 'lleconfg.asm'					; System Configuration data
	list
config_size	equ		(*)-config_ptr

	org		x(105):

heap_ptr	ds		SYSMEM_HEAP_SIZE		; Heap
heap_size	equ		(*)-heap_ptr

	org		y(301):
	nolist	
	include 'lleyrom.asm'					; Game Encoder ROM
	list	

;**** program code *************************************************

	endsec	; Sysmem
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\llef23.asm ===
;	File info
;	  File name: llef23.asm
;	  Build date: 01/10/01, 11:05:00
;	Program info
;	  Program number: 3
;	  Revision number: 1.51
;	  Load address: p:$000300
;	  Entry point: p:$000304
;	  Size: 1626 words
;	  Checksum: $79FDD6

		dc	$D01B40,$00065A,$030133,$79FDD6,$20000B,$0D1002,$000625,$0D1080
		dc	$000615,$57F400,$000010,$300000,$0D1080,$000211,$44F400,$000000
		dc	$200045,$057400,$0D1080,$00062D,$00000C,$46F461,$000010,$230700
		dc	$06D910,$00000A,$50D97C,$057407,$21E478,$0C1E46,$0C1E90,$21E449
		dc	$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F461,$000010,$230700
		dc	$50D97C,$057407,$21E478,$0C1E46,$0C1E90,$21E449,$545A58,$0C1E68
		dc	$0C1E4E,$218500,$00000C,$46F400,$000010,$230700,$06D910,$00000D
		dc	$56D900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449
		dc	$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$46F400,$000010,$230700
		dc	$56D900,$0C1E6E,$20AC7C,$057407,$21E478,$0C1E46,$0C1E90,$21E449
		dc	$545A58,$0C1E68,$0C1E4E,$218500,$00000C,$61F400,$000D12,$46F400
		dc	$0000FF,$06D810,$00000E,$0C1C90,$200056,$51D800,$219900,$0C1D91
		dc	$4CE900,$20004B,$0C1C90,$200056,$219900,$0C1D91,$4CE900,$20004B
		dc	$0C1E91,$21AE00,$0C1C11,$00000C,$61F41B,$000E12,$46F400,$0000FF
		dc	$204800,$06D810,$00000D,$21AE5E,$44F800,$21B900,$0C1ED0,$200042
		dc	$4CE900,$200043,$218F56,$219900,$0C1ED1,$4CE900,$20004B,$0C1E91
		dc	$21AE00,$0C1C11,$00000C,$0003F6,$0003F6,$0003F6,$000408,$000408
		dc	$000408,$000403,$000420,$000420,$000420,$000420,$000420,$000420
		dc	$000420,$000420,$000420,$000420,$000420,$000420,$000420,$00042C
		dc	$00042C,$00042C,$00043D,$00043D,$00043D,$00043D,$00043D,$00043D
		dc	$00043D,$00043D,$00043D,$00043D,$00043D,$00043D,$00043D,$00043D
		dc	$00043D,$00043D,$00043D,$00043D,$00043D,$00043D,$00043D,$00043D
		dc	$00043D,$00043D,$00043D,$00043D,$00043D,$22B100,$231900,$204800
		dc	$204900,$45F41B,$000040,$51F400,$000C00,$44D801,$06DC10,$000003
		dc	$44D8A6,$505901,$240000,$447000,$000492,$240000,$447000,$000491
		dc	$231000,$22B800,$74F400,$000383,$65F400,$000B32,$44F000,$000B7B
		dc	$46F400,$000032,$2244D0,$0C1D2E,$44F440,$000C1C,$200040,$219600
		dc	$390100,$0B72CE,$000F1A,$23C400,$220745,$027040,$232474,$57E844
		dc	$205800,$45E800,$05A40D,$47F400,$0000D1,$06CC10,$000009,$21EE6C
		dc	$029060,$20582E,$45E82B,$21BD7D,$4CED00,$202F40,$21CF00,$225400
		dc	$44F461,$000100,$07EC94,$47F044,$000491,$0AE480,$57700D,$000493
		dc	$05F408,$20EE6D,$05F458,$0140C4,$000040,$202913,$218700,$050C53
		dc	$47F400,$000180,$050C50,$218600,$23CE00,$014785,$05A40D,$20CE00
		dc	$20000D,$05F408,$20EE6D,$05F408,$0140C4,$000040,$202913,$218700
		dc	$050C03,$47F400,$000180,$44F000,$000493,$56F04D,$000492,$557000
		dc	$000493,$059404,$232E00,$717000,$000492,$200003,$05A414,$050C1E
		dc	$20000D,$05F408,$20EE6D,$05F41A,$0140C4,$000040,$202913,$218700
		dc	$050C15,$47F400,$000140,$050C12,$200071,$0140C4,$000080,$202913
		dc	$218700,$050C0C,$44F001,$00048F,$44F044,$00048E,$547001,$00048B
		dc	$477044,$000491,$547074,$00048A,$050C1B,$56F000,$00048B,$44F000
		dc	$00048D,$44F044,$00048F,$218601,$45F044,$00048A,$44F055,$00048C
		dc	$029050,$547061,$00048B,$44F044,$00048E,$218601,$477044,$000491
		dc	$44F055,$00048B,$029050,$547074,$00048A,$200045,$029040,$44F000
		dc	$000490,$4EDE4C,$0C1C85,$202914,$200055,$029050,$546A00,$220E00
		dc	$23C400,$205A45,$0596D7,$00000C,$56F000,$0004B7,$44F003,$0004A2
		dc	$05A407,$20EE00,$240064,$06CC10,$000002,$445900,$050C4D,$64F400
		dc	$000CBA,$66F400,$0004A5,$57DA00,$46F04C,$0004BF,$20005C,$20291B
		dc	$0140CE,$001FE0,$5EDD58,$200075,$027070,$21C564,$014184,$219E00
		dc	$56D800,$46F414,$00003F,$202913,$0C1ECA,$200055,$027050,$219C00
		dc	$06DE10,$00000B,$56D800,$7EEC14,$202913,$0C1ECA,$765955,$027050
		dc	$219C00,$56EE00,$014180,$546E00,$7EEC00,$765900,$56EE00,$014180
		dc	$546E71,$200065,$057799,$00000C,$60F400,$000B68,$70F000,$000B40
		dc	$57E800,$44F000,$000B7A,$20004C,$20000B,$05140C,$200013,$567000
		dc	$000B66,$567000,$000B67,$567000,$0004A4,$567000,$000B6E,$0D10C0
		dc	$000027,$200013,$21D800,$44F000,$000B70,$200045,$059404,$56F400
		dc	$000009,$21D800,$200005,$05F409,$200013,$567000,$000B66,$567000
		dc	$000B67,$567000,$0004A4,$050C13,$56F400,$000001,$567000,$000B66
		dc	$21EE00,$230400,$200044,$0C1C06,$280000,$567000,$000B67,$0C1D06
		dc	$230400,$200040,$567000,$0004A4,$21C400,$20004C,$56F000,$000B40
		dc	$44F400,$000005,$200045,$052413,$56F000,$000B9F,$44F000,$000B7A
		dc	$200044,$44F000,$000B53,$200044,$21D900,$577000,$000B6E,$200003
		dc	$059404,$200005,$05F402,$050C03,$232400,$208F00,$56F000,$000B70
		dc	$200003,$05F40A,$44F400,$000001,$447000,$000B66,$44F000,$000B67
		dc	$200040,$567000,$000B67,$00000C,$221100,$22B200,$46F469,$000002
		dc	$06D810,$000005,$56C900,$218F14,$200050,$545A00,$234E00,$234432
		dc	$230440,$240044,$05A404,$06CC10,$000002,$445A00,$22B000,$229100
		dc	$65F400,$000D0D,$75F400,$FFFFFE,$06DA10,$000007,$F0B800,$F0B8D0
		dc	$D0B8D2,$2000D2,$200022,$505900,$00000C,$05F420,$FFFFFF,$0461A0
		dc	$0462A0,$0464A0,$0465A0,$0466A0,$00F3B8,$44F400,$000000,$20004D
		dc	$05A40C,$44F400,$000010,$20004D,$0D104A,$00000F,$300000,$56F400
		dc	$000000,$57F400,$FFFFFF,$00000C,$200013,$300000,$56F400,$000000
		dc	$57F400,$000608,$00000C,$56F000,$000B40,$2E0003,$052402,$014180
		dc	$567000,$000B89,$0D1080,$00038B,$44F400,$0004C6,$447000,$000B72
		dc	$0D1080,$000014,$56F000,$000B40,$2E0003,$052403,$0D1080,$000353
		dc	$0D1080,$00009D,$56F000,$000B96,$200003,$052403,$0D1080,$00019C
		dc	$200013,$21101B,$00000C,$00000C,$44F400,$000001,$447000,$000B6F
		dc	$56F01B,$000B40,$200003,$052402,$000009,$517000,$0004C0,$300200
		dc	$310100,$320100,$350200,$0B70C4,$000C08,$447000,$00048D,$0B71C4
		dc	$000C04,$447000,$00048C,$0B72C4,$000C14,$447000,$00048F,$0B75C4
		dc	$000C18,$447000,$000490,$360000,$44F000,$000B97,$06C410,$00004E
		dc	$280100,$507000,$0004C0,$300400,$0B70C4,$000C0C,$447000,$00048E
		dc	$44F400,$FF8000,$447000,$00048A,$44F400,$FF8000,$447000,$00048B
		dc	$22C400,$46F400,$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040,$219000
		dc	$22C400,$46F400,$0000B5,$44F4D0,$0000FA,$0C1D2E,$200040,$219500
		dc	$22C400,$46F400,$000032,$44F4D0,$000000,$0C1D2E,$200040,$219A00
		dc	$380000,$56F400,$000BA5,$22C400,$200040,$219100,$74E100,$76E100
		dc	$320000,$667000,$000B41,$0D03B5,$66F000,$000B41,$56F400,$0004C1
		dc	$22C400,$200040,$219000,$626000,$56F400,$000494,$22C400,$200040
		dc	$219000,$44F000,$00048A,$446000,$56F400,$000499,$22C400,$200040
		dc	$219000,$44F000,$00048B,$446000,$205E00,$56F000,$000B7E,$200003
		dc	$05A41C,$280100,$507000,$0004C0,$300400,$0B70C4,$000C0C,$447000
		dc	$00048E,$44F400,$FF8000,$447000,$00048A,$44F400,$FF8000,$447000
		dc	$00048B,$60F400,$000483,$65F400,$000483,$72F400,$0004B8,$380000
		dc	$3C0700,$3E0700,$320000,$0D03B5,$00000C,$56F000,$000B40,$200003
		dc	$052404,$240000,$447000,$000B6E,$340000,$20001B,$44F000,$000B97
		dc	$06C410,$000003,$014188,$014188,$014188,$56F000,$000B7D,$200003
		dc	$052402,$014188,$56F000,$000B4A,$44F403,$000008,$05A402,$200048
		dc	$014188,$56F000,$000B89,$200003,$05A402,$014188,$56F000,$000B7D
		dc	$014285,$052407,$014188,$56F000,$000B40,$44F403,$000004,$202A48
		dc	$44F000,$000B97,$06C410,$000002,$014288,$56F000,$000B7E,$200003
		dc	$05A402,$014188,$56F400,$000B8A,$240000,$200040,$219000,$44F000
		dc	$000B97,$06C410,$000006,$56D800,$200003,$05A402,$014688,$000000
		dc	$60F400,$000B8A,$61F400,$000B91,$46F400,$000007,$44F000,$000B97
		dc	$06C410,$00000A,$56D800,$44D903,$05A406,$014488,$2000D0,$0C1D2E
		dc	$200018,$014288,$000000,$56F000,$000B7E,$200003,$05A408,$56F000
		dc	$000B8F,$44F403,$00000E,$05A403,$014488,$200048,$014188,$56F000
		dc	$000B90,$200003,$05A406,$014288,$014288,$014288,$014288,$014388
		dc	$014188,$56F000,$000B6F,$200003,$05A40E,$014688,$44F000,$000B97
		dc	$06C410,$000003,$014488,$014388,$56F000,$000B7E,$200003,$05A403
		dc	$014488,$014388,$014188,$014188,$21E71B,$56F000,$000B40,$0140C5
		dc	$000003,$0D1042,$00000D,$21E779,$014988,$21E779,$014188,$014188
		dc	$56F000,$000B40,$0140C5,$000003,$052402,$016F88,$014788,$0C1EC7
		dc	$557000,$000B70,$0C1E87,$21E479,$200048,$557000,$000B71,$56F000
		dc	$000B40,$200003,$052407,$20001B,$014188,$014188,$015088,$557000
		dc	$000B53,$56F000,$000B40,$200003,$05248C,$57F000,$000B51,$44F000
		dc	$000B53,$200048,$44F000,$000B9A,$46F400,$000008,$2000D0,$210E00
		dc	$200014,$547000,$000B52,$56F000,$000B53,$44F000,$000B9F,$200045
		dc	$057485,$44F41B,$155555,$56F000,$000B52,$0140C4,$00002F,$218500
		dc	$2000A8,$21AF00,$44F000,$000B71,$20004D,$05F458,$21A500,$44F400
		dc	$000006,$2000A0,$0C1D2E,$44F036,$000B52,$200040,$0140C4,$00002F
		dc	$21C700,$0140C8,$000001,$56F400,$000B68,$240000,$200040,$219000
		dc	$20F800,$06D810,$000002,$575800,$0140CC,$000001,$56F400,$000006
		dc	$200074,$200003,$05F405,$21D800,$06D810,$000002,$575800,$56F400
		dc	$000B68,$44F400,$000003,$200040,$219000,$56E000,$016F80,$566000
		dc	$56F400,$000B68,$240000,$200040,$219000,$70F000,$000B40,$56E800
		dc	$44F000,$000B71,$200044,$566800,$00000C,$44F400,$000001,$447000
		dc	$000B96,$00000C,$0D1080,$000023,$200003,$05A41B,$0D1080,$FFFDA6
		dc	$56F400,$000005,$44F000,$000B40,$200045,$05F417,$56F400,$000B68
		dc	$44F000,$000B40,$200040,$0140C0,$000001,$21D000,$56D000,$44D800
		dc	$200040,$44F000,$000B7A,$45F044,$0004A4,$200064,$566000,$050C05
		dc	$0D1080,$000158,$0D1080,$FFFD8A,$00000C,$45F400,$FFFF90,$457000
		dc	$00049F,$0D1080,$00007C,$44F400,$000008,$447000,$00049E,$240000
		dc	$447000,$0004B5,$50F000,$00049E,$00000A,$507000,$00049E,$0D1080
		dc	$000087,$20000B,$059409,$44F400,$000001,$447000,$0004B5,$44F000
		dc	$00049F,$447000,$0004B6,$56F000,$0004B5,$200003,$05A40F,$56F400
		dc	$000010,$21C400,$567000,$0004A0,$56F000,$00049F,$567000,$0004A1
		dc	$200040,$200022,$567000,$00049F,$050C0E,$56F400,$FFFF10,$21C400
		dc	$567000,$0004A1,$56F000,$00049F,$567000,$0004A0,$200040,$200022
		dc	$567000,$00049F,$0D1080,$000043,$0D1080,$00005A,$20000B,$05940E
		dc	$44F000,$00049F,$447000,$0004A1,$44F400,$000001,$447000,$0004B5
		dc	$44F000,$00049F,$447000,$0004B6,$050C05,$44F000,$00049F,$447000
		dc	$0004A0,$56F000,$0004A0,$44F000,$0004A1,$21C644,$0140C5,$000001
		dc	$052408,$0D1080,$000128,$44F400,$000001,$447000,$0004B5,$050C1B
		dc	$200051,$200040,$200022,$200045,$057404,$208E00,$014180,$050C05
		dc	$200055,$059403,$20CE00,$014184,$547000,$00049F,$56F000,$00049E
		dc	$014184,$547000,$00049E,$057787,$56F000,$0004B5,$014185,$052403
		dc	$0D1080,$000109,$56F000,$0004B5,$00000C,$56F000,$00049F,$0140C0
		dc	$0000F0,$0C1C08,$218400,$2C0000,$0C1D08,$218600,$60F400,$000B73
		dc	$62F400,$000B79,$64F400,$000B74,$3C0500,$70F000,$000B97,$229500
		dc	$445800,$465A00,$06D810,$000002,$465D00,$00000C,$70F000,$000B40
		dc	$60F400,$000B68,$57E800,$21FA00,$56F000,$0004C0,$200003,$05A545
		dc	$56F400,$000001,$567000,$0004B7,$56F400,$000000,$44F000,$000B73
		dc	$200045,$05A404,$240000,$447000,$0004B7,$46F400,$000000,$60F400
		dc	$000B74,$44F000,$000B97,$06C410,$000008,$56D800,$200055,$05A404
		dc	$200013,$567000,$0004B7,$000000,$56F000,$000B7E,$200003,$05A408
		dc	$56F000,$000B79,$200055,$05A404,$200013,$567000,$0004B7,$300700
		dc	$0B70C4,$000CB2,$447000,$0004BF,$60F413,$0004A5,$061090,$000002
		dc	$565800,$360000,$44F000,$000B97,$06C410,$000036,$56F400,$000B74
		dc	$22C400,$200040,$219000,$56F000,$000B73,$44E000,$014F84,$0C1D08
		dc	$200040,$0C1D04,$547000,$0004A2,$56F400,$000BA5,$22C400,$200040
		dc	$219000,$250000,$47E000,$22C400,$46F400,$0000B5,$44F4D0,$0000FA
		dc	$0C1D2E,$200040,$219000,$22C400,$46F400,$0000B5,$44F0D0,$000B72
		dc	$0C1D2E,$200040,$219100,$22C400,$46F400,$000032,$44F4D0,$000000
		dc	$0C1D2E,$200040,$219200,$65F400,$000F1A,$667000,$000B41,$0D0464
		dc	$66F000,$000B41,$205E00,$56F000,$000B7E,$200003,$05A417,$56F000
		dc	$000B73,$44F000,$000B79,$014F84,$0C1D08,$200040,$0C1D04,$547000
		dc	$0004A2,$250000,$47F400,$000007,$60F400,$000483,$61F400,$00084F
		dc	$62F400,$0004B8,$65F400,$000F1A,$0D0464,$60F400,$0004A6,$66F41B
		dc	$000CFB,$44D800,$47F413,$D55555,$20E800,$4EDEC6,$218413,$44D8DA
		dc	$20E800,$4EDEC6,$218400,$F0D8DA,$44D8DA,$47F413,$C00000,$20E800
		dc	$4EDEC6,$218400,$2000DA,$F0D800,$060A90,$000002,$F0D8DA,$2000DA
		dc	$0C1DAE,$567000,$000B7A,$050C02,$050C00,$44F01B,$000B7A,$234F00
		dc	$20004C,$21FA00,$20000B,$051402,$050C03,$0D1080,$FFFC37,$00000C
		dc	$60F41B,$000B7A,$576000,$60F400,$000B73,$62F400,$000B79,$64F400
		dc	$000B74,$70F000,$000B97,$229500,$576000,$576200,$06D810,$000002
		dc	$575D00,$360000,$44F000,$000B97,$06C410,$000012,$22C400,$46F400
		dc	$0000B5,$44F0D0,$000B72,$0C1D2E,$200040,$219000,$56F400,$000BA5
		dc	$22C400,$200040,$219200,$066210,$000002,$575800,$205E00,$56F000
		dc	$000B7E,$200003,$05A406,$60F400,$00084F,$060790,$000002,$575800
		dc	$00000C,$44F000,$0004B6,$447000,$00049F,$0D1080,$FFFEF8,$050A0F
		dc	$00000C,$20001B,$015088,$015088,$014288,$014688,$014588,$014388
		dc	$014388,$56F000,$000B7D,$014185,$05A404,$014186,$05A402,$014288
		dc	$56F000,$000B7D,$014486,$05A402,$014288,$56F000,$000B7D,$014285
		dc	$052402,$014288,$014188,$014588,$014188,$56F000,$000B4C,$44F403
		dc	$000008,$05A402,$200048,$014188,$014188,$014188,$014188,$014188
		dc	$014188,$014188,$577000,$000B51,$00000C,$360000,$44F000,$000B97
		dc	$06C410,$000034,$56F400,$000B8A,$22C400,$200040,$219000,$56E000
		dc	$219203,$05A44B,$22C400,$46F400,$0000B5,$44F4D0,$0000FA,$0C1D2E
		dc	$200040,$219000,$56F400,$000B5C,$22C400,$200040,$219100,$70E100
		dc	$0B72D9,$000F12,$56F400,$000B91,$22C400,$200040,$219100,$72E100
		dc	$45D800,$22C400,$46F400,$0000B5,$44F4D0,$0004C6,$0C1D2E,$200040
		dc	$219500,$455D00,$22C400,$46F400,$00001F,$44F4D0,$000856,$0C1D2E
		dc	$200040,$219400,$455C00,$0D04FC,$205E00,$56F000,$000B7E,$200003
		dc	$05A413,$56F000,$000B8F,$200003,$05A40F,$60F400,$000483,$380600
		dc	$79F000,$000F13,$3A0200,$45D800,$65F400,$00084F,$455D00,$64F400
		dc	$0008F1,$455C00,$0D04FC,$00000C,$56F400,$000011,$57F400,$000001
		dc	$70F400,$000390,$390000,$60F400,$0000FA,$0BF080,$000180,$200003
		dc	$052400,$00000C,$56F400,$000012,$57F400,$000000,$70F400,$000390
		dc	$0BF080,$000180,$200003,$052400,$56F400,$000013,$57F400,$000000
		dc	$70F400,$0000A2,$0BF080,$000180,$200003,$052400,$00000C,$56F400
		dc	$000012,$57F400,$000002,$70F400,$000390,$390000,$60F400,$0004C6
		dc	$0BF080,$000180,$200003,$052400,$56F400,$000013,$57F400,$000002
		dc	$70F400,$0000A2,$390000,$60F400,$000856,$0BF080,$000180,$200003
		dc	$052400,$00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\loader.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			loader.asm
;												
;   Contents:		Loader for Dolby Game Encoder
;
;	Author:			jmw
;											
;	Revision:		1.00b
;											
;	History:
;
;		Rev 1.00	10/11/2000 7:23:25 AM		jmw
;	          Created.
;               Rev 1.00b       12/11/2000 4:11:12 PM           Ethan Brodsky
;        	  brought DMA code over from Dolby/v1.20 package
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'Dolby Loader'

	section	Loader

;**** include files ************************************************

	nolist
	include 'ldr_sip.inc'
	include 'eputil.h'    ; EP constants
	include 'dmautil.h'   ; DMA constants
	list

;**** equates ******************************************************

	;DEFINE	ERRCHK	'1'			; Enable error checking

	IF		!@DEF('RTSYS')
	DEFINE	CHKSUM	'0'			; Enable program checksum
	ENDIF

	DEFINE	PREAMBLE	'1'		; Enable AC3 SPDIF Preamble
	DEFINE	ZEROFILL	'1'		; Enable AC3 SPDIF Zero Fill


;**** macros ******************************************************


debug_wait macro
_wait_for_flag
    move    p:debug_enable,a
    cmp     #0,a
    beq     _wait_no_debug
    move    p:debug_wait_flag,a
    cmp     #0,a
	beq     _wait_for_flag
_wait_no_debug
    move    #0,x0
    move    x0,p:debug_wait_flag
	endm

;**** program code *************************************************

	xref	LdrTable


	org		p(100):				; Loader Runtime Counter is 100

;******************************************************************************
;*										  
;*   Subroutine Name:	Loader
;*								  
;*   Description:		Loader
;*										      
;*   Input:				a	- Buffer ID word
;*						b	- Loader action
;*						r0	- DSP memory address
;*						n0	- number of words to transfer
;*						n1	- System memory offset
;*
;*   Output:			a	- error return code: nonzero if error
;*
;*   Modifies:			
;*
;*	 Locals:			
;*
;*	 Stack Space Used:	
;*										      
;******************************************************************************

loader:
	move	#LdrTable,r2			; set up loader table base
	move	a1,n2					; set up loader table offset
    move    #1,n5                   ; set Flag indicating DMAs are blocking type
	

;	Check Buffer ID to see what to do, check for errors along the way

	IF		@DEF('ERRCHK')
	cmp		#LID_MIN,a				; is ID too small?
	blt		<abort_id				; if so, abort
	cmp		#LID_MAX,a				; is ID too big?
	bgt		<abort_id				; if so, abort
	ENDIF


	cmp		#LID_LOADER_INIT,a		; loader init request?
	beq		<loader_init		    ; if so, go init the loader

	move	(r2)+n2					; point into table (halfway)
	move	(r2)+n2					; point into table
	move	p:(r2)+,r1				; get system memory address
							; (or FIFO index, in case of ac3/rtlt)

	cmp		#LID_BUF_DATA,a			; is ID a heap data buffer?
	bge		<heap_id				; if so, go parse heap buffer params
	cmp		#LID_MAX_PROG,a			; is ID a program?
	ble		<load_program			; if so, go load program
	cmp		#LID_BUF_AC3,a			; is ID for output AC-3?
	beq		<save_ac3				; if so, save AC-3
	cmp		#LID_CONFIG_LIST,a		; is ID system configuration data?
	beq		<load_config			; if so, go load configuration list
	cmp		#LID_PING_PONG,a		; should we toggle the PCM input ping pong
	beq		<toggle_ping_pong

	cmp		#LID_AC3_ZEROS,a		; is ID for zero fill of AC-3 output buffer?
	beq		<SPDIFzerofill			; if so, go zero fill
	cmp		#LID_AC3_PREAMBLE,a		; is ID to write AC3 S/PDIF preamble?
	beq		<SPDIFpreamble			; if so, go write SPDIF preamble

	cmp		#LID_BUF_LTRT,a
	beq		<save_ltrt				; save Lt/Rt

	bra		<load_pcm				; if so, load pcm

;***********************************************************************
;	Data storage for loader variables

ldr_heap_ptr		dc		0		; current heap pointer
ldr_heap_size		dc		0		; current heap size
	IF		@DEF('CHKSUM')
ldr_r0_copy			dc		0		; copy of r0 input argument
ldr_n0_copy			dc		0		; copy of n0
	ENDIF	; @DEF('CHKSUM')

debug_wait_flag			dc      0		;
debug_enable            dc      1

dmaNode	                dc	    0
dmaNode1                dc	    0
dmaNode2	            dc	    0
dmaNode3	            dc	    0
dmaNode4	            dc	    0
dmaNode5	            dc	    0
dmaNode6	            dc	    0



;***********************************************************************
;	Load configuration data from system
;		uses input DSP address, gets length from loader table
;		ignores input action, offset, and length

load_config:

	move	p:(r2)+,a				; get length from Sys Mem
	move	n0,x0					; copy max length to x0
	cmp		x0,a a1,n0				; compare two lengths. preload length
	IF		@DEF('ERRCHK')
	bgt		<abort_length			; if SysMem length to large, fail
	ENDIF

	bsr		<CopySysToDSPX			; copy list

	bra		<done

;***********************************************************************
;	Load a program
;		uses input DSP address, gets length from loader table
;		ignores input action, offset, and length
;		error checking for program checksum

load_program:
	move	p:(r2)+,n0				; get program size
	IF		@DEF('CHKSUM')
	move	r0,p:ldr_r0_copy		; save r0
	move	n0,p:ldr_n0_copy		; save n0
	ENDIF	; @DEF('CHKSUM')
	bsr		<CopySysToDSPP			; copy program
	IF		@DEF('CHKSUM')
	clr		a						; init checksum
	move	p:ldr_n0_copy,n0		; restore n0
	move	p:ldr_r0_copy,r0		; restore r0
	dor		n0,checksumlp
	move	p:(r0)+,x0				; get DSP word
	add		x0,a					; add to checksum
checksumlp:
	move	#>0,a2					; clear msword, use as return code
	rts								; return from here
	ELSE
	bra		<done					; exit
	ENDIF



;***********************************************************************
;	Toggle ping pong buffer on PCM input

toggle_ping_pong:
	move	p:LdrTable+LDR_PINGPONG_OFFSET,x0
	bchg	#8,x0                               
	move	x0,p:LdrTable+LDR_PINGPONG_OFFSET

	bra		<done					; exit

;***********************************************************************
;	Load input PCM data
;		uses input DSP address, length, offset
;		ignores input action
;		error checking for buffer overflow

load_pcm:

;	The following lines convert an interleave buffer index into an offset
;	suitable for contiguous audio buffers.  

	move	n1,b					; get interleave buffer index
	asl		#9,b,b					; multiply by 512
	move	r1,x0					; rewritten to avoid pipeline stall
	add		x0,b
    move	p:LdrTable+LDR_PINGPONG_OFFSET,a
	add		b,a
	move	a1,r1

load_pcm_block0:
	bsr		<CopySysToDSPX			; copy buffer data

	bra		<done					; exit




;***********************************************************************
;	Save output Lt/Rt data
;		uses input DSP address, length, offset
;		ignores input action
;		error checking for buffer overflow
;	Note:	FIFO index is in r1 instead of system memory address

save_ltrt:

	;ignore the second save_ltrt, we do interleave
	move	n1,a
	cmp		#0,a
	bne		<done

	move	#1,n2						;This flag indicates number of channels -1 to interleave
	move	#0,n4                       ;This flag indicates null ouput
	bsr		<CopyDSPXToFIFO


	bra		<done					; exit

;***********************************************************************
;	Save output AC-3 data
;		uses input DSP address, length, offset
;		ignores input action
;		error checking for buffer overflow
;	Note:	FIFO index is in r1 instead of system memory address

save_ac3:

;;;;;; Note: Dolby memory-based code
;;;;;	move	(r1)+n1					; adjust output pointer
;       Note: XXXXX TODO - this might be a problem - we've switched to a FIFO,
;             so we can't support the n1 offset into the buffer.  Hopefully
;             Dolby will be writing everything in order...
;;;;;	bsr		<CopyDSPXToSys			; copy buffer data


	move	#0,n2						;This flag indicates number of channels -1 to interleave
	move	#0,n4                       ;This flag indicates null ouput
    ;move    #0,n5                       ;Clear blocking flag
	bsr		<CopyDSPXToFIFO
;	Note: 	this currently blocks until DMA completion...  If we're working
;		with a FIFO, will it complete quickly or slowly?  If slowly,
;		we probably need to make this non-blocking.  In which case we
;		need to have multiple DMA nodes instead of using a single node
;		for everything...

	bra		<done					; exit




;***********************************************************************
; Zero Fill AC-3 output buffer
;	uses length (n0), offset (n1)


SPDIFzerofill:
	IF		@DEF('ZEROFILL')

	move	#0,n2						;This flag indicates number of channels -1 to interleave
	move	#1,n4                       ;This flag indicates null ouput
    move    #0,n5                       ;Clear blocking flag
	bsr		<CopyDSPXToFIFO

    ENDIF
	bra		<done					; exit




;***********************************************************************
; Load preamble from DSP X memory
;	(essentially the same routine as used for "save_ac3")
;	uses input DSP address (r0), offset (n1), length (n0)

SPDIFpreamble:

	IF		@DEF('PREAMBLE')

	move	#0,n2						;This flag indicates number of channels -1 to interleave
	move	#0,n4                       ;This flag indicates null ouput
	bsr		<CopyDSPXToFIFO
;	Note: 	this currently blocks until DMA completion...  If we're working
;		with a FIFO, will it complete quickly or slowly?  If slowly,
;		we probably need to make this non-blocking.  In which case we
;		need to have multiple DMA nodes instead of using a single node
;		for everything...

    ENDIF
	bra		<done					; exit


;***********************************************************************
;	Heap handler

heap_jmptbl		dc		CopySysToDSPX,CopyDSPXToSys
				dc		CopySysToDSPY,CopyDSPYToSys
				dc		CopySysToDSPP,CopyDSPPToSys

heap_id:
	cmp		#LDR_ACT_ALLOC,b		; is action alloc?
	beq		<alloc_heap				; if so, skip ahead

;***********************************************************************
;	Heap access code
;		Transfers data to/from allocated data buffers
;		Uses all input parameters
;		Checks for following errors:
;			Buffer not yet allocated
;			Invalid length
;			Invalid offset
;			Buffer overflow

access_heap:
	IF		@DEF('ERRCHK')
	tst		b r1,a					; is action too small?, copy buffer pointer
	ble		<abort_action			; if so, abort
	cmp		#LDR_ACT_MAX,b			; is action too big?
	bgt		<abort_action			; if so, abort
	tst		a n0,a					; is the buffer allocated?	get length
	beq		<abort_alloc			; if not, abort
;	move	n0,a					; get length (no longer needed, done above)
	tst		a a1,x0					; is length valid?
	ble		<abort_length			; if not, abort
	move	n1,a					; get offset
	tst		a						; is offset valid?
	blt		<abort_length			; if not, abort
	add		x0,a					; add together
	move	p:(r2)+,x0				; get buffer size
	cmp		x0,a					; check for overflow
	bgt		<abort_length			; if so, abort
	ENDIF

	move	b1,n4					; set up table index
	move	#heap_jmptbl-1,r4		; set up jump table base
	move	(r1)+n1					; adjust pointer
	move	p:(r4+n4),r6			; get jump address
	jsr		(r6)					; call handler routine
	bra		<done

;***********************************************************************
;	Heap allocation code
;		Allocates new data buffer from heap
;		Uses input length, ignores other parameters
;		Checks for following errors:
;			Buffer already allocated
;			Requested length <= 0
;			Heap underflow

alloc_heap:
	IF		@DEF('ERRCHK')
	move	r1,a					; copy buffer pointer
	tst		a n0,b					; is the buffer allocated?, copy length
	bne		<abort_alloc			; if so, abort
	tst		b						; is the length valid?
	ble		<abort_alloc			; if not, abort
	ELSE
	move	n0,b					; copy length
	ENDIF

	move	p:ldr_heap_size,a		; get current heap size
	move	p:ldr_heap_ptr,x0		; get current heap pointer
	sub		b,a						; update heap size
	blt		<abort_alloc			; if underflow, abort
	add		x0,b (r2)-				; update heap pointer, back up table ptr
	move	x0,p:(r2)+				; save buffer pointer to loader table
	move	n0,p:(r2)+				; save buffer size to loader table
	move	a1,p:ldr_heap_size		; save heap size
	move	b1,p:ldr_heap_ptr		; save heap pointer

;***********************************************************************
;	Exit points

done:

	clr		a						; no error status
	rts

abort_alloc:
	move	#>LDR_ERR_ALLOC,a		; set up error status
	rts
	IF		@DEF('ERRCHK')
abort_id:
	move	#>LDR_ERR_ID,a			; set up error status
	rts
abort_action:
	move	#>LDR_ERR_ACTION,a		; set up error status
	rts
abort_length:
	move	#>LDR_ERR_LENGTH,a		; set up error status
	rts
	ENDIF
												  
;***********************************************************************
;	Loader initialization code
;		Copies loader table from system memory to DSP memory
;		Clears dynamic table entries
;		Initializes local heap variables

loader_init:
; Note: we no longer need to copy the loader table, since the RM prepositions
;       it in system memory so that it is automatically loaded by the DSP
;       bootstrap.
;	move	#LdrTable,r0				; point to loader table
;	move	#LDR_SYSTABLE_SIZE,n0			; set up length
;	move	#SYSMEMTABLEBASE,r1		   	; point to SysMem loader table
;	bsr		<CopySysToDSPP			; copy loader table
	move	p:LdrTable+LDR_HEAP_ADDR,x0		; get heap address
	move	x0,p:ldr_heap_ptr			; save to local memory
	move	p:LdrTable+LDR_HEAP_SIZE,x0		; get heap size
	move	x0,p:ldr_heap_size			; save to local memory
	clr	a #LdrTable+LDR_HEAP_ADDR,r0		; set up pointer
	dor	#LDR_NUM_DATA*2,clrlp
	move	a,p:(r0)+						; clear table value
clrlp:


	bsr	DMAInit					; one-time DMA initialization
	
	bra	<done					; exit

;******************************************************************************
;*										  
;*   Subroutine Name:	CopySysToDSPX
;*								  
;*   Description:	Copy from System Memory to DSP x: space
;*										      
;*   Input:		r0 	- DSP address (x:)
;*			n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopySysToDSPX:
	IF		@DEF('RTSYS')
	jsr		set_timing
	ENDIF

; Note: Dolby-only testing code
;	dor		n0,systoxlp
;	move	x:(r1)+,x0
;	move	x0,x:(r0)+
;systoxlp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_XRAM,a 		; adjust DSP address for X base
	move	a1,r0
	
	jsr	DMANewNode_Read			; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)

	IF		@DEF('RTSYS')
	jsr		clr_timing
	ENDIF
	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopyDSPXToSys
;*								  
;*   Description:	Copy from DSP x: space to System Memory
;*										      
;*   Input:		r0 	- DSP address (x:)
;*			n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopyDSPXToSys:
	IF		@DEF('RTSYS')
	jsr		set_timing
	ENDIF
	
; Note: Dolby-only testing code
;	dor		n0,xtosyslp
;	move	x:(r0)+,x0
;	move	x0,x:(r1)+
;xtosyslp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_XRAM,a 		; adjust DSP address for X base
	move	a1,r0
	
	jsr	DMANewNode_Write		; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)
        
	IF		@DEF('RTSYS')
	jsr		clr_timing
	ENDIF
	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopyDSPXToFIFO
;*								  
;*   Description:	Copy from DSP x: space to FIFO
;*									      
;*   Input:		r0 	- DSP address (x:)
;*			n0	- number of words to copy
;*			r1	- FIFO index
;*			n2  - (Channels -1) to interleave
;*			n4  - Flag indicating NULL ouput
;*										      
;******************************************************************************

CopyDSPXToFIFO:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_XRAM,a 		; adjust DSP address for X base
	move	a1,r0
	
	move	n2,a
	cmp		#0,a
	bne		CopyDSPXToFIFO_Interleaved
	jsr	    DMANewNode_WriteFIFO		; create DMA node
	bra		CopyDSPXToFIFOStart

CopyDSPXToFIFO_Interleaved:	
	jsr	    DMANewNode_WriteFIFOInterleaved		; create DMA node

CopyDSPXToFIFOStart:
	jsr	    DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)
        
	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopySysToDSPY
;*								  
;*   Description:	Copy from System Memory to DSP y: space
;*		       							      
;*   Input:	 	r0 	- DSP address (y:)
;*			n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopySysToDSPY:

; Note: Dolby-only testing code
;	dor		n0,systoylp
;	move	x:(r1)+,x0
;	move	x0,y:(r0)+
;systoylp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_YRAM,a 		; adjust DSP address for Y base
	move	a1,r0
	
	jsr	DMANewNode_Read			; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)

	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopyDSPYToSys
;*								  
;*   Description:	Copy from DSP y: space to System Memory
;*										      
;*   Input:		r0 	- DSP address (y:)
;*	   		n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopyDSPYToSys:

; Note: Dolby-only testing code
;	dor		n0,ytosyslp
;	move	y:(r0)+,x0
;	move	x0,x:(r1)+
;ytosyslp:


	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_YRAM,a 		; adjust DSP address for Y base
	move	a1,r0
	
	jsr	DMANewNode_Write		; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)

	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopySysToDSPP
;*								  
;*   Description:	Copy from System Memory to DSP p: space
;*										      
;*   Input:	 	r0 	- DSP address (p:)
;*			n0	- number of words to copy
;*			r1	- System Memory address
;*										      
;******************************************************************************

CopySysToDSPP:

; Note: Dolby-only testing code
;	dor		n0,systoplp
;	move	x:(r1)+,x0
;	move	x0,p:(r0)+
;	nop
;systoplp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_PRAM,a 		; adjust DSP address for Y base
	move	a1,r0
	
	jsr	DMANewNode_Read			; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)

	rts

;******************************************************************************
;*										  
;*   Subroutine Name:	CopyDSPPToSys
;*								  
;*   Description:	Copy from DSP p: space to System Memory
;*										      
;*   Input:	       	r0 	- DSP address (p:)
;*		  	n0	- number of words to copy
;*		       	r1	- System Memory address
;*										      
;******************************************************************************

CopyDSPPToSys:
	
; Note: Dolby-only testing code
;	dor		n0,ptosyslp
;	move	p:(r0)+,x0
;	move	x0,x:(r1)+
;ptosyslp:

	move	#dmaNode,r4			; r4 <- address of dma node
	
	move	r0,a1
	add 	#kEPMemory_Base_PRAM,a 		; adjust DSP address for Y base
	move	a1,r0
	
	jsr	DMANewNode_Write		; create DMA node
	
	jsr	DMAStartNodeP_Wait		; initiate DMA 
						; (and wait for completion)
	rts
	
	
;************************************************************
; DMANewNode_Read
;
;	This DMA Read node is configured for the System
;	Memory -> DSP transfer
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r4	node DSP PRAM address
;			r0	DSP Memory address
;			r1	System Memory address
;           n0      Length
;************************************************************
DMANewNode_Read

	jsr 	DMAWaitForIdle			    ; Wait fro DMA to be idle

; Word0
	move	r4,r5			; r5 <- copy of node base 
	
	move	r4,a1
	and		#>kDMANode_EOLMask,a	; Clear reserved upper bits
	or		#>kDMANode_EOL,a 	; set EOL bit
	
    movem   a1,p:(r5)+		; Link to itself			
; Word1
    move    #>DMA_BASE_READ1,a1
	movem	a1,p:(r5)+
; Word2
	movem	n0,p:(r5)+		; Length       	
; Word3
	movem	r0,p:(r5)+		; DSP RAM address (System memory space)	
; Word4						
	move	r1,a
	lsl		#2,a					
	movem	a1,p:(r5)+		; System memory address


 	rts
; ---- end DMANewNode_Read


;************************************************************
; DMANewNode_Write     	
;
;	This DMA Write node is configured for the DSP -> SM
;	transfer 
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r4	node DSP PRAM address
;			r0	DSP Memory address 
;			r1	System Memory address
;			n0	Length
;************************************************************
DMANewNode_Write	

	jsr 	DMAWaitForIdle			    ; Wait fro DMA to be idle

; Word0
	move	r4,r5			; r5 <- copy of node base 
	
	move	r4,a1
	and		#>kDMANode_EOLMask,a	; Clear reserved upper bits
	or		#>kDMANode_EOL,a	; set EOL bit
    	
; Word0
	move    a1,p:(r5)+		; Link to itself			

; Word1
    	move    #>DMA_BASE_WRITE1,a1
	movem	a1,p:(r5)+			
; Word2
	movem	n0,p:(r5)+		; Length
; Word3
	movem	r0,p:(r5)+		; DSP RAM address (System memory space)	
; Word4	
	move	r1,a
	lsl		#2,a					
	movem	a1,p:(r5)+		; System memory address

 	rts
; ---- end DMANewNode_Write ----

;************************************************************
; DMANewNode_WriteFIFO
;
;	This DMA Write node is configured for the DSP -> FIFO
;	transfer 
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r4	node DSP PRAM address
;			r0	DSP Memory address 
;			r1	FIFO number
;			n0	Length
;			n4  NULL output flag
;************************************************************
DMANewNode_WriteFIFO

	jsr 	DMAWaitForIdle			    ; Wait fro DMA to be idle

; Word0
	move	r4,r5			; r5 <- copy of node base 
	
	move	r4,a1
	and		#>kDMANode_EOLMask,a	; Clear reserved upper bits
	or		#>kDMANode_EOL,a	; Set EOL bit
    	
	move    a1,p:(r5)+		; Link to itself			

; Word1
    move    #>DMA_BASE_WRITEFIFO1,a1 	; start with "write to FIFO/16-bit" control word
	move	r1,b			; FIFO index from r1
    lsl	    #5,b			; shift FIFO index smBufId bits
	move	b,x1
	or	    x1,a			; put FIFO index into control word
	movem	a1,p:(r5)+		; write control word
; Word2
	movem	n0,p:(r5)+			
; Word3
	move	n4,a			; Null Flag
    lsl	    #14,a
	move	r0,x0
	add		x0,a			; Add DSP Address
	movem	a1,p:(r5)+		; DSP RAM address (System memory space)	
; Word4 is no longer used

 	rts
; ---- end DMANewNode_WriteFIFO ----


;************************************************************
; DMANewNode_WriteFIFOInterleaved
;
;	This DMA Write node is configured for the DSP -> FIFO
;	transfer 
;	This node is also set up to be the last node in
;	the list, so it is self-linked with the EndOfList
;	bit set
;
;	Parameters:  	r4	node DSP PRAM address
;			r0	DSP Memory address 
;			r1	FIFO number
;			n0	Length
;			n2  Channels per block
;			n4  NULL output flag
;************************************************************
DMANewNode_WriteFIFOInterleaved

	jsr 	DMAWaitForIdle			    ; Wait fro DMA to be idle

; Word0
	move	r4,r5			; r5 <- copy of node base 
	
	move	r4,a1
	and 	#>kDMANode_EOLMask,a	; Clear reserved upper bits
	or		#>kDMANode_EOL,a	; Set EOL bit
	move    a1,p:(r5)+		; Link to itself			

; Word1
    move    #>DMA_BASE_WRITEFIFO2,a1 	; start with "write to FIFO/16-bit interleaved" control word
	move	r1,b			; FIFO index from r1
    lsl	    #5,b			; shift FIFO index smBufId bits
	move	b,x1
	or	    x1,a			; put FIFO index into control word

	move	n0,b			; Set Incr value
    lsl	    #14,b			; shift incr value bits (Increment by size of a single channel buffer)
	move	b,x1
	or	    x1,a			; put FIFO index into control word
	movem	a1,p:(r5)+		; write control word
; Word2
	move	n0,b			; Set Length value
    lsl	    #4,b			; shift Length bits (Increment by size of a single channel buffer)
	move	n2,x1
	add		x1,b			; Add samples per block
	movem	b1,p:(r5)+		; write control word
; Word3
	move	n4,a			; Null Flag
    lsl	    #14,a
	move	r0,x0
	add		x0,a			; Add DSP Address
	movem	a1,p:(r5)+		; DSP RAM address (System memory space)	
; Word4 is no longer used

 	rts
; ---- end DMANewNode_WriteFIFO ----





;************************************************************
; DMAWaitForStop	
;
;		Alters DMA Running state 
;************************************************************
DMAWaitForIdle 


; Wait for DMA engine to enter Idle state: 0 = Idle, 1 = Running
	jset 	#kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAWaitForIdle

; Clear DMA EndofList, Bit 7
	movep    #$80,x:INTERRUPT_REGISTER	; "Write-1-To-Clear-One" 

 	rts
; ---- end DMAStopAndFreeze ----

;************************************************************
; DMAStart
;
;		Alters DMA Running state 
;************************************************************
DMAStart 


; Write "run" command
    movep    #>kDMA_ActionRequest_Start,x:DMA_CONTROL_REGISTER	

; Wait for DMA engine to enter Running state: 0 = Idle, 1 = Running
DMAUnFreezeAndStart_WaitForStart
;	jset	#kDMAErrorBit,x:INTERRUPT_REGISTER,DMAError
	jclr 	#kDMA_RunningBit,x:DMA_CONTROL_REGISTER,DMAUnFreezeAndStart_WaitForStart

 	rts
; ---- end DMAUnFreezeAndStart ----

;************************************************************
; DMAWaitForEOL		Wait for DMA EOL interrupt and clear register bit
;************************************************************
DMAWaitForEOL 

; Poll for DMA EOL interrupt
DMAWaitForEOL_Poll
	jset	#kDMAErrorBit,x:INTERRUPT_REGISTER,DMAError
	jclr 	#kDMAEndOfListBit,x:INTERRUPT_REGISTER,DMAWaitForEOL_Poll

; Clear DMA EndofList, Bit 7
	movep    #$80,x:INTERRUPT_REGISTER	; "Write-1-To-Clear-One" 

    ;debug_wait


 	rts
; ---- end DMAWaitForEOL ----

;************************************************************
; DMAStartNodeP_Wait	
;
;	Replace start block, initiate transfer and Wait for
;				completion
;
;	This function assumes a single DMA node that is
;	setup as the EOL block.
;
;	Parameters:  	 r4	next node DSP PRAM address
;************************************************************
DMAStartNodeP_Wait 
	
	move	r4,a
	add		#kEPMemory_Base_PRAM,a			; block is in PRAM 
	movep	a,x:DMA_NEXT_BLOCK_CONTROL_REGISTER
	
	jsr 	DMAStart			        ; Start transfer
	
    clr     b
    move    n5,b
    cmp     #0,b
    beq     DMAStartNodeP_NoWait

	jsr 	DMAWaitForEOL				; Wait for completion

DMAStartNodeP_NoWait
 	rts
; ---- end DMAStartNodeX_Wait ----


;******************************************************************************
;*
;*   Subroutine Name:	DMAInit             
;*
;*   Description:		Inits the EP for DMA (based on Gints' GP code)
;*
;******************************************************************************
;
;

DMAInit:
	;GPClearInterruptRegister
	movep    #$FFF,x:INTERRUPT_REGISTER	 ; "Write-1-To-Clear-One"
	
	;GPClearProcessingControlRegister
	movep    #$1,x:PROCESSING_CONTROL_REGISTER	 ; "Set Idle bit"	

	;GPClearSampleControlRegister
	movep    #$0,x:SAMPLE_CONTROL_REGISTER	 
	
	;abort any DMA transfers
;    movep    #>kDMA_ActionRequest_Abort,x:DMA_CONTROL_REGISTER

    move    #$4000,x0	
	move    x0,x:DMA_START_BLOCK_CONTROL_REGISTER
	move    x0,x:DMA_NEXT_BLOCK_CONTROL_REGISTER

	;GPClearDMAConfigRegister 
	movep    #>0,x:DMA_CONFIGURATION_REGISTER

	rts


DMAError
	bra	DMAError




;** Loader Status

;status_active	dc	0
;status_ID		dc	-1
;status_action	dc	-1
;status_dspaddr	dc	-1
;status_length	dc	-1
;status_sysaddr	dc	-1
;status_wait		dc	0

	endsec
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\mot_equ.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			mot_equ.inc
;												
;   Contents:		EQUATES for 56301 registers and ports
;					Reference: 56301 Specifications Revision 3.00
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	9/19/2000 8:49:01 PM		jmw
;	Copied.
;
;
; ******************************************************************

	page	132,55,0,0,0
	opt	mex

ioequ   ident   1,0

;------------------------------------------------------------------------
;
;       EQUATES for I/O Port Programming
;
;------------------------------------------------------------------------

;       Register Addresses

M_DATH   EQU     $FFFFCF         ; Port B (host) GPIO data Register
M_DIRH   EQU     $FFFFCE         ; Port B (host) GPIO direction Register

M_PCRC   EQU     $FFFFBF         ; Port C (ESSI0) Control Register
M_PRRC   EQU     $FFFFBE         ; Port C (ESSI0) Direction Register
M_PDRC   EQU     $FFFFBD         ; Port C (ESSI0) GPIO Data Register

M_PCRD   EQU     $FFFFAF         ; Port D (ESSI1) Control register
M_PRRD   EQU     $FFFFAE         ; Port D (ESSI1) Direction Data Register
M_PDRD   EQU     $FFFFAD         ; Port D (ESSI1) GPIO Data Register

M_PCRE   EQU     $FFFF9F         ; Port E (SCI) Control register
M_PRRE   EQU     $FFFF9E         ; Port E (SCI) Direction Register
M_PDRE   EQU     $FFFF9D         ; Port E (SCI) Data Register

M_OGDB   EQU     $FFFFFC         ; OnCE GDB Register 

;------------------------------------------------------------------------
;
;       EQUATES for Host Interface
;
;------------------------------------------------------------------------

;       Register Addresses
 
M_DTXS   EQU     $FFFFCD         ; DSP SLAVE TRANSMIT DATA FIFO (DTXS)
M_DTXM   EQU     $FFFFCC         ; DSP MASTER TRANSMIT DATA FIFO (DTXM)
M_DRXR   EQU     $FFFFCB         ; DSP RECEIVE DATA FIFO (DRXR)
M_DPSR   EQU     $FFFFCA         ; DSP PCI STATUS REGISTER (DPSR)
M_DSR    EQU     $FFFFC9         ; DSP STATUS REGISTER (DSR)
M_DPAR   EQU     $FFFFC8         ; DSP PCI ADDRESS REGISTER (DPAR)
M_DPMC   EQU     $FFFFC7         ; DSP PCI MASTER CONTROL REGISTER (DPMC)
M_DPCR   EQU     $FFFFC6         ; DSP PCI CONTROL REGISTER (DPCR)
M_DCTR   EQU     $FFFFC5         ; DSP CONTROL REGISTER (DCTR)    
 
;       Host Control Register Bit Flags

M_HCIE   EQU     0               ; Host Command Interrupt Enable
M_STIE   EQU     1               ; Slave Transmit Interrupt Enable
M_SRIE   EQU     2               ; Slave Receive Interrupt Enable
M_HF35   EQU     $38             ; Host Flags 5-3 Mask
M_HF3    EQU     3               ; Host Flag 3
M_HF4    EQU     4               ; Host Flag 4
M_HF5    EQU     5               ; Host Flag 5
M_HINT   EQU     6               ; Host Interrupt A
M_HDSM   EQU     13              ; Host Data Strobe Mode
M_HRWP   EQU     14              ; Host RD/WR Polarity
M_HTAP   EQU     15              ; Host Transfer Acknowledge Polarity
M_HDRP   EQU     16              ; Host Dma Request Polarity
M_HRSP   EQU     17              ; Host Reset Polarity
M_HIRP   EQU     18              ; Host Interrupt  Request Polarity
M_HIRC   EQU     19              ; Host Interupt Request Control
M_HM0    EQU     20              ; Host Interface Mode
M_HM1    EQU     21              ; Host Interface Mode
M_HM2    EQU     22              ; Host Interface Mode
M_HM     EQU     $700000         ; Host Interface Mode Mask

;       Host PCI Control Register Bit Flags

M_PMTIE  EQU     1               ; PCI Master Transmit         Interrupt Enable
M_PMRIE  EQU     2               ; PCI Master Receive          Interrupt Enable
M_PMAIE  EQU     4               ; PCI Master Address          Interrupt Enable
M_PPEIE  EQU     5               ; PCI Parity Error            Interrupt Enable
M_PTAIE  EQU     7               ; PCI Transaction Abort       Interrupt Enable
M_PTTIE  EQU     9               ; PCI Transaction Termination Interrupt Enable
M_PTCIE  EQU     12              ; PCI Transfer Complete       Interrupt Enable
M_CLRT   EQU     14              ; Clear Transmitter
M_MTT    EQU     15              ; Master Transfer Terminate
M_SERF   EQU     16              ; HSERR~ Force
M_MACE   EQU     18              ; Master Access Counter Enable
M_MWSD   EQU     19              ; Master Wait States Disable
M_RBLE   EQU     20              ; Receive Buffer Lock Enable
M_IAE    EQU     21              ; Insert Address Enable 

;       Host PCI Master Control Register Bit Flags

M_ARH    EQU     $00ffff         ; DSP PCI Transaction Address (High)
M_BL     EQU     $3f0000         ; PCI Data Burst Length
M_FC     EQU     $c00000         ; Data Transfer Format Control

;       Host PCI Address Register Bit Flags

M_ARL    EQU     $00ffff         ; DSP PCI Transaction Address (Low)
M_C      EQU     $0f0000         ; PCI Bus Command
M_BE     EQU     $f00000         ; PCI Byte Enables

;       DSP Status Register Bit Flags
 
M_HCP    EQU     0               ; Host Command pending
M_STRQ   EQU     1               ; Slave Transmit Data Request
M_SRRQ   EQU     2               ; Slave Receive Data Request
M_HF02   EQU     $38             ; Host Flag 0-2 Mask
M_HF0    EQU     3               ; Host Flag 0
M_HF1    EQU     4               ; Host Flag 1
M_HF2    EQU     5               ; Host Flag 2

;       DSP PCI Status Register Bit Flags

M_MWS    EQU    0               ; PCI Master Wait States
M_MTRQ   EQU    1               ; PCI Master Transmit Data Request
M_MRRQ   EQU    2               ; PCI Master Receive Data Request
M_MARQ   EQU    4               ; PCI Master Address Request
M_APER   EQU    5               ; PCI Address Parity Error
M_DPER   EQU    6               ; PCI Data Parity Error
M_MAB    EQU    7               ; PCI Master Abort
M_TAB    EQU    8               ; PCI Target Abort
M_TDIS   EQU    9               ; PCI Target Disconnect
M_TRTY   EQU    10              ; PCI Target Retry
M_TO     EQU    11              ; PCI Time Out Termination
M_RDC    EQU    $3F0000         ; Remaining Data Count Mask (RDC5-RDC0)
M_RDC0   EQU    16              ; Remaining Data Count  0
M_RDC1   EQU    17              ; Remaining Data Count  1
M_RDC2   EQU    18              ; Remaining Data Count  2
M_RDC3   EQU    19              ; Remaining Data Count  3
M_RDC4   EQU    20              ; Remaining Data Count  4
M_RDC5   EQU    21              ; Remaining Data Count  5
M_HACT   EQU    23              ; Hi32 Active


;------------------------------------------------------------------------
;
;       EQUATES for Serial Communications Interface (SCI)
;
;------------------------------------------------------------------------

;       Register Addresses

M_STXH   EQU     $FFFF97         ; SCI Transmit Data Register (high)
M_STXM   EQU     $FFFF96         ; SCI Transmit Data Register (middle)
M_STXL   EQU     $FFFF95         ; SCI Transmit Data Register (low)
M_SRXH   EQU     $FFFF9A         ; SCI Receive Data Register (high)
M_SRXM   EQU     $FFFF99         ; SCI Receive Data Register (middle)
M_SRXL   EQU     $FFFF98         ; SCI Receive Data Register (low)
M_STXA   EQU     $FFFF94         ; SCI Transmit Address Register
M_SCR    EQU     $FFFF9C         ; SCI Control Register
M_SSR    EQU     $FFFF93         ; SCI Status Register
M_SCCR   EQU     $FFFF9B         ; SCI Clock Control Register

;       SCI Control Register Bit Flags

M_WDS    EQU     $7              ; Word Select Mask (WDS0-WDS3)
M_WDS0   EQU     0               ; Word Select 0
M_WDS1   EQU     1               ; Word Select 1
M_WDS2   EQU     2               ; Word Select 2
M_SSFTD  EQU     3               ; SCI Shift Direction 
M_SBK    EQU     4               ; Send Break
M_WAKE   EQU     5               ; Wakeup Mode Select
M_RWU    EQU     6               ; Receiver Wakeup Enable
M_WOMS   EQU     7               ; Wired-OR Mode Select
M_SCRE   EQU     8               ; SCI Receiver Enable
M_SCTE   EQU     9               ; SCI Transmitter Enable
M_ILIE   EQU     10              ; Idle Line Interrupt Enable
M_SCRIE  EQU     11              ; SCI Receive Interrupt Enable
M_SCTIE  EQU     12              ; SCI Transmit Interrupt Enable
M_TMIE   EQU     13              ; Timer Interrupt Enable
M_TIR    EQU     14              ; Timer Interrupt Rate
M_SCKP   EQU     15              ; SCI Clock Polarity
M_REIE   EQU     16              ; SCI Error Interrupt Enable (REIE)

;       SCI Status Register Bit Flags

M_TRNE   EQU     0               ; Transmitter Empty
M_TDRE   EQU     1               ; Transmit Data Register Empty
M_RDRF   EQU     2               ; Receive Data Register Full
M_IDLE   EQU     3               ; Idle Line Flag
M_OR     EQU     4               ; Overrun Error Flag 
M_PE     EQU     5               ; Parity Error
M_FE     EQU     6               ; Framing Error Flag
M_R8     EQU     7               ; Received Bit 8 (R8) Address

;       SCI Clock Control Register 

M_CD     EQU     $FFF            ; Clock Divider Mask (CD0-CD11)
M_COD    EQU     12              ; Clock Out Divider
M_SCP    EQU     13              ; Clock Prescaler
M_RCM    EQU     14              ; Receive Clock Mode Source Bit
M_TCM    EQU     15              ; Transmit Clock Source Bit

;------------------------------------------------------------------------
;
;       EQUATES for Enhanced Synchronous Serial Interface (ESSI)
;
;------------------------------------------------------------------------

;
;       Register Addresses Of ESSI0 
M_TX00   EQU     $FFFFBC         ; ESSI0 Transmit Data Register 0
M_TX01   EQU     $FFFFBB         ; ESSIO Transmit Data Register 1
M_TX02   EQU     $FFFFBA         ; ESSIO Transmit Data Register 2
M_TSR0   EQU     $FFFFB9         ; ESSI0 Time Slot Register
M_RX0    EQU     $FFFFB8         ; ESSI0 Receive Data Register
M_SSISR0 EQU     $FFFFB7         ; ESSI0 Status Register
M_CRB0   EQU     $FFFFB6         ; ESSI0 Control Register B
M_CRA0   EQU     $FFFFB5         ; ESSI0 Control Register A
M_TSMA0  EQU     $FFFFB4         ; ESSI0 Transmit Slot Mask Register A
M_TSMB0  EQU     $FFFFB3         ; ESSI0 Transmit Slot Mask Register B
M_RSMA0  EQU     $FFFFB2         ; ESSI0 Receive Slot Mask Register A
M_RSMB0  EQU     $FFFFB1         ; ESSI0 Receive Slot Mask Register B

;       Register Addresses Of ESSI1                                        
M_TX10   EQU     $FFFFAC         ; ESSI1 Transmit Data Register 0
M_TX11   EQU     $FFFFAB         ; ESSI1 Transmit Data Register 1
M_TX12   EQU     $FFFFAA         ; ESSI1 Transmit Data Register 2
M_TSR1   EQU     $FFFFA9         ; ESSI1 Time Slot Register
M_RX1    EQU     $FFFFA8         ; ESSI1 Receive Data Register
M_SSISR1 EQU     $FFFFA7         ; ESSI1 Status Register
M_CRB1   EQU     $FFFFA6         ; ESSI1 Control Register B
M_CRA1   EQU     $FFFFA5         ; ESSI1 Control Register A
M_TSMA1  EQU     $FFFFA4         ; ESSI1 Transmit Slot Mask Register A
M_TSMB1  EQU     $FFFFA3         ; ESSI1 Transmit Slot Mask Register B
M_RSMA1  EQU     $FFFFA2         ; ESSI1 Receive Slot Mask Register A
M_RSMB1  EQU     $FFFFA1         ; ESSI1 Receive Slot Mask Register B

;       ESSI Control Register A Bit Flags

M_PM     EQU     $FF             ; Prescale Modulus Select Mask (PM0-PM7)              
M_PSR    EQU     11              ; Prescaler Range       
M_DC     EQU     $1F000          ; Frame Rate Divider Control Mask (DC0-DC7)
M_ALC    EQU     18	         ; Alignment Control (ALC)
M_WL     EQU     $380000         ; Word Length Control Mask (WL0-WL7)
M_SSC1   EQU     22	         ; Select SC1 as TR #0 drive enable (SSC1)

;       ESSI Control Register B Bit Flags                                   

M_OF     EQU     $3              ; Serial Output Flag Mask
M_OF0    EQU     0               ; Serial Output Flag 0                     
M_OF1    EQU     1               ; Serial Output Flag 1                     
M_SCD    EQU     $1C             ; Serial Control Direction Mask            
M_SCD0   EQU     2               ; Serial Control 0 Direction                
M_SCD1   EQU     3               ; Serial Control 1 Direction               
M_SCD2   EQU     4               ; Serial Control 2 Direction               
M_SCKD   EQU     5               ; Clock Source Direction
M_SHFD   EQU     6               ; Shift Direction                          
M_FSL    EQU     $180            ; Frame Sync Length Mask (FSL0-FSL1)
M_FSL0   EQU     7               ; Frame Sync Length 0
M_FSL1   EQU     8               ; Frame Sync Length 1
M_FSR    EQU     9               ; Frame Sync Relative Timing
M_FSP    EQU     10              ; Frame Sync Polarity
M_CKP    EQU     11              ; Clock Polarity                           
M_SYN    EQU     12              ; Sync/Async Control                       
M_MOD    EQU     13              ; ESSI Mode Select
M_SSTE   EQU     $1C000          ; ESSI Transmit enable Mask                  
M_SSTE2  EQU     14              ; ESSI Transmit #2 Enable                   
M_SSTE1  EQU     15              ; ESSI Transmit #1 Enable                    
M_SSTE0  EQU     16              ; ESSI Transmit #0 Enable                    
M_SSRE   EQU     17              ; ESSI Receive Enable                       
M_SSTIE  EQU     18              ; ESSI Transmit Interrupt Enable            
M_SSRIE  EQU     19              ; ESSI Receive Interrupt Enable              
M_STLIE  EQU     20              ; ESSI Transmit Last Slot Interrupt Enable 
M_SRLIE  EQU     21              ; ESSI Receive Last Slot Interrupt Enable 
M_STEIE  EQU     22              ; ESSI Transmit Error Interrupt Enable 
M_SREIE  EQU     23              ; ESSI Receive Error Interrupt Enable              

;       ESSI Status Register Bit Flags                                       

M_IF     EQU     $3              ; Serial Input Flag Mask           
M_IF0    EQU     0               ; Serial Input Flag 0                      
M_IF1    EQU     1               ; Serial Input Flag 1                      
M_TFS    EQU     2               ; Transmit Frame Sync Flag                 
M_RFS    EQU     3               ; Receive Frame Sync Flag                  
M_TUE    EQU     4               ; Transmitter Underrun Error FLag          
M_ROE    EQU     5               ; Receiver Overrun Error Flag              
M_TDE    EQU     6               ; Transmit Data Register Empty             
M_RDF    EQU     7               ; Receive Data Register Full

;       ESSI Transmit Slot Mask Register A

M_SSTSA  EQU     $FFFF           ; ESSI Transmit Slot Bits Mask A (TS0-TS15)

;       ESSI Transmit Slot Mask Register B

M_SSTSB  EQU     $FFFF           ; ESSI Transmit Slot Bits Mask B (TS16-TS31)

;       ESSI Receive Slot Mask Register A

M_SSRSA  EQU     $FFFF           ; ESSI Receive Slot Bits Mask A (RS0-RS15)
 
;       ESSI Receive Slot Mask Register B

M_SSRSB  EQU     $FFFF           ; ESSI Receive Slot Bits Mask B (RS16-RS31)

              

;------------------------------------------------------------------------
;
;       EQUATES for Exception Processing                                    
;
;------------------------------------------------------------------------


;       Register Addresses

M_IPRC   EQU     $FFFFFF         ; Interrupt Priority Register Core
M_IPRP   EQU     $FFFFFE         ; Interrupt Priority Register Peripheral

;       Interrupt Priority Register Core (IPRC) 

M_IAL    EQU     $7              ; IRQA Mode Mask
M_IAL0   EQU     0               ; IRQA Mode Interrupt Priority Level (low)
M_IAL1   EQU     1               ; IRQA Mode Interrupt Priority Level (high)
M_IAL2   EQU     2               ; IRQA Mode Trigger Mode
M_IBL    EQU     $38             ; IRQB Mode Mask
M_IBL0   EQU     3               ; IRQB Mode Interrupt Priority Level (low)
M_IBL1   EQU     4               ; IRQB Mode Interrupt Priority Level (high)
M_IBL2   EQU     5               ; IRQB Mode Trigger Mode
M_ICL    EQU     $1C0            ; IRQC Mode Mask
M_ICL0   EQU     6               ; IRQC Mode Interrupt Priority Level (low)
M_ICL1   EQU     7               ; IRQC Mode Interrupt Priority Level (high)
M_ICL2   EQU     8               ; IRQC Mode Trigger Mode
M_IDL    EQU     $E00            ; IRQD Mode Mask
M_IDL0   EQU     9               ; IRQD Mode Interrupt Priority Level (low)
M_IDL1   EQU     10              ; IRQD Mode Interrupt Priority Level (high)
M_IDL2   EQU     11              ; IRQD Mode Trigger Mode
M_D0L    EQU     $3000           ; DMA0 Interrupt priority Level Mask
M_D0L0   EQU     12              ; DMA0 Interrupt Priority Level (low)
M_D0L1   EQU     13              ; DMA0 Interrupt Priority Level (high)
M_D1L    EQU     $C000           ; DMA1 Interrupt Priority Level Mask
M_D1L0   EQU     14              ; DMA1 Interrupt Priority Level (low)
M_D1L1   EQU     15              ; DMA1 Interrupt Priority Level (high)
M_D2L    EQU     $30000          ; DMA2 Interrupt priority Level Mask
M_D2L0   EQU     16              ; DMA2 Interrupt Priority Level (low)
M_D2L1   EQU     17              ; DMA2 Interrupt Priority Level (high)
M_D3L    EQU     $C0000          ; DMA3 Interrupt Priority Level Mask
M_D3L0   EQU     18              ; DMA3 Interrupt Priority Level (low)
M_D3L1   EQU     19              ; DMA3 Interrupt Priority Level (high)
M_D4L    EQU     $300000         ; DMA4 Interrupt priority Level Mask
M_D4L0   EQU     20              ; DMA4 Interrupt Priority Level (low)
M_D4L1   EQU     21              ; DMA4 Interrupt Priority Level (high)
M_D5L    EQU     $C00000         ; DMA5 Interrupt priority Level Mask
M_D5L0   EQU     22              ; DMA5 Interrupt Priority Level (low)
M_D5L1   EQU     23              ; DMA5 Interrupt Priority Level (high)


;       Interrupt Priority Register Peripheral (IPRP)

M_HPL    EQU     $3              ; Host Interrupt Priority Level Mask
M_HPL0   EQU     0               ; Host Interrupt Priority Level (low)
M_HPL1   EQU     1               ; Host Interrupt Priority Level (high)
M_S0L    EQU     $C              ; ESSI0 Interrupt Priority Level Mask
M_S0L0   EQU     2               ; ESSI0 Interrupt Priority Level (low)
M_S0L1   EQU     3               ; ESSI0 Interrupt Priority Level (high)
M_S1L    EQU     $30             ; ESSI1 Interrupt Priority Level Mask
M_S1L0   EQU     4               ; ESSI1 Interrupt Priority Level (low)
M_S1L1   EQU     5               ; ESSI1 Interrupt Priority Level (high)
M_SCL    EQU     $C0             ; SCI  Interrupt Priority Level  Mask       
M_SCL0   EQU     6               ; SCI  Interrupt Priority Level  (low)
M_SCL1   EQU     7               ; SCI  Interrupt Priority Level  (high)
M_T0L    EQU     $300            ; TIMER Interrupt Priority Level Mask
M_T0L0   EQU     8               ; TIMER Interrupt Priority Level (low)
M_T0L1   EQU     9               ; TIMER Interrupt Priority Level (high)


;------------------------------------------------------------------------
;
;       EQUATES for TIMER 
;
;------------------------------------------------------------------------

;       Register Addresses Of TIMER0

M_TCSR0  EQU     $FFFF8F         ; TIMER0 Control/Status Register            
M_TLR0	 EQU	 $FFFF8E	 ; TIMER0 Load Reg   
M_TCPR0  EQU     $FFFF8D         ; TIMER0 Compare Register
M_TCR0	 EQU	 $FFFF8C 	 ; TIMER0 Count Register

;       Register Addresses Of TIMER1

M_TCSR1  EQU     $FFFF8B         ; TIMER1 Control/Status Register            
M_TLR1	 EQU	 $FFFF8A	 ; TIMER1 Load Reg   
M_TCPR1  EQU     $FFFF89         ; TIMER1 Compare Register
M_TCR1	 EQU	 $FFFF88	 ; TIMER1 Count Register


;       Register Addresses Of TIMER2

M_TCSR2  EQU     $FFFF87         ; TIMER2 Control/Status Register            
M_TLR2	 EQU	 $FFFF86	 ; TIMER2 Load Reg   
M_TCPR2  EQU     $FFFF85         ; TIMER2 Compare Register
M_TCR2	 EQU	 $FFFF84	 ; TIMER2 Count Register
M_TPLR	 EQU	 $FFFF83	 ; TIMER Prescaler Load Register
M_TPCR	 EQU	 $FFFF82	 ; TIMER Prescalar Count Register


;       Timer Control/Status Register Bit Flags                                        

M_TE     EQU     0               ; Timer Enable 
M_TOIE   EQU     1               ; Timer Overflow Interrupt Enable
M_TCIE   EQU     2               ; Timer Compare Interrupt Enable
M_TC     EQU     $F0             ; Timer Control Mask (TC0-TC3)
M_INV    EQU     8               ; Inverter Bit
M_TRM    EQU     9               ; Timer Restart Mode 
M_DIR    EQU     11              ; Direction Bit
M_DI     EQU     12              ; Data Input
M_DO     EQU     13              ; Data Output
M_PCE	 EQU	 15		 ; Prescaled Clock Enable
M_TOF    EQU     20              ; Timer Overflow Flag
M_TCF    EQU     21              ; Timer Compare Flag 

;       Timer Prescaler Register Bit Flags                                        

M_PS	EQU	 $600000 	 ; Prescaler Source Mask
M_PS0	EQU	 21
M_PS1	EQU	 22

;	Timer Control Bits
M_TC0    EQU     4               ; Timer Control 0
M_TC1    EQU     5               ; Timer Control 1
M_TC2    EQU     6               ; Timer Control 2
M_TC3    EQU     7               ; Timer Control 3


;------------------------------------------------------------------------
;
;       EQUATES for Direct Memory Access (DMA)                                 
;
;------------------------------------------------------------------------

;       Register Addresses Of DMA
M_DSTR	 EQU	$FFFFF4		; DMA Status Register
M_DOR0   EQU     $FFFFF3         ; DMA Offset Register 0
M_DOR1   EQU     $FFFFF2         ; DMA Offset Register 1
M_DOR2   EQU     $FFFFF1         ; DMA Offset Register 2
M_DOR3   EQU     $FFFFF0         ; DMA Offset Register 3


;       Register Addresses Of DMA0

M_DSR0   EQU     $FFFFEF         ; DMA0 Source Address Register
M_DDR0   EQU     $FFFFEE         ; DMA0 Destination Address Register 
M_DCO0   EQU     $FFFFED         ; DMA0 Counter
M_DCR0   EQU     $FFFFEC         ; DMA0 Control Register 

;       Register Addresses Of DMA1

M_DSR1   EQU     $FFFFEB         ; DMA1 Source Address Register
M_DDR1   EQU     $FFFFEA         ; DMA1 Destination Address Register 
M_DCO1   EQU     $FFFFE9         ; DMA1 Counter
M_DCR1   EQU     $FFFFE8         ; DMA1 Control Register

;       Register Addresses Of DMA2

M_DSR2   EQU     $FFFFE7         ; DMA2 Source Address Register
M_DDR2   EQU     $FFFFE6         ; DMA2 Destination Address Register 
M_DCO2   EQU     $FFFFE5         ; DMA2 Counter
M_DCR2   EQU     $FFFFE4         ; DMA2 Control Register
 
;       Register Addresses Of DMA4

M_DSR3   EQU     $FFFFE3         ; DMA3 Source Address Register
M_DDR3   EQU     $FFFFE2         ; DMA3 Destination Address Register 
M_DCO3   EQU     $FFFFE1         ; DMA3 Counter
M_DCR3   EQU     $FFFFE0         ; DMA3 Control Register

;       Register Addresses Of DMA4


M_DSR4   EQU     $FFFFDF         ; DMA4 Source Address Register
M_DDR4   EQU     $FFFFDE         ; DMA4 Destination Address Register 
M_DCO4   EQU     $FFFFDD         ; DMA4 Counter
M_DCR4   EQU     $FFFFDC         ; DMA4 Control Register 

;       Register Addresses Of DMA5

M_DSR5   EQU     $FFFFDB         ; DMA5 Source Address Register
M_DDR5   EQU     $FFFFDA         ; DMA5 Destination Address Register 
M_DCO5   EQU     $FFFFD9         ; DMA5 Counter
M_DCR5   EQU     $FFFFD8         ; DMA5 Control Register

;	DMA Control Register

M_DSS	 EQU	$3		; DMA Source Space Mask (DSS0-Dss1)
M_DSS0	 EQU	0		; DMA Source Memory space 0
M_DSS1	 EQU	1		; DMA Source Memory space 1	
M_DDS	 EQU	$C		; DMA Destination Space Mask (DDS-DDS1)
M_DDS0	 EQU	2		; DMA Destination Memory Space 0
M_DDS1	 EQU	3		; DMA Destination Memory Space 1
M_DAM	 EQU	$3f0		; DMA Address Mode Mask (DAM5-DAM0)
M_DAM0 	 EQU	4		; DMA Address Mode 0
M_DAM1 	 EQU	5		; DMA Address Mode 1
M_DAM2 	 EQU	6		; DMA Address Mode 2
M_DAM3 	 EQU	7		; DMA Address Mode 3
M_DAM4 	 EQU	8		; DMA Address Mode 4
M_DAM5 	 EQU	9		; DMA Address Mode 5
M_D3D	 EQU 	10		; DMA Three Dimensional Mode
M_DRS	 EQU	$F800		; DMA Request Source Mask (DRS0-DRS4)
M_DCON	 EQU	16		; DMA Continuous Mode
M_DPR	 EQU	$60000		; DMA Channel Priority
M_DPR0	 EQU	17		; DMA Channel Priority Level (low)
M_DPR1	 EQU	18		; DMA Channel Priority Level (high)
M_DTM	 EQU	$380000		; DMA Transfer Mode Mask (DTM2-DTM0)
M_DTM0	 EQU	19		; DMA Transfer Mode 0
M_DTM1	 EQU	20		; DMA Transfer Mode 1
M_DTM2	 EQU	21		; DMA Transfer Mode 2
M_DIE	 EQU	22		; DMA Interrupt Enable bit
M_DE	 EQU	23		; DMA Channel Enable bit 

;       DMA Status Register

M_DTD	 EQU	$3F		; Channel Transfer Done Status MASK (DTD0-DTD5)
M_DTD0   EQU     0               ; DMA Channel Transfer Done Status 0
M_DTD1   EQU     1               ; DMA Channel Transfer Done Status 1
M_DTD2   EQU     2               ; DMA Channel Transfer Done Status 2
M_DTD3   EQU     3               ; DMA Channel Transfer Done Status 3
M_DTD4   EQU     4               ; DMA Channel Transfer Done Status 4
M_DTD5   EQU     5               ; DMA Channel Transfer Done Status 5
M_DACT	 EQU	 8		 ; DMA Active State
M_DCH	 EQU	 $E00		 ; DMA Active Channel Mask (DCH0-DCH2)
M_DCH0	 EQU	 9		 ; DMA Active Channel 0
M_DCH1	 EQU	 10		 ; DMA Active Channel 1
M_DCH2	 EQU	 11	 	 ; DMA Active Channel 2


;------------------------------------------------------------------------
;
;       EQUATES for Phase Locked Loop (PLL) 
;
;------------------------------------------------------------------------

;       Register Addresses Of PLL

M_PCTL   EQU     $FFFFFD         ; PLL Control Register

;       PLL Control Register

M_MF     EQU     $FFF            ; Multiplication Factor Bits Mask (MF0-MF11)
M_DF     EQU     $7000           ; Division Factor Bits Mask (DF0-DF2)
M_XTLR   EQU     15              ; XTAL Range select bit
M_XTLD   EQU     16              ; XTAL Disable Bit
M_PSTP   EQU     17              ; STOP Processing State Bit 
M_PEN    EQU     18              ; PLL Enable Bit
M_PCOD   EQU     19              ; PLL Clock Output Disable Bit
M_PD	 EQU	$F00000		; PreDivider Factor Bits Mask (PD0-PD3)


;------------------------------------------------------------------------
;
;       EQUATES for BIU 
;
;------------------------------------------------------------------------

;       Register Addresses Of BIU


M_BCR    EQU     $FFFFFB         ; Bus Control Register
M_DCR    EQU     $FFFFFA         ; DRAM Control Register
M_AAR0   EQU     $FFFFF9         ; Address Attribute Register 0 
M_AAR1   EQU     $FFFFF8         ; Address Attribute Register 1 
M_AAR2   EQU     $FFFFF7         ; Address Attribute Register 2 
M_AAR3   EQU     $FFFFF6         ; Address Attribute Register 3 
M_IDR	 EQU	$FFFFF5		; ID Register

;       Bus Control Register

M_BA0W   EQU     $1F             ; Area 0 Wait Control Mask (BA0W0-BA0W4)
M_BA1W   EQU     $3E0            ; Area 1 Wait Control Mask (BA1W0-BA14)
M_BA2W   EQU     $1C00           ; Area 2 Wait Control Mask (BA2W0-BA2W2)
M_BA3W   EQU     $E000           ; Area 3 Wait Control Mask (BA3W0-BA3W3)
M_BDFW   EQU     $1F0000         ; Default Area Wait Control Mask (BDFW0-BDFW4)
M_BBS    EQU     21              ; Bus State
M_BLH    EQU     22              ; Bus Lock Hold
M_BRH    EQU     23              ; Bus Request Hold

;       DRAM Control Register

M_BCW    EQU     $3              ; In Page Wait States Bits Mask (BCW0-BCW1)
M_BRW    EQU     $C              ; Out Of Page Wait States Bits Mask (BRW0-BRW1)
M_BPS    EQU     $300            ; DRAM Page Size Bits Mask (BPS0-BPS1)
M_BPLE   EQU     11              ; Page Logic Enable
M_BME    EQU     12              ; Mastership Enable
M_BRE    EQU     13              ; Refresh Enable
M_BSTR   EQU     14              ; Software Triggered Refresh
M_BRF    EQU     $7F8000         ; Refresh Rate Bits Mask (BRF0-BRF7)
M_BRP    EQU     23              ; Refresh prescaler

;       Address Attribute Registers

M_BAT    EQU     $3              ; External Access Type and Pin Definition Bits Mask (BAT0-BAT1)
M_BAAP   EQU     2               ; Address Attribute Pin Polarity
M_BPEN   EQU     3               ; Program Space Enable
M_BXEN   EQU     4               ; X Data Space Enable
M_BYEN   EQU     5               ; Y Data Space Enable
M_BAM    EQU     6               ; Address Muxing
M_BPAC 	 EQU	 7		 ; Packing Enable
M_BNC    EQU     $F00            ; Number of Address Bits to Compare Mask (BNC0-BNC3)
M_BAC    EQU     $FFF000         ; Address to Compare Bits Mask (BAC0-BAC11)

;       control and status bits in SR

M_CP	EQU	$c00000          ; mask for CORE-DMA priority bits in SR
M_CA    equ     0                ; Carry
M_V     equ     1                ; Overflow      
M_Z     equ     2                ; Zero
M_N     equ     3                ; Negative      
M_U     equ     4                ; Unnormalized
M_E     equ     5                ; Extension     
M_L     equ     6                ; Limit
M_S     equ     7                ; Scaling Bit   
M_I0    equ     8                ; Interupt Mask Bit 0
M_I1    equ     9                ; Interupt Mask Bit 1
M_S0    equ     10               ; Scaling Mode Bit 0
M_S1    equ     11               ; Scaling Mode Bit 1
M_SC    equ     13               ; Sixteen_Bit Compatibility
M_DM    equ     14               ; Double Precision Multiply
M_LF    equ     15               ; DO-Loop Flag
M_FV    equ     16               ; DO-Forever Flag
M_SA    equ     17               ; Sixteen-Bit Arithmetic
M_CE    equ     19               ; Instruction Cache Enable
M_SM    equ     20               ; Arithmetic Saturation
M_RM    equ     21               ; Rounding Mode
M_CP0	EQU	22               ; bit 0 of priority bits in SR
M_CP1   EQU     23               ; bit 1 of priority bits in SR

;       control and status bits in OMR
M_CDP	EQU	$300             ; mask for CORE-DMA priority bits in OMR
M_MA    equ     0                ; Operating Mode A
M_MB   equ      1                ; Operating Mode B
M_MC    equ     2                ; Operating Mode C
M_MD    equ     3                ; Operating Mode D
M_EBD   equ     4                ; External Bus Disable bit in OMR
M_SD    equ     6                ; Stop Delay  
M_CDP0	EQU	8                ; bit 0 of priority bits in OMR
M_CDP1	EQU	9                ; bit 1 of priority bits in OMR
M_BEN   EQU     10               ; Burst Enable 
M_TAS   EQU     11               ; TA Synchronize Select
M_BRT   EQU     12               ; Bus Release Timing 
M_XYS   equ     16               ; Stack Extension space select bit in OMR.
M_EUN   equ     17               ; Extensed stack UNderflow flag in OMR.
M_EOV   equ     18               ; Extended stack OVerflow flag in OMR.
M_WRP   equ     19               ; Extended WRaP flag in OMR.
M_SEN   equ     20               ; Stack Extension Enable bit in OMR.




;*********************************************************************************
;
;     EQUATES for 56301 interrupts
;     Reference: 56301 Specifications Revision 3.00 
;
;     Last update: August   16 1994
;
;*********************************************************************************

	page	132,55,0,0,0
	opt	mex

intequ  ident   1,0

	if	@DEF(I_VEC)
	;leave user definition as is.
	else
I_VEC	equ	$0
	endif

;------------------------------------------------------------------------
; Non-Maskable interrupts
;------------------------------------------------------------------------
I_RESET  EQU  I_VEC+$00   ; Hardware RESET
I_STACK  EQU  I_VEC+$02   ; Stack Error
I_ILL    EQU  I_VEC+$04   ; Illegal Instruction
I_DBG    EQU  I_VEC+$06   ; Debug Request      
I_TRAP   EQU  I_VEC+$08   ; Trap
I_NMI    EQU  I_VEC+$0A   ; Non Maskable Interrupt

;------------------------------------------------------------------------
; Interrupt Request Pins
;------------------------------------------------------------------------
I_IRQA   EQU  I_VEC+$10   ; IRQA
I_IRQB   EQU  I_VEC+$12   ; IRQB
I_IRQC   EQU  I_VEC+$14   ; IRQC
I_IRQD   EQU  I_VEC+$16   ; IRQD

;------------------------------------------------------------------------
; DMA Interrupts
;------------------------------------------------------------------------
I_DMA0   EQU  I_VEC+$18   ; DMA Channel 0
I_DMA1   EQU  I_VEC+$1A   ; DMA Channel 1
I_DMA2   EQU  I_VEC+$1C   ; DMA Channel 2
I_DMA3   EQU  I_VEC+$1E   ; DMA Channel 3
I_DMA4   EQU  I_VEC+$20   ; DMA Channel 4
I_DMA5   EQU  I_VEC+$22   ; DMA Channel 5

;------------------------------------------------------------------------
; Timer Interrupts
;------------------------------------------------------------------------
I_TIM0C  EQU  I_VEC+$24   ; TIMER 0 compare
I_TIM0OF EQU  I_VEC+$26   ; TIMER 0 overflow
I_TIM1C  EQU  I_VEC+$28   ; TIMER 1 compare
I_TIM1OF EQU  I_VEC+$2A   ; TIMER 1 overflow
I_TIM2C  EQU  I_VEC+$2C   ; TIMER 2 compare
I_TIM2OF EQU  I_VEC+$2E   ; TIMER 2 overflow

;------------------------------------------------------------------------
; ESSI Interrupts
;------------------------------------------------------------------------
I_SI0RD  EQU  I_VEC+$30   ; ESSI0 Receive Data
I_SI0RDE EQU  I_VEC+$32   ; ESSI0 Receive Data With Exception Status
I_SI0RLS EQU  I_VEC+$34   ; ESSI0 Receive last slot
I_SI0TD  EQU  I_VEC+$36   ; ESSI0 Transmit data
I_SI0TDE EQU  I_VEC+$38   ; ESSI0 Transmit Data With Exception Status
I_SI0TLS EQU  I_VEC+$3A   ; ESSI0 Transmit last slot
I_SI1RD  EQU  I_VEC+$40   ; ESSI1 Receive Data
I_SI1RDE EQU  I_VEC+$42   ; ESSI1 Receive Data With Exception Status
I_SI1RLS EQU  I_VEC+$44   ; ESSI1 Receive last slot
I_SI1TD  EQU  I_VEC+$46   ; ESSI1 Transmit data
I_SI1TDE EQU  I_VEC+$48   ; ESSI1 Transmit Data With Exception Status
I_SI1TLS EQU  I_VEC+$4A   ; ESSI1 Transmit last slot

;------------------------------------------------------------------------
; SCI Interrupts
;------------------------------------------------------------------------
I_SCIRD  EQU  I_VEC+$50   ; SCI Receive Data 
I_SCIRDE EQU  I_VEC+$52   ; SCI Receive Data With Exception Status
I_SCITD  EQU  I_VEC+$54   ; SCI Transmit Data
I_SCIIL  EQU  I_VEC+$56   ; SCI Idle Line
I_SCITM  EQU  I_VEC+$58   ; SCI Timer

;------------------------------------------------------------------------
; HOST Interrupts
;------------------------------------------------------------------------
I_HPTT   EQU  I_VEC+$60   ; Host PCI Transaction Termination
I_HPTA   EQU  I_VEC+$62   ; Host PCI Transaction Abort
I_HPPE   EQU  I_VEC+$64   ; Host PCI Parity Error
I_HPTC   EQU  I_VEC+$66   ; Host PCI Transfer Complete
I_HPMR   EQU  I_VEC+$68   ; Host PCI Master Receive
I_HSR    EQU  I_VEC+$6A   ; Host Slave Receive
I_HPMT   EQU  I_VEC+$6C   ; Host PCI Master Transmit
I_HST    EQU  I_VEC+$6E   ; Host Slave Transmit
I_HPMA   EQU  I_VEC+$70   ; Host PCI Master Address
I_HCNMI  EQU  I_VEC+$72   ; Host Command/Host NMI (Default)

;------------------------------------------------------------------------
; INTERRUPT ENDING ADDRESS
;------------------------------------------------------------------------
I_INTEND EQU  I_VEC+$FF   ; last address of interrupt vector space
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\lleyrom.asm ===
dc	$80B652
	dc	$7E94D5
	dc	$081251
	dc	$F7EE67
	dc	$081251
	dc	$805361
	dc	$7F6007
	dc	$1C8662
	dc	$E37CFE
	dc	$1C8662
	dc	$808C65
	dc	$7EEB1C
	dc	$010B74
	dc	$FEF67B
	dc	$010B74
	dc	$801DB0
	dc	$7FCD25
	dc	$1142D5
	dc	$EEC16A
	dc	$1142D5
	dc	$FFD43D
	dc	$119829
	dc	$26DA06
	dc	$21C64D
	dc	$26DA06
	dc	$159B58
	dc	$55B759
	dc	$605766
	dc	$201F9E
	dc	$605766
	dc	$1FA4D2
	dc	$774339
	dc	$687FE3
	dc	$30FF87
	dc	$687FE3
	dc	$0B0E75
	dc	$1251AB
	dc	$35486E
	dc	$1EEEDC
	dc	$35486E
	dc	$251CD5
	dc	$57319E
	dc	$4C080D
	dc	$449C2A
	dc	$4C080D
	dc	$30C7F7
	dc	$77ADA6
	dc	$74AE92
	dc	$360AEE
	dc	$74AE92
	dc	$16C3AB
	dc	$14ACB7
	dc	$39D4BB
	dc	$27454B
	dc	$39D4BB
	dc	$3441F9
	dc	$5978D5
	dc	$536EAE
	dc	$4D7C52
	dc	$536EAE
	dc	$40ECCE
	dc	$7843E0
	dc	$763244
	dc	$44C8FA
	dc	$763244
	dc	$230D4D
	dc	$18EE97
	dc	$420FC8
	dc	$2D74D1
	dc	$420FC8
	dc	$42D5AD
	dc	$5C8EC1
	dc	$5AD851
	dc	$5644BD
	dc	$5AD851
	dc	$4FC627
	dc	$7902EE
	dc	$72771E
	dc	$5779E0
	dc	$72771E
	dc	$300690
	dc	$1F7818
	dc	$47C4B6
	dc	$37FDE7
	dc	$47C4B6
	dc	$509D22
	dc	$6073ED
	dc	$6215CE
	dc	$5EC14B
	dc	$6215CE
	dc	$5D0C75
	dc	$79E730
	dc	$756077
	dc	$6220C1
	dc	$756077
	dc	$3DCBB1
	dc	$28CEA4
	dc	$4D2AF1
	dc	$450812
	dc	$4D2AF1
	dc	$5D56F0
	dc	$6526DF
	dc	$6906E1
	dc	$66CA75
	dc	$6906E1
	dc	$687E85
	dc	$7AEC6C
	dc	$7A76E9
	dc	$68F757
	dc	$7A76E9
	dc	$4C781F
	dc	$35A91E
	dc	$5738EF
	dc	$5013BE
	dc	$5738EF
	dc	$68BA93
	dc	$6AA314
	dc	$6FAFD0
	dc	$6E5C4D
	dc	$6FAFD0
	dc	$71E246
	dc	$7C0DD3
	dc	$7A3EE3
	dc	$72EB44
	dc	$7A3EE3
	dc	$5C2288
	dc	$4701E7
	dc	$612530
	dc	$5E7E4C
	dc	$612530
	dc	$72788D
	dc	$70DFBD
	dc	$75B679
	dc	$7515A8
	dc	$75B679
	dc	$790593
	dc	$7D4612
	dc	$7CCFFF
	dc	$78205F
	dc	$7CCFFF
	dc	$6CD503
	dc	$5E2F5B
	dc	$6E5E78
	dc	$6D8E38
	dc	$6E5E78
	dc	$7A3B64
	dc	$77CE50
	dc	$7B18F9
	dc	$7AEBEE
	dc	$7B18F9
	dc	$7DBF1C
	dc	$7E8F57
	dc	$7DC387
	dc	$7C7BEB
	dc	$7DC387
	dc	$52680A
	dc	$3D2546
	dc	$27E5C9
	dc	$12A305
	dc	$47C84B
	dc	$328588
	dc	$1D42C4
	dc	$CD7DE9
	dc	$17E153
	dc	$2CD213
	dc	$D36808
	dc	$2CD213
	dc	$BF3A00
	dc	$47D461
	dc	$3B1618
	dc	$C6A2F1
	dc	$3B1618
	dc	$0CCCCD
	dc	$09999A
	dc	$066666
	dc	$333333
	dc	$200000
	dc	$133333
	dc	$000475
	dc	$0007FE
	dc	$000C02
	dc	$0010A3
	dc	$0015F5
	dc	$001C08
	dc	$0022ED
	dc	$002AB5
	dc	$003371
	dc	$003D32
	dc	$00480A
	dc	$00540D
	dc	$00614B
	dc	$006FDA
	dc	$007FCD
	dc	$009138
	dc	$00A431
	dc	$00B8CC
	dc	$00CF1F
	dc	$00E741
	dc	$010148
	dc	$011D4B
	dc	$013B61
	dc	$015BA2
	dc	$017E25
	dc	$01A302
	dc	$01CA51
	dc	$01F42C
	dc	$0220A9
	dc	$024FE2
	dc	$0281F0
	dc	$02B6EA
	dc	$02EEE9
	dc	$032A07
	dc	$03685A
	dc	$03A9FC
	dc	$03EF04
	dc	$04378A
	dc	$0483A5
	dc	$04D36D
	dc	$0526F7
	dc	$057E5B
	dc	$05D9AE
	dc	$063904
	dc	$069C74
	dc	$070410
	dc	$076FEB
	dc	$07E01A
	dc	$0854AC
	dc	$08CDB3
	dc	$094B40
	dc	$09CD61
	dc	$0A5425
	dc	$0ADF98
	dc	$0B6FC8
	dc	$0C04BF
	dc	$0C9E87
	dc	$0D3D2A
	dc	$0DE0AE
	dc	$0E891A
	dc	$0F3674
	dc	$0FE8C0
	dc	$109FFF
	dc	$115C34
	dc	$121D5D
	dc	$12E37B
	dc	$13AE89
	dc	$147E84
	dc	$155366
	dc	$162D27
	dc	$170BBF
	dc	$17EF23
	dc	$18D748
	dc	$19C421
	dc	$1AB59F
	dc	$1BABB2
	dc	$1CA648
	dc	$1DA54F
	dc	$1EA8B0
	dc	$1FB058
	dc	$20BC2D
	dc	$21CC18
	dc	$22DFFD
	dc	$23F7C2
	dc	$251348
	dc	$263272
	dc	$275520
	dc	$287B31
	dc	$29A482
	dc	$2AD0F1
	dc	$2C0059
	dc	$2D3294
	dc	$2E677C
	dc	$2F9EE8
	dc	$30D8B1
	dc	$3214AC
	dc	$3352B0
	dc	$349290
	dc	$35D422
	dc	$371738
	dc	$385BA5
	dc	$39A13B
	dc	$3AE7CC
	dc	$3C2F2A
	dc	$3D7725
	dc	$3EBF8D
	dc	$400834
	dc	$4150E9
	dc	$42997D
	dc	$43E1C0
	dc	$452981
	dc	$467092
	dc	$47B6C3
	dc	$48FBE3
	dc	$4A3FC6
	dc	$4B823B
	dc	$4CC316
	dc	$4E0228
	dc	$4F3F45
	dc	$507A40
	dc	$51B2EF
	dc	$52E925
	dc	$541CBA
	dc	$554D85
	dc	$567B5E
	dc	$57A61D
	dc	$58CD9E
	dc	$59F1BB
	dc	$5B1252
	dc	$5C2F3F
	dc	$5D4863
	dc	$5E5D9D
	dc	$5F6ED0
	dc	$607BDE
	dc	$6184AD
	dc	$628923
	dc	$638927
	dc	$6484A3
	dc	$657B81
	dc	$666DAF
	dc	$675B19
	dc	$6843B1
	dc	$692767
	dc	$6A062D
	dc	$6ADFF9
	dc	$6BB4C2
	dc	$6C847D
	dc	$6D4F27
	dc	$6E14B8
	dc	$6ED52F
	dc	$6F9089
	dc	$7046C6
	dc	$70F7E9
	dc	$71A3F3
	dc	$724AEA
	dc	$72ECD3
	dc	$7389B6
	dc	$74219D
	dc	$74B490
	dc	$75429B
	dc	$75CBCC
	dc	$765031
	dc	$76CFD8
	dc	$774AD3
	dc	$77C132
	dc	$783308
	dc	$78A068
	dc	$790968
	dc	$796E1C
	dc	$79CE9A
	dc	$7A2AF9
	dc	$7A8350
	dc	$7AD7B8
	dc	$7B2849
	dc	$7B751D
	dc	$7BBE4C
	dc	$7C03F1
	dc	$7C4625
	dc	$7C8504
	dc	$7CC0A8
	dc	$7CF92C
	dc	$7D2EAA
	dc	$7D613E
	dc	$7D9101
	dc	$7DBE10
	dc	$7DE883
	dc	$7E1076
	dc	$7E3603
	dc	$7E5943
	dc	$7E7A4F
	dc	$7E9942
	dc	$7EB633
	dc	$7ED13A
	dc	$7EEA6F
	dc	$7F01EA
	dc	$7F17C0
	dc	$7F2C08
	dc	$7F3ED7
	dc	$7F5043
	dc	$7F605E
	dc	$7F6F3C
	dc	$7F7CF1
	dc	$7F898E
	dc	$7F9525
	dc	$7F9FC6
	dc	$7FA982
	dc	$7FB268
	dc	$7FBA86
	dc	$7FC1EB
	dc	$7FC8A4
	dc	$7FCEBE
	dc	$7FD443
	dc	$7FD941
	dc	$7FDDC2
	dc	$7FE1CF
	dc	$7FE572
	dc	$7FE8B4
	dc	$7FEB9E
	dc	$7FEE36
	dc	$7FF086
	dc	$7FF293
	dc	$7FF463
	dc	$7FF5FD
	dc	$7FF765
	dc	$7FF8A1
	dc	$7FF9B6
	dc	$7FFAA7
	dc	$7FFB79
	dc	$7FFC2F
	dc	$7FFCCB
	dc	$7FFD52
	dc	$7FFDC6
	dc	$7FFE28
	dc	$7FFE7B
	dc	$7FFEC2
	dc	$7FFEFD
	dc	$7FFF2F
	dc	$7FFF58
	dc	$7FFF7B
	dc	$7FFF97
	dc	$7FFFAE
	dc	$7FFFC0
	dc	$7FFFCF
	dc	$7FFFDB
	dc	$7FFFE4
	dc	$7FFFEC
	dc	$7FFFF1
	dc	$7FFFF6
	dc	$7FFFF9
	dc	$7FFFFB
	dc	$7FFFFD
	dc	$7FFFFE
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$7FFFFF
	dc	$80000A
	dc	$80031F
	dc	$800B24
	dc	$801818
	dc	$8029FA
	dc	$8040C9
	dc	$805C86
	dc	$807D2E
	dc	$80A2C1
	dc	$80CD3C
	dc	$80FC9F
	dc	$8130E8
	dc	$816A14
	dc	$81A821
	dc	$81EB0E
	dc	$8232D6
	dc	$827F79
	dc	$82D0F2
	dc	$83273E
	dc	$83825B
	dc	$83E244
	dc	$8446F7
	dc	$84B06E
	dc	$851EA6
	dc	$85919B
	dc	$860949
	dc	$8685AA
	dc	$8706BA
	dc	$878C74
	dc	$8816D3
	dc	$88A5D1
	dc	$89396A
	dc	$89D196
	dc	$8A6E51
	dc	$8B0F94
	dc	$8BB55A
	dc	$8C5F9B
	dc	$8D0E51
	dc	$8DC176
	dc	$8E7902
	dc	$8F34EF
	dc	$8FF535
	dc	$90B9CC
	dc	$9182AE
	dc	$924FD3
	dc	$932132
	dc	$93F6C3
	dc	$94D07F
	dc	$95AE5D
	dc	$969054
	dc	$97765B
	dc	$98606A
	dc	$994E78
	dc	$9A407C
	dc	$9B366B
	dc	$9C303E
	dc	$9D2DE9
	dc	$9E2F64
	dc	$9F34A4
	dc	$A03DA0
	dc	$A14A4C
	dc	$A25AA0
	dc	$A36E8F
	dc	$A48610
	dc	$A5A118
	dc	$A6BF9C
	dc	$A7E191
	dc	$A906EC
	dc	$AA2FA0
	dc	$AB5BA4
	dc	$AC8AEB
	dc	$ADBD6A
	dc	$AEF315
	dc	$B02BDF
	dc	$B167BE
	dc	$B2A6A4
	dc	$B3E886
	dc	$B52D56
	dc	$B67509
	dc	$B7BF92
	dc	$B90CE4
	dc	$BA5CF2
	dc	$BBAFB0
	dc	$BD050F
	dc	$BE5D04
	dc	$BFB780
	dc	$C11477
	dc	$C273DB
	dc	$C3D59F
	dc	$C539B4
	dc	$C6A00D
	dc	$C8089D
	dc	$C97355
	dc	$CAE027
	dc	$CC4F05
	dc	$CDBFE2
	dc	$CF32AF
	dc	$D0A75D
	dc	$D21DDF
	dc	$D39625
	dc	$D51022
	dc	$D68BC7
	dc	$D80904
	dc	$D987CD
	dc	$DB0810
	dc	$DC89C1
	dc	$DE0CD0
	dc	$DF912D
	dc	$E116CB
	dc	$E29D9A
	dc	$E4258B
	dc	$E5AE8F
	dc	$E73896
	dc	$E8C392
	dc	$EA4F74
	dc	$EBDC2B
	dc	$ED69AA
	dc	$EEF7DF
	dc	$F086BD
	dc	$F21634
	dc	$F3A634
	dc	$F536AD
	dc	$F6C792
	dc	$F858D1
	dc	$F9EA5B
	dc	$FB7C22
	dc	$FD0E16
	dc	$FEA026
	dc	$FFCDBC
	dc	$FE3BA0
	dc	$FCA995
	dc	$FB17AC
	dc	$F985F3
	dc	$F7F479
	dc	$F6634F
	dc	$F4D284
	dc	$F34228
	dc	$F1B249
	dc	$F022F7
	dc	$EE9442
	dc	$ED0638
	dc	$EB78EA
	dc	$E9EC67
	dc	$E860BD
	dc	$E6D5FD
	dc	$E54C35
	dc	$E3C374
	dc	$E23BCB
	dc	$E0B547
	dc	$DF2FF7
	dc	$DDABEC
	dc	$DC2933
	dc	$DAA7DD
	dc	$D927F6
	dc	$D7A98F
	dc	$D62CB7
	dc	$D4B17B
	dc	$D337EA
	dc	$D1C013
	dc	$D04A05
	dc	$CED5CE
	dc	$CD637C
	dc	$CBF31D
	dc	$CA84C1
	dc	$C91874
	dc	$C7AE45
	dc	$C64641
	dc	$C4E078
	dc	$C37CF6
	dc	$C21BC9
	dc	$C0BCFF
	dc	$BF60A5
	dc	$BE06C9
	dc	$BCAF79
	dc	$BB5AC0
	dc	$BA08AE
	dc	$B8B94D
	dc	$B76CAC
	dc	$B622D8
	dc	$B4DBDC
	dc	$B397C6
	dc	$B256A2
	dc	$B1187D
	dc	$AFDD62
	dc	$AEA55F
	dc	$AD707E
	dc	$AC3ECC
	dc	$AB1054
	dc	$A9E523
	dc	$A8BD44
	dc	$A798C2
	dc	$A677A8
	dc	$A55A02
	dc	$A43FDB
	dc	$A3293D
	dc	$A21634
	dc	$A106C9
	dc	$9FFB08
	dc	$9EF2FA
	dc	$9DEEAB
	dc	$9CEE23
	dc	$9BF16C
	dc	$9AF892
	dc	$9A039C
	dc	$991295
	dc	$982586
	dc	$973C78
	dc	$965774
	dc	$957683
	dc	$9499AD
	dc	$93C0FB
	dc	$92EC75
	dc	$921C24
	dc	$91500F
	dc	$90883F
	dc	$8FC4BB
	dc	$8F058B
	dc	$8E4AB6
	dc	$8D9443
	dc	$8CE239
	dc	$8C349F
	dc	$8B8B7D
	dc	$8AE6D7
	dc	$8A46B5
	dc	$89AB1E
	dc	$891416
	dc	$8881A3
	dc	$87F3CC
	dc	$876A96
	dc	$86E606
	dc	$866621
	dc	$85EAED
	dc	$85746D
	dc	$8502A6
	dc	$84959E
	dc	$842D57
	dc	$83C9D7
	dc	$836B20
	dc	$831138
	dc	$82BC20
	dc	$826BDC
	dc	$822070
	dc	$81D9DE
	dc	$819829
	dc	$815B54
	dc	$812360
	dc	$80F051
	dc	$80C228
	dc	$8098E6
	dc	$80748E
	dc	$805521
	dc	$803A9F
	dc	$80250B
	dc	$801464
	dc	$8008AD
	dc	$8001E4
	dc	$800027
	dc	$800C7E
	dc	$802C8F
	dc	$806056
	dc	$80A7CB
	dc	$8102E4
	dc	$817191
	dc	$81F3C3
	dc	$828964
	dc	$83325F
	dc	$83EE98
	dc	$84BDF3
	dc	$85A04F
	dc	$86958B
	dc	$879D7F
	dc	$88B804
	dc	$89E4EE
	dc	$8B240E
	dc	$8C7533
	dc	$8DD82A
	dc	$8F4CBB
	dc	$90D2AD
	dc	$9269C4
	dc	$9411C1
	dc	$95CA62
	dc	$979365
	dc	$996C81
	dc	$9B5570
	dc	$9D4DE4
	dc	$9F5590
	dc	$A16C24
	dc	$A3914E
	dc	$A5C4B8
	dc	$A8060D
	dc	$AA54F3
	dc	$ACB10E
	dc	$AF1A03
	dc	$B18F70
	dc	$B410F7
	dc	$B69E33
	dc	$B936C0
	dc	$BBDA37
	dc	$BE8830
	dc	$C14042
	dc	$C40201
	dc	$C6CD00
	dc	$C9A0D2
	dc	$CC7D05
	dc	$CF612B
	dc	$D24CCF
	dc	$D53F80
	dc	$D838C8
	dc	$DB3833
	dc	$DE3D49
	dc	$E14795
	dc	$E4569D
	dc	$E769E9
	dc	$EA80FF
	dc	$ED9B67
	dc	$F0B8A4
	dc	$F3D83C
	dc	$F6F9B5
	dc	$FA1C91
	dc	$FD4056
	dc	$FF9B78
	dc	$FC7756
	dc	$F953C0
	dc	$F63130
	dc	$F31025
	dc	$EFF117
	dc	$ECD484
	dc	$E9BAE5
	dc	$E6A4B6
	dc	$E39270
	dc	$E0848B
	dc	$DD7B82
	dc	$DA77CB
	dc	$D779DE
	dc	$D48231
	dc	$D19138
	dc	$CEA769
	dc	$CBC535
	dc	$C8EB10
	dc	$C61969
	dc	$C350AF
	dc	$C09151
	dc	$BDDBBB
	dc	$BB3059
	dc	$B88F92
	dc	$B5F9D0
	dc	$B36F78
	dc	$B0F0EF
	dc	$AE7E96
	dc	$AC18CF
	dc	$A9BFF9
	dc	$A7746F
	dc	$A5368C
	dc	$A306AA
	dc	$A0E51E
	dc	$9ED23C
	dc	$9CCE56
	dc	$9AD9BC
	dc	$98F4BC
	dc	$971F9F
	dc	$955AAE
	dc	$93A62F
	dc	$920266
	dc	$906F92
	dc	$8EEDF3
	dc	$8D7DC4
	dc	$8C1F3C
	dc	$8AD294
	dc	$8997FD
	dc	$886FA8
	dc	$8759C3
	dc	$865679
	dc	$8565F2
	dc	$848852
	dc	$83BDBD
	dc	$830651
	dc	$82622B
	dc	$81D163
	dc	$815411
	dc	$80EA47
	dc	$809416
	dc	$80518B
	dc	$8022B1
	dc	$80078E
	dc	$000040
	dc	$00003F
	dc	$00003E
	dc	$00003D
	dc	$00003C
	dc	$00003B
	dc	$00003A
	dc	$000039
	dc	$000038
	dc	$000037
	dc	$000036
	dc	$000035
	dc	$000034
	dc	$000034
	dc	$000033
	dc	$000032
	dc	$000031
	dc	$000030
	dc	$00002F
	dc	$00002F
	dc	$00002E
	dc	$00002D
	dc	$00002C
	dc	$00002C
	dc	$00002B
	dc	$00002A
	dc	$000029
	dc	$000029
	dc	$000028
	dc	$000027
	dc	$000026
	dc	$000026
	dc	$000025
	dc	$000024
	dc	$000024
	dc	$000023
	dc	$000023
	dc	$000022
	dc	$000021
	dc	$000021
	dc	$000020
	dc	$000020
	dc	$00001F
	dc	$00001E
	dc	$00001E
	dc	$00001D
	dc	$00001D
	dc	$00001C
	dc	$00001C
	dc	$00001B
	dc	$00001B
	dc	$00001A
	dc	$00001A
	dc	$000019
	dc	$000019
	dc	$000018
	dc	$000018
	dc	$000017
	dc	$000017
	dc	$000016
	dc	$000016
	dc	$000015
	dc	$000015
	dc	$000015
	dc	$000014
	dc	$000014
	dc	$000013
	dc	$000013
	dc	$000013
	dc	$000012
	dc	$000012
	dc	$000012
	dc	$000011
	dc	$000011
	dc	$000011
	dc	$000010
	dc	$000010
	dc	$000010
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000005
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000004
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000002
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$00003F
	dc	$000053
	dc	$000067
	dc	$00007B
	dc	$00000F
	dc	$000011
	dc	$000013
	dc	$000015
	dc	$000080
	dc	$000100
	dc	$000180
	dc	$000200
	dc	$000280
	dc	$000300
	dc	$000380
	dc	$000400
	dc	$000540
	dc	$0004D8
	dc	$000478
	dc	$000410
	dc	$000000
	dc	$000700
	dc	$000900
	dc	$000B00
	dc	$0004D0
	dc	$0004D0
	dc	$000440
	dc	$000400
	dc	$0003E0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000370
	dc	$000360
	dc	$000360
	dc	$000350
	dc	$000350
	dc	$000340
	dc	$000340
	dc	$000330
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000310
	dc	$000340
	dc	$000390
	dc	$0003E0
	dc	$000420
	dc	$000460
	dc	$000490
	dc	$0004A0
	dc	$000460
	dc	$000440
	dc	$000440
	dc	$000520
	dc	$000800
	dc	$000840
	dc	$000840
	dc	$0004F0
	dc	$0004F0
	dc	$000460
	dc	$000410
	dc	$0003E0
	dc	$0003D0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000370
	dc	$000360
	dc	$000360
	dc	$000350
	dc	$000350
	dc	$000340
	dc	$000340
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000320
	dc	$000350
	dc	$000390
	dc	$0003E0
	dc	$000420
	dc	$000450
	dc	$0004A0
	dc	$000490
	dc	$000460
	dc	$000440
	dc	$000480
	dc	$000630
	dc	$000840
	dc	$000840
	dc	$000580
	dc	$000580
	dc	$0004B0
	dc	$000450
	dc	$000420
	dc	$0003F0
	dc	$0003E0
	dc	$0003D0
	dc	$0003C0
	dc	$0003B0
	dc	$0003B0
	dc	$0003B0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$0003A0
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000390
	dc	$000380
	dc	$000380
	dc	$000380
	dc	$000370
	dc	$000360
	dc	$000350
	dc	$000340
	dc	$000330
	dc	$000320
	dc	$000310
	dc	$000300
	dc	$0002F0
	dc	$0002F0
	dc	$0002F0
	dc	$000300
	dc	$000310
	dc	$000330
	dc	$000350
	dc	$0003C0
	dc	$000410
	dc	$000470
	dc	$0004A0
	dc	$000460
	dc	$000440
	dc	$000450
	dc	$0004E0
	dc	$0002F0
	dc	$0002B0
	dc	$000270
	dc	$000230
	dc	$0001F0
	dc	$000170
	dc	$0000F0
	dc	$FFF800
	dc	$000000
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000001
	dc	$000002
	dc	$000002
	dc	$000003
	dc	$000003
	dc	$000003
	dc	$000004
	dc	$000004
	dc	$000005
	dc	$000005
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000006
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000007
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000008
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$000009
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000A
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000B
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000C
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000D
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000E
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$00000F
	dc	$000000
	dc	$000005
	dc	$000007
	dc	$000003
	dc	$000007
	dc	$000004
	dc	$000005
	dc	$000006
	dc	$000007
	dc	$000008
	dc	$000009
	dc	$00000A
	dc	$00000B
	dc	$00000C
	dc	$00000E
	dc	$000010
	dc	$000009
	dc	$000003
	dc	$000001
	dc	$000019
	dc	$000005
	dc	$000001
	dc	$00000B
	dc	$000001
	dc	$000000
	dc	$008005
	dc	$00800F
	dc	$00000A
	dc	$00801B
	dc	$00001E
	dc	$000014
	dc	$008011
	dc	$008033
	dc	$000036
	dc	$00003C
	dc	$008039
	dc	$000028
	dc	$00802D
	dc	$008027
	dc	$000022
	dc	$008063
	dc	$000066
	dc	$00006C
	dc	$008069
	dc	$000078
	dc	$00807D
	dc	$008077
	dc	$000072
	dc	$000050
	dc	$008055
	dc	$00805F
	dc	$00005A
	dc	$00804B
	dc	$00004E
	dc	$000044
	dc	$008041
	dc	$0080C3
	dc	$0000C6
	dc	$0000CC
	dc	$0080C9
	dc	$0000D8
	dc	$0080DD
	dc	$0080D7
	dc	$0000D2
	dc	$0000F0
	dc	$0080F5
	dc	$0080FF
	dc	$0000FA
	dc	$0080EB
	dc	$0000EE
	dc	$0000E4
	dc	$0080E1
	dc	$0000A0
	dc	$0080A5
	dc	$0080AF
	dc	$0000AA
	dc	$0080BB
	dc	$0000BE
	dc	$0000B4
	dc	$0080B1
	dc	$008093
	dc	$000096
	dc	$00009C
	dc	$008099
	dc	$000088
	dc	$00808D
	dc	$008087
	dc	$000082
	dc	$008183
	dc	$000186
	dc	$00018C
	dc	$008189
	dc	$000198
	dc	$00819D
	dc	$008197
	dc	$000192
	dc	$0001B0
	dc	$0081B5
	dc	$0081BF
	dc	$0001BA
	dc	$0081AB
	dc	$0001AE
	dc	$0001A4
	dc	$0081A1
	dc	$0001E0
	dc	$0081E5
	dc	$0081EF
	dc	$0001EA
	dc	$0081FB
	dc	$0001FE
	dc	$0001F4
	dc	$0081F1
	dc	$0081D3
	dc	$0001D6
	dc	$0001DC
	dc	$0081D9
	dc	$0001C8
	dc	$0081CD
	dc	$0081C7
	dc	$0001C2
	dc	$000140
	dc	$008145
	dc	$00814F
	dc	$00014A
	dc	$00815B
	dc	$00015E
	dc	$000154
	dc	$008151
	dc	$008173
	dc	$000176
	dc	$00017C
	dc	$008179
	dc	$000168
	dc	$00816D
	dc	$008167
	dc	$000162
	dc	$008123
	dc	$000126
	dc	$00012C
	dc	$008129
	dc	$000138
	dc	$00813D
	dc	$008137
	dc	$000132
	dc	$000110
	dc	$008115
	dc	$00811F
	dc	$00011A
	dc	$00810B
	dc	$00010E
	dc	$000104
	dc	$008101
	dc	$008303
	dc	$000306
	dc	$00030C
	dc	$008309
	dc	$000318
	dc	$00831D
	dc	$008317
	dc	$000312
	dc	$000330
	dc	$008335
	dc	$00833F
	dc	$00033A
	dc	$00832B
	dc	$00032E
	dc	$000324
	dc	$008321
	dc	$000360
	dc	$008365
	dc	$00836F
	dc	$00036A
	dc	$00837B
	dc	$00037E
	dc	$000374
	dc	$008371
	dc	$008353
	dc	$000356
	dc	$00035C
	dc	$008359
	dc	$000348
	dc	$00834D
	dc	$008347
	dc	$000342
	dc	$0003C0
	dc	$0083C5
	dc	$0083CF
	dc	$0003CA
	dc	$0083DB
	dc	$0003DE
	dc	$0003D4
	dc	$0083D1
	dc	$0083F3
	dc	$0003F6
	dc	$0003FC
	dc	$0083F9
	dc	$0003E8
	dc	$0083ED
	dc	$0083E7
	dc	$0003E2
	dc	$0083A3
	dc	$0003A6
	dc	$0003AC
	dc	$0083A9
	dc	$0003B8
	dc	$0083BD
	dc	$0083B7
	dc	$0003B2
	dc	$000390
	dc	$008395
	dc	$00839F
	dc	$00039A
	dc	$00838B
	dc	$00038E
	dc	$000384
	dc	$008381
	dc	$000280
	dc	$008285
	dc	$00828F
	dc	$00028A
	dc	$00829B
	dc	$00029E
	dc	$000294
	dc	$008291
	dc	$0082B3
	dc	$0002B6
	dc	$0002BC
	dc	$0082B9
	dc	$0002A8
	dc	$0082AD
	dc	$0082A7
	dc	$0002A2
	dc	$0082E3
	dc	$0002E6
	dc	$0002EC
	dc	$0082E9
	dc	$0002F8
	dc	$0082FD
	dc	$0082F7
	dc	$0002F2
	dc	$0002D0
	dc	$0082D5
	dc	$0082DF
	dc	$0002DA
	dc	$0082CB
	dc	$0002CE
	dc	$0002C4
	dc	$0082C1
	dc	$008243
	dc	$000246
	dc	$00024C
	dc	$008249
	dc	$000258
	dc	$00825D
	dc	$008257
	dc	$000252
	dc	$000270
	dc	$008275
	dc	$00827F
	dc	$00027A
	dc	$00826B
	dc	$00026E
	dc	$000264
	dc	$008261
	dc	$000220
	dc	$008225
	dc	$00822F
	dc	$00022A
	dc	$00823B
	dc	$00023E
	dc	$000234
	dc	$008231
	dc	$008213
	dc	$000216
	dc	$00021C
	dc	$008219
	dc	$000208
	dc	$00820D
	dc	$008207
	dc	$000202
	dc	$000000
	dc	$007F81
	dc	$00FF02
	dc	$008083
	dc	$007E01
	dc	$000180
	dc	$008103
	dc	$00FE82
	dc	$00FC02
	dc	$008383
	dc	$000300
	dc	$007C81
	dc	$008203
	dc	$00FD82
	dc	$007D01
	dc	$000280
	dc	$007801
	dc	$000780
	dc	$008703
	dc	$00F882
	dc	$000600
	dc	$007981
	dc	$00F902
	dc	$008683
	dc	$008403
	dc	$00FB82
	dc	$007B01
	dc	$000480
	dc	$00FA02
	dc	$008583
	dc	$000500
	dc	$007A81
	dc	$00F002
	dc	$008F83
	dc	$000F00
	dc	$007081
	dc	$008E03
	dc	$00F182
	dc	$007101
	dc	$000E80
	dc	$000C00
	dc	$007381
	dc	$00F302
	dc	$008C83
	dc	$007201
	dc	$000D80
	dc	$008D03
	dc	$00F282
	dc	$008803
	dc	$00F782
	dc	$007701
	dc	$000880
	dc	$00F602
	dc	$008983
	dc	$000900
	dc	$007681
	dc	$007401
	dc	$000B80
	dc	$008B03
	dc	$00F482
	dc	$000A00
	dc	$007581
	dc	$00F502
	dc	$008A83
	dc	$006001
	dc	$001F80
	dc	$009F03
	dc	$00E082
	dc	$001E00
	dc	$006181
	dc	$00E102
	dc	$009E83
	dc	$009C03
	dc	$00E382
	dc	$006301
	dc	$001C80
	dc	$00E202
	dc	$009D83
	dc	$001D00
	dc	$006281
	dc	$001800
	dc	$006781
	dc	$00E702
	dc	$009883
	dc	$006601
	dc	$001980
	dc	$009903
	dc	$00E682
	dc	$00E402
	dc	$009B83
	dc	$001B00
	dc	$006481
	dc	$009A03
	dc	$00E582
	dc	$006501
	dc	$001A80
	dc	$009003
	dc	$00EF82
	dc	$006F01
	dc	$001080
	dc	$00EE02
	dc	$009183
	dc	$001100
	dc	$006E81
	dc	$006C01
	dc	$001380
	dc	$009303
	dc	$00EC82
	dc	$001200
	dc	$006D81
	dc	$00ED02
	dc	$009283
	dc	$00E802
	dc	$009783
	dc	$001700
	dc	$006881
	dc	$009603
	dc	$00E982
	dc	$006901
	dc	$001680
	dc	$001400
	dc	$006B81
	dc	$00EB02
	dc	$009483
	dc	$006A01
	dc	$001580
	dc	$009503
	dc	$00EA82
	dc	$00C002
	dc	$00BF83
	dc	$003F00
	dc	$004081
	dc	$00BE03
	dc	$00C182
	dc	$004101
	dc	$003E80
	dc	$003C00
	dc	$004381
	dc	$00C302
	dc	$00BC83
	dc	$004201
	dc	$003D80
	dc	$00BD03
	dc	$00C282
	dc	$00B803
	dc	$00C782
	dc	$004701
	dc	$003880
	dc	$00C602
	dc	$00B983
	dc	$003900
	dc	$004681
	dc	$004401
	dc	$003B80
	dc	$00BB03
	dc	$00C482
	dc	$003A00
	dc	$004581
	dc	$00C502
	dc	$00BA83
	dc	$003000
	dc	$004F81
	dc	$00CF02
	dc	$00B083
	dc	$004E01
	dc	$003180
	dc	$00B103
	dc	$00CE82
	dc	$00CC02
	dc	$00B383
	dc	$003300
	dc	$004C81
	dc	$00B203
	dc	$00CD82
	dc	$004D01
	dc	$003280
	dc	$004801
	dc	$003780
	dc	$00B703
	dc	$00C882
	dc	$003600
	dc	$004981
	dc	$00C902
	dc	$00B683
	dc	$00B403
	dc	$00CB82
	dc	$004B01
	dc	$003480
	dc	$00CA02
	dc	$00B583
	dc	$003500
	dc	$004A81
	dc	$00A003
	dc	$00DF82
	dc	$005F01
	dc	$002080
	dc	$00DE02
	dc	$00A183
	dc	$002100
	dc	$005E81
	dc	$005C01
	dc	$002380
	dc	$00A303
	dc	$00DC82
	dc	$002200
	dc	$005D81
	dc	$00DD02
	dc	$00A283
	dc	$00D802
	dc	$00A783
	dc	$002700
	dc	$005881
	dc	$00A603
	dc	$00D982
	dc	$005901
	dc	$002680
	dc	$002400
	dc	$005B81
	dc	$00DB02
	dc	$00A483
	dc	$005A01
	dc	$002580
	dc	$00A503
	dc	$00DA82
	dc	$005001
	dc	$002F80
	dc	$00AF03
	dc	$00D082
	dc	$002E00
	dc	$005181
	dc	$00D102
	dc	$00AE83
	dc	$00AC03
	dc	$00D382
	dc	$005301
	dc	$002C80
	dc	$00D202
	dc	$00AD83
	dc	$002D00
	dc	$005281
	dc	$002800
	dc	$005781
	dc	$00D702
	dc	$00A883
	dc	$005601
	dc	$002980
	dc	$00A903
	dc	$00D682
	dc	$00D402
	dc	$00AB83
	dc	$002B00
	dc	$005481
	dc	$00AA03
	dc	$00D582
	dc	$005501
	dc	$002A80
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000004
	dc	$000000
	dc	$800000
	dc	$C00000
	dc	$E00000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$000006
	dc	$000007
	dc	$000008
	dc	$000009
	dc	$00000A
	dc	$00000B
	dc	$00000C
	dc	$00000D
	dc	$00000E
	dc	$00000F
	dc	$000010
	dc	$000011
	dc	$000012
	dc	$000013
	dc	$000014
	dc	$000015
	dc	$000016
	dc	$000017
	dc	$000018
	dc	$000019
	dc	$00001A
	dc	$00001B
	dc	$00001C
	dc	$00001F
	dc	$000022
	dc	$000025
	dc	$000028
	dc	$00002B
	dc	$00002E
	dc	$000031
	dc	$000037
	dc	$00003D
	dc	$000043
	dc	$000049
	dc	$00004F
	dc	$000055
	dc	$000061
	dc	$00006D
	dc	$000079
	dc	$000085
	dc	$00009D
	dc	$0000B5
	dc	$0000CD
	dc	$0000E5
	dc	$0000FD
	dc	$000500
	dc	$000500
	dc	$000571
	dc	$000572
	dc	$000780
	dc	$000780
	dc	$800000
	dc	$000000
	dc	$A57D86
	dc	$5A827A
	dc	$89BE51
	dc	$30FBC5
	dc	$CF043B
	dc	$7641AF
	dc	$8275A1
	dc	$18F8B8
	dc	$B8E313
	dc	$6A6D99
	dc	$959267
	dc	$471CED
	dc	$E70748
	dc	$7D8A5F
	dc	$809DC9
	dc	$0C8BD3
	dc	$AECC33
	dc	$62F202
	dc	$8F1D34
	dc	$3C56BA
	dc	$DAD7F4
	dc	$7A7D05
	dc	$8582FB
	dc	$25280C
	dc	$C3A946
	dc	$70E2CC
	dc	$9D0DFE
	dc	$5133CD
	dc	$F3742D
	dc	$7F6237
	dc	$802778
	dc	$0647D9
	dc	$AA0A5B
	dc	$5ED77D
	dc	$8C4A14
	dc	$36BA20
	dc	$D4E0CB
	dc	$788484
	dc	$83D604
	dc	$1F19F9
	dc	$BE31E2
	dc	$6DCA0D
	dc	$99307F
	dc	$4C3FE0
	dc	$ED37F0
	dc	$7E9D56
	dc	$8162AA
	dc	$12C810
	dc	$B3C020
	dc	$66CF81
	dc	$9235F3
	dc	$41CE1E
	dc	$E0E607
	dc	$7C29FC
	dc	$877B7C
	dc	$2B1F35
	dc	$C945E0
	dc	$73B5EC
	dc	$A12883
	dc	$55F5A5
	dc	$F9B827
	dc	$7FD888
	dc	$000000
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000001
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000003
	dc	$000005
	dc	$FFFFFF
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000005
	dc	$FFFFFF
	dc	$000000
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$FFFFFF
	dc	$000000
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000004
	dc	$000005
	dc	$000002
	dc	$000001
	dc	$000002
	dc	$000003
	dc	$000003
	dc	$000004
	dc	$000004
	dc	$000005
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\se_sip.inc ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			se_sip.inc
;												
;   Contents:		Super Exec Configuration Software Interface Protocol (SIP)
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	10/14/2000 10:08:08 AM		jmw
;	Created.
;
;
; ******************************************************************

;**** SuperExec input parameter list equates ****

SE_IN_SIZE			equ		0		; input parameter list size
SE_IN_DO_SURROUND	equ		1		; do Dolby Surround Encoder flag
SE_IN_DO_GAME		equ		2		; do Dolby Game Encoder flag
SE_IN_FSCODE		equ		3		; PCM sampling rate code
SE_IN_ACMODE		equ		4		; input channel configuration
SE_IN_LFE			equ		5		; low frequency effects channel present flag
SE_IN_DIALNORM		equ		6		; dialnorm setting
SE_IN_BW			equ		7		; manual channel bandwidth
SE_IN_LPF			equ		8		; channel LPF enabled flag
SE_IN_LFELPF		equ		9		; LFE LPF flag
SE_IN_HPF			equ		10		; DC HPF flag
SE_IN_DYNRNGE		equ		11		; dynrng exists flag
SE_IN_DYNRNG		equ		12		; AC-3 dynamic range code
SE_IN_COMPRE		equ		13		; compr exists flag
SE_IN_COMPR			equ		14		; AC-3 compression code
SE_IN_SURR_GE		equ		15		; Dolby Surround gain enabled flag
SE_IN_SURR_GAIN		equ		16		; Dolby Surround gain
SE_IN_DSURMOD		equ		17		; Dolby Surround Mode.  Only used for 2/0 Mode

SE_IN_MAX			equ		18		; maximum input parameter list size
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\initlib\dsp\dolby2\asm\nvidia\suprexec.asm ===
; ******************************************************************
;
; 	Unpublished work.  Copyright 2000 Dolby Laboratories Inc.
; 	All Rights Reserved.
;												
;	File:			Suprexec.asm
;												
;   Contents:		Superexec for Dolby Game Encoder
;
;	Author:			jmw
;											
;	Revision:		1.00
;											
;	History:
;
;		Rev 1.00	8/16/2000 3:51:37 PM		jmw
;	Created.
;
;
; ******************************************************************

	page	132,66,3,3
	opt		cre,loc,cc,cex,mex,mu,so

	title	'Dolby Super Exec'

	section	SuperExec

;**** include files ************************************************

	nolist
	include 'ldr_sip.inc'
	include	'se_sip.inc'
	include 'eputil.h'        
	list

;**** Development Switches *****************************************

	IF			@DEF('SIM_XBOX_SYS_MEM') 	
 	DEFINE		TRASH_DSP_MEMORY	   	'1'		; Overwrite DSP memory each block
	ENDIF

;*** Switches (leave defined for X-Box) ****************************

	DEFINE		ERRHALT					'1'		; Halt on loader error	

;**** Development External References ******************************

	IF		@DEF('RTSYS')						; Dolby development HW only
	xref	rt_init,rt_input,rt_output
	ENDIF

	IF		@DEF('SIM_XBOX_SYS_MEM')			; Motorola simulator only
	xref	CopyInFilesToSysMem
	xref	CopySysMemToOutputFiles
	xref	Copy6ChInFileToSysMem
	xref	CopySysMemToAC3OutputFile
	ENDIF

;**** equates ******************************************************

STACK_EXTSZ					equ		32		; stack extension size
CONFIG_SIZE					equ		32		; config data size
SE_NUM_BLOCKS				equ		6		; number of blocks per frame (6)
PMEMSIZE					equ		$001000	; p: is 4k words
YMEMSIZE					equ		$000100	; y: is 256 words
TRASHWORD					equ		$ffffff	; overwrite memory with this word

;*******************************************************************
;	Super Exec sets up stack extension at top of x: RAM.
	
	mode	rel
	org		x(201):					; place stack at top of RAM.

stack_ext	ds	STACK_EXTSZ			; stack extension

;*******************************************************************
; 	Config List from System. Place immediately below stack extension.

	mode	rel
	org		x(204):

config_list		ds	CONFIG_SIZE

;;;;; Note: Interrupt vectors are in ROM on nVidia system
;;;;;*******************************************************************
;;;;;	For now, set up interrupt vectors 
;;;;;	They will be in ROM in the final NVidia silicon.
;;;;
;;;;	mode	rel
;;;;	org		p(200):
;;;;								
;;;;Vectors:
;;;;									 
;;;;	bra		>SuperExec				; hardware reset interrupt vector - jump to start of program
;;;;	 
;;;;	bra		>*						; stack error interrupt vector - halt, stack error
;;;;

;**** code *********************************************************
;	Start Program Code Here.

	mode	rel
	org		p(202):

SuperExec:

	bra		<SEStart				; skip over local variables

;	Local Variables

supexec_blknum		dc		0 			; to sync all functions to same block.
surr_reset			dc		1 			; surround reset flag - init to one (!)
game_reset			dc		1 			; game encoder reset flag - init to one (!)

suprexec_idle_time	dc		0			; idle loop time
suprexec_time       dc      0           ; execution time
suprexec_temp	    dc		0
suprexec_chksum     dc      0



;*******************************************************************
;	Start SuperExec Program Code.  

SEStart:


;	Enable Stack extension.

	movec	#0,sp					; reset the stack pointer
	movec	#stack_ext,ep			; init extension pointer register
	movec	#STACK_EXTSZ,sz			; init stack size register
	bset	#20,omr					; enable stack extension

;	Enable any counters, etc. at reset.
	
	clr		a						; a0 = 0
	move	a0,p:supexec_blknum		; start with block zero at reset
	inc		a						; a0 = 1
	move	a0,p:surr_reset			; explicitly set reset flag
	move	a0,p:game_reset			; explicitly set reset flag

;	Initialize the loader

	move	#>LID_LOADER_INIT,a		; Packet ID
	jsr		LOADERBASE				; Call the Loader
	IF		@DEF('ERRHALT')
	tst		a						; check error status
	bne		<*
	ENDIF

;	Dolby development hardware only (RTSYS)

	IF		@DEF('RTSYS')
	bsr		rt_init					; init real-time hardware
	ENDIF

;	Clear the start frame bit
	EPClearStartFrameBit

	
;*******************************************************************
;	Enter Endless Loop to process each of the four possible Functions
;	in series.	Note that we might not process the function; it depends upon
;	the corresponding flag in the config_list.

;	1. Dolby Surround
;	2. Dolby Game Encoder Function 1
;	3. Dolby Game Encoder Function 2
;	4. Dolby Game Encoder Function 3

SELoop:

; Write the idle bit
	EPSetIdleBit

    move    x:TIMER1_COUNT,a
    move    p:suprexec_temp,x0
    move    a,p:suprexec_temp
    sub     x0,a
    move    a,p:suprexec_time       	


;	Simulate fact that memory is in unknown state

	IF		@DEF('TRASH_DSP_MEMORY')
	bsr		<trashmem
	ENDIF

;	following section is for Dolby development hardware only
;	gui can override config_list parameters 
;	call to rt_input returns a = audio/non-audio flag

	IF		@DEF('RTSYS')
	bsr		rt_input			; get input from real-time hardware
	ENDIF	; @DEF('RTSYS')

;	if block zero, get configuration data from system memory

	move	p:supexec_blknum,a			; get block number
	tst		a #config_list,r0			; is it zero? preload config_list address
	bne		<config_list_loaded			; if not, don't load list

	move	#>LID_CONFIG_LIST,a			; Packet ID
	move	#CONFIG_SIZE,n0				; tell Loader max number of words allowable
	jsr		LOADERBASE					; Call the Loader
	IF		@DEF('ERRHALT')
	tst		a							; check error status
	bne		<*							; stop if loader error
	ENDIF
	
config_list_loaded:

	
waitframe:

	jclr 	#kStartFrameBit,x:INTERRUPT_REGISTER,waitframe

; Clear GP Start Block (bit 1)
	EPClearStartFrameBit	

 
    move    x:TIMER1_COUNT,a
    move    p:suprexec_temp,x0
    move    a,p:suprexec_temp
    sub     x0,a
    move    a,p:suprexec_idle_time       	

;-------------------------------------------------------------------
;	1. Check if we're supposed to do Dolby Surround. If not, skip it.
;-------------------------------------------------------------------

SEDS:

	move	x:config_list+SE_IN_DO_SURROUND,a	; get DO_SURROUND flag
	tst		a #DOLBYEXECBASE,r0					; is zero? preload DSP memory address
	beq		<SEDSDone							; if so, bypass Surround

;	Load Program Code for Dolby Surround

SEDSLdP:

	move	#>LID_PROG_DSURRE,a						; Packet ID
	jsr		LOADERBASE								; Call the Loader
	IF		@DEF('ERRHALT')
	tst		a										; check error status
	bne		<*										; stop if loader error
	ENDIF

	IF		@DEF('SIM_XBOX_SYS_MEM')

;	Copy inputs to System memory (Simulator Only - NVIDIA: Remove this call!)

SECopyIn:

	jsr		<CopyInFilesToSysMem

	ENDIF	; @DEF('SIM_XBOX_SYS_MEM')


	;	Run Program Code for Dolby Surround

SEDSjsr:
	
	move	p:surr_reset,b							; get surround reset word
	move	#config_list,r0							; pass pointer to configuration data (in x:)
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of Dolby Surround Exec (skip header)
	   
;	clear surround reset word

	move	#0,x0
	move	x0,p:surr_reset


	IF		@DEF('SIM_XBOX_SYS_MEM')

;	copy System Memory to output files (Simulator Only - NVIDIA: Remove this call!)

SECopyOut:

	jsr		<CopySysMemToOutputFiles

	ENDIF	; @DEF('SIM_XBOX_SYS_MEM')

; All Done with Dolby Surround.

SEDSDone:

;-------------------------------------------------------------------
;	2. Check if we're supposed to do Game Encoder. If not, skip it.
;-------------------------------------------------------------------

SEF1:

	move	x:config_list+SE_IN_DO_GAME,a	; get DO_GAME flag
	tst		a #DOLBYEXECBASE,r0				; is it zero? preload DSP memory address
	beq		<SEF3Done						; if so, bypass Game Encoder
	
;	Load Program Code for Function 1

SEF1LdP:

	move	#>LID_PROG_DGAME1,a						; Packet ID
	jsr		LOADERBASE								; Call the Loader
	IF		@DEF('ERRHALT')
	tst		a										; check error status
	bne		<*										; stop if loader error
	ENDIF


	IF		@DEF('SIM_XBOX_SYS_MEM')

;	Copy inputs to System memory (Simulator Only - NVIDIA: Remove this call!)

	jsr		Copy6ChInFileToSysMem

	ENDIF	; @DEF('SIM_XBOX_SYS_MEM')


;	Run Program Code for Function 1

SEF1jsr:


	
	move	#config_list,r0							; set up config list pointer
	move	p:game_reset,b							; get Game Encoder reset word
	move	p:supexec_blknum,x0						; set up x0 with current block number
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of GE Function 1 (skip past header)



; 	All Done with Function 1.

SEF1Done:

;-------------------------------------------------------------------
;	Game Encoder Fcn 2.
;-------------------------------------------------------------------

SEF2:

;	Load Program Code for Function 2

SEF2LdP:

	move	#DOLBYEXECBASE,r0						; r0 is DSP memory address
	move	#>LID_PROG_DGAME2,a						; Packet ID
	jsr		LOADERBASE								; Call the Loader
	IF		@DEF('ERRHALT')
	tst		a										; check error status
	bne		<*										; stop if loader error
	ENDIF


;	Run Program Code for Function 2

SEF2jsr:
	
	move	p:game_reset,b							; get Game Encoder reset word
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of GE Function 2 (skip past header)

; 	All Done with Function 2.

SEF2Done:

;-------------------------------------------------------------------
;	Game Encoder Fcn 3.
;-------------------------------------------------------------------

SEF3:
	
;	Load Program Code for Function 3 Executive

SEF3LdP:

	move	#DOLBYEXECBASE,r0						; r0 is DSP memory address
	move	#>LID_PROG_DGAME3,a						; Packet ID
	jsr		LOADERBASE								; Call the Loader
	IF		@DEF('ERRHALT')
	tst		a										; check error status
	bne		<*										; stop if loader error
	ENDIF


;	Run Program Code for Function 3

SEF3jsr:
	
	move	p:game_reset,b							; get Game Encoder reset word
	move	p:supexec_blknum,x0						; set up x0 with current block number (need for output)
	jsr		DOLBYEXECBASE+LDR_HDR_SIZE				; jsr to Entry Point of GE Function 3 (skip past header)

;	clear Game Encoder reset word

	move	#0,x0
	move	x0,p:game_reset

	IF		@DEF('SIM_XBOX_SYS_MEM')

;	Write Outputs (for Motorola Simulator only) at the end of block 5
;	NVIDIA - remove this call!

SEWriteAC3:

	move	p:supexec_blknum,a
	cmp		#SE_NUM_BLOCKS-1,a
	bseq	<CopySysMemToAC3OutputFile

	ENDIF	; @DEF('SIM_XBOX_SYS_MEM') 

; 	All Done with Function 3.

SEF3Done:

	IF		@DEF('RTSYS')

;	Dolby development hardware only (RTSYS)

	move	x:config_list+SE_IN_DO_GAME,a
	move	p:supexec_blknum,x0	; set up x0 with current block number
	bsr		rt_output			; send output to real-time hardware

	ENDIF	; @DEF('RTSYS')

;-------------------------------------------------------------------
; 	Increment Block Number, and wrap if necessary.

SEBlkAdj:

	move	p:supexec_blknum,a
	add		#1,a
	cmp		#SE_NUM_BLOCKS,a
	clr		a ifge
	move	a1,p:supexec_blknum

;	Loop


;	Increment the ping-pong for pcm input

	move	#>LID_PING_PONG,a						; Packet ID
	jsr		LOADERBASE								; Call the Loader


	bra		<SELoop
	

	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


	IF		@DEF('TRASH_DSP_MEMORY')

;*******************************************************************
;*
;*	Subroutine Name:	trashmem
;*																								
;*  Description:		trashes DSP memory as an acid test
;*
;*	Input:
;*											
;*	Output:
;*											
;*	Modifies:
;*
;*	Locals:
;*
;*	Stack Space Used:
;*
;*******************************************************************

trashmem:

;	Overwrite p: DSP memory from DOLBYEXECBASE to top of p: space.

trashp:

	move	#>DOLBYEXECBASE,x0		; get base of Dolby functions
	move	x0,r0					; save as start address
	move	#>PMEMSIZE,a			; get size of p:
	sub		x0,a					; compute size of Dolby Fcn space
	move	a,n0					; and trash this many locations
	move	#>TRASHWORD,a			; overwrite word

	dor		n0,trashplp
		move a,p:(r0)+
trashplp:

;	Overwrite y: DSP memory from $0 to top of y: space

trashy:

	move	#YMEMSIZE,n0				; trash all of y:
	move	#0,r0						; start at zero
	
	dor		n0,trashylp
		move	a,y:(r0)+			
trashylp:		

;	Overwrite x: DSP memory from $0 to
;	to bottom of stack extension
;	(stack extension is located at top of x:)

trashx:

	move	#CONFIGBASE,n0		; trash everything in x: below config	
	move	#0,r0				; start at zero
	
	dor		n0,trashxlp
		move	a,x:(r0)+	
trashxlp:		

	rts

	ENDIF	; @DEF('TRASH_DSP_MEMORY')


;*******************************************************************
	endsec		; SuperExec

	end			; end of file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\adpcm.h ===
#pragma once

typedef enum
{
    WAVEBANK_ADPCM_8K4BM = 0,
    WAVEBANK_ADPCM_8K4BS = 1,
    WAVEBANK_ADPCM_11K4BM = 2,
    WAVEBANK_ADPCM_11K4BS = 3,
    WAVEBANK_ADPCM_16K4BM = 4,
    WAVEBANK_ADPCM_16K4BS = 5,
    WAVEBANK_ADPCM_22K4BM = 6,
    WAVEBANK_ADPCM_22K4BS = 7,
    WAVEBANK_ADPCM_24K4BM = 8,
    WAVEBANK_ADPCM_32K4BM = 9,
    WAVEBANK_ADPCM_32K4BS = 10,
    WAVEBANK_ADPCM_44K4BM = 11,
    WAVEBANK_ADPCM_44K4BS = 12,
    WAVEBANK_ADPCM_48K4BS = 13,
    WAVEBANK_ADPCM_48K4BM = 14,
} WAVEBANK_ADPCM;

#define WAVEBANK_ADPCM_ENTRY_COUNT 15
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\8bit.h ===
#pragma once

typedef enum
{
    WAVEBANK_8BIT_8K16BM = 0,
    WAVEBANK_8BIT_8K16BS = 1,
    WAVEBANK_8BIT_11K16BM = 2,
    WAVEBANK_8BIT_11K16BS = 3,
    WAVEBANK_8BIT_16K16BM = 4,
    WAVEBANK_8BIT_16K16BS = 5,
    WAVEBANK_8BIT_22K8BM = 6,
    WAVEBANK_8BIT_22K16BM = 7,
    WAVEBANK_8BIT_22K16BS = 8,
    WAVEBANK_8BIT_24K16BM = 9,
    WAVEBANK_8BIT_32K16BM = 10,
    WAVEBANK_8BIT_32K16BS = 11,
    WAVEBANK_8BIT_44K16BM = 12,
    WAVEBANK_8BIT_44K16BS = 13,
    WAVEBANK_8BIT_48K16BM = 14,
    WAVEBANK_8BIT_48K16BS = 15,
} WAVEBANK_8BIT;

#define WAVEBANK_8BIT_ENTRY_COUNT 16
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\compress.h ===
#pragma once

typedef enum
{
    WAVEBANK_COMPRESS_8K16BM = 0,
    WAVEBANK_COMPRESS_8K16BS = 1,
    WAVEBANK_COMPRESS_11K16BM = 2,
    WAVEBANK_COMPRESS_11K16BS = 3,
    WAVEBANK_COMPRESS_16K16BM = 4,
    WAVEBANK_COMPRESS_16K16BS = 5,
    WAVEBANK_COMPRESS_22K8BM = 6,
    WAVEBANK_COMPRESS_22K16BM = 7,
    WAVEBANK_COMPRESS_22K16BS = 8,
    WAVEBANK_COMPRESS_24K16BM = 9,
    WAVEBANK_COMPRESS_32K16BM = 10,
    WAVEBANK_COMPRESS_32K16BS = 11,
    WAVEBANK_COMPRESS_44K16BM = 12,
    WAVEBANK_COMPRESS_44K16BS = 13,
    WAVEBANK_COMPRESS_48K16BS = 14,
    WAVEBANK_COMPRESS_48K16BM = 15,
} WAVEBANK_COMPRESS;

#define WAVEBANK_COMPRESS_ENTRY_COUNT 16
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\lnktest.c ===
#include "lnktest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\lnktest.h ===
#include <xtl.h>

#ifdef __cplusplus
#define REF_GUID_NULL GUID_NULL
#else // __cplusplus
#define REF_GUID_NULL 0
#endif // __cplusplus

static void
LinkTest
(
    void
)
{
    DirectSoundCreate(0, 0, 0);
    DirectSoundCreateBuffer(0, 0);
    DirectSoundCreateStream(0, 0);
    DirectSoundDoWork();
    DirectSoundUseFullHRTF();
    DirectSoundUseLightHRTF();
    DirectSoundUsePan3D();
    DirectSoundOverrideSpeakerConfig(0);
    DirectSoundGetSampleTime();
    DirectSoundDumpMemoryUsage(0);
    XAudioCreatePcmFormat(0, 0, 0, 0);
    XAudioCreateAdpcmFormat(0, 0, 0);
    XAudioCalculatePitch(0);
    WmaCreateDecoder(0, 0, 0, 0, 0, 0, 0, 0);
    WmaCreateInMemoryDecoder(0, 0, 0, 0, 0);
    WmaCreateDecoderEx(0, 0, 0, 0, 0, 0, 0, 0);
    WmaCreateInMemoryDecoderEx(0, 0, 0, 0, 0);
    Ac97CreateMediaObject(0, 0, 0, 0);
    XFileCreateMediaObject(0, 0, 0, 0, 0, 0);
    XFileCreateMediaObjectEx(0, 0);
    XWaveFileCreateMediaObject(0, 0, 0);
    XWaveFileCreateMediaObjectEx(0, 0, 0);
    XAudioDownloadEffectsImage(0, 0, 0, 0);
    IDirectSound_QueryInterface(0, REF_GUID_NULL, 0);
    IDirectSound_AddRef(0);
    IDirectSound_Release(0);
    IDirectSound_GetCaps(0, 0);
    IDirectSound_CreateSoundBuffer(0, 0, 0, 0);
    IDirectSound_CreateSoundStream(0, 0, 0, 0);
    IDirectSound_GetSpeakerConfig(0, 0);
    IDirectSound_SetCooperativeLevel(0, 0, 0);
    IDirectSound_Compact(0);
    IDirectSound_DownloadEffectsImage(0, 0, 0, 0, 0);
    IDirectSound_SetEffectData(0, 0, 0, 0, 0, 0);
    IDirectSound_CommitEffectData(0);
    IDirectSound_EnableHeadphones(0, 0);
    IDirectSound_SetMixBinHeadroom(0, 0, 0);
    IDirectSound_SetAllParameters(0, 0, 0);
    IDirectSound_SetDistanceFactor(0, 0, 0);
    IDirectSound_SetDopplerFactor(0, 0, 0);
    IDirectSound_SetOrientation(0, 0, 0, 0, 0, 0, 0, 0);
    IDirectSound_SetPosition(0, 0, 0, 0, 0);
    IDirectSound_SetRolloffFactor(0, 0, 0);
    IDirectSound_SetVelocity(0, 0, 0, 0, 0);
    IDirectSound_SetI3DL2Listener(0, 0, 0);
    IDirectSound_CommitDeferredSettings(0);
    IDirectSound_GetTime(0, 0);
    IDirectSoundBuffer_QueryInterface(0, REF_GUID_NULL, 0);
    IDirectSoundBuffer_AddRef(0);
    IDirectSoundBuffer_Release(0);
    IDirectSoundBuffer_SetFrequency(0, 0);
    IDirectSoundBuffer_SetVolume(0, 0);
    IDirectSoundBuffer_SetPitch(0, 0);
    IDirectSoundBuffer_SetLFO(0, 0);
    IDirectSoundBuffer_SetEG(0, 0);
    IDirectSoundBuffer_SetFilter(0, 0);
    IDirectSoundBuffer_SetOutputBuffer(0, 0);
    IDirectSoundBuffer_SetMixBins(0, 0);
    IDirectSoundBuffer_SetMixBinVolumes(0, 0);
    IDirectSoundBuffer_SetAllParameters(0, 0, 0);
    IDirectSoundBuffer_SetConeAngles(0, 0, 0, 0);
    IDirectSoundBuffer_SetConeOrientation(0, 0, 0, 0, 0);
    IDirectSoundBuffer_SetConeOutsideVolume(0, 0, 0);
    IDirectSoundBuffer_SetMaxDistance(0, 0, 0);
    IDirectSoundBuffer_SetMinDistance(0, 0, 0);
    IDirectSoundBuffer_SetMode(0, 0, 0);
    IDirectSoundBuffer_SetPosition(0, 0, 0, 0, 0);
    IDirectSoundBuffer_SetVelocity(0, 0, 0, 0, 0);
    IDirectSoundBuffer_SetRolloffFactor(0, 0, 0);
    IDirectSoundBuffer_SetRolloffCurve(0, 0, 0, 0);
    IDirectSoundBuffer_SetI3DL2Source(0, 0, 0);
    IDirectSoundBuffer_Play(0, 0, 0, 0);
    IDirectSoundBuffer_PlayEx(0, 0, 0);
    IDirectSoundBuffer_Stop(0);
    IDirectSoundBuffer_StopEx(0, 0, 0);
    IDirectSoundBuffer_SetPlayRegion(0, 0, 0);
    IDirectSoundBuffer_SetLoopRegion(0, 0, 0);
    IDirectSoundBuffer_GetStatus(0, 0);
    IDirectSoundBuffer_GetCurrentPosition(0, 0, 0);
    IDirectSoundBuffer_SetCurrentPosition(0, 0);
    IDirectSoundBuffer_SetBufferData(0, 0, 0);
    IDirectSoundBuffer_Lock(0, 0, 0, 0, 0, 0, 0, 0);
    IDirectSoundBuffer_Unlock(0, 0, 0, 0, 0);
    IDirectSoundBuffer_Restore(0);
    IDirectSoundBuffer_SetNotificationPositions(0, 0, 0);
    IDirectSoundStream_QueryInterface(0, REF_GUID_NULL, 0);
    IDirectSoundStream_AddRef(((LPDIRECTSOUNDSTREAM)0));
    IDirectSoundStream_Release(((LPDIRECTSOUNDSTREAM)0));
    IDirectSoundStream_GetInfo(((LPDIRECTSOUNDSTREAM)0), 0);
    IDirectSoundStream_GetStatus(((LPDIRECTSOUNDSTREAM)0), 0);
    IDirectSoundStream_Process(((LPDIRECTSOUNDSTREAM)0), 0, 0);
    IDirectSoundStream_Discontinuity(((LPDIRECTSOUNDSTREAM)0));
    IDirectSoundStream_Flush(((LPDIRECTSOUNDSTREAM)0));
    IDirectSoundStream_SetFrequency(0, 0);
    IDirectSoundStream_SetVolume(0, 0);
    IDirectSoundStream_SetPitch(0, 0);
    IDirectSoundStream_SetLFO(0, 0);
    IDirectSoundStream_SetEG(0, 0);
    IDirectSoundStream_SetFilter(0, 0);
    IDirectSoundStream_SetOutputBuffer(0, 0);
    IDirectSoundStream_SetMixBins(0, 0);
    IDirectSoundStream_SetMixBinVolumes(0, 0);
    IDirectSoundStream_SetAllParameters(0, 0, 0);
    IDirectSoundStream_SetConeAngles(0, 0, 0, 0);
    IDirectSoundStream_SetConeOrientation(0, 0, 0, 0, 0);
    IDirectSoundStream_SetConeOutsideVolume(0, 0, 0);
    IDirectSoundStream_SetMaxDistance(0, 0, 0);
    IDirectSoundStream_SetMinDistance(0, 0, 0);
    IDirectSoundStream_SetMode(0, 0, 0);
    IDirectSoundStream_SetPosition(0, 0, 0, 0, 0);
    IDirectSoundStream_SetVelocity(0, 0, 0, 0, 0);
    IDirectSoundStream_SetRolloffFactor(0, 0, 0);
    IDirectSoundStream_SetRolloffCurve(0, 0, 0, 0);
    IDirectSoundStream_SetI3DL2Source(0, 0, 0);
    IDirectSoundStream_Pause(0, 0);
    IDirectSoundStream_FlushEx(0, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\loop.h ===
#pragma once

typedef enum
{
    WAVEBANK_LOOP_WAVCTLOOPED_0_3_1R = 0,
    WAVEBANK_LOOP_WAVCTLOOPED_0_6_1R = 1,
    WAVEBANK_LOOP_WAVCTLOOPED_1_5_1R = 2,
    WAVEBANK_LOOP_WAVCTLOOPED_3_6_1R = 3,
    WAVEBANK_LOOP_SHOOT = 4,
    WAVEBANK_LOOP_DIALOG = 5,
    WAVEBANK_LOOP_EXPLO1 = 6,
    WAVEBANK_LOOP_LOOP_EMBEDDED = 7,
    WAVEBANK_LOOP_LOOP_ENDTOEND = 8,
    WAVEBANK_LOOP_MUSLOOP = 9,
} WAVEBANK_LOOP;

#define WAVEBANK_LOOP_ENTRY_COUNT 10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\lnktest2.cpp ===
#include "lnktest.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\pcm.h ===
#pragma once

typedef enum
{
    WAVEBANK_PCM_8K8BM = 0,
    WAVEBANK_PCM_8K8BS = 1,
    WAVEBANK_PCM_8K16BM = 2,
    WAVEBANK_PCM_8K16BS = 3,
    WAVEBANK_PCM_11K8BM = 4,
    WAVEBANK_PCM_11K8BS = 5,
    WAVEBANK_PCM_11K16BM = 6,
    WAVEBANK_PCM_11K16BS = 7,
    WAVEBANK_PCM_16K8BM = 8,
    WAVEBANK_PCM_16K8BS = 9,
    WAVEBANK_PCM_16K16BM = 10,
    WAVEBANK_PCM_16K16BS = 11,
    WAVEBANK_PCM_22K8BM = 12,
    WAVEBANK_PCM_22K8BS = 13,
    WAVEBANK_PCM_22K16BM = 14,
    WAVEBANK_PCM_22K16BS = 15,
    WAVEBANK_PCM_24K16BM = 16,
    WAVEBANK_PCM_32K8BM = 17,
    WAVEBANK_PCM_32K8BS = 18,
    WAVEBANK_PCM_32K16BM = 19,
    WAVEBANK_PCM_32K16BS = 20,
    WAVEBANK_PCM_44K8BM = 21,
    WAVEBANK_PCM_44K8BS = 22,
    WAVEBANK_PCM_44K16BM = 23,
    WAVEBANK_PCM_44K16BS = 24,
    WAVEBANK_PCM_48K16BS = 25,
    WAVEBANK_PCM_48K8BM = 26,
    WAVEBANK_PCM_48K8BS = 27,
    WAVEBANK_PCM_48K16BM = 28,
} WAVEBANK_PCM;

#define WAVEBANK_PCM_ENTRY_COUNT 29
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\makefile.inc ===
bank: res.sbp
    ..\tools\wavbndlr\console\obj\i386\wavbndlr$(D).exe /fl res.sbp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\pcmaiff.h ===
#pragma once

typedef enum
{
    WAVEBANK_PCMAIFF_8K8BM = 0,
    WAVEBANK_PCMAIFF_8K8BS = 1,
    WAVEBANK_PCMAIFF_8K16BM = 2,
    WAVEBANK_PCMAIFF_8K16BS = 3,
    WAVEBANK_PCMAIFF_11K8BM = 4,
    WAVEBANK_PCMAIFF_11K8BS = 5,
    WAVEBANK_PCMAIFF_11K16BM = 6,
    WAVEBANK_PCMAIFF_11K16BS = 7,
    WAVEBANK_PCMAIFF_16K8BM = 8,
    WAVEBANK_PCMAIFF_16K8BS = 9,
    WAVEBANK_PCMAIFF_16K16BM = 10,
    WAVEBANK_PCMAIFF_16K16BS = 11,
    WAVEBANK_PCMAIFF_22K8BM = 12,
    WAVEBANK_PCMAIFF_22K8BS = 13,
    WAVEBANK_PCMAIFF_22K16BM = 14,
    WAVEBANK_PCMAIFF_22K16BS = 15,
    WAVEBANK_PCMAIFF_24K16BM = 16,
    WAVEBANK_PCMAIFF_32K8BM = 17,
    WAVEBANK_PCMAIFF_32K8BS = 18,
    WAVEBANK_PCMAIFF_32K16BM = 19,
    WAVEBANK_PCMAIFF_32K16BS = 20,
    WAVEBANK_PCMAIFF_44K8BM = 21,
    WAVEBANK_PCMAIFF_44K8BS = 22,
    WAVEBANK_PCMAIFF_44K16BM = 23,
    WAVEBANK_PCMAIFF_44K16BS = 24,
    WAVEBANK_PCMAIFF_48K16BS = 25,
    WAVEBANK_PCMAIFF_48K8BM = 26,
    WAVEBANK_PCMAIFF_48K8BS = 27,
    WAVEBANK_PCMAIFF_48K16BM = 28,
} WAVEBANK_PCMAIFF;

#define WAVEBANK_PCMAIFF_ENTRY_COUNT 29
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\mixed.h ===
#pragma once

typedef enum
{
    WAVEBANK_MIXED_8K8BM = 0,
    WAVEBANK_MIXED_8K8BS = 1,
    WAVEBANK_MIXED_8K16BM = 2,
    WAVEBANK_MIXED_8K16BS = 3,
    WAVEBANK_MIXED_11K8BM = 4,
    WAVEBANK_MIXED_11K8BS = 5,
    WAVEBANK_MIXED_11K16BM = 6,
    WAVEBANK_MIXED_11K16BS = 7,
    WAVEBANK_MIXED_16K8BM = 8,
    WAVEBANK_MIXED_16K8BS = 9,
    WAVEBANK_MIXED_16K16BM = 10,
    WAVEBANK_MIXED_16K16BS = 11,
    WAVEBANK_MIXED_22K8BM = 12,
    WAVEBANK_MIXED_22K8BS = 13,
    WAVEBANK_MIXED_22K16BM = 14,
    WAVEBANK_MIXED_22K16BS = 15,
    WAVEBANK_MIXED_24K16BM = 16,
    WAVEBANK_MIXED_32K8BM = 17,
    WAVEBANK_MIXED_32K8BS = 18,
    WAVEBANK_MIXED_32K16BM = 19,
    WAVEBANK_MIXED_32K16BS = 20,
    WAVEBANK_MIXED_44K8BM = 21,
    WAVEBANK_MIXED_44K8BS = 22,
    WAVEBANK_MIXED_44K16BM = 23,
    WAVEBANK_MIXED_44K16BS = 24,
    WAVEBANK_MIXED_48K8BM = 25,
    WAVEBANK_MIXED_48K8BS = 26,
    WAVEBANK_MIXED_48K16BM = 27,
    WAVEBANK_MIXED_48K16BS = 28,
} WAVEBANK_MIXED;

#define WAVEBANK_MIXED_ENTRY_COUNT 29
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\main.c ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       main.c
 *  Content:    Application entry point.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/07/01    dereks  Created.
 *
 ****************************************************************************/

#include "testds.h"

BOOL fTestMe = FALSE;
BOOL fBreakTest = FALSE;


/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "main"

void __cdecl
main
(
    void
)
{
    HRESULT                 hr;
    
    while(TRUE)
    {
        hr = DS_OK;

#ifdef STALL_ON_START

        fTestMe = FALSE;

        DPF_TEST("");
        DPF_TEST("******************************************************************************");
        DPF_TEST("");
        DPF_TEST("Enter the following into the debugger in order to start testing:");
        DPF_TEST("ed testds!fTestMe 1;g");
        DPF_TEST("");
        DPF_TEST("******************************************************************************");
        DPF_TEST("");

        while(!fTestMe);

#elif defined(BREAK_ON_START)

        __asm int 3

#endif // STALL_ON_START

        fBreakTest = FALSE;

        if(SUCCEEDED(hr)) hr = TestDirectSound();
        // if(SUCCEEDED(hr)) hr = TestAc97Xmo(DSAC97_CHANNEL_ANALOG, DSAC97_MODE_PCM);
        // if(SUCCEEDED(hr)) hr = TestAc97Xmo(DSAC97_CHANNEL_DIGITAL, DSAC97_MODE_PCM);
        // if(SUCCEEDED(hr)) hr = TestAc97Xmo(DSAC97_CHANNEL_DIGITAL, DSAC97_MODE_ENCODED);
        // if(SUCCEEDED(hr)) hr = TestMemoryUsage();

        if(SUCCEEDED(hr))
        {
            DPF_TEST("Test successful");
        }
        else
        {
            DPF_TEST("Test failed");
        }

        DirectSoundDumpMemoryUsage(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\testac97.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       testac97.cpp
 *  Content:    AC97 XMO tests.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/07/01    dereks  Created.
 *
 ****************************************************************************/

#include "testds.h"


/****************************************************************************
 *
 *  TestAc97XmoCallback
 *
 *  Description:
 *      Callback function for TestAc97Xmo.
 *
 *  Arguments:
 *      LPVOID [in]: stream context.
 *      LPVOID [in]: packet context.
 *      DWORD [in]: packet status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestAc97XmoCallback"

void CALLBACK
TestAc97XmoCallback
(
    LPVOID                  pvStreamContext,
    LPVOID                  pvPacketContext,
    DWORD                   dwStatus
)
{
    LPDWORD                 pdwSubmittedMask    = (LPDWORD)pvStreamContext;
    DWORD                   dwPacketIndex       = (DWORD)pvPacketContext;

    *pdwSubmittedMask &= ~(1UL << dwPacketIndex);
}    


/****************************************************************************
 *
 *  TestAc97Xmo
 *
 *  Description:
 *      Tests the AC97 XMO.
 *
 *  Arguments:
 *      DWORD [in]: channel index.
 *      DWORD [in]: channel mode.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestAc97XmoCallback"

HRESULT
TestAc97Xmo
(
    DWORD                   dwChannel,
    DWORD                   dwMode
)
{
    static const DWORD      dwPacketSize        = 0x1000;
    XAc97MediaObject *      pDevice             = NULL;
    XFileMediaObject *      pWaveFile           = NULL;
    LPVOID                  pvBufferData        = NULL;
    volatile DWORD          dwSubmittedMask     = 0;
    DWORD                   dwSubmittedSize     = 0;
    XMEDIAPACKET            xmp;
    DWORD                   dwRead;
    DWORD                   dwPosition;
    DWORD                   i;
    HRESULT                 hr;

    hr = ValidateResult(Ac97CreateMediaObject(dwChannel, TestAc97XmoCallback, (LPVOID)&dwSubmittedMask, &pDevice));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pDevice->SetMode(dwMode));
    }

    if(SUCCEEDED(hr))
    {
        if(DSAC97_MODE_ENCODED == dwMode)
        {
            hr = ValidateResult(OpenWaveFile("t:\\media\\audio\\ac3\\dd-broadway.wav", NULL, &pWaveFile));
        }
        else
        {
            hr = ValidateResult(OpenStdWaveFile(CreateFormat(WAVE_FORMAT_PCM, 48000, 16, 2), &pWaveFile));
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidatePtr(pvBufferData = XPhysicalAlloc(dwPacketSize * DSAC97_MAX_ATTACHED_PACKETS, ~0UL, PAGE_SIZE, PAGE_READWRITE));
    }

    while(SUCCEEDED(hr))
    {
        while(((1UL << DSAC97_MAX_ATTACHED_PACKETS) - 1) == dwSubmittedMask);

        for(i = 0; i < DSAC97_MAX_ATTACHED_PACKETS; i++)
        {
            if(!(dwSubmittedMask & (1UL << i)))
            {
                break;
            }
        }

        ASSERT(i < DSAC97_MAX_ATTACHED_PACKETS);

        xmp.pvBuffer = (LPBYTE)pvBufferData + (dwPacketSize * i);
        xmp.dwMaxSize = dwPacketSize;
        xmp.pdwCompletedSize = &dwRead;
        xmp.pdwStatus = NULL;
        xmp.pContext = NULL;
        xmp.prtTimestamp = NULL;

        hr = ValidateResult(pWaveFile->Process(NULL, &xmp));

        if(SUCCEEDED(hr))
        {
            if(dwRead)
            {
                dwSubmittedMask |= 1UL << i;

                xmp.dwMaxSize = dwRead;
                xmp.pdwCompletedSize = NULL;
                xmp.pContext = (LPVOID)i;

                dwSubmittedSize += dwRead;

                hr = ValidateResult(pDevice->Process(&xmp, NULL));

                if(SUCCEEDED(hr))
                {
                    hr = ValidateResult(pDevice->Discontinuity());
                }

                if(SUCCEEDED(hr))
                {
                    hr = pDevice->GetCurrentPosition(&dwPosition);
                }

                if(SUCCEEDED(hr))
                {
                    DPF_TEST("submitted %lu, position %lu", dwSubmittedSize, dwPosition);
                }
            }
            else
            {
                while(dwSubmittedMask);

                hr = pDevice->GetCurrentPosition(&dwPosition);

                if(SUCCEEDED(hr))
                {
                    DPF_TEST("FINAL: submitted %lu, position %lu", dwSubmittedSize, dwPosition);
                }

                break;
            }
        }
    }

    if(pvBufferData)
    {
        XPhysicalFree(pvBufferData);
    }

    RELEASE(pWaveFile);
    RELEASE(pDevice);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\testds.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       testds.h
 *  Content:    Main header.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/07/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __TESTDS_H__
#define __TESTDS_H__

// #define STALL_ON_START
#define BREAK_ON_START
// #define ALLOC_ALIGNED
#define ALLOC_CONTIGUOUS
// #define ALLOC_NOCACHE
// #define ALLOC_GUARD_PAGE

#define BEGIN_TEST(name) \
    if(SUCCEEDED(hr)) DPF_TEST("*** Starting " #name " ***"), hr = name

#include <dsoundi.h>
#include <dsstdfx.h>
#include <wavbndli.h>
#include "util.h"

static void __cdecl DPF_TEST(LPCSTR pszFormat, ...)
{
    CHAR                    szString[0x100];
    va_list                 va;

    va_start(va, pszFormat);
    vsprintf(szString, pszFormat, va);
    va_end(va);

    OutputDebugStringA("TESTDS: ");
    OutputDebugStringA(szString);
    OutputDebugStringA("\n");
}

//
// Global variables
//

EXTERN_C BOOL fTestMe;
EXTERN_C BOOL fBreakTest;

//
// Main DirectSound test function
//

EXTERN_C HRESULT TestDirectSound(void);

//
// DirectSoundCreate stress test
//

EXTERN_C HRESULT TestDirectSoundCreate(void);

//
// AC97 XMO tests
//

EXTERN_C HRESULT TestAc97Xmo(DWORD dwChannel, DWORD dwMode);

//
// Memory usage tests
//

EXTERN_C HRESULT TestMemoryUsage(void);

#endif // __TESTDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\util.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       util.h
 *  Content:    DirectSound utility functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/07/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __UTIL_H__
#define __UTIL_H__

//
// Data structures
//

BEGIN_DEFINE_UNION()
    WAVEFORMATEX        wfx;
    XBOXADPCMWAVEFORMAT wfAdpcm;
END_DEFINE_UNION(UNIWAVEFORMAT);

//
// Return code validation
//

__inline HRESULT ValidateResult(HRESULT hr)
{
    if(FAILED(hr))
    {
        __asm int 3;
    }

    return hr;
}

__inline HRESULT ValidatePtr(LPVOID pv)
{
    if(!pv)
    {
        __asm int 3;
    }

    return pv ? DS_OK : DSERR_OUTOFMEMORY;
}

//
// Memory management
//

LPVOID __MALLOC(DWORD dwSize);
VOID __FREE(LPVOID *ppv);

#define MALLOC(p, type, count) \
    ValidatePtr((p) = (type *)__MALLOC(sizeof(type) * (count)))

#define FREE(p) \
    __FREE((LPVOID *)&(p))

#ifdef __cplusplus

//
// XMO helpers
//

HRESULT
ReadXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwRead
);

HRESULT
WriteXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwWritten
);

HRESULT
TransformXMO
(
    XMediaObject *          pMediaObject,
    LPCVOID                 pvSource,
    DWORD                   dwSourceSize,
    LPDWORD                 pdwRead,
    LPVOID                  pvDest,
    DWORD                   dwDestSize,
    LPDWORD                 pdwWritten
);

//
// Wave files
//

HRESULT
OpenWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    XFileMediaObject **     ppMediaObject
);

HRESULT
LoadWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    LPVOID *                ppvBuffer,
    LPDWORD                 pdwBufferSize,
    XFileMediaObject **     ppMediaObject
);

void
GetStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    LPSTR                   pszFileName
);

LPCSTR
GetStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat
);

HRESULT
OpenStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    XFileMediaObject **     ppMediaObject
);

HRESULT
LoadStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    LPVOID *                ppvBuffer,
    LPDWORD                 pdwBufferSize,
    XFileMediaObject **     ppMediaObject
);

//
// Buffer creation
//

HRESULT
CreateBufferFromFile
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags, 
    LPCDSMIXBINS            pMixBins, 
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDBUFFER *   ppBuffer, 
    LPDWORD                 pdwBufferBytes  = NULL
);

HRESULT
CreateStdBuffer
(
    DWORD                   dwFlags, 
    LPCWAVEFORMATEX         pwfxFormat, 
    LPCDSMIXBINS            pMixBins, 
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDBUFFER *   ppBuffer        = NULL, 
    LPDWORD                 pdwBufferBytes  = NULL
);

HRESULT
CreateToneBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwToneFrequency,
    DWORD                   dwBufferBytes,
    LPCDSMIXBINS            pMixBins, 
    LPDIRECTSOUNDBUFFER *   ppBuffer
);

HRESULT
CreateImpulseBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPeriodDivisor,
    DWORD                   dwLeadIn,
    DWORD                   dwRollOff,
    LPCDSMIXBINS            pMixBins, 
    LPDIRECTSOUNDBUFFER *   ppBuffer
);

//
// Buffer utilities
//

HRESULT
WaitBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    BOOL                    fPlaying
);

HRESULT
PlayBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    DWORD                   dwFlags     = 0,
    DWORD                   dwDelay     = 0,
    BOOL                    fWait       = FALSE
);

HRESULT
PlayBufferToCompletion
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    DWORD                   dwFlags     = 0,
    DWORD                   dwDelay     = 0
);

HRESULT
StopBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    DWORD                   dwFlags     = 0,
    DWORD                   dwDelay     = 0,
    BOOL                    fReset      = FALSE,
    BOOL                    fWait       = FALSE
);

HRESULT
GetFreeSGEs
(
    LPDWORD                 pdwFreeSGEs
);

HRESULT
ClampBufferSize
(
    LPDWORD                 pdwBufferBytes
);

//
// Stream creation
//

HRESULT
CreateStreamFromFile
(
    LPCSTR                      pszFile, 
    DWORD                       dwFlags, 
    LPCDSMIXBINS                pMixBins, 
    LPDWORD                     pdwPacketSize,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback,
    LPVOID                      pvContext,
    LPDIRECTSOUNDBUFFER         pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *       ppStream, 
    LPVOID *                    ppvAudioData,
    LPDWORD                     pdwAudioDataSize,
    LPDWORD                     pdwPacketCount
);

HRESULT
CreateStdStream
(
    DWORD                       dwFlags, 
    LPCWAVEFORMATEX             pwfxFormat,
    LPCDSMIXBINS                pMixBins, 
    LPDWORD                     pdwPacketSize,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback,
    LPVOID                      pvContext,
    LPDIRECTSOUNDBUFFER         pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *       ppStream, 
    LPVOID *                    ppvAudioData,
    LPDWORD                     pdwAudioDataSize,
    LPDWORD                     pdwPacketCount
);

HRESULT
CreateQueuedStreamFromFile
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags, 
    LPCDSMIXBINS            pMixBins, 
    LPDWORD                 pdwPacketSize,
    HANDLE                  hCompletionEvent,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *   ppStream, 
    LPVOID *                ppvAudioData
);

HRESULT
CreateStdQueuedStream
(
    DWORD                   dwFlags, 
    LPCWAVEFORMATEX         pwfxFormat,
    LPCDSMIXBINS            pMixBins, 
    LPDWORD                 pdwPacketSize,
    HANDLE                  hCompletionEvent,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *   ppStream, 
    LPVOID *                ppvAudioData
);

//
// Stream utilties
//

HRESULT
PauseStream
(
    LPDIRECTSOUNDSTREAM     pStream,
    BOOL                    fPause  = TRUE
);

HRESULT
FlushStream
(
    LPDIRECTSOUNDSTREAM     pStream,
    DWORD                   dwFlags = 0,
    DWORD                   dwDelay = 0,
    BOOL                    fWait   = FALSE
);

HRESULT
WaitStream
(
    LPDIRECTSOUNDSTREAM     pStream,
    BOOL                    fPlaying
);

void CALLBACK
ResubmitPacketCallback
(
    LPVOID                  pvStreamContext,
    LPVOID                  pvPacketContext,
    DWORD                   dwStatus
);

//
// Generic helpers
//

void
GenerateTone
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwBitsPerSample,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
);

void
GenerateTone8
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
);

void
GenerateTone16
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
);

void
GenerateNoise
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize
);

HRESULT
MakeMultiChannel
(
    LPCWAVEFORMATEX         pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    LPCVOID                 pvSrcData,
    DWORD                   dwSrcDataSize,
    LPVOID *                ppvDstData,
    LPDWORD                 pdwDstDataSize
);

LPCWAVEFORMATEX
CreateFormat
(
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels
);

HRESULT
LoadEffectsImage
(
    LPCSTR                  pszImageName,
    DWORD                   dwFlags
);

HRESULT
GetDirectSoundCaps
(
    LPDSCAPS                pdsc
);

#endif // __cplusplus

#endif // __UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\testds.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       testds.cpp
 *  Content:    DirectSound test functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    dereks  Created.
 *
 ****************************************************************************/

#include "testds.h"
#include "pcm.h"
#include "adpcm.h"
#include "compress.h"
#include "8bit.h"
#include "pcmaiff.h"
#include "loop.h"
#include "mixed.h"

#ifdef DEBUG

EXTERN_C BOOL g_fDirectSoundSimulateDeltaPanic;

#endif // DEBUG

LPDIRECTSOUND g_pDirectSound = NULL;


/****************************************************************************
 *
 *  RotateVectorAzimuth
 *
 *  Description:
 *      Rotates a vector in a circle or elipse around a point.
 *
 *  Arguments:
 *      FLOAT [in]: circle size in radians.
 *      FLOAT [in]: theta in radians.
 *      LPD3DXVECTOR3 [in/out]: vector.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RotateVectorAzimuth"

__inline void
RotateVectorAzimuth
(
    FLOAT                   flDistance,
    FLOAT                   flTheta,
    LPD3DVECTOR             pvrPosition
)
{
    pvrPosition->x = (float)cos(flTheta) * flDistance;
    pvrPosition->z = (float)sin(flTheta) * flDistance;
}


/****************************************************************************
 *
 *  Test3d
 *
 *  Description:
 *      Moves a sound source around a circle.
 *
 *  Arguments:
 *      FLOAT [in]: listener position (X).
 *      FLOAT [in]: listener position (Y).
 *      FLOAT [in]: listener position (Z).
 *      FLOAT [in]: source circle radians.
 *      FLOAT [in]: source angular velocity.
 *      DWORD [in]: time, in ms, to run the test.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Test3d"

HRESULT
Test3d
(
    FLOAT                   flListenerPositionX,
    FLOAT                   flListenerPositionY,
    FLOAT                   flListenerPositionZ,
    FLOAT                   flDistance,
    FLOAT                   flAngularVelocity,
    DWORD                   dwTime
)
{
    static const LPCSTR     pszFile                 = "t:\\media\\audio\\pcm\\heli.wav";
    LPDIRECTSOUNDBUFFER     pBuffer                 = NULL;
    INT                     nLastX                  = -1;
    INT                     nLastY                  = -1;
    INT                     nLastZ                  = -1;
    DSMIXBINVOLUMEPAIR      aMixBinVolumePairs[]    = { DSMIXBINVOLUMEPAIRS_REQUIRED_3D, { DSMIXBIN_FRONT_CENTER, 0 } };
    DSMIXBINS               MixBins;
    FLOAT                   flTheta;
    D3DXVECTOR3             vrPreviousPosition;
    D3DXVECTOR3             vrCurrentPosition;
    D3DXVECTOR3             vrVelocity;
    DWORD                   dwStartTime;
    DWORD                   dwCurrentTime;
    FLOAT                   flTimeDelta;
    HRESULT                 hr;

    MixBins.dwMixBinCount = NUMELMS(aMixBinVolumePairs);
    MixBins.lpMixBinVolumePairs = aMixBinVolumePairs;

    //
    // Convert angular velocity to radians
    //

    flAngularVelocity = (flAngularVelocity * D3DX_PI) / 180.0f;
    flTheta = (90.0f * D3DX_PI) / 180.0f;

    //
    // Calculate the buffer's initial position
    //

    vrPreviousPosition.x = 0;
    vrPreviousPosition.y = 0;
    vrPreviousPosition.z = flDistance;

    vrCurrentPosition = vrPreviousPosition;

    //
    // Set the listener position
    //
    
    hr = ValidateResult(g_pDirectSound->SetPosition(flListenerPositionX, flListenerPositionY, flListenerPositionZ, DS3D_IMMEDIATE));

    //
    // Create the buffer
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(CreateBufferFromFile(pszFile, DSBCAPS_CTRL3D, &MixBins, NULL, &pBuffer));
    }

    //
    // Set the buffer's initial position
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetPosition(vrPreviousPosition.x, vrPreviousPosition.y, vrPreviousPosition.z, DS3D_IMMEDIATE));
    }

    //
    // Start the buffer playing
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
    }

    //
    // Get the current system time
    //

    if(SUCCEEDED(hr))
    {
        dwStartTime = GetTickCount();
    }

    //
    // Enter the main loop
    // 

    while(SUCCEEDED(hr) && !fBreakTest)
    {
        //
        // Get the current system time
        //

        while(dwStartTime == (dwCurrentTime = GetTickCount()));

        if(INFINITE != dwTime)
        {
            if(dwCurrentTime >= dwStartTime + dwTime)
            {
                break;
            }
        }

        //
        // Calculate the distance the sound should travel
        //

        flTimeDelta = (FLOAT)(dwCurrentTime - dwStartTime) / 1000.0f;
        flTheta += flAngularVelocity * flTimeDelta;

        //
        // Set the object's new position and velocity
        //

        RotateVectorAzimuth(flDistance, flTheta, &vrCurrentPosition);

        vrVelocity.x = (vrCurrentPosition.x - vrPreviousPosition.x) / flTimeDelta;
        vrVelocity.y = (vrCurrentPosition.y - vrPreviousPosition.y) / flTimeDelta;
        vrVelocity.z = (vrCurrentPosition.z - vrPreviousPosition.z) / flTimeDelta;

        hr = ValidateResult(pBuffer->SetVelocity(vrVelocity.x, vrVelocity.y, vrVelocity.z, DS3D_DEFERRED));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetPosition(vrCurrentPosition.x, vrCurrentPosition.y, vrCurrentPosition.z, DS3D_DEFERRED));
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(g_pDirectSound->CommitDeferredSettings());
        }

        if(SUCCEEDED(hr))
        {
            if(((INT)vrCurrentPosition.x != nLastX) || ((INT)vrCurrentPosition.y != nLastY) || ((INT)vrCurrentPosition.z != nLastZ))
            {
                nLastX = (INT)vrCurrentPosition.x;
                nLastY = (INT)vrCurrentPosition.y;
                nLastZ = (INT)vrCurrentPosition.z;

                DPF_TEST("%d %d %d (%d %d %d)", nLastX, nLastY, nLastZ, (int)vrVelocity.x, (int)vrVelocity.y, (int)vrVelocity.z);
            }
        }

        //
        // Save settings for the next time around
        //

        vrPreviousPosition = vrCurrentPosition;
        dwStartTime = dwCurrentTime;
    }

    //
    // Clean up
    //

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotBuffer
 *
 *  Description:
 *      Plays a single buffer to completion.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: buffer creation flags.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotBuffer"

HRESULT
PlayOneShotBuffer
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags     = 0,
    LPCDSMIXBINS            pMixBins    = NULL
)
{
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateBufferFromFile(pszFile, dwFlags, pMixBins, NULL, &pBuffer));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBufferToCompletion(pBuffer));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotBuffer
 *
 *  Description:
 *      Plays a single buffer to completion.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotBuffer"

HRESULT
PlayOneShotBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    LPCDSMIXBINS            pMixBins            = NULL
)
{
    WAVEFORMATEX            wfxFormat           = INIT_PCM_WAVEFORMAT(dwChannelCount, dwSamplesPerSec, dwBitsPerSample);
    LPCSTR                  pszFileName         = GetStdWaveFile(&wfxFormat);
    
    return PlayOneShotBuffer(pszFileName, dwFlags, pMixBins);
}


/****************************************************************************
 *
 *  TestSequentialBuffers
 *
 *  Description:
 *      Plays a list of secondary buffers sequentially.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSequentialBuffers"

HRESULT
TestSequentialBuffers
(
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]    = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]  = { 1, 2 };
    static const DWORD      adwBitResolutions[] = { 8, 16 };
    static const DWORD      dwBufferCount       = NUMELMS(adwSampleRates) * NUMELMS(adwChannelCounts) * NUMELMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    HRESULT                 hr                  = DS_OK;
    DWORD                   i;

    for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
    {
        hr = PlayOneShotBuffer(0, dwFormatTag, adwSampleRates[i % NUMELMS(adwSampleRates)], adwBitResolutions[i % NUMELMS(adwBitResolutions)], adwChannelCounts[i % NUMELMS(adwChannelCounts)]);
    }

    return hr;
}


/****************************************************************************
 *
 *  TestMultipleBuffers
 *
 *  Description:
 *      Plays multiple buffers of varying formats.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultipleBuffers"

HRESULT
TestMultipleBuffers
(
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]            = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]          = { 1, 2 };
    static const DWORD      adwBitResolutions[]         = { 8, 16 };
    static const DWORD      dwBufferCount               = NUMELMS(adwSampleRates) * NUMELMS(adwChannelCounts) * NUMELMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     apBuffers[dwBufferCount]    = { NULL };
    DWORD                   dwSampleRateIndex           = 0;
    DWORD                   dwChannelCountIndex         = 0;
    DWORD                   dwBitResolutionIndex        = 0;
    DWORD                   dwActiveBuffers             = 0;
    HRESULT                 hr                          = DS_OK;
    DWORD                   dwFreeSGEs;
    DWORD                   dwMaxBufferSize;
    DWORD                   dwBufferSize;
    LPCWAVEFORMATEX         pwfx;
    DWORD                   dwStatus;
    DWORD                   i;

    //
    // Get the count of free SGEs
    //

    hr = GetFreeSGEs(&dwFreeSGEs);

    //
    // Calculate the maximum buffer size
    //

    if(SUCCEEDED(hr))
    {
        dwMaxBufferSize = PAGE_SIZE;
    }

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveBuffers < dwBufferCount))
    {
        //
        // Create the buffer
        //
        
        pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);
        dwBufferSize = dwMaxBufferSize;
        
        hr = CreateStdBuffer(0, pwfx, 0, NULL, &apBuffers[dwActiveBuffers], &dwBufferSize);

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[dwActiveBuffers]);
        }

        if(SUCCEEDED(hr))
        {
            dwSampleRateIndex = (dwSampleRateIndex + 1) % NUMELMS(adwSampleRates);
            dwChannelCountIndex = (dwChannelCountIndex + 1) % NUMELMS(adwChannelCounts);
            dwBitResolutionIndex = (dwBitResolutionIndex + 1) % NUMELMS(adwBitResolutions);

            dwActiveBuffers++;
        }
    }

    //
    // Wait for all buffers to finish playing
    //

    while(SUCCEEDED(hr) && dwActiveBuffers)
    {
        DirectSoundDoWork();
        
        for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
        {
            if(apBuffers[i])
            {
                hr = ValidateResult(apBuffers[i]->GetStatus(&dwStatus));

                if(SUCCEEDED(hr) && !(dwStatus & DSBSTATUS_PLAYING))
                {
                    RELEASE(apBuffers[i]);

                    dwActiveBuffers--;
                }
            }
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  TestMultipleStreams
 *
 *  Description:
 *      Plays multiple streams of varying formats.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultipleStreams"

HRESULT
TestMultipleStreams
(
    DWORD                   dwFormatTag,
    DWORD                   dwPacketSize
)
{
    static const DWORD      adwSampleRates[]                    = { 8000, 11025, 16000, 22050, 32000, 44100, 48000 };
    static const DWORD      adwChannelCounts[]                  = { 1, 2 };
    static const DWORD      adwBitResolutions[]                 = { 8, 16 };
    static const DWORD      dwStreamCount                       = NUMELMS(adwSampleRates) * NUMELMS(adwChannelCounts) * NUMELMS(adwBitResolutions);
    LPDIRECTSOUNDSTREAM     apStreams[dwStreamCount]            = { NULL };
    LPVOID                  apvStreamData[dwStreamCount]        = { NULL };
    HANDLE                  ahCompletionEvents[dwStreamCount]   = { NULL };
    DWORD                   dwSampleRateIndex                   = 0;
    DWORD                   dwChannelCountIndex                 = 0;
    DWORD                   dwBitResolutionIndex                = 0;
    DWORD                   dwActiveStreams                     = 0;
    HRESULT                 hr                                  = DS_OK;
    LPCWAVEFORMATEX         pwfx;
    DWORD                   i;

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveStreams < dwStreamCount))
    {
        hr = ValidatePtr(ahCompletionEvents[dwActiveStreams] = CreateEvent(NULL, FALSE, FALSE, NULL));

        if(SUCCEEDED(hr))
        {
            pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);

            dwPacketSize /= pwfx->nBlockAlign;
            dwPacketSize *= pwfx->nBlockAlign;
            
            hr = CreateStdQueuedStream(0, pwfx, 0, &dwPacketSize, ahCompletionEvents[dwActiveStreams], NULL, &apStreams[dwActiveStreams], &apvStreamData[dwActiveStreams]);
        }

        if(SUCCEEDED(hr))
        {
            hr = PauseStream(apStreams[dwActiveStreams], FALSE);
        }

        if(SUCCEEDED(hr))
        {
            dwSampleRateIndex = (dwSampleRateIndex + 1) % NUMELMS(adwSampleRates);
            dwChannelCountIndex = (dwChannelCountIndex + 1) % NUMELMS(adwChannelCounts);
            dwBitResolutionIndex = (dwBitResolutionIndex + 1) % NUMELMS(adwBitResolutions);

            dwActiveStreams++;
        }
    }

    //
    // Wait for each stream to complete
    //

    while(SUCCEEDED(hr) && dwActiveStreams)
    {
        DirectSoundDoWork();
        
        if((i = WaitForMultipleObjects(dwStreamCount, ahCompletionEvents, FALSE, 0)) < dwStreamCount)
        {
            RELEASE(apStreams[i]);
            FREE(apvStreamData[i]);

            dwActiveStreams--;
        }
    }

    //
    // Clean up
    //

    for(i = 0; i < dwStreamCount; i++)
    {
        CLOSE_HANDLE(ahCompletionEvents[i]);
    }

    return hr;
}


/****************************************************************************
 *
 *  TestNotifies
 *
 *  Description:
 *      Tests notifications.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestNotifies"

HRESULT
TestNotifies
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwNotifyCount,
    BOOL                    fLoop
)
{
    LPCWAVEFORMATEX         pwfxFormat      = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPXFILEMEDIAOBJECT      pWaveFile       = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DWORD                   dwVolumeIndex   = 0;
    DWORD                   dwDuration      = 0;
    DWORD                   dwPeriod;
    LPHANDLE                pahEvents;
    LPDSBPOSITIONNOTIFY     padsbpn;
    DSENVELOPEDESC          dseg;
    HRESULT                 hr;
    DWORD                   i;

    //
    // Create the buffer
    //

    hr = CreateStdBuffer(DSBCAPS_CTRLPOSITIONNOTIFY, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    //
    // Calculate the notification period
    //
    
    if(SUCCEEDED(hr))
    {
        dwPeriod = dwDuration / (dwNotifyCount - 1) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign;
    }

    //
    // Create notification events
    //
    
    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pahEvents, HANDLE, dwNotifyCount);
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwNotifyCount; i++)
        {
            if(FAILED(hr = ValidatePtr(pahEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL))))
            {
                break;
            }
        }
    }

    //
    // Set notifications
    //

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padsbpn, DSBPOSITIONNOTIFY, dwNotifyCount);
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwNotifyCount - 2; i++)
        {
            padsbpn[i].dwOffset = i * dwPeriod;
            padsbpn[i].hEventNotify = pahEvents[i];
        }

        padsbpn[i].dwOffset = dwDuration - pwfxFormat->nBlockAlign;
        padsbpn[i].hEventNotify = pahEvents[i];

        i++;
        
        padsbpn[i].dwOffset = DSBPN_OFFSETSTOP;
        padsbpn[i].hEventNotify = pahEvents[i];

        hr = ValidateResult(pBuffer->SetNotificationPositions(dwNotifyCount, padsbpn));
    }

    //
    // Start playback
    //

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, fLoop ? DSBPLAY_LOOPING : 0);
    }

    //
    // Wait for playback to complete
    //

    if(SUCCEEDED(hr))
    {
        while(!fBreakTest)
        {
            DirectSoundDoWork();
            
            if((i = WaitForMultipleObjects(dwNotifyCount, pahEvents, FALSE, 100)) < dwNotifyCount)
            {
                DPF_TEST("Event %lu signaled", i);

                if(WAIT_OBJECT_0 + dwNotifyCount - 1 == i)
                {
                    break;
                }
            }
        }
    }

    //
    // Clean up
    //

    if(pahEvents)
    {
        for(i = 0; i < dwNotifyCount; i++)
        {
            CLOSE_HANDLE(pahEvents[i]);
        }
    }

    FREE(pahEvents);
    FREE(padsbpn);

    RELEASE(pBuffer);
    RELEASE(pWaveFile);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotStream
 *
 *  Description:
 *      Tests streaming.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: packet size, in bytes.
 *      DWORD [in]: mixbin mask.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotStream"

HRESULT
PlayOneShotStream
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags,
    DWORD                   dwPacketSize,
    LPCDSMIXBINS            pMixBins            = NULL 
)
{
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvDataBuffer        = NULL;
    HANDLE                  hCompletionEvent;
    HRESULT                 hr;
    
    //
    // Create the completion event
    //
    
    hr = ValidatePtr(hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL));

    //
    // Create the stream 
    //

    if(SUCCEEDED(hr))
    {
        hr = CreateQueuedStreamFromFile(pszFile, dwFlags, pMixBins, &dwPacketSize, hCompletionEvent, NULL, &pStream, &pvDataBuffer);
    }

    //
    // Start playback
    //

    if(SUCCEEDED(hr))
    {
        hr = PauseStream(pStream, FALSE);
    }

    //
    // Wait for the completion event to be signaled
    //

    if(SUCCEEDED(hr))
    {
        while(TRUE)
        {
            DirectSoundDoWork();

            if(WAIT_TIMEOUT != WaitForSingleObject(hCompletionEvent, 0))
            {
                break;
            }
        }
    }

    //
    // Clean up
    //

    RELEASE(pStream);
    FREE(pvDataBuffer);
    CLOSE_HANDLE(hCompletionEvent);

    return hr;
}


/****************************************************************************
 *
 *  PlayOneShotStream
 *
 *  Description:
 *      Tests streaming.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayOneShotStream"

HRESULT
PlayOneShotStream
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize,
    LPCDSMIXBINS            pMixBins        = NULL
)
{
    LPCWAVEFORMATEX         pwfxFormat      = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPCSTR                  pszFileName     = GetStdWaveFile(pwfxFormat);
    
    return PlayOneShotStream(pszFileName, dwFlags, dwPacketSize, pMixBins);
}


/****************************************************************************
 *
 *  TestBufferOffsets
 *
 *  Description:
 *      Tests buffer play region.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      FLOAT [in]: play start position (0 to 1).
 *      FLOAT [in]: play end position (0 to 1).
 *      FLOAT [in]: loop start position (0 to 1).
 *      FLOAT [in]: loop end position (0 to 1).
 *      BOOL [in]: TRUE to play looping.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestBufferOffsets"

HRESULT
TestBufferOffsets
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    FLOAT                   flPlayStart,
    FLOAT                   flPlayEnd,
    FLOAT                   flLoopStart,
    FLOAT                   flLoopEnd,
    BOOL                    fLoop
)
{
    LPCWAVEFORMATEX         pwfxFormat  = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    DWORD                   dwDuration  = 0;
    DWORD                   dwPlayStart;
    DWORD                   dwPlayLength;
    DWORD                   dwLoopStart;
    DWORD                   dwLoopLength;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    if(SUCCEEDED(hr))
    {
        dwPlayStart = (DWORD)((FLOAT)dwDuration * flPlayStart) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign;
        dwPlayLength = ((DWORD)((FLOAT)dwDuration * flPlayEnd) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign) - dwPlayStart;
        
        dwLoopStart = (DWORD)((FLOAT)dwDuration * flLoopStart) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign - dwPlayStart;
        dwLoopLength = ((DWORD)((FLOAT)dwDuration * flLoopEnd) / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign) - dwLoopStart - dwPlayStart;

        DPF_TEST("Setting buffer play region to %lu, %lu and loop region to %lu, %lu (duration %lu)", dwPlayStart, dwPlayLength, dwLoopStart, dwLoopLength, dwDuration);
        
        hr = ValidateResult(pBuffer->SetPlayRegion(dwPlayStart, dwPlayLength));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetLoopRegion(dwLoopStart, dwLoopLength));
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, fLoop ? DSBPLAY_LOOPING : 0);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(30000);

        hr = PlayBuffer(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestSubMix
 *
 *  Description:
 *      Tests basic submixing.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to test MIXIN.  FALSE to test FXIN.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestSubMix"

HRESULT
TestSubMix
(
    BOOL                    fMixIn,
    DWORD                   dwFormatTag
)
{
    static const DWORD      adwSampleRates[]            = { /*22050, 32000, */44100, 48000};
    static const DWORD      adwChannelCounts[]          = { 1 };
    static const DWORD      adwBitResolutions[]         = { 16 };
    static const DWORD      dwBufferCount               = NUMELMS(adwSampleRates) * NUMELMS(adwChannelCounts) * NUMELMS(adwBitResolutions);
    LPDIRECTSOUNDBUFFER     apBuffers[dwBufferCount]    = { NULL };
    LPDIRECTSOUNDBUFFER     apOutputBuffers[2]          = { NULL };
    DWORD                   dwActiveBuffers             = 0;
    DWORD                   dwSampleRateIndex           = 0;
    DWORD                   dwChannelCountIndex         = 0;
    DWORD                   dwBitResolutionIndex        = 0;
    HRESULT                 hr                          = DS_OK;
    DSBUFFERDESC            dsbd;
    DWORD                   dwFreeSGEs;
    DWORD                   dwMaxBufferSize;
    DWORD                   dwBufferSize;
    DWORD                   dwStatus;
    LPCWAVEFORMATEX         pwfx;
    DSMIXBINS               MixBins;
    DWORD                   i, z;

    //
    // Create output buffers
    //

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = fMixIn ? DSBCAPS_MIXIN : DSBCAPS_FXIN;

    for(i = 0; (i < NUMELMS(apOutputBuffers)) && SUCCEEDED(hr); i++)
    {
        if(!fMixIn)
        {
            dsbd.dwInputMixBin = DSMIXBIN_FXSEND_10 + i;
        }
        
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apOutputBuffers[i]));
    }

    //
    // Get the count of free SGEs
    //

    if(SUCCEEDED(hr))
    {
        hr = GetFreeSGEs(&dwFreeSGEs);
    }

    //
    // Calculate the maximum buffer size
    //

    if(SUCCEEDED(hr))
    {
        dwMaxBufferSize = ((dwFreeSGEs - dwBufferCount) * PAGE_SIZE) / dwBufferCount / 4 * 4;
    }

    //
    // Enter the creation loop
    //
    
    while(SUCCEEDED(hr) && (dwActiveBuffers < dwBufferCount))
    {
        //
        // Create the buffer
        //
        
        pwfx = CreateFormat(dwFormatTag, adwSampleRates[dwSampleRateIndex], adwBitResolutions[dwBitResolutionIndex], adwChannelCounts[dwChannelCountIndex]);
        dwBufferSize = dwMaxBufferSize;

        MixBins.dwMixBinCount = 0;
        
        hr = CreateStdBuffer(0, pwfx, &MixBins, apOutputBuffers[dwActiveBuffers % NUMELMS(apOutputBuffers)], &apBuffers[dwActiveBuffers], &dwBufferSize);

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[dwActiveBuffers]);
        }

        if(SUCCEEDED(hr))
        {
            dwSampleRateIndex = (dwSampleRateIndex + 1) % NUMELMS(adwSampleRates);
            dwChannelCountIndex = (dwChannelCountIndex + 1) % NUMELMS(adwChannelCounts);
            dwBitResolutionIndex = (dwBitResolutionIndex + 1) % NUMELMS(adwBitResolutions);

            dwActiveBuffers++;
        }
    }

    //
    // Wait for all buffers to finish playing
    //

    while(SUCCEEDED(hr) && dwActiveBuffers)
    {
        for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
        {
            if(apBuffers[i])
            {
                hr = ValidateResult(apBuffers[i]->GetStatus(&dwStatus));

                if(SUCCEEDED(hr) && !(dwStatus & DSBSTATUS_PLAYING))
                {
                    RELEASE(apBuffers[i]);

                    dwActiveBuffers--;
                }
            }
        }
    }

    //
    // Release output buffers
    //

    for(i = 0; i < NUMELMS(apOutputBuffers); i++)
    {
        RELEASE(apOutputBuffers[i]);
    }

    return hr;
}


/****************************************************************************
 *
 *  TestDLS
 *
 *  Description:
 *      Tests basic DLS functionality.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDLS"

HRESULT
TestDLS
(
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    static const DWORD      dwSegmentLength = 200;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DSENVELOPEDESC          env;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        env.dwEG = DSEG_AMPLITUDE;
        env.dwMode = DSEG_MODE_DELAY;
        env.dwDelay = dwSegmentLength;
        env.dwAttack = dwSegmentLength;
        env.dwHold = dwSegmentLength;
        env.dwDecay = dwSegmentLength;
        env.dwRelease = dwSegmentLength;
        env.dwSustain = 0xFF;
        env.lPitchScale = 0;
        env.lFilterCutOff = 0;

        hr = ValidateResult(pBuffer->SetEG(&env));
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 10000, FALSE, TRUE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestStreamStop
 *
 *  Description:
 *      Tests stream release envelopes.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *      DWORD [in]: packet size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestStreamStop"

HRESULT
TestStreamStop
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize
)
{
    static const DWORD      dwSegmentLength     = 200;
    static const DWORD      dwDelay             = 5000;
    const LPCWAVEFORMATEX   pwfxFormat          = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvAudioData         = NULL;
    DSENVELOPEDESC          env;
    HRESULT                 hr;

    hr = CreateStdQueuedStream(0, pwfxFormat, NULL, &dwPacketSize, NULL, NULL, &pStream, &pvAudioData);

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&env, sizeof(env));
        
        env.dwEG = DSEG_AMPLITUDE;
        env.dwMode = DSEG_MODE_HOLD;
        env.dwRelease = dwSegmentLength;
        env.dwSustain = 0xFF;

        hr = ValidateResult(pStream->SetEG(&env));
    }

    if(SUCCEEDED(hr))
    {
        hr = PauseStream(pStream, FALSE);
    }

    if(SUCCEEDED(hr))
    {
        hr = FlushStream(pStream, dwFlags, (dwFlags & DSSTREAMFLUSHEX_ASYNC) ? dwDelay : 0, TRUE);
    }

    RELEASE(pStream);

    FREE(pvAudioData);

    return hr;
}


/****************************************************************************
 *
 *  TestSurroundEncoder
 *
 *  Description:
 *      Tests surround-sound encoding.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "TestSurroundEncoder"

HRESULT
TestSurroundEncoder
(
    DWORD                       dwFormatTag,
    DWORD                       dwSamplesPerSec,
    DWORD                       dwBitsPerSample
)
{
    typedef struct
    {
        LPCSTR                  pszDescription;
        DWORD                   pMixBins;
    } TESTMIXBINS;

    static const TESTMIXBINS    aMixBins[] =
    {

#if 0

        { "All speakers",       DSMIXBIN_SPEAKER_MASK },
        { "Front left",         DSMIXBIN_FRONT_LEFT },
        { "Front right",        DSMIXBIN_FRONT_RIGHT },
        { "Front center",       DSMIXBIN_FRONT_CENTER },
        { "Back left",          DSMIXBIN_BACK_LEFT },
        { "Back right",         DSMIXBIN_BACK_RIGHT },
        { "LFE",                DSMIXBIN_LOW_FREQUENCY },

#else

        { "Front",              DSMIXBIN_FRONT_LEFT },
        { "Back",               DSMIXBIN_BACK_LEFT },

#endif

    };
    
    static const DWORD          dwDuration  = 5000;
    LPDIRECTSOUNDBUFFER         pBuffer     = NULL;
    HRESULT                     hr;
    DWORD                       i;

    hr = CreateStdBuffer(0, CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, 1), 0, NULL, &pBuffer);

    for(i = 0; (i < NUMELMS(aMixBins)) && SUCCEEDED(hr); i++)
    {
        DPF_TEST(aMixBins[i].pszDescription);

        hr = ValidateResult(pBuffer->SetMixBins(aMixBins[i].pMixBins));

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
        }

        if(SUCCEEDED(hr))
        {
            Sleep(dwDuration);
        }
    }

    RELEASE(pBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  TestSgeSharing
 *
 *  Description:
 *      Tests whether buffer SGE sharing works by creating two very large
 *      buffers and pointing them to the same memory.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSgeSharing"

HRESULT
TestSgeSharing
(
    void
)
{
    LPVOID                      pvBufferData    = NULL;
    LPDIRECTSOUNDBUFFER         apBuffers[2]    = { NULL };
    DWORD                       dwBufferSize;
    DSBUFFERDESC                dsbd;
    WAVEFORMATEX                wfx;
    HRESULT                     hr;
    DWORD                       i;

    XAudioCreatePcmFormat(2, 48000, 16, &wfx);

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.lpwfxFormat = &wfx;

    dwBufferSize = -1;
    
    hr = ClampBufferSize(&dwBufferSize);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvBufferData, BYTE, dwBufferSize);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone16(pvBufferData, dwBufferSize, wfx.nSamplesPerSec, wfx.nChannels, 500);
    }

    for(i = 0; (i < NUMELMS(apBuffers)) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[i]));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(apBuffers[i]->SetBufferData(pvBufferData, dwBufferSize));
        }

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[i], DSBPLAY_LOOPING);
        }

        if(SUCCEEDED(hr))
        {
            hr = StopBuffer(apBuffers[i], 0, (5000 * i) + 10000);
        }
    }

    for(i = 0; (i < NUMELMS(apBuffers)) && SUCCEEDED(hr); i++)
    {
        if(apBuffers[i])
        {
            hr = WaitBuffer(apBuffers[i], FALSE);

            RELEASE(apBuffers[i]);
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  TestSgeHeap
 *
 *  Description:
 *      Allocates all available SGEs, then frees them all in a random order
 *      to verify that they were coalesced properly.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestSgeHeap"

HRESULT
TestSgeHeap
(
    void
)
{
    LPDIRECTSOUNDBUFFER     apBuffers[256]  = { NULL };
    LPVOID                  pvBufferData    = NULL;
    DWORD                   dwBufferCount;
    DWORD                   dwBufferSize;
    DWORD                   dwRemaining;
    DWORD                   dwFree;
    DSBUFFERDESC            dsbd;
    DSCAPS                  dsc;
    HRESULT                 hr;
    DWORD                   i;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.lpwfxFormat = (LPWAVEFORMATEX)CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);

    hr = GetDirectSoundCaps(&dsc);

    if(SUCCEEDED(hr))
    {
        dwBufferCount = dsc.dwFree2DBuffers + dsc.dwFree3DBuffers;
        dwBufferSize = dsc.dwFreeBufferSGEs / dwBufferCount;
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidatePtr(pvBufferData = MmAllocateContiguousMemoryEx(dsc.dwFreeBufferSGEs * PAGE_SIZE, 0, 0xFFFFFFFF, PAGE_SIZE, PAGE_READWRITE));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("Creating %lu buffers", dwBufferCount);
        
        for(i = 0; (i < dwBufferCount) && SUCCEEDED(hr); i++)
        {
            hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[i]));

            if(SUCCEEDED(hr))
            {
                if(dwBufferCount - 1 == i)
                {
                    dwBufferSize = dsc.dwFreeBufferSGEs - dwBufferSize;
                }
                
                hr = ValidateResult(apBuffers[i]->SetBufferData(pvBufferData, dwBufferSize * PAGE_SIZE));
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = GetFreeSGEs(&dwFree);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(!dwFree);
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("Releasing all buffers");

        for(dwRemaining = dwBufferCount; dwRemaining; dwRemaining--)
        {
            dwFree = rand() % dwRemaining;

            for(i = 0; i < dwBufferCount; i++)
            {
                if(apBuffers[i])
                {
                    if(!dwFree)
                    {
                        RELEASE(apBuffers[i]);
                        break;
                    }

                    dwFree--;
                }
            }

            ASSERT(!dwFree);
        }

        for(i = 0; i < dwBufferCount; i++)
        {
            ASSERT(!apBuffers[i]);
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("Creating big buffer");

        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[0]));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(apBuffers[0]->SetBufferData(pvBufferData, dsc.dwFreeBufferSGEs * PAGE_SIZE));
    }

    RELEASE(apBuffers[0]);

    if(pvBufferData)
    {
        MmFreeContiguousMemory(pvBufferData);
    }

    return hr;
}


/****************************************************************************
 *
 *  Test256Voices
 *
 *  Description:
 *      Creates 256 voices.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Test256Voices"

HRESULT
Test256Voices
(
    void
)
{
    static const DWORD          dwBufferSize    = PAGE_SIZE;
    LPVOID                      pvBufferData    = NULL;
    LPDIRECTSOUNDBUFFER         apBuffers[256]  = { NULL };
    DSCAPS                      dsc;
    DSBUFFERDESC                dsbd;
    WAVEFORMATEX                wfx;
    HRESULT                     hr;
    DWORD                       i;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.lpwfxFormat = &wfx;

    XAudioCreatePcmFormat(1, dwBufferSize / 2, 16, &wfx);

    hr = MALLOC(pvBufferData, BYTE, dwBufferSize);

    if(SUCCEEDED(hr))
    {
        GenerateTone16(pvBufferData, dwBufferSize, wfx.nSamplesPerSec, wfx.nChannels, 500);
    }

    if(SUCCEEDED(hr))
    {
        hr = GetDirectSoundCaps(&dsc);
    }

    for(i = 0; (i < dsc.dwFree2DBuffers) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[i]));
    }

    if(SUCCEEDED(hr))
    {
        dsbd.dwFlags |= DSBCAPS_CTRL3D;
    }
    
    for(i = 0; (i < dsc.dwFree3DBuffers) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &apBuffers[dsc.dwFree2DBuffers + i]));
    }

    for(i = 0; (i < dsc.dwFree2DBuffers + dsc.dwFree3DBuffers) && SUCCEEDED(hr); i++)
    {
        hr = ValidateResult(apBuffers[i]->SetBufferData(pvBufferData, dwBufferSize));

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(apBuffers[i], DSBPLAY_LOOPING);
        }
    }

    if(SUCCEEDED(hr))
    {
        Sleep(5000);
    }

    for(i = 0; i < NUMELMS(apBuffers); i++)
    {
        if(apBuffers[i])
        {
            StopBuffer(apBuffers[i], 0, 0, FALSE, TRUE);
        }
        
        RELEASE(apBuffers[i]);
    }

    FREE(pvBufferData);

    return hr;
}


/****************************************************************************
 *
 *  TestStop
 *
 *  Description:
 *      Tests stopping and restarting a buffer.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestStop"

HRESULT
TestStop
(
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    LPCWAVEFORMATEX         pwfxFormat  = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    DWORD                   dwDuration  = 0;
    DWORD                   dwPlay;
    DWORD                   dwWrite;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, pwfxFormat, 0, NULL, &pBuffer, &dwDuration);

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(!dwPlay);
        ASSERT(!dwWrite);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("initial play:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(2000);

        hr = ValidateResult(pBuffer->SetCurrentPosition(dwDuration / 2 / pwfxFormat->nBlockAlign * pwfxFormat->nBlockAlign));
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("manual setposition:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, 0, 10000, FALSE, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(2500);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("forced stop:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("play from current position:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("natural stop:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(2000);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("play after natural stop (2000 ms delayed):  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_FROMSTART);
    }

    if(SUCCEEDED(hr))
    {
        Sleep(1);
        
        hr = ValidateResult(pBuffer->GetCurrentPosition(&dwPlay, &dwWrite));
    }

    if(SUCCEEDED(hr))
    {
        DPF_TEST("play from start:  play %lu write %lu duration %lu", dwPlay, dwWrite, dwDuration);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestFrequency
 *
 *  Description:
 *      Tests changing the frequency.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestFrequency"

HRESULT
TestFrequency
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwDelay
)
{
    static const DWORD      adwFrequencies[]    = { 0, 8000, 11025, 16000, 22050, 32000, 44100, 48000, 64000, 96000 };
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    DWORD                   dwFrequency;
    HRESULT                 hr;

    hr = CreateStdBuffer(dwFlags, CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        for(dwFrequency = 0; (dwFrequency < NUMELMS(adwFrequencies)) && SUCCEEDED(hr); dwFrequency++)
        {
            DPF_TEST("Frequency %lu", adwFrequencies[dwFrequency]);

            hr = ValidateResult(pBuffer->SetFrequency(adwFrequencies[dwFrequency]));

            if(SUCCEEDED(hr))
            {
                Sleep(dwDelay);
            }
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestDiscontinuity
 *
 *  Description:
 *      Tests allowing the stream to starve by calling Discontinuity.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDiscontinuity"

HRESULT
TestDiscontinuity
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize,
    BOOL                    fStarve
)
{
    LPCWAVEFORMATEX         pwfxFormat          = CreateFormat(dwFormatTag, dwSampleRate, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvDataBuffer        = NULL;
    DWORD                   dwPacketsThisTime   = 0;
    DWORD                   dwDuration;
    DWORD                   dwPacketCount;
    XMEDIAPACKET            xmb;
    HRESULT                 hr;
    DWORD                   i, z;

    //
    // Create the stream

    hr = CreateStdStream(dwFlags, pwfxFormat, 0, &dwPacketSize, NULL, NULL, NULL, &pStream, &pvDataBuffer, &dwDuration, &dwPacketCount);

    //
    // Enter the stream loop
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmb, sizeof(xmb));
        
        xmb.pvBuffer = pvDataBuffer;
        xmb.dwMaxSize = dwPacketSize;

        while(dwPacketCount)
        {
            dwPacketsThisTime = ((dwPacketsThisTime + 1) % 2) + 1;

            for(z = 0; (z < dwPacketsThisTime) && dwPacketCount && SUCCEEDED(hr); z++)
            {
                DirectSoundDoWork();
            
                if(!--dwPacketCount)
                {
                    xmb.dwMaxSize = dwDuration;
                }                
            
                hr = ValidateResult(pStream->Process(&xmb, NULL));

                xmb.pvBuffer = (LPBYTE)xmb.pvBuffer + xmb.dwMaxSize;
            
                dwDuration -= xmb.dwMaxSize;
            }

            if(SUCCEEDED(hr) && !fStarve)
            {
                hr = ValidateResult(pStream->Discontinuity());
            }

            if(SUCCEEDED(hr))
            {
                Sleep((dwPacketSize * dwPacketsThisTime * 2) / (pwfxFormat->nAvgBytesPerSec / 1000));
            }
        }
    }

    //
    // Clean up
    //

    RELEASE(pStream);
    FREE(pvDataBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestDeferredCommandRelease
 *
 *  Description:
 *      Tests whether deferred commands automatically get released when the
 *      buffer is.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDeferredCommandRelease"

HRESULT
TestDeferredCommandRelease
(
    void
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = CreateStdBuffer(0, CreateFormat(WAVE_FORMAT_PCM, 32000, 16, 2), 0, NULL, &pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 10000);
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestHeadroom
 *
 *  Description:
 *      Tests headroom.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "TestHeadroom"

HRESULT
TestHeadroom
(
    void
)
{
    static const DWORD      dwSleep         = 2000;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    HRESULT                 hr;
    int                     i;

    hr = CreateToneBuffer(0, 8000, 16, 1, 500, 0, 0, &pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    for(i = DSBHEADROOM_MAX; SUCCEEDED(hr) && (i >= DSBHEADROOM_MIN); i -= 1000)
    {
        DPF_TEST("%lu voice headroom", i);

        hr = ValidateResult(pBuffer->SetHeadroom(i));

        if(SUCCEEDED(hr))
        {
            Sleep(dwSleep);
        }
    }

    for(i = DSHEADROOM_MIN; SUCCEEDED(hr) && (i <= DSHEADROOM_MAX); i++)
    {
        DPF_TEST("%lu mixbin headroom", i);

        hr = ValidateResult(g_pDirectSound->SetMixBinHeadroom(DSMIXBIN_VALID, i));

        if(SUCCEEDED(hr))
        {
            Sleep(dwSleep);
        }
    }

    RELEASE(pBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  TestI3DL2Listener
 *
 *  Description:
 *      Tests I3DL2 listener.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "TestI3DL2Listener"

HRESULT
TestI3DL2Listener
(
    void
)
{
    static const struct
    {
        LPCSTR                      pszName;
        DSI3DL2LISTENER             Properties;
    } Environments[] =
    {
        { "Default",         { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT } },
        { "Generic",         { DSI3DL2_ENVIRONMENT_PRESET_GENERIC } },
        { "PaddedCell",      { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL } },
        { "Room",            { DSI3DL2_ENVIRONMENT_PRESET_ROOM } },
        { "Bathroom",        { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM } },
        { "LivingRoom",      { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM } },
        { "StoneRoom",       { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM } },
        { "Auditorium",      { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM } },
        { "ConcertHall",     { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL } },
        { "Cave",            { DSI3DL2_ENVIRONMENT_PRESET_CAVE } },
        { "Arena",           { DSI3DL2_ENVIRONMENT_PRESET_ARENA } },
        { "Hangar",          { DSI3DL2_ENVIRONMENT_PRESET_HANGAR } },
        { "CarpetedHallway", { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY } },
        { "Hallway",         { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY } },
        { "StoneCorridor",   { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR } },
        { "Alley",           { DSI3DL2_ENVIRONMENT_PRESET_ALLEY } },
        { "Forest",          { DSI3DL2_ENVIRONMENT_PRESET_FOREST } },
        { "City",            { DSI3DL2_ENVIRONMENT_PRESET_CITY } },
        { "Mountains",       { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS } },
        { "Quarry",          { DSI3DL2_ENVIRONMENT_PRESET_QUARRY } },
        { "Plain",           { DSI3DL2_ENVIRONMENT_PRESET_PLAIN } },
        { "ParkingLot",      { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT } },
        { "SewerPipe",       { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE } },
        { "UnderWater",      { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER } },
    };

    static const DWORD              pMixBins    = DSMIXBIN_SPEAKER_MASK | DSMIXBIN_I3DL2;
    static const DWORD              dwDelay         = 10000;
    LPDIRECTSOUNDBUFFER             pBuffer         = NULL;
    HRESULT                         hr;
    DWORD                           i;

    hr = CreateBufferFromFile("t:\\media\\audio\\pcm\\CleanGuitarArpeggios.wav", 0, pMixBins, NULL, &pBuffer);

    for(i = 0; SUCCEEDED(hr) && (i < NUMELMS(Environments)); i++)
    {
        DPF_TEST(Environments[i].pszName);

        hr = ValidateResult(g_pDirectSound->SetI3DL2Listener(&Environments[i].Properties, DS3D_IMMEDIATE));

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
        }

        if(SUCCEEDED(hr))
        {
            Sleep(dwDelay);
        }
    }

    RELEASE(pBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  TestMultiChannel
 *
 *  Description:
 *      Tests multichannel content.
 *
 *  Arguments:
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultiChannel"

HRESULT
TestMultiChannel
(
    DWORD                   dwSampleRate,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount
)
{
    LPCWAVEFORMATEX         pwfxSrc             = CreateFormat(WAVE_FORMAT_PCM, dwSampleRate, dwBitsPerSample, dwChannelCount);
    XFileMediaObject *      pWaveFile           = NULL;
    LPVOID                  pvSrcData           = NULL;
    LPVOID                  pvDstData           = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer             = NULL;
    WAVEFORMATEX            wfxDst;
    DWORD                   dwSrcDataSize;
    DWORD                   dwDstDataSize;
    DSBUFFERDESC            dsbd;
    HRESULT                 hr;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = 0;
    dsbd.lpwfxFormat = &wfxDst;
    
    //
    // Load the source wave file
    //

    hr = LoadStdWaveFile(pwfxSrc, &pvSrcData, &dwSrcDataSize, &pWaveFile);

    //
    // Enter the multichannel test loop
    //

    if(SUCCEEDED(hr))
    {
        for(wfxDst.nChannels = pwfxSrc->nChannels + 1; wfxDst.nChannels <= 6; wfxDst.nChannels++)
        {
            if(wfxDst.nChannels % pwfxSrc->nChannels)
            {
                continue;
            }

            if(wfxDst.nChannels % 2)
            {
                continue;
            }

            //
            // Convert to multichannel
            //

            DPF_TEST("Converting from %lu channel to %lu channel", pwfxSrc->nChannels, wfxDst.nChannels);
            
            hr = MakeMultiChannel(pwfxSrc, &wfxDst, pvSrcData, dwSrcDataSize, &pvDstData, &dwDstDataSize);

            //
            // Create the buffer, making sure to keep it to 2047 SGEs
            //
            
            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
            }

            if(SUCCEEDED(hr))
            {
                hr = ClampBufferSize(&dwDstDataSize);
            }

            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(pBuffer->SetBufferData(pvDstData, dwDstDataSize));
            }

            //
            // Start playback
            //

            if(SUCCEEDED(hr))
            {
                hr = PlayBufferToCompletion(pBuffer);
            }

            //
            // Clean up
            //

            FREE(pvDstData);
            RELEASE(pBuffer);
        }
    }

    //
    // Clean up
    //

    RELEASE(pWaveFile);
    FREE(pvSrcData);

    return hr;
}


/****************************************************************************
 *
 *  TestMultiChannel2
 *
 *  Description:
 *      Tests multichannel content.
 *
 *  Arguments:
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultiChannel2"

HRESULT
TestMultiChannel2
(
    DWORD                   dwChannelCount
)
{
    static const DWORD      dwSegmentLength = 2;
    LPVOID                  pvMonoData      = NULL;
    LPVOID                  pvMultiData     = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    WAVEFORMATEX            wfxMono;
    WAVEFORMATEX            wfxMulti;
    short *                 pnMonoData;
    short *                 pnMultiData;
    DSBUFFERDESC            dsbd;
    HRESULT                 hr;
    DWORD                   a, b, c;

    XAudioCreatePcmFormat(1, 48000, 16, &wfxMono);
    XAudioCreatePcmFormat(6, wfxMono.nSamplesPerSec, wfxMono.wBitsPerSample, &wfxMulti);

    hr = MALLOC(pvMonoData, BYTE, wfxMono.nAvgBytesPerSec * dwSegmentLength);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvMultiData, BYTE, wfxMulti.nAvgBytesPerSec * wfxMulti.nChannels * dwSegmentLength);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvMonoData, wfxMono.nAvgBytesPerSec * dwSegmentLength, wfxMono.nSamplesPerSec, wfxMono.wBitsPerSample, wfxMono.nChannels, 500);
    }

    if(SUCCEEDED(hr))
    {
        pnMultiData = (short *)pvMultiData;
        
        for(a = 0; a < wfxMulti.nChannels; a++)
        {
            pnMonoData = (short *)pvMonoData;
            
            for(b = 0; b < wfxMulti.nSamplesPerSec * dwSegmentLength; b++)
            {
                for(c = 0; c < a; c++)
                {
                    *pnMultiData++ = 0;
                }

                *pnMultiData++ = *pnMonoData++;

                for(c = a + 1; c < wfxMulti.nChannels; c++)
                {
                    *pnMultiData++ = 0;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = &wfxMulti;

        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetBufferData(pvMultiData, wfxMulti.nAvgBytesPerSec * wfxMulti.nChannels * dwSegmentLength));
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    RELEASE(pBuffer);

    FREE(pvMultiData);
    FREE(pvMonoData);

    return hr;
}


/****************************************************************************
 *
 *  TestMultiChannel3
 *
 *  Description:
 *      Tests multichannel content.
 *
 *  Arguments:
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMultiChannel3"

HRESULT
TestMultiChannel3
(
    DWORD                   dwChannelCount
)
{
    static const DWORD      dwSegmentLength = 2;
    LPVOID                  pvMonoData      = NULL;
    LPVOID                  pvMultiData     = NULL;
    LPDIRECTSOUNDSTREAM     pStream         = NULL;
    WAVEFORMATEX            wfxMono;
    WAVEFORMATEX            wfxMulti;
    short *                 pnMonoData;
    short *                 pnMultiData;
    DSSTREAMDESC            dssd;
    XMEDIAPACKET            xmp;
    DWORD                   dwStatus;
    HRESULT                 hr;
    DWORD                   a, b, c;

    XAudioCreatePcmFormat(1, 48000, 16, &wfxMono);
    XAudioCreatePcmFormat(6, wfxMono.nSamplesPerSec, wfxMono.wBitsPerSample, &wfxMulti);

    hr = MALLOC(pvMonoData, BYTE, wfxMono.nAvgBytesPerSec * dwSegmentLength);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvMultiData, BYTE, wfxMulti.nAvgBytesPerSec * wfxMulti.nChannels * dwSegmentLength);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvMonoData, wfxMono.nAvgBytesPerSec * dwSegmentLength, wfxMono.nSamplesPerSec, wfxMono.wBitsPerSample, wfxMono.nChannels, 500);
    }

    if(SUCCEEDED(hr))
    {
        pnMultiData = (short *)pvMultiData;
        
        for(a = 0; a < wfxMulti.nChannels; a++)
        {
            pnMonoData = (short *)pvMonoData;
            
            for(b = 0; b < wfxMulti.nSamplesPerSec * dwSegmentLength; b++)
            {
                for(c = 0; c < a; c++)
                {
                    *pnMultiData++ = 0;
                }

                *pnMultiData++ = *pnMonoData++;

                for(c = a + 1; c < wfxMulti.nChannels; c++)
                {
                    *pnMultiData++ = 0;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dssd, sizeof(dssd));

        dssd.lpwfxFormat = &wfxMulti;
        dssd.dwMaxAttachedPackets = 1;

        hr = ValidateResult(DirectSoundCreateStream(&dssd, &pStream));
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvMultiData;
        xmp.dwMaxSize = wfxMulti.nAvgBytesPerSec * wfxMulti.nChannels * dwSegmentLength;
        xmp.pdwStatus = &dwStatus;

        hr = ValidateResult(pStream->Process(&xmp, NULL));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pStream->Discontinuity());
    }

    if(SUCCEEDED(hr))
    {
        while(XMEDIAPACKET_STATUS_PENDING == *((volatile DWORD *)&dwStatus))
        {
            DirectSoundDoWork();
        }
    }

    RELEASE(pStream);

    FREE(pvMultiData);
    FREE(pvMonoData);

    return hr;
}


/****************************************************************************
 *
 *  TestReleaseEnvelope
 *
 *  Description:
 *      Tests the hardware release envelope.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestReleaseEnvelope"

HRESULT
TestReleaseEnvelope
(
    void
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    DSENVELOPEDESC          dsed;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(0, 8000, 16, 1, 500, 0, 0, &pBuffer));

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsed, sizeof(dsed));

        dsed.dwEG = DSEG_MULTI;
        dsed.dwMode = DSEG_MODE_DISABLE;
        dsed.dwRelease = 1000;
        
        hr = ValidateResult(pBuffer->SetEG(&dsed));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(StopBuffer(pBuffer, DSBSTOPEX_ENVELOPE, 0, FALSE, TRUE));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  CompareVolume
 *
 *  Description:
 *      Compares comparable 2D and 3D buffer volume.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#if 0

#undef DPF_FNAME
#define DPF_FNAME "CompareVolume"

HRESULT
CompareVolume
(
    FLOAT                   flDistance
)
{
    static const LONG       lExtra  = -600;
    const LONG              lVolume = (LONG)(-2000.0f * log10f(flDistance)) + lExtra;
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    BOOL                    f3d     = FALSE;
    HRESULT                 hr      = DS_OK;

    while(SUCCEEDED(hr) && !fBreakTest)
    {
        DPF_TEST(f3d ? "3D" : "2D");
        
        hr = ValidateResult(CreateToneBuffer(f3d ? DSBCAPS_CTRL3D : 0, 8000, 16, 1, 500, 0, f3d ? 0 : DSMIXBIN_FRONT_RIGHT | DSMIXBIN_FRONT_LEFT, &pBuffer));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetHeadroom(0));
        }

        if(SUCCEEDED(hr))
        {
            if(f3d)
            {
                hr = ValidateResult(pBuffer->SetPosition(0, 0, flDistance, DS3D_IMMEDIATE));
            }
            else
            {
                hr = ValidateResult(pBuffer->SetVolume(lVolume));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(StopBuffer(pBuffer, 0, 2000, FALSE, TRUE));
        }

        RELEASE(pBuffer);

        f3d = !f3d;
    }

    RELEASE(pBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  PlayToneBuffer
 *
 *  Description:
 *      Plays a simple sine-wave buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *      DWORD [in]: length of time to play the buffer, in ms.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayToneBuffer"

HRESULT
PlayToneBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels,
    DWORD                   dwToneFrequency,
    DWORD                   dwTime
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(dwFlags, dwSamplesPerSec, dwBitsPerSample, dwChannels, dwToneFrequency, 0, 0, &pBuffer));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
    }

    if(SUCCEEDED(hr) && (INFINITE != dwTime))
    {
        hr = ValidateResult(StopBuffer(pBuffer, 0, dwTime));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(WaitBuffer(pBuffer, FALSE));
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestNaturalStop
 *
 *  Description:
 *      Tests playing a buffer to completion.
 *
 *  Arguments:
 *      DWORD [in]: iterations.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestNaturalStop"

HRESULT
TestNaturalStop
(
    DWORD                   dwIterations
)
{
    LPDIRECTSOUNDBUFFER     pBuffer = NULL;
    HRESULT                 hr;

    hr = ValidateResult(CreateToneBuffer(0, 8000, 16, 1, 400, 400, 0, &pBuffer));

    while(SUCCEEDED(hr))
    {
        if(INFINITE != dwIterations)
        {
            if(!dwIterations--)
            {
                break;
            }
        }
    
        hr = ValidateResult(PlayBuffer(pBuffer));

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(WaitBuffer(pBuffer, FALSE));
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  TestFlush
 *
 *  Description:
 *      Tests flushing a stream.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestFlush"

HRESULT
TestFlush
(
    void
)
{
    const LPCWAVEFORMATEX   pwfxFormat          = CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    DWORD                   dwPacketSize        = 0x1000;
    LPVOID                  pvAudioData         = NULL;
    DWORD                   dwAudioDataSize     = NULL;
    DWORD                   dwPacketCount       = 0;
    LPDWORD                 padwStatus          = NULL;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    DWORD                   i;

    hr = ValidateResult(CreateStdStream(0, pwfxFormat, 0, &dwPacketSize, NULL, NULL, NULL, &pStream, &pvAudioData, &dwAudioDataSize, &dwPacketCount));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padwStatus, DWORD, dwPacketCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvAudioData;
        xmp.dwMaxSize = dwPacketSize;
        xmp.pdwStatus = padwStatus;
        
        for(i = 0; SUCCEEDED(hr) && (i < dwPacketCount); i++)
        {
            if(i + 1 == dwPacketCount)
            {
                xmp.dwMaxSize = dwAudioDataSize - (dwPacketSize * (dwPacketCount - 1));
            }
            
            hr = ValidateResult(pStream->Process(&xmp, NULL));

            if(SUCCEEDED(hr))
            {
                xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
                xmp.pdwStatus++;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        Sleep(5000);

        hr = ValidateResult(pStream->Flush());
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            if((XMEDIAPACKET_STATUS_SUCCESS != padwStatus[i]) && (XMEDIAPACKET_STATUS_FLUSHED != padwStatus[i]))
            {
                DPF_TEST("Packet %lu status %x", i, padwStatus[i]);
                hr = E_FAIL;
            }
        }
    }

    RELEASE(pStream);
    FREE(padwStatus);
    FREE(pvAudioData);

    return hr;
}


/****************************************************************************
 *
 *  TestPitch
 *
 *  Description:
 *      Tests pitch.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestPitch"

HRESULT
TestPitch
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels
)
{
    static const LONG       alPitch[]   = { DSBPITCH_MIN, 0, DSBPITCH_MAX };
    const LPCWAVEFORMATEX   pwfxFormat  = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannels);
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    HRESULT                 hr;
    DWORD                   i;

    hr = ValidateResult(CreateStdBuffer(dwFlags, pwfxFormat, 0, NULL, &pBuffer, NULL));

    if(SUCCEEDED(hr))
    {
        for(i = 0; (i < NUMELMS(alPitch)) && SUCCEEDED(hr); i++)
        {
            DPF_TEST("Pitch %d", alPitch[i]);
            
            hr = ValidateResult(pBuffer->SetPitch(alPitch[i]));

            if(SUCCEEDED(hr))
            {
                hr = ValidateResult(PlayBuffer(pBuffer, DSBPLAY_LOOPING));
            }

            if(SUCCEEDED(hr))
            {
                Sleep(2000);
            }
        }
    }

    RELEASE(pBuffer);

    return hr;
}


/****************************************************************************
 *
 *  StressPlayStop
 *
 *  Description:
 *      Stresses calling Play and Stop.
 *
 *  Arguments:
 *      DWORD [in]: time to test, in ms.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "StressPlayStop"

HRESULT
StressPlayStop
(
    DWORD                       dwFlags,
    DWORD                       dwSourceCount,
    DWORD                       dwNoteOffMin,
    DWORD                       dwNoteOffMax,
    DWORD                       dwTestLength,
    DWORD                       dwStreamCount,
    DWORD                       dwStreamFrequency
)
{
    static const DWORD          DSBSTATUS_PENDINGSTOP   = 0x80000000;
    static const WORD           awSilence[32]           = { 0 };
    const WAVEFORMATEX          wfxSilence              = INIT_PCM_WAVEFORMAT(1, dwStreamFrequency, 16);
    LPDIRECTSOUNDBUFFER         apSourceBuffers[256]    = { NULL };
    DWORD                       adwStatus[256]          = { 0 };
    LPDIRECTSOUNDSTREAM         apStreams[256]          = { NULL };
    LPDIRECTSOUNDBUFFER         pDestBuffer             = NULL;
    DWORD                       dwPlayCount             = 0;
    DWORD                       dwStopCount             = 0;
    DWORD                       dwNoteOffCount          = 0;
    DWORD                       dwNaturalStopCount      = 0;
    DWORD                       dwSubmixCount           = 0;
    DWORD                       dwLoopCount             = 0;
    HRESULT                     hr                      = S_OK;
    DWORD                       dwStartTime;
    DWORD                       dwCurrentTime;
    DWORD                       dwStatus;
    DSCAPS                      dsc;
    DSBUFFERDESC                dsbd;
    DSSTREAMDESC                dssd;
    DSENVELOPEDESC              dseg;
    XMEDIAPACKET                xmp;
    DWORD                       i, z;

    //
    // Set up the envelope description for NoteOff
    //
    
    dseg.dwEG = DSEG_AMPLITUDE;
    dseg.dwMode = DSEG_MODE_HOLD;
    dseg.dwDelay = DSEG_DELAY_DEFAULT;
    dseg.dwAttack = DSEG_ATTACK_DEFAULT;
    dseg.dwHold = DSEG_HOLD_DEFAULT;
    dseg.dwDecay = DSEG_DECAY_DEFAULT;
    dseg.dwRelease = DSEG_RELEASE_DEFAULT;
    dseg.dwSustain = DSEG_SUSTAIN_DEFAULT;
    dseg.lPitchScale = DSEG_PITCHSCALE_DEFAULT;
    dseg.lFilterCutOff = DSEG_FILTERCUTOFF_DEFAULT;

    //
    // Create the submix buffer
    //

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_MIXIN;

    hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pDestBuffer));

    //
    // Create interference streams
    //

    if(SUCCEEDED(hr) && dwStreamCount)
    {
        DPF_TEST("Creating %lu interference streams", dwStreamCount);

        ZeroMemory(&dssd, sizeof(dssd));

        dssd.lpwfxFormat = (LPWAVEFORMATEX)&wfxSilence;
        dssd.dwMaxAttachedPackets = 2;
        dssd.lpfnCallback = ResubmitPacketCallback;
        
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = (LPVOID)awSilence;
        xmp.dwMaxSize = sizeof(awSilence);
        xmp.pContext = &xmp;

        for(i = 0; (i < dwStreamCount) && SUCCEEDED(hr); i++)
        {
            dssd.lpvContext = &apStreams[i];

            hr = ValidateResult(DirectSoundCreateStream(&dssd, &apStreams[i]));

            if(SUCCEEDED(hr))
            {
                hr = PauseStream(apStreams[i], TRUE);
            }

            for(z = 0; (z < dssd.dwMaxAttachedPackets) && SUCCEEDED(hr); z++)
            {
                hr = ValidateResult(apStreams[i]->Process(&xmp, NULL));
            }

            if(SUCCEEDED(hr))
            {
                hr = PauseStream(apStreams[i], FALSE);
            }
        }
    }

    //
    // Create source buffers
    //
    
    if(SUCCEEDED(hr))
    {
        hr = GetDirectSoundCaps(&dsc);
    }

    if(SUCCEEDED(hr))
    {
        dwSourceCount = min(dwSourceCount, dsc.dwFree2DBuffers + dsc.dwFree3DBuffers);

        DPF_TEST("Creating %lu buffers", dwSourceCount);

        for(i = 0; (i < dwSourceCount) && SUCCEEDED(hr); i++)
        {
            hr = ValidateResult(CreateToneBuffer(dwFlags, 32000, 16, 1, 500, 0, 0, &apSourceBuffers[i]));
        }
    }

    //
    // Save the current time
    //

    if(SUCCEEDED(hr))
    {
        dwStartTime = GetTickCount();
    }

    //
    // Enter the main loop
    //

    while(SUCCEEDED(hr))
    {
        DirectSoundDoWork();

        //
        // Check the current time
        //
        
        if(!((dwCurrentTime = GetTickCount()) % 2000))
        {
            DPF_TEST("%lu plays (%lu submixing, %lu looping), %lu natural stops, %lu forced, %lu note-off", dwPlayCount, dwSubmixCount, dwLoopCount, dwNaturalStopCount, dwStopCount, dwNoteOffCount);

            dwPlayCount = 0;
            dwStopCount = 0;
            dwNoteOffCount = 0;
            dwNaturalStopCount = 0;
            dwSubmixCount = 0;
            dwLoopCount = 0;

            if(INFINITE != dwTestLength)
            {
                if(dwCurrentTime >= dwStartTime + dwTestLength)
                {
                    break;
                }
            }
        }

        //
        // Pick a random buffer and get it's status
        //

        i = rand() % dwSourceCount;

        hr = ValidateResult(apSourceBuffers[i]->GetStatus(&dwStatus));

        if(SUCCEEDED(hr))
        {
            if(adwStatus[i] & DSBSTATUS_PENDINGSTOP)
            {
                if(!(dwStatus & DSBSTATUS_PLAYING))
                {
                    adwStatus[i] = 0;
                }
            }
            else
            {
                adwStatus[i] = dwStatus;
            }
        }

        //
        // Should we play or stop?
        //

        if(SUCCEEDED(hr) && !(adwStatus[i] & DSBSTATUS_PENDINGSTOP))
        {
            if(rand() % 2)
            {
                dwPlayCount++;
            
                //
                // Submix or not?
                //
            
                if(!(adwStatus[i] & DSBSTATUS_PLAYING))
                {
                    if(rand() % 2)
                    {
                        dwSubmixCount++;
                
                        hr = ValidateResult(apSourceBuffers[i]->SetOutputBuffer(pDestBuffer));
                    }
                    else
                    {
                        hr = ValidateResult(apSourceBuffers[i]->SetOutputBuffer(NULL));
                    }
                }

                //
                // Loop or not?
                //

                if(SUCCEEDED(hr)) 
                {
                    if(rand() % 2)
                    {
                        dwLoopCount++;
                
                        hr = ValidateResult(apSourceBuffers[i]->Play(0, 0, DSBPLAY_LOOPING));
                    }
                    else
                    {
                        hr = ValidateResult(apSourceBuffers[i]->Play(0, 0, 0));
                    }
                }
            }
            else
            {
                //
                // Still playing?
                //
            
                if(adwStatus[i] & DSBSTATUS_PLAYING)
                {
                    //
                    // Envelope or not?
                    //

                    if(rand() % 2)
                    {
                        dwNoteOffCount++;
                        
                        dseg.dwRelease = dwNoteOffMin + (rand() % (dwNoteOffMax + 1 - dwNoteOffMin));

                        hr = ValidateResult(apSourceBuffers[i]->SetEG(&dseg));

                        if(SUCCEEDED(hr))
                        {
                            hr = ValidateResult(apSourceBuffers[i]->StopEx(0, DSBSTOPEX_ENVELOPE));
                        }
                    }
                    else
                    {
                        dwStopCount++;

                        hr = ValidateResult(apSourceBuffers[i]->Stop());
                    }

                    if(SUCCEEDED(hr))
                    {
                        adwStatus[i] |= DSBSTATUS_PENDINGSTOP;
                    }
                }
                else
                {
                    dwNaturalStopCount++;
                }
            }
        }
    }

    for(i = 0; i < dwSourceCount; i++)
    {
        RELEASE(apSourceBuffers[i]);
    }

    for(i = 0; i < dwStreamCount; i++)
    {
        RELEASE(apStreams[i]);
    }

    RELEASE(pDestBuffer);

    return hr;
}    


/****************************************************************************
 *
 *  FindFrequencyRange
 *
 *  Description:
 *      Insert description text here.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FindFrequencyRange"

HRESULT
FindFrequencyRange
(
    void
)
{
    LONG                    lPitch;
    DWORD                   i;
    
    for(i = 48000; i > 0; i--)
    {
        if((lPitch = XAudioCalculatePitch(i)) < DSBPITCH_MIN)
        {
            DPF_TEST("Lower %lu (pitch %ld)", i + 1, lPitch);
            break;
        }
    }

    for(i = 48000; ; i++)
    {
        if((lPitch = XAudioCalculatePitch(i)) > DSBPITCH_MAX)
        {
            DPF_TEST("Upper %lu (pitch %ld)", i - 1, lPitch);
            break;
        }
    }

    return DS_OK;
}


/****************************************************************************
 *
 *  TestDeltaPanic
 *
 *  Description:
 *      Main test function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ****************************************************************************/

#if 0

#undef DPF_FNAME
#define DPF_FNAME "TestDeltaPanic"

HRESULT
TestDeltaPanic
(
    void
)
{
    LPDIRECTSOUNDBUFFER     pToneBuffer     = NULL;
    HRESULT                 hr;

    hr = CreateToneBuffer(0, 8000, 8, 1, 500, 0, 0, &pToneBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pToneBuffer->SetVolume(-2400);
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pToneBuffer, DSBPLAY_LOOPING);
    }
    
    while(SUCCEEDED(hr))
    {

#ifdef DEBUG

        g_fDirectSoundSimulateDeltaPanic = TRUE;

#endif // DEBUG

        hr = PlayOneShotBuffer(0, WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 1, DSMIXBIN_FXSEND_0);
    }

    RELEASE(pToneBuffer);

    return hr;
}

#endif


/****************************************************************************
 *
 *  TestTimeStampedPackets
 *
 *  Description:
 *      Tests stream packets with a timestamp.
 *
 *  Arguments:
 *      DWORD [in]: delay between packets, in milliseconds.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestTimeStampedPackets"

HRESULT
TestTimeStampedPackets
(
    DWORD                   dwDelay
)
{
    static const DWORD      dwPacketCount                   = 2;
    const LPCWAVEFORMATEX   pwfxFormat                      = CreateFormat(WAVE_FORMAT_PCM, 8000, 16, 1);
    const DWORD             dwBufferSize                    = pwfxFormat->nAvgBytesPerSec * 4;
    LPVOID                  pvPacketData                    = NULL;
    LPDIRECTSOUNDSTREAM     pStream                         = NULL;
    DWORD                   adwStatus[dwPacketCount];
    REFERENCE_TIME          rtPacketLength;
    REFERENCE_TIME          artTimeStamps[dwPacketCount];
    DSSTREAMDESC            dssd;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    DWORD                   i;

    ZeroMemory(&dssd, sizeof(dssd));

    dssd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
    dssd.dwMaxAttachedPackets = dwPacketCount;

    hr = ValidateResult(DirectSoundCreateStream(&dssd, &pStream));

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvPacketData, BYTE, dwBufferSize);
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvPacketData, dwBufferSize, pwfxFormat->nSamplesPerSec, pwfxFormat->wBitsPerSample, pwfxFormat->nChannels, 500);

        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvPacketData;
        xmp.dwMaxSize = dwBufferSize;

        rtPacketLength = ((REFERENCE_TIME)dwBufferSize * 10000000i64) / (REFERENCE_TIME)pwfxFormat->nAvgBytesPerSec;
        rtPacketLength += (REFERENCE_TIME)dwDelay * 10000i64;
        
        for(i = 0; (i < dwPacketCount) && SUCCEEDED(hr); i++)
        {
            artTimeStamps[i] = -(rtPacketLength * i);

            xmp.pdwStatus = &adwStatus[i];
            xmp.prtTimestamp = &artTimeStamps[i];

            hr = ValidateResult(pStream->Process(&xmp, NULL));
        }
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < dwPacketCount; i++)
        {
            while(XMEDIAPACKET_STATUS_PENDING == adwStatus[i])
            {
                DirectSoundDoWork();
            }
        }
    }

    RELEASE(pStream);
    FREE(pvPacketData);

    return hr;
}


/****************************************************************************
 *
 *  TestSetFormat
 *
 *  Description:
 *      Sets format on a buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "TestSetFormat"

HRESULT
TestSetFormat
(
    void
)
{
    static const WAVEFORMATEX           wfxFormat1      = INIT_PCM_WAVEFORMAT(2, 44100, 16);
    static const XBOXADPCMWAVEFORMAT    wfxFormat2      = INIT_XBOX_ADPCM_WAVEFORMAT(1, 22050);
    static const DWORD                  dwDelay         = 2500;
    XFileMediaObject *                  pSrcXmo2        = NULL;
    LPVOID                              pvDataBuffer2   = NULL;
    IDirectSoundBuffer *                pBuffer         = NULL;
    DWORD                               dwLength2;
    HRESULT                             hr;
    
    hr = CreateStdBuffer(0, &wfxFormat1, NULL, NULL, &pBuffer);
    
    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, 0, dwDelay, TRUE, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetBufferData(NULL, 0));
    }
    
    if(SUCCEEDED(hr))
    {
        hr = LoadStdWaveFile(&wfxFormat2.wfx, &pvDataBuffer2, &dwLength2, &pSrcXmo2);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetFormat(&wfxFormat2.wfx));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetBufferData(pvDataBuffer2, dwLength2));
    }

    if(SUCCEEDED(hr))
    {
        hr = PlayBuffer(pBuffer, DSBPLAY_LOOPING);
    }

    if(SUCCEEDED(hr))
    {
        hr = StopBuffer(pBuffer, 0, dwDelay, TRUE, TRUE);
    }

    RELEASE(pBuffer);        
    RELEASE(pSrcXmo2);
    FREE(pvDataBuffer2);

    return hr;
}


/****************************************************************************
 *
 *  TestStarvation
 *
 *  Description:
 *      Tests starving a stream.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      DWORD [in]: packet size, in bytes.
 *      DWORD [in]: 1-in-N chance the stream will starve between packets.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestStarvation"

HRESULT
TestStarvation
(
    DWORD                   dwFlags,
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwPacketSize,
    DWORD                   dwStarvationChance
)
{
    const LPCWAVEFORMATEX   pwfxFormat      = CreateFormat(dwFormatTag, dwSamplesPerSec, dwBitsPerSample, dwChannelCount);
    LPDIRECTSOUNDSTREAM     pStream         = NULL;
    LPVOID                  pvAudioData     = NULL;
    DWORD                   dwAudioDataSize = 0;
    DWORD                   dwPacketCount   = 0;
    LPDWORD                 padwStatus      = NULL;
    BOOL                    fStarve;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    hr = CreateStdStream(dwFlags, pwfxFormat, NULL, &dwPacketSize, NULL, NULL, NULL, &pStream, &pvAudioData, &dwAudioDataSize, &dwPacketCount);

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(padwStatus, DWORD, dwPacketCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvAudioData;
        xmp.dwMaxSize = dwPacketSize;
        xmp.pdwStatus = padwStatus;
    }

    while(SUCCEEDED(hr) && dwPacketCount--)
    {
        if(!dwPacketCount)
        {
            xmp.dwMaxSize = dwAudioDataSize;
        }

        DPF_TEST("Feeding the stream");

        hr = ValidateResult(pStream->Process(&xmp, NULL));

        if(SUCCEEDED(hr))
        {
            fStarve = !(rand() % dwStarvationChance);
            
            if(!dwPacketCount || fStarve)
            {
                if(fStarve)
                {
                    DPF_TEST("Starving the stream");
                }

                while(XMEDIAPACKET_STATUS_PENDING == *xmp.pdwStatus)
                {
                    DirectSoundDoWork();
                }
            }
        }

        xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
        
        xmp.pdwStatus++;

        dwAudioDataSize -= xmp.dwMaxSize;
    }

    RELEASE(pStream);

    FREE(pvAudioData);
    FREE(padwStatus);

    return hr;
}


/****************************************************************************
 *
 *  TestWaveBundler
 *
 *  Description:
 *      Test the Wave Bundler tool.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestWaveBundler"

HRESULT
TestWaveBundler
(
    LPCSTR                  pszBank,
    DWORD                   dwEntryCount
)
{
    LPDIRECTSOUNDBUFFER     pBuffer     = NULL;
    CWaveBankReader         WaveBank;
    DSBUFFERDESC            dsbd;
    WAVEBANKSECTIONDATA     SectionData;
    WAVEBANKUNIWAVEFORMAT   wfx;
    WAVEBANKENTRYREGION     PlayRegion;
    WAVEBANKENTRYREGION     LoopRegion;
    DWORD                   dwSize;
    BOOL                    fMapped;
    HRESULT                 hr;
    DWORD                   i;

    DPF_ENTER();

    DPF_TEST("Opening wave bank %s", pszBank);
    
    hr = ValidateResult(WaveBank.Open(pszBank));

    if(SUCCEEDED(hr))
    {
        WaveBank.GetSectionData(&SectionData);
    }

    if(SUCCEEDED(hr))
    {  
        ASSERT(dwEntryCount == SectionData.pHeader->dwEntryCount);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = (LPWAVEFORMATEX)CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);

        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    if(SUCCEEDED(hr))
    {
        dwSize = SectionData.dwDataSize;

        hr = ClampBufferSize(&dwSize);
    }

    if(SUCCEEDED(hr))
    {
        if(fMapped = (dwSize == SectionData.dwDataSize))
        {
            hr = ValidateResult(pBuffer->SetBufferData(SectionData.pvData, SectionData.dwDataSize));

            if(SUCCEEDED(hr))
            {
                DPF_TEST("Entire bank mapped.  Using SetPlayRegion");
            }
        }
        else
        {
            DPF_TEST("Bank too big to map.  Using SetBufferData for each element");
        }
    }

    for(i = 0; (i < dwEntryCount) && SUCCEEDED(hr); i++)
    {
        WaveBankExpandFormat(&SectionData.paMetaData[i].Format, &wfx);
        
        PlayRegion = SectionData.paMetaData[i].PlayRegion;
        LoopRegion = SectionData.paMetaData[i].LoopRegion;
        
        DPF_TEST("Loading entry %lu (%s, %lu.%3.3lu kHz, %lu-bit, %lu-channel, offset %lu, length %lu)", i, (WAVE_FORMAT_XBOX_ADPCM == wfx.WaveFormatEx.wFormatTag) ? "ADPCM" : "PCM", wfx.WaveFormatEx.nSamplesPerSec / 1000, wfx.WaveFormatEx.nSamplesPerSec % 1000, wfx.WaveFormatEx.wBitsPerSample, wfx.WaveFormatEx.nChannels, PlayRegion.dwStart, PlayRegion.dwLength);
        
        hr = ValidateResult(pBuffer->SetFormat(&wfx.WaveFormatEx));

        if(SUCCEEDED(hr))
        {
            if(fMapped)
            {
                hr = ValidateResult(pBuffer->SetPlayRegion(PlayRegion.dwStart, PlayRegion.dwLength));
            }
            else
            {
                ClampBufferSize(&PlayRegion.dwLength);
            
                hr = ValidateResult(pBuffer->SetBufferData((LPBYTE)SectionData.pvData + PlayRegion.dwStart, PlayRegion.dwLength));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = ValidateResult(pBuffer->SetLoopRegion(LoopRegion.dwStart, LoopRegion.dwLength));
        }

        if(SUCCEEDED(hr))
        {
            hr = PlayBuffer(pBuffer, LoopRegion.dwLength ? DSBPLAY_LOOPING : 0);
        }

        if(SUCCEEDED(hr) && LoopRegion.dwLength)
        {
            Sleep(PlayRegion.dwLength * 2 * 1000 / wfx.WaveFormatEx.nAvgBytesPerSec);

            hr = PlayBuffer(pBuffer);
        }

        if(SUCCEEDED(hr))
        {
            hr = WaitBuffer(pBuffer, FALSE);
        }
    }

    RELEASE(pBuffer);

    DPF_LEAVE_HRESULT(hr);
    
    return hr;
}


/****************************************************************************
 *
 *  TestReleasePausedStream
 *
 *  Description:
 *      Tests releasing a paused stream.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestReleasePausedStream"

HRESULT
TestReleasePausedStream
(
    void
)
{
    LPDIRECTSOUNDSTREAM     pStream = NULL;
    DSSTREAMDESC            dssd;
    HRESULT                 hr;
    
    DPF_ENTER();

    ZeroMemory(&dssd, sizeof(dssd));

    dssd.lpwfxFormat = (LPWAVEFORMATEX)CreateFormat(WAVE_FORMAT_PCM, 44100, 16, 2);
    dssd.dwMaxAttachedPackets = 1;

    hr = DirectSoundCreateStream(&dssd, &pStream);

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pStream->Pause(DSSTREAMPAUSE_PAUSE));
    }

    RELEASE(pStream);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  TestTimedStreamResume
 *
 *  Description:
 *      Tests resuming a paused stream using a timestamp.
 *
 *  Arguments:
 *      DWORD [in]: delay, in ms.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestTimedStreamResume"

HRESULT
TestTimedStreamResume
(
    DWORD                   dwDelay
)
{
    const LPCWAVEFORMATEX   pwfxFormat          = CreateFormat(WAVE_FORMAT_PCM, 48000, 16, 2);
    const REFERENCE_TIME    rtTimestamp         = (REFERENCE_TIME)dwDelay * -10000i64;
    LPDIRECTSOUNDSTREAM     pStream             = NULL;
    LPVOID                  pvAudioData         = NULL;
    DWORD                   dwPacketSize        = 0x4000;
    HRESULT                 hr;

    hr = CreateStdQueuedStream(0, pwfxFormat, NULL, &dwPacketSize, NULL, NULL, &pStream, &pvAudioData);

    if(SUCCEEDED(hr))
    {
        DPF_TEST("Setting Pause command for %lu ms in the future", dwDelay);
        
        hr = ValidateResult(pStream->PauseEx(rtTimestamp, DSSTREAMPAUSE_RESUME));
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitStream(pStream, TRUE);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaitStream(pStream, FALSE);
    }

    RELEASE(pStream);
    FREE(pvAudioData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  TestDirectSound
 *
 *  Description:
 *      Main test function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestDirectSound"

HRESULT
TestDirectSound
(
    void
)
{
    HRESULT                 hr  = DS_OK;

    DirectSoundUsePan3D();

    //
    // Create the DirectSound object
    //

    hr = ValidateResult(DirectSoundCreate(NULL, &g_pDirectSound, NULL));

    //
    // Load the default effects image
    //

    if(SUCCEEDED(hr))
    {
        hr = LoadEffectsImage("dsstdfx", XAUDIO_DOWNLOADFX_XBESECTION);
    }
    
    //
    // Test away...
    //

    // BEGIN_TEST(PlayOneShotBuffer)(0, WAVE_FORMAT_PCM, 48000, 16, 1);
    // BEGIN_TEST(PlayOneShotBuffer)("t:\\media\\audio\\pcm\\48k16bs.aif");
    // BEGIN_TEST(PlayOneShotStream)(0, WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 1, 0x4000);
    // BEGIN_TEST(PlayToneBuffer)(0, 8000, 8, 1, 400, INFINITE);
    // BEGIN_TEST(Test3d)(0.0f, 0.0f, 0.0f, 5.0f, -72.0f, INFINITE);
    // BEGIN_TEST(TestMultipleBuffers)(WAVE_FORMAT_PCM);
    // BEGIN_TEST(TestMultipleStreams)(WAVE_FORMAT_PCM, 0x4000);
    // BEGIN_TEST(TestSequentialBuffers)(WAVE_FORMAT_PCM);
    // BEGIN_TEST(TestNotifies)(WAVE_FORMAT_PCM, 22050, 16, 1, 20, FALSE);
    // BEGIN_TEST(TestBufferOffsets)(WAVE_FORMAT_PCM, 48000, 16, 2, 0.0f, 1.0f, 0.5f, 1.0f, TRUE);
    // BEGIN_TEST(TestSubMix)(TRUE, WAVE_FORMAT_PCM);
    // BEGIN_TEST(TestDLS)(WAVE_FORMAT_PCM, 44100, 16, 1);
    // BEGIN_TEST(TestSurroundEncoder)(WAVE_FORMAT_PCM, 44100, 16);
    // BEGIN_TEST(TestSgeSharing)();
    // BEGIN_TEST(TestSgeHeap)();
    // BEGIN_TEST(Test256Voices)();
    // BEGIN_TEST(TestStop)(WAVE_FORMAT_PCM, 44100, 16, 1);
    // BEGIN_TEST(TestFrequency)(DSBCAPS_CTRL3D, WAVE_FORMAT_PCM, 22050, 16, 1, 5000);
    // BEGIN_TEST(TestDiscontinuity)(0, WAVE_FORMAT_PCM, 22050, 16, 1, 0x4000, TRUE);
    // BEGIN_TEST(TestDeferredCommandRelease)();
    // BEGIN_TEST(TestHeadroom)();
    // BEGIN_TEST(TestI3DL2Listener)();
    // BEGIN_TEST(TestMultiChannel)(44100, 8, 1);
    // BEGIN_TEST(TestMultiChannel2)(6);
    // BEGIN_TEST(TestMultiChannel3)(6);
    // BEGIN_TEST(TestReverb)();
    // BEGIN_TEST(StressPlayStop)(0, -1, 1, 50, INFINITE, 0, 8000);
    // BEGIN_TEST(TestReleaseEnvelope)();
    // BEGIN_TEST(TestNaturalStop)(1);
    // BEGIN_TEST(TestFlush)();
    // BEGIN_TEST(TestPitch)(0, WAVE_FORMAT_PCM, 44100, 16, 1);
    // BEGIN_TEST(FindFrequencyRange)();
    // BEGIN_TEST(TestTimeStampedPackets)(5000);
    // BEGIN_TEST(TestDeltaPanic)();
    // BEGIN_TEST(TestSetFormat)();
    // BEGIN_TEST(TestStarvation)(0, WAVE_FORMAT_XBOX_ADPCM, 48000, 16, 1, 0x4000, 3);
    // BEGIN_TEST(TestStreamStop)(DSSTREAMFLUSHEX_IMMEDIATE, WAVE_FORMAT_PCM, 44100, 16, 2, 0x4000);
    // BEGIN_TEST(TestStreamStop)(DSSTREAMFLUSHEX_ASYNC, WAVE_FORMAT_PCM, 44100, 16, 2, 0x4000);
    // BEGIN_TEST(TestStreamStop)(DSSTREAMFLUSHEX_ASYNC | DSSTREAMFLUSHEX_ENVELOPE, WAVE_FORMAT_PCM, 44100, 16, 2, 0x4000);
    // BEGIN_TEST(TestReleasePausedStream)();
    BEGIN_TEST(TestTimedStreamResume)(10000);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\pcm.xwb", WAVEBANK_PCM_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\pcmaiff.xwb", WAVEBANK_PCMAIFF_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\adpcm.xwb", WAVEBANK_ADPCM_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\compress.xwb", WAVEBANK_COMPRESS_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\8bit.xwb", WAVEBANK_8BIT_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\loop.xwb", WAVEBANK_LOOP_ENTRY_COUNT);
    // BEGIN_TEST(TestWaveBundler)("t:\\media\\audio\\mixed.xwb", WAVEBANK_MIXED_ENTRY_COUNT);

    //
    // Release the DirectSound object
    //

    RELEASE(g_pDirectSound);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\testboot\main.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       main.cpp
 *  Content:    insert content description here.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/19/01    dereks  Created.
 *
 ****************************************************************************/

#include "xtl.h"
#include "xdbg.h"

EXTERN_C PVOID InitBootSound();
EXTERN_C VOID ReleaseBootSound(PVOID pCore);

DWORD g_dwBreak = 0;

///
/// Set up necessary types
/// 

typedef short* LPSHORT;

///
/// Setup the frequency, and define PI
///

static const double FREQ = 2.55;
static const double PI = 3.1415926535;

///
/// Scaling factors
///
/// ISCALE is used to convert an interger [0, 44099] to a double [0, 2PI]
/// DATASCALE is used to conver a double [-1.0, 1.0] to an integer [-32767, 32767]

static const double ISCALE = 2.0 * PI / 48000.0;
static const double DATASCALE = 32767.0 / 1.0;


HRESULT PlaySineWave(double Frequency, DWORD dwMixBins,LPDIRECTSOUNDBUFFER     *pBuffer )
{

	///
	/// create a dsound buffer and a data buffer
	///

    HRESULT hr = S_OK;
	LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
	LPSHORT pData = NULL;

	///
	/// place to hold the number of bytes allocated by dsound
	///

	DWORD dwBytes = 0;

	///
	/// allocate space for calculate argument to sin, return value from sine, and actual integer value
	///

	double dArg = 0.0;
	double dSinVal = 0.0;
	SHORT sVal = 0;
   
	///
	/// allocate the dsound buffer description and the wave format
	///

	DSBUFFERDESC dsbd;
	WAVEFORMATEX wfx;

	///
	/// It's always safe to zero out stack allocated structs
	///

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( DSBUFFERDESC ) );

	///
	/// setup the waveformat description to be PCM, 44100hz, 16bit, mono
    ///

	wfx.cbSize = 0;
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.nSamplesPerSec = 48000;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	///
	/// setup the dsound buffer description with the waveformatex
	///

	dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
	dsbd.dwFlags = 0;
	dsbd.dwSize = sizeof( DSBUFFERDESC );
	dsbd.lpwfxFormat = &wfx;
    dsbd.dwMixBinMask = dwMixBins;

	/// 
	/// Create the dsound buffer
	///

	hr = DirectSoundCreateBuffer( &dsbd, &pDSBuffer );

	///
	/// continue forever (or until an error occurs)
	///

	if ( SUCCEEDED( hr ) )
	{

		///
		/// get a buffer from dsound using lock
		///

		hr = pDSBuffer->Lock( 0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0 );

		///
		/// go through the buffer 2 bytes (1 short) at a time
		///

		for( DWORD i = 0; SUCCEEDED( hr ) && i < dsbd.dwBufferBytes / 2; i++ )
		{	
			///
			/// calculate the sin value
			///

			dArg = (double) i * ISCALE;
			dSinVal = sin( Frequency * dArg );
			sVal = (SHORT) ( dSinVal * DATASCALE );

			///
			/// copy the value into the dsound buffer
			///

			pData[i] = sVal;
		}

    }
    
	///
	/// start the dsound buffer playing in a loop mode
	///

	if ( SUCCEEDED( hr ) )
	{
		hr = pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );
        *pBuffer = pDSBuffer;
	}



    //
    // leave with the buffer still playing..
    //

    return hr;
}

void __cdecl
main
(
    void
)
{
    HRESULT                 hr;
    LPDIRECTSOUNDBUFFER pBuffer;
    LPDIRECTSOUNDBUFFER pOscBuffer;

    hr = PlaySineWave(1000,DSMIXBIN_FXSEND_1, &pBuffer);

    if (FAILED(hr)) {
        _asm int 3;
    }

    hr = PlaySineWave(3,DSMIXBIN_FXSEND_2, &pOscBuffer);

    if (FAILED(hr)) {
        _asm int 3;
    }

    DWORD i =0,dwValue;
    while(TRUE) {

        dwValue = i;
        if (i%410000 == 0) {
            DbgPrint("dwValue %d\n",dwValue);
        }
        
        i++;

        if (g_dwBreak == 1) {
            break;
        }

        if (g_dwBreak == 2) {

            *(PDWORD)(0xFE830000+0x14) = 1;
        }

    }

    pBuffer->Release();
    pOscBuffer->Release();
    while(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\testdsp\testds.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       testds.cpp
 *  Content:    DirectSound test functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/08/00    dereks  Created.
 *  04/2001   georgioc  cut and paste/delete from testds, for testing dsp stuff
 *
 ****************************************************************************/

#include "dsoundi.h"
#include "c:\xboxbins\dsp\reverb_2ch.h"
#include "C:\xbox\private\windows\directx\dsound\tools\internal\DSP\rvbparam\rvbformat.h"

// #define FIX_BUFFER_SIZE 0x1004
#define STALL_ON_START
#define BREAK_ON_START
// #define ALLOC_ALIGNED
#define ALLOC_CONTIGUOUS

#ifdef STALL_ON_START

BOOL fTestMe;

#endif // STALL_ON_START

BOOL fBreakTest;

static const float pi = 3.1415f;


#define DPF_TEST DPF_ABSOLUTE

__inline HRESULT
ValidateResult
(
    HRESULT                 hr
)
{
    ASSERT(SUCCEEDED(hr));

    return hr;
}


__inline HRESULT
ValidateBool
(
    BOOL                    fSuccess
)
{
    ASSERT(fSuccess);

    return fSuccess ? S_OK : E_FAIL;
}


__inline HRESULT
ValidatePtr
(
    LPVOID                  pv
)
{
    ASSERT(pv);

    return pv ? S_OK : E_OUTOFMEMORY;
}


LPVOID
__Malloc
(
    DWORD                   dwSize
)
{

#ifdef ALLOC_CONTIGUOUS

#ifdef ALLOC_ALIGNED

    return MmAllocateContiguousMemoryEx(dwSize, 0, 0xFFFFFFFF, 4, PAGE_READWRITE);

#else // ALLOC_ALIGNED

    return MmAllocateContiguousMemoryEx(dwSize, 0, 0xFFFFFFFF, PAGE_SIZE, PAGE_READWRITE);

#endif // ALLOC_ALIGNED

#else // ALLOC_CONTIGUOUS

    DWORD                   dwAllocSize;
    DWORD                   dwOffset;
    LPVOID                  pvBuffer;
    DWORD                   dwOldProtect;
    BOOL                    fProtect;

    dwAllocSize = dwSize + PAGE_SIZE + PAGE_SIZE - 1;

#ifndef ALLOC_ALIGNED

    dwAllocSize += sizeof(DWORD);

#endif // ALLOC_ALIGNED

    dwAllocSize /= PAGE_SIZE;
    dwAllocSize *= PAGE_SIZE;

    if(pvBuffer = VirtualAlloc(NULL, dwAllocSize, MEM_COMMIT, PAGE_READWRITE))
    {
        fProtect = VirtualProtect((LPBYTE)pvBuffer + dwAllocSize - PAGE_SIZE, PAGE_SIZE, PAGE_NOACCESS, &dwOldProtect);
        ASSERT(fProtect);

#ifndef ALLOC_ALIGNED

        dwOffset = dwAllocSize - dwSize - PAGE_SIZE;

        pvBuffer = (LPBYTE)pvBuffer + dwOffset;

        *((LPDWORD)pvBuffer - 1) = dwOffset;

#endif // ALLOC_ALIGNED

    }

    return pvBuffer;

#endif // ALLOC_CONTIGUOUS

}

#define MALLOC(a) \
    __Malloc(a)


void
__Free
(
    LPVOID *                ppvBuffer
)
{

    LPVOID                  pvBuffer    = *ppvBuffer;
    DWORD                   dwOffset;

    *ppvBuffer = NULL;

    if(pvBuffer)
    {

#ifdef ALLOC_CONTIGUOUS

        MmFreeContiguousMemory(pvBuffer);

#else // ALLOC_CONTIGUOUS

#ifdef ALLOC_ALIGNED

        dwOffset = 0;

#else // ALLOC_ALIGNED

        dwOffset = *((LPDWORD)pvBuffer - 1);

#endif // ALLOC_ALIGNED
    
        VirtualFree((LPBYTE)pvBuffer - dwOffset, 0, MEM_RELEASE);

#endif // ALLOC_CONTIGUOUS

    }
}

#define FREE(p) \
    __Free((LPVOID *)&(p))


HRESULT TestMe(void);


/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl
main
(
    void
)
{
    HRESULT                 hr;
    
    XInitDevices(0, NULL);

    while(TRUE)
    {

#ifdef STALL_ON_START

        fTestMe = FALSE;

        DPF_TEST("");
        DPF_TEST("******************************************************************************");
        DPF_TEST("");
        DPF_TEST("Enter the following into the debugger in order to start testing:");
        DPF_TEST("ed testds!fTestMe 1;g");
        DPF_TEST("");
        DPF_TEST("******************************************************************************");
        DPF_TEST("");

        while(!fTestMe);

#endif // STALL_ON_START

#ifdef BREAK_ON_START

        BREAK();

#endif // BREAK_ON_START

        fBreakTest = FALSE;

        hr = TestMe();

        if(SUCCEEDED(hr))
        {
            DPF_TEST("Test successful");
        }
        else
        {
            DPF_TEST("Test failed");
        }
    }
}


/****************************************************************************
 *
 *  GenerateTone
 *
 *  Description:
 *      Generates a 16-bit sine-wave tone.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *      DWORD [in]: playback frequency.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
void
GenerateTone
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    DWORD                   dwFrequency
)
{
    static const double     freq            = 750.0;
    static const double     datascale       = 32767.0;
    const double            iscale          = 2.0 * pi * (double)(dwFrequency - 1);
    short * const           psBuffer        = (short *)pvBuffer;
    const DWORD             dwSampleCount   = dwBufferSize / 2;
    DWORD                   i;

    for(i = 0; i < dwSampleCount; i++)
    {
        psBuffer[i] = (short)(sin(freq * ((double)i * iscale)) * datascale);
    }
}


/****************************************************************************
 *
 *  GenerateNoise
 *
 *  Description:
 *      Generates white noise.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
void
GenerateNoise
(
    DWORD                   dwChannels,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize
)
{
    short *                 psBuffer    = (short *)pvBuffer;
    DWORD                   dwSamples   = dwBufferSize / 2;

    while(dwSamples--)
    {
        *psBuffer++ = (short)((rand() % 0xFFFF) - 0x7FFF);
    }
}


/****************************************************************************
 *
 *  ReadXMO
 *
 *  Description:
 *      Reads data from an XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size.
 *      LPDWORD [out]: amount read.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
ReadXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwRead
)
{
    HANDLE                  hCompletionEvent    = NULL;
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    //
    // Check to see if the XMO is ASYNC.  It's massive overhead to do this
    // every time we want to read, but hey, it's test code.
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    //
    // If we are ASYNC, create an event so we can simulate SYNC.
    //
    
    if(SUCCEEDED(hr) && (xmi.dwFlags & XMO_STREAMF_OUTPUT_ASYNC))
    {
        hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Read from the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvBuffer;
        xmp.dwMaxSize = dwBufferSize,
        xmp.pdwCompletedSize = pdwRead;
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pMediaObject->Process(NULL, &xmp));
    }

    //
    // Wait for processing to complete
    //

    if(SUCCEEDED(hr) && hCompletionEvent)
    {
        WaitForSingleObject(hCompletionEvent, INFINITE);
    }

    //
    // Clean up
    //

    CLOSE_HANDLE(hCompletionEvent);

    return hr;
}

/****************************************************************************
 *
 *  LoadWaveFile
 *
 *  Description:
 *      Loads a wave file into an XMO object.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      LPCWAVEFORMATEX [out]: wave file format.
 *      XMediaObject ** [out]: wave file XMO.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
LoadWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    XFileMediaObject **     ppMediaObject
)
{
    DPF_TEST("Loading %s", pszFileName);

    return ValidateResult(XWaveFileCreateMediaObject(pszFileName, ppwfxFormat, ppMediaObject));
}


/****************************************************************************
 *
 *  LoadStdWaveFile
 *
 *  Description:
 *      Loads a "standard" wave file into a CWaveFile object.
 *
 *  Arguments:
 *      CWaveFile * [in]: wave file.
 *      DWORD [in]: sample rate, in Hz
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
LoadStdWaveFile
(
    WORD                    wFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitResolution,
    DWORD                   dwChannelCount,
    LPCWAVEFORMATEX *       ppwfxFormat,
    XFileMediaObject **     ppMediaObject
)
{
    static const LPCSTR     pszParent               = "d:\\media\\audio\\";
    static const LPCSTR     pszPcm                  = "pcm\\";
    static const LPCSTR     pszXboxAdpcm            = "xbadpcm\\";
    static const LPCSTR     pszFileTemplate         = "std\\%uk%ub%ls.wav";
    static const LPCSTR     pszMono                 = "m";
    static const LPCSTR     pszStereo               = "s";
    CHAR                    szFileName[MAX_PATH];

    strcpy(szFileName, pszParent);

    switch(wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            strcat(szFileName, pszPcm);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            strcat(szFileName, pszXboxAdpcm);
            break;

        default:
            DPF_TEST("Unsupported format");
            return E_FAIL;
    }

    sprintf(szFileName + strlen(szFileName), pszFileTemplate, dwSampleRate / 1000, dwBitResolution, (1 == dwChannelCount) ? pszMono : pszStereo);

    return LoadWaveFile(szFileName, ppwfxFormat, ppMediaObject);
}


/****************************************************************************
 *
 *  CreateBufferFromFile
 *
 *  Description:
 *      Creates a sound buffer based on a given wave file.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      XFileMediaObject * [in]: file XMO.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.
 *      LPDWORD [out]: buffer length, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CreateBufferFromFile
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    XFileMediaObject *      pMediaObject,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPDWORD                 pdwDuration     = NULL
)
{
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    HRESULT                 hr              = DS_OK;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    DWORD                   dwLockSize = 0;

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = dwFlags;
    dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;

#ifdef FIX_BUFFER_SIZE

    dsbd.dwBufferBytes = FIX_BUFFER_SIZE;

#else // FIX_BUFFER_SIZE

    hr = ValidateResult(pMediaObject->GetLength(&dsbd.dwBufferBytes));

#endif // FIX_BUFFER_SIZE

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Lock(0, 0, &pvLock, &dwLockSize, NULL, NULL, DSBLOCK_ENTIREBUFFER));
    }

    if(SUCCEEDED(hr))
    {
        hr = ReadXMO(pMediaObject, pvLock, dwLockSize, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;

        if(pdwDuration)
        {
            *pdwDuration = dsbd.dwBufferBytes;
        }
    }
    else
    {
        RELEASE(pBuffer);
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateBufferFromFile
 *
 *  Description:
 *      Creates a sound buffer based on a given wave file.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: buffer creation flags.
 *      REFGUID [in]: 3D algorithm.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CreateBufferFromFile
(
    LPCSTR                  pszFile,
    DWORD                   dwFlags,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPDWORD                 pdwDuration     = NULL
)
{
    XFileMediaObject *      pMediaObject    = NULL;
    LPCWAVEFORMATEX         pwfxFormat      = NULL;
    HRESULT                 hr;

    hr = LoadWaveFile(pszFile, &pwfxFormat, &pMediaObject);

    if(SUCCEEDED(hr))
    {
        hr = CreateBufferFromFile(dwFlags, pwfxFormat, pMediaObject, ppBuffer, pdwDuration);
    }

    RELEASE(pMediaObject);

    return hr;
}


/****************************************************************************
 *
 *  CreateStdSoundBuffer
 *
 *  Description:
 *      Creates a "standard" sound buffer using one of the "standard" wave
 *      files.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: format tag.
 *      DWORD [in]: sample rate, in Hz
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer object.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CreateStdSoundBuffer
(
    DWORD                   dwFlags,
    WORD                    wFormatTag,
    DWORD                   dwSampleRate,
    DWORD                   dwBitResolution,
    DWORD                   dwChannelCount,
    LPDIRECTSOUNDBUFFER *   ppBuffer,
    LPCWAVEFORMATEX *       ppwfxFormat     = NULL,
    LPDWORD                 pdwDuration     = NULL
)
{
    XFileMediaObject *      pMediaObject    = NULL;
    LPCWAVEFORMATEX         pwfxFormat      = NULL;
    HRESULT                 hr;

    hr = LoadStdWaveFile(wFormatTag, dwSampleRate, dwBitResolution, dwChannelCount, &pwfxFormat, &pMediaObject);

    if(SUCCEEDED(hr))
    {
        hr = CreateBufferFromFile(dwFlags, pwfxFormat, pMediaObject, ppBuffer, pdwDuration);
    }

    if(SUCCEEDED(hr) && ppwfxFormat)
    {
        *ppwfxFormat = pwfxFormat;
    }

    RELEASE(pMediaObject);

    return hr;
}

#define IDLE_BUFFER_SIZE    100
#define IDLE_BUFFER_BASE    (0x36000+0x800*sizeof(DWORD)-IDLE_BUFFER_SIZE*sizeof(DWORD)-sizeof(DWORD))
#define DSP_COUNTER_OVERHEAD 5

VOID
DisplayGPDspStats()
{
    int i;
    DWORD dwMin=-1;
    DWORD dwMax=0;
    DWORD dwAvg=0;
    DWORD dwValue;

    PDWORD  pDspYramIdleBuffer = (PDWORD)(0xFE800000+IDLE_BUFFER_BASE);  // BASE mcpx BAR + yram offset

    //
    // get some DSP usage statistics straight form Y-ram and print them out
    //

    dwAvg = 0;
    for (i=0;i<IDLE_BUFFER_SIZE/sizeof(DWORD);i++) {

        dwValue = *(pDspYramIdleBuffer+i)*DSP_COUNTER_OVERHEAD;
        dwAvg += dwValue;
        if (dwValue>dwMax) {
            dwMax=dwValue;
        }

        if (dwValue<dwMin) {
            dwMin=dwValue;
        }
    }

    dwAvg = dwAvg/(IDLE_BUFFER_SIZE/sizeof(DWORD));

    DPF_TEST("GPIdle Cycles: Avg = %d, min = %d, max = %d",dwAvg,dwMin,dwMax);

}

VOID
WaitForAnyButton()
{
    BOOL fButtonPressed = FALSE;
    static DWORD dwPads = 0;
    DWORD dwInsertions, dwRemovals;
    static HANDLE hPads[XGetPortCount()] = { 0 };
    int i;

    dwPads = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    while (!fButtonPressed)
    {

        if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
        {
            DPF_TEST("GetDevicesReturned %x %x",dwInsertions, dwRemovals);
            dwPads |= dwInsertions;
            dwPads &= ~dwRemovals;

            for (i = 0; i < XGetPortCount(); i++)
            {
                if ((1 << i) & dwRemovals)
                {
                    if (NULL != hPads[i])
                    {
                        XInputClose(hPads[i]);
                        hPads[i] = NULL;
                    }
                }

                if ((1 << i) & dwInsertions)
                {
                    if (NULL == hPads[i])
                    {
                        hPads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL);;
                    }
                }
            }
        }

        for (i = 0; i < XGetPortCount(); i++)
        {
            if ((1 << i) & dwPads)
            {
                if (NULL != hPads[i])
                {
                    XINPUT_STATE State;

                    if (ERROR_SUCCESS == XInputGetState(hPads[i], &State))
                    {
                        if ((State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 28) &&
                            (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 28) &&
                            (State.Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_THUMB))
                        {
                            DPF_TEST("DPAD pressed");
                            DisplayGPDspStats();           
                        }
                        else if ((0 != ((XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK) & State.Gamepad.wButtons)) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > 28) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > 28) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] > 28) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] > 28) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] > 28) ||
                                 (State.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] > 28))
                        {
                            fButtonPressed = TRUE;
                            DPF_TEST("Button pressed");
                            DisplayGPDspStats();           

                        }
                    }
                }
            }

        }
    }
}

///
/// Set up necessary types
/// 

typedef short* LPSHORT;

///
/// Setup the frequency, and define PI
///

static const double FREQ = 2.55;
static const double PI = 3.1415926535;

///
/// Scaling factors
///
/// ISCALE is used to convert an interger [0, 44099] to a double [0, 2PI]
/// DATASCALE is used to conver a double [-1.0, 1.0] to an integer [-32767, 32767]

static const double ISCALE = 2.0 * PI / 48000.0;
static const double DATASCALE = 32767.0 / 1.0;

///
/// the main sine player code
///

    
HRESULT PlaySineWave(double Frequency, DWORD dwMixBins,LPDIRECTSOUNDBUFFER     *pBuffer )
{

	///
	/// create a dsound buffer and a data buffer
	///

    HRESULT hr = S_OK;
	LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
	LPSHORT pData = NULL;

	///
	/// place to hold the number of bytes allocated by dsound
	///

	DWORD dwBytes = 0;

	///
	/// allocate space for calculate argument to sin, return value from sine, and actual integer value
	///

	double dArg = 0.0;
	double dSinVal = 0.0;
	SHORT sVal = 0;
   
	///
	/// allocate the dsound buffer description and the wave format
	///

	DSBUFFERDESC dsbd;
	WAVEFORMATEX wfx;

	///
	/// It's always safe to zero out stack allocated structs
	///

	ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
	ZeroMemory( &wfx, sizeof( DSBUFFERDESC ) );

	///
	/// setup the waveformat description to be PCM, 44100hz, 16bit, mono
    ///

	wfx.cbSize = 0;
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 1;
	wfx.nSamplesPerSec = 48000;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = 2;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	///
	/// setup the dsound buffer description with the waveformatex
	///

	dsbd.dwBufferBytes = wfx.nAvgBytesPerSec;
	dsbd.dwFlags = 0;
	dsbd.dwSize = sizeof( DSBUFFERDESC );
	dsbd.lpwfxFormat = &wfx;
    dsbd.dwMixBinMask = dwMixBins;

	/// 
	/// Create the dsound buffer
	///

	hr = DirectSoundCreateBuffer( &dsbd, &pDSBuffer );

	///
	/// continue forever (or until an error occurs)
	///

	if ( SUCCEEDED( hr ) )
	{

		///
		/// get a buffer from dsound using lock
		///

		hr = pDSBuffer->Lock( 0, dsbd.dwBufferBytes, (LPVOID*) &pData, &dwBytes, NULL, NULL, 0 );

		///
		/// go through the buffer 2 bytes (1 short) at a time
		///

		for( DWORD i = 0; SUCCEEDED( hr ) && i < dsbd.dwBufferBytes / 2; i++ )
		{	
			///
			/// calculate the sin value
			///

			dArg = (double) i * ISCALE;
			dSinVal = sin( Frequency * dArg );
			sVal = (SHORT) ( dSinVal * DATASCALE );

			///
			/// copy the value into the dsound buffer
			///

			pData[i] = sVal;
		}

    }
    
	///
	/// start the dsound buffer playing in a loop mode
	///

	if ( SUCCEEDED( hr ) )
	{
		hr = pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );
        *pBuffer = pDSBuffer;
	}



    //
    // leave with the buffer still playing..
    //

    return hr;
}

HRESULT
PlayLoopingBuffer
(
    BOOL                    fUseCliffWaves,
    WORD                    wFormatTag,
    DWORD                   dwSampleRate,
    WORD                    wBitsPerSample,
    WORD                    wChannelCount,
    LPDIRECTSOUNDBUFFER     *pBuffer
)
{

    HRESULT hr = S_OK;
    LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
    DWORD dwDuration;

    if (fUseCliffWaves) {

        hr = CreateBufferFromFile("d:\\media\\audio\\pcm\\CleanGuitarArpeggios.wav",
                                  0,
                                  &pDSBuffer,
                                  &dwDuration);

    } else {

        hr = CreateStdSoundBuffer(0, wFormatTag, dwSampleRate, wBitsPerSample, wChannelCount, &pDSBuffer);

    }

    if (SUCCEEDED(hr)) {

        hr = pDSBuffer->SetLoopRegion( 0, 0);

    }

    if (SUCCEEDED(hr)) {

        hr = pDSBuffer->Play( 0, 0, DSBPLAY_LOOPING );

    }

    *pBuffer = pDSBuffer;

    return hr;
}

HRESULT
DownloadScratch(PCHAR pszScratchFile)
{

    LPDIRECTSOUND           pDirectSound;
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer;
    DWORD err;
    HRESULT hr=S_OK;

    UCHAR data[4] = {0,1,2,3};
    LPDSEFFECTIMAGEDESC pDesc;

    //
    // open scratch image file generated by xps2 tool
    //


    hFile = CreateFile(
        pszScratchFile,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        fprintf(stderr,"\n Failed to open the dsp image file.Error 0x%x\n", err);
        hr = HRESULT_FROM_WIN32(err);

    }

    if (SUCCEEDED(hr)) {

        dwSize = SetFilePointer(hFile, 0, NULL, FILE_END);              
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        pBuffer = new BYTE[dwSize];
        ASSERT(pBuffer);

        DWORD dwBytesRead;
        BOOL bResult = ReadFile(hFile,
            pBuffer,
            dwSize,
            &dwBytesRead,
            0);
        
        if (!bResult) {
            
            err = GetLastError();
            fprintf(stderr,"\n Failed to open the dsp image file.Error 0x%x\n", err);
            hr = HRESULT_FROM_WIN32(err);
    
        }

    }

    if (SUCCEEDED(hr)) {

        //
        // call dsound api to download the image..
        //

        hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

        if (SUCCEEDED(hr)) {

            hr = ValidateResult(pDirectSound->DownloadEffectsImage(pBuffer,
                                               dwSize,
                                               NULL,
                                               &pDesc));
        }

    }

    if (hFile) {
        CloseHandle(hFile);
    }
    
    delete [] pBuffer;


    return hr;
}

HRESULT LoadReverbParameters()
{

    LPDIRECTSOUND           pDirectSound;
    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer=NULL;
    DWORD err;
    HRESULT hr=S_OK;

    UCHAR data[4] = {0,1,2,3};
    LPDSEFFECTIMAGEDESC pDesc;
    PREVERB_EFFECT_PARAMS pRvbData;

    hFile = CreateFile(
        "d:\\media\\hangar.bin",
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE) {

        err = GetLastError();
        hr = HRESULT_FROM_WIN32(err);
        _asm int 3;

    }

    if (SUCCEEDED(hr)) {

        dwSize = SetFilePointer(hFile, 0, NULL, FILE_END);              
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
    
        pBuffer = new BYTE[dwSize];

        DWORD dwBytesRead;
        BOOL bResult = ReadFile(hFile,
            pBuffer,
            dwSize,
            &dwBytesRead,
            0);
        
        if (!bResult) {
            
            err = GetLastError();
            _asm int 3;
            hr = HRESULT_FROM_WIN32(err);
    
        }

        pRvbData = (PREVERB_EFFECT_PARAMS) pBuffer;
    }

    if (SUCCEEDED(hr)) {

        hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

    }

    if (SUCCEEDED(hr)) {

        //
        // call dsound api to download the new reverb parameters..
        // defer commiting so they can only get DMAed at once
        // We only update the non-scratch related values
        //

        hr = ValidateResult(pDirectSound->SetEffectData(
                                    REVERB_CHAIN_FX0_REVERB, 
                                    sizeof(REVERB_CHAIN_FX0_REVERB_STATE)+FIELD_OFFSET(REVERB_EFFECT_PARAMS,dwReflectionsInputDelay0),
                                    &pRvbData->dwReflectionsInputDelay0,
                                    dwSize-FIELD_OFFSET(REVERB_EFFECT_PARAMS,dwReflectionsInputDelay0),
                                    DSFX_DEFERRED));
    }

    //
    // commit FX changes
    //

    if (SUCCEEDED(hr)) {
        hr = pDirectSound->CommitEffectData();
    }

    if (hFile) {
        CloseHandle(hFile);
    }
    
    if (pBuffer) {
        delete [] pBuffer;
    }    

    return hr;

}

HRESULT
TestSurround(LPDIRECTSOUNDBUFFER pBuffer)
{

    typedef struct
    {
        LPCSTR                  pszDescription;
        DWORD                   dwMixBins;
    } TESTMIXBINS;

    static const TESTMIXBINS    aMixBins[] =
    {
        { "All speakers",   DSMIXBIN_SPEAKER_MASK },
        { "Front left",     DSMIXBIN_FRONT_LEFT },
        { "Front right",    DSMIXBIN_FRONT_RIGHT },
        { "Back left",      DSMIXBIN_BACK_LEFT },
        { "Back right",     DSMIXBIN_BACK_RIGHT },
        { "Center",         DSMIXBIN_FRONT_CENTER },
        { "LFE",            DSMIXBIN_LOW_FREQUENCY },
        { "All speakers",   DSMIXBIN_SPEAKER_MASK },

    };
    
    HRESULT                     hr = S_OK;
    DWORD                       i;

    for(i = 0; (i < NUMELMS(aMixBins)) && SUCCEEDED(hr); i++)
    {
        DPF_TEST(aMixBins[i].pszDescription);

        hr = ValidateResult(pBuffer->SetMixBins(aMixBins[i].dwMixBins));

        Sleep(5000);

    }

    return hr;
}

/****************************************************************************
 *
 *  TestMe
 *
 *  Description:
 *      Main test function.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

HRESULT
TestMe
(
    void
)
{
    HRESULT                 hr  = DS_OK;
    LPDIRECTSOUNDBUFFER pDSBuffer = NULL;
    LPDIRECTSOUNDBUFFER pOscillatorBuffer0 = NULL;
    LPDIRECTSOUNDBUFFER pOscillatorBuffer1 = NULL;
    LPDIRECTSOUNDBUFFER pOscillatorBuffer2 = NULL;
    DWORD dwMask = 0;
    

    hr = PlaySineWave(3,DSMIXBIN_FXSEND_0,&pOscillatorBuffer0);
    if(SUCCEEDED(hr)) hr = PlaySineWave(1,DSMIXBIN_FXSEND_1,&pOscillatorBuffer1);
    if(SUCCEEDED(hr)) hr = PlaySineWave(1005,DSMIXBIN_FXSEND_2,&pOscillatorBuffer2);

    //
    // create audio buffer
    //

    if(SUCCEEDED(hr)) hr = PlayLoopingBuffer(TRUE, WAVE_FORMAT_PCM, 44100, 16, 1, &pDSBuffer);

    //
    // set mixbins
    //

    //dwMask = DSMIXBIN_XTLK_FRONT_LEFT | DSMIXBIN_XTLK_FRONT_RIGHT | DSMIXBIN_XTLK_BACK_LEFT | DSMIXBIN_XTLK_BACK_RIGHT;
    //hr = ValidateResult(pDSBuffer->SetMixBins(dwMask));

    //
    // test surround config
    //

    if(SUCCEEDED(hr)) hr = TestSurround(pDSBuffer);
    

    while(TRUE) {

        WaitForAnyButton();
        if(SUCCEEDED(hr)) hr = DownloadScratch("d:\\media\\audio\\scratchimg.bin");
        WaitForAnyButton();   
        if(SUCCEEDED(hr)) hr = LoadReverbParameters();

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\util.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       util.cpp
 *  Content:    DirectSound utility functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  06/07/01    dereks  Created.
 *
 ****************************************************************************/

#include "testds.h"


/****************************************************************************
 *
 *  __MALLOC
 *
 *  Description:
 *      Allocates memory (duh).
 *
 *  Arguments:
 *      DWORD [in]: number of bytes to allocate.
 *
 *  Returns:  
 *      LPVOID: base pointer.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__MALLOC"

LPVOID
__MALLOC
(
    DWORD                   dwSize
)
{

#ifdef ALLOC_ALIGNED

    static const DWORD      dwAlignment     = PAGE_SIZE;

#else // ALLOC_ALIGNED

    static const DWORD      dwAlignment     = 4;

#endif // ALLOC_ALIGNED

#ifdef ALLOC_NOCACHE

    static const DWORD      dwFlags         = PAGE_READWRITE | PAGE_NOCACHE;

#else // ALLOC_NOCACHE

    static const DWORD      dwFlags         = PAGE_READWRITE;

#endif // ALLOC_NOCACHE

#ifdef ALLOC_CONTIGUOUS

    return MmAllocateContiguousMemoryEx(dwSize, 0, 0xFFFFFFFF, dwAlignment, dwFlags);

#else // ALLOC_CONTIGUOUS

    DWORD                   dwAllocSize     = dwSize;
    DWORD                   dwOffset;
    LPVOID                  pvBuffer;
    DWORD                   dwOldProtect;
    BOOL                    fProtect;

#ifdef ALLOC_GUARD_PAGE

    dwAllocSize += (PAGE_SIZE * 2) - 1;

#ifndef ALLOC_ALIGNED

    dwAllocSize += sizeof(DWORD);

#endif // ALLOC_ALIGNED

    dwAllocSize /= PAGE_SIZE;
    dwAllocSize *= PAGE_SIZE;

#endif // ALLOC_GUARD_PAGE

    if(pvBuffer = VirtualAlloc(NULL, dwAllocSize, MEM_COMMIT, dwFlags))
    {

#ifdef ALLOC_GUARD_PAGE

        fProtect = VirtualProtect((LPBYTE)pvBuffer + dwAllocSize - PAGE_SIZE, PAGE_SIZE, PAGE_NOACCESS, &dwOldProtect);
        ASSERT(fProtect);

#ifndef ALLOC_ALIGNED

        dwOffset = dwAllocSize - dwSize - PAGE_SIZE;

        pvBuffer = (LPBYTE)pvBuffer + dwOffset;

        *((LPDWORD)pvBuffer - 1) = dwOffset;

#endif // ALLOC_ALIGNED

#endif // ALLOC_GUARD_PAGE

    }

    return pvBuffer;

#endif // ALLOC_CONTIGUOUS

}


/****************************************************************************
 *
 *  __FREE
 *
 *  Description:
 *      Frees memory allocated with __MALLOC.
 *
 *  Arguments:
 *      LPVOID * [in/out]: base pointer.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "__FREE"

void
__FREE
(
    LPVOID *                ppvBuffer
)
{

    LPVOID                  pvBuffer    = *ppvBuffer;
    DWORD                   dwOffset;

    *ppvBuffer = NULL;

    if(pvBuffer)
    {

#ifdef ALLOC_CONTIGUOUS

        MmFreeContiguousMemory(pvBuffer);

#else // ALLOC_CONTIGUOUS

#if defined(ALLOC_ALIGNED) || !defined(ALLOC_GUARD_PAGE)

        dwOffset = 0;

#else // defined(ALLOC_ALIGNED) || !defined(ALLOC_GUARD_PAGE)

        dwOffset = *((LPDWORD)pvBuffer - 1);

#endif // defined(ALLOC_ALIGNED) || !defined(ALLOC_GUARD_PAGE)
    
        VirtualFree((LPBYTE)pvBuffer - dwOffset, 0, MEM_RELEASE);

#endif // ALLOC_CONTIGUOUS

    }
}


/****************************************************************************
 *
 *  ReadXMO
 *
 *  Description:
 *      Reads data from an XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size.
 *      LPDWORD [out]: amount read.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ReadXMO"

HRESULT
ReadXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwRead
)
{
    HANDLE                  hCompletionEvent    = NULL;
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    //
    // Check to see if the XMO is ASYNC.  It's massive overhead to do this
    // every time we want to read, but hey, it's test code.
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    //
    // If we are ASYNC, create an event so we can simulate SYNC.
    //
    
    if(SUCCEEDED(hr) && (xmi.dwFlags & XMO_STREAMF_OUTPUT_ASYNC))
    {
        hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Read from the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvBuffer;
        xmp.dwMaxSize = dwBufferSize,
        xmp.pdwCompletedSize = pdwRead;
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pMediaObject->Process(NULL, &xmp));
    }

    //
    // Wait for processing to complete
    //

    if(SUCCEEDED(hr) && hCompletionEvent)
    {
        WaitForSingleObject(hCompletionEvent, INFINITE);
    }

    //
    // Clean up
    //

    CLOSE_HANDLE(hCompletionEvent);

    return hr;
}


/****************************************************************************
 *
 *  WriteXMO
 *
 *  Description:
 *      Writes data to an XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPVOID [out]: data buffer.
 *      DWORD [in]: data buffer size.
 *      LPDWORD [out]: amount written.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WriteXMO"

HRESULT
WriteXMO
(
    XMediaObject *          pMediaObject,
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize,
    LPDWORD                 pdwWritten
)
{
    HANDLE                  hCompletionEvent    = NULL;
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;

    //
    // Check to see if the XMO is ASYNC.  It's massive overhead to do this
    // every time we want to read, but hey, it's test code.
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    //
    // If we are ASYNC, create an event so we can simulate SYNC.
    //
    
    if(SUCCEEDED(hr) && (xmi.dwFlags & XMO_STREAMF_OUTPUT_ASYNC))
    {
        hCompletionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }

    //
    // Write to the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvBuffer;
        xmp.dwMaxSize = dwBufferSize,
        xmp.pdwCompletedSize = pdwWritten;
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pMediaObject->Process(&xmp, NULL));
    }

    //
    // Wait for processing to complete
    //

    if(SUCCEEDED(hr) && hCompletionEvent)
    {
        WaitForSingleObject(hCompletionEvent, INFINITE);
    }

    //
    // Clean up
    //

    CLOSE_HANDLE(hCompletionEvent);

    return hr;
}


/****************************************************************************
 *
 *  TransformXMO
 *
 *  Description:
 *      Passes data through a transform XMO.
 *
 *  Arguments:
 *      XMediaObject * [in]: XMO.
 *      LPCVOID [in]: source buffer.
 *      DWORD [in]: source buffer size.
 *      LPDWORD [out]: amount read.
 *      LPVOID [in]: destination buffer.
 *      DWORD [in]: destination buffer size.
 *      LPDWORD [out]: amount written.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TransformXMO"

HRESULT
TransformXMO
(
    XMediaObject *          pMediaObject,
    LPCVOID                 pvSource,
    DWORD                   dwSourceSize,
    LPDWORD                 pdwRead,
    LPVOID                  pvDest,
    DWORD                   dwDestSize,
    LPDWORD                 pdwWritten
)
{
    XMEDIAINFO              xmi;
    XMEDIAPACKET            xmpInput;
    XMEDIAPACKET            xmpOutput;
    HRESULT                 hr;

#ifdef TRANSFORMXMO_SINGLEBLOCK

    DWORD                   dwTotalRead     = 0;
    DWORD                   dwTotalWritten  = 0;
    DWORD                   dwRead;
    DWORD                   dwWritten;

#endif // TRANSFORMXMO_SINGLEBLOCK

    //
    // Verify that the XMO is synchronous
    //

    ZeroMemory(&xmi, sizeof(xmi));

    hr = ValidateResult(pMediaObject->GetInfo(&xmi));

    if(SUCCEEDED(hr))
    {
        ASSERT(!(xmi.dwFlags & (XMO_STREAMF_INPUT_ASYNC | XMO_STREAMF_OUTPUT_ASYNC)));
    }

    //
    // Call the XMO
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmpInput, sizeof(xmpInput));
        ZeroMemory(&xmpOutput, sizeof(xmpOutput));

#ifdef TRANSFORMXMO_SINGLEBLOCK

        while(SUCCEEDED(hr) && (dwTotalRead < dwSourceSize) && (dwTotalWritten < dwDestSize))
        {
            xmpInput.pvBuffer = (LPBYTE)pvSource + dwTotalRead;
            xmpInput.dwMaxSize = min(xmi.dwInputSize, dwSourceSize - dwTotalRead);
            xmpInput.pdwCompletedSize = &dwRead;

            xmpOutput.pvBuffer = (LPBYTE)pvDest + dwTotalWritten;
            xmpOutput.dwMaxSize = min(xmi.dwOutputSize, dwDestSize - dwTotalWritten);
            xmpOutput.pdwCompletedSize = &dwWritten;

#else // TRANSFORMXMO_SINGLEBLOCK

            xmpInput.pvBuffer = (LPVOID)pvSource;
            xmpInput.dwMaxSize = dwSourceSize,
            xmpInput.pdwCompletedSize = pdwRead;

            xmpOutput.pvBuffer = pvDest;
            xmpOutput.dwMaxSize = dwDestSize,
            xmpOutput.pdwCompletedSize = pdwWritten;

#endif // TRANSFORMXMO_SINGLEBLOCK

            hr = ValidateResult(pMediaObject->Process(&xmpInput, &xmpOutput));

#ifdef TRANSFORMXMO_SINGLEBLOCK

            dwTotalRead += dwRead;
            dwTotalWritten += dwWritten;
        }

#endif // TRANSFORMXMO_SINGLEBLOCK

    }

#ifdef TRANSFORMXMO_SINGLEBLOCK

    if(SUCCEEDED(hr) && pdwRead)
    {
        *pdwRead = dwTotalRead;
    }

    if(SUCCEEDED(hr) && pdwWritten)
    {
        *pdwWritten = dwTotalWritten;
    }

#endif // TRANSFORMXMO_SINGLEBLOCK

    return hr;
}


/****************************************************************************
 *
 *  OpenWaveFile
 *
 *  Description:
 *      Loads a wave file into an XMO object.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      LPCWAVEFORMATEX [out]: wave file format.
 *      XMediaObject ** [out]: wave file XMO.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "OpenWaveFile"

HRESULT
OpenWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    XFileMediaObject **     ppMediaObject
)
{
    DPF_TEST("Loading %s", pszFileName);

    return ValidateResult(XWaveFileCreateMediaObject(pszFileName, ppwfxFormat, ppMediaObject));
}


/****************************************************************************
 *
 *  LoadWaveFile
 *
 *  Description:
 *      Loads an entire wave file into memory.
 *
 *  Arguments:
 *      LPCSTR [in]: file name.
 *      LPCWAVEFORMATEX * [out]: wave file format.
 *      LPVOID * [out]: wave file data.  The caller is responsible for 
 *                      freeing this buffer with FREE.
 *      LPDWORD [out]: data buffer size, in bytes.
 *      XFileMediaObject ** [out]: wave file XMO.  The caller is responsible
 *                                 for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "LoadWaveFile"

HRESULT
LoadWaveFile
(
    LPCSTR                  pszFileName,
    LPCWAVEFORMATEX *       ppwfxFormat,
    LPVOID *                ppvBuffer,
    LPDWORD                 pdwBufferSize,
    XFileMediaObject **     ppMediaObject
)
{
    XFileMediaObject *      pMediaObject    = NULL;
    LPVOID                  pvBuffer        = NULL;
    DWORD                   dwBufferSize;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    
    ASSERT(pszFileName);
    ASSERT(ppvBuffer);
    ASSERT(pdwBufferSize);
    ASSERT(ppMediaObject);

    hr = ValidateResult(XWaveFileCreateMediaObject(pszFileName, ppwfxFormat, &pMediaObject));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pMediaObject->GetLength(&dwBufferSize));
    }

    if(SUCCEEDED(hr))
    {
        hr = ClampBufferSize(&dwBufferSize);
    }

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvBuffer, BYTE, dwBufferSize);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvBuffer;
        xmp.dwMaxSize = dwBufferSize;
        
        hr = ValidateResult(pMediaObject->Process(NULL, &xmp));
    }

    if(SUCCEEDED(hr))
    {
        *ppvBuffer = pvBuffer;
        *pdwBufferSize = dwBufferSize;
        *ppMediaObject = pMediaObject;
    }
    else
    {
        FREE(pvBuffer);
        RELEASE(pMediaObject);
    }

    return hr;
}


/****************************************************************************
 *
 *  GetStdWaveFile
 *
 *  Description:
 *      Gets a standard wave file path.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *      LPSTR [out]: file path.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetStdWaveFile"

void
GetStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    LPSTR                   pszFileName
)
{
    static const LPCSTR     pszParent       = "t:\\media\\audio\\";
    static const LPCSTR     pszPcm          = "pcm\\";
    static const LPCSTR     pszAdpcm        = "adpcm\\";
    static const LPCSTR     pszFileTemplate = "%uk%ub%ls.wav";
    static const LPCSTR     pszMono         = "m";
    static const LPCSTR     pszStereo       = "s";

    strcpy(pszFileName, pszParent);

    switch(pwfxFormat->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            strcat(pszFileName, pszPcm);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            strcat(pszFileName, pszAdpcm);
            break;

        default:
            ASSERTMSG("Unsupported format");
            break;
    }

    sprintf(pszFileName + strlen(pszFileName), pszFileTemplate, pwfxFormat->nSamplesPerSec / 1000, pwfxFormat->wBitsPerSample, (1 == pwfxFormat->nChannels) ? pszMono : pszStereo);
}


/****************************************************************************
 *
 *  GetStdWaveFile
 *
 *  Description:
 *      Gets a standard wave file path.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      LPSTR: file path.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetStdWaveFile"

LPCSTR
GetStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat
)
{
    static CHAR             szFileName[MAX_PATH];

    GetStdWaveFile(pwfxFormat, szFileName);

    return szFileName;
}


/****************************************************************************
 *
 *  OpenStdWaveFile
 *
 *  Description:
 *      Loads a standard wave file into an XMO object.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *      XMediaObject ** [out]: wave file XMO.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "OpenStdWaveFile"

HRESULT
OpenStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    XFileMediaObject **     ppMediaObject
)
{
    return OpenWaveFile(GetStdWaveFile(pwfxFormat), NULL, ppMediaObject);
}


/****************************************************************************
 *
 *  LoadStdWaveFile
 *
 *  Description:
 *      Loads an entire wave file into memory.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *      LPVOID * [out]: wave file data.  The caller is responsible for 
 *                      freeing this buffer with FREE.
 *      LPDWORD [out]: data buffer size, in bytes.
 *      XFileMediaObject ** [out]: wave file XMO.  The caller is responsible
 *                                 for freeing this object with Release.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "LoadStdWaveFile"

HRESULT
LoadStdWaveFile
(
    LPCWAVEFORMATEX         pwfxFormat,
    LPVOID *                ppvBuffer,
    LPDWORD                 pdwBufferSize,
    XFileMediaObject **     ppMediaObject
)
{
    return LoadWaveFile(GetStdWaveFile(pwfxFormat), NULL, ppvBuffer, pdwBufferSize, ppMediaObject);
}


/****************************************************************************
 *
 *  CreateBufferFromFile
 *
 *  Description:
 *      Creates a DirectSound buffer from a file.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: output mixbin mask.
 *      DWORD [in]: submix output buffer.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer.
 *      LPDWORD [in/out]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateBufferFromFile"

HRESULT
CreateBufferFromFile
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags, 
    LPCDSMIXBINS            pMixBins, 
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDBUFFER *   ppBuffer, 
    LPDWORD                 pdwBufferBytes
)
{
    LPXFILEMEDIAOBJECT      pWaveFile       = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    LPCWAVEFORMATEX         pwfxFormat;
    LPVOID                  pvBufferData;
    DWORD                   dwBufferBytes;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    HRESULT                 hr;

    //
    // Open the wave file.  If it's longer than allowed, trim down the size
    //

    hr = LoadWaveFile(pszFile, &pwfxFormat, &pvBufferData, &dwBufferBytes, &pWaveFile);

    //
    // Create the buffer
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.dwFlags = dwFlags;
        dsbd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
        dsbd.lpMixBins = pMixBins;
        
        hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->SetBufferData(pvBufferData, dwBufferBytes));
    }

    //
    // Set the output buffer
    //

    if(SUCCEEDED(hr) && pOutputBuffer)
    {
        hr = ValidateResult(pBuffer->SetOutputBuffer(pOutputBuffer));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        ASSERT(ppBuffer);

        *ppBuffer = pBuffer;

        if(pdwBufferBytes)
        {
            if(!*pdwBufferBytes || (*pdwBufferBytes > dwBufferBytes))
            {
                *pdwBufferBytes = dwBufferBytes;
            }
            else
            {
                dwBufferBytes = *pdwBufferBytes;
            }
        }
    }
    else
    {
        RELEASE(pBuffer);
    }

    RELEASE(pWaveFile);

    return hr;
}


/****************************************************************************
 *
 *  CreateStdBuffer
 *
 *  Description:
 *      Creates a sound buffer from one of the standard wave files.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      DWORD [in]: output mixbin mask.
 *      DWORD [in]: submix output buffer.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer.
 *      LPDWORD [in/out]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateStdBuffer"

HRESULT
CreateStdBuffer
(
    DWORD                   dwFlags, 
    LPCWAVEFORMATEX         pwfxFormat, 
    LPCDSMIXBINS            pMixBins, 
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDBUFFER *   ppBuffer, 
    LPDWORD                 pdwBufferBytes
)
{
    return ValidateResult(CreateBufferFromFile(GetStdWaveFile(pwfxFormat), dwFlags, pMixBins, pOutputBuffer, ppBuffer, pdwBufferBytes));
}


/****************************************************************************
 *
 *  WaitBuffer
 *
 *  Description:
 *      Waits for a buffer's status to change.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *      BOOL [in]: TRUE to wait for the buffer to start playing, FALSE to
 *                 wait for it to stop.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaitBuffer"

HRESULT
WaitBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    BOOL                    fPlaying
)
{
    const DWORD             dwStatusMask    = DSBSTATUS_PLAYING;
    const DWORD             dwWaitStatus    = fPlaying ? DSBSTATUS_PLAYING : 0;
    DWORD                   dwStatus;
    HRESULT                 hr;

    while(TRUE)
    {
        DirectSoundDoWork();
        
        hr = ValidateResult(pBuffer->GetStatus(&dwStatus));

        if(FAILED(hr))
        {
            break;
        }

        if((dwStatus & dwStatusMask) == dwWaitStatus)
        {
            DPF_TEST("Buffer %s", fPlaying ? "playing" : "stopped");
            break;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  PlayBuffer
 *
 *  Description:
 *      Plays a sound buffer.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *      DWORD [in]: play flags.
 *      DWORD [in]: delay, in milliseconds.
 *      BOOL [in]: TRUE to wait for buffer to start playing.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayBuffer"

HRESULT
PlayBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    DWORD                   dwFlags,
    DWORD                   dwDelay,
    BOOL                    fWait
)
{
    REFERENCE_TIME          rtTimeStamp = -(LONGLONG)dwDelay * 10000;
    HRESULT                 hr;

    if(dwDelay)
    {
        DPF_TEST("Playing buffer (delayed %lu ms)", dwDelay);
    }
    else
    {
        DPF_TEST("Playing buffer");
        fWait = FALSE;
    }

    hr = ValidateResult(pBuffer->PlayEx(rtTimeStamp, dwFlags));

    if(SUCCEEDED(hr) && fWait)
    {
        hr = WaitBuffer(pBuffer, TRUE);
    }

    return hr;
}


/****************************************************************************
 *
 *  PlayBufferToCompletion
 *
 *  Description:
 *      Plays a sound buffer to completion.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *      DWORD [in]: delay, in milliseconds.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PlayBufferToCompletion"

HRESULT
PlayBufferToCompletion
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    DWORD                   dwFlags,
    DWORD                   dwDelay
)
{
    HRESULT                 hr;

    hr = PlayBuffer(pBuffer, dwFlags, dwDelay, TRUE);

    if(SUCCEEDED(hr))
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    return hr;
}


/****************************************************************************
 *
 *  StopBuffer
 *
 *  Description:
 *      Stops a sound buffer.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: buffer.
 *      DWORD [in]: flags.
 *      DWORD [in]: delay, in milliseconds.
 *      BOOL [in]: TRUE to reset cursor position.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "StopBuffer"

HRESULT
StopBuffer
(
    LPDIRECTSOUNDBUFFER     pBuffer,
    DWORD                   dwFlags,
    DWORD                   dwDelay,
    BOOL                    fReset,
    BOOL                    fWait
)
{
    REFERENCE_TIME          rtTimeStamp = -(LONGLONG)dwDelay * 10000;
    HRESULT                 hr;

    if(fReset)
    {
        fWait = TRUE;
    }

    if(dwDelay)
    {
        DPF_TEST("Stopping buffer (delayed %lu ms)", dwDelay);
    }
    else
    {
        DPF_TEST("Stopping buffer");
    }

    hr = ValidateResult(pBuffer->StopEx(rtTimeStamp, dwFlags));

    if(SUCCEEDED(hr) && fWait)
    {
        hr = WaitBuffer(pBuffer, FALSE);
    }

    if(SUCCEEDED(hr) && fReset)
    {
        DPF_TEST("Resetting cursor position");
        
        hr = ValidateResult(pBuffer->SetCurrentPosition(0));
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateStreamFromFile
 *
 *  Description:
 *      Creates a DirectSound stream based on a given wave file.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: output mixbin mask.
 *      LPDWORD [in/out]: packet size, in bytes.
 *      LPFNXMEDIAOBJECTCALLBACK [in]: stream callback function.
 *      LPVOID [in]: stream callback context.
 *      LPDIRECTSOUNDBUFFER [in]: submix output buffer.
 *      LPDIRECTSOUNDSTREAM * [out]: stream object.
 *      LPVOID * [out]: audio data buffer.
 *      LPDWORD [out]: audio data buffer size, in bytes.
 *      LPDWORD [in/out]: packet count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateStreamFromFile"

HRESULT
CreateStreamFromFile
(
    LPCSTR                      pszFile, 
    DWORD                       dwFlags, 
    LPCDSMIXBINS                pMixBins, 
    LPDWORD                     pdwPacketSize,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback,
    LPVOID                      pvContext,
    LPDIRECTSOUNDBUFFER         pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *       ppStream, 
    LPVOID *                    ppvAudioData,
    LPDWORD                     pdwAudioDataSize,
    LPDWORD                     pdwPacketCount
)
{
    LPXFILEMEDIAOBJECT          pWaveFile       = NULL;
    LPDIRECTSOUNDSTREAM         pStream         = NULL;
    LPVOID                      pvAudioData     = NULL;
    LPCWAVEFORMATEX             pwfxFormat;
    DWORD                       dwDuration;
    DWORD                       dwPacketCount;
    DSSTREAMDESC                dssd;
    HRESULT                     hr;

    //
    // Open the wave file
    //

    hr = ValidateResult(OpenWaveFile(pszFile, &pwfxFormat, &pWaveFile));

    //
    // Block-align the packet size
    //

    if(SUCCEEDED(hr))
    {
        *pdwPacketSize /= pwfxFormat->nBlockAlign;
        *pdwPacketSize *= pwfxFormat->nBlockAlign;
    }

    //
    // Get the file size
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pWaveFile->GetLength(&dwDuration));
    }

    //
    // Allocate a buffer for the wave data
    //

    if(SUCCEEDED(hr))
    {
        hr = MALLOC(pvAudioData, BYTE, dwDuration);
    }

    //
    // Read wave data
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(ReadXMO(pWaveFile, pvAudioData, dwDuration, &dwDuration));
    }

    //
    // Calculate the number of packets required
    //

    if(SUCCEEDED(hr))
    {
        dwPacketCount = dwDuration / *pdwPacketSize;
    }

    if(SUCCEEDED(hr) && pdwPacketCount)
    {
        if(!*pdwPacketCount || (*pdwPacketCount > dwPacketCount))
        {
            *pdwPacketCount = dwPacketCount;
        }
        else
        {
            dwPacketCount = *pdwPacketCount;
        }
    }

    //
    // Create the stream
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dssd, sizeof(dssd));

        dssd.dwFlags = dwFlags;
        dssd.dwMaxAttachedPackets = dwPacketCount;
        dssd.lpwfxFormat = (LPWAVEFORMATEX)pwfxFormat;
        dssd.lpfnCallback = pfnCallback;
        dssd.lpvContext = pvContext;
        dssd.lpMixBins = pMixBins;

        hr = ValidateResult(DirectSoundCreateStream(&dssd, &pStream));
    }

    //
    // Set the output buffer
    //

    if(SUCCEEDED(hr) && pOutputBuffer)
    {
        hr = ValidateResult(pStream->SetOutputBuffer(pOutputBuffer));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppStream = pStream;
        *ppvAudioData = pvAudioData;
        *pdwAudioDataSize = dwDuration;
    }
    else
    {
        RELEASE(pStream);
        FREE(pvAudioData);
    }

    RELEASE(pWaveFile);

    return hr;
}


/****************************************************************************
 *
 *  CreateStdStream
 *
 *  Description:
 *      Creates a DirectSound stream based on a standard wave file.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      LPCWAVEFORMATEX [in]: stream format.
 *      DWORD [in]: output mixbin mask.
 *      LPDWORD [in/out]: packet size, in bytes.
 *      LPFNXMEDIAOBJECTCALLBACK [in]: stream callback function.
 *      LPVOID [in]: stream callback context.
 *      LPDIRECTSOUNDBUFFER [in]: submix output buffer.
 *      LPDIRECTSOUNDSTREAM * [out]: stream object.
 *      LPVOID * [out]: audio data buffer.
 *      LPDWORD [out]: audio data buffer size, in bytes.
 *      LPDWORD [in/out]: packet count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateStdStream"

HRESULT
CreateStdStream
(
    DWORD                       dwFlags, 
    LPCWAVEFORMATEX             pwfxFormat,
    LPCDSMIXBINS                pMixBins, 
    LPDWORD                     pdwPacketSize,
    LPFNXMEDIAOBJECTCALLBACK    pfnCallback,
    LPVOID                      pvContext,
    LPDIRECTSOUNDBUFFER         pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *       ppStream, 
    LPVOID *                    ppvAudioData,
    LPDWORD                     pdwAudioDataSize,
    LPDWORD                     pdwPacketCount
)
{
    return ValidateResult(CreateStreamFromFile(GetStdWaveFile(pwfxFormat), dwFlags, pMixBins, pdwPacketSize, pfnCallback, pvContext, pOutputBuffer, ppStream, ppvAudioData, pdwAudioDataSize, pdwPacketCount));
}


/****************************************************************************
 *
 *  CreateQueuedStreamFromFile
 *
 *  Description:
 *      Creates a DirectSound stream based on a given wave file and submits
 *      data to it.
 *
 *  Arguments:
 *      LPCSTR [in]: file path.
 *      DWORD [in]: stream creation flags.
 *      DWORD [in]: output mixbin mask.
 *      LPDWORD [in/out]: packet size, in bytes.
 *      HANDLE [in]: completion event for the last packet.
 *      LPDIRECTSOUNDBUFFER [in]: submix output buffer.
 *      LPDIRECTSOUNDSTREAM * [out]: stream object.
 *      LPVOID * [out]: audio data buffer.
 *      LPCWAVEFORMATEX [out]: stream format.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateQueuedStreamFromFile"

HRESULT
CreateQueuedStreamFromFile
(
    LPCSTR                  pszFile, 
    DWORD                   dwFlags, 
    LPCDSMIXBINS            pMixBins, 
    LPDWORD                 pdwPacketSize,
    HANDLE                  hCompletionEvent,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *   ppStream, 
    LPVOID *                ppvAudioData
)
{
    LPDIRECTSOUNDSTREAM     pStream         = NULL;
    LPVOID                  pvAudioData     = NULL;
    DWORD                   dwAudioDataSize = 0;
    DWORD                   dwPacketCount   = 0;
    XMEDIAPACKET            xmp;
    HRESULT                 hr;
    DWORD                   i;

    //
    // Create the stream
    //

    hr = ValidateResult(CreateStreamFromFile(pszFile, dwFlags, pMixBins, pdwPacketSize, NULL, NULL, pOutputBuffer, &pStream, &pvAudioData, &dwAudioDataSize, &dwPacketCount));

    //
    // Pause the stream
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(PauseStream(pStream));
    }

    //
    // Submit all packets
    //

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&xmp, sizeof(xmp));

        xmp.pvBuffer = pvAudioData;
        xmp.dwMaxSize = *pdwPacketSize;
        
        for(i = 0; SUCCEEDED(hr) && (i < dwPacketCount - 1); i++)
        {
            hr = ValidateResult(pStream->Process(&xmp, NULL));

            if(SUCCEEDED(hr))
            {
                xmp.pvBuffer = (LPBYTE)xmp.pvBuffer + xmp.dwMaxSize;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        xmp.dwMaxSize = dwAudioDataSize - (*pdwPacketSize * (dwPacketCount - 1));
        xmp.hCompletionEvent = hCompletionEvent;

        hr = ValidateResult(pStream->Process(&xmp, NULL));
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pStream->Discontinuity());
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppStream = pStream;
        *ppvAudioData = pvAudioData;
    }
    else
    {
        RELEASE(pStream);
        FREE(pvAudioData);
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateStdQueuedStream
 *
 *  Description:
 *      Creates a DirectSound stream based on a given wave file and submits
 *      data to it.
 *
 *  Arguments:
 *      DWORD [in]: stream creation flags.
 *      LPCWAVEFORMATEX [in]: stream format.
 *      DWORD [in]: output mixbin mask.
 *      LPDWORD [in/out]: packet size, in bytes.
 *      HANDLE [in]: completion event for the last packet.
 *      LPDIRECTSOUNDBUFFER [in]: submix output buffer.
 *      LPDIRECTSOUNDSTREAM * [out]: stream object.
 *      LPVOID * [out]: audio data buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateStdQueuedStream"

HRESULT
CreateStdQueuedStream
(
    DWORD                   dwFlags, 
    LPCWAVEFORMATEX         pwfxFormat,
    LPCDSMIXBINS            pMixBins, 
    LPDWORD                 pdwPacketSize,
    HANDLE                  hCompletionEvent,
    LPDIRECTSOUNDBUFFER     pOutputBuffer, 
    LPDIRECTSOUNDSTREAM *   ppStream, 
    LPVOID *                ppvAudioData
)
{
    return CreateQueuedStreamFromFile(GetStdWaveFile(pwfxFormat), dwFlags, pMixBins, pdwPacketSize, hCompletionEvent, pOutputBuffer, ppStream, ppvAudioData);
}


/****************************************************************************
 *
 *  ResubmitPacketCallback
 *
 *  Description:
 *      Stream callback function that automatically resubmits the completed
 *      packet.
 *
 *  Arguments:
 *      LPVOID [in]: stream context.
 *      LPVOID [in]: packet context.
 *      DWORD [in]: packet status.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "ResubmitPacketCallback"

void CALLBACK
ResubmitPacketCallback
(
    LPVOID                  pvStreamContext,
    LPVOID                  pvPacketContext,
    DWORD                   dwStatus
)
{
    LPXMEDIAOBJECT *        ppStream    = (LPXMEDIAOBJECT *)pvStreamContext;
    LPXMEDIAPACKET          pPacket     = (LPXMEDIAPACKET)pvPacketContext;
    
    if(XMEDIAPACKET_STATUS_SUCCESS == dwStatus)
    {
        (*ppStream)->Process(pPacket, NULL);
    }
}


/****************************************************************************
 *
 *  GenerateTone
 *
 *  Description:
 *      Generates a PCM sine-wave tone.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *      DWORD [in]: playback frequency.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GenerateTone"

void
GenerateTone
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwBitsPerSample,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
)
{
    switch(dwBitsPerSample)
    {
        case 8:
            GenerateTone8(pvBuffer, dwBufferBytes, dwPlaybackFrequency, dwChannelCount, dwToneFrequency);
            break;

        case 16:
            GenerateTone16(pvBuffer, dwBufferBytes, dwPlaybackFrequency, dwChannelCount, dwToneFrequency);
            break;

        default:
            ASSERTMSG("Unexpected bit resolution");
            break;
    }            
}


/****************************************************************************
 *
 *  GenerateTone8
 *
 *  Description:
 *      Generates an 8-bit sine-wave tone.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *      DWORD [in]: playback frequency.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GenerateTone8"

void
GenerateTone8
(
    LPVOID                      pvBuffer,
    DWORD                       dwBufferBytes,
    DWORD                       dwPlaybackFrequency,
    DWORD                       dwChannelCount,
    DWORD                       dwToneFrequency
)
{
    static const double         dbScale     = 255.0;
    static const unsigned char  bHalfScale  = 128;
    const double                dbPhase     = 2.0 * D3DX_PI / (double)dwPlaybackFrequency;
    const double                dbFactor    = dbPhase * (double)dwToneFrequency;
    unsigned char *             pbBuffer    = (unsigned char *)pvBuffer;
    unsigned char               bSample;
    DWORD                       i, z;

    for(i = 0; i < dwBufferBytes / dwChannelCount; i++)
    {
        bSample = (unsigned char)(sin((double)i * dbFactor) * dbScale) + bHalfScale;

        for(z = 0; z < dwChannelCount; z++)
        {
            *pbBuffer++ = bSample;
        }
    }
}


/****************************************************************************
 *
 *  GenerateTone16
 *
 *  Description:
 *      Generates a 16-bit sine-wave tone.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *      DWORD [in]: channel count.
 *      DWORD [in]: playback frequency.
 *      DWORD [in]: tone frequency.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GenerateTone16"

void
GenerateTone16
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferBytes,
    DWORD                   dwPlaybackFrequency,
    DWORD                   dwChannelCount,
    DWORD                   dwToneFrequency
)
{
    static const double     dbScale     = 32767.0;
    const double            dbPhase     = 2.0 * D3DX_PI / (double)dwPlaybackFrequency;
    const double            dbFactor    = dbPhase * (double)dwToneFrequency;
    short *                 pnBuffer    = (short *)pvBuffer;
    short                   nSample;
    DWORD                   i, z;

    for(i = 0; i < dwBufferBytes / (2 * dwChannelCount); i++)
    {
        nSample = (short)(sin((double)i * dbFactor) * dbScale);

        for(z = 0; z < dwChannelCount; z++)
        {
            *pnBuffer++ = nSample;
        }
    }
}


/****************************************************************************
 *
 *  GenerateNoise
 *
 *  Description:
 *      Generates white noise.
 *
 *  Arguments:
 *      LPVOID [out]: audio data buffer.
 *      DWORD [in]: audio data buffer size, in bytes.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/
 
#undef DPF_FNAME
#define DPF_FNAME "GenerateNoise"

void
GenerateNoise
(
    LPVOID                  pvBuffer,
    DWORD                   dwBufferSize
)
{
    DWORD                   i;

    for(i = 0; i < dwBufferSize; i++)
    {
        *(((LPBYTE)pvBuffer) + i) = (BYTE)(rand() % 0xFF);
    }
}


/****************************************************************************
 *
 *  MakeMultiChannel
 *
 *  Description:
 *      Converts a mono or stereo PCM sound file to multichannel.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: source format.
 *      LPWAVEFORMATEX [out]: destination format.  Only nChannels needs to
 *                            be filled in.
 *      LPCVOID [in]: source data.
 *      DWORD [in]: source data size, in bytes.
 *      LPVOID * [out]: destination data.
 *      LPDWORD [out]: destinatin data size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MakeMultiChannel"

HRESULT
MakeMultiChannel
(
    LPCWAVEFORMATEX         pwfxSrc,
    LPWAVEFORMATEX          pwfxDst,
    LPCVOID                 pvSrcData,
    DWORD                   dwSrcDataSize,
    LPVOID *                ppvDstData,
    LPDWORD                 pdwDstDataSize
)
{
    LPVOID                  pvDstData;
    DWORD                   dwDstDataSize;
    DWORD                   dwMultiplier;
    DWORD                   dwSampleCount;
    HRESULT                 hr;
    DWORD                   a, b;

    ASSERT(WAVE_FORMAT_PCM == pwfxSrc->wFormatTag);
    ASSERT(!(pwfxDst->nChannels % pwfxSrc->nChannels));
    
    XAudioCreatePcmFormat(pwfxDst->nChannels, pwfxSrc->nSamplesPerSec, pwfxSrc->wBitsPerSample, pwfxDst);

    dwMultiplier = pwfxDst->nChannels / pwfxSrc->nChannels;
    dwSampleCount = dwSrcDataSize / pwfxSrc->nBlockAlign;
    dwDstDataSize = dwSampleCount * pwfxDst->nBlockAlign;

    hr = MALLOC(pvDstData, BYTE, dwDstDataSize);

    if(SUCCEEDED(hr))
    {
        *ppvDstData = pvDstData;
        *pdwDstDataSize = dwDstDataSize;

        while(dwSampleCount--)
        {
            for(a = 0; a < dwMultiplier; a++)
            {
                for(b = 0; b < pwfxSrc->nChannels; b++)
                {
                    if(8 == pwfxSrc->wBitsPerSample)
                    {
                        *(unsigned char *)pvDstData = *(const unsigned char *)pvSrcData;
                        pvDstData = (unsigned char *)pvDstData + 1;
                    }
                    else
                    {
                        *(short *)pvDstData = *(const short *)pvSrcData;
                        pvDstData = (short *)pvDstData + 1;
                    }
                }
            }

            pvSrcData = (LPBYTE)pvSrcData + pwfxSrc->nBlockAlign;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  PauseStream
 *
 *  Description:
 *      Pauses or resumes a stream.
 *
 *  Arguments:
 *      LPDIRECTSOUNDSTREAM [in]: stream.
 *      BOOL [in]: TRUE to pause, FALSE to resume.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PauseStream"

HRESULT
PauseStream
(
    LPDIRECTSOUNDSTREAM     pStream,
    BOOL                    fPause
)
{
    HRESULT                 hr;

    if(fPause)
    {
        DPF_TEST("Pausing stream");
    }
    else
    {
        DPF_TEST("Resuming paused stream");
    }

    hr = ValidateResult(pStream->Pause(fPause));

    return hr;
}


/****************************************************************************
 *
 *  CreateFormat
 *
 *  Description:
 *      Creates a WAVEFORMATEX structure.
 *
 *  Arguments:
 *      DWORD [in]: format tag.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bit resolution.
 *      DWORD [in]: channel count.
 *
 *  Returns:  
 *      LPCWAVEFORMATEX: format data.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateFormat"

LPCWAVEFORMATEX
CreateFormat
(
    DWORD                   dwFormatTag,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannels
)
{
    static UNIWAVEFORMAT    wfx;
    
    switch(dwFormatTag)
    {
        case WAVE_FORMAT_PCM:
            XAudioCreatePcmFormat((WORD)dwChannels, dwSamplesPerSec, (WORD)dwBitsPerSample, &wfx.wfx);
            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            XAudioCreateAdpcmFormat((WORD)dwChannels, dwSamplesPerSec, &wfx.wfAdpcm);
            break;

        default:
            ASSERTMSG("Unexpected format tag");
            break;
    }

    return &wfx.wfx;
}


/****************************************************************************
 *
 *  GetFreeSGEs
 *
 *  Description:
 *      Gets the count of free buffer SGEs.
 *
 *  Arguments:
 *      LPDWORD [out]: SGE count.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetFreeSGEs"

HRESULT
GetFreeSGEs
(
    LPDWORD                 pdwFreeSGEs
)
{
    DSCAPS                  dsc;
    HRESULT                 hr;
    
    hr = ValidateResult(GetDirectSoundCaps(&dsc));

    if(SUCCEEDED(hr))
    {
        *pdwFreeSGEs = dsc.dwFreeBufferSGEs;
    }

    return hr;
}


/****************************************************************************
 *
 *  ClampBufferSize
 *
 *  Description:
 *      Clamps a buffer size so that it will fit in the available SGEs.
 *
 *  Arguments:
 *      LPDWORD [in/out]: buffer size, in bytes.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ClampBufferSize"

HRESULT
ClampBufferSize
(
    LPDWORD                 pdwBufferBytes
)
{
    static const DWORD      dwSGESlop           = 1;
    DWORD                   dwFreeSGEs;
    DWORD                   dwMaxBufferBytes;
    HRESULT                 hr;
    
    hr = ValidateResult(GetFreeSGEs(&dwFreeSGEs));

    if(SUCCEEDED(hr) && (dwFreeSGEs <= dwSGESlop))
    {
        DPF_TEST("Out of SGEs");
        hr = DSERR_OUTOFMEMORY;
    }
        
    if(SUCCEEDED(hr))
    {
        dwMaxBufferBytes = (dwFreeSGEs - dwSGESlop) * PAGE_SIZE;

        if(*pdwBufferBytes > dwMaxBufferBytes)
        {
            DPF_TEST("Clamping buffer size from %lu to %lu", *pdwBufferBytes, dwMaxBufferBytes);
            *pdwBufferBytes = dwMaxBufferBytes;
        }
    }

    return hr;
}


/****************************************************************************
 *
 *  LoadEffectsImage
 *
 *  Description:
 *      Loads the default effects image from a file or XBE section.
 *
 *  Arguments:
 *      LPCSTR [in]: file name or section name.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "LoadEffectsImage"

HRESULT
LoadEffectsImage
(
    LPCSTR                  pszImageName,
    DWORD                   dwFlags
)
{
    DSEFFECTIMAGELOC        EffectLoc;

    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;
    
    return ValidateResult(XAudioDownloadEffectsImage(pszImageName, &EffectLoc, dwFlags, NULL));
}


/****************************************************************************
 *
 *  GetDirectSoundCaps
 *
 *  Description:
 *      Gets DirectSound capabilities.
 *
 *  Arguments:
 *      LPDSCAPS [out]: caps.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetDirectSoundCaps"

HRESULT
GetDirectSoundCaps
(
    LPDSCAPS                pdsc
)
{
    LPDIRECTSOUND           pDirectSound    = NULL;
    HRESULT                 hr;

    hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pDirectSound->GetCaps(pdsc));
    }

    RELEASE(pDirectSound);

    return hr;
}


/****************************************************************************
 *
 *  CreateToneBuffer
 *
 *  Description:
 *      Creates a simple sine-wave tone buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *      DWORD [in]: buffer size in bytes, or 0 for default.
 *      DWORD [in]: buffer mixbin assignments.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateToneBuffer"

HRESULT
CreateToneBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwToneFrequency,
    DWORD                   dwBufferBytes,
    LPCDSMIXBINS            pMixBins, 
    LPDIRECTSOUNDBUFFER *   ppBuffer
)
{
    WAVEFORMATEX            wfxFormat       = INIT_PCM_WAVEFORMAT(dwChannelCount, dwSamplesPerSec, dwBitsPerSample);
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    DWORD                   dwLock;
    HRESULT                 hr;

    ASSERT(!(dwSamplesPerSec % dwToneFrequency));

    //
    // Create the buffer
    //

    if(!dwBufferBytes)
    {
        dwBufferBytes = (dwSamplesPerSec / dwToneFrequency) * wfxFormat.nBlockAlign;
    }

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = dwFlags;
    dsbd.lpwfxFormat = &wfxFormat;
    dsbd.dwBufferBytes = dwBufferBytes;
    dsbd.lpMixBins = pMixBins;

    hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));

    //
    // Write the audio data
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Lock(0, dwBufferBytes, &pvLock, &dwLock, NULL, NULL, 0));
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvLock, dwLock, dwSamplesPerSec, dwBitsPerSample, dwChannelCount, dwToneFrequency);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Unlock(pvLock, dwLock, NULL, 0));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    return hr;
}


/****************************************************************************
 *
 *  CreateImpulseBuffer
 *
 *  Description:
 *      Creates a simple sine-wave impulse buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: sampling rate.
 *      DWORD [in]: bits per sample.
 *      DWORD [in]: channel count.
 *      DWORD [in]: tone frequency.
 *      DWORD [in]: lead-in length, in seconds.
 *      DWORD [in]: rolloff length, in seconds.
 *      DWORD [in]: buffer mixbin assignments.
 *      LPDIRECTSOUNDBUFFER * [out]: buffer.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CreateImpulseBuffer"

HRESULT
CreateImpulseBuffer
(
    DWORD                   dwFlags,
    DWORD                   dwSamplesPerSec,
    DWORD                   dwBitsPerSample,
    DWORD                   dwChannelCount,
    DWORD                   dwToneFrequency,
    DWORD                   dwLeadIn,
    DWORD                   dwRollOff,
    LPCDSMIXBINS            pMixBins, 
    LPDIRECTSOUNDBUFFER *   ppBuffer
)
{
    WAVEFORMATEX            wfxFormat       = INIT_PCM_WAVEFORMAT(dwChannelCount, dwSamplesPerSec, dwBitsPerSample);
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    DWORD                   dwImpulseLength;
    DSBUFFERDESC            dsbd;
    LPVOID                  pvLock;
    DWORD                   dwLock;
    HRESULT                 hr;

    ASSERT(!(dwSamplesPerSec % dwToneFrequency));
    ASSERT(!((dwSamplesPerSec / dwToneFrequency) % 2));

    //
    // Convert the lead-in, rolloff and impulse length to bytes
    //

    dwLeadIn *= wfxFormat.nAvgBytesPerSec;
    dwRollOff *= wfxFormat.nAvgBytesPerSec;
    dwImpulseLength = (dwSamplesPerSec / dwToneFrequency / 2) * wfxFormat.nBlockAlign;

    //
    // Create the buffer
    //

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = dwFlags;
    dsbd.lpwfxFormat = &wfxFormat;
    dsbd.dwBufferBytes = dwLeadIn + dwImpulseLength + dwRollOff;
    dsbd.lpMixBins = pMixBins;

    hr = ValidateResult(DirectSoundCreateBuffer(&dsbd, &pBuffer));

    //
    // Write the audio data
    //

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Lock(dwLeadIn, dwImpulseLength, &pvLock, &dwLock, NULL, NULL, 0));
        // hr = ValidateResult(pBuffer->Lock(0, dsbd.dwBufferBytes, &pvLock, &dwLock, NULL, NULL, 0));
    }

    if(SUCCEEDED(hr))
    {
        GenerateTone(pvLock, dwLock, dwSamplesPerSec, dwBitsPerSample, dwChannelCount, dwToneFrequency);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(pBuffer->Unlock(pvLock, dwLock, NULL, 0));
    }

    //
    // Success
    //

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    return hr;
}


/****************************************************************************
 *
 *  FlushStream
 *
 *  Description:
 *      Flushes a sound stream.
 *
 *  Arguments:
 *      LPDIRECTSOUNDSTREAM [in]: stream.
 *      DWORD [in]: flags.
 *      DWORD [in]: delay, in milliseconds.
 *      BOOL [in]: TRUE to wait for the flush to complete.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FlushStream"

HRESULT
FlushStream
(
    LPDIRECTSOUNDSTREAM     pStream,
    DWORD                   dwFlags,
    DWORD                   dwDelay,
    BOOL                    fWait
)
{
    REFERENCE_TIME          rtTimeStamp = -(LONGLONG)dwDelay * 10000;
    HRESULT                 hr;

    if(dwDelay)
    {
        DPF_TEST("Flushing stream (delayed %lu ms)", dwDelay);
    }
    else
    {
        DPF_TEST("Flushing stream");
    }

    hr = ValidateResult(pStream->FlushEx(rtTimeStamp, dwFlags));

    if(SUCCEEDED(hr) && fWait)
    {
        hr = WaitStream(pStream, FALSE);
    }

    return hr;
}


/****************************************************************************
 *
 *  WaitStream
 *
 *  Description:
 *      Waits for a stream's status to change.
 *
 *  Arguments:
 *      LPDIRECTSOUNDSTREAM [in]: stream.
 *      BOOL [in]: TRUE to wait for the stream to start playing, FALSE to
 *                 wait for it to stop.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "WaitStream"

HRESULT
WaitStream
(
    LPDIRECTSOUNDSTREAM     pStream,
    BOOL                    fPlaying
)
{
    const DWORD             dwStatusMask    = DSSTREAMSTATUS_PLAYING;
    const DWORD             dwWaitStatus    = fPlaying ? DSSTREAMSTATUS_PLAYING : 0;
    DWORD                   dwStatus;
    HRESULT                 hr;

    while(TRUE)
    {
        DirectSoundDoWork();
        
        hr = ValidateResult(pStream->GetStatus(&dwStatus));

        if(FAILED(hr))
        {
            break;
        }

        if((dwStatus & dwStatusMask) == dwWaitStatus)
        {
            DPF_TEST("Stream %s", fPlaying ? "playing" : "stopped");
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\test\testmem.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       testmem.cpp
 *  Content:    Memory usage tests.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  10/18/01    dereks  Created.
 *
 ****************************************************************************/

#include "testds.h"

typedef struct
{
    DWORD   dwPool;
    DWORD   dwPhysical;
    DWORD   dwSlop;
    DWORD   dwRecovered;
} DSMEMUSAGE, *LPDSMEMUSAGE;

typedef const DSMEMUSAGE *LPCDSMEMUSAGE;
typedef const DSMEMUSAGE &REFDSMEMUSAGE;


/****************************************************************************
 *
 *  GetCurrentMemoryUsage
 *
 *  Description:
 *      Saves the current memory usage numbers.
 *
 *  Arguments:
 *      LPDSMEMUSAGE [out]: memory usage data.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetCurrentMemoryUsage"

__inline void
GetCurrentMemoryUsage
(
    LPDSMEMUSAGE            pMemory
)
{
    pMemory->dwPool = g_dwDirectSoundPoolMemoryUsage;
    pMemory->dwPhysical = g_dwDirectSoundPhysicalMemoryUsage;
    pMemory->dwSlop = g_dwDirectSoundPhysicalMemorySlop;
    pMemory->dwRecovered = g_dwDirectSoundPhysicalMemoryRecovered;
}


/****************************************************************************
 *
 *  DumpCurrentMemoryUsage
 *
 *  Description:
 *      Dumps the amount of memory used by a test.
 *
 *  Arguments:
 *      LPCSTR [in]: test name.
 *      LPDSMEMUSAGE [in/out]: on entry, "before" usage.  On exit, "after"
 *                             usage.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DumpCurrentMemoryUsage"

void
DumpCurrentMemoryUsage
(
    LPCSTR                  pszTest,
    LPDSMEMUSAGE            pBefore
)
{
    DSMEMUSAGE              After;
    DSMEMUSAGE              Diff;

    GetCurrentMemoryUsage(&After);

    Diff.dwPool = After.dwPool - pBefore->dwPool;
    Diff.dwPhysical = After.dwPhysical - pBefore->dwPhysical;
    Diff.dwSlop = After.dwSlop - pBefore->dwSlop;
    Diff.dwRecovered = After.dwRecovered - pBefore->dwRecovered;

    DPF_TEST("%s: %ld pool, %ld physical (%ld slop), %ld recovered, %ld total", pszTest, Diff.dwPool, Diff.dwPhysical, Diff.dwSlop, Diff.dwRecovered, Diff.dwPool + Diff.dwPhysical + Diff.dwRecovered);

    *pBefore = After;
}


/****************************************************************************
 *
 *  TestMemoryUsage
 *
 *  Description:
 *      Determines the amount of memory used by each object type.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "TestMemoryUsage"

HRESULT
TestMemoryUsage
(
    void
)
{
    WAVEFORMATEX            wfxFormat       = INIT_PCM_WAVEFORMAT(1, 48000, 16);
    LPDIRECTSOUND           pDirectSound    = NULL;
    LPDIRECTSOUNDBUFFER     pBuffer         = NULL;
    LPDIRECTSOUNDSTREAM     pStream         = NULL;
    LPAC97MEDIAOBJECT       pAnalogAc97     = NULL;
    LPAC97MEDIAOBJECT       pDigitalAc97    = NULL;
    DSMEMUSAGE              Memory;
    DSBUFFERDESC            dsbd;
    DSSTREAMDESC            dssd;
    HRESULT                 hr;

    DirectSoundUseLightHRTF();

    GetCurrentMemoryUsage(&Memory);

    hr = ValidateResult(DirectSoundCreate(NULL, &pDirectSound, NULL));

    if(SUCCEEDED(hr))
    {
        DumpCurrentMemoryUsage("DirectSoundCreate", &Memory);
    }

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(LoadEffectsImage("dsstdfx", XAUDIO_DOWNLOADFX_XBESECTION));
    }

    if(SUCCEEDED(hr))
    {
        DumpCurrentMemoryUsage("DownloadEffectsImage (dsstdfx)", &Memory);
    }

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dsbd, sizeof(dsbd));

        dsbd.dwSize = sizeof(dsbd);
        dsbd.lpwfxFormat = &wfxFormat;

        hr = ValidateResult(pDirectSound->CreateSoundBuffer(&dsbd, &pBuffer, NULL));
    }

    if(SUCCEEDED(hr))
    {
        DumpCurrentMemoryUsage("CreateSoundBuffer (2D)", &Memory);
    }

    RELEASE(pBuffer);

    GetCurrentMemoryUsage(&Memory);

    if(SUCCEEDED(hr))
    {
        dsbd.dwFlags |= DSBCAPS_CTRL3D;
        
        hr = ValidateResult(pDirectSound->CreateSoundBuffer(&dsbd, &pBuffer, NULL));
    }

    if(SUCCEEDED(hr))
    {
        DumpCurrentMemoryUsage("CreateSoundBuffer (3D)", &Memory);
    }
        
    RELEASE(pBuffer);

    GetCurrentMemoryUsage(&Memory);

    if(SUCCEEDED(hr))
    {
        ZeroMemory(&dssd, sizeof(dssd));

        dssd.lpwfxFormat = &wfxFormat;
        dssd.dwMaxAttachedPackets = 4;

        hr = ValidateResult(pDirectSound->CreateSoundStream(&dssd, &pStream, NULL));
    }

    if(SUCCEEDED(hr))
    {
        DumpCurrentMemoryUsage("CreateSoundStream (2D, 4 packets)", &Memory);
    }

    RELEASE(pStream);

    GetCurrentMemoryUsage(&Memory);

    if(SUCCEEDED(hr))
    {
        dssd.dwFlags |= DSBCAPS_CTRL3D;

        hr = ValidateResult(pDirectSound->CreateSoundStream(&dssd, &pStream, NULL));
    }

    if(SUCCEEDED(hr))
    {
        DumpCurrentMemoryUsage("CreateSoundStream (3D, 4 packets)", &Memory);
    }

    RELEASE(pStream);
    RELEASE(pDirectSound);

    GetCurrentMemoryUsage(&Memory);

    ASSERT(!Memory.dwPool);
    ASSERT(!Memory.dwPhysical);
    ASSERT(!Memory.dwSlop);
    ASSERT(!Memory.dwRecovered);

    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(Ac97CreateMediaObject(DSAC97_CHANNEL_ANALOG, NULL, NULL, &pAnalogAc97));
    }

    if(SUCCEEDED(hr))
    {
        DumpCurrentMemoryUsage("Ac97CreateMediaObject (first)", &Memory);
    }
        
    if(SUCCEEDED(hr))
    {
        hr = ValidateResult(Ac97CreateMediaObject(DSAC97_CHANNEL_DIGITAL, NULL, NULL, &pDigitalAc97));
    }

    if(SUCCEEDED(hr))
    {
        DumpCurrentMemoryUsage("Ac97CreateMediaObject (second)", &Memory);
    }

    RELEASE(pAnalogAc97);
    RELEASE(pDigitalAc97);
        
    DirectSoundDumpMemoryUsage(TRUE);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\acm\driver.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       driver.cpp
 *  Content:    XBox ADPCM ACM driver.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/29/01    dereks  Created.
 *
 ****************************************************************************/

#include "imaadpcm.h"
#include "resource.h"
#include "stdio.h"

#if DBG
#define DPF DbgPrint
#else
#pragma warning(disable:4002)
#define DPF()
#endif

#define XBOX_ADPCM_SAMPLES_PER_BLOCK    64

#define VERSION_ACM_DRIVER              MAKE_ACM_VERSION(4,  0, 0)
#define VERSION_MSACM                   MAKE_ACM_VERSION(3, 50, 0)

enum
{
    XBOX_ADPCM_FORMAT_INDEX_PCM = 0,
    XBOX_ADPCM_FORMAT_INDEX_ADPCM,
    XBOX_ADPCM_FORMAT_INDEX_COUNT,
};

//
// The driver object
//

class CXboxAdpcmDriver
{
public:
    static const DWORD      m_adwStdSamplingRates[];    // "Standard" sampling rates used by this CODEC
    static DWORD            m_dwOpenDriverCount;        // Count of driver instances currently open

public:
    // Driver functions
    static LONG OpenDriver(HDRVR hdrvr, LPACMDRVOPENDESC pOpen);
    static LONG CloseDriver(HDRVR hdrvr, DWORD dwDriverId);
    static LONG GetDriverDetails(HDRVR hdrvr, LPACMDRIVERDETAILS pDetails);
    static LONG GetFormatTagDetails(HDRVR hdrvr, LPACMFORMATTAGDETAILS pDetails, DWORD dwFlags);
    static LONG GetFormatDetails(HDRVR hdrvr, LPACMFORMATDETAILS pDetails, DWORD dwFlags);
    static LONG SuggestFormat(HDRVR hdrvr, LPACMDRVFORMATSUGGEST pSuggest);
    static LONG OpenStream(HDRVR hdrvr, LPACMDRVSTREAMINSTANCE pStream);
    static LONG CloseStream(HDRVR hdrvr, LPACMDRVSTREAMINSTANCE pStream);
    static LONG GetStreamSize(HDRVR hdrvr, LPACMDRVSTREAMINSTANCE pStream, LPACMDRVSTREAMSIZE pSize);
    static LONG ConvertStream(HDRVR hdrvr, LPACMDRVSTREAMINSTANCE pStream, LPACMDRVSTREAMHEADER pHeader);

    // Format helpers
    static BOOL IsValidPcmFormat(LPCWAVEFORMATEX pwfx);
    static BOOL IsValidAdpcmFormat(LPCIMAADPCMWAVEFORMAT pwfx);

    static void CreatePcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPWAVEFORMATEX pwfx);
    static void CreateAdpcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPIMAADPCMWAVEFORMAT pwfx);
};

const DWORD CXboxAdpcmDriver::m_adwStdSamplingRates[] =
{
    8000,
    11025,
    16000,
    22050,
    32000,
    44100,
    48000
};

DWORD CXboxAdpcmDriver::m_dwOpenDriverCount = 0;

__inline BOOL CXboxAdpcmDriver::IsValidPcmFormat(LPCWAVEFORMATEX pwfx)
{
    return CImaAdpcmCodec::IsValidPcmFormat(pwfx);
}

__inline BOOL CXboxAdpcmDriver::IsValidAdpcmFormat(LPCIMAADPCMWAVEFORMAT pwfx)
{
    if(!CImaAdpcmCodec::IsValidImaAdpcmFormat(pwfx))
    {
        return FALSE;
    }

    if(XBOX_ADPCM_SAMPLES_PER_BLOCK != pwfx->wSamplesPerBlock)
    {
        return FALSE;
    }

    return TRUE;
}

__inline void CXboxAdpcmDriver::CreatePcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPWAVEFORMATEX pwfx)
{
    CImaAdpcmCodec::CreatePcmFormat(nChannels, nSamplesPerSec, pwfx);
}

__inline void CXboxAdpcmDriver::CreateAdpcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPIMAADPCMWAVEFORMAT pwfx)
{
    CImaAdpcmCodec::CreateImaAdpcmFormat(nChannels, nSamplesPerSec, XBOX_ADPCM_SAMPLES_PER_BLOCK, pwfx);
}


/****************************************************************************
 *
 *  DbgPrint
 *
 *  Description:
 *      Prints a string to the debugger.
 *
 *  Arguments:
 *      LPCSTR [in]: format string.
 *      ... [in]: format arguments.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void __cdecl 
DbgPrint
(
    LPCSTR                  pszFormat,
    ...
)
{
    CHAR                    szFinal[0x400];
    va_list                 va;

    OutputDebugString("XBADPCM: ");
    
    va_start(va, pszFormat);
    vsprintf(szFinal, pszFormat, va);
    va_end(va);

    strcat(szFinal, "\n");

    OutputDebugStringA(szFinal);

}


/****************************************************************************
 *
 *  MyLoadStringW
 *
 *  Description:
 *      Loads a unicode version of a resource string.
 *
 *  Arguments:
 *      HINSTANCE [in]: module instance handle.
 *      UINT [in]: resource identifier.
 *      LPWSTR [in]: resource buffer.
 *      int [in]: size of buffer.
 *
 *  Returns:  
 *      int: number of characters copied to the buffer.
 *
 ****************************************************************************/
 
#ifndef UNICODE

int
MyLoadStringW
(
    HINSTANCE               hInst,
    UINT                    nResourceId,
    LPWSTR                  pszString,
    int                     nStringLength
)
{
    CHAR                    szAnsi[0x100];

    //
    // Load the ANSI version
    //

    if(!LoadStringA(hInst, nResourceId, szAnsi, NUMELMS(szAnsi)))
    {
        return 0;
    }

    //
    // Convert to UNICODE
    //

    return MultiByteToWideChar(CP_ACP, 0, szAnsi, -1, pszString, nStringLength);
}

#define LoadStringW MyLoadStringW

#endif // UNICODE


/****************************************************************************
 *
 *  DriverProc
 *
 *  Description:
 *      Driver entry point.
 *
 *  Arguments:
 *      DWORD [in]: driver identifier.
 *      HDRVR [in]: driver handle.
 *      UINT [in]: driver message.
 *      LPARAM [in]: message parameter 1.
 *      LPARAM [in]: message parameter 2.
 *
 *  Returns:  
 *      LONG: non-zero on success.
 *
 ****************************************************************************/

EXTERN_C
LONG
CALLBACK
DriverProc
(
    DWORD                   dwDriverId, 
    HDRVR                   hdrvr,
    UINT                    uMsg,
    LPARAM                  lParam1,
    LPARAM                  lParam2
)
{
    if(uMsg >= ACMDM_BASE)
    {
        DPF("ACM message %lu:  %x %x %x %x", uMsg - ACMDM_BASE, dwDriverId, hdrvr, lParam1, lParam2);
    }
    else
    {
        DPF("System message %lu:  %x %x %x %x", uMsg, dwDriverId, hdrvr, lParam1, lParam2);
    }

    //
    // Handle generic driver messages
    //

    switch(uMsg)
    {
        case DRV_CONFIGURE:
        case DRV_QUERYCONFIGURE:
            
            //
            // We're not supporting configuration
            //

            return 0;

        case DRV_LOAD:
        case DRV_FREE:
            
            //
            // Ok, thanks.  We're ready to go
            //

            return 1;

        case DRV_DISABLE:
        case DRV_ENABLE:
        case DRV_POWER:
            
            //
            // Ignored
            //

            return 0;

        case DRV_INSTALL:
        case DRV_REMOVE:

            //
            // No extra install necessary
            //

            return DRVCNF_OK;

        case ACMDM_DRIVER_ABOUT:

            //
            // Not supporting an about box
            //

            return MMSYSERR_NOTSUPPORTED;
    }

    //
    // Handle the specific message
    //

    switch(uMsg)
    {
        case DRV_OPEN:
            
            //
            // Handle the open operation
            //

            return CXboxAdpcmDriver::OpenDriver(hdrvr, (LPACMDRVOPENDESC)lParam2);

        case DRV_CLOSE:
            
            //
            // Close the driver instance
            //
            
            return CXboxAdpcmDriver::CloseDriver(hdrvr, dwDriverId);

        case ACMDM_DRIVER_DETAILS:
            
            //
            // Get driver details
            //

            return CXboxAdpcmDriver::GetDriverDetails(hdrvr, (LPACMDRIVERDETAILS)lParam1);

        case ACMDM_FORMAT_SUGGEST:

            //
            // Suggest a format
            //

            return CXboxAdpcmDriver::SuggestFormat(hdrvr, (LPACMDRVFORMATSUGGEST)lParam1);

        case ACMDM_FORMATTAG_DETAILS:

            //
            // Get format tag details
            //

            return CXboxAdpcmDriver::GetFormatTagDetails(hdrvr, (LPACMFORMATTAGDETAILS)lParam1, (DWORD)lParam2);

        case ACMDM_FORMAT_DETAILS:
            
            //
            // Get format details
            //

            return CXboxAdpcmDriver::GetFormatDetails(hdrvr, (LPACMFORMATDETAILS)lParam1, (DWORD)lParam2);

        case ACMDM_STREAM_OPEN:
            
            //
            // Open a new stream
            //

            return CXboxAdpcmDriver::OpenStream(hdrvr, (LPACMDRVSTREAMINSTANCE)lParam1);

        case ACMDM_STREAM_CLOSE:
            
            //
            // Close an open stream
            //

            return CXboxAdpcmDriver::CloseStream(hdrvr, (LPACMDRVSTREAMINSTANCE)lParam1);

        case ACMDM_STREAM_SIZE:
            
            //
            // Get the size of converted data
            //

            return CXboxAdpcmDriver::GetStreamSize(hdrvr, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMSIZE)lParam2);

        case ACMDM_STREAM_CONVERT:

            //
            // Convert a stream of data
            //

            return CXboxAdpcmDriver::ConvertStream(hdrvr, (LPACMDRVSTREAMINSTANCE)lParam1, (LPACMDRVSTREAMHEADER)lParam2);
    }

    return DefDriverProc(dwDriverId, hdrvr, uMsg, lParam1, lParam2);
}


/****************************************************************************
 *
 *  OpenDriver
 *
 *  Description:
 *      Initializes the driver object.
 *
 *  Arguments:
 *      LPACMDRVOPENDESC [in/out]: ACM data.
 *
 *  Returns:  
 *      LONG: driver instance.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::OpenDriver
(
    HDRVR                   hdrvr,
    LPACMDRVOPENDESC        pOpen
)
{
    HINSTANCE               hInst;

    //
    // Refuse to open if we're being called from anyone but ACM
    //

    if(pOpen)
    {
        if(ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC != pOpen->fccType)
        {
            return 0;
        }
    }

    //
    // Tell ACM that we loaded successfully
    //

    if(pOpen)
    {
        pOpen->dwError = MMSYSERR_NOERROR;
    }

    //
    // Increment the count of open driver instances
    //
    
    m_dwOpenDriverCount++;

    DPF("Driver %lu open", m_dwOpenDriverCount);

    return m_dwOpenDriverCount;
}


/****************************************************************************
 *
 *  CloseDriver
 *
 *  Description:
 *      Closes a driver instance.
 *
 *  Arguments:
 *      DWORD [in]: driver instance.
 *
 *  Returns:  
 *      LONG: non-zero on success.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::CloseDriver
(
    HDRVR                   hdrvr,
    DWORD                   dwDriverId
)
{
    DPF("CloseDriver %lu", dwDriverId);

    if(dwDriverId > m_dwOpenDriverCount)
    {
        DPF("Invalid driver identifier");
        return 0;
    }

    m_dwOpenDriverCount--;

    return 1;
}


/****************************************************************************
 *
 *  GetDriverDetails
 *
 *  Description:
 *      Gets information about the driver.
 *
 *  Arguments:
 *      HDRVR [in]: driver handle.
 *      LPACMDRIVERDETAILS [in/out]: driver details.
 *
 *  Returns:  
 *      LONG: MMSYSTEM error code.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::GetDriverDetails
(
    HDRVR                   hdrvr,
    LPACMDRIVERDETAILS      pDetails
)
{
    HINSTANCE               hInst;
    ACMDRIVERDETAILS        add;

    DPF("GetDriverDetails");

    hInst = GetDriverModuleHandle(hdrvr);

    ZeroMemory(&add, sizeof(add));
    
    add.cbStruct = sizeof(add);
    add.fccType = ACMDRIVERDETAILS_FCCTYPE_AUDIOCODEC;
    add.fccComp = ACMDRIVERDETAILS_FCCCOMP_UNDEFINED;
    add.wMid = MM_MICROSOFT;
    add.wPid = WAVE_FORMAT_XBOX_ADPCM; // BUGBUG
    add.vdwACM = VERSION_MSACM;
    add.vdwDriver = VERSION_ACM_DRIVER;
    add.fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    add.cFormatTags = XBOX_ADPCM_FORMAT_INDEX_COUNT;

    LoadStringW(hInst, IDS_ACM_DRIVER_SHORTNAME, add.szShortName, NUMELMS(add.szShortName));
    LoadStringW(hInst, IDS_ACM_DRIVER_LONGNAME,  add.szLongName,  NUMELMS(add.szLongName));
    LoadStringW(hInst, IDS_ACM_DRIVER_COPYRIGHT, add.szCopyright, NUMELMS(add.szCopyright));
    LoadStringW(hInst, IDS_ACM_DRIVER_LICENSING, add.szLicensing, NUMELMS(add.szLicensing));
    LoadStringW(hInst, IDS_ACM_DRIVER_FEATURES,  add.szFeatures,  NUMELMS(add.szFeatures));

    CopyMemory(pDetails, &add, min(pDetails->cbStruct, add.cbStruct));

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *
 *  GetFormatTagDetails
 *
 *  Description:
 *      Gets information about formats supported by this driver.
 *
 *  Arguments:
 *      LPACMFORMATTAGDETAILS [in/out]: format tag details.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      LONG: MMSYSTEM error code.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::GetFormatTagDetails
(
    HDRVR                   hdrvr,
    LPACMFORMATTAGDETAILS   pDetails,
    DWORD                   dwFlags
)
{
    HINSTANCE               hInst;
    DWORD                   dwFormatTag;
    
    DPF("GetFormatTagDetails");

    if(pDetails->cbStruct < sizeof(*pDetails))
    {
        DPF("Details structure too small");
        return ACMERR_NOTPOSSIBLE;
    }

    hInst = GetDriverModuleHandle(hdrvr);

    switch(dwFlags)
    {
        case ACM_FORMATTAGDETAILSF_INDEX:
            
            switch(pDetails->dwFormatTagIndex)
            {
                case XBOX_ADPCM_FORMAT_INDEX_PCM:
                    dwFormatTag = WAVE_FORMAT_PCM;
                    break;

                case XBOX_ADPCM_FORMAT_INDEX_ADPCM:
                    dwFormatTag = WAVE_FORMAT_XBOX_ADPCM;
                    break;

                default:
                    DPF("Bad format tag index");
                    return ACMERR_NOTPOSSIBLE;
            }
            
            break;

        case ACM_FORMATTAGDETAILSF_LARGESTSIZE:

            if(WAVE_FORMAT_UNKNOWN == pDetails->dwFormatTag)
            {
                dwFormatTag = WAVE_FORMAT_XBOX_ADPCM;
            }
            else
            {
                dwFormatTag = pDetails->dwFormatTag;
            }

            break;

        case ACM_FORMATTAGDETAILSF_FORMATTAG:
            dwFormatTag = pDetails->dwFormatTag;
            break;

        default:
            DPF("Bad tag details request");
            return MMSYSERR_NOTSUPPORTED;
    }

    switch(dwFormatTag)
    {
        case WAVE_FORMAT_PCM:
            DPF("Returning PCM tag details");
            
            pDetails->dwFormatTagIndex = XBOX_ADPCM_FORMAT_INDEX_PCM;
            pDetails->dwFormatTag = WAVE_FORMAT_PCM;
            pDetails->cbFormatSize = sizeof(PCMWAVEFORMAT);
            
            pDetails->szFormatTag[0] = 0;

            break;

        case WAVE_FORMAT_XBOX_ADPCM:
            DPF("Returning ADPCM tag details");
            
            pDetails->dwFormatTagIndex = XBOX_ADPCM_FORMAT_INDEX_ADPCM;
            pDetails->dwFormatTag = WAVE_FORMAT_XBOX_ADPCM;
            pDetails->cbFormatSize = sizeof(IMAADPCMWAVEFORMAT);

            LoadStringW(hInst, IDS_ACM_DRIVER_TAG_NAME, pDetails->szFormatTag, NUMELMS(pDetails->szFormatTag));

            break;

        default:
            DPF("Bad format tag");
            return ACMERR_NOTPOSSIBLE;
    }

    pDetails->cbStruct = sizeof(*pDetails);
    pDetails->fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    pDetails->cStandardFormats = IMAADPCM_MAX_CHANNELS * NUMELMS(m_adwStdSamplingRates);

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *
 *  GetFormatDetails
 *
 *  Description:
 *      Gets information about formats supported by this driver.
 *
 *  Arguments:
 *      LPACMFORMATDETAILS [in/out]: format tag details.
 *      DWORD [in]: flags.
 *
 *  Returns:  
 *      LONG: MMSYSTEM error code.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::GetFormatDetails
(
    HDRVR                   hdrvr,
    LPACMFORMATDETAILS      pDetails,
    DWORD                   dwFlags
)
{
    HINSTANCE               hInst;
    DWORD                   dwSamplingRateIndex;
    DWORD                   dwSamplingRate;
    DWORD                   dwChannelCount;
    
    DPF("GetFormatDetails");

    if(pDetails->cbStruct < sizeof(*pDetails))
    {
        DPF("Details structure too small");
        return ACMERR_NOTPOSSIBLE;
    }

    hInst = GetDriverModuleHandle(hdrvr);

    switch(dwFlags)
    {
        case ACM_FORMATDETAILSF_INDEX:
            
            //
            // Fill in format by index
            //

            dwSamplingRateIndex = pDetails->dwFormatIndex / IMAADPCM_MAX_CHANNELS;

            if(dwSamplingRateIndex >= NUMELMS(m_adwStdSamplingRates))
            {
                return ACMERR_NOTPOSSIBLE;
            }

            dwChannelCount = (pDetails->dwFormatIndex % IMAADPCM_MAX_CHANNELS) + 1;
            dwSamplingRate = m_adwStdSamplingRates[dwSamplingRateIndex];

            switch(pDetails->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:
                    
                    if(pDetails->cbwfx < sizeof(PCMWAVEFORMAT))
                    {
                        DPF("Format buffer too small for PCM");
                        return ACMERR_NOTPOSSIBLE;
                    }

                    DPF("Returning PCM details");

                    CreatePcmFormat((WORD)dwChannelCount, dwSamplingRate, pDetails->pwfx);

                    break;

                case WAVE_FORMAT_XBOX_ADPCM:

                    if(pDetails->cbwfx < sizeof(IMAADPCMWAVEFORMAT))
                    {
                        DPF("Format buffer too small for ADPCM");
                        return ACMERR_NOTPOSSIBLE;
                    }

                    DPF("Returning ADPCM details");

                    CreateAdpcmFormat((WORD)dwChannelCount, dwSamplingRate, (LPIMAADPCMWAVEFORMAT)pDetails->pwfx);

                    break;

                default:
                    DPF("Bad format tag");
                    return ACMERR_NOTPOSSIBLE;
            }

            break;

        case ACM_FORMATDETAILSF_FORMAT:

            //
            // Just validate the format
            //

            switch(pDetails->dwFormatTag)
            {
                case WAVE_FORMAT_PCM:

                    if(pDetails->cbwfx < sizeof(PCMWAVEFORMAT))
                    {
                        DPF("Format buffer too small for PCM");
                        return ACMERR_NOTPOSSIBLE;
                    }

                    if(!IsValidPcmFormat(pDetails->pwfx))
                    {
                        DPF("Bad PCM format");
                        return ACMERR_NOTPOSSIBLE;
                    }

                    break;

                case WAVE_FORMAT_XBOX_ADPCM:

                    if(pDetails->cbwfx < sizeof(IMAADPCMWAVEFORMAT))
                    {
                        DPF("Format buffer too small for ADPCM");
                        return ACMERR_NOTPOSSIBLE;
                    }

                    if(!IsValidAdpcmFormat((LPCIMAADPCMWAVEFORMAT)pDetails->pwfx))
                    {
                        DPF("Bad ADPCM format");
                        return ACMERR_NOTPOSSIBLE;
                    }

                    break;

                default:
                    DPF("Bad format tag");
                    return ACMERR_NOTPOSSIBLE;
            }

            break;

        default:
            DPF("Bad details request");
            return MMSYSERR_NOTSUPPORTED;
    }

    pDetails->cbStruct = sizeof(*pDetails);
    pDetails->fdwSupport = ACMDRIVERDETAILS_SUPPORTF_CODEC;
    pDetails->szFormat[0] = 0;

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *
 *  SuggestFormat
 *
 *  Description:
 *      Suggest a compatible format.
 *
 *  Arguments:
 *      LPACMDRVFORMATSUGGEST [in/out]: format suggestion data.
 *
 *  Returns:  
 *      LONG: MMSYSTEM error code.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::SuggestFormat
(
    HDRVR                   hdrvr,
    LPACMDRVFORMATSUGGEST   pSuggest
)
{
    static const DWORD      dwSupportMask   = ACM_FORMATSUGGESTF_WFORMATTAG | ACM_FORMATSUGGESTF_NCHANNELS | ACM_FORMATSUGGESTF_NSAMPLESPERSEC | ACM_FORMATSUGGESTF_WBITSPERSAMPLE;
    IMAADPCMWAVEFORMAT      wfxAdpcm;

    DPF("SuggestFormat");

    //
    // Make sure we support the requested fields
    //

    if(pSuggest->fdwSuggest & ~dwSupportMask)
    {
        return MMSYSERR_NOTSUPPORTED;
    }

    if(WAVE_FORMAT_PCM == pSuggest->pwfxSrc->wFormatTag)
    {
        //
        // Verify that the format is valid for our purposes
        //

        if(pSuggest->cbwfxSrc < sizeof(PCMWAVEFORMAT))
        {
            DPF("Format buffer too small for PCM");
            return ACMERR_NOTPOSSIBLE;
        }

        if(pSuggest->cbwfxDst < sizeof(WAVEFORMATEX))
        {
            DPF("Format buffer too small for ADPCM");
            return ACMERR_NOTPOSSIBLE;
        }

        if(!IsValidPcmFormat(pSuggest->pwfxSrc))
        {
            DPF("Bad PCM format");
            return ACMERR_NOTPOSSIBLE;
        }

        //
        // If the destination format tag is specified, make sure it's
        // ADPCM.
        //

        if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG)
        {
            if(WAVE_FORMAT_XBOX_ADPCM != pSuggest->pwfxDst->wFormatTag)
            {
                DPF("Destination format tag not ADPCM");
                return ACMERR_NOTPOSSIBLE;
            }
        }

        //
        // If the destination channel count was specified, make sure
        // it's the same as the source.
        //

        if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_NCHANNELS)
        {
            if(pSuggest->pwfxSrc->nChannels != pSuggest->pwfxDst->nChannels)
            {
                DPF("Destination channel count not %lu", pSuggest->pwfxSrc->nChannels);
                return ACMERR_NOTPOSSIBLE;
            }
        }

        //
        // If the destination sampling rate was specified, make sure
        // it's the same as the source.
        //

        if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_NSAMPLESPERSEC)
        {
            if(pSuggest->pwfxSrc->nSamplesPerSec != pSuggest->pwfxDst->nSamplesPerSec)
            {
                DPF("Destination sampling rate not %lu", pSuggest->pwfxSrc->nSamplesPerSec);
                return ACMERR_NOTPOSSIBLE;
            }
        }

        //
        // If the destination bit resolution was specified, make sure it's
        // correct.
        //

        if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_WBITSPERSAMPLE)
        {
            if(IMAADPCM_BITS_PER_SAMPLE != pSuggest->pwfxDst->wBitsPerSample)
            {
                DPF("Destination bit resolution not %lu", IMAADPCM_BITS_PER_SAMPLE);
                return ACMERR_NOTPOSSIBLE;
            }
        }

        //
        // Fill in the format
        //

        DPF("Suggesting ADPCM format");

        CreateAdpcmFormat(pSuggest->pwfxSrc->nChannels, pSuggest->pwfxSrc->nSamplesPerSec, &wfxAdpcm);
        CopyMemory(pSuggest->pwfxDst, &wfxAdpcm, min(pSuggest->cbwfxDst, sizeof(wfxAdpcm)));

    }
    else if(WAVE_FORMAT_XBOX_ADPCM == pSuggest->pwfxSrc->wFormatTag)
    {
        if(pSuggest->cbwfxSrc < sizeof(IMAADPCMWAVEFORMAT))
        {
            DPF("Format buffer too small for ADPCM");
            return ACMERR_NOTPOSSIBLE;
        }

        if(pSuggest->cbwfxDst < sizeof(PCMWAVEFORMAT))
        {
            DPF("Format buffer too small for PCM");
            return ACMERR_NOTPOSSIBLE;
        }

        //
        // Verify that the format is valid for our purposes
        //

        if(!IsValidAdpcmFormat((LPCIMAADPCMWAVEFORMAT)pSuggest->pwfxSrc))
        {
            DPF("Bad ADPCM format");
            return ACMERR_NOTPOSSIBLE;
        }

        //
        // If the destination format tag is specified, make sure it's
        // PCM.
        //

        if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_WFORMATTAG)
        {
            if(WAVE_FORMAT_PCM != pSuggest->pwfxDst->wFormatTag)
            {
                DPF("Destination format tag not PCM");
                return ACMERR_NOTPOSSIBLE;
            }
        }

        //
        // If the destination channel count was specified, make sure
        // it's the same as the source.
        //

        if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_NCHANNELS)
        {
            if(pSuggest->pwfxSrc->nChannels != pSuggest->pwfxDst->nChannels)
            {
                DPF("Destination channel count not %lu", pSuggest->pwfxSrc->nChannels);
                return ACMERR_NOTPOSSIBLE;
            }
        }

        //
        // If the destination sampling rate was specified, make sure
        // it's the same as the source.
        //

        if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_NSAMPLESPERSEC)
        {
            if(pSuggest->pwfxSrc->nSamplesPerSec != pSuggest->pwfxDst->nSamplesPerSec)
            {
                DPF("Destination sampling rate not %lu", pSuggest->pwfxSrc->nSamplesPerSec);
                return ACMERR_NOTPOSSIBLE;
            }
        }

        //
        // If the destination bit resolution was specified, make sure it's
        // correct.
        //

        if(pSuggest->fdwSuggest & ACM_FORMATSUGGESTF_WBITSPERSAMPLE)
        {
            if(IMAADPCM_PCM_BITS_PER_SAMPLE != pSuggest->pwfxDst->wBitsPerSample)
            {
                DPF("Destination bit resolution not %lu", IMAADPCM_PCM_BITS_PER_SAMPLE);
                return ACMERR_NOTPOSSIBLE;
            }
        }

        //
        // Fill in the format
        //

        DPF("Suggesting PCM format");

        CreatePcmFormat(pSuggest->pwfxSrc->nChannels, pSuggest->pwfxSrc->nSamplesPerSec, pSuggest->pwfxDst);
    }
    else
    {
        // 
        // Bad format
        //

        DPF("Bad format tag");
        return ACMERR_NOTPOSSIBLE;
    }

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *
 *  OpenStream
 *
 *  Description:
 *      Opens a conversion stream.
 *
 *  Arguments:
 *      LPACMDRVSTREAMINSTANCE [in/out]: stream data.
 *
 *  Returns:  
 *      LONG: MMSYSTEM error code.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::OpenStream
(
    HDRVR                   hdrvr,
    LPACMDRVSTREAMINSTANCE  pStream
)
{
    LPCIMAADPCMWAVEFORMAT   pwfxEncode;
    LPCWAVEFORMATEX         pwfxDecode;
    BOOL                    fEncoder;
    CImaAdpcmCodec *        pCodec;

    DPF("OpenStream");

    //
    // Save pointers to the conversion formats
    //

    if(WAVE_FORMAT_PCM == pStream->pwfxSrc->wFormatTag)
    {
        if(WAVE_FORMAT_XBOX_ADPCM == pStream->pwfxDst->wFormatTag)
        {
            pwfxEncode = (LPCIMAADPCMWAVEFORMAT)pStream->pwfxDst;
            pwfxDecode = pStream->pwfxSrc;
        }
        else
        {
            DPF("Bad destination format tag");
            return ACMERR_NOTPOSSIBLE;
        }

        fEncoder = TRUE;
    }
    else if(WAVE_FORMAT_XBOX_ADPCM == pStream->pwfxSrc->wFormatTag)
    {
        if(WAVE_FORMAT_PCM == pStream->pwfxDst->wFormatTag)
        {
            pwfxEncode = (LPCIMAADPCMWAVEFORMAT)pStream->pwfxSrc;
            pwfxDecode = pStream->pwfxDst;
        }
        else
        {
            DPF("Bad destination format tag");
            return ACMERR_NOTPOSSIBLE;
        }

        fEncoder = FALSE;
    }
    else
    {
        DPF("Bad source format tag");
        return ACMERR_NOTPOSSIBLE;
    }
    
    if(!IsValidAdpcmFormat(pwfxEncode))
    {
        DPF("Bad ADPCM format");
        return ACMERR_NOTPOSSIBLE;
    }

    if(!IsValidPcmFormat(pwfxDecode))
    {
        DPF("Bad PCM format");
        return ACMERR_NOTPOSSIBLE;
    }

    if(pwfxEncode->wfx.nChannels != pwfxDecode->nChannels)
    {
        DPF("Channel-count mismatch");
        return ACMERR_NOTPOSSIBLE;
    }

    if(pwfxEncode->wfx.nSamplesPerSec != pwfxDecode->nSamplesPerSec)
    {
        DPF("Sampling-rate mismatch");
        return ACMERR_NOTPOSSIBLE;
    }

    //
    // Check for an open query as opposed to a full-on open operation
    //

    if(pStream->fdwOpen & ACM_STREAMOPENF_QUERY)
    {
        return MMSYSERR_NOERROR;
    }

    //
    // Create the CODEC object
    //

    if(!(pCodec = new CImaAdpcmCodec))
    {
        return MMSYSERR_NOMEM;
    }

    if(!pCodec->Initialize(pwfxEncode, fEncoder))
    {
        DPF("Failed to initialize CODEC");
        delete pCodec;
        return ACMERR_NOTPOSSIBLE;
    }

    //
    // Fill in stream instance data
    //

    pStream->fdwDriver = 0;
    pStream->dwDriver = (DWORD)pCodec;

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *
 *  CloseStream
 *
 *  Description:
 *      Closes an open conversion stream.
 *
 *  Arguments:
 *      LPACMDRVSTREAMINSTANCE [in/out]: stream data.
 *
 *  Returns:  
 *      LONG: MMSYSTEM error code.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::CloseStream
(
    HDRVR                   hdrvr,
    LPACMDRVSTREAMINSTANCE  pStream
)
{
    CImaAdpcmCodec *        pCodec  = (CImaAdpcmCodec *)pStream->dwDriver;

    DPF("CloseStream");

    if(pCodec)
    {
        delete pCodec;
    }

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *
 *  GetStreamSize
 *
 *  Description:
 *      Gets the expected size of a conversion operation.
 *
 *  Arguments:
 *      LPACMDRVSTREAMINSTANCE [in/out]: stream data.
 *      LPACMDRVSTREAMSIZE [in/out]: stream size data.
 *
 *  Returns:  
 *      LONG: MMSYSTEM error code.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::GetStreamSize
(
    HDRVR                   hdrvr,
    LPACMDRVSTREAMINSTANCE  pStream,
    LPACMDRVSTREAMSIZE      pSize
)
{
    CImaAdpcmCodec *        pCodec  = (CImaAdpcmCodec *)pStream->dwDriver;

    DPF("GetStreamSize");

    if(!pCodec)
    {
        DPF("No CODEC pointer");
        return ACMERR_NOTPOSSIBLE;
    }

    switch(pSize->fdwSize)
    {
        case ACM_STREAMSIZEF_SOURCE:
            
            //
            // How many bytes are needed to hold the converted data?
            //

            pSize->cbDstLength = pSize->cbSrcLength / pCodec->GetSourceAlignment() * pCodec->GetDestinationAlignment();

            break;

        case ACM_STREAMSIZEF_DESTINATION:
            
            //
            // How many bytes can be converted into the given buffer?
            //

            pSize->cbSrcLength = pSize->cbDstLength / pCodec->GetDestinationAlignment() * pCodec->GetSourceAlignment();

            break;

        default:
            DPF("Bad size request");
            return MMSYSERR_NOTSUPPORTED;
    }

    return MMSYSERR_NOERROR;
}


/****************************************************************************
 *
 *  ConvertStream
 *
 *  Description:
 *      Converts stream data.
 *
 *  Arguments:
 *      LPACMDRVSTREAMINSTANCE [in/out]: stream data.
 *      LPACMDRVSTREAMHEADER [in/out]: stream conversion data.
 *
 *  Returns:  
 *      LONG: MMSYSTEM error code.
 *
 ****************************************************************************/

LONG
CXboxAdpcmDriver::ConvertStream
(
    HDRVR                   hdrvr,
    LPACMDRVSTREAMINSTANCE  pStream,
    LPACMDRVSTREAMHEADER    pConvert
)
{
    CImaAdpcmCodec *        pCodec      = (CImaAdpcmCodec *)pStream->dwDriver;
    DWORD                   dwSrcBlocks;
    DWORD                   dwDstBlocks;
    DWORD                   dwBlocks;

    DPF("ConvertStream");

    if(!pCodec)
    {
        DPF("No CODEC pointer");
        return ACMERR_NOTPOSSIBLE;
    }

    //
    // Reset the CODEC if necessary
    //

    if(pConvert->fdwConvert & ACM_STREAMCONVERTF_START)
    {
        pCodec->Reset();
    }

    //
    // Calculate the number of blocks to convert
    //

    dwSrcBlocks = pConvert->cbSrcLength / pCodec->GetSourceAlignment();
    dwDstBlocks = pConvert->cbDstLength / pCodec->GetDestinationAlignment();

    dwBlocks = min(dwSrcBlocks, dwDstBlocks);

    //
    // Convert data
    //

    if(!pCodec->Convert(pConvert->pbSrc, pConvert->pbDst, dwBlocks))
    {
        DPF("CODEC failure");
        return ACMERR_NOTPOSSIBLE;
    }

    //
    // Return the amount of data converted
    //

    pConvert->cbSrcLengthUsed = dwBlocks * pCodec->GetSourceAlignment();
    pConvert->cbDstLengthUsed = dwBlocks * pCodec->GetDestinationAlignment();

    //
    // If the caller knew the source size wasn't block-aligned, we'll be nice
    // and tell them we used the little bit of crap at the end.
    //

    if(!(pConvert->fdwConvert & ACM_STREAMCONVERTF_BLOCKALIGN))
    {
        pConvert->cbSrcLengthUsed = pConvert->cbSrcLength;
    }

    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\acm\makefile.inc ===
$(_NT386TREE)\winx\dump\$(TARGETNAME).$(TARGETEXT): $(TARGET)
    copy $** $@

$(_NT386TREE)\winx\dump\$(TARGETNAME).inf: oemsetup.inf
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\acm\resource.h ===
#define IDS_ACM_DRIVER_SHORTNAME    1
#define IDS_ACM_DRIVER_LONGNAME     2
#define IDS_ACM_DRIVER_COPYRIGHT    3
#define IDS_ACM_DRIVER_LICENSING    4
#define IDS_ACM_DRIVER_FEATURES     5
#define IDS_ACM_DRIVER_TAG_NAME     6
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\acm\acmtest\acmtest.cpp ===
#include <windows.h>
#include <stdio.h>
#include <mmreg.h>
#include <msacm.h>

BOOL CALLBACK 
acmFormatEnumCallback
(
    HACMDRIVERID            hadid,
    LPACMFORMATDETAILSA     pafd,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
)
{
    printf("%s\n", pafd->szFormat);
    
    return TRUE;
}


BOOL CALLBACK
acmDriverEnumCallback
(
    HACMDRIVERID            hadid,
    DWORD                   dwInstance,
    DWORD                   fdwSupport
)
{
    ACMDRIVERDETAILS        add;
    HACMDRIVER              had;
    ACMFORMATDETAILS        afd;
    WAVEFORMATEX            wfxSrc;
    IMAADPCMWAVEFORMAT      wfxDst;
    MMRESULT                mmr;

    ZeroMemory(&add, sizeof(add));
    add.cbStruct = sizeof(add);
    
    ZeroMemory(&afd, sizeof(afd));
    afd.cbStruct = sizeof(afd);
    afd.dwFormatTag = 0x69;
    afd.pwfx = &wfxDst.wfx;
    afd.cbwfx = sizeof(wfxDst);

    ZeroMemory(&wfxDst, sizeof(wfxDst));
    wfxDst.wfx.wFormatTag = 0x69;

    wfxSrc.wFormatTag = WAVE_FORMAT_PCM;
    wfxSrc.nChannels = 2;
    wfxSrc.nSamplesPerSec = 22050;
    wfxSrc.wBitsPerSample = 16;
    wfxSrc.nBlockAlign = 4;
    wfxSrc.nAvgBytesPerSec = wfxSrc.nSamplesPerSec * wfxSrc.nBlockAlign;

    mmr = acmDriverDetails(hadid, &add, 0);
    mmr = acmDriverOpen(&had, hadid, 0);
    mmr = acmFormatEnum(had, &afd, acmFormatEnumCallback, 0, ACM_FORMATENUMF_WFORMATTAG);
    mmr = acmFormatSuggest(had, &wfxSrc, &wfxDst.wfx, sizeof(wfxDst), 0);
    mmr = acmDriverClose(had, 0);

    return TRUE;
}


void
main
(
    void
)
{
    MMRESULT                mmr;

    mmr = acmDriverEnum(acmDriverEnumCallback, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.h ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       imaadpcm.h
 *  Content:    IMA ADPCM CODEC.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/29/01    dereks  Created.
 *
 ****************************************************************************/

#ifndef __IMAADPCM_H__
#define __IMAADPCM_H__

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <ctype.h>
#include <mmreg.h>
#include <msacm.h>
#include <msacmdrv.h>

#define WAVE_FORMAT_XBOX_ADPCM          0x0069
                                        
#define IMAADPCM_BITS_PER_SAMPLE        4
#define IMAADPCM_HEADER_LENGTH          4
                                        
#define IMAADPCM_MAX_CHANNELS           2
#define IMAADPCM_PCM_BITS_PER_SAMPLE    16

#define NUMELMS(a) (sizeof(a) / sizeof(a[0]))

typedef const WAVEFORMATEX *LPCWAVEFORMATEX;
typedef const IMAADPCMWAVEFORMAT *LPCIMAADPCMWAVEFORMAT;

#ifdef __cplusplus

//
// IMA ADPCM encoder function prototype
//

typedef BOOL (*LPFNIMAADPCMCONVERT)(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);

//
// IMA ADPCM CODEC
//

class CImaAdpcmCodec
{
private:
    static const short      m_asNextStep[16];           // Step increment array
    static const short      m_asStep[89];               // Step value array
    IMAADPCMWAVEFORMAT      m_wfxEncode;                // Encoded format description
    BOOL                    m_fEncoder;                 // Is the object acting as an encoder?
    int                     m_nStepIndexL;              // Left-channel stepping index
    int                     m_nStepIndexR;              // Right-channel stepping index
    LPFNIMAADPCMCONVERT     m_pfnConvert;               // Conversion function

public:
    CImaAdpcmCodec(void);
    ~CImaAdpcmCodec(void);

public:
    // Initialization
    BOOL Initialize(LPCIMAADPCMWAVEFORMAT pwfxEncode, BOOL fEncoder);

    // Size conversions
    WORD GetEncodeAlignment(void);
    WORD GetDecodeAlignment(void);
    WORD GetSourceAlignment(void);
    WORD GetDestinationAlignment(void);

    // Data conversions
    BOOL Convert(LPCVOID pvSrc, LPVOID pvDst, UINT cBlocks);
    void Reset(void);

    // Format descriptions
    static void CreatePcmFormat(WORD nChannels, DWORD nSamplesPerSec, LPWAVEFORMATEX pwfxFormat);
    static void CreateImaAdpcmFormat(WORD nChannels, DWORD nSamplesPerSec, WORD nSamplesPerBlock, LPIMAADPCMWAVEFORMAT pwfxFormat);

    static BOOL IsValidPcmFormat(LPCWAVEFORMATEX pwfxFormat);
    static BOOL IsValidImaAdpcmFormat(LPCIMAADPCMWAVEFORMAT pwfxFormat);

private:
    // En/decoded data alignment
    static WORD CalculateEncodeAlignment(WORD nSamplesPerBlock, WORD nChannels);
    
    // Data conversion functions
    static BOOL EncodeM16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL EncodeS16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL DecodeM16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);
    static BOOL DecodeS16(LPBYTE pbSrc, LPBYTE pbDst, UINT cBlocks, UINT nBlockAlignment, UINT cSamplesPerBlock, LPINT pnStepIndexL, LPINT pnStepIndexR);

    static int EncodeSample(int nInputSample, int *nPredictedSample, int nStepSize);
    static int DecodeSample(int nInputSample, int nPredictedSample, int nStepSize);

    static int NextStepIndex(int nEncodedSample, int nStepIndex);
    static BOOL ValidStepIndex(int nStepIndex);
};

__inline WORD CImaAdpcmCodec::GetSourceAlignment(void)
{
    return m_fEncoder ? GetDecodeAlignment() : GetEncodeAlignment();
}

__inline WORD CImaAdpcmCodec::GetDestinationAlignment(void)
{
    return m_fEncoder ? GetEncodeAlignment() : GetDecodeAlignment();
}

__inline int CImaAdpcmCodec::NextStepIndex(int nEncodedSample, int nStepIndex)
{
    nStepIndex += m_asNextStep[nEncodedSample];

    if(nStepIndex < 0)
    {
        nStepIndex = 0;
    }
    else if(nStepIndex >= NUMELMS(m_asStep))
    {
        nStepIndex = NUMELMS(m_asStep) - 1;
    }

    return nStepIndex;
}

__inline BOOL CImaAdpcmCodec::ValidStepIndex(int nStepIndex)
{
    return (nStepIndex >= 0) && (nStepIndex < NUMELMS(m_asStep));
}

#endif // __cplusplus

#endif // __IMAADPCM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\acm\resrc1.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xbadpcm.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\AudAnalyze.cpp ===
#include "globals.h"

CClassTracker *g_pClassList = NULL;
BOOL g_bQuiet = FALSE;


HRESULT CommandLineParamFromCLSID(const GUID *pCLSID, LPSTR szParam);

CLSIDElement CLSIDTable[] =
{
{&CLSID_DirectMusic,                    "CLSID_DirectMusic",                "DirectMusicCreate(iid,ppvInterface)",              "DirectMusic object - not used on XBox"},
{&CLSID_DirectMusicCollection,          "CLSID_DirectMusicCollection",      "DirectMusicCollectionCreate(iid,ppvInterface)",    "DLS Collection: manages a DLS file - always required for MIDI + DLS"},
{&CLSID_DirectMusicSynth,               "CLSID_DirectMusicSynth",           "DirectMusicSynthCreate(iid,ppvInterface)",         "Synthesizer: controls the hardware synthesizer - always required"},
{&CLSID_DirectMusicFileStream,          "CLSID_DirectMusicFileStream",      "DirectMusicFileStreamCreate(iid,ppvInterface)",    "File Stream - used to read content from disk"},
{&CLSID_DirectMusicStreamStream,        "CLSID_DirectMusicStreamStream",    "DirectMusicStreamStreamCreate(iid,ppvInterface)",  "Stream wrapper - used to read content from app supplied IStream"},
{&CLSID_DirectMusicMemStream,           "CLSID_DirectMusicMemStream",       "DirectMusicMemStreamCreate(iid,ppvInterface)",     "Memory Stream - used to read content from memory"},
{&CLSID_DirectMusicSegment,             "CLSID_DirectMusicSegment",         "DirectMusicSegmentCreate(iid,ppvInterface)",       "Segment - primary playback mechanism - always required"},
{&CLSID_DirectMusicLoader,              "CLSID_DirectMusicLoader",          "DirectMusicLoaderCreate(iid,ppvInterface)",        "Loader: required to read files from disk and link objects. May be replaced by application"},
{&CLSID_DirectMusicTempoTrack,          "CLSID_DirectMusicTempoTrack",      "DirectMusicTempoTrackCreate(iid,ppvInterface)",    "Tempo Track - defines tempo changes, always required for music"},
{&CLSID_DirectMusicTimeSigTrack,        "CLSID_DirectMusicTimeSigTrack",    "DirectMusicTimeSigTrackCreate(iid,ppvInterface)",  "Time Signature Track - defines time signature in segments, always required for music synchronization"},
{&CLSID_DirectMusicBandTrack,           "CLSID_DirectMusicBandTrack",       "DirectMusicBandTrackCreate(iid,ppvInterface)",     "Band Track - manages one or more bands - always required for any MIDI + DLS playback"},
{&CLSID_DirectMusicPerformance,         "CLSID_DirectMusicPerformance",     "DirectMusicPerformanceCreate(iid,ppvInterface)",   "Performance - segment playback framework, always required"},
{&CLSID_DirectMusicBand,                "CLSID_DirectMusicBand",            "DirectMusicBandCreate(iid,ppvInterface)",          "Band - manages downloading of DLS instruments as well as volume and pan presets - always required for MIDI + DLS"},
{&CLSID_DirectMusicSeqTrack,            "CLSID_DirectMusicSeqTrack",        "DirectMusicSeqTrackCreate(iid,ppvInterface)",      "Sequence Track: plays straight MIDI sequences"},
{&CLSID_DirectSoundWave,                "CLSID_DirectSoundWave",            "DirectSoundWaveCreate(iid,ppvInterface)",          "Wave: represents the file version of a wave - required if wave files are used"},
{&CLSID_DirectMusicWaveTrack,           "CLSID_DirectMusicWaveTrack",       "DirectMusicWaveTrackCreate(iid,ppvInterface)",     "Wave Track - plays one or more waves"},
{&CLSID_DirectMusicChordTrack,          "CLSID_DirectMusicChordTrack",      "DirectMusicChordTrackCreate(iid,ppvInterface)",    "Chord Track - used for style playback"},
{&CLSID_DirectMusicCommandTrack,        "CLSID_DirectMusicCommandTrack",    "DirectMusicCommandTrackCreate(iid,ppvInterface)",  "Groove Track - used to store groove levels for style playback"},
{&CLSID_DirectMusicStyleTrack,          "CLSID_DirectMusicStyleTrack",      "DirectMusicStyleTrackCreate(iid,ppvInterface)",    "Style Track - selects style for playback"},
{&CLSID_DirectMusicPatternTrack,        "CLSID_DirectMusicPatternTrack",    "DirectMusicPatternTrackCreate(iid,ppvInterface)",  "Pattern Track - plays patterns with variations tranposed to chord progression"},
{&CLSID_DirectMusicMotifTrack,          "CLSID_DirectMusicMotifTrack",      "DirectMusicMotifTrackCreate(iid,ppvInterface)",    "Motif Track - mechanism for playing a style motif segment"},
{&CLSID_DirectMusicStyle,               "CLSID_DirectMusicStyle",           "DirectMusicStyleCreate(iid,ppvInterface)",         "Style - style playback object, represents a specific style type"},
{&CLSID_DirectMusicMelodyFormulationTrack, "CLSID_DirectMusicMelodyFormulationTrack", "DirectMusicMelodyFormulationTrackCreate(iid,ppvInterface)", "Melody Formulation Track - define the shape of a melody"},
{&CLSID_DirectMusicComposer,            "CLSID_DirectMusicComposer",        "DirectMusicComposerCreate(iid,ppvInterface)",      "Composer: creates playback segments and autotransitions from chordmaps and template segments"},
{&CLSID_DirectMusicChordMap,            "CLSID_DirectMusicChordMap",        "DirectMusicChordMapCreate(iid,ppvInterface)",      "ChordMap - defines chords to create chord progressions and transitions on the fly"},
{&CLSID_DirectMusicChordMapTrack,       "CLSID_DirectMusicChordMapTrack",   "DirectMusicChordMapTrackCreate(iid,ppvInterface)", "ChordMap Track - defines ChordMap to be used to compose a chord track"},
{&CLSID_DirectMusicSignPostTrack,       "CLSID_DirectMusicSignPostTrack",   "DirectMusicSignPostTrackCreate(iid,ppvInterface)", "SignPost Track - defines phrasing to be used to compose a chord track"},
{&CLSID_AutDirectMusicAudioPath,        "CLSID_AutDirectMusicAudioPath",    "DirectMusicAutAudioPathCreate(pUnkOuter,iid,ppvInterface)",     "Audio Path Automation - used by scripting to control a style directly"},
{&CLSID_AutDirectMusicAudioPathConfig,  "CLSID_AutDirectMusicAudioPathConfig", "DirectMusicAutAudioPathConfigCreate(pUnkOuter,iid,ppvInterface)", "Audio Path Configuration Automation - used by scripting to control an audiopath configuration"},
{&CLSID_AutDirectMusicSong,             "CLSID_AutDirectMusicSong",         "DirectMusicAutSongCreate(pUnkOuter,iid,ppvInterface)",          "Song Automation - used by scripting to control a song"},
{&CLSID_AutDirectMusicPerformance,      "CLSID_AutDirectMusicPerformance",  "DirectMusicAutPerformanceCreate(pUnkOuter,iid,ppvInterface)",   "Performance Automation - used by scripting to control a performance"},
{&CLSID_AutDirectMusicSegment,          "CLSID_AutDirectMusicSegment",      "DirectMusicAutSegmentCreate(pUnkOuter,iid,ppvInterface)",       "Segment Automation: used by scripting to control a segment"},
{&CLSID_DirectMusicScript,              "CLSID_DirectMusicScript",          "DirectMusicScriptCreate(iid,ppvInterface)",        "Script: Manages a script and all embedded and linked content"},
{&CLSID_DirectMusicScriptTrack,         "CLSID_DirectMusicScriptTrack",     "DirectMusicScriptTrackCreate(iid,ppvInterface)",   "Script Track: Sequences script routines to play in time with the music"},
{&CLSID_DirectMusicContainer,           "CLSID_DirectMusicContainer",       "DirectMusicContainerCreate(iid,ppvInterface)",     "Container: storage container for multiple DirectMusic file objects. Always used in scripting"},
{&CLSID_AutDirectMusicSegmentState,     "CLSID_AutDirectMusicSegmentState", "AutDirectMusicSegmentStateCreate(pUnkOuter,iid,ppvInterface)","A helper scripting object that implements IDispatch"},
{&CLSID_DirectMusicMuteTrack,           "CLSID_DirectMusicMuteTrack",       "DirectMusicMuteTrackCreate(iid,ppvInterface)",     "Mute Track - controls muting on sequence, style, and other event generating tracks"},
{&CLSID_DirectMusicMarkerTrack,         "CLSID_DirectMusicMarkerTrack",     "DirectMusicMarkerTrackCreate(iid,ppvInterface)",   "Marker Track - indicates segment start and alignment points"},
{&CLSID_DirectMusicSong,                "CLSID_DirectMusicSong",            "DirectMusicSongCreate(iid,ppvInterface)",          "Song: manages the composition and playback of a set of segments"},
{&CLSID_DirectMusicAudioPathConfig,     "CLSID_DirectMusicAudioPathConfig", "DirectMusicAudioPathConfigCreate(iid,ppvInterface)", "Audio Path Configuration: file representation of an audiopath"},
{&CLSID_DirectMusicGraph,               "CLSID_DirectMusicGraph",           "DirectMusicGraphCreate(iid,ppvInterface)",         "Tool Graph: manages a set of Tools (MIDI Processors)"},
{&CLSID_DirectMusicSysExTrack,          "CLSID_DirectMusicSysExTrack",      "DirectMusicSysexTrackCreate(iid,ppvInterface)",    "System Exclusive Track: sends system exclusive messages to the synthesizer"},
{&CLSID_DirectMusicSegmentTriggerTrack, "CLSID_DirectMusicSegmentTriggerTrack", "DirectMusicTriggerTrackCreate(iid,ppvInterface)", "Segment Trigger Track: triggers additional segments"},
{&CLSID_DirectMusicLyricsTrack,         "CLSID_DirectMusicLyricsTrack",     "DirectMusicLyricsTrackCreate(iid,ppvInterface)",   "Lyrics Track: sends lyrics"},
{&CLSID_DirectMusicParamControlTrack,   "CLSID_DirectMusicParamControlTrack","DirectMusicParamsTrackCreate(iid,ppvInterface)", "Parameter Control Track: provides realtime control of audio and MIDI effects"},

{&CLSID_DirectMusicAudioVBScriptIgnore, "CLSID_DirectMusicAudioVBScriptIgnore", "ERROR(1): Please report.", "ERROR(1): Please report."},
{&CLSID_DirectMusicIgnoreThisOne,       "CLSID_DirectMusicIgnoreThisOne",       "ERROR(2): Please report.", "ERROR(2): Please report."},
};
DWORD dwCLSIDTableSize = NUMELEMS(CLSIDTable);

/********************************************************************************
********************************************************************************/
const GUID *DefaultCLSIDsAdd[] = 
{
&CLSID_DirectMusicSynth,
&CLSID_DirectMusicFileStream,  
&CLSID_DirectMusicStreamStream,
&CLSID_DirectMusicMemStream,
&CLSID_DirectMusicComposer,
&CLSID_DirectMusicChordTrack,
&CLSID_DirectMusicChordMapTrack,
&CLSID_DirectMusicCommandTrack
};


/********************************************************************************
********************************************************************************/
const GUID *DefaultCLSIDsRemove[] = 
{
&CLSID_DirectMusic,
&CLSID_DirectMusicIgnoreThisOne,
&CLSID_DirectMusicAudioVBScriptIgnore
};

/********************************************************************************
********************************************************************************/
const GUID *DefaultCLSIDsIgnore[] = 
{
&CLSID_DirectMusic,
&CLSID_DirectMusicIgnoreThisOne,
&CLSID_DirectMusicAudioVBScriptIgnore
};


/********************************************************************************
********************************************************************************/
BOOL IgnoreThisCLSID(const GUID &guid)
{
    for (int i=0; i<NUMELEMS(DefaultCLSIDsIgnore); i++)
    {
        if (memcmp(&guid, DefaultCLSIDsIgnore[i], sizeof(GUID))==0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


/********************************************************************************
Given a CLSID, tells you what the command-line parameter for it should be.
********************************************************************************/
HRESULT CommandLineParamFromCLSID(const GUID *pCLSID, LPSTR szParam)
{
    HRESULT hr = S_OK;
    
    struct MAPPING
    {
        LPCSTR pContainedString;
        LPCSTR pShortened;
    };

    MAPPING Mappings[]= { {"CLSID_DirectMusic",    "DM"},
                          {"CLSID_AutDirectMusic", "ADM"},
                          {"CLSID_DirectSound",    "DS"} };    
    
    BOOL bFoundCLSID     = FALSE;
    BOOL bFoundSubString = FALSE;
    
    bFoundCLSID     = FALSE;
    for (int i = 0; i<NUMELEMS(CLSIDTable) && SUCCEEDED(hr); i++)
    {
        if (IsEqualGUID(*(CLSIDTable[i].pclsid), *pCLSID ))
        {

            //Note that we found this.
            bFoundCLSID = TRUE;

            //Now find which prefix we're using.
            bFoundSubString = FALSE;
            for (int j=0; j<NUMELEMS(Mappings) && SUCCEEDED(hr); j++)
            {
                if (0 == strncmp(CLSIDTable[i].pszClassName, Mappings[j].pContainedString, strlen(Mappings[j].pContainedString)))
                {
                    strcpy(szParam, Mappings[j].pShortened);
                    LPCSTR szRemainder = CLSIDTable[i].pszClassName + strlen(Mappings[j].pContainedString);
                    strcat(szParam, szRemainder);
                    bFoundSubString = TRUE;
                    break;
                }
            }           

            if (!bFoundSubString)
            {
                printf("Error: Could not create an command-line parameter name for %s\n", CLSIDTable[i].pszClassName);
                hr = E_FAIL;
            }
        }
    }

    if (!bFoundCLSID)
    {
        _tprintf( TEXT("Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n"), pCLSID->Data1, pCLSID->Data2, pCLSID->Data3, pCLSID->Data4[0], pCLSID->Data4[1], pCLSID->Data4[2], pCLSID->Data4[3], pCLSID->Data4[4], pCLSID->Data4[5], pCLSID->Data4[6], pCLSID->Data4[7] );
        hr = E_FAIL;
    }

return hr;
};



//TODO:
//Add examples to PrintUsage function.

/********************************************************************************

AUDANALYZE                                                                  
    Description
    -----------
    It analyzes your application's DMusic content and writes a
    "factory" function containing a list of DMusic objects needed to run your
    content. When objects are omittied from this list, their code is also
    omitted from your application by the linker, decreasing your app's size.
    If you use DMusic's default factory function, it won't know anything
    about your content, and must include code for all possible DMusic objects,
    much of which may be unnecessary.  

    AudAnalyze is a tool that helps decrease the size of your DMusic
    applications.  Based on a list of content you provide, AudAnalyze
    creates a file containing a function named MyFactory() to replace       
    DirectMusicDefaultFactory().  This function contains a list of DMusic
    objects needed to play your content.  If your code passes MyFactory()
    instead of DirectMusicDefaultFactory() to DirectMusicInitializeEx(),
    the linker will exclude unneeded DMusic objects from your XBox app,
    decreasing its size.  (DirectMusicDefaultFactory() includes ALL the
    objects, whether needed or not.)

    Explicity Adding/Omitting DMusic Objects
    ----------------------------------------
    Note that AudAnalyze can not be entirely accurate for all content.  
    Some required objects may be ommitted from MyFactory().  If this is the case,
    when DMusic tries to create an object of that type, MyFactory() will
    print an error message stating the CLSID of the unknown object, and call
    DebugBreak().  

Usage:                                                                      
    %s [SEGMENT | LIST]... [[+|-]ObjectType][...] [/All] [/Q] OutputFile
                                                                            
    SEGMENT:     The name of a DirectMusic segment file, or a wildcard specifying
                 a set of files.
    LIST:        A file ending in .TXT containing a list of segments, one on each
                 line.  May not contain wildcards.  Relative pathnames in list
                 files are relative to the current directory, which is not
                 necessarily the list file's directory.
    ObjectType:  A DirectMusic object (see list below).                     
    OutputFile:  Output file containing MyFactory().
    +            Forces inclusion of an object type.                                  
    -            Forces exclusion of an object type.                                  
    /all         Forces inclusion of all object types.
    /q           Quiet mode.  Doesn't ask before overwriting destination file.


    Examples
    --------    
    Simply analyze one segment:
        AudAnalyze MySegment.sgt FACTORY.CPP

    Analyze two segments:
        AudAnalyze MySegment.sgt AnotherSegment.sgt FACTORY.CPP

    Analyze all segments in these subdirectories:
        AudAnalyze Disco\*.sgt HipHop\*.sgt FACTORY.CPP

    Analyze all segments in this list:
        AudAnalyze MyPlayList.txt FACTORY.CPP

    Analyze all segments, and add the 
        AudAnalyze MyPlayList.txt FACTORY.CPP

    Include everything.
        AudAnalyze /all FACTORY.CPP

    How To Convert Your Existing DMusic App To Use AudAnalyze
    ---------------------------------------------------------
    1) Put all your content into a directory.
    2) Run "AudAnalyze AllMyContent\*.* FACTORY.CPP
    3) #include "factory.cpp" in another one of your CPP files
       that has dmusici.h already included.
    4) Instead of using DirectMusicInitialze(), use
       DirectMusicInitialzeEx() or
       DirectMusicInitializeFixedSizeHeaps().  Admittedly there's
       currently no convenient way to keep your heap behavior
       while using this feature.  Anyway, pass MyFactory to
       the Init function you're using.
    5) Compile and run your app.  If it runs fine, go to step 11.
    6) Your app asserted.  Note the CLSID it was looking for.
    7) Find the corresponding CLSID in either dmusici.h or just
       above MyFactory().
    8) Type "AudAnalyze" with no parameters to find the parameter
       matching the CLSID you need to add
    9) Run AudAnalyze again on your content, adding the your parameter
       preceeded by a '+' (i.e. +MyParameter).
    10)Go back to step 5.   
    11)Great!  Your app is running!  However you may have EXTRA objects
       in your MyFactory() function that aren't needed.  If you see
       an object like CLSID_DirectMusicChordMapTrack used in MyFactory()
       but your content contains no chordmap tracks, it's a good candidate
       for removal.  Comment it out, or rerun AudAnalyze with the
       -DMChordMapTrack parameter.  If you get no asserts, congrats, you've
       just decreased your code size!!



********************************************************************************/
HRESULT PrintUsage(void)
{
printf("AUDANALYZE                                                                  \n");
printf("    Description\n");
printf("    -----------\n");
printf("    It analyzes your application's DMusic content and writes a\n");
printf("    \"factory\" function containing a list of DMusic objects needed to run your\n");
printf("    content. When objects are omittied from this list, their code is also\n");
printf("    omitted from your application by the linker, decreasing your app's size.\n");
printf("    If you use DMusic's default factory function, it won't know anything\n");
printf("    about your content, and must include code for all possible DMusic objects,\n");
printf("    much of which may be unnecessary.  \n");
printf("\n");
printf("    AudAnalyze is a tool that helps decrease the size of your DMusic\n");
printf("    applications.  Based on a list of content you provide, AudAnalyze\n");
printf("    creates a file containing a function named MyFactory() to replace       \n");
printf("    DirectMusicDefaultFactory().  This function contains a list of DMusic\n");
printf("    objects needed to play your content.  If your code passes MyFactory()\n");
printf("    instead of DirectMusicDefaultFactory() to DirectMusicInitializeEx(),\n");
printf("    the linker will exclude unneeded DMusic objects from your XBox app,\n");
printf("    decreasing its size.  (DirectMusicDefaultFactory() includes ALL the\n");
printf("    objects, whether needed or not.)\n");
printf("\n");
printf("    Explicity Adding/Omitting DMusic Objects\n");
printf("    ----------------------------------------\n");
printf("    Note that AudAnalyze can not be entirely accurate for all content.  \n");
printf("    Some required objects may be ommitted from MyFactory().  If this is the case,\n");
printf("    when DMusic tries to create an object of that type, MyFactory() will\n");
printf("    print an error message stating the CLSID of the unknown object, and call\n");
printf("    DebugBreak().  \n");
printf("\n");
printf("Usage:                                                                      \n");
printf("    AUDANALYZE [SEGMENT | LIST]... [[+|-]ObjectType][...] [/All] [/Q] OutputFile\n");
printf("                                                                            \n");
printf("    SEGMENT:     The name of a DirectMusic segment file, or a wildcard specifying\n");
printf("                 a set of files.\n");
printf("    LIST:        A file ending in .TXT containing a list of segments, one on each\n");
printf("                 line.  May not contain wildcards.  Relative pathnames in list\n");
printf("                 files are relative to the current directory, which is not\n");
printf("                 necessarily the list file's directory.\n");
printf("    ObjectType:  A DirectMusic object (see list below).                     \n");
printf("    OutputFile:  Output file containing MyFactory().\n");
printf("    +            Forces inclusion of an object type.                              \n");
printf("    -            Forces exclusion of an object type.                              \n");
printf("    /all         Forces inclusion of all object types.\n");
printf("    /q           Quiet mode.  Doesn't ask before overwriting destination file.\n");
printf("\n");
printf("\n");
printf("    Examples\n");
printf("    --------    \n");
printf("    Simply analyze one segment:\n");
printf("        AudAnalyze MySegment.sgt FACTORY.CPP\n");
printf("\n");
printf("    Analyze two segments:\n");
printf("        AudAnalyze MySegment.sgt AnotherSegment.sgt FACTORY.CPP\n");
printf("\n");
printf("    Analyze all segments in these subdirectories:\n");
printf("        AudAnalyze Disco\\*.sgt HipHop\\*.sgt FACTORY.CPP\n");
printf("\n");
printf("    Analyze all segments in this list:\n");
printf("        AudAnalyze MyPlayList.txt FACTORY.CPP\n");
printf("\n");
printf("    Analyze all segments, and add the \n");
printf("        AudAnalyze MyPlayList.txt FACTORY.CPP\n");
printf("\n");
printf("    Include everything.\n");
printf("        AudAnalyze /all FACTORY.CPP\n");
printf("\n");
printf("\n");
printf("    List of object types:                                                   \n");
printf("    CLSID                                    Corresponding parameter name   \n");
printf("    ---------------------------------------- -------------------------------\n");

for (DWORD i=0; i<dwCLSIDTableSize; i++)
{
    CHAR szParam[MAX_PATH];
    CommandLineParamFromCLSID(CLSIDTable[i].pclsid, szParam);
    if (IgnoreThisCLSID(*(CLSIDTable[i].pclsid)))
        continue;
    printf("    %-40s: %s\n", CLSIDTable[i].pszClassName, szParam);
}
printf("\n");
printf("\n");
printf("\n");

return S_OK;
};




/********************************************************************************
********************************************************************************/
void HandleCLSID( REFCLSID clsid )
{
    BOOL bFound = FALSE;
    for (int i = 0; i<NUMELEMS(CLSIDTable); i++)
    {
        if (IsEqualGUID(*(CLSIDTable[i].pclsid), clsid ))
        {
            InsertClass(CLSIDTable[i].pszClassName, CLSIDTable[i].pszFunctionName, CLSIDTable[i].pszComment);           
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        _tprintf( TEXT("Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n"), clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
    }
}


/********************************************************************************
********************************************************************************/
void RemoveCLSID( REFCLSID clsid )
{
    BOOL bFound = FALSE;
    for (int i = 0; i<NUMELEMS(CLSIDTable); i++)
    {
        if (IsEqualGUID(*(CLSIDTable[i].pclsid), clsid ))
        {
            RemoveClass(CLSIDTable[i].pszClassName);           
            bFound = TRUE;
            break;
        }
    }

    if (!bFound)
    {
        _tprintf( TEXT("Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\n"), clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );
    }
}

/********************************************************************************
********************************************************************************/
void CreateClassLinkFile(TCHAR *pszFileName)

{
        char *szHeader[] = {
            "                                                                                                  \r\n",
            "//--------------------------------------------------------------------------------------------    \r\n",
            "DEFINE_GUID(CLSID_DirectMusicBand,0x79ba9e00, 0xb6ee, 0x11d1, 0x86, 0xbe, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef); \r\n",
            "DEFINE_GUID(CLSID_DirectMusicTempoTrack,0xd2ac2885, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicSeqTrack,0xd2ac2886, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicSysExTrack,0xd2ac2887, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicTimeSigTrack,0xd2ac2888, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicChordTrack,0xd2ac288b, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicCommandTrack,0xd2ac288c, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicStyleTrack,0xd2ac288d, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicMotifTrack,0xd2ac288e, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicSignPostTrack,0xf17e8672, 0xc3b4, 0x11d1, 0x87, 0xb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicBandTrack,0xd2ac2894, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicChordMapTrack,0xd2ac2896, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicMuteTrack,0xd2ac2898, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicScriptTrack,0x4108fa85, 0x3586, 0x11d3, 0x8b, 0xd7, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4108FA85-3586-11d3-8BD7-00600893B1B6} */\r\n",
            "DEFINE_GUID(CLSID_DirectMusicMarkerTrack,0x55a8fd00, 0x4288, 0x11d3, 0x9b, 0xd1, 0x8a, 0xd, 0x61, 0xc8, 0x88, 0x35);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicSegmentTriggerTrack, 0xbae4d665, 0x4ea1, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {BAE4D665-4EA1-11d3-8BDA-00600893B1B6} */\r\n",
            "DEFINE_GUID(CLSID_DirectMusicLyricsTrack, 0x995c1cf5, 0x54ff, 0x11d3, 0x8b, 0xda, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {995C1CF5-54FF-11d3-8BDA-00600893B1B6} */\r\n",
            "DEFINE_GUID(CLSID_DirectMusicParamControlTrack, 0x4be0537b, 0x5c19, 0x11d3, 0x8b, 0xdc, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); /* {4BE0537B-5C19-11d3-8BDC-00600893B1B6} */\r\n",
            "DEFINE_GUID(CLSID_DirectMusicMelodyFormulationTrack, 0xb0684266, 0xb57f, 0x11d2, 0x97, 0xf9, 0x0, 0xc0, 0x4f, 0xa3, 0x6e, 0x58);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicWaveTrack,0xeed36461, 0x9ea5, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);\r\n",
            "DEFINE_GUID(CLSID_DirectMusicSynth,0x58C2B4D0,0x46E7,0x11D1,0x89,0xAC,0x00,0xA0,0xC9,0x05,0x41,0x29);\r\n",
            "DEFINE_GUID(CLSID_AutDirectMusicPerformance,		0xa861c6e2, 0xfcfc, 0x11d2, 0x8b, 0xc9, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {A861C6E2-FCFC-11d2-8BC9-00600893B1B6}\r\n",
            "DEFINE_GUID(CLSID_AutDirectMusicSegment,			0x4062c116, 0x0270, 0x11d3, 0x8b, 0xcb, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {4062C116-0270-11d3-8BCB-00600893B1B6}\r\n",
            "DEFINE_GUID(CLSID_AutDirectMusicSong,				0xa16f1761, 0xb6d8, 0x42eb, 0x8d, 0x57, 0x4a, 0x44, 0xfe, 0xdd, 0x3b, 0xd2);// {A16F1761-B6D8-42eb-8D57-4A44FEDD3BD2}\r\n",
            "DEFINE_GUID(CLSID_AutDirectMusicSegmentState,		0xebf2320a, 0x2502, 0x11d3, 0x8b, 0xd1, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xb6); // {EBF2320A-2502-11d3-8BD1-00600893B1B6}\r\n",
            "DEFINE_GUID(CLSID_AutDirectMusicAudioPathConfig,	0x1cebde3e, 0x6b91, 0x484a, 0xaf, 0x48, 0x5e, 0x4f, 0x4e, 0xd6, 0xb1, 0xe1);// {1CEBDE3E-6B91-484a-AF48-5E4F4ED6B1E1}\r\n",
            "DEFINE_GUID(CLSID_AutDirectMusicAudioPath,			0x2c5f9b72, 0x7148, 0x4d97, 0xbf, 0xc9, 0x68, 0xa0, 0xe0, 0x76, 0xbe, 0xbd);// {2C5F9B72-7148-4d97-BFC9-68A0E076BEBD}\r\n",
            "\r\n",
            "STDAPI DirectMusicChordTrackCreate( REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicCommandTrackCreate( REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicStyleTrackCreate( REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicMelodyFormulationTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicMuteTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicChordMapTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicChordMapCreate(REFIID iid, void ** ppChordMap );\r\n",
            "STDAPI DirectMusicSignPostTrackCreate(REFIID iid, void ** ppChordMap );\r\n",
            "STDAPI DirectMusicTempoTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicTimeSigTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicMarkerTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicBandTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicPatternTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicMotifTrackCreate(REFIID iid, void ** ppDMT );\r\n",
            "STDAPI DirectMusicWaveTrackCreate(REFIID iid, void ** ppDMT);\r\n",
            "STDAPI DirectMusicSegmentCreate( REFIID iid, void ** ppDMSeg );\r\n",
            "STDAPI DirectMusicTemplCreate(REFIID iid, void ** ppDMTempl );\r\n",
            "STDAPI DirectMusicPerformanceCreate(REFIID iid, void ** ppDMP);\r\n",
            "STDAPI DirectMusicBandCreate(REFIID iid, void ** ppBand);\r\n",
            "STDAPI DirectMusicStyleCreate(REFIID iid, void ** ppStyle);\r\n",
            "STDAPI DirectMusicSectionCreate(REFIID iid, void ** ppSection);\r\n",
            "STDAPI DirectMusicAutAudioPathCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);\r\n",
            "STDAPI DirectMusicAutAudioPathConfigCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);\r\n",
            "STDAPI DirectMusicAutSongCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);\r\n",
            "STDAPI DirectMusicAutPerformanceCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);\r\n",
            "STDAPI DirectMusicAutSegmentCreate(LPUNKNOWN pUnkOuter,REFIID iid, void ** ppAuto);\r\n",
            "STDAPI DirectMusicScriptCreate(REFIID iid, void ** ppScript);\r\n",
            "STDAPI DirectMusicScriptTrackCreate(REFIID iid, void ** ppTrack);\r\n",
            "STDAPI DirectMusicSongCreate(REFIID iid, void ** ppSong);\r\n",
            "STDAPI DirectMusicAudioPathConfigCreate(REFIID iid, void ** ppPath);\r\n",
            "STDAPI DirectMusicSeqTrackCreate(REFIID iid, void ** ppTrack);\r\n",
            "STDAPI DirectMusicGraphCreate(REFIID iid, void ** ppGraph);\r\n",
            "STDAPI DirectMusicSysexTrackCreate(REFIID iid, void ** ppTrack);\r\n",
            "STDAPI DirectMusicTriggerTrackCreate(REFIID iid, void ** ppTrack);\r\n",
            "STDAPI DirectMusicLyricsTrackCreate(REFIID iid, void ** ppTrack);\r\n",
            "STDAPI DirectMusicParamsTrackCreate(REFIID iid, void ** ppTrack);\r\n",
            "STDAPI DirectMusicSegStateCreate(REFIID iid, void ** ppSegState);\r\n",
            "STDAPI DirectMusicComposerCreate(REFIID iid, void ** ppDMComp8 );\r\n",
            "STDAPI DirectMusicCreate(REFIID iid, void ** ppDMC );\r\n",
            "STDAPI DirectMusicCollectionCreate(REFIID iid, void ** ppDMC );\r\n",
            "STDAPI DirectMusicSynthCreate(REFIID iid, void ** ppDMSynth );\r\n",
            "STDAPI DirectSoundWaveCreate( REFIID iid, void ** ppDSW );\r\n",
            "STDAPI DirectMusicContainerCreate( REFIID iid, void ** ppContainer );\r\n",
            "STDAPI DirectMusicLoaderCreate( REFIID iid, void ** ppLoader );\r\n",
            "STDAPI AutDirectMusicSegmentStateCreate(LPUNKNOWN pUnkOuter, REFIID iid, void ** ppLoader );\r\n",
            "STDAPI DirectMusicMemStreamCreate( REFIID iid, void ** ppStream );\r\n",
            "STDAPI DirectMusicStreamStreamCreate( REFIID iid, void ** ppStream );\r\n",
            "STDAPI DirectMusicFileStreamCreate( REFIID iid, void ** ppStream );\r\n",
            "                                                                                                  \r\n",
            "                                                                                                  \r\n",
            "HRESULT CALLBACK MyFactory(REFCLSID clsid,\r\n",
            "                           LPUNKNOWN pUnkOuter,\r\n", 
            "                           REFIID iid,\r\n", 
            "                           LPVOID *ppvInterface)\r\n",
            "{\r\n",
            "   HRESULT hr = E_FAIL;\r\n"
            
        };



    //Check to see if the file exists.
    if (!g_bQuiet)
    {
        if (_access(pszFileName, 00) == 0)
        {

            //Check to see if the file is writeable.
            if (_access(pszFileName, 02) != 0)
            {
                printf("Error: Cannot write to %s.\n", pszFileName);
                return;
            }
        
            printf("%s exists, overwrite? (y/n)\n", pszFileName);
            if (!YesOrNo())
                return;
        }
    }

    HANDLE hFile = CreateFile(pszFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
		DWORD dwBytesWritten;
        for (DWORD dwI = 0; dwI < NUMELEMS(szHeader); dwI++)
        {
            WriteFile(hFile,szHeader[dwI],strlen(szHeader[dwI]),&dwBytesWritten,NULL);
        }
        CClassTracker *pScan = g_pClassList;
        BOOL fFirst = TRUE;
        for (;;)
        {
            CClassTracker *pBestSoFar = NULL;
            DWORD dwMaxCount = 0;
            for (pScan = g_pClassList;pScan;pScan = pScan->m_pNext)
            {
                if (!pScan->m_fSaved)
                {
                    if (pScan->m_dwCount > dwMaxCount)
                    {
                        pBestSoFar = pScan;
                        dwMaxCount = pScan->m_dwCount;
                    }
                }
            }
            if (!pBestSoFar)
            {
                break;
            }
            pBestSoFar->m_fSaved = TRUE;
			if (fFirst)
			{
				WriteFile(hFile,"    if ",7,&dwBytesWritten,NULL);
			}
            if (!fFirst)
            {
                WriteFile(hFile,"    else if ",12,&dwBytesWritten,NULL);
            }
            fFirst = FALSE;
            char szData[400];
            wsprintfA(szData,"(clsid == %s)\r\n    {\r\n        // %s.\r\n        hr = %s;\r\n    }\r\n",
                pBestSoFar->m_pszClassName,pBestSoFar->m_pszComment,pBestSoFar->m_pszFunctionName);
            WriteFile(hFile,szData,strlen(szData),&dwBytesWritten,NULL);
        }
        char *szTail[] = {
            "    #ifndef AUDANALYZE_NODEBUG     \r\n",
            "    else                           \r\n",
            "    {                              \r\n",
            "        OutputDebugStringA(\"DirectMusic needs to allocate an object that your MyFactory() function doesn't support.  \\n\");\r\n",
            "        OutputDebugStringA(\"Please locate the CLSID in the list above MyFactory(), or in dmusici.h, and make sure    \\n\");\r\n",
            "        OutputDebugStringA(\"AudAnalyzer includes support for this CLSID when generating MyFactory(), by using        \\n\");\r\n",
            "        OutputDebugStringA(\"a command-line parameter if necessary (see AudAnalyzer docs for more details.)           \\n\");\r\n",
            "        CHAR szTemp[MAX_PATH] ={0};\r\n",
            "        sprintf(szTemp,\"Unknown CLSID: %08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x\\n\", clsid.Data1, clsid.Data2, clsid.Data3, clsid.Data4[0], clsid.Data4[1], clsid.Data4[2], clsid.Data4[3], clsid.Data4[4], clsid.Data4[5], clsid.Data4[6], clsid.Data4[7] );\r\n"
            "        OutputDebugStringA(szTemp);\r\n",
            "        DebugBreak();              \r\n",
            "    }                              \r\n",
            "    #endif AUDANALYZE_NODEBUG     \r\n",
            "    return hr;                     \r\n",
            "}\r\n", 
        };
        for (dwI = 0; dwI < NUMELEMS(szTail); dwI++)
        {
            WriteFile(hFile,szTail[dwI],strlen(szTail[dwI]),&dwBytesWritten,NULL);
        }
        CloseHandle(hFile);
    }
}


/********************************************************************************
********************************************************************************/
// Detours stuff
extern "C" {
#define FUNCPTR_CoCreate HRESULT (STDAPICALLTYPE *)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter, IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv)


HRESULT (STDAPICALLTYPE *DynamicTrampoline)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
                    IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv) = NULL;
}

STDAPI DynamicDetour(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
                    IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv)
{
	HandleCLSID( rclsid );

	return DynamicTrampoline( rclsid, pUnkOuter, dwClsContext, riid, ppv );
}



/********************************************************************************
********************************************************************************/
HRESULT ProcessDMusicFile(IDirectMusicPerformance8 *pPerf, IDirectMusicLoader8 *pLoader, LPCSTR szFileFull)
{

    HRESULT hr = S_OK;
    IDirectMusicSegment8* pSegment = NULL;
    IDirectMusicScript8*  pScript  = NULL;
    IDirectMusicContainer *  pContainer = NULL;
//    IDirectMusicAudioPath *pPath = NULL;
    IUnknown *  pStyle = NULL;
    BOOL bWarning = FALSE;


    ASSERT(pLoader);
    ASSERT(szFileFull);
    
    // DMusic only takes wide strings, for some odd, inefficient reason.
    CHAR  szDirectory[MAX_PATH] = {0};
    WCHAR wstrFileName[MAX_PATH] = {0};
    WCHAR wstrDirectory[MAX_PATH] = {0};
    
    CHECKRUN(ChopPath(szFileFull, szDirectory, NULL));
    DXUtil_ConvertGenericStringToWide( wstrFileName,  szFileFull, MAX_PATH );
    DXUtil_ConvertGenericStringToWide( wstrDirectory, szDirectory, MAX_PATH );

    ASSERT(szDirectory[0]);
    ASSERT(szFileFull [0]);
    
    //Can't use macro cuz this dumb function returns S_FALSE.
    if (SUCCEEDED(hr))
    {
        hr = pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, wstrDirectory, FALSE);
    }
    if (hr == S_FALSE)
        hr = S_OK;

    if (strstr(szFileFull, ".sgt") || strstr(szFileFull, ".wav"))
    {

	    CHECKRUN(pLoader->LoadObjectFromFile( CLSID_DirectMusicSegment,
                                              IID_IDirectMusicSegment8,
                                              wstrFileName,
                                              (LPVOID*) &pSegment ));
        
        
//        CHECKRUN(pPerf->CreateStandardAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 16, TRUE, &pPath));
//        CHECKRUN(pSegment->Download(pPath))
//        CHECKRUN(pPerf->PlaySegmentEx(pSegment, 0, 0, 0, 0, 0, 0, pPath));
    }
    else if (strstr(szFileFull, ".spt"))
    {
	    CHECKRUN(pLoader->LoadObjectFromFile( CLSID_DirectMusicScript,
                                              IID_IDirectMusicScript8,
                                              wstrFileName,
                                              (LPVOID*) &pScript ));        

    }
   else if (strstr(szFileFull, ".con"))
    {

        CHECKRUN(pLoader->LoadObjectFromFile(CLSID_DirectMusicContainer,
                                             IID_IDirectMusicContainer,
                                             wstrFileName,
                                             (void**)&pContainer)); 
    }
   else if (strstr(szFileFull, ".sty"))
    {

        CHECKRUN(pLoader->LoadObjectFromFile(CLSID_DirectMusicStyle,
                                             IID_IDirectMusicStyle,
                                             wstrFileName,
                                             (void**)&pStyle)); 
    }
    else
    {
		_ftprintf(stderr,TEXT("Warning: DMusic file [%s] is of unknown type - exluding from analysis.\n"), szFileFull);        
        bWarning = TRUE;
    }
    


	if( FAILED(hr))
    {
		_ftprintf(stderr,TEXT("Error loading DMusic file [%s]\n"), szFileFull);
    }
    else if (!bWarning)
    {
		_ftprintf(stderr,TEXT("Successfully processed [%s]\n"), szFileFull);
    }

    //pPerf->StopEx(0, 0, 0);    
//    if (pSegment && pPath)
//    {
//        pSegment->Unload(pPath);
//    }
//	RELEASE(pPath);
	RELEASE(pStyle);
	RELEASE(pContainer);
    RELEASE(pSegment);
	RELEASE(pScript);

    return hr;
}


/********************************************************************************
********************************************************************************/
HRESULT ProcessTextFile(IDirectMusicPerformance8 *pPerf, IDirectMusicLoader8 *pLoader, LPCSTR szFileFull)
{
    HRESULT hr = S_OK;
    CHAR szSegment[MAX_PATH] = {0};
    CHAR szLineOText[MAX_PATH] = {0};
    FILE *fyle = NULL;

    ASSERT(pLoader);
    ASSERT(szFileFull);

    fyle = fopen(szFileFull, "rt");
    CHECKALLOC(fyle);    
    if (SUCCEEDED(hr))
    {
        printf("Processing text file %s\n", szFileFull);
        while (fgets(szLineOText, MAX_PATH - 1, fyle) && SUCCEEDED(hr))
        {
            //Bail if it's a comment.
            if (szLineOText[0] == ';')
                continue;

            //Bail if we didn't get one item.
            DWORD dwScanned = sscanf(szLineOText, " %[^\"\n]",szSegment);
            if (1 != dwScanned)
            {
                if (0!=dwScanned)
                {
                    printf("Error: Too many tokens on line: The following line of %s was not understood and not processed:\n%s\n", szFileFull, szLineOText);
                }
                continue;
            }

            CHAR szFullPath[MAX_PATH] = {0};
            GetFullPathName(szSegment, MAX_PATH-1, szFullPath, NULL);
            CHECKRUN(ProcessDMusicFile(pPerf, pLoader, szFullPath));
        }
    }
    else
    {
        printf("Error: Could not open file %s\n", szFileFull);
    }

    //Close the file (reset it).
    if (fyle)
    {
        fclose(fyle);
        fyle = NULL;
    }
return hr;
};


/********************************************************************************
So we must test if something's a command-line param first - anything that's not
one must be a segment name.  However, we must do the actual processing of
segments first and command-line params second (since the latter process adds/removes 
things from a list), hence the "dwLookingFor" variable.


Priority of adding/removing
---------------------------
Command-line parameters
Default CLSIDs.
Content

i.e.
1) Add to list based on content
2) Add/Remove from list based on default CLSIDs
3) Add/Remove from list based on command-line parameters.
********************************************************************************/
#define FILES 0
#define DEFAULTCLSIDS 1
#define CHECKSCRIPTING 2
#define PARAMS 3


HRESULT HandleCommandLineParams(int argc, char *argv[], IDirectMusicLoader8 *pLoader, IDirectMusicPerformance8 *pPerf)
{
HRESULT hr = S_OK;
int i;
DWORD j, dwLookingFor;


for (dwLookingFor=0; dwLookingFor < 4 && SUCCEEDED(hr); dwLookingFor++)
{

    //#2 - add to list based on default CLSIDs.
    if (dwLookingFor == DEFAULTCLSIDS)
    {
        for (i=0; i<NUMELEMS(DefaultCLSIDsAdd) && SUCCEEDED(hr); i++)
        {
            CHECK(HandleCLSID(*DefaultCLSIDsAdd[i]));
        }
        for (i=0; i<NUMELEMS(DefaultCLSIDsRemove) && SUCCEEDED(hr); i++)
        {
            CHECK(RemoveCLSID(*DefaultCLSIDsRemove[i]));
        }
        continue;
    }

    //#2 - If scripts are enabled as a result of file parsing, we must also 
    //      include some other CLSIDs.
    if (dwLookingFor == CHECKSCRIPTING)
    {
        
        if (CLSIDPresent("CLSID_DirectMusicScript"))
        {
            HandleCLSID(CLSID_AutDirectMusicAudioPath);
            HandleCLSID(CLSID_AutDirectMusicPerformance);
            HandleCLSID(CLSID_AutDirectMusicSegmentState);
            HandleCLSID(CLSID_AutDirectMusicSong);
            HandleCLSID(CLSID_AutDirectMusicSegment);
            HandleCLSID(CLSID_AutDirectMusicAudioPathConfig);
        }
        continue;
    }


    //Go through all but the last parameter.
    for (i=1; i<argc-1 && SUCCEEDED(hr); i++)
    {
        CHAR szLwrParam[MAX_PATH] ={0};
        CHAR szLwrFromCLSID[MAX_PATH] ={0};

        strcpy(szLwrParam, argv[i]);
        _strlwr(szLwrParam);
    
        //First see if it's a command-line parameter.
        BOOL bFoundParam = FALSE;
        if (argv[i][0] == '-' || argv[i][0] == '+')
        {
            for (j=0; j<NUMELEMS(CLSIDTable) && SUCCEEDED(hr); j++)
            {            
            
                CHECKRUN(CommandLineParamFromCLSID(CLSIDTable[j].pclsid, szLwrFromCLSID));
                _strlwr(szLwrFromCLSID);
                if (strcmp(szLwrParam+1, szLwrFromCLSID)==0)
                {
                    bFoundParam = TRUE;

                    //If we're not looking for params yet, then just say "I found it!" and bail;
                    if (dwLookingFor == PARAMS)
                    {
                        switch(argv[i][0])
                        {
                            case '+':
                                CHECK(HandleCLSID(*(CLSIDTable[j].pclsid)));
                                printf("User added object %s\n", CLSIDTable[j].pszClassName);
                                break;
                            case '-':
                                CHECK(RemoveCLSID(*(CLSIDTable[j].pclsid)));
                                printf("User excluded object %s\n", CLSIDTable[j].pszClassName);
                                break;
                            default:
                                printf("AudAnalyze Error: Expected a '+' or '-' prefix on %s\n.  Please report this error.", argv[i]);
                                hr = E_FAIL;
                                break;
                        }
                    }
                    break;
                }
            }
        }
        else if (_strcmpi(argv[i], "/all")==0)
        {

            for (i=0; i<NUMELEMS(CLSIDTable); i++)
            {
                if (!IgnoreThisCLSID(*(CLSIDTable[i].pclsid)))
                {
                    HandleCLSID(*(CLSIDTable[i].pclsid));
                }
            }
            bFoundParam = TRUE;
        }
        else if (_strcmpi(argv[i], "/q") == 0)
        {
            g_bQuiet = TRUE;
            bFoundParam = TRUE;
        }

        if (SUCCEEDED(hr))
        {
            //If this is false, we must assume it's not a param, but a file.  
            if (!bFoundParam)
            {
                //If we're looking for files then jump on it.
                if (dwLookingFor == FILES)
                {            
                    WIN32_FIND_DATA FindFileData = {0};
                    HANDLE fyle = NULL;
                    CHAR szFullPath [MAX_PATH] = {0};
                    CHAR szDirectory[MAX_PATH] = {0};


                    //Get the full path+file name and path name of our parameter, which is a file our wildcard.
                    GetFullPathName(argv[i], MAX_PATH -1, szFullPath, NULL);                    
                    CHECKRUN(ChopPath(szFullPath, szDirectory, NULL));
                    ASSERT(szDirectory[MAX_PATH - 1] == 0);
                    ASSERT(szFullPath [MAX_PATH - 1] == 0);
                    ASSERT(szDirectory[0]);
                    ASSERT(szFullPath [0]);

                    //Are there any files that match this wildcard?
                    fyle = FindFirstFile(szFullPath, &FindFileData);


                    if (!fyle || INVALID_HANDLE_VALUE==fyle)
                    {
                        printf("warning: No files found that match %s\n", argv[i]);
                    }
                    else
                    {
                        do
                        {
                            CHAR szFullFileName[MAX_PATH] = {0};
                            sprintf(szFullFileName, "%s%s", szDirectory, FindFileData.cFileName);
                            
                            //Get the directory name from 
                            _strlwr(szFullFileName);
                            //If it's a text file, open it and read the names of all the segment files from it.                    
                            if (strstr(szFullFileName, ".txt"))
                            {
                                CHECKRUN(ProcessTextFile(pPerf, pLoader, szFullFileName));
                            }

                            //If it's a segment file, then just load and release it.
                            else
                            {
                                CHECKRUN(ProcessDMusicFile(pPerf, pLoader, szFullFileName));
                            }
                        }
                        while (FindNextFile(fyle, &FindFileData));

                        if (ERROR_NO_MORE_FILES != GetLastError())
                        {
                            CHAR szMessage[MAX_PATH] = {0};
                            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                                          NULL,
                                          GetLastError(),
                                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                          szMessage,
                                          MAX_PATH - 1,
                                          NULL 
                                          );

                            printf("Error: %s\n", szMessage); 
                        }

                        if (fyle && INVALID_HANDLE_VALUE != fyle)
                        {
                            FindClose(fyle);
                        }
                    }
                }
            }

            if (FAILED(hr))
            {
                printf("Failed to process %s\n", argv[i]);
            }
        }
    }
}

if (SUCCEEDED(hr))
{
    if (argc == 1)
    {
        printf("Error: Not enough parameters.  You need at least one parameter specifying the destination file\n");
        hr = E_FAIL;
    }
    else
    {
        CreateClassLinkFile(argv[argc-1]);
    }
}

if (FAILED(hr))
    PrintUsage();



return hr;
}
#undef FILES
#undef CHECKSCRIPTING
#undef DEFAULTCLSIDS
#undef PARAMS






/********************************************************************************
********************************************************************************/
int __cdecl main(int argc, char* argv[])
{
    HRESULT hr = S_OK;
	IDirectMusicLoader8 *pIDirectMusicLoader8 = NULL;
	IDirectMusicPerformance8 *pIDirectMusicPerformance8 = NULL;

	CoInitialize( NULL );

	if( DynamicTrampoline == NULL )
	{
		HRESULT (STDAPICALLTYPE *DynamicTarget)(IN REFCLSID rclsid, IN LPUNKNOWN pUnkOuter,
						IN DWORD dwClsContext, IN REFIID riid, OUT LPVOID FAR* ppv) = &CoCreateInstance;
		DynamicTrampoline = (FUNCPTR_CoCreate)DetourFunction( (PBYTE)DynamicTarget, (PBYTE)DynamicDetour );
	}

    // Create performance object
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance( CLSID_DirectMusicPerformance, NULL, CLSCTX_INPROC, 
                           IID_IDirectMusicPerformance8, (void**)&pIDirectMusicPerformance8 );
	    if( FAILED(hr) )
	    {
		    _ftprintf(stderr,TEXT("Error CoCreating CLSID_DirectMusicPerformance (0x%08X).  Make sure your have DirectX 8 installed on your machine.\n"), hr);
	    }
    }

    // Create loader object
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance( CLSID_DirectMusicLoader, NULL, CLSCTX_INPROC, 
                               IID_IDirectMusicLoader8, (void**)&pIDirectMusicLoader8 );
	    if( FAILED(hr) )
	    {
		    _ftprintf(stderr,TEXT("Error CoCreating CLSID_DirectMusicLoader (0x%08X).\n"), hr);
	    }
    }


    // Initialize the performance with the standard audio path.
    // This initializes both DirectMusic and DirectSound and 
    // sets up the synthesizer. Typcially its easist to use an 
    // audio path for playing music and sound effects.
    
    //if (SUCCEEDED(hr))
    //{
    //    hr = pIDirectMusicPerformance8->InitAudio( NULL, NULL, NULL, DMUS_APATH_DYNAMIC_STEREO, 
    //                                    128, DMUS_AUDIOF_ALL, NULL );
	//    if( FAILED(hr) )
	//    {
	//	    _ftprintf(stderr,TEXT("Error calling Performance8->InitAudio: %08X.\n"), hr);
	//    }
    //}

    CHECKRUN(HandleCommandLineParams(argc, argv, pIDirectMusicLoader8, pIDirectMusicPerformance8));

    if (pIDirectMusicPerformance8)
    {
	    pIDirectMusicPerformance8->CloseDown();
	    RELEASE(pIDirectMusicPerformance8);
    }
	
    RELEASE(pIDirectMusicLoader8);


	if( DynamicTrampoline )
	{
		DetourRemove((PBYTE)DynamicTrampoline, (PBYTE)DynamicDetour);
		DynamicTrampoline = NULL;
	}

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\acm\imaadpcm.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       imaadpcm.cpp
 *  Content:    IMA ADPCM CODEC.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  04/29/01    dereks  Created.
 *
 ****************************************************************************/

#include "imaadpcm.h"


/****************************************************************************
 *
 *  CImaAdpcmCodec
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

//
// This array is used by NextStepIndex to determine the next step index to use.  
// The step index is an index to the m_asStep[] array, below.
//

const short CImaAdpcmCodec::m_asNextStep[16] =
{
    -1, -1, -1, -1, 2, 4, 6, 8,
    -1, -1, -1, -1, 2, 4, 6, 8
};

//
// This array contains the array of step sizes used to encode the ADPCM
// samples.  The step index in each ADPCM block is an index to this array.
//

const short CImaAdpcmCodec::m_asStep[89] =
{
        7,     8,     9,    10,    11,    12,    13,
       14,    16,    17,    19,    21,    23,    25,
       28,    31,    34,    37,    41,    45,    50,
       55,    60,    66,    73,    80,    88,    97,
      107,   118,   130,   143,   157,   173,   190,
      209,   230,   253,   279,   307,   337,   371,
      408,   449,   494,   544,   598,   658,   724,
      796,   876,   963,  1060,  1166,  1282,  1411,
     1552,  1707,  1878,  2066,  2272,  2499,  2749,
     3024,  3327,  3660,  4026,  4428,  4871,  5358,
     5894,  6484,  7132,  7845,  8630,  9493, 10442,
    11487, 12635, 13899, 15289, 16818, 18500, 20350,
    22385, 24623, 27086, 29794, 32767
};

CImaAdpcmCodec::CImaAdpcmCodec
(
    void
)
{
}


/****************************************************************************
 *
 *  ~CImaAdpcmCodec
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CImaAdpcmCodec::~CImaAdpcmCodec
(
    void
)
{
}


/****************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPCIMAADPCMWAVEFORMAT [in]: encoded data format.
 *      BOOL [in]: TRUE to initialize the object as an encoder.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::Initialize
(
    LPCIMAADPCMWAVEFORMAT               pwfxEncode, 
    BOOL                                fEncoder
)
{
    static const LPFNIMAADPCMCONVERT    apfnConvert[2][2] = 
    { 
        {
            DecodeM16,
            DecodeS16 
        },
        {
            EncodeM16,
            EncodeS16 
        }
    };
    
    if(!IsValidImaAdpcmFormat(pwfxEncode))
    {
        return FALSE;
    }

    //
    // Save the format data
    //

    m_wfxEncode = *pwfxEncode;
    m_fEncoder = !!fEncoder;

    //
    // Set up the conversion function
    //

    m_pfnConvert = apfnConvert[m_fEncoder][m_wfxEncode.wfx.nChannels - 1];

    //
    // Initialize the stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;

    return TRUE;
}


/****************************************************************************
 *
 *  Convert
 *
 *  Description:
 *      Converts data from the source to destination format.
 *
 *  Arguments:
 *      LPCVOID [in]: source buffer.
 *      LPVOID [out]: destination buffer.
 *      UINT [in]: block count.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::Convert
(
    LPCVOID                 pvSrc,
    LPVOID                  pvDst,
    UINT                    cBlocks
)
{
    return m_pfnConvert((LPBYTE)pvSrc, (LPBYTE)pvDst, cBlocks, m_wfxEncode.wfx.nBlockAlign, m_wfxEncode.wSamplesPerBlock, &m_nStepIndexL, &m_nStepIndexR);
}


/****************************************************************************
 *
 *  Reset
 *
 *  Description:
 *      Resets the conversion operation.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::Reset
(
    void
)
{
    //
    // Reset the stepping indeces
    //

    m_nStepIndexL = m_nStepIndexR = 0;
}


/****************************************************************************
 *
 *  GetEncodeAlignment
 *
 *  Description:
 *      Gets the alignment of an encoded buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::GetEncodeAlignment
(
    void
)
{
    return m_wfxEncode.wfx.nBlockAlign;
}


/****************************************************************************
 *
 *  GetDecodeAlignment
 *
 *  Description:
 *      Gets the alignment of a decoded buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      DWORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::GetDecodeAlignment
(
    void
)
{
    return m_wfxEncode.wSamplesPerBlock * m_wfxEncode.wfx.nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;
}


/****************************************************************************
 *
 *  CalculateEncodeAlignment
 *
 *  Description:
 *      Calculates an encoded data block alignment based on a PCM sample
 *      count and an alignment multiplier.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      WORD [in]: PCM samples per block.
 *
 *  Returns:  
 *      WORD: alignment, in bytes.
 *
 ****************************************************************************/

WORD
CImaAdpcmCodec::CalculateEncodeAlignment
(
    WORD                    nChannels,
    WORD                    nSamplesPerBlock
)
{
    const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;
    const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;
    WORD                    nBlockAlign;

    //
    // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
    // value may include a partial encoded sample, so be sure to round up.
    //
    // Start with the samples-per-block, minus 1.  The first sample is actually
    // stored in the header.
    //

    nBlockAlign = nSamplesPerBlock - 1;

    //
    // Convert to encoded sample size
    //

    nBlockAlign *= nEncodedSampleBits;
    nBlockAlign += 7;
    nBlockAlign /= 8;

    //
    // The stereo encoder requires that there be at least two DWORDs to process
    //

    nBlockAlign += 7;
    nBlockAlign /= 8;
    nBlockAlign *= 8;

    //
    // Add the header
    //

    nBlockAlign += nHeaderBytes;

    return nBlockAlign;
}


/****************************************************************************
 *
 *  CreatePcmFormat
 *
 *  Description:
 *      Creates a PCM format descriptor.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPWAVEFORMATEX [out]: format descriptor.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::CreatePcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    LPWAVEFORMATEX          pwfx
)
{
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = nChannels;
    pwfx->nSamplesPerSec = nSamplesPerSec;
    pwfx->nBlockAlign = nChannels * IMAADPCM_PCM_BITS_PER_SAMPLE / 8;
    pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
    pwfx->wBitsPerSample = IMAADPCM_PCM_BITS_PER_SAMPLE;
}


/****************************************************************************
 *
 *  CreateImaAdpcmFormat
 *
 *  Description:
 *      Creates an IMA ADPCM format descriptor.
 *
 *  Arguments:
 *      WORD [in]: channel count.
 *      DWORD [in]: sampling rate.
 *      LPIMAADPCMWAVEFORMAT [out]: format descriptor.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

void
CImaAdpcmCodec::CreateImaAdpcmFormat
(
    WORD                    nChannels, 
    DWORD                   nSamplesPerSec, 
    WORD                    nSamplesPerBlock,
    LPIMAADPCMWAVEFORMAT    pwfx
)
{
    pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
    pwfx->wfx.nChannels = nChannels;
    pwfx->wfx.nSamplesPerSec = nSamplesPerSec;
    pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(nChannels, nSamplesPerBlock);
    pwfx->wfx.nAvgBytesPerSec = nSamplesPerSec * pwfx->wfx.nBlockAlign / nSamplesPerBlock;
    pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;
    pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
    pwfx->wSamplesPerBlock = nSamplesPerBlock;
}


/****************************************************************************
 *
 *  IsValidPcmFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL 
CImaAdpcmCodec::IsValidPcmFormat
(
    LPCWAVEFORMATEX         pwfx
)
{
    if(WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        return FALSE;
    }
    
    if((pwfx->nChannels < 1) || (pwfx->nChannels > IMAADPCM_MAX_CHANNELS))
    {
        return FALSE;
    }

    if(IMAADPCM_PCM_BITS_PER_SAMPLE != pwfx->wBitsPerSample)
    {
        return FALSE;
    }

    if(pwfx->nChannels * pwfx->wBitsPerSample / 8 != pwfx->nBlockAlign)
    {
        return FALSE;
    }

    if(pwfx->nBlockAlign * pwfx->nSamplesPerSec != pwfx->nAvgBytesPerSec)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  IsValidXboxAdpcmFormat
 *
 *  Description:
 *      Validates a format structure.
 *
 *  Arguments:
 *      LPCIMAADPCMWAVEFORMAT [in]: format.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL 
CImaAdpcmCodec::IsValidImaAdpcmFormat
(
    LPCIMAADPCMWAVEFORMAT   pwfx
)
{
    if(WAVE_FORMAT_XBOX_ADPCM != pwfx->wfx.wFormatTag)
    {
        return FALSE;
    }

    if(sizeof(*pwfx) - sizeof(pwfx->wfx) != pwfx->wfx.cbSize)
    {
        return FALSE;
    }
    
    if((pwfx->wfx.nChannels < 1) || (pwfx->wfx.nChannels > IMAADPCM_MAX_CHANNELS))
    {
        return FALSE;
    }

    if(IMAADPCM_BITS_PER_SAMPLE != pwfx->wfx.wBitsPerSample)
    {
        return FALSE;
    }

    if(CalculateEncodeAlignment(pwfx->wfx.nChannels, pwfx->wSamplesPerBlock) != pwfx->wfx.nBlockAlign)
    {
        return FALSE;
    }

    return TRUE;
}


/****************************************************************************
 *
 *  EncodeSample
 *
 *  Description:
 *      Encodes a sample.
 *
 *  Arguments:
 *      int [in]: the sample to be encoded.
 *      LPINT [in/out]: the predicted value of the sample.
 *      int [in]: the quantization step size used to encode the sample.
 *
 *  Returns:  
 *      int: the encoded ADPCM sample.
 *
 ****************************************************************************/

int
CImaAdpcmCodec::EncodeSample
(
    int                 nInputSample,
    LPINT               pnPredictedSample,
    int                 nStepSize
)
{
    int                 nPredictedSample;
    LONG                lDifference;
    int                 nEncodedSample;
    
    nPredictedSample = *pnPredictedSample;

    lDifference = nInputSample - nPredictedSample;
    nEncodedSample = 0;

    if(lDifference < 0) 
    {
        nEncodedSample = 8;
        lDifference = -lDifference;
    }

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 4;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 2;
        lDifference -= nStepSize;
    }

    nStepSize >>= 1;

    if(lDifference >= nStepSize)
    {
        nEncodedSample |= 1;
        lDifference -= nStepSize;
    }

    if(nEncodedSample & 8)
    {
        nPredictedSample = nInputSample + lDifference - (nStepSize >> 1);
    }
    else
    {
        nPredictedSample = nInputSample - lDifference + (nStepSize >> 1);
    }

    if(nPredictedSample > 32767)
    {
        nPredictedSample = 32767;
    }
    else if(nPredictedSample < -32768)
    {
        nPredictedSample = -32768;
    }

    *pnPredictedSample = nPredictedSample;
    
    return nEncodedSample;
}


/****************************************************************************
 *
 *  DecodeSample
 *
 *  Description:
 *      Decodes an encoded sample.
 *
 *  Arguments:
 *      int [in]: the sample to be decoded.
 *      int [in]: the predicted value of the sample.
 *      int [i]: the quantization step size used to encode the sample.
 *
 *  Returns:  
 *      int: the decoded PCM sample.
 *
 ****************************************************************************/

int
CImaAdpcmCodec::DecodeSample
(
    int                 nEncodedSample,
    int                 nPredictedSample,
    int                 nStepSize
)
{
    LONG                lDifference;
    LONG                lNewSample;

    lDifference = nStepSize >> 3;

    if(nEncodedSample & 4) 
    {
        lDifference += nStepSize;
    }

    if(nEncodedSample & 2) 
    {
        lDifference += nStepSize >> 1;
    }

    if(nEncodedSample & 1) 
    {
        lDifference += nStepSize >> 2;
    }

    if(nEncodedSample & 8)
    {
        lDifference = -lDifference;
    }

    lNewSample = nPredictedSample + lDifference;

    if((LONG)(short)lNewSample != lNewSample)
    {
        if(lNewSample < -32768)
        {
            lNewSample = -32768;
        }
        else
        {
            lNewSample = 32767;
        }
    }

    return (int)lNewSample;
}


/****************************************************************************
 *
 *  Conversion Routines
 *
 *  Description:
 *      Converts a PCM buffer to ADPCM, or the reverse.
 *
 *  Arguments:
 *      LPBYTE [in]: source buffer.
 *      LPBYTE [out]: destination buffer.
 *      UINT [in]: block count.
 *      UINT [in]: block alignment of the ADPCM data, in bytes.
 *      UINT [in]: the number of samples in each ADPCM block (not used in
 *                 decoding).
 *      LPINT [in/out]: left-channel stepping index.
 *      LPINT [in/out]: right-channel stepping index.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ****************************************************************************/

BOOL
CImaAdpcmCodec::EncodeM16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    int                     nSample;
    int                     nStepSize;
    int                     nEncSample1;
    int                     nEncSample2;
    int                     nPredSample;
    int                     nStepIndex;

    //
    // Save a local copy of the step index so we're not constantly 
    // dereferencing a pointer.
    //
    
    nStepIndex = *pnStepIndexL;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbDst;
        cSamples = cSamplesPerBlock - 1;

        //
        // Block header
        //

        nPredSample = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSample, nStepIndex);
        pbBlock += sizeof(LONG);

        //
        // We have written the header for this block--now write the data
        // chunk (which consists of a bunch of encoded nibbles).  Note
        // that if we don't have enough data to fill a complete byte, then
        // we add a 0 nibble on the end.
        //

        while(cSamples)
        {
            //
            // Sample 1
            //

            nSample = *(short *)pbSrc;
            pbSrc += sizeof(short);
            cSamples--;

            nStepSize = m_asStep[nStepIndex];
            nEncSample1 = EncodeSample(nSample, &nPredSample, nStepSize);
            nStepIndex = NextStepIndex(nEncSample1, nStepIndex);

            //
            // Sample 2
            //

            if(cSamples)
            {
                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);
                cSamples--;

                nStepSize = m_asStep[nStepIndex];
                nEncSample2 = EncodeSample(nSample, &nPredSample, nStepSize);
                nStepIndex = NextStepIndex(nEncSample2, nStepIndex);
            }
            else
            {
                nEncSample2 = 0;
            }

            //
            // Write out encoded byte.
            //

            *pbBlock++ = (BYTE)(nEncSample1 | (nEncSample2 << 4));
        }

        //
        // Skip padding
        //

        pbDst += nBlockAlignment;
    }

    //
    // Restore the value of the step index to be used on the next buffer.
    //

    *pnStepIndexL = nStepIndex;

    return TRUE;
}


BOOL
CImaAdpcmCodec::EncodeS16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    UINT                    cSubSamples;
    int                     nSample;
    int                     nStepSize;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;
    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;
    UINT                    i;

    //
    // Save a local copy of the step indeces so we're not constantly 
    // dereferencing a pointer.
    //
    
    nStepIndexL = *pnStepIndexL;
    nStepIndexR = *pnStepIndexR;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbDst;
        cSamples = cSamplesPerBlock - 1;

        //
        // LEFT channel block header
        //

        nPredSampleL = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSampleL, nStepIndexL);
        pbBlock += sizeof(LONG);

        //
        // RIGHT channel block header
        //

        nPredSampleR = *(short *)pbSrc;
        pbSrc += sizeof(short);

        *(LONG *)pbBlock = MAKELONG(nPredSampleR, nStepIndexR);
        pbBlock += sizeof(LONG);

        //
        // We have written the header for this block--now write the data
        // chunk.  This consists of 8 left samples (one DWORD of output)
        // followed by 8 right samples (also one DWORD).  Since the input
        // samples are interleaved, we create the left and right DWORDs
        // sample by sample, and then write them both out.
        //

        while(cSamples)
        {
            dwLeft = 0;
            dwRight = 0;

            cSubSamples = min(cSamples, 8);

            for(i = 0; i < cSubSamples; i++)
            {
                //
                // LEFT channel
                //

                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);

                nStepSize = m_asStep[nStepIndexL];
                
                nEncSampleL = EncodeSample(nSample, &nPredSampleL, nStepSize);

                nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);
                dwLeft |= (DWORD)nEncSampleL << (4 * i);

                //
                // RIGHT channel
                //

                nSample = *(short *)pbSrc;
                pbSrc += sizeof(short);

                nStepSize = m_asStep[nStepIndexR];
                
                nEncSampleR = EncodeSample(nSample, &nPredSampleR, nStepSize);

                nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);
                dwRight |= (DWORD)nEncSampleR << (4 * i);
            }

            //
            // Write out encoded DWORDs.
            //

            *(LPDWORD)pbBlock = dwLeft;
            pbBlock += sizeof(DWORD);

            *(LPDWORD)pbBlock = dwRight;
            pbBlock += sizeof(DWORD);

            cSamples -= cSubSamples;
        }

        //
        // Skip padding
        //

        pbDst += nBlockAlignment;
    }

    //
    // Restore the value of the step index to be used on the next buffer.
    //
    
    *pnStepIndexL = nStepIndexL;
    *pnStepIndexR = nStepIndexR;

    return TRUE;

}


BOOL
CImaAdpcmCodec::DecodeM16   
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    BOOL                    fSuccess    = TRUE;
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    BYTE                    bSample;
    int                     nStepSize;
    int                     nEncSample;
    int                     nPredSample;
    int                     nStepIndex;
    DWORD                   dwHeader;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbSrc;
        cSamples = cSamplesPerBlock - 1;
        
        //
        // Block header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);

        nPredSample = (int)(short)LOWORD(dwHeader);
        nStepIndex = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndex))
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }
        
        //
        // Write out first sample
        //

        *(short *)pbDst = (short)nPredSample;
        pbDst += sizeof(short);

        //
        // Enter the block loop
        //

        while(cSamples)
        {
            bSample = *pbBlock++;

            //
            // Sample 1
            //

            nEncSample = (bSample & (BYTE)0x0F);
            nStepSize = m_asStep[nStepIndex];
            nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);
            nStepIndex = NextStepIndex(nEncSample, nStepIndex);

            *(short *)pbDst = (short)nPredSample;
            pbDst += sizeof(short);

            cSamples--;

            //
            // Sample 2
            //

            if(cSamples)
            {
                nEncSample = (bSample >> 4);
                nStepSize = m_asStep[nStepIndex];
                nPredSample = DecodeSample(nEncSample, nPredSample, nStepSize);
                nStepIndex = NextStepIndex(nEncSample, nStepIndex);

                *(short *)pbDst = (short)nPredSample;
                pbDst += sizeof(short);

                cSamples--;
            }
        }

        //
        // Skip padding
        //

        pbSrc += nBlockAlignment;
    }

    return fSuccess;
}


BOOL
CImaAdpcmCodec::DecodeS16
(
    LPBYTE                  pbSrc,
    LPBYTE                  pbDst,
    UINT                    cBlocks,
    UINT                    nBlockAlignment,
    UINT                    cSamplesPerBlock,
    LPINT                   pnStepIndexL,
    LPINT                   pnStepIndexR
)
{
    BOOL                    fSuccess    = TRUE;
    LPBYTE                  pbBlock;
    UINT                    cSamples;
    UINT                    cSubSamples;
    int                     nStepSize;
    DWORD                   dwHeader;
    DWORD                   dwLeft;
    DWORD                   dwRight;
    int                     nEncSampleL;
    int                     nPredSampleL;
    int                     nStepIndexL;
    int                     nEncSampleR;
    int                     nPredSampleR;
    int                     nStepIndexR;
    UINT                    i;

    //
    // Enter the main loop
    //
    
    while(cBlocks--)
    {
        pbBlock = pbSrc;
        cSamples = cSamplesPerBlock - 1;

        //
        // LEFT channel header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);
        
        nPredSampleL = (int)(short)LOWORD(dwHeader);
        nStepIndexL = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndexL)) 
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }
        
        //
        // RIGHT channel header
        //

        dwHeader = *(LPDWORD)pbBlock;
        pbBlock += sizeof(DWORD);
        
        nPredSampleR = (int)(short)LOWORD(dwHeader);
        nStepIndexR = (int)(BYTE)HIWORD(dwHeader);

        if(!ValidStepIndex(nStepIndexR))
        {
            //
            // The step index is out of range - this is considered a fatal
            // error as the input stream is corrupted.  We fail by returning
            // zero bytes converted.
            //

            fSuccess = FALSE;
            break;
        }

        //
        // Write out first sample
        //

        *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
        pbDst += sizeof(DWORD);

        //
        // The first DWORD contains 4 left samples, the second DWORD
        // contains 4 right samples.  We process the source in 8-byte
        // chunks to make it easy to interleave the output correctly.
        //

        while(cSamples)
        {
            dwLeft = *(LPDWORD)pbBlock;
            pbBlock += sizeof(DWORD);
            dwRight = *(LPDWORD)pbBlock;
            pbBlock += sizeof(DWORD);

            cSubSamples = min(cSamples, 8);
            
            for(i = 0; i < cSubSamples; i++)
            {
                //
                // LEFT channel
                //

                nEncSampleL = (dwLeft & 0x0F);
                nStepSize = m_asStep[nStepIndexL];
                nPredSampleL = DecodeSample(nEncSampleL, nPredSampleL, nStepSize);
                nStepIndexL = NextStepIndex(nEncSampleL, nStepIndexL);

                //
                // RIGHT channel
                //

                nEncSampleR = (dwRight & 0x0F);
                nStepSize = m_asStep[nStepIndexR];
                nPredSampleR = DecodeSample(nEncSampleR, nPredSampleR, nStepSize);
                nStepIndexR = NextStepIndex(nEncSampleR, nStepIndexR);

                //
                // Write out sample
                //

                *(LPDWORD)pbDst = MAKELONG(nPredSampleL, nPredSampleR);
                pbDst += sizeof(DWORD);

                //
                // Shift the next input sample into the low-order 4 bits.
                //

                dwLeft >>= 4;
                dwRight >>= 4;
            }

            cSamples -= cSubSamples;
        }

        //
        // Skip padding
        //

        pbSrc += nBlockAlignment;
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\detours.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.cpp
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.3. (Build 43)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#include <ole2.h>
#include <imagehlp.h>
#include "detours.h"
#include "dtrsint.h"

//////////////////////////////////////////////////////////////////////////////
//
enum {
    OP_PRE_ES       = 0x26,
    OP_PRE_CS       = 0x2e,
    OP_PRE_SS       = 0x36,
    OP_PRE_DS       = 0x3e,
    OP_PRE_FS       = 0x64,
    OP_PRE_GS       = 0x65,
    OP_JMP_SEG      = 0x25,
    
    OP_JA           = 0x77,
    OP_NOP          = 0x90,
    OP_CALL         = 0xe8,
    OP_JMP          = 0xe9,
    OP_PREFIX       = 0xff,
    OP_MOV_EAX      = 0xa1,
    OP_SET_EAX      = 0xb8,
    OP_JMP_EAX      = 0xe0,
    OP_RET_POP      = 0xc2,
    OP_RET          = 0xc3,
    OP_BRK          = 0xcc,

    SIZE_OF_JMP     = 5,
    SIZE_OF_NOP     = 1,
    SIZE_OF_BRK     = 1,
    SIZE_OF_TRP_OPS = SIZE_OF_JMP /* + SIZE_OF_BRK */,
};

class CEnableWriteOnCodePage
{
public:
    CEnableWriteOnCodePage(PBYTE pbCode, LONG cbCode = DETOUR_TRAMPOLINE_SIZE)
    {
        m_pbCode = pbCode;
        m_cbCode = cbCode;
        m_dwOldPerm = 0;
        m_hProcess = GetCurrentProcess();

        if (m_pbCode && m_cbCode) {
            if (!FlushInstructionCache(m_hProcess, pbCode, cbCode)) {
                return;
            }
            if (!VirtualProtect(pbCode,
                                cbCode,
                                PAGE_EXECUTE_READWRITE,
                                &m_dwOldPerm)) {
                return;
            }
        }
    }

    ~CEnableWriteOnCodePage()
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            DWORD dwTemp = 0;
            if (!FlushInstructionCache(m_hProcess, m_pbCode, m_cbCode)) {
                return;
            }
            if (!VirtualProtect(m_pbCode, m_cbCode, m_dwOldPerm, &dwTemp)) {
                return;
            }
        }
    }

    BOOL SetPermission(DWORD dwPerms)
    {
        if (m_dwOldPerm && m_pbCode && m_cbCode) {
            m_dwOldPerm = dwPerms;
            return TRUE;
        }
        return FALSE;
    }

    BOOL IsValid(VOID)
    {
        return m_pbCode && m_cbCode && m_dwOldPerm;
    }

private:
    HANDLE  m_hProcess;
    PBYTE   m_pbCode;
    LONG    m_cbCode;
    DWORD   m_dwOldPerm;
};

//////////////////////////////////////////////////////////////////////////////
//
static BOOL detour_insert_jump(PBYTE pbCode, PBYTE pbDest, LONG cbCode)
{
    if (cbCode < SIZE_OF_JMP)
        return FALSE;

    pbCode = DetourGenJmp(pbCode, pbDest);
    for (cbCode -= SIZE_OF_JMP; cbCode > 0; cbCode--) {
        pbCode = DetourGenBreak(pbCode);
    }
    return TRUE;
}

static BOOL detour_insert_detour(PBYTE pbTarget,
                                 PBYTE pbTrampoline,
                                 PBYTE pbDetour)
{
    PBYTE pbCont = pbTarget;
    for (LONG cbTarget = 0; cbTarget < SIZE_OF_TRP_OPS;) {
        PBYTE pbOp = pbCont;
        BYTE bOp = *pbOp;
        pbCont = DetourCopyInstruction(NULL, pbCont, NULL);
        cbTarget = pbCont - pbTarget;

        if (bOp == OP_JMP ||
            bOp == OP_JMP_EAX ||
            bOp == OP_RET_POP ||
            bOp == OP_RET) {

            break;
        }
        if (bOp == OP_PREFIX && pbOp[1] == OP_JMP_SEG) {
            break;
        }
        if ((bOp == OP_PRE_ES ||
             bOp == OP_PRE_CS ||
             bOp == OP_PRE_SS ||
             bOp == OP_PRE_DS ||
             bOp == OP_PRE_FS ||
             bOp == OP_PRE_GS) &&
            pbOp[1] == OP_PREFIX &&
            pbOp[2] == OP_JMP_SEG) {
            break;
        }
    }
    if (cbTarget  < SIZE_OF_TRP_OPS) {
        // Too few instructions.
        return FALSE;
    }
    if (cbTarget > (DETOUR_TRAMPOLINE_SIZE - SIZE_OF_JMP - 1)) {
        // Too many instructions.
        return FALSE;
    }

    //////////////////////////////////////////////////////// Finalize Reroute.
    //
    CEnableWriteOnCodePage ewTrampoline(pbTrampoline, DETOUR_TRAMPOLINE_SIZE);
    CEnableWriteOnCodePage ewTarget(pbTarget, cbTarget);
    if (!ewTrampoline.SetPermission(PAGE_EXECUTE_READWRITE))
        return FALSE;
    if (!ewTarget.IsValid())
        return FALSE;
    
    PBYTE pbSrc = pbTarget;
    PBYTE pbDst = pbTrampoline;
    for (LONG cbCopy = 0; cbCopy < cbTarget;) {
        pbSrc = DetourCopyInstruction(pbDst, pbSrc, NULL);
        cbCopy = pbSrc - pbTarget;
        pbDst = pbTrampoline + cbCopy;
    }
    if (cbCopy != cbTarget)                             // Count came out different!
        return FALSE;

    if (!detour_insert_jump(pbDst, pbTarget + cbTarget, SIZE_OF_JMP))
        return FALSE;

    pbTrampoline[DETOUR_TRAMPOLINE_SIZE-1] = (BYTE)cbTarget;

    if (!detour_insert_jump(pbTarget, pbDetour, cbTarget))
        return FALSE;
    
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
BOOL WINAPI DetourRemove(PBYTE pbTrampoline,
                                       PBYTE pbDetour)
{
    pbTrampoline = DetourGetFinalCode(pbTrampoline, TRUE);
    pbDetour = DetourGetFinalCode(pbDetour, FALSE);

    ////////////////////////////////////// Verify that Trampoline is in place.
    //
    LONG cbTarget = pbTrampoline[DETOUR_TRAMPOLINE_SIZE-1];
    if (cbTarget == 0 || cbTarget >= DETOUR_TRAMPOLINE_SIZE - 1) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (pbTrampoline[cbTarget] != OP_JMP) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
        
    LONG offset = *((PDWORD)&pbTrampoline[cbTarget + 1]);
    PBYTE pbTarget = pbTrampoline + cbTarget + SIZE_OF_JMP + offset - cbTarget;

    if (pbTarget[0] != OP_JMP) {                        // Missing detour.
        SetLastError(ERROR_INVALID_BLOCK);
        return FALSE;
    }

    offset = *((PDWORD)&pbTarget[1]);
    PBYTE pbTargetDetour = pbTarget + SIZE_OF_JMP + offset;
    if (pbTargetDetour != pbDetour) {
        SetLastError(ERROR_INVALID_ACCESS);
        return FALSE;
    }

    /////////////////////////////////////////////////////// Remove the Detour.
    CEnableWriteOnCodePage ewTarget(pbTarget, cbTarget);
    
    PBYTE pbSrc = pbTrampoline;
    PBYTE pbDst = pbTarget;
    for (LONG cbCopy = 0; cbCopy < cbTarget; pbDst = pbTarget + cbCopy) {
        pbSrc = DetourCopyInstruction(pbDst, pbSrc, NULL);
        cbCopy = pbSrc - pbTrampoline;
    }
    if (cbCopy != cbTarget) {                           // Count came out different!
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }
    return TRUE;
}

PBYTE WINAPI DetourFunction(PBYTE pbTarget,
                            PBYTE pbDetour)
{
    PBYTE pbTrampoline = new BYTE [DETOUR_TRAMPOLINE_SIZE];
    if (pbTrampoline == NULL)
        return NULL;

    pbTarget = DetourGetFinalCode(pbTarget, FALSE);
    pbDetour = DetourGetFinalCode(pbDetour, FALSE);

    if (detour_insert_detour(pbTarget, pbTrampoline, pbDetour))
        return pbTrampoline;

    delete[] pbTrampoline;
    return NULL;
}

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour)
{
    return DetourFunctionWithEmptyTrampolineEx(pbTrampoline, pbTarget, pbDetour,
                                               NULL, NULL, NULL);
}

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour)
{
    pbTrampoline = DetourGetFinalCode(pbTrampoline, TRUE);
    pbTarget = DetourGetFinalCode(pbTarget, FALSE);
    pbDetour = DetourGetFinalCode(pbDetour, FALSE);
    
    if (ppbRealTrampoline)
        *ppbRealTrampoline = pbTrampoline;
    if (ppbRealTarget)
        *ppbRealTarget = pbTarget;
    if (ppbRealDetour)
        *ppbRealDetour = pbDetour;
    
    if (pbTrampoline == NULL || pbDetour == NULL || pbTarget == NULL)
        return FALSE;
    
    if (pbTrampoline[0] != OP_NOP ||
        pbTrampoline[1] != OP_NOP) {
        
        return FALSE;
    }
    
    return detour_insert_detour(pbTarget, pbTrampoline, pbDetour);
}

BOOL WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                         PBYTE pbDetour)
{
    return DetourFunctionWithTrampolineEx(pbTrampoline, pbDetour, NULL, NULL);
}

BOOL WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                           PBYTE pbDetour,
                                           PBYTE *ppbRealTrampoline,
                                           PBYTE *ppbRealTarget)
{
    PBYTE pbTarget = NULL;

    pbTrampoline = DetourGetFinalCode(pbTrampoline, TRUE);
    pbDetour = DetourGetFinalCode(pbDetour, FALSE);
    
    if (ppbRealTrampoline)
        *ppbRealTrampoline = pbTrampoline;
    if (ppbRealTarget)
        *ppbRealTarget = NULL;
    
    if (pbTrampoline == NULL || pbDetour == NULL)
        return FALSE;

    if (pbTrampoline[0] != OP_NOP   ||
        pbTrampoline[1] != OP_NOP   ||
        pbTrampoline[2] != OP_CALL  ||
        pbTrampoline[7] != OP_PREFIX    ||
        pbTrampoline[8] != OP_JMP_EAX) {
        
        return FALSE;
    }

    PVOID (__fastcall * pfAddr)(VOID);

    pfAddr = (PVOID (__fastcall *)(VOID))(pbTrampoline +
                                          SIZE_OF_NOP + SIZE_OF_NOP + SIZE_OF_JMP +
                                          *(LONG *)&pbTrampoline[3]);

    pbTarget = DetourGetFinalCode((PBYTE)(*pfAddr)(), FALSE);
    if (ppbRealTarget)
        *ppbRealTarget = pbTarget;

    return detour_insert_detour(pbTarget, pbTrampoline, pbDetour);
}

//////////////////////////////////////////////////////////////////////////////

PDETOUR_SYM_INFO DetourLoadImageHlp(VOID)
{
    static DETOUR_SYM_INFO symInfo;
    static PDETOUR_SYM_INFO pSymInfo= NULL;

    if (pSymInfo != NULL) {
        return pSymInfo;
    }

    pSymInfo = &symInfo;
    ZeroMemory(&symInfo, sizeof(symInfo));
    symInfo.hProcess = GetCurrentProcess();

    symInfo.hImageHlp = LoadLibraryA("imagehlp.dll");
    if (symInfo.hImageHlp == NULL) {
        return NULL;
    }

    symInfo.pfImagehlpApiVersionEx
        = (PF_ImagehlpApiVersionEx)GetProcAddress(symInfo.hImageHlp,
                                                  "ImagehlpApiVersionEx");
    symInfo.pfSymInitialize
        = (PF_SymInitialize)GetProcAddress(symInfo.hImageHlp, "SymInitialize");
    symInfo.pfSymSetOptions
        = (PF_SymSetOptions)GetProcAddress(symInfo.hImageHlp, "SymSetOptions");
    symInfo.pfSymGetOptions
        = (PF_SymGetOptions)GetProcAddress(symInfo.hImageHlp, "SymGetOptions");
    symInfo.pfSymLoadModule
        = (PF_SymLoadModule)GetProcAddress(symInfo.hImageHlp, "SymLoadModule");
    symInfo.pfSymGetModuleInfo
        = (PF_SymGetModuleInfo)GetProcAddress(symInfo.hImageHlp, "SymGetModuleInfo");
    symInfo.pfSymGetSymFromName
        = (PF_SymGetSymFromName)GetProcAddress(symInfo.hImageHlp, "SymGetSymFromName");
    symInfo.pfBindImage
        = (PF_BindImage)GetProcAddress(symInfo.hImageHlp, "BindImage");

    API_VERSION av;
    ZeroMemory(&av, sizeof(av));
    av.MajorVersion = API_VERSION_NUMBER;
            
    if (symInfo.pfImagehlpApiVersionEx) {
        (*symInfo.pfImagehlpApiVersionEx)(&av);
    }

    if (symInfo.pfImagehlpApiVersionEx == NULL || av.MajorVersion < API_VERSION_NUMBER) {
        FreeLibrary(symInfo.hImageHlp);
        symInfo.hImageHlp = NULL;
        return NULL;
    }
        
    if (symInfo.pfSymInitialize) {
        (*symInfo.pfSymInitialize)(symInfo.hProcess, NULL, FALSE);
    }
        
    if (symInfo.pfSymGetOptions && symInfo.pfSymSetOptions) {
        DWORD dw = (*symInfo.pfSymGetOptions)();
        dw &= (SYMOPT_CASE_INSENSITIVE | SYMOPT_UNDNAME | SYMOPT_DEFERRED_LOADS);
        (*symInfo.pfSymSetOptions)(dw);
    }
        
    return pSymInfo;
}

//////////////////////////////////////////////////////////////////////////////
//
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp)
{
    if (pbCode == NULL) {
        return NULL;
    }
    
    if (pbCode[0] == OP_PREFIX && pbCode[1] == OP_JMP_SEG) {
        // Looks like an import alias jump, then get the code it points to.
        pbCode = *(PBYTE *)&pbCode[2];
        pbCode = *(PBYTE *)pbCode;
    }
    else if (pbCode[0] == OP_JMP && fSkipJmp) {         // Reference passed (for tramp).
        // Looks like a reference passed from an incremental-link build.
        // We only skip these for trampolines.
        pbCode = pbCode + SIZE_OF_JMP + *(LONG *)&pbCode[1];
    }
    return pbCode;
}

PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction)
{
    /////////////////////////////////////////////// First, Try GetProcAddress.
    //
    HMODULE hModule = LoadLibraryA(pszModule);
    if (hModule == NULL) {
        return NULL;
    }

    PBYTE pbCode = (PBYTE)GetProcAddress(hModule, pszFunction);
    if (pbCode) {
        return pbCode;
    }

    ////////////////////////////////////////////////////// Then Try ImageHelp.
    //
    PDETOUR_SYM_INFO pSymInfo = DetourLoadImageHlp();
    if (pSymInfo == NULL || 
        pSymInfo->pfSymLoadModule == NULL ||
        pSymInfo->pfSymGetModuleInfo == NULL ||
        pSymInfo->pfSymGetSymFromName == NULL) {

        return NULL;
    }
    
    (*pSymInfo->pfSymLoadModule)(pSymInfo->hProcess, NULL, pszModule, NULL, (DWORD)hModule, 0);

    IMAGEHLP_MODULE modinfo;
    ZeroMemory(&modinfo, sizeof(modinfo));
    if (!(*pSymInfo->pfSymGetModuleInfo)(pSymInfo->hProcess, (DWORD)hModule, &modinfo)) {
        return NULL;
    }

    CHAR szFullName[512];
    strcpy(szFullName, modinfo.ModuleName);
    strcat(szFullName, "!");
    strcat(szFullName, pszFunction);
    
    DWORD nDisplacement = 0;
    struct CFullSymbol : IMAGEHLP_SYMBOL {
        CHAR szRestOfName[512];
    } symbol;
    ZeroMemory(&symbol, sizeof(symbol));
    symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    symbol.MaxNameLength = sizeof(symbol.szRestOfName)/sizeof(0);

    if (!(*pSymInfo->pfSymGetSymFromName)(pSymInfo->hProcess, szFullName, &symbol)) {
        return NULL;
    }

    return (PBYTE)symbol.Address;
}

//////////////////////////////////////////////////// Module Image Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast)
{
    PBYTE pbLast;
    
    if (hModuleLast == NULL) {
        pbLast = (PBYTE)0x10000;
    }
    else {
        pbLast = (PBYTE)hModuleLast + 0x10000;
    }

    MEMORY_BASIC_INFORMATION mbi;
    ZeroMemory(&mbi, sizeof(mbi));

    // Find the next memory region that contains a mapped PE image.
    //
    for (;; pbLast = (PBYTE)mbi.BaseAddress + mbi.RegionSize) {
        if (VirtualQuery((PVOID)pbLast, &mbi, sizeof(mbi)) <= 0) {
            return NULL;
        }

        // Skip uncommitted regions and guard pages.
        //
        if ((mbi.State != MEM_COMMIT) || (mbi.Protect & PAGE_GUARD)) {
            continue;
        }
        
        __try {
            PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pbLast;
            if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
                continue;
            }

            PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                              pDosHeader->e_lfanew);
            if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
                continue;
            }

            return (HMODULE)pDosHeader;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            /* nothing. */
        }
    }
    return NULL;
}

PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
    }
    
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }
        
        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        SetLastError(NO_ERROR);
        return (PBYTE)pNtHeader->OptionalHeader.AddressOfEntryPoint +
            pNtHeader->OptionalHeader.ImageBase;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);
    
    return NULL;
}

static inline PBYTE RvaAdjust(HMODULE hModule, DWORD raddr)
{
    if (raddr != NULL) {
        return (PBYTE)hModule + raddr;
    }
    return NULL;
}

BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
    }
    
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }
        
        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return FALSE;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        PIMAGE_EXPORT_DIRECTORY pExportDir
            = (PIMAGE_EXPORT_DIRECTORY)
            RvaAdjust(hModule,
                      pNtHeader->OptionalHeader
                      .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
        ULONG cbExportDir = pNtHeader->OptionalHeader
            .DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;
        
        if (pExportDir == NULL) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return FALSE;
        }

        PCHAR pszName = (PCHAR)RvaAdjust(hModule, pExportDir->Name);
        PDWORD pdwFunctions = (PDWORD)RvaAdjust(hModule, pExportDir->AddressOfFunctions);
        PDWORD pdwNames = (PDWORD)RvaAdjust(hModule, pExportDir->AddressOfNames);
        PWORD pwOrdinals = (PWORD)RvaAdjust(hModule, pExportDir->AddressOfNameOrdinals);

        for (DWORD nFunc = 0; nFunc < pExportDir->NumberOfFunctions; nFunc++) {
            PBYTE pbCode = (PBYTE)RvaAdjust(hModule, pdwFunctions[nFunc]);
            PCHAR pszName = (nFunc < pExportDir->NumberOfNames) ?
                (PCHAR)RvaAdjust(hModule, pdwNames[nFunc]) : NULL;
            ULONG nOrdinal = pExportDir->Base + pwOrdinals[nFunc];

            if (!(*pfExport)(pContext, nOrdinal, pszName, pbCode)) {
                break;
            }
        }
        SetLastError(NO_ERROR);
        return TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);
    return FALSE;
}

static PDETOUR_LOADED_BINARY WINAPI GetPayloadSectionFromModule(HMODULE hModule)
{
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hModule;
    if (hModule == NULL) {
        pDosHeader = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
    }
    
    __try {
        if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
            SetLastError(ERROR_BAD_EXE_FORMAT);
            return NULL;
        }
        
        PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)((PBYTE)pDosHeader +
                                                          pDosHeader->e_lfanew);
        if (pNtHeader->Signature != IMAGE_NT_SIGNATURE) {
            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        if (pNtHeader->FileHeader.SizeOfOptionalHeader == 0) {
            SetLastError(ERROR_EXE_MARKED_INVALID);
            return NULL;
        }
        
        PIMAGE_SECTION_HEADER pSectionHeaders
            = (PIMAGE_SECTION_HEADER)((PBYTE)pNtHeader
                                      + sizeof(pNtHeader->Signature)
                                      + sizeof(pNtHeader->FileHeader)
                                      + pNtHeader->FileHeader.SizeOfOptionalHeader);

        for (DWORD n = 0; n < pNtHeader->FileHeader.NumberOfSections; n++) {
            if (strcmp((PCHAR)pSectionHeaders[n].Name, ".detour") == 0) {
                if (pSectionHeaders[n].VirtualAddress == 0 ||
                    pSectionHeaders[n].SizeOfRawData == 0) {

                    break;
                }
                    
                PBYTE pbData = (PBYTE)pDosHeader + pSectionHeaders[n].VirtualAddress;
                DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pbData;
                if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
                    pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {
                    
                    break;
                }

                if (pHeader->nDataOffset == 0) {
                    pHeader->nDataOffset = pHeader->cbHeaderSize;
                }
                SetLastError(NO_ERROR);
                return (PBYTE)pHeader;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    SetLastError(ERROR_EXE_MARKED_INVALID);
    
    return NULL;
}

DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule)
{
    PDETOUR_LOADED_BINARY pBinary = GetPayloadSectionFromModule(hModule);
    
    __try {
        DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pBinary;
        if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
            pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {
            
            SetLastError(ERROR_INVALID_HANDLE);
            return 0;
        }
        SetLastError(NO_ERROR);
        return pHeader->cbDataSize;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    }
    SetLastError(ERROR_INVALID_HANDLE);
    return 0;
}

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD * pcbData)
{
    PBYTE pbData = NULL;
    DWORD cbData = 0;
    if (pcbData) {
        *pcbData = 0;
    }

    PDETOUR_LOADED_BINARY pBinary = GetPayloadSectionFromModule(hModule);
    
    __try {
        DETOUR_SECTION_HEADER *pHeader = (DETOUR_SECTION_HEADER *)pBinary;
        if (pHeader->cbHeaderSize < sizeof(DETOUR_SECTION_HEADER) ||
            pHeader->nSignature != DETOUR_SECTION_HEADER_SIGNATURE) {

            SetLastError(ERROR_INVALID_EXE_SIGNATURE);
            return NULL;
        }
        
        PBYTE pbBeg = ((PBYTE)pHeader) + pHeader->nDataOffset;
        PBYTE pbEnd = ((PBYTE)pHeader) + pHeader->cbDataSize;
        
        for (pbData = pbBeg; pbData < pbEnd;) {
            DETOUR_SECTION_RECORD *pSection = (DETOUR_SECTION_RECORD *)pbData;
            
            if (pSection->guid == rguid) {
                if (pcbData) {
                    *pcbData = pSection->cbBytes - sizeof(*pSection);
                    SetLastError(NO_ERROR);
                    return (PBYTE)(pSection + 1);
                }
            }
            
            pbData = (PBYTE)pSection + pSection->cbBytes;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }
    SetLastError(ERROR_INVALID_HANDLE);
    return NULL;
}

//  End of File
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\globals.h ===
/**************************************************************************************************************
**************************************************************************************************************/
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

#include <stdio.h>
#include <io.h>
#include <objbase.h>
#include <assert.h>
#include "detours.h"
#include <tchar.h>
#include <initguid.h>
#include <dmusici.h>
#include <string.h>
#include "dmscriptautguids.h"
#include "macros.h"
#include "helpers.h"

#define APP_NAME "AUDANALYZE"
#define ASSERT assert

DEFINE_GUID(CLSID_DirectMusicIgnoreThisOne,0xaee78e4d,0x8818,0x4020,0xAA,0x5D,0x99,0x77,0x56,0xAF,0x53,0xfb);
DEFINE_GUID(CLSID_DirectMusicFileStream, 0xf12f2c7d, 0x3651, 0x486f, 0xb9, 0xfa, 0x16, 0xe1, 0x1d, 0x15, 0x24, 0xfd);
DEFINE_GUID(CLSID_DirectMusicStreamStream, 0xf34feac1, 0xe3af, 0x49ad, 0x83, 0x97, 0xb, 0xed, 0x32, 0x3e, 0xf9, 0x6b);
DEFINE_GUID(CLSID_DirectMusicMemStream, 0x75ccb447, 0x8d3f, 0x4154, 0xab, 0xad, 0x59, 0x60, 0xae, 0xd4, 0xba, 0x63);


DEFINE_GUID(CLSID_DirectMusicAudioVBScriptIgnore, 0x4ee17959, 0x931e, 0x49e4, 0xa2, 0xc6, 0x97, 0x7e, 0xcf, 0x36, 0x28, 0xf3);


extern DWORD dwCLSIDTableSize;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\dtrsint.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       dtrsint.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.3. (Build 43)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DTRSINT_H_
#define _DTRSINT_H_

//////////////////////////////////////////////////////////////////////////////
//
typedef LPAPI_VERSION (NTAPI *PF_ImagehlpApiVersionEx)(LPAPI_VERSION AppVersion);

typedef BOOL (NTAPI *PF_SymInitialize)(IN HANDLE hProcess,
                                       IN LPSTR UserSearchPath,
                                       IN BOOL fInvadeProcess);
typedef DWORD (NTAPI *PF_SymSetOptions)(IN DWORD SymOptions);
typedef DWORD (NTAPI *PF_SymGetOptions)(VOID);
typedef BOOL (NTAPI *PF_SymLoadModule)(IN HANDLE hProcess,
                                       IN HANDLE hFile,
                                       IN PSTR ImageName,
                                       IN PSTR ModuleName,
                                       IN DWORD BaseOfDll,
                                       IN DWORD SizeOfDll);
typedef BOOL (NTAPI *PF_SymGetModuleInfo)(IN HANDLE hProcess,
                                          IN DWORD dwAddr,
                                          OUT PIMAGEHLP_MODULE ModuleInfo);
typedef BOOL (NTAPI *PF_SymGetSymFromName)(IN HANDLE hProcess,
                                           IN LPSTR Name,
                                           OUT PIMAGEHLP_SYMBOL Symbol);
typedef BOOL (NTAPI *PF_BindImage)(IN LPSTR pszImageName,
                                   IN LPSTR pszDllPath,
                                   IN LPSTR pszSymbolPath);

typedef struct _DETOUR_SYM_INFO
{
    HANDLE                   hProcess;
    HMODULE                  hImageHlp;
    PF_ImagehlpApiVersionEx  pfImagehlpApiVersionEx;
    PF_SymInitialize         pfSymInitialize;
    PF_SymSetOptions         pfSymSetOptions;
    PF_SymGetOptions         pfSymGetOptions;
    PF_SymLoadModule         pfSymLoadModule;
    PF_SymGetModuleInfo      pfSymGetModuleInfo;
    PF_SymGetSymFromName     pfSymGetSymFromName;
    PF_BindImage             pfBindImage;
} DETOUR_SYM_INFO, *PDETOUR_SYM_INFO;

//////////////////////////////////////////////////////////////////////////////
//
PDETOUR_SYM_INFO DetourLoadImageHlp(VOID);

//////////////////////////////////////////////////////////////////////////////
//
inline PBYTE DetourGenMovEax(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB8;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBB;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEcx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xB9;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdx(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBA;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBE;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEdi(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBF;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEbp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBD;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenMovEsp(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0xBC;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenPush(PBYTE pbCode, UINT32 nValue)
{
    *pbCode++ = 0x68;
    *((UINT32*&)pbCode)++ = nValue;
    return pbCode;
}

inline PBYTE DetourGenJmp(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE9;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenCall(PBYTE pbCode, PBYTE pbJmpDst, PBYTE pbJmpSrc = 0)
{
    if (pbJmpSrc == 0) {
        pbJmpSrc = pbCode;
    }
    *pbCode++ = 0xE8;
    *((INT32*&)pbCode)++ = pbJmpDst - (pbJmpSrc + 5);
    return pbCode;
}

inline PBYTE DetourGenBreak(PBYTE pbCode)
{
    *pbCode++ = 0xcc;
    return pbCode;
}

inline PBYTE DetourGenBreakRet(PBYTE pbCode)
{
    *pbCode++ = 0xc3;
    return pbCode;
}

inline PBYTE DetourGenBreakNop(PBYTE pbCode)
{
    *pbCode++ = 0x90;
    return pbCode;
}

#endif // _DTRSINT_H_

////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\windows\directx\dsound\tools\audanalyze\disasm.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//	Module:		detours.lib
//  File:		disasm.cpp
//
//	Detours for binary functions.  Version 1.3. (Build 43)
//  Includes support for all x86 chips prior to the Pentium III.
//
//	Copyright 1999, Microsoft Corporation
//
//	http://research.microsoft.com/sn/detours
//

#include <ole2.h>
#include <imagehlp.h>
#include "detours.h"
#include "disasm.h"

#undef ASSERT
#define ASSERT(x)

//////////////////////////////////////////////////////////////////////////////
//
//  Function:
//      DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget)
//  Purpose:
//      Copy a single instruction from pbSrc to pbDst.
//  Arguments:
//      pbDst:
//          Destination address for the instruction.  May be NULL in which
//          case DetourCopyInstruction is used to measure an instruction.
//          If not NULL then the source instruction is copied to the
//          destination instruction and any relative arguments are adjusted.
//      pbSrc:
//          Source address of the instruction.
//      ppbTarget:
//          Out parameter for any target instruction address pointed to by
//          the instruction.  For example, a branch or a jump insruction has
//          a target, but a load or store instruction doesn't.  A target is
//          another instruction that may be executed as a result of this
//          instruction.  ppbTarget may be NULL.
//		plExtra:
//			Out parameter for the number of extra bytes needed by the
//			instruction to reach the target.  For example, lExtra = 3 if the
//			instruction had an 8-bit relative offset, but needs a 32-bit
//			relative offset.
//  Returns:
//      Returns the address of the next instruction (following in the source)
//      instruction.  By subtracting pbSrc from the return value, the caller
//      can determinte the size of the instruction copied.
//  Comments:
//      By following the pbTarget, the caller can follow alternate
//      instruction streams.  However, it is not always possible to determine
//      the target based on static analysis.  For example, the destination of
//      a jump relative to a register cannot be determined from just the
//      instruction stream.  The output value, pbTarget, can have any of the
//      following outputs:
//			DETOUR_INSTRUCTION_TARGET_NONE:
//          	The instruction has no targets.
//			DETOUR_INSTRUCTION_TARGET_DYNAMIC:
//          	The instruction has a non-deterministic (dynamic) target.
//				(i.e. the jump is to an address held in a register.)
//          Address:   The instruction has the specified target.
//
//      When copying instructions, DetourCopyInstruction insures that any
//      targets remain constant.  It does so by adjusting any IP relative
//      offsets.
//
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
									 PBYTE pbSrc,
									 PBYTE *ppbTarget,
									 LONG *plExtra)
{
	CDetourDis oDetourDisasm(ppbTarget, plExtra);
	return oDetourDisasm.CopyInstruction(pbDst, pbSrc);
}

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget)
{
	CDetourDis oDetourDisasm(ppbTarget, NULL);
	return oDetourDisasm.CopyInstruction(pbDst, pbSrc);
}

/////////////////////////////////////////////////////////// Disassembler Code.
//
CDetourDis::CDetourDis(PBYTE *ppbTarget, LONG *plExtra)
{
	Set32BitOperand();
	Set32BitAddress();

	m_ppbTarget = ppbTarget ? ppbTarget : &m_pbScratchTarget;
	m_plExtra = plExtra ? plExtra : &m_lScratchExtra;

	*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_NONE;
	*m_plExtra = 0;
}

VOID CDetourDis::Set16BitOperand()
{
	m_b16BitOperand = TRUE;
}

VOID CDetourDis::Set32BitOperand()
{
	m_b16BitOperand = FALSE;
}

VOID CDetourDis::Set16BitAddress()
{
	m_b16BitAddress = TRUE;
}

VOID CDetourDis::Set32BitAddress()
{
	m_b16BitAddress = FALSE;
}

PBYTE CDetourDis::CopyInstruction(PBYTE pbDst, PBYTE pbSrc)
{
	// Configure scratch areas if real areas are not available.
	if (NULL == pbDst) {
		pbDst = m_rbScratchDst;
	}
	if (NULL == pbSrc) {
		// We can't copy a non-existent instruction.
		SetLastError(ERROR_INVALID_DATA);
		return NULL;
	}
	
	// Figure out how big the instruction is, do the appropriate copy,
	// and figure out what the target of the instruction is if any.
	//
	REFCOPYENTRY pEntry = &s_rceCopyTable[pbSrc[0]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyBytes(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
	LONG nBytesFixed = (pEntry->nFlagBits & ADDRESS)
		? (m_b16BitAddress ? pEntry->nFixedSize16 : pEntry->nFixedSize)
		: (m_b16BitOperand ? pEntry->nFixedSize16 : pEntry->nFixedSize);
	LONG nBytes = nBytesFixed;
	if (pEntry->nModOffset > 0) {
		BYTE bModRm = pbSrc[pEntry->nModOffset];
		BYTE bFlags = s_rbModRm[bModRm];
		
		if (bFlags & SIB) {
			BYTE bSib = pbSrc[pEntry->nModOffset + 1];
			
			if ((bSib & 0x07) == 0x05) {
				if ((bModRm & 0xc0) == 0x00) {
					nBytes += 4;
				}
				else if ((bModRm & 0xc0) == 0x40) {
					nBytes += 1;
				}
				else if ((bModRm & 0xc0) == 0x80) {
					nBytes += 4;
				}
			}
		}
		nBytes += bFlags & NOTSIB;
	}
	CopyMemory(pbDst, pbSrc, nBytes);

	if (pEntry->nRelOffset) {
		*m_ppbTarget = AdjustTarget(pbDst, pbSrc, nBytesFixed, pEntry->nRelOffset);
	}
	if (pEntry->nFlagBits & NOENLARGE) {
		*m_plExtra = -*m_plExtra;
	}
	if (pEntry->nFlagBits & DYNAMIC) {
		*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_DYNAMIC;
	}
	return pbSrc + nBytes;
}

PBYTE CDetourDis::CopyBytesPrefix(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	CopyBytes(pEntry, pbDst, pbSrc);
	
	pEntry = &s_rceCopyTable[pbSrc[1]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst + 1, pbSrc + 1);
}

PBYTE CDetourDis::AdjustTarget(PBYTE pbDst, PBYTE pbSrc, LONG cbOp, LONG cbTargetOffset)
{
	LONG cbTargetSize = cbOp - cbTargetOffset;
	PBYTE pbTarget = NULL;
	PVOID pvTargetAddr = &pbDst[cbTargetOffset];
	LONG nOldOffset = 0;
	
	switch (cbTargetSize) {
	  case 1:
		nOldOffset = (LONG)*(PCHAR&)pvTargetAddr;
		*m_plExtra = 3;
		break;
	  case 2:
		nOldOffset = (LONG)*(PSHORT&)pvTargetAddr;
		*m_plExtra = 2;
		break;
	  case 4:
		nOldOffset = (LONG)*(PLONG&)pvTargetAddr;
		*m_plExtra = 0;
		break;
	  default:
		ASSERT(!"cbTargetSize is invalid.");
		break;
	}
	
	pbTarget = pbSrc + cbOp + nOldOffset;
	LONG nNewOffset = nOldOffset - (pbDst - pbSrc);
	
	switch (cbTargetSize) {
	  case 1:
		*(PCHAR&)pvTargetAddr = (CHAR)nNewOffset;
		break;
	  case 2:
		*(PSHORT&)pvTargetAddr = (SHORT)nNewOffset;
		break;
	  case 4:
		*(PLONG&)pvTargetAddr = (LONG)nNewOffset;
		break;
	}
	ASSERT(pbDst + cbOp + nNewOffset == pbTarget);
	return pbTarget;
}

PBYTE CDetourDis::Invalid(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	ASSERT(!"Invalid Instruction");
	return pbSrc + 1;
}

////////////////////////////////////////////////////// Individual Bytes Codes.
//
PBYTE CDetourDis::Copy0F(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc)
{
	CopyBytes(pEntry, pbDst, pbSrc);
	
	pEntry = &s_rceCopyTable0F[pbSrc[1]];
	return (this->*pEntry->pfCopy)(pEntry, pbDst + 1, pbSrc + 1);
}

PBYTE CDetourDis::Copy66(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{	// Operand-size override prefix
	Set16BitOperand();
	return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::Copy67(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{	// Address size override prefix
	Set16BitAddress();
	return CopyBytesPrefix(pEntry, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF6(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	// TEST BYTE /0
	if (0x00 == (0x38 & pbSrc[1])) {	// reg(bits 543) of ModR/M == 0
		const COPYENTRY ce = { 0xf6, ENTRY_CopyBytes2Mod1 };
		return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
	}
	// DIV /6
	// IDIV /7
	// IMUL /5
	// MUL /4
	// NEG /3
	// NOT /2
	
	const COPYENTRY ce = { 0xf6, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyF7(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{
	// TEST WORD /0
	if (0x00 == (0x38 & pbSrc[1])) {	// reg(bits 543) of ModR/M == 0
		const COPYENTRY ce = { 0xf7, ENTRY_CopyBytes2ModOperand };
		return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
	}
	
	// DIV /6
	// IDIV /7
	// IMUL /5
	// MUL /4
	// NEG /3
	// NOT /2
	const COPYENTRY ce = { 0xf7, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

PBYTE CDetourDis::CopyFF(REFCOPYENTRY pEntry, PBYTE pbDst, PBYTE pbSrc) 
{	// CALL /2
	// CALL /3
	// INC /0
	// JMP /4
	// JMP /5
	// PUSH /6

	if (0x15 == pbSrc[1] || 0x25 == pbSrc[1]) {			// CALL [], JMP []
		PBYTE *ppbTarget = *(PBYTE**) &pbSrc[2];
		*m_ppbTarget = *ppbTarget;
	}
	else if (0x10 == (0x38 & pbSrc[1]) || // CALL /2 --> reg(bits 543) of ModR/M == 010
			 0x18 == (0x38 & pbSrc[1]) || // CALL /3 --> reg(bits 543) of ModR/M == 011
			 0x20 == (0x38 & pbSrc[1]) || // JMP /4 --> reg(bits 543) of ModR/M == 100
			 0x28 == (0x38 & pbSrc[1])    // JMP /5 --> reg(bits 543) of ModR/M == 101
			 ) {
		*m_ppbTarget = DETOUR_INSTRUCTION_TARGET_DYNAMIC;
	}
	const COPYENTRY ce = { 0xff, ENTRY_CopyBytes2Mod };
	return (this->*ce.pfCopy)(&ce, pbDst, pbSrc);
}

///////////////////////////////////////////////////////// Disassembler Tables.
//
const BYTE CDetourDis::s_rbModRm[256] = {
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 0x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 1x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 2x
	0,0,0,0, SIB|1,4,0,0, 0,0,0,0, SIB|1,4,0,0,					// 3x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 4x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 5x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 6x
	1,1,1,1, 2,1,1,1, 1,1,1,1, 2,1,1,1,					// 7x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// 8x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// 9x
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// Ax
	4,4,4,4, 5,4,4,4, 4,4,4,4, 5,4,4,4,					// Bx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Cx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Dx
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,					// Ex
	0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0					// Fx
};

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable[257] =
{ 
	{ 0x00, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x01, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x02, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x03, ENTRY_CopyBytes2Mod },						// ADD /r
	{ 0x04, ENTRY_CopyBytes2 },							// ADD ib
	{ 0x05, ENTRY_CopyBytes3Or5 },						// ADD iw
	{ 0x06, ENTRY_CopyBytes1 },							// PUSH
	{ 0x07, ENTRY_CopyBytes1 },							// POP
	{ 0x08, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x09, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0A, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0B, ENTRY_CopyBytes2Mod },						// OR /r
	{ 0x0C, ENTRY_CopyBytes2 },							// OR ib
	{ 0x0D, ENTRY_CopyBytes3Or5 },						// OR iw
	{ 0x0E, ENTRY_CopyBytes1 },							// PUSH
	{ 0x0F, ENTRY_Copy0F },								// Extension Ops 
	{ 0x10, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x11, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x12, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x13, ENTRY_CopyBytes2Mod },						// ADC /r
	{ 0x14, ENTRY_CopyBytes2 },							// ADC ib
	{ 0x15, ENTRY_CopyBytes3Or5 },						// ADC id
	{ 0x16, ENTRY_CopyBytes1 },							// PUSH
	{ 0x17, ENTRY_CopyBytes1 },							// POP
	{ 0x18, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x19, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1A, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1B, ENTRY_CopyBytes2Mod },						// SBB /r
	{ 0x1C, ENTRY_CopyBytes2 },							// SBB ib
	{ 0x1D, ENTRY_CopyBytes3Or5 },						// SBB id
	{ 0x1E, ENTRY_CopyBytes1 },							// PUSH
	{ 0x1F, ENTRY_CopyBytes1 },							// POP
	{ 0x20, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x21, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x22, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x23, ENTRY_CopyBytes2Mod },						// AND /r
	{ 0x24, ENTRY_CopyBytes2 },							// AND ib
	{ 0x25, ENTRY_CopyBytes3Or5 },						// AND id
	{ 0x26, ENTRY_CopyBytesPrefix },					// ES prefix 
	{ 0x27, ENTRY_CopyBytes1 },							// DAA
	{ 0x28, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x29, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2A, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2B, ENTRY_CopyBytes2Mod },						// SUB /r
	{ 0x2C, ENTRY_CopyBytes2 },							// SUB ib
	{ 0x2D, ENTRY_CopyBytes3Or5 },						// SUB id
	{ 0x2E, ENTRY_CopyBytesPrefix },					// CS prefix 
	{ 0x2F, ENTRY_CopyBytes1 },							// DAS
	{ 0x30, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x31, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x32, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x33, ENTRY_CopyBytes2Mod },						// XOR /r
	{ 0x34, ENTRY_CopyBytes2 },							// XOR ib
	{ 0x35, ENTRY_CopyBytes3Or5 },						// XOR id
	{ 0x36, ENTRY_CopyBytesPrefix },					// SS prefix 
	{ 0x37, ENTRY_CopyBytes1 },							// AAA
	{ 0x38, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x39, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3A, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3B, ENTRY_CopyBytes2Mod },						// CMP /r
	{ 0x3C, ENTRY_CopyBytes2 },							// CMP ib
	{ 0x3D, ENTRY_CopyBytes3Or5 },						// CMP id
	{ 0x3E, ENTRY_CopyBytesPrefix },					// DS prefix 
	{ 0x3F, ENTRY_CopyBytes1 },							// AAS
	{ 0x40, ENTRY_CopyBytes1 },							// INC
	{ 0x41, ENTRY_CopyBytes1 },							// INC
	{ 0x42, ENTRY_CopyBytes1 },							// INC
	{ 0x43, ENTRY_CopyBytes1 },							// INC
	{ 0x44, ENTRY_CopyBytes1 },							// INC
	{ 0x45, ENTRY_CopyBytes1 },							// INC
	{ 0x46, ENTRY_CopyBytes1 },							// INC
	{ 0x47, ENTRY_CopyBytes1 },							// INC
	{ 0x48, ENTRY_CopyBytes1 },							// DEC
	{ 0x49, ENTRY_CopyBytes1 },							// DEC
	{ 0x4A, ENTRY_CopyBytes1 },							// DEC
	{ 0x4B, ENTRY_CopyBytes1 },							// DEC
	{ 0x4C, ENTRY_CopyBytes1 },							// DEC
	{ 0x4D, ENTRY_CopyBytes1 },							// DEC
	{ 0x4E, ENTRY_CopyBytes1 },							// DEC
	{ 0x4F, ENTRY_CopyBytes1 },							// DEC
	{ 0x50, ENTRY_CopyBytes1 },							// PUSH
	{ 0x51, ENTRY_CopyBytes1 },							// PUSH
	{ 0x52, ENTRY_CopyBytes1 },							// PUSH
	{ 0x53, ENTRY_CopyBytes1 },							// PUSH
	{ 0x54, ENTRY_CopyBytes1 },							// PUSH
	{ 0x55, ENTRY_CopyBytes1 },							// PUSH
	{ 0x56, ENTRY_CopyBytes1 },							// PUSH
	{ 0x57, ENTRY_CopyBytes1 },							// PUSH
	{ 0x58, ENTRY_CopyBytes1 },							// POP
	{ 0x59, ENTRY_CopyBytes1 },							// POP
	{ 0x5A, ENTRY_CopyBytes1 },							// POP
	{ 0x5B, ENTRY_CopyBytes1 },							// POP
	{ 0x5C, ENTRY_CopyBytes1 },							// POP
	{ 0x5D, ENTRY_CopyBytes1 },							// POP
	{ 0x5E, ENTRY_CopyBytes1 },							// POP
	{ 0x5F, ENTRY_CopyBytes1 },							// POP
	{ 0x60, ENTRY_CopyBytes1 },							// PUSHAD
	{ 0x61, ENTRY_CopyBytes1 },							// POPAD
	{ 0x62, ENTRY_CopyBytes2Mod },						// BOUND /r
	{ 0x63, ENTRY_CopyBytes2Mod },						// ARPL /r
	{ 0x64, ENTRY_CopyBytesPrefix },					// FS prefix 
	{ 0x65, ENTRY_CopyBytesPrefix },					// GS prefix 
	{ 0x66, ENTRY_Copy66 },								// Operand Prefix 
	{ 0x67, ENTRY_Copy67 },								// Address Prefix 
	{ 0x68, ENTRY_CopyBytes3Or5 },						// PUSH
	{ 0x69, ENTRY_CopyBytes2ModOperand },				// 
	{ 0x6A, ENTRY_CopyBytes2 },							// PUSH
	{ 0x6B, ENTRY_CopyBytes2Mod1 },						// IMUL /r ib 
	{ 0x6C, ENTRY_CopyBytes1 },							// INS
	{ 0x6D, ENTRY_CopyBytes1 },							// INS
	{ 0x6E, ENTRY_CopyBytes1 },							// OUTS/OUTSB
	{ 0x6F, ENTRY_CopyBytes1 },							// OUTS/OUTSW
	{ 0x70, ENTRY_CopyBytes2Jump },						// JO
	{ 0x71, ENTRY_CopyBytes2Jump },						// JNO
	{ 0x72, ENTRY_CopyBytes2Jump },						// JB/JC/JNAE
	{ 0x73, ENTRY_CopyBytes2Jump },						// JAE/JNB/JNC
	{ 0x74, ENTRY_CopyBytes2Jump },						// JE/JZ
	{ 0x75, ENTRY_CopyBytes2Jump },						// JNE/JNZ
	{ 0x76, ENTRY_CopyBytes2Jump },						// JBE/JNA
	{ 0x77, ENTRY_CopyBytes2Jump },						// JA/JNBE
	{ 0x78, ENTRY_CopyBytes2Jump },						// JS
	{ 0x79, ENTRY_CopyBytes2Jump },						// JNS
	{ 0x7A, ENTRY_CopyBytes2Jump },						// JP/JPE
	{ 0x7B, ENTRY_CopyBytes2Jump },						// JNP/JPO
	{ 0x7C, ENTRY_CopyBytes2Jump },						// JL/JNGE
	{ 0x7D, ENTRY_CopyBytes2Jump },						// JGE/JNL
	{ 0x7E, ENTRY_CopyBytes2Jump },						// JLE/JNG
	{ 0x7F, ENTRY_CopyBytes2Jump },						// JG/JNLE
	{ 0x80, ENTRY_CopyBytes2Mod1 },						// ADC/2 ib, etc.s 
	{ 0x81, ENTRY_CopyBytes2ModOperand },				// 
	{ 0x82, ENTRY_CopyBytes2 },							// MOV al,x
	{ 0x83, ENTRY_CopyBytes2Mod1 },						// ADC/2 ib, etc. 
	{ 0x84, ENTRY_CopyBytes2Mod },						// TEST /r
	{ 0x85, ENTRY_CopyBytes2Mod },						// TEST /r
	{ 0x86, ENTRY_CopyBytes2Mod },						// XCHG /r @todo 
	{ 0x87, ENTRY_CopyBytes2Mod },						// XCHG /r @todo 
	{ 0x88, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x89, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8A, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8B, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8C, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8D, ENTRY_CopyBytes2Mod },						// LEA /r
	{ 0x8E, ENTRY_CopyBytes2Mod },						// MOV /r
	{ 0x8F, ENTRY_CopyBytes2Mod },						// POP /0
	{ 0x90, ENTRY_CopyBytes1 },							// NOP
	{ 0x91, ENTRY_CopyBytes1 },							// XCHG
	{ 0x92, ENTRY_CopyBytes1 },							// XCHG
	{ 0x93, ENTRY_CopyBytes1 },							// XCHG
	{ 0x94, ENTRY_CopyBytes1 },							// XCHG
	{ 0x95, ENTRY_CopyBytes1 },							// XCHG
	{ 0x96, ENTRY_CopyBytes1 },							// XCHG
	{ 0x97, ENTRY_CopyBytes1 },							// XCHG
	{ 0x98, ENTRY_CopyBytes1 },							// CWDE
	{ 0x99, ENTRY_CopyBytes1 },							// CDQ
	{ 0x9A, ENTRY_CopyBytes5Or7Dynamic },				// CALL cp 
	{ 0x9B, ENTRY_CopyBytes1 },							// WAIT/FWAIT
	{ 0x9C, ENTRY_CopyBytes1 },							// PUSHFD
	{ 0x9D, ENTRY_CopyBytes1 },							// POPFD
	{ 0x9E, ENTRY_CopyBytes1 },							// SAHF
	{ 0x9F, ENTRY_CopyBytes1 },							// LAHF
	{ 0xA0, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA1, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA2, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA3, ENTRY_CopyBytes3Or5Address },				// MOV
	{ 0xA4, ENTRY_CopyBytes1 },							// MOVS
	{ 0xA5, ENTRY_CopyBytes1 },							// MOVS/MOVSD
	{ 0xA6, ENTRY_CopyBytes1 },							// CMPS/CMPSB
	{ 0xA7, ENTRY_CopyBytes1 },							// CMPS/CMPSW
	{ 0xA8, ENTRY_CopyBytes2 },							// TEST
	{ 0xA9, ENTRY_CopyBytes3Or5 },						// TEST
	{ 0xAA, ENTRY_CopyBytes1 },							// STOS/STOSB
	{ 0xAB, ENTRY_CopyBytes1 },							// STOS/STOSW
	{ 0xAC, ENTRY_CopyBytes1 },							// LODS/LODSB
	{ 0xAD, ENTRY_CopyBytes1 },							// LODS/LODSW
	{ 0xAE, ENTRY_CopyBytes1 },							// SCAS/SCASB
	{ 0xAF, ENTRY_CopyBytes1 },							// SCAS/SCASD
	{ 0xB0, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB1, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB2, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB3, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB4, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB5, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB6, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB7, ENTRY_CopyBytes2 },							// MOV B0+rb
	{ 0xB8, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xB9, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBA, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBB, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBC, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBD, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBE, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xBF, ENTRY_CopyBytes3Or5 },						// MOV B8+rb
	{ 0xC0, ENTRY_CopyBytes2Mod1 },						// RCL/2 ib, etc. 
	{ 0xC1, ENTRY_CopyBytes2Mod1 },						// RCL/2 ib, etc. 
	{ 0xC2, ENTRY_CopyBytes3 },							// RET
	{ 0xC3, ENTRY_CopyBytes1 },							// RET
	{ 0xC4, ENTRY_CopyBytes2Mod },						// LES
	{ 0xC5, ENTRY_CopyBytes2Mod },						// LDS
	{ 0xC6, ENTRY_CopyBytes2Mod1 },						// MOV 
	{ 0xC7, ENTRY_CopyBytes2ModOperand },				// MOV
	{ 0xC8, ENTRY_CopyBytes4 },							// ENTER
	{ 0xC9, ENTRY_CopyBytes1 },							// LEAVE
	{ 0xCA, ENTRY_CopyBytes3Dynamic },					// RET
	{ 0xCB, ENTRY_CopyBytes1Dynamic },					// RET
	{ 0xCC, ENTRY_CopyBytes1Dynamic },					// INT 3
	{ 0xCD, ENTRY_CopyBytes2Dynamic },					// INT ib
	{ 0xCE, ENTRY_CopyBytes1Dynamic },					// INTO
	{ 0xCF, ENTRY_CopyBytes1Dynamic },					// IRET
	{ 0xD0, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD1, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD2, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD3, ENTRY_CopyBytes2Mod },						// RCL/2, etc.
	{ 0xD4, ENTRY_CopyBytes2 },							// AAM
	{ 0xD5, ENTRY_CopyBytes2 },							// AAD
	{ 0xD6, ENTRY_Invalid },							// 
	{ 0xD7, ENTRY_CopyBytes1 },							// XLAT/XLATB
	{ 0xD8, ENTRY_CopyBytes2Mod },						// FADD, etc. 
	{ 0xD9, ENTRY_CopyBytes2Mod },						// F2XM1, etc.
	{ 0xDA, ENTRY_CopyBytes2Mod },						// FLADD, etc. 
	{ 0xDB, ENTRY_CopyBytes2Mod },						// FCLEX, etc. 
	{ 0xDC, ENTRY_CopyBytes2Mod },						// FADD/0, etc. 
	{ 0xDD, ENTRY_CopyBytes2Mod },						// FFREE, etc. 
	{ 0xDE, ENTRY_CopyBytes2Mod },						// FADDP, etc. 
	{ 0xDF, ENTRY_CopyBytes2Mod },						// FBLD/4, etc. 
	{ 0xE0, ENTRY_CopyBytes2CantJump },					// LOOPNE cb
	{ 0xE1, ENTRY_CopyBytes2CantJump },					// LOOPE cb
	{ 0xE2, ENTRY_CopyBytes2CantJump },					// LOOP cb
	{ 0xE3, ENTRY_CopyBytes2Jump },						// JCXZ/JECXZ
	{ 0xE4, ENTRY_CopyBytes2 },							// IN ib
	{ 0xE5, ENTRY_CopyBytes2 },							// IN id
	{ 0xE6, ENTRY_CopyBytes2 },							// OUT ib
	{ 0xE7, ENTRY_CopyBytes2 },							// OUT ib
	{ 0xE8, ENTRY_CopyBytes3Or5Target },				// CALL cd
	{ 0xE9, ENTRY_CopyBytes3Or5Target },				// JMP cd
	{ 0xEA, ENTRY_CopyBytes5Or7Dynamic },				// JMP cp
	{ 0xEB, ENTRY_CopyBytes2Jump },						// JMP cb
	{ 0xEC, ENTRY_CopyBytes1 },							// IN ib
	{ 0xED, ENTRY_CopyBytes1 },							// IN id
	{ 0xEE, ENTRY_CopyBytes1 },							// OUT
	{ 0xEF, ENTRY_CopyBytes1 },							// OUT
	{ 0xF0, ENTRY_CopyBytesPrefix },					// LOCK prefix 
	{ 0xF1, ENTRY_Invalid },							// 
	{ 0xF2, ENTRY_CopyBytesPrefix },					// REPNE prefix 
	{ 0xF3, ENTRY_CopyBytesPrefix },					// REPE prefix 
	{ 0xF4, ENTRY_CopyBytes1 },							// HLT
	{ 0xF5, ENTRY_CopyBytes1 },							// CMC
	{ 0xF6, ENTRY_CopyF6 },								// TEST/0, DIV/6 
	{ 0xF7, ENTRY_CopyF7 },								// TEST/0, DIV/6 
	{ 0xF8, ENTRY_CopyBytes1 },							// CLC
	{ 0xF9, ENTRY_CopyBytes1 },							// STC
	{ 0xFA, ENTRY_CopyBytes1 },							// CLI
	{ 0xFB, ENTRY_CopyBytes1 },							// STI
	{ 0xFC, ENTRY_CopyBytes1 },							// CLD
	{ 0xFD, ENTRY_CopyBytes1 },							// STD
	{ 0xFE, ENTRY_CopyBytes2Mod },						// DEC/1,INC/0
	{ 0xFF, ENTRY_CopyFF },								// CALL/2
	{ 0, ENTRY_End },
};

const CDetourDis::COPYENTRY CDetourDis::s_rceCopyTable0F[257] =
{
	{ 0x00, ENTRY_CopyBytes2Mod },						// LLDT/2, etc. 
	{ 0x01, ENTRY_CopyBytes2Mod },						// INVLPG/7, etc. 
	{ 0x02, ENTRY_CopyBytes2Mod },						// LAR/r 
	{ 0x03, ENTRY_CopyBytes2Mod },						// LSL/r 
	{ 0x04, ENTRY_Invalid },							// _04 
	{ 0x05, ENTRY_Invalid },							// _05 
	{ 0x06, ENTRY_CopyBytes2 },							// CLTS 
	{ 0x07, ENTRY_Invalid },							// _07 
	{ 0x08, ENTRY_CopyBytes2 },							// INVD 
	{ 0x09, ENTRY_CopyBytes2 },							// WBINVD 
	{ 0x0A, ENTRY_Invalid },							// _0A 
	{ 0x0B, ENTRY_CopyBytes2 },							// UD2 
	{ 0x0C, ENTRY_Invalid },							// _0C 
	{ 0x0D, ENTRY_Invalid },							// _0D 
	{ 0x0E, ENTRY_Invalid },							// _0E 
	{ 0x0F, ENTRY_Invalid },							// _0F 
	{ 0x10, ENTRY_Invalid },							// _10 
	{ 0x11, ENTRY_Invalid },							// _11 
	{ 0x12, ENTRY_Invalid },							// _12 
	{ 0x13, ENTRY_Invalid },							// _13 
	{ 0x14, ENTRY_Invalid },							// _14 
	{ 0x15, ENTRY_Invalid },							// _15 
	{ 0x16, ENTRY_Invalid },							// _16 
	{ 0x17, ENTRY_Invalid },							// _17 
	{ 0x18, ENTRY_Invalid },							// _18 
	{ 0x19, ENTRY_Invalid },							// _19 
	{ 0x1A, ENTRY_Invalid },							// _1A 
	{ 0x1B, ENTRY_Invalid },							// _1B 
	{ 0x1C, ENTRY_Invalid },							// _1C 
	{ 0x1D, ENTRY_Invalid },							// _1D 
	{ 0x1E, ENTRY_Invalid },							// _1E 
	{ 0x1F, ENTRY_Invalid },							// _1F 
	{ 0x20, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x21, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x22, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x23, ENTRY_CopyBytes2Mod },						// MOV/r 
	{ 0x24, ENTRY_Invalid },							// _24 
	{ 0x25, ENTRY_Invalid },							// _25 
	{ 0x26, ENTRY_Invalid },							// _26 
	{ 0x27, ENTRY_Invalid },							// _27 
	{ 0x28, ENTRY_Invalid },							// _28 
	{ 0x29, ENTRY_Invalid },							// _29 
	{ 0x2A, ENTRY_Invalid },							// _2A 
	{ 0x2B, ENTRY_Invalid },							// _2B 
	{ 0x2C, ENTRY_Invalid },							// _2C 
	{ 0x2D, ENTRY_Invalid },							// _2D 
	{ 0x2E, ENTRY_Invalid },							// _2E 
	{ 0x2F, ENTRY_Invalid },							// _2F 
	{ 0x30, ENTR