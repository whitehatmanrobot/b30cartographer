  4:4
#define SGS_DAC_POWER_MGMNT_B_FIFO_DPM_DISABLED         0x00
#define SGS_DAC_POWER_MGMNT_B_FIFO_DPM_ENABLED          0x01
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL                   3:3
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL_POWER             0x00
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL_NO_POWER          0x01
#define SGS_DAC_POWER_MGMNT_B_APPL                      2:2
#define SGS_DAC_POWER_MGMNT_B_APPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_APPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_B_VPPL                      1:1
#define SGS_DAC_POWER_MGMNT_B_VPPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_VPPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_B_MPPL                      0:0
#define SGS_DAC_POWER_MGMNT_B_MPPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_MPPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_C                           0x000E
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT                  1:1
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT_POWER            0x00
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT_NO_POWER         0x01
#define SGS_DAC_POWER_MGMNT_C_CURSOR                    0:0
#define SGS_DAC_POWER_MGMNT_C_CURSOR_POWER              0x00
#define SGS_DAC_POWER_MGMNT_C_CURSOR_NO_POWER           0x01
#define SGS_DAC_MPLL_M                                  0x0010
#define SGS_DAC_MPLL_N                                  0x0011
#define SGS_DAC_MPLL_O                                  0x0012
#define SGS_DAC_MPLL_P                                  0x0013
#define SGS_DAC_APLL_M                                  0x0014
#define SGS_DAC_APLL_N                                  0x0015
#define SGS_DAC_APLL_O                                  0x0016
#define SGS_DAC_APLL_P                                  0x0017
#define SGS_DAC_VPLL_M                                  0x0018
#define SGS_DAC_VPLL_N                                  0x0019
#define SGS_DAC_VPLL_O                                  0x001A
#define SGS_DAC_VPLL_P                                  0x001B
#define SGS_DAC_VBLANK_CTRL                             0x001C
#define SGS_DAC_VBLANK_CTRL_DETECTION                   1:1
#define SGS_DAC_VBLANK_CTRL_DETECTION_NORMAL            0x00
#define SGS_DAC_VBLANK_CTRL_DETECTION_INHIBIT           0x01
#define SGS_DAC_VBLANK_CTRL_CONDITION                   0:0
#define SGS_DAC_VBLANK_CTRL_CONDITION_NORMAL            0x00
#define SGS_DAC_VBLANK_CTRL_CONDITION_FORCE             0x01
#define SGS_DAC_CURSOR_CTRL                             0x0020
#define SGS_DAC_CURSOR_CTRL_DISPLAY                     1:0
#define SGS_DAC_CURSOR_CTRL_DISPLAY_DISABLED            0x00
#define SGS_DAC_CURSOR_CTRL_DISPLAY_THREE_COLOR         0x01
#define SGS_DAC_CURSOR_CTRL_DISPLAY_TWO_COLOR_XOR       0x02
#define SGS_DAC_CURSOR_CTRL_DISPLAY_TWO_COLOR           0x03
#define SGS_DAC_CURSOR_POS_X_LO                         0x0022
#define SGS_DAC_CURSOR_POS_X_HI                         0x0023
#define SGS_DAC_CURSOR_POS_Y_LO                         0x0024
#define SGS_DAC_CURSOR_POS_Y_HI                         0x0025
#define SGS_DAC_CHECKSUM_CTRL                           0x0030
#define SGS_DAC_CHECKSUM_CTRL_VALUE                     2:2
#define SGS_DAC_CHECKSUM_CTRL_VALUE_NOT_RESET           0x00
#define SGS_DAC_CHECKSUM_CTRL_VALUE_RESET               0x01
#define SGS_DAC_CHECKSUM_CTRL_COLOR                     1:0
#define SGS_DAC_CHECKSUM_CTRL_COLOR_BLUE                0x00
#define SGS_DAC_CHECKSUM_CTRL_COLOR_GREEN               0x01
#define SGS_DAC_CHECKSUM_CTRL_COLOR_RED                 0x02
#define SGS_DAC_CHECKSUM_HI                             0x0031
#define SGS_DAC_CHECKSUM_MID                            0x0032
#define SGS_DAC_CHECKSUM_LO                             0x0033
#define SGS_DAC_GAMEPORT_STATE                          0x003D
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE            4:4
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE_ANALOG     0x00
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE_DIGITAL    0x01
#define SGS_DAC_GAMEPORT_STATE_COUNTER                  3:0
#define SGS_DAC_GAMEPORT_TYPE                           0x003E
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_7                 7:7
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_6                 6:6
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_5                 5:5
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_4                 4:4
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_3                 3:3
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_2                 2:2
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_1                 1:1
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_0                 0:0
#define SGS_DAC_GAMEPORT_TYPE_ANALOG                    0x00
#define SGS_DAC_GAMEPORT_TYPE_DIGITAL                   0x01
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT                  0x003F
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_7        7:7
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_6        6:6
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_5        5:5
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_4        4:4
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_3        3:3
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_2        2:2
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_1        1:1
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_0        0:0
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_NOT_PRESSED      0x00
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_PRESSED          0x01
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_0_LO              0x0040
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_0_HI              0x0041
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_1_LO              0x0042
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_1_HI              0x0043
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_2_LO              0x0044
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_2_HI              0x0045
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_3_LO              0x0046
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_3_HI              0x0047
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_4_LO              0x0048
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_4_HI              0x0049
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_5_LO              0x004A
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_5_HI              0x004B
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_6_LO              0x004C
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_6_HI              0x004D
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_7_LO              0x004E
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_7_HI              0x004F
#define SGS_DAC_CURSOR_COLOR_1_RED                      0x0050
#define SGS_DAC_CURSOR_COLOR_1_GREEN                    0x0051
#define SGS_DAC_CURSOR_COLOR_1_BLUE                     0x0052
#define SGS_DAC_CURSOR_COLOR_2_RED                      0x0054
#define SGS_DAC_CURSOR_COLOR_2_GREEN                    0x0055
#define SGS_DAC_CURSOR_COLOR_2_BLUE                     0x0056
#define SGS_DAC_CURSOR_COLOR_3_RED                      0x0057
#define SGS_DAC_CURSOR_COLOR_3_GREEN                    0x0058
#define SGS_DAC_CURSOR_COLOR_3_BLUE                     0x0059
#define SGS_DAC_CURSOR_PLANE_0_WRITE_0                  0x0100
#define SGS_DAC_CURSOR_PLANE_0_WRITE_7F                 0x017F
#define SGS_DAC_CURSOR_PLANE_1_WRITE_0                  0x0180
#define SGS_DAC_CURSOR_PLANE_1_WRITE_7F                 0x01FF
#define SGS_DAC_CURSOR_PLANE_0_READ_0                   0x0500
#define SGS_DAC_CURSOR_PLANE_0_READ_7F                  0x057F
#define SGS_DAC_CURSOR_PLANE_1_READ_0                   0x0580
#define SGS_DAC_CURSOR_PLANE_1_READ_7F                  0x05FF
#define SGS_DAC_TESTPOINT_0_0                           0xF000
#define SGS_DAC_TESTPOINT_0_1                           0xF001
#define SGS_DAC_TESTPOINT_0_2                           0xF002
#define SGS_DAC_TESTPOINT_0_3                           0xF003
#define SGS_DAC_TESTPOINT_0_4                           0xF004
#define SGS_DAC_TESTPOINT_0_5                           0xF005
#define SGS_DAC_TESTPOINT_0_6                           0xF006
#define SGS_DAC_TESTPOINT_0_7                           0xF007
#define SGS_DAC_TESTPOINT_1_0                           0xF008
#define SGS_DAC_TESTPOINT_1_1                           0xF009
#define SGS_DAC_TESTPOINT_1_2                           0xF00A
#define SGS_DAC_TESTPOINT_1_3                           0xF00B
#define SGS_DAC_TESTPOINT_1_4                           0xF00C
#define SGS_DAC_TESTPOINT_1_5                           0xF00D
#define SGS_DAC_TESTPOINT_1_6                           0xF00E
#define SGS_DAC_TESTPOINT_1_7                           0xF00F
#define SGS_DAC_TESTPOINT_3_0                           0xF010
#define SGS_DAC_TESTPOINT_3_1                           0xF011
#define SGS_DAC_TESTPOINT_3_2                           0xF012
#define SGS_DAC_TESTPOINT_3_3                           0xF013
#define SGS_DAC_TESTPOINT_3_4                           0xF014
#define SGS_DAC_TESTPOINT_3_5                           0xF015
#define SGS_DAC_TESTPOINT_3_6                           0xF016
#define SGS_DAC_TESTPOINT_3_7                           0xF017
#define SGS_DAC_TESTPOINT_4_0                           0xF018
#define SGS_DAC_TESTPOINT_4_1                           0xF019
#define SGS_DAC_TESTPOINT_4_2                           0xF01A
#define SGS_DAC_TESTPOINT_4_3                           0xF01B
#define SGS_DAC_TESTPOINT_4_4                           0xF01C
#define SGS_DAC_TESTPOINT_4_5                           0xF01D
#define SGS_DAC_TESTPOINT_4_6                           0xF01E
#define SGS_DAC_TESTPOINT_4_7                           0xF01F
#define SGS_DAC_CURSOR_TEST_0                           0xF028
#define SGS_DAC_CURSOR_TEST_1                           0xF029
#define SGS_DAC_CURSOR_TEST_2                           0xF02A
#define SGS_DAC_CURSOR_TEST_3                           0xF02B
#define SGS_DAC_CURSOR_TEST_4                           0xF02C
#define SGS_DAC_CURSOR_TEST_5                           0xF02D
#define SGS_DAC_CURSOR_TEST_6                           0xF02E
#define SGS_DAC_CURSOR_TEST_7                           0xF02F
#define SGS_DAC_FIFO_TEST_0                             0xF030
#define SGS_DAC_FIFO_TEST_1                             0xF031
#define SGS_DAC_FIFO_TEST_2                             0xF032
#define SGS_DAC_FIFO_TEST_3                             0xF033
#define SGS_DAC_FIFO_TEST_4                             0xF034
#define SGS_DAC_FIFO_TEST_5                             0xF035
#define SGS_DAC_FIFO_TEST_6                             0xF036
#define SGS_DAC_FIFO_TEST_7                             0xF037
#define SGS_DAC_MPLL_TEST_0                             0xF038
#define SGS_DAC_MPLL_TEST_1                             0xF039
#define SGS_DAC_MPLL_TEST_2                             0xF03A
#define SGS_DAC_MPLL_TEST_3                             0xF03B
#define SGS_DAC_MPLL_TEST_4                             0xF03C
#define SGS_DAC_MPLL_TEST_5                             0xF03D
#define SGS_DAC_MPLL_TEST_6                             0xF03E
#define SGS_DAC_MPLL_TEST_7                             0xF03F
#define SGS_DAC_VPLL_TEST_0                             0xF040
#define SGS_DAC_VPLL_TEST_1                             0xF041
#define SGS_DAC_VPLL_TEST_2                             0xF042 
#define SGS_DAC_VPLL_TEST_3                             0xF043
#define SGS_DAC_VPLL_TEST_4                             0xF044
#define SGS_DAC_VPLL_TEST_5                             0xF045
#define SGS_DAC_VPLL_TEST_6                             0xF046
#define SGS_DAC_VPLL_TEST_7                             0xF047
#define SGS_DAC_GAMEPORT_TEST_0                         0xF048
#define SGS_DAC_GAMEPORT_TEST_1                         0xF049
#define SGS_DAC_GAMEPORT_TEST_2                         0xF04A
#define SGS_DAC_GAMEPORT_TEST_3                         0xF04B
#define SGS_DAC_GAMEPORT_TEST_4                         0xF04C
#define SGS_DAC_GAMEPORT_TEST_5                         0xF04D
#define SGS_DAC_GAMEPORT_TEST_6                         0xF04E
#define SGS_DAC_GAMEPORT_TEST_7                         0xF04F
#define SGS_DAC_TESTPOINT_CTRL                          0xF058
#define SGS_DAC_TESTPOINT_TIMER                         0xF059
#define SGS_DAC_TEST_CTRL                               0xF05A
#define SGS_DAC_MISC_TEST_STATE                         0xF05B
#define SGS_DAC_TEST_OUT_CTRL                           0xF05C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\GTF.C ===
/*
    FILE:   gtf.c
    DATE:   4/8/99

    This file is the generic entry point for the gtf modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "gtf.h"
#include "gtfmath.h"
#include "utils.h"

/*
    Function:   GtfFindMode

    Purpose:    This routine looks for a mode in the GTF list of modes.

    Arguments:  lpModeIn    ptr to MODEINFO structure
                lpModeOut   ptr to MODEOUT structure

    Returns:    Gtf is a formula based mode computation. Given a set
                of input parameters which describe the mode, the
                set of timing parameters to display the mode is
                computed.

                Hence, this routine always returns TRUE and lpModeOut
                is filled in with the corret timing parameters.

    Preserve:   Do not change any fields in lpModeIn.
*/

int CFUNC
GtfFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut)
{
    GTFIN       GTFIn;
    GTFOUT      GTFOut;
    MODESTRUC   sGTF;

    GTFIn.dwHPixels      = lpModeIn->dwXRes;
    GTFIn.dwVLines       = lpModeIn->dwYRes;
    GTFIn.dwMarginsRqd   = FALSE;
    GTFIn.dwIntRqd       = FALSE;
    GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
    GTFIn.dwIPFreqRqd    = lpModeIn->dwRefreshRate;

    // Be careful of double scan modes. 512x384 needs to be calculated
    // as if it is 1024x768.
    if (lpModeIn->dwYRes < 400)
    {
        GTFIn.dwHPixels = (GTFIn.dwHPixels * 2);
        GTFIn.dwVLines  = (GTFIn.dwVLines  * 2);
    }

    // Get the timing parameters.
    ComputeGTFParameters(&GTFIn, &GTFOut);

    // Store all parameters in temporary MODESTRUC buffer. Note that
    // horizontal GTF parameters are returned in character clocks and
    // need to be converted to pixels.
    sGTF.wHorizVisible    = (USHORT) (GTFOut.dwHActiveChars << 3);
    sGTF.wVertVisible     = (USHORT) GTFOut.dwVActiveScans;
    sGTF.wRefresh         = (USHORT) lpModeIn->dwRefreshRate;
    sGTF.wHorizTotal      = (USHORT) (GTFOut.dwHTotalChars << 3);
    sGTF.wHorizBlankStart = (USHORT) (GTFOut.dwHBlankStartChar << 3);
    sGTF.wHorizSyncStart  = (USHORT) ((GTFOut.dwHBlankStartChar
                                     + GTFOut.dwHFrontPorchChars) << 3);
    sGTF.wHorizSyncEnd    = (USHORT) (sGTF.wHorizSyncStart
                                     + (GTFOut.dwHSyncChars << 3));
    sGTF.wHorizBlankEnd   = (USHORT) (GTFOut.dwHBlankEndChar << 3);
    sGTF.wVertTotal       = (USHORT) GTFOut.dwVTotalScans;
    sGTF.wVertBlankStart  = (USHORT) GTFOut.dwVBlankStartScan;
    sGTF.wVertSyncStart   = (USHORT) (GTFOut.dwVBlankStartScan
                                     + GTFOut.dwVFrontPorchScans);
    sGTF.wVertSyncEnd     = (USHORT) (sGTF.wVertSyncStart
                                     + GTFOut.dwVSyncScans);
    sGTF.wVertBlankEnd    = (USHORT) GTFOut.dwVBlankEndScan;
    sGTF.wDotClock        = (USHORT) GTFOut.dwPixelClockIn10KHertz;
    sGTF.wHSyncPolarity   = BUFFER_HSYNC_NEGATIVE;
    sGTF.wVSyncPolarity   = BUFFER_VSYNC_POSITIVE;

    // Be careful of double scan modes. Need to reduce the horizontals and
    // pixel clock by half since the GTF calculations were done with
    // GTFIn.dwHPixels and GTFIn.dwVLines doubled. All verticals except
    // VertVisible remain the same.
    if (lpModeIn->dwYRes < 400)
    {
        // Add 1 to account for rounding off--otherwise values will
        // be truncated.
        sGTF.wHorizVisible    = ((sGTF.wHorizVisible + 1)/2);
        sGTF.wVertVisible     = ((sGTF.wVertVisible + 1)/2);
        sGTF.wHorizTotal      = ((sGTF.wHorizTotal + 1)/2);
        sGTF.wHorizBlankStart = ((sGTF.wHorizBlankStart + 1)/2);
        sGTF.wHorizSyncStart  = ((sGTF.wHorizSyncStart + 1)/2);
        sGTF.wHorizSyncEnd    = ((sGTF.wHorizSyncEnd + 1)/2);
        sGTF.wHorizBlankEnd   = ((sGTF.wHorizBlankEnd + 1)/2);
        sGTF.wDotClock        = ((sGTF.wDotClock + 1)/2);
    }

    // Convert to final output format
    SetupParamsForVidLutClass (&sGTF, lpModeOut, lpModeIn);

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\GTF.H ===
/*
    FILE:   gtf.h
    DATE:   4/8/99

    This file is the gtf find or set mode code.
*/

extern int CFUNC GtfFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\vpemini.c ===
//***************************************************************************
//  Module Name:
//
//      vpemini.c
//
//  Abstract:
//
//      This module contains the miniport parts of the DXAPI "kernel-mode
//      VPE" interface for the .
//
//      The DirectDraw Video Port Extensions (VPE) are the services that
//      control hardware videoports, where video data is streamed into
//      off-screen memory from an external device such as a TV tuner or
//      MPEG decoder, and then displayed on the screen by a video overlay.
//
//      To support VPE, you'll need the following:
//
//          1. A 2-D driver with DirectDraw overlay support;
//          2. A video input device that interfaces with the videoport;
//          3. A bunch of VPE code in the display driver;
//          4. A bunch of VPE code here in the miniport.
//
//      The miniport code here comprises part of the DXAPI "kernel-mode
//      VPE" interface that can be called by other WDM drivers, such as
//      an MPEG driver.
//
// IMPORTANT NOTE ABOUT HARDWARE REQUIREMENTS:
//
//      Almost all of these miniport "kernel-mode VPE" routines may be
//      called asynchronously to what the display driver is currently
//      doing.  For example, a thread may be in the display driver in the
//      middle of programming an accelerated Blt at the exact moment that
//      the miniport gets called to do a videoport flip call.  Consequently,
//      your hardware MUST be able to handle these commands at any time
//      regardless of the state of the display driver.  So this means:
//
//          1. Your hardware has to be able to allow the programming of any
//             "kernel-mode VPE" command even while Blts or direct frame
//             buffer accesses or DMAs or whatever are occuring, without
//             hanging or incorrect drawing.
//
//          2. The registers used to program any of the "kernel-mode VPE"
//             services must be disjoint and separate from those used by
//             the display driver.  If you must program an indexed register
//             that is also used by the display driver (such as 0x3d4/0x3d5),
//             *YOU ARE PROBABLY TOAST*.  Both a thread in the display driver
//             and a thread calling these miniport services are preemptible,
//             meaning that even if you save and restore the index register,
//             there's no guarantee that the other thread won't wake up in
//             the middle and try to use the same (now incorrectly set)
//             register.
//
//      If your hardware does not guarantee both of the above, you CANNOT
//      support the "kernel-mode VPE" interface!  Go yell at your hardware
//      designers and get them to fix the hardware.  If both of the above
//      are not guaranteed, it's inevitable that your customers will randomly
//      hit system hangs and crashes while using VPE.  Your customers will
//      not be happy!
//
//      Also note that the likelihood of hitting a problem is significantly
//      increased when running on a multiple-processor machine.  Consequently,
//      you should try to test VPE on an MP machine while applications (such
//      as Winstone) are running in the background.
//
//      (Okay, okay, so I exaggerated a bit about pointer number 2.  You can
//      in fact use shared indexed registers in these VPE routines if you do
//      one of the following:
//
//          1. Disable VPE on multiple-processor machines.  (As of the time
//             of this writing, we haven't yet implemented a VideoPort or
//             Eng function that you can call to determine whether you're
//             running on a UP or MP machine, otherwise I would tell you
//             the name of the function to call.  But by the time you read
//             this, it will probably exist -- so have a look through the
//             VideoPort and Eng calls...)
//
//             You'll also have to save and restore the index register when
//             you're done.  Because a thread that calls a miniport function
//             is at raised IRQL, it may interrupt a thread in the display
//             driver at any point, but on a UP machine it's guaranteed that
//             the display driver thread will not interrupt the miniport
//             thread.
//
//          2. Use the CRTC register only in the DxEnableIrq routine --
//             DirectDraw automatically synchronizes with the display driver
//             before calling DxEnableIrq (this is not true for any other
//             Dx miniport calls).
//
// NOTE:
//
//      Most "kernel-mode VPE" routines can be called at raised IRQL, meaning
//      that they MUST be non-paged, and cannot call any pageable functions.
//
//  Environment:
//
//      Kernel mode
//
//  Copyright (c) 1997 Microsoft Corporation
//
//***************************************************************************

#ifdef NVPE

// Temporary fix for Compile error...ask!
#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

#include "vpelocal.h"

//#define _NVP_DTRACE

#ifdef _NVP_DTRACE
#define DEFINE_GLOBALS
#include "dtrace.h"
#endif


////////// globals
BOOL g_bFlip = FALSE;

extern void KeClearEvent(void *hEvent);


//
// Mark those routines that we can as pageable.  Remember that most
// "kernel-mode VPE" routines can be called at raised IRQL, which means
// that they must be kept non-paged.
//
// Note that these are the only two VPE miniport routines which may be
// pageable:
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NVQueryInterface)
#pragma alloc_text(PAGE,GetIrqInfo)
#endif

// !!! Not hooking Lock is success, but not hooking SetPattern is failure?
// !!! Should dwFlags be ANDed or EQUALed?  (SkipNextField)
// !!! Should we mark the interrupt as unsharable?


/*++

Routine Description:

    On NT, the miniport always has to "manage the IRQ" (to borrow from the
    Win95 terminology).  Consequently, this routine simply tells DirectDraw
    what interrupts we support.

    It's actually pretty easy to enable interrupts, in part because you
    don't have to tell the system what interrupt vector you're using, as
    PNP already knows that.  However, you *do* have to check whether PNP
    successfully assigned you an interrupt vector, before you tell DirectDraw
    that you support interrupts.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.

--*/

DWORD GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DWORD status = DXERR_UNSUPPORTED;

    //
    // Sometimes, the motherboard BIOS or PNP may conspire to refuse to
    // allocate an interrupt to us.  So before we tell DirectDraw that
    // we support interrupts, we must first check if we've actually been
    // assigned one!
    //

//     if ((hwDeviceExtension->BusInterruptLevel != 0) ||
//        (hwDeviceExtension->BusInterruptVector != 0)) 
	{

        GetIrqInfo->dwFlags = IRQINFO_HANDLED;

        status = DX_OK;
	}

    return status;
}

/*++

Routine Description:

    This routine is the interrupt service routine for the kernel video
    driver.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    TRUE if the interrupt is serviced; FALSE if it wasn't ours (this is done
    to support chained interrupts).

--*/

BOOLEAN Interrupt(PVOID HwDeviceExtension)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    // add your IRQ handling code here
	return FALSE;
}

/*++

Routine Description:

    This function notifies the miniport when it should enable or disable
    interrupts for VPE.  If an IRQ is not specified in this call, it
    should be disabled.

    On NT, since miniports always "manage the IRQ", we must call DirectDraw's
    IRQCallback routine from our HwInterrupt routine to notify DirectDraw
    whenever an interrupt occurs.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    EnableIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD EnableIrq(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PDDENABLEIRQINFO EnableIrqInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // First make sure we stash IRQCallback in our device extension before
    // enabling interrupts for the first time, otherwise we may call a NULL
    // pointer from our HwInterrupt routine!
    //
    // (Note that DirectDraw will give us a valid IRQCallback and lpIRQData
    // even when disabling interrupts, which means we won't crash if an
    // interrupt is taken between this point and the actual disabling of the
    // interrupt.)
    //

    hwDeviceExtension->IRQCallback = EnableIrqInfo->IRQCallback;
    hwDeviceExtension->pIRQData = EnableIrqInfo->lpIRQData;
	hwDeviceExtension->dwIRQSources = EnableIrqInfo->dwIRQSources;

    //
    // Clear any existing interrupts, turn off all interrupts by default,
    // and enable the new requested interrupts.
    //
    // NOTE: Be very careful if your driver uses interrupts for purposes
    //       other than VPE.  For example, if your display driver uses DMA,
    //       you probably won't want to clear the DMA interrupt flag here!
    //

    // Now enable the master interrupt switch.  Again, be careful if your
    // display driver uses interrupt for purposes other than VPE -- you
    // probably won't want to disable all video interrupts here like we
    // do!
    //
    // Note: DxEnableIrq is the only routine that may access the CRTC
    //       registers!  For more details, read the large note at the
    //       top of this file.
    //

    // If the vsync interrupt has been disabled, but a deferred overlay
    // offset is pending, flush it now.
    //

    return DX_OK;
}

/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD FlipVideoPort(
    PVOID HwDeviceExtension,
    PDDFLIPVIDEOPORTINFO FlipVideoPortInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    ULONG offset;

	VideoDebugPrint((0,"VPEMINI: FlipVideoPort()\n"));

    //
    // Get offset (from framebuffer) and add offset from surface:
    //

    offset = FlipVideoPortInfo->lpTargetSurface->dwSurfaceOffset
           + FlipVideoPortInfo->lpVideoPortData->dwOriginOffset;

    // flip the actual hw surface here

    return DX_OK;
}

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD FlipOverlay(
    PVOID HwDeviceExtension,
    PDDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput)
{
#if 0
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	DDSURFACEDATA* pCurSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpCurrentSurface;
	DDSURFACEDATA* pTargSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpTargetSurface;
	PNVP_CONTEXT pVPEContext;
	U032 dwFlags;
	NVP_OVERLAY pOvInfo;

	VideoDebugPrint((1,"VPEMINI: FlipOverlay()\n"));

	// get a pointer to the appropriate VPE context (assume VPE 0)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	pOvInfo = &(pVPEContext->nvpOverlay);

    // VPP flags
	dwFlags = VPP_PRESCALE;

	if (pTargSurf->dwOverlayFlags & DDOVER_INTERLEAVED)
	   dwFlags |= VPP_INTERLEAVED;

	if (pTargSurf->dwOverlayFlags & DDOVER_BOB)
	   dwFlags |= VPP_BOB;

    if (pFlipOverlayInfo->dwFlags & DDFLIP_ODD)
	   dwFlags |= VPP_ODD;
	else if (pFlipOverlayInfo->dwFlags & DDFLIP_EVEN)
	   dwFlags |= VPP_EVEN;


    // if not initialized 
/*
    NVP_CMD_OBJECT cmdObj;
	cmdObj.dwPortId = 0;
	cmdObj.dwChipId = pHwDevExt->ulChipID;
	cmdObj.dwDeviceId = ppdev->hDriver;
	cmdObj.hClient = ppdev->hClient;

    NVPInitialize(pHwDevExt, &cmdObj);
*/
    // initialize index 
    if (pVPEContext->nvpOverlay.dwOverlayBufferIndex == NVP_UNDEF)
        pVPEContext->nvpOverlay.dwOverlayBufferIndex = 0;

    // flip overlay here !
	if (NVPPrescaleAndFlip(pVPEContext, pOvInfo, pTargSurf->dwOverlayOffset, pTargSurf->lPitch, 0, dwFlags))
	    return DX_OK;

    return DXERR_GENERIC;
#else
	return DX_OK;
#endif
}


/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD BobNextField(
    PVOID HwDeviceExtension,
    PDDBOBNEXTFIELDINFO BobNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((2,"VPEMINI: BobNextField()\n"));

    return DX_OK;
}

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD SetState(
    PVOID HwDeviceExtension,
    PDDSETSTATEININFO SetStateInInfo,
    PDDSETSTATEOUTINFO SetStateOutInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((0,"VPEMINI: SetState()\n"));

    return DX_OK;
}


/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD SkipNextField(
    PVOID HwDeviceExtension,
    PDDSKIPNEXTFIELDINFO SkipNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((0,"VPEMINI: SkipNextField()\n"));

    return DX_OK;
}


/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD GetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO pGetPolarityInInfo,
    PDDGETPOLARITYOUTINFO pGetPolarityOutInfo)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;

	VideoDebugPrint((3,"VPEMINI: GetPolarity()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	// check video first !
	if (pVPEContext->nNumVidSurf)
	{
		// TRUE for Even, FALSE for Odd
		if (pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType == NVP_FIELD_ODD)
			pGetPolarityOutInfo->bPolarity = FALSE;
		else
			pGetPolarityOutInfo->bPolarity = TRUE;
	}
	// vbi polarity 
	else if (pVPEContext->nNumVBISurf)
	{
		if (pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType == NVP_FIELD_ODD)
			pGetPolarityOutInfo->bPolarity = FALSE;
		else
			pGetPolarityOutInfo->bPolarity = TRUE;
	}
	else
		return DXERR_GENERIC;

    return DX_OK;
}

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PDDGETCURRENTAUTOFLIPININFO pGetCurrentAutoflipInInfo,
    PDDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	int nNotifyIdx;

	VideoDebugPrint((3,"VPEMINI: GetCurrentAutoflip()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
	// check out video 
	if (pVPEContext->nNumVidSurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
		else
			// assume it is the next surface then !
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].nNextSurfaceIdx);
	}

	pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
	// check out vbi
	if (pVPEContext->nNumVBISurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
		else
			// assume it is the next surface then !
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].nNextSurfaceIdx);
	}

    return DX_OK;
}


/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PDDGETPREVIOUSAUTOFLIPININFO pGetAutoflipInInfo,
    PDDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	int nNotifyIdx;

	VideoDebugPrint((3,"VPEMINI: GetPreviousAutoflip()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
	// check out video 
	if (pVPEContext->nNumVidSurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			// if in progress, return index of previous surface
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)((pVPEContext->nVidSurfIdx == 0) ? (pVPEContext->nNumVidSurf - 1): (pVPEContext->nVidSurfIdx - 1));
		else
			// assume this is the "previous"ly autoflipped surface then !
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
	}

	pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
	// check out vbi
	if (pVPEContext->nNumVBISurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			// if in progress, return index of previous surface
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)((pVPEContext->nVBISurfIdx == 0) ? (pVPEContext->nNumVBISurf - 1): (pVPEContext->nVBISurfIdx - 1));
		else
			// assume this is the "previous"ly autoflipped surface then !
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
	}

    return DX_OK;
}


/*++

Routine Description:

    Generic method for obtaining interfaces from the miniport.

    Among other things, it's used for exporting the DXAPI "kernel-mode
    VPE" interface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    QueryInterface - Pointer to structure that describes the requested
        interface.

Return Value:

    DX_OK if successful.

--*/
VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;

    status = DXERR_UNSUPPORTED;

    if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_DxApi)) 
    {
	    PDXAPI_INTERFACE DxApiInterface;
        DxApiInterface = (PDXAPI_INTERFACE) QueryInterface->Interface;

        //
        // We are queried here for our "kernel-mode VPE" support only after
        // the display driver has already enabled VPE.  Consequently, we let
        // the display driver control what chips VPE is enabled on -- we
        // don't have to do that here.
        //

        DxApiInterface->Size    = sizeof(DXAPI_INTERFACE);
        DxApiInterface->Version = DXAPI_HALVERSION;
        DxApiInterface->Context = hwDeviceExtension;

        DxApiInterface->DxGetIrqInfo          = GetIrqInfo;
        DxApiInterface->DxEnableIrq           = EnableIrq;
        DxApiInterface->DxSkipNextField       = SkipNextField;
        DxApiInterface->DxBobNextField        = BobNextField;
        DxApiInterface->DxSetState            = SetState;
        DxApiInterface->DxFlipOverlay         = FlipOverlay;
        DxApiInterface->DxFlipVideoPort       = FlipVideoPort;
        DxApiInterface->DxGetPolarity         = GetPolarity;
        DxApiInterface->DxGetCurrentAutoflip  = GetCurrentAutoflip;
        DxApiInterface->DxGetPreviousAutoflip = GetPreviousAutoflip;
		DxApiInterface->DxTransfer			  = NVPTransfer;
		DxApiInterface->DxGetTransferStatus	  = NVPGetTransferStatus;

        status = DX_OK;
    }
	// I2c Interface
	else if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_I2C_INTERFACE))
	{
		I2CINTERFACE *pI2cInterface;
        pI2cInterface = (I2CINTERFACE *) QueryInterface->Interface;


		//pI2cInterface->_vddInterface;
    	pI2cInterface->i2cOpen = (I2COPEN) miniI2COpen;
    	pI2cInterface->i2cAccess = (I2CACCESS) miniI2CAccess;

        status = DX_OK;
	}

    return status;
}

/*
==============================================================================
	
	NVP3Initialize

	Description:	Initializes the NV video port. Creates channels and DMA
					contexts. Create Video and VBI objects.
					NV3 version uses PIO channel

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVP3Initialize(
	PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	NVOS10_PARAMETERS evParam;
	int nFreeCount;
	U032 status;
	NVOS09_PARAMETERS ntfParam;
	Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);

//////////// HACK
	g_bFlip = FALSE;
///////////

	VideoDebugPrint((3,"VPEMINI: NVP3Initialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// initialize context
	pVPEContext->pNVPChannel = (ULONG) pNVPChannel;	// keep a copy of the pio channel pointer
	pVPEContext->nvDmaFifo = NULL;
	pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
	pVPEContext->hClient = pCmdObj->hClient;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
	pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
	pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
	pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
	pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
	pVPEContext->nNumVidSurf = 0;
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->dwVPState = NVP_STATE_STOPPED;
	pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
	pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
	pVPEContext->nCurTransferIdx = NVP_EOQ;
	pVPEContext->nLastTransferIdx = NVP_EOQ;
	pVPEContext->nRecentTransferIdx = NVP_EOQ;
	pVPEContext->nNumTransfer = 0;
	pVPEContext->bxfContextCreated = FALSE;
	pVPEContext->bxfContextFlushed = FALSE;
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// alloc external decoder object
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_EXTERNAL_DECODER_OBJECT,
				NV03_EXTERNAL_VIDEO_DECODER) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate External Decoder Object 0x%X\n", NVP_EXTERNAL_DECODER_OBJECT));
		return FALSE;
	}

	// allocate transfer object (used for vbi and video capture)
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_M2M_OBJECT,
				NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Mem to mem transfer Object 0x%X\n", NVP_M2M_OBJECT));
		return FALSE;
	}

    // allocate the transfer FROM context
    if (RmAllocContextDma(
						pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
						0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
	}

    // allocate a notify context for transfer object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
    }
	
	// allocate a notify context for external decoder
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_EXTERNAL_DECODER_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->avpNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}

	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field0\n"));
		return FALSE;
	}

	// context DMA for video field1	
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field1\n"));
		return FALSE;
	}
	
	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field0\n"));
		return FALSE;
	}

	// context DMA for video field1
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field1\n"));
		return FALSE;
	}

	//CHECK_FREE_COUNT(pNVPChannel,10*5);
	nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	while (nFreeCount < 13*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}			
	pVPEContext->nFreeCount = nFreeCount - (13*4);

	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// transfer object setup
    pNVPChannel->subchannel[5].SetObject  = NVP_M2M_OBJECT;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = NVP_M2M_NOTIFIER;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = NVP_M2M_FROM_CONTEXT;
	
	// make sure decoder object is in the channel....
	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = NVP_EXTERNAL_DECODER_NOTIFIER;

	// plug in our buffer contexts
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] = NVP_VIDEO_FIELD0_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] = NVP_VIDEO_FIELD1_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]   = NVP_VBI_FIELD0_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]   = NVP_VBI_FIELD1_BUFFER_CONTEXT;
	
	// NB: we don't want to launch any captures at this point

	// setup the transfer callback
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_M2M_OBJECT;
  	evParam.hObjectNew = NVP_M2M_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
  	evParam.hEvent.low = (ULONG) NVPTransferNotify;
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for m2m transfer 0\n"));
		return FALSE;
	}

	// setup fields callbacks
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VideoField0Notify;

	// video field0
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 0\n"));
		return FALSE;
	}

	// video field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VideoField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 1\n"));
		return FALSE;
	}

	// vbi field0
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VBIField0Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 0\n"));
		return FALSE;
	}
			
	// vbi field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VBIField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 1\n"));
		return FALSE;
	}

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPInitialize

	Description:	Initializes the NV video port. Creates channels and DMA
					contexts. Create Video and VBI objects.
					DMA push buffer version (NV ver >= 0x04)

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPInitialize(
	PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
    NvNotification *aovNotifiers;
	U032 dwOvObj;
	NVOS10_PARAMETERS evParam;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
	U032 status;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pCmdObj->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3Initialize(pHwDevExt, pCmdObj);

//////////// HACK
	g_bFlip = FALSE;
///////////

	VideoDebugPrint((3,"VPEMINI: NVPInitialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// initialize context
	//pVPEContext->pNVPChannel = (ULONG) 0;
	pVPEContext->dwChipId = pCmdObj->dwChipId;
	pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
	pVPEContext->hClient = pCmdObj->hClient;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
	pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
	pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
	pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
	pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
	pVPEContext->nNumVidSurf = 0;
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->dwVPState = NVP_STATE_STOPPED;
	pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
	pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
	pVPEContext->nCurTransferIdx = NVP_EOQ;
	pVPEContext->nLastTransferIdx = NVP_EOQ;
	pVPEContext->nRecentTransferIdx = NVP_EOQ;
	pVPEContext->nNumTransfer = 0;
	pVPEContext->bxfContextCreated = FALSE;
	pVPEContext->bxfContextFlushed = FALSE;
	pVPEContext->hVPSyncEvent = pCmdObj->hVPSyncEvent;

	pVPEContext->nvDmaFifo = NULL;
	pVPEContext->DmaPushBufTotalSize = 32*1024*4;	// 32k DWORDs
	if (VideoPortAllocateBuffer((PVOID)pHwDevExt, pVPEContext->DmaPushBufTotalSize, (PVOID *)&(pVPEContext->nvDmaFifo)) != NO_ERROR)
		return FALSE;

    if (RmAllocContextDma(  pCmdObj->hClient,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_ONLY,
							0, // selector
                            (U032)(pVPEContext->nvDmaFifo),
                            pVPEContext->DmaPushBufTotalSize - 1) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Context Dma for PushBuffer Object\n"));
		return FALSE;
    }

    // Allocate the DMA push buffer ERROR notifier
    if (RmAllocContextDma(  pCmdObj->hClient,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
							0, // selector
                            (U032)(&(pVPEContext->DmaPushBufErrNotifier[0])),
                            sizeof(NvNotification) - 1) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate PushBuffer notifier\n"));
		return FALSE;
    }

	// allocate DMA channel here !
    if (RmAllocChannelDma(  pCmdObj->hClient,
                            pCmdObj->dwDeviceId,
                            NVP_VPE_CHANNEL,
                            NV4_CHANNEL_DMA,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            0,
                            (PVOID)&(pVPEContext->pDmaChannel)) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Dma Channel 0x%X\n", NVP_VPE_CHANNEL));
		return FALSE;
    }

	// alloc external decoder object
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_EXTERNAL_DECODER_OBJECT,
				NV03_EXTERNAL_VIDEO_DECODER) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate External Decoder Object 0x%X\n", NVP_EXTERNAL_DECODER_OBJECT));
		return FALSE;
	}

	// allocate transfer object (used for vbi and video capture)
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_M2M_OBJECT,
				NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Mem to mem transfer Object 0x%X\n", NVP_M2M_OBJECT));
		return FALSE;
	}

    dwOvObj = (pCmdObj->dwChipId < NV_DEVICE_VERSION_10) ? NV04_VIDEO_OVERLAY : NV10_VIDEO_OVERLAY;

	// alloc overlay object 
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_OVERLAY_OBJECT,
				dwOvObj) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Overlay Object 0x%X\n", NVP_OVERLAY_OBJECT));
		return FALSE;
	}


	// alloc DVD subpicture object 
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_DVD_SUBPICTURE_OBJECT,
				NV4_DVD_SUBPICTURE) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate DVD subpicture Object 0x%X\n", NVP_DVD_SUBPICTURE_OBJECT));
		return FALSE;
	}

    // allocate the transfer FROM context
    if (RmAllocContextDma(
						pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
						0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
	}

    // allocate a notify context for transfer object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
    }
	
	// allocate a notify context for external decoder
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_EXTERNAL_DECODER_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->avpNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}

	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field0\n"));
		return FALSE;
	}

	// context DMA for video field1	
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field1\n"));
		return FALSE;
	}
	
	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field0\n"));
		return FALSE;
	}

	// context DMA for video field1
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field1\n"));
		return FALSE;
	}

    // allocate a context for overlay object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_OVERLAY_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate dma context for overlay buffer0\n"));
        return FALSE;
    }

    // allocate a context for DVD subpicture object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_DVD_SUBPICTURE_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate dma context for DVD subpicture Object\n"));
        return FALSE;
    }

	// allocate a notify context for overlay notifiers
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_OVERLAY_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->aovNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS07A_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}


    // reset media port notifiers
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // reset overlay notifiers
    aovNotifiers = (NvNotification *) (pVPEContext->aovNotifiers);
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(0)].status = 0;
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(1)].status = 0;

	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = (U032) (pVPEContext->aovNotifiers);

	// init Dma channel pointers
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    pDmaChannel->Put = 0;
    nvDmaCount = 0;

	// set m2m object context
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_NOTIFIES, NVP_M2M_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_IN, NVP_M2M_FROM_CONTEXT);

	// make sure decoder object is in the channel....
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_NOTIFIES, NVP_EXTERNAL_DECODER_NOTIFIER);
	// plug in our buffer contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(0), NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(1), NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(0), NVP_VBI_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(1), NVP_VBI_FIELD1_BUFFER_CONTEXT);

    // set overlay contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_NOTIFIES, NVP_OVERLAY_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(0), NVP_OVERLAY_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(1), NVP_OVERLAY_BUFFER_CONTEXT);

    // same for DVD subpicture context
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT, NVP_DVD_SUBPICTURE_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_IN, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_OUT, NVP_DVD_SUBPICTURE_CONTEXT);

	pVPEContext->nvDmaCount = nvDmaCount;
    pDmaChannel->Put = nvDmaCount << 2;

	// NB: we don't want to launch any captures at this point

	// setup the transfer callback
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_M2M_OBJECT;
  	evParam.hObjectNew = NVP_M2M_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
  	evParam.hEvent.low = (ULONG) NVPTransferNotify;
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for m2m transfer 0\n"));
		return FALSE;
	}

	// setup fields callbacks
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VideoField0Notify;

	// video field0
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 0\n"));
		return FALSE;
	}

	// video field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VideoField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 1\n"));
		return FALSE;
	}

	// vbi field0
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VBIField0Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 0\n"));
		return FALSE;
	}
			
	// vbi field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VBIField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 1\n"));
		return FALSE;
	}

	// vsync event
	if (pCmdObj->hVPSyncEvent)
	{
	    // field 0
		evParam.hRoot = pCmdObj->hClient;
	  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
	  	evParam.hObjectNew = NVP_VSYNC_EVENT0;
	  	evParam.hClass = NV01_EVENT_WIN32_EVENT;
	  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
	  	evParam.hEvent.low = (ULONG) pCmdObj->hVPSyncEvent;

		status = Nv01AllocEvent(&evParam);
		if (status)
		{
	    	VideoDebugPrint((0,"VPEMINI: Cannot set event for video field 0\n"));
			return FALSE;
		}

        // field 1 (use same event for both fields)
		evParam.hRoot = pCmdObj->hClient;
	  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
	  	evParam.hObjectNew = NVP_VSYNC_EVENT1;
	  	evParam.hClass = NV01_EVENT_WIN32_EVENT;
	  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
	  	evParam.hEvent.low = (ULONG) pCmdObj->hVPSyncEvent;

		status = Nv01AllocEvent(&evParam);
		if (status)
		{
	    	VideoDebugPrint((0,"VPEMINI: Cannot set event for video field 0\n"));
			return FALSE;
		}

	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUninitialize

	Description:	Free channels, DMA contexts and objects created by a 
					previous call to NVPInitialize

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUninitialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;

	VideoDebugPrint((3,"VPEMINI: NVPUninitialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// free allocated resources
	////////// shouldn't we wait for completion (either grab of transfer ?!)
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_EXTERNAL_DECODER_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_EXTERNAL_DECODER_OBJECT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DVD_SUBPICTURE_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_OBJECT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DVD_SUBPICTURE_OBJECT);

	// free transfer object resources
	if (pVPEContext->bxfContextCreated)
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_CONTEXT);

	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_FROM_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_OBJECT);

	if (pVPEContext->hVPSyncEvent)
	{
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VSYNC_EVENT0);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VSYNC_EVENT1);
		pVPEContext->hVPSyncEvent = 0;
	}

	if (pVPEContext->nvDmaFifo != NULL)
	{
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VPE_CHANNEL);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_FROM_MEMORY_PUSHBUF);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_PUSHBUF_ERROR_NOTIFIER);
		VideoPortReleaseBuffer((PVOID)(pHwDevExt), (PVOID)(pVPEContext->nvDmaFifo));
	}

    pVPEContext->pOverlayChannel = 0;
    pVPEContext->nvDmaFifo = NULL;

    pVPEContext->nvpOverlay.dwOverlayBufferIndex = NVP_UNDEF;

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUpdate

	Description:	Updates the NV video port data.

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUpdate(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_OVERLAY pnvOverlay;
    int i;

	VideoDebugPrint((3,"VPEMINI: NVPUpdate()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
	{
		VideoDebugPrint((0,"VPEMINI: Error in 'NVPUpdate' >>> exceeded number of extra 422 surfaces \n"));
		return ERROR_INVALID_PARAMETER;
	}

	// get a pointer to the overlay object in VPE context
	pnvOverlay = &(pVPEContext->nvpOverlay);

	// update overlay info: extra 422 surfaces used for prescaling
	pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
	pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
	pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < (int)pCmdObj->dwExtra422NumSurfaces; i++)
	{
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i];	// extra memory space used for prescaling
    }

	// start video grabbing here if not already done in NVPStart
	if ((pVPEContext->nNumVidSurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO))
	{
		// start VBI at the same time as video if vbi is not already enabled !
		if (pVPEContext->nNumVBISurf > 0)
		{
		    // is it already started, then no need to do it again...
		    if (!(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
			{
				(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
				pVPEContext->nNextVBISurfId = 1;
			}
			pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO | NVP_STATE_STARTED_VBI);
		}
		else
	    	pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO);
		 
		(pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
		// kick off VP 
		pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
		// we OR 0x80 to tell function this is not a notifier calling !
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
	}
	// start VBI grabbing here if not already done in NVPStart
    else if ((pVPEContext->nNumVBISurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
	{
	    // if video already started, then only enable VBI state flag
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
		{
		    pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
		}
		else
		{
			pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VBI);
			(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
			pVPEContext->nNextVBISurfId = 1;
			// kick off VP 
			NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
			NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
		}
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPStart

	Description:	Tells the NV video port to start grabbing video

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPStart(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_OVERLAY pnvOverlay;
    int i;

	VideoDebugPrint((3,"VPEMINI: NVPStart()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// aleady started ?! it must be an UpdateVideo then...
	if (pVPEContext->dwVPState & NVP_STATE_STARTED)
		return NVPUpdate(pHwDevExt,	pCmdObj);

	// current
	pVPEContext->nVidSurfIdx = 0;
	pVPEContext->nVBISurfIdx = 0;
	// next in the list
	pVPEContext->nNextVideoSurfId = 0;
	pVPEContext->nNextVBISurfId = 0;

	// update overlay channel pointer ! 
	/////// NVPUpdate() must be the place for this !?
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

	pVPEContext->dwVPState = NVP_STATE_STARTED;
	pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;
//	pVPEContext->aExtra422OverlayOffset[0] = pCmdObj->aExtra422OverlayOffset[0];
//	pVPEContext->aExtra422OverlayOffset[1] = pCmdObj->aExtra422OverlayOffset[1];

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
	{
		VideoDebugPrint((0,"VPEMINI: Error in 'NVPStart' >>> exceeded number of extra 422 surfaces \n"));
		return ERROR_INVALID_PARAMETER;
	}

	// get a pointer to the overlay object in VPE context
	pnvOverlay = &(pVPEContext->nvpOverlay);

	// update overlay info: extra 422 surfaces used for prescaling
	pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
	pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
	pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < (int)pCmdObj->dwExtra422NumSurfaces; i++)
	{
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i];	// extra memory space used for prescaling
    }

	// make a cyclic chain with surfaces 
	if (pVPEContext->nNumVidSurf > 0)
	{
		pVPEContext->dwVPState |= NVP_STATE_STARTED_VIDEO;
		(pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
		// kick off VP 
		pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
		// before kicking off the media port, check out VBI setting
		if (pVPEContext->nNumVBISurf > 0)
		{
			pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
			(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
			pVPEContext->nNextVBISurfId = 1;
		}
		// we OR 0x80 to tell function this is not a notifier calling !
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
	}
	else if (pVPEContext->nNumVBISurf > 0)
	{
		pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
		(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
		pVPEContext->nNextVBISurfId = 1;
		// kick off VP 
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVP3Stop

	Description:	Tells the NV video port to stop grabbing. PIO channel 
					version

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVP3Stop(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	NVOS09_PARAMETERS ntfParam;
	U032 i = 0;

	VideoDebugPrint((3,"VPEMINI: NVP3Stop()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// aleady stopped ?!
	if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
		return NO_ERROR;
	else
		pVPEContext->dwVPState = NVP_STATE_STOPPED;

	g_bFlip = FALSE;

	pVPEContext->pNVPChannel = (ULONG) pNVPChannel;	// get a copy of the pio channel pointer
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// tell VP to stop grabbing !
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage = 0;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;


// NO LONGER EXISTS IN OFFICIAL NVOS.H....ASK!!!

//	ntfParam.hObjectParent = pCmdObj->dwDeviceId;


#define NVP_NOTIFY_TIMEOUT 100000
	// wait for the last few notifies to show up...
	while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
	         (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) || 
		   (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   (i < NVP_NOTIFY_TIMEOUT)))
	{
		i++;
		//RmInterrupt(&ntfParam);
	}

	// reset surfaces counters
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->nNumVidSurf = 0;

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPStop

	Description:	Tells the NV video port to stop grabbing

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPStop(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
    Nv03ChannelPio *pOvChannel;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
    NvNotification *pPioFlipOverlayNotifier;
	U032 i;

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // overlay channel
    pOvChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);	// get a pointer to the overlay channel

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3Stop(pHwDevExt, pCmdObj);

	VideoDebugPrint((3,"VPEMINI: NVPStop()\n"));

	// aleady stopped ?!
	if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
		return NO_ERROR;
	else
		pVPEContext->dwVPState = NVP_STATE_STOPPED;

    // channel
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
	nvDmaCount = pVPEContext->nvDmaCount;

	// stop overlay engine
	if (pOvChannel && g_bFlip)
	{
	    g_bFlip = FALSE;

	    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
		pDmaChannel->Put = nvDmaCount << 2;
	    pVPEContext->nvDmaCount = nvDmaCount;

		// reset notifiers
        pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

        i = 0;
        while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
            i++;

        // timed-out... 
        if (i >= NVP_VPP_TIME_OUT)
	        VideoDebugPrint((0,"VPEMINI: waiting for overlay flip notifiers timed-out....\n"));

        pPioFlipOverlayNotifier[1].status = 0;
        pPioFlipOverlayNotifier[2].status = 0;
    }

	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// tell VP to stop grabbing !
	nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
	//if (pCmdObj->dwStopStrm & NVP_STOP_VIDEO)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_IMAGE , 0);
	//if (pCmdObj->dwStopStrm & NVP_STOP_VBI)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_VBI , 0);
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

#define NVP_NOTIFY_TIMEOUT 100000
    i = 0;
	// wait for the last few notifies to show up...
	while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
	         (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) || 
		   (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   (i < NVP_NOTIFY_TIMEOUT)))
	{
		i++;
		//RmInterrupt(&ntfParam);
	}

    // timed-out... 
    if (i >= NVP_NOTIFY_TIMEOUT)
        VideoDebugPrint((0,"VPEMINI: waiting for MediaPort notifiers timed-out....\n"));

	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// reset surfaces counters
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->nNumVidSurf = 0;

    // clear/reset sync event 
	KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPRegSurface

	Description:	register a DDraw surface. Insert in list and update 
					attributes

	Date:			Feb 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPRegSurface(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	BOOL bVideoStarted, bVBIStarted;

	VideoDebugPrint((3,"VPEMINI: NVPRegSurface()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    bVideoStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO);
    bVBIStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI);

	// update attributes of already existing surfaces ?!
	if (pCmdObj->bSurfUpdate)
	{
		// vbi surfaces ?!
		if (pCmdObj->bSurfVBI)
		{
			if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVBISurf)
			{
				pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
				// check for mem offset in framebuffer !
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    pSurface->dwHeight = pCmdObj->dwVBIHeight;
				    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// startline for vbi

				}
				else
				{
					VideoDebugPrint((0,"VPEMINI: can't update VBI surface data !\n"));
					return ERROR_INVALID_PARAMETER;
				}

			}
			else
			{
				// new vbi surfaces
				pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
				(pVPEContext->nNumVBISurf)++;
			    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
			    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
			    pSurface->dwPitch = pCmdObj->dwSurfPitch;
			    pSurface->dwHeight = pCmdObj->dwVBIHeight;
			    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// Programs Y-crop for image, and startline for vbi
			    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
				pSurface->bIsFirstFieldCaptured = FALSE;				// reset value

			}
		}
		else	// video surface
		{
			if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVidSurf)
			{
				//////////
				///// I assume something changing in the following values only !
				pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    pSurface->dwHeight = pCmdObj->dwInHeight;
				    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
				    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// Programs Y-crop for image, and startline for vbi
				    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
				    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
				}
				else
				{
					VideoDebugPrint((0,"VPEMINI: can't update video surface data !\n"));
					return ERROR_INVALID_PARAMETER;
				}
			}
			else
			{
				// new video surfaces
				pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
				(pVPEContext->nNumVidSurf)++;
			    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
			    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
			    pSurface->dwPitch = pCmdObj->dwSurfPitch;
			    pSurface->dwHeight = pCmdObj->dwInHeight;
			    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
			    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// Programs Y-crop for image, and startline for vbi
			    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
			    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
			    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
				pSurface->bIsFirstFieldCaptured = FALSE;				// reset value

			}
		}
	}
	else	// new surfaces !
	{
		if (pVPEContext->dwVPState & NVP_STATE_STARTED)
		{
			VideoDebugPrint((0,"VPEMINI: can't register new DD surfaces while Video Port is running !\n"));
			return ERROR_INVALID_PARAMETER;
		}

		// vbi surfaces ?!
		if (pCmdObj->bSurfVBI)
		{
			pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
			(pVPEContext->nNumVBISurf)++;
		    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// startline for vbi
		}
		else	// video surface
		{
			pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
			(pVPEContext->nNumVidSurf)++;
		    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// startline for video
		}

	    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
	    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
	    pSurface->dwPitch = pCmdObj->dwSurfPitch;
	    pSurface->dwHeight = pCmdObj->dwInHeight;
	    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
	    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
	    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
	    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
		pSurface->bIsFirstFieldCaptured = FALSE;				// reset value
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUpdateOverlay

	Description:	update the overlay info structure

	Date:			Mar 01, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUpdateOverlay(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    Nv03ChannelPio *pChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);	// get a pointer to the overlay channel;
	PNVP_OVERLAY pnvOverlay =  &(pVPEContext->nvpOverlay);
    NvNotification *pPioFlipOverlayNotifier;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
	int i = 0;

	VideoDebugPrint((3,"VPEMINI: NVPUpdateOverlay()\n"));

	if ((pCmdObj->dwOverlayDstWidth != 0) && (pCmdObj->dwOverlayDstHeight != 0))
	{
		// I must rather have a structure memcpy !
		pnvOverlay->dwOverlayFormat = pCmdObj->dwOverlayFormat;
		pnvOverlay->dwOverlaySrcX = pCmdObj->dwOverlaySrcX;
		pnvOverlay->dwOverlaySrcY = pCmdObj->dwOverlaySrcY;
		pnvOverlay->dwOverlaySrcPitch = pCmdObj->dwOverlaySrcPitch;
		pnvOverlay->dwOverlaySrcSize = pCmdObj->dwOverlaySrcSize;
		pnvOverlay->dwOverlaySrcWidth = pCmdObj->dwOverlaySrcWidth;
		pnvOverlay->dwOverlaySrcHeight = pCmdObj->dwOverlaySrcHeight;
		pnvOverlay->dwOverlayDstWidth = pCmdObj->dwOverlayDstWidth;
		pnvOverlay->dwOverlayDstHeight = pCmdObj->dwOverlayDstHeight;
		pnvOverlay->dwOverlayDstX = pCmdObj->dwOverlayDstX;
	    pnvOverlay->dwOverlayDstY = pCmdObj->dwOverlayDstY;
		pnvOverlay->dwOverlayDeltaX = pCmdObj->dwOverlayDeltaX;
		pnvOverlay->dwOverlayDeltaY = pCmdObj->dwOverlayDeltaY;
		pnvOverlay->dwOverlayColorKey = pCmdObj->dwOverlayColorKey;
		pnvOverlay->dwOverlayMode = pCmdObj->dwOverlayMode;
	    pnvOverlay->dwOverlayMaxDownScale = pCmdObj->dwOverlayMaxDownScale;

		VideoDebugPrint((3,"VPEMINI: overlay flipping enabled....\n"));
		g_bFlip = TRUE;
	}
	else
	{
		VideoDebugPrint((3,"VPEMINI: overlay flipping disabled....\n"));
		g_bFlip = FALSE;	// no autoflip !
		// stop overlay engine
		if (pChannel)
		{
		    // channel
			pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
			nvDmaCount = pVPEContext->nvDmaCount;

		    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
			pDmaChannel->Put = nvDmaCount << 2;
		    pVPEContext->nvDmaCount = nvDmaCount;

			// reset notifiers
            pPioFlipOverlayNotifier = (NvNotification *)pnvOverlay->pNvPioFlipOverlayNotifierFlat;

            while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                i++;
            // timed-out... 
            if (i >= NVP_VPP_TIME_OUT)
		        VideoDebugPrint((0,"VPEMINI: waiting for overlay flip notifiers timed-out....\n"));

	        pPioFlipOverlayNotifier[1].status = 0;
            pPioFlipOverlayNotifier[2].status = 0;
		}
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPFlipVideoPort

	Description:	start capturing in specified surface 

	Date:			Mar 01, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPFlipVideoPort(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	NvNotification *avpNotifiers;
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPFlipVideoPort()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// NVP_UNDEF tells us to lookup the surface in list
	if (pCmdObj->dwSurfaceId == NVP_UNDEF)
	{
		for (i = 0; i < pVPEContext->nNumVidSurf; i++)
		{
				//////////
				///// I assume nothing changing in the surfaces values 
				pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    // clear/reset sync event 
					KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
					// found target surface, so update index of video surface we're currently capturing into
					pVPEContext->nVidSurfIdx = i;
					return NO_ERROR;
				}
		}
	}
	else
	{
		// check for weird values !
		if ((pCmdObj->dwSurfaceId >= 0) && 
			(pCmdObj->dwSurfaceId < pVPEContext->nNumVidSurf) && 
			(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId].pVidMem == pCmdObj->pSurfVidMem))
		{
			    // clear/reset sync event 
				KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
				// update index of video surface we're currently capturing into
				pVPEContext->nVidSurfIdx = (int)(pCmdObj->dwSurfaceId);
				return NO_ERROR;
		}
	}

	////// if we got here, it means the target surface wasn't found in list... 
	// so add it at the end of the list  
	i = pVPEContext->nNumVidSurf;
	pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
	(pVPEContext->nNumVidSurf)++;
	pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// startline for video
    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
    pSurface->dwPitch = pCmdObj->dwSurfPitch;
    pSurface->dwHeight = pCmdObj->dwInHeight;
    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
    pSurface->nNextSurfaceIdx = 0;							// the next surface idx in the chain
	pSurface->bIsFirstFieldCaptured = FALSE;				// reset value
    // clear/reset sync event 
	KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
	// flip to surface !
	pVPEContext->nVidSurfIdx = i;							

	return NO_ERROR;
}

/*
==============================================================================
	
	NVP3ProgVideoField

	Description:	programs the vp to capture the specified video field

	Date:			Feb 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVP3ProgVideoField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId,
	U032 dwSurfPitch,
	U032 dwInterleaveOffset,
	BOOL bGrab)
{
	Nv03ChannelPio *pNVPChannel;
	NvNotification *avpNotifiers;
	int nFreeCount;
	NVOS09_PARAMETERS ntfParam;

	pSurface->dwFieldType = (ULONG)nFieldId;

	// get a pointer to the appropriate VPE context
	pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;	// get a copy of the pio channel pointer

#ifdef _NV_DPC
	//CHECK_FREE_COUNT(pNVPChannel,6*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 7*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}			
	pVPEContext->nFreeCount = nFreeCount - (7*4);
#endif

	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	// program the VP to grab in the next surface
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeIn  = (pSurface->dwWidth) | (pSurface->dwHeight << 16);
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeOut = (pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16);

	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = pSurface->dwStartLine;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].offset  = pSurface->dwOffset + dwInterleaveOffset; 

	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].format =
			(dwSurfPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000);
}

/*
==============================================================================
	
	NVP3ProgVBIField

	Description:	programs the vp to capture the specified VBI field.
					PIO channel version.

	Date:			Feb 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVP3ProgVBIField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId)
{
	Nv03ChannelPio *pNVPChannel;
	int nFreeCount;
	NVOS09_PARAMETERS ntfParam;
	NvNotification *avpNotifiers;

	pSurface->dwFieldType = (ULONG)nFieldId;

	// get a pointer to the appropriate VPE context
	pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;	// get a copy of the pio channel pointer

#ifdef _NV_DPC
	//CHECK_FREE_COUNT(pNVPChannel,5*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 5*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}
	pVPEContext->nFreeCount = nFreeCount - (5*4);
#endif
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].size  = (pSurface->dwStartLine) | (pSurface->dwHeight << 16);
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].offset  = pSurface->dwOffset;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].format =
			(pSurface->dwPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);
}

/*
==============================================================================
	
	NVPProgVideoField

	Description:	programs the vp to capture the specified video field

	Date:			Apr 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPProgVideoField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId,
	U032 dwSurfPitch,
	U032 dwInterleaveOffset,
	BOOL bGrab)
{
	Nv4ControlDma *pDmaChannel;
	NvNotification *avpNotifiers;
	U032 dwFormat;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
	{
		NVP3ProgVideoField(pVPEContext, pSurface, nFieldId, dwSurfPitch, dwInterleaveOffset, bGrab);
		return;
	}

	// update type of field we're capturing
	pSurface->dwFieldType = (ULONG)nFieldId;

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(12);

	// reset notifier
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_IN(nFieldId), ((pSurface->dwWidth) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_OUT(nFieldId), ((pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_START_LINE, pSurface->dwStartLine);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_OFFSET(nFieldId), (pSurface->dwOffset + dwInterleaveOffset));
	dwFormat = ((dwSurfPitch & 0xFFFF) |
				((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
				((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000));

	NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;
}

/*
==============================================================================
	
	NVPProgVBIField

	Description:	programs the vp to capture the specified VBI field

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPProgVBIField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId)
{
	Nv4ControlDma *pDmaChannel;
	NvNotification *avpNotifiers;
	U032 dwFormat;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
	{
		NVP3ProgVBIField(pVPEContext, pSurface, nFieldId);
		return;
	}

	// update type of field we're capturing
	pSurface->dwFieldType = (ULONG)nFieldId;

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(8);

	// reset notifier
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_SIZE(nFieldId), ((pSurface->dwStartLine) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_OFFSET(nFieldId), pSurface->dwOffset);
	dwFormat = (pSurface->dwPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);
	NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;
}


/*
==============================================================================
	
	NVPProcessState

	Description:	programs the video port grab in a surface and determines
					which surface is next.

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPProcessState(
	PHW_DEVICE_EXTENSION pHwDevExt,
	int nIndex,
	BOOL bVBIField)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	int nFieldId = nIndex & 1;
	U032 status;
	BOOL bIRQCallback;

	VideoDebugPrint((3,"VPEMINI: NVPProcessState()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[0]);

    // setting nIndex to greater than 1 (nField | any_value) means that the caller is NVPStart or NVPUpdate
	// so first time initialize the dwOverlayIndex to match up with the nFieldId (notifier)
    if ((pVPEContext->nvpOverlay.dwOverlayBufferIndex == NVP_UNDEF) && (nIndex <= 1))
       pVPEContext->nvpOverlay.dwOverlayBufferIndex = nFieldId;

	// calling IRQCallback must be done only at the end of video field or at end of vbi when
	// capturing vbi only 
	bIRQCallback = (!bVBIField) || (pVPEContext->nNumVidSurf == 0);
	// any transfer request of already captured vbi/video data ?!
	if (bIRQCallback)
		NVPCheckForLaunch(pVPEContext, NULL);


	if (pVPEContext->dwVPState != NVP_STATE_STOPPED)
    {
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
	    {
		    // program VBI here. This way VBI is synchronized with the video thus we eliminate the need 
		    // for a seperate VBI notifications routine unless we're streaming VBI only
		    if (!bVBIField)
			{
			    if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
				{
					pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
					// program the VP to grab in the next surface
					NVPProgVBIField(pVPEContext, pSurface, nFieldId);

					// next surface in the chain !
					pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
					pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
				}

				if (pVPEContext->dwVPConFlags & DDVPCONNECT_INTERLACED)
				{
					if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
					{
						if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
						{
							// Bob from interleaved surfaces (skip even/odd included here too)
							DoBobFromInterleaved(pVPEContext, nFieldId);
						}
						else
						{
							// Weave
							DoWeave(pVPEContext, nFieldId);
						}
					}
					else
					{
						// Bob from non-interleaved (separate) surfaces (skip even/odd included here too)
						DoBob(pVPEContext, nFieldId);
					}
				}
				else
				{
					// Progressive 
					DoProgressive(pVPEContext, nFieldId);
				}
			}
		}
        else if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
		{
			pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
			// program the VP to grab in the next surface
			NVPProgVBIField(pVPEContext, pSurface, nFieldId);

			// next surface in the chain !
			pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
			pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
		}
    }

	//
	// calling IRQCallback must be done only at the end of video field or at end of vbi when
	// capturing vbi only 
	if (bIRQCallback)
	{
		// can we pass on the interrupt !
		if ((pHwDevExt->IRQCallback) && (pHwDevExt->dwIRQSources & DDIRQ_VPORT0_VSYNC))
		{
			PDX_IRQDATA pIRQData;
			pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
			pIRQData->dwIrqFlags |= DDIRQ_VPORT0_VSYNC;
			((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
		}
	}

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPEProcessCommand

	Description:	dispatches commands sent via IOCTL to the appropriate 
					NVP function

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPEProcessCommand(
    PVOID pHwDeviceExtension,
    PVIDEO_REQUEST_PACKET pRequestPacket)
{
	U032 status = 0;
	NVP_CMD_OBJECT *pnvCmdObj;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	VideoDebugPrint((3,"VPEMINI: NVPEProcessCommand()\n"));

	pnvCmdObj = (NVP_CMD_OBJECT *)(pRequestPacket->InputBuffer);
	// some arguments validation
	if ((pnvCmdObj->dwPortId < 0) || (pnvCmdObj->dwPortId >= NVP_MAX_VPORTS)) 
		return ERROR_INVALID_PARAMETER;

	// dispatch call
	switch (pnvCmdObj->dwSrvId)
	{
		case NVP_SRV_INITIALIZE:
			status = NVPInitialize(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UNINITIALIZE:
			status = NVPUninitialize(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_START_VIDEO:
			status = NVPStart(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_STOP_VIDEO:
			status = NVPStop(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UPDATE_VIDEO:
			status = NVPUpdate(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_REG_SURFACE:
			status = NVPRegSurface(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UPDATE_OVERLAY:
			status = NVPUpdateOverlay(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_FLIP_VIDEOPORT:
			status = NVPFlipVideoPort(pHwDevExt, pnvCmdObj);
			break;
		default:
			VideoDebugPrint((0,"VPEMINI: invalid VPE command !\n"));
			return ERROR_INVALID_PARAMETER;
	}

	return status;
}

/*
==============================================================================
	
	VideoField0Notify

	Description:	callback function. Called after a video buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VideoField0Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 0, FALSE);
}

/*
==============================================================================
	
	VideoField1Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VideoField1Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 1, FALSE);
}


/*
==============================================================================
	
	VBIField0Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VBIField0Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 0, TRUE);
}

/*
==============================================================================
	
	VBIField1Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VBIField1Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 1, TRUE);
}


/*
==============================================================================
	
	NVPScheduleOverlayFlip

	Description:	program overlay object to flip surface

	Date:			Feb 25, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPScheduleOverlayFlip(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int  nImageId,
	U032 dwSrcPitch,
	U032 dwMoveDownOffset)
{
	NVP_OVERLAY ovOverlayInfo;
	Nv03ChannelPio *pOvrChannel;
	U032 dwFlags = 0;
	U032 dwSubChn;
	U032 dwSrcDeltaY;
	U032 dwSrcOffset;

	if (!g_bFlip)
		return NO_ERROR;

	VideoDebugPrint((3,"VPEMINI: NVPScheduleOverlayFlip()\n"));


	dwFlags = VPP_PRESCALE;

	if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
	   dwFlags |= VPP_INTERLEAVED;
	else 
	   dwFlags |= VPP_BOB;

	if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
	   dwFlags |= VPP_BOB;

    if (nImageId == NVP_FIELD_ODD)
	   dwFlags |= VPP_ODD;
	else if (nImageId == NVP_FIELD_EVEN)
	   dwFlags |= VPP_EVEN;
    
    NVPPrescaleAndFlip(
	    pVPEContext, 
	    &(pVPEContext->nvpOverlay), 
	    pSurface->dwOffset, 
	    pSurface->dwPitch, // source pitch
        nImageId,
        dwFlags);          // VPP flags

	return NO_ERROR;
}


/*
==============================================================================
	
	DoProgressive

	Description:	displays progressive video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoProgressive(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;

	dwSrcPitch = pSurface->dwPitch;

	// Overlay Image n from CS
	NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, 0);

	pVPEContext->nVidSurfIdx = nTargetSurfId;

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoWeave

	Description:	use weave method to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoWeave(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch, dwOffset = 0;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	// if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;
	// double pitch (interleaved data)
	dwSrcPitch = 2*(pSurface->dwPitch);

	if (nFieldId == NVP_FIELD_ODD)
	{
		// Invert Polarity ?!
		if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
		{
			// change vp grab offset one line down
			dwOffset = pSurface->dwPitch;
			// Shift Down Image destination by 1 line !
			/////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
			//dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
		}
	}
	else
	{
		// not Invert Polarity ?!
		if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
		{
			// offset vp grab one line down
			dwOffset = pSurface->dwPitch;

			// Shift Down Image destination by 1 line !
			/////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
			//dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
		}
	}

	// whole frame captured ?!
	if (pSurface->bIsFirstFieldCaptured)
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, NVP_UNDEF, pSurface->dwPitch, 0);
		// NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);

		pSurface->bIsFirstFieldCaptured = FALSE;	// reset flag (for the next time)

		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
	}
	else
		pSurface->bIsFirstFieldCaptured = TRUE;	// set flag (for the next time)

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoBobFromInterleaved

	Description:	use bob from interleaved input to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoBobFromInterleaved(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch, dwOffset = 0;
	int nImage = nFieldId;

	// Current Surface (CS)
	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	// NewPitch = OldPitch
	dwSrcPitch = pSurface->dwPitch;	// interleaved
	// if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;

#if 0
	if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
	{
		if (nFieldId == NVP_FIELD_EVEN)
		{
			// VP minimum programming to issue an interrupt at end of field !
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
			return NO_ERROR;
		}
	}
	else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
	{
		if (nFieldId == NVP_FIELD_ODD)
		{
			// VP minimum programming to issue an interrupt at end of field !
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
			return NO_ERROR;
		}
	}
	else
#endif
	{
		// double pitch (interleaved data)
		dwSrcPitch = 2*dwSrcPitch;
		if (nFieldId == NVP_FIELD_ODD)
		{
			// Invert Polarity ?!
			if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
			{
				// change vp grab offset one line down
				dwOffset = pSurface->dwPitch;
			}
		}
		else
		{
			// Invert Polarity ?!
			// for the even field (bottom) shift down overlay destination if invert polarity flag is not set !
			if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
			{
				dwOffset = pSurface->dwPitch;

			}
		}

	}

	if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
		!((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, dwOffset);
		// NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);
	}

	// whole frame captured ?!
	if (pSurface->bIsFirstFieldCaptured)
	{
		pSurface->bIsFirstFieldCaptured = FALSE;	// reset (for the next time)
		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
	}
	else
		pSurface->bIsFirstFieldCaptured = TRUE;	// for the next time

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoBob

	Description:	use bob from non-interleaved input to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoBob(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	dwSrcPitch = pSurface->dwPitch;
#if 0
	if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
	{
		if (nFieldId == NVP_FIELD_EVEN)
		{
			// VP minimum programming to issue an interrupt at end of field !
			// TS = next2(CS)
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
			pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
			return NO_ERROR;
		}
		else
			// TS = next(CS)
			nTargetSurfId = pSurface->nNextSurfaceIdx;
	}
	else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
	{
		if (nFieldId == NVP_FIELD_ODD)
		{
			// VP minimum programming to issue an interrupt at end of field !
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
			pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
			return NO_ERROR;
		}
		else
			// TS = next(CS)
			nTargetSurfId = pSurface->nNextSurfaceIdx;
	}
	else
#endif
	{
		// if autoflip, TS = next2(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
	}

	if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
		!((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, 0);
	}

	// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPTransfer

	Description:	transfers content of video or vbi field to specified
					buffer (usually system memory buffer)

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPTransfer(
	PVOID pContext, 
	PDDTRANSFERININFO pInInfo, 
	PDDTRANSFEROUTINFO pOutInfo)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_TRANSFER_BUFFER pTransfer;
	PNVP_SURFACE_INFO pSurface = NULL;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;
	BOOL bVal;
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPTransfer()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	if (pInInfo->dwTransferFlags & DDTRANSFER_NONLOCALVIDMEM)
		return DXERR_UNSUPPORTED;
	
	// we DO handle cancels for transfer buffers not "in progress" !
	if (pInInfo->dwTransferFlags & DDTRANSFER_CANCEL)
		return NVPCancelTransfer(pVPEContext, pInInfo);

	// determine polarity, TRUE for Even, FALSE for Odd !
	NVPGetSurface(pVPEContext, ((DDSURFACEDATA*) pInInfo->lpSurfaceData)->dwSurfaceOffset, &pSurface);
	if ((pSurface != NULL) && (pSurface->dwFieldType == NVP_FIELD_ODD))
		pOutInfo->dwBufferPolarity = FALSE;
	else
		pOutInfo->dwBufferPolarity = TRUE;
	
	// queue request
	if (NVPAddTransfer(pVPEContext, pInInfo, !(pOutInfo->dwBufferPolarity)))
		return DXERR_GENERIC;

	if (pVPEContext->nCurTransferIdx != -1)
	{
		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
		// Recreate context dma for MDL
		NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
	}

	return DX_OK;
}

/*
==============================================================================
	
	NVPGetSurface

	Description:	looks for surface that has the specified offset. pSurface
					is set to NULL if no surface is found.


	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
BOOL NVPGetSurface(
	PNVP_CONTEXT pVPEContext,
	U032 dwSurfOffset,
	PNVP_SURFACE_INFO *pSurface)
{
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPGetSurface()\n"));

	*pSurface = NULL;

	// why VBI first ! well, this is most probably what we're transfering... kinda optimization !
	for (i = 0; i < pVPEContext->nNumVBISurf; i++)
	{
		if (pVPEContext->aVBISurfaceInfo[i].dwOffset == dwSurfOffset)
		{
			*pSurface = &(pVPEContext->aVBISurfaceInfo[i]);
			return FALSE;	// FALSE means VBI
		}
	}

	for (i = 0; i < pVPEContext->nNumVidSurf; i++)
	{
		if (pVPEContext->aVideoSurfaceInfo[i].dwOffset == dwSurfOffset)
		{
			*pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
			return TRUE;	// TRUE means VIDEO
		}
	}

	return FALSE;	// return something ! (pSurface is NULL anyway)
}

/*
==============================================================================
	
	NVP3RecreateContext

	Description:	if necessary, create context DMA for mem to mem object
					PIO channel version.

	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVP3RecreateContext(
	PNVP_CONTEXT pVPEContext,
	PMDL pDestMDL) 
{
	Nv03ChannelPio *pChan;
	NVOS09_PARAMETERS ntfParam;
	U032 dwStart;
	U032 dwLimit;
	int nFreeCount;

	pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);

	// first check to see if we can reuse the OLD context... since context creation is expensive.
	dwStart = (U032)(pDestMDL->lpMappedSystemVa);
	dwLimit = (pDestMDL->ByteCount) - 1;
	
	if (pVPEContext->bxfContextCreated)
	{
		// do not recreate if same context
		if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
			return DX_OK;
	}

#ifdef _NV_DPC
	// FIFO free count check up
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 4*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (4*4);
#endif

	// free the old context first
	if (pVPEContext->bxfContextCreated)
	{
		pChan->subchannel[5].SetObject = NVP_M2M_OBJECT;
		pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#ifdef _NV_DPC
		// Do a software method flush here
		ntfParam.hObjectParent = pVPEContext->dwDeviceId;
		nFreeCount = pVPEContext->nFreeCount;
		while (nFreeCount < NV06A_FIFO_GUARANTEED_SIZE) 
		{
			//RmInterrupt(&ntfParam);
			nFreeCount = NvGetFreeCount(pChan, 5);
		}
		pVPEContext->nFreeCount = nFreeCount - NV06A_FIFO_GUARANTEED_SIZE;
#endif
		RmFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

		pVPEContext->bxfContextCreated = FALSE;
	}
	
	// setup Notify Context
	if (RmAllocContextDma(
					pVPEContext->hClient,
	         		NVP_M2M_CONTEXT,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		dwStart,
	         		dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate mem 2 mem context\n"));
		return DXERR_GENERIC;
	}

	// set context of M2M object
	pChan->subchannel[5].SetObject  = NVP_M2M_OBJECT;
	pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = NVP_M2M_CONTEXT;

	pVPEContext->dwTransferCtxStart = dwStart;
	pVPEContext->dwTransferCtxSize = dwLimit;
	pVPEContext->bxfContextCreated = TRUE;

	return DX_OK;
}

/*
==============================================================================
	
	NVP3CheckForLaunch

	Description:	try to launch another mem transfer if engine not busy
					(PIO version)

	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVP3CheckForLaunch(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface)
{
	Nv03ChannelPio *pChan;
	PNVP_TRANSFER_BUFFER pTransfer;
	LPDDSURFACEDATA pSurfaceData;
	NVOS09_PARAMETERS ntfParam;
	NvNotification *aM2MNotifiers;
	PMDL pDestMDL;
	U032 dwOffsetStartByte;
	LONG lLength, lPitch, lCount;
	int nFreeCount;
	PNVP_SURFACE_INFO pSurf = NULL;

	VideoDebugPrint((3,"VPEMINI: NVP3CheckForLaunch()\n"));

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	// is transfer in progress ?
	if ((aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS) ||
		// or no transfer request !?
		(pVPEContext->nCurTransferIdx == -1))
		return DXERR_GENERIC;

	// get a pointer to the VP pio channel
	pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);
	// which surface are we transferring from ?
	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
	pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
	if (pSurface == NULL)
	{
		NVPGetSurface(pVPEContext, pSurfaceData->dwSurfaceOffset, &pSurf);
		if (pSurf == NULL)
		{
			VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() can't get pointer to surface\n"));
			return DXERR_GENERIC;
		}
	}
	else
		pSurf = pSurface;

	// Recreate context dma for MDL
	NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
	
	// reset notifier status
	aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

#ifdef _NV_DPC
	//CHECKFREECOUNT(pMyNvChan,9*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 9*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (9*4);
#endif

	// start at given line
	dwOffsetStartByte = pSurfaceData->dwSurfaceOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

	// lLength and lPitch might not be the same (case of interleaved fields !!!)
	lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
	lPitch = pSurfaceData->lPitch;
			
	// SMAC@microsoft.com  :  Yes, you should transfer the end line.  
	// Therefore, if we only wanted you to transfer a single line, start line would equal end line.	
	lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);
	if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
	{
		// if we want to invert things, then we should 
		// negate the pitch and put the start offset at the end.
		
		dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
		lPitch = -lPitch;
	}

	pDestMDL = (PMDL)(pTransfer->pDestMDL);
	if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
	{ 
		VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count\n"));
	//	lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
		lCount = pDestMDL->ByteCount / lLength;
	}

#ifdef _NV_DPC
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 8*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (8*4);
#endif

	// set mem to mem transfer object !
	pChan->subchannel[NVP_M2M_SUBCHANNEL].SetObject = NVP_M2M_OBJECT;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetIn	= dwOffsetStartByte;
	//pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = 0;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchIn	= lPitch;	// use the pitch in so that we can do interleaved
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchOut	= lLength;  // use line length on pitch out so that it squishes together
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineLengthIn = lLength; 
	
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineCount 	= lCount;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.Format 		=  ( 1 | (1 << 8));
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.BufferNotify = NV039_NOTIFY_WRITE_THEN_AWAKEN_1;

	pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;

	return DX_OK;
}

/*
==============================================================================
	
	NVPRecreateContext

	Description:	if necessary, create context DMA for mem to mem object
					(DMA version)

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPRecreateContext(
	PNVP_CONTEXT pVPEContext,
	PMDL pDestMDL) 
{
	U032 dwStart;
	U032 dwLimit;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3RecreateContext(pVPEContext, pDestMDL);

	// first check to see if we can reuse the OLD context... since context creation is expensive.
	dwStart = (U032)(pDestMDL->lpMappedSystemVa);
	dwLimit = (pDestMDL->ByteCount) - 1;
	
	if (pVPEContext->bxfContextCreated)
	{
		// do not recreate if same context
		if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
			return DX_OK;
	}

	// free the old context first
	if (pVPEContext->bxfContextCreated)
	{
		// free m2m dma context
		RmFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

		pVPEContext->bxfContextCreated = FALSE;
	}
	
	// setup Notify Context
	if (RmAllocContextDma(
					pVPEContext->hClient,
	         		NVP_M2M_CONTEXT,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		dwStart,
	         		dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate mem 2 mem context\n"));
		return DXERR_GENERIC;
	}

	pVPEContext->dwTransferCtxStart = dwStart;
	pVPEContext->dwTransferCtxSize = dwLimit;
	pVPEContext->bxfContextFlushed = FALSE;
	pVPEContext->bxfContextCreated = TRUE;

	return DX_OK;
}

/*
==============================================================================
	
	NVPCheckForLaunch

	Description:	try to launch another mem transfer if engine not busy
					(DMA version)

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCheckForLaunch(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface)
{
	PNVP_TRANSFER_BUFFER pTransfer;
	LPDDSURFACEDATA pSurfaceData;
	NvNotification *aM2MNotifiers;
	PMDL pDestMDL;
	U032 dwOffsetStartByte;
	LONG lLength, lPitch, lCount;
	PNVP_SURFACE_INFO pSurf = NULL;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3CheckForLaunch(pVPEContext, pSurface);

//	VideoDebugPrint((3,"VPEMINI: NVPCheckForLaunch()\n"));

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	// is transfer in progress ?
	if (aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
		return DXERR_GENERIC;

	// or no transfer request !?
	if ((pVPEContext->nCurTransferIdx == -1) || !(pVPEContext->bxfContextCreated))
	{
		return DXERR_GENERIC;
	}

	// which surface are we transferring from ?
	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
	pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
	if (pSurface == NULL)
	{
		NVPGetSurface(pVPEContext, pSurfaceData->dwSurfaceOffset, &pSurf);
		if (pSurf == NULL)
		{
			VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() can't get pointer to surface\n"));
			return DXERR_GENERIC;
		}
	}
	else
		pSurf = pSurface;

	// reset notifier status
	aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

	// start at given line
	dwOffsetStartByte = pSurfaceData->dwSurfaceOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

	// lLength and lPitch might not be the same (case of interleaved fields !!!)
	lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
	lPitch = pSurfaceData->lPitch;
			
	// SMAC@microsoft.com  :  Yes, you should transfer the end line.  
	// Therefore, if we only wanted you to transfer a single line, start line would equal end line.	
	lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);
	if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
	{
		// if we want to invert things, then we should 
		// negate the pitch and put the start offset at the end.
		
		dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
		lPitch = -lPitch;
	}

	pDestMDL = (PMDL)(pTransfer->pDestMDL);
	if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
	{ 
		VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count\n"));
	//	lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
		lCount = pDestMDL->ByteCount / lLength;
	}

	// get a pointer to the VPE dma channel
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(20);

	NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
	NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_OUT, NVP_M2M_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_IN, dwOffsetStartByte);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_OUT, 0);	//(unsigned long)pTransfer->DestMDL->ByteOffset
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_IN, lPitch);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_OUT, lLength);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_LENGTH_IN, lLength);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_COUNT, lCount);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_FORMAT, ( 1 | (1 << 8)));
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_BUFFER_NOTIFY, NV039_NOTIFY_WRITE_THEN_AWAKEN_1);

	pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;
	// go !
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

	return DX_OK;
}


/*
==============================================================================
	
	NVPGetTransferStatus

	Description:	returns status of buffer transfer (from video mem to 
					system mem)

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPGetTransferStatus(
	PVOID pContext, 
	PVOID pNotUsed, 
	PDDGETTRANSFEROUTINFO pOutInfo)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;
	PNVP_TRANSFER_BUFFER pTransfer;
	PNVP_CONTEXT pVPEContext;

//	VideoDebugPrint((3,"VPEMINI: NVPGetTransferStatus()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	if (pVPEContext->nRecentTransferIdx == NVP_EOQ)
		return DXERR_GENERIC;

	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nRecentTransferIdx]);

	if (pTransfer->dwTransferStatus == NVP_TRANSFER_DONE)
	{
		// return MS transfer ID
		pOutInfo->dwTransferID = pTransfer->dwTransferId;
		NVPRemoveTransfer(pVPEContext, pVPEContext->nRecentTransferIdx);

	}
	else 
		return DXERR_GENERIC;

	return DX_OK;
}

/*
==============================================================================
	
	NVPAddTransfer

	Description:	adds transfer buffer to queue

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPAddTransfer(
	PNVP_CONTEXT pVPEContext,
	PDDTRANSFERININFO pInInfo,
	BOOL bIsOddField)
{
	PNVP_TRANSFER_BUFFER pNewTransfer;
	int i = pVPEContext->nCurTransferIdx;

	VideoDebugPrint((3,"VPEMINI: NVPAddTransfer()\n"));

	if (pVPEContext->nNumTransfer >= NVP_MAX_TRANSFER_BUFFERS)
		return DXERR_GENERIC;
	
	while (i != NVP_EOQ)
	{
		if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
			// a transfer request with same ID is already queued !!!
			return DXERR_GENERIC;
		else 
			i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
	}

		
	// queue new transfer request !
	i = pVPEContext->nLastTransferIdx;
	pVPEContext->nLastTransferIdx = ++(pVPEContext->nLastTransferIdx) % NVP_MAX_TRANSFER_BUFFERS;
	pNewTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nLastTransferIdx]);
	if (i != NVP_EOQ)
		pVPEContext->aTransferBuffers[i].nNextTransferIdx = pVPEContext->nLastTransferIdx;
	pNewTransfer->nNextTransferIdx = NVP_EOQ;
	pNewTransfer->nPrevTransferIdx = i;
	(pVPEContext->nNumTransfer)++;
	if (pVPEContext->nCurTransferIdx == NVP_EOQ)
		pVPEContext->nCurTransferIdx = pVPEContext->nLastTransferIdx;

    // DDTRANSFER_HALFLINES indicates that, due to half line issues, the odd field contains an 
    // extra line of useless data at the top that the driver must account for
	if ((pInInfo->dwTransferFlags & DDTRANSFER_HALFLINES) && (bIsOddField))
	{
		pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine) + 1;
		pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine) + 1;
	} 
	else 
	{
		pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine);
		pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine);
	}

	// copy input data...
	pNewTransfer->pSurfaceData = (ULONG) (pInInfo->lpSurfaceData);
	pNewTransfer->dwTransferId = pInInfo->dwTransferID;
	pNewTransfer->dwTransferFlags = pInInfo->dwTransferFlags;
	pNewTransfer->pDestMDL = (ULONG) (pInInfo->lpDestMDL);
	pNewTransfer->dwTransferStatus = NVP_TRANSFER_QUEUED;

	return DX_OK;
}


/*
==============================================================================
	
	NVPCancelTransfer

	Description:	cancels transfer request before it gets processed 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCancelTransfer(
	PNVP_CONTEXT pVPEContext,
	PDDTRANSFERININFO pInInfo)
{
	PNVP_TRANSFER_BUFFER pTransfer = NULL;
	int i = pVPEContext->nCurTransferIdx;

	VideoDebugPrint((3,"VPEMINI: NVPCancelTransfer()\n"));

	// look for transfer in queue
	while (i != NVP_EOQ)
	{
		if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
		{
			pTransfer = &(pVPEContext->aTransferBuffers[i]);
			break;
		}
		i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
	}

	if ((pTransfer) && (pTransfer->dwTransferStatus == NVP_TRANSFER_QUEUED))
		return NVPRemoveTransfer(pVPEContext, i);
	else
		return DXERR_GENERIC;
}

/*
==============================================================================
	
	NVPRemoveTransfer

	Description:	removes transfer request from queue

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPRemoveTransfer(
	PNVP_CONTEXT pVPEContext,
	int nTransferIdx)
{
	PNVP_TRANSFER_BUFFER pTransfer = &(pVPEContext->aTransferBuffers[nTransferIdx]);

	VideoDebugPrint((3,"VPEMINI: NVPRemoveTransfer()\n"));

	// check limits
	if (nTransferIdx == pVPEContext->nCurTransferIdx)
		pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;
	else if (nTransferIdx == pVPEContext->nLastTransferIdx)
		pVPEContext->nLastTransferIdx = pTransfer->nPrevTransferIdx;
	// reset values
	pTransfer->dwTransferId = NVP_UNDEF;
	pTransfer->dwTransferStatus = NVP_TRANSFER_FREE;
	// re-map indices
	if (pTransfer->nPrevTransferIdx != NVP_EOQ)
	{
		pVPEContext->aTransferBuffers[pTransfer->nPrevTransferIdx].nNextTransferIdx = pTransfer->nNextTransferIdx;
		pTransfer->nPrevTransferIdx = NVP_EOQ;
	}
	if (pTransfer->nNextTransferIdx != NVP_EOQ)
	{
		pVPEContext->aTransferBuffers[pTransfer->nNextTransferIdx].nPrevTransferIdx = pTransfer->nPrevTransferIdx;
		pTransfer->nNextTransferIdx = NVP_EOQ;
	}

	// one down !
	(pVPEContext->nNumTransfer)--;

	return DX_OK;
}
	

/*
==============================================================================
	
	NVPCheckTransferStatus

	Description:	checks for transfer status. Calls MS callback. 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCheckTransferStatus(
	PHW_DEVICE_EXTENSION pHwDevExt)
{
	NvNotification *aM2MNotifiers;
	PNVP_CONTEXT pVPEContext;
	PDX_IRQDATA pIRQData;
	PNVP_TRANSFER_BUFFER pTransfer;
	U032 status;

	VideoDebugPrint((3,"VPEMINI: NVPCheckTransferStatus()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	status = aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status;
	
	if (status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
		// still in progress
		return FALSE;
	else if (status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS)
	{
		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

		// finished ok!
		if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
			pTransfer->dwTransferStatus = NVP_TRANSFER_DONE;

		pVPEContext->nRecentTransferIdx = pVPEContext->nCurTransferIdx;
	} 
	else
	{
		VideoDebugPrint((0,"VPEMINI: NVPCheckTransferStatus() - memory transfer failed error %d\n", status));

		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

		// finished with an error !
		if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
			pTransfer->dwTransferStatus = NVP_TRANSFER_FAILURE;

	}

	// move to next transfer in queue (*** not sure whether I should do this even when an error had occured ?!?!?!?)
	pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;

	// we pass on the interrupt
	if (pHwDevExt->IRQCallback) //&& (pHwDevExt->dwIRQSources & DDIRQ_BUSMASTER))
	{
		pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
		pIRQData->dwIrqFlags |= DDIRQ_BUSMASTER;
		((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
	}
	
	return DX_OK;
}

/*
==============================================================================
	
	NVPTransferNotify

	Description:	checks for transfer status. Calls MS callback. 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPTransferNotify(
	PVOID pHwDevExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) pHwDevExtension;
	PNVP_CONTEXT pVPEContext;

	// call MS callback if done with transfer
	if (NVPCheckTransferStatus(pHwDevExt) == DX_OK)
	{
		// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
		pVPEContext = &(pHwDevExt->avpContexts[0]);
		//  transfer next in queue !
//		NVPCheckForLaunch(pVPEContext, NULL);
	}
}




//---------------------------------------------------------------------------
// vddPreScale
//      Prescales YUV422 surface.  The new width and height are returned.  If
//      this routine does the field prescaling, it flips off the field flags
//      to indicate that the flip should not bob.
//

BOOL NVPPreScale(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwSrcOffset, 
    DWORD         dwSrcPitch,
    DWORD         dwDstOffset, 
    DWORD         dwDstPitch,
    DWORD         *pWidth, 
    DWORD         *pHeight,
    DWORD         *pField)
{
    DWORD preScaleDeltaX;
    DWORD preScaleDeltaY;
    DWORD preScaleOverlay;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwOutSizeX, dwOutSizeY, dwOutFormat;
    DWORD dwInPitch, dwInOffset, dwInPoint, dwInSize;
    BOOL isField;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

    if (pOverlayInfo->dwOverlayDstWidth == 0 ||
        pOverlayInfo->dwOverlayDstHeight == 0)
        return FALSE;

    isField = IS_FIELD(*pField);

    if (pOverlayInfo->dwOverlayDstWidth <= 1) 
    {
        dwDeltaX = 0x100000;
	}
	else
	{
	    dwDeltaX = (pOverlayInfo->dwOverlaySrcWidth - 1) << 16;
	    dwDeltaX /= pOverlayInfo->dwOverlayDstWidth - 1;
	    dwDeltaX <<= 4;
	}

    if (pOverlayInfo->dwOverlayDstHeight <= 1) 
    {
        dwDeltaY = 0x100000;
	}
	else
	{
	    dwDeltaY = (pOverlayInfo->dwOverlaySrcHeight - 1) << 16; //(*pHeight - 1) << 16; //
	    // err on the side of caution, need to do this because of the 1/4 pixel offset
	    // ????? why is NV4 different from NV5?  NV4 HW must be a little wonky
	    if (pVPEContext->dwChipId <= NV_DEVICE_VERSION_4) {
	        dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 2;
	    } else {
	        dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 1;
	    }
	    dwDeltaY <<= 4;
    }

    preScaleOverlay = 0;

    if (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale)) 
    {
        // use X prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = (pOverlayInfo->dwOverlayDstWidth + 2) & ~1;
        preScaleDeltaX = dwDeltaX;
        pOverlayInfo->dwOverlayDeltaX = 0x100000;
    } else {
        // use X overlay scaler
        dwOutSizeX = (*pWidth + 2) & ~1;
        preScaleDeltaX = 0x100000;
        pOverlayInfo->dwOverlayDeltaX = dwDeltaX;
    }

    if (pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale))
	{
        // use Y prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = pOverlayInfo->dwOverlayDstHeight;
        preScaleDeltaY = dwDeltaY;
        pOverlayInfo->dwOverlayDeltaY = 0x100000;
    } 
    else 
    {
        // use Y overlay scaler
        dwOutSizeY = *pHeight;
        preScaleDeltaY = 0x100000;
        pOverlayInfo->dwOverlayDeltaY = dwDeltaY;
    }

    if ((pVPEContext->dwChipId < NV_DEVICE_VERSION_10) || (preScaleOverlay & NV_PRESCALE_OVERLAY_Y)) 
    {
        if (isField) 
        {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            if (*pField & VPP_INTERLEAVED)
                preScaleDeltaY >>= 1;
        }
    }

    if (preScaleOverlay == 0)
        return FALSE;

    dwInSize = asmMergeCoords(*pWidth, *pHeight);
    dwInPoint = 0;
    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField && (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        if (*pField & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            *pHeight >>= 1;
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (*pField & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInPoint = 0xFFFC0000;
            } else {
                dwInPoint = 0x00040000;
            }
        }
    }

//    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
//    } else {
//        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
//    }

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(38);

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT , NVP_DVD_SUBPICTURE_OBJECT); // pVPEContext->dwDVDSubPicObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_POINT, 0);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_SIZE, (asmMergeCoords(dwOutSizeX, dwOutSizeY)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_FORMAT, ((dwOutFormat << 16) | dwDstPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_OFFSET, dwDstOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_FORMAT, ((dwOutFormat << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_POINT, dwInPoint);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_FORMAT, ((NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_POINT, 0);

    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NOTIFY, NV038_NOTIFY_WRITE_THEN_AWAKEN);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NO_OPERATION, 0);

    // this forces the H/W to serialize
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

    // return changes in state
    if (//(pDriverData->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
        (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        // with HQVUp, we no longer use the overlay to bob
        *pField &= ~(VPP_ODD | VPP_EVEN | VPP_BOB | VPP_INTERLEAVED);
    }

    *pHeight = dwOutSizeY;
    *pWidth  = dwOutSizeX;

    return TRUE;
}

//---------------------------------------------------------------------------
// vddFlip
//      Flip to surface.
//

BOOL NVPFlip(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset 
    DWORD         dwPitch,         // source pitch
	DWORD         dwWidth,         // source width
	DWORD         dwHeight,        // source height
    DWORD         dwIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;
    DWORD dwPointIn, dwOverlayFormat, dwSizeIn;
    DWORD dwDeltaX, dwDeltaY;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;  // << 3 insteed of << 4 because YUYV is 2 bytes wide
    dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));
    dwSizeIn += dwPointIn;
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    // Remember this in case we get a SetOverlayPosition call
    //pOverlayInfo->dwOverlaySrcOffset = dwOffset;
    //pOverlayInfo->dwOverlaySrcPitch = dwPitch;

    dwDeltaX = pOverlayInfo->dwOverlayDeltaX;
    dwDeltaY = pOverlayInfo->dwOverlayDeltaY;

    if (IS_FIELD(dwFlags)) {
        if (dwFlags & VPP_INTERLEAVED) {
            // if (dwFlags & VPP_ODD) { 
            if (dwFlags & VPP_EVEN) {
                dwOffset += dwPitch;
            }
            dwPitch <<= 1;
            dwHeight >>= 1;
            dwDeltaY >>= 1;
        }
        if (dwFlags & VPP_BOB) {
            // if (dwFlags & VPP_ODD) {
            if (dwFlags & VPP_EVEN) {
                dwPointIn += 0xFFFC0000;
            } else {
                dwPointIn += 0x00040000;
            }
        }
    }

    // replace old surface pitch value with current pitch value
    dwOverlayFormat = pOverlayInfo->dwOverlayFormat;
    dwOverlayFormat &= 0xFFFF0000;
    dwOverlayFormat |= dwPitch;
    dwOverlayFormat |= (1 << 31);

/*

    if (pVPEContext->dwVPConnectFlags & NVP_CONNECT_HDTV) // progressive (non-interlaced) and 16bit VIP
        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT709 << 24);
*/
    if (dwIndex & 0x1) {
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;
    } else {
        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
    }

	// program overlay to flip
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(20);

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_IN(dwIndex), dwSizeIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstWidth, pOverlayInfo->dwOverlayDstHeight)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_IN(dwIndex), dwPointIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstX, pOverlayInfo->dwOverlayDstY)));

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_OFFSET(dwIndex), dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_COLORKEY(dwIndex), pOverlayInfo->dwOverlayColorKey);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DU_DX(dwIndex), dwDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DV_DY(dwIndex), dwDeltaY);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_FORMAT(dwIndex), dwOverlayFormat);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

    return TRUE;
}

//---------------------------------------------------------------------------
// vddPrescaleAndFlip
//
//      VPE implementation of selected parts of DDRAW's VPP pipe.  Only 
//      prescaling and flip are performed.
//

#define NEXT_SURFACE { \
            dwSrcOffset = dwDstOffset;  \
            dwSrcPitch = dwDstPitch;    \
            dwDstOffset = dwNextOffset; \
            dwDstPitch = dwNextPitch;   \
            dwNextOffset = dwSrcOffset; \
            dwNextPitch = dwSrcPitch;   \
            dwOpCount++;                \
        }

#define NV_WIN_DEVICE    0x00002002

BOOL NVPPrescaleAndFlip(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset 
    DWORD         dwPitch,         // source pitch
    DWORD         dwOvIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
	DWORD dwHeight, dwWidth, i = 0;
    DWORD dwSrcOffset, dwSrcPitch;
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwNextOffset, dwNextPitch;
    DWORD dwOpCount;
    DWORD dwWorkSurfaces;
    BOOL  doXPreScale, doYPreScale, doPreScale;
    BOOL  isDownScale;
    DWORD dwRoundX, dwRoundY;
    DWORD vppExec;
    BOOL  isField;
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;


#if 0 //#ifdef DEBUG
    char debugstr[256];

    debugstr[0] = '\0';
    if (dwFlags & VPP_ODD)          strcat(debugstr, "odd  ");
    if (dwFlags & VPP_EVEN)         strcat(debugstr, "even ");
    if (dwFlags & VPP_BOB)          strcat(debugstr, "bob ");
    if (dwFlags & VPP_INTERLEAVED)  strcat(debugstr, "int ");
    if (dwFlags & VPP_VIDEOPORT)    strcat(debugstr, "vp ");
    if (dwFlags & VPP_WAIT)         strcat(debugstr, "wait ");
    if (dwFlags & VPP_OPTIMIZEFLIP) strcat(debugstr, "opt ");
    strcat(debugstr, "REQ: ");
    if (dwFlags & VPP_CONVERT)      strcat(debugstr, "cvt ");
    if (dwFlags & VPP_SUBPICTURE)   strcat(debugstr, "sp ");
    if (dwFlags & VPP_PRESCALE)     strcat(debugstr, "ps ");
    if (dwFlags & VPP_COLOURCONTROL) strcat(debugstr, "cc ");
    if (dwFlags & VPP_TEMPORAL)     strcat(debugstr, "tf ");
    if (dwFlags & VPP_DEINTERLACE)  strcat(debugstr, "df ");
#endif

    //assert(pDriverData);

    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    // find out if overlay hardware is busy, if so return "overlay busy" error code.
    // Perhaps check a "number of overlay buffers programmed" count.  When this count is less 
    // than 2, the overlay hardare is not busy and when it's equal to 2, the hardwar is busy. 
    // If it's not busy, then program it up here and increment the count.  Then use a kernel 
    // callback to decrement this count upon buffer complete.
    //
    
    DWORD dwIndex = pOverlayInfo->dwOverlayBufferIndex;

#ifdef _NVP_DTRACE
    DTRACE(0xdead0001);
    DTRACE_CYCLE_DELTA();
    DTRACE(dwOffset);
    DTRACE(dwIndex);

//    return TRUE;
#endif

/*
        while ((pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS) && (i < VDD_VPP_TIME_OUT))
            i++;
        // timed-out... stop the appropriate buffer and return error
        if (i >= VDD_VPP_TIME_OUT)
*/
    // drop field if previous one is still being drawn (same overlay buffer) !
    if (pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS)
        return 1;

    dwWorkSurfaces = pOverlayInfo->dwExtra422NumSurfaces;
    vppExec = 0;
    dwOpCount = 0;
    dwSrcOffset = dwOffset;
    dwSrcPitch = dwPitch;
    dwDstOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index];
    dwDstPitch = pOverlayInfo->dwExtra422Pitch;
    dwNextOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index + 1];
    dwNextPitch = pOverlayInfo->dwExtra422Pitch;

    isField = IS_FIELD(dwFlags);

    doXPreScale = (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale));
    doYPreScale = (pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale));
  
    if (pVPEContext->dwChipId < NV_DEVICE_VERSION_10) {
        // NV4/5 also prescales:
        //  - all BOBed fields
        //  - vertical upscales when HQVUp is enabled
        doYPreScale = TRUE; //doYPreScale || isField; //|| (pOverlayInfo->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)
    }

    doPreScale = (dwFlags & VPP_PRESCALE) &&
                 (doXPreScale || doYPreScale);

    isDownScale = FALSE;
    if (doPreScale) 
    {
        DWORD dwSrcArea, dwDstArea;

        dwSrcArea = pOverlayInfo->dwOverlaySrcHeight * pOverlayInfo->dwOverlaySrcWidth;
        if ((dwFlags & (VPP_ODD | VPP_EVEN)) && (dwFlags & VPP_INTERLEAVED)) 
        {
            // bob mode
			dwSrcArea >>= 1;
        }
        dwDstArea = pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayDstWidth;
        if (dwSrcArea > dwDstArea) 
        {
            isDownScale = TRUE;
        }
    }

    if (dwWorkSurfaces < 2) {
        // no work surfaces, can't do anything
        doPreScale = FALSE;
    }

    // adjust for the subrectangle
    dwRoundX = pOverlayInfo->dwOverlaySrcX & 0x1;
    dwRoundY = pOverlayInfo->dwOverlaySrcY & 0x1;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcY & ~0x1) * dwSrcPitch;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcX & ~0x1) << 1;   // always YUV422
    dwWidth = pOverlayInfo->dwOverlaySrcSize & 0xFFFF;
    dwHeight = pOverlayInfo->dwOverlaySrcSize >> 16;
    if (dwWidth & 1)
        dwWidth += 1;
    if (dwRoundY)
        dwHeight += 1;

    // do the prescaling now
    if (doPreScale) 
    {
        if (NVPPreScale(pVPEContext, pOverlayInfo, 
                        dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, &dwWidth, &dwHeight, 
                        &dwFlags)) {
            NEXT_SURFACE;
            vppExec |= VPP_PRESCALE;
        }
    }

    if (dwRoundY) 
    {
        dwSrcOffset += dwSrcPitch;
        dwHeight -= 1;
    }

//    if (dwRoundX)
//        dwWidth -= 1;

    // always do the flip, even if we are not flipping
    if (NVPFlip(pVPEContext, pOverlayInfo, dwSrcOffset,
                dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFlags)) 
    {
        pOverlayInfo->dwOverlayBufferIndex ^= 1;
        if (dwWorkSurfaces == 0) 
        {
            pOverlayInfo->dwExtra422Index = 0;
        }
        else if (dwWorkSurfaces <= 3)
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 1) % dwWorkSurfaces;
        } 
        else 
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 2) % dwWorkSurfaces;
        }
    } 
    else 
    {
        return FALSE;
    }

    return TRUE;
}


#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\GTFMATH.H ===
/*==========================================================================
;
; Copyright (C) 1999, Nvidia Corporation
;
; File:     gtf.h
;
; Purpose:  This file implements the GTF algorithm
==========================================================================*/

typedef struct  tagGTFIN
{
    ULONG   dwHPixels;
    ULONG   dwVLines;
    ULONG   dwMarginsRqd;
    ULONG   dwIntRqd;
    ULONG   dwIPParmType;
    ULONG   dwIPFreqRqd;
} GTFIN;

typedef GTFIN   FAR *LPGTFIN;

// The entire GTF based computation is based upon the variables provided
// in the GTFIN structure. They are defined as follows:
// HPixels      - the horizontal resolution in Pixels
// VLines       - the vertical resolution in scanlines
// MarginsRqd   - this is a flag -- TRUE if borders should be present
//                FALSE if they shouldn't be. Borders are also referred
//                to as the overscan area.
// IntRqd       - this is a flag -- TRUE if interlace mode is desired
//                FALSE if non-interlace mode is desired.
// IPParmType   - this indicates what the dwIPFreqRqd variables means.
//                assording to the following table.
//  If IPParm is this           IPFreqRqd is this
//  1                           vertical refresh rate in hz
//  2                           horizontal refresh rate in Khz
//  3                           pixel clock rate in Mhz

// These are the tree values that can be assumed by the
// dwIPParmType file din the GTFIN structure.
#define IPTYPE_VERTICAL_REFRESH_RATE    1
#define IPTYPE_HORIZONTAL_REFRESH_RATE  2
#define IPTYPE_PIXEL_CLOCK_RATE         3


typedef struct  tagGTFOUT
{
    ULONG   dwHTotalChars;
    ULONG   dwVTotalScans;
    ULONG   dwHActiveChars;
    ULONG   dwVActiveScans;
    ULONG   dwHBlankStartChar;
    ULONG   dwHFrontPorchChars;
    ULONG   dwHSyncChars;
    ULONG   dwHBackPorchChars;
    ULONG   dwHBlankEndChar;
    ULONG   dwVBlankStartScan;
    ULONG   dwVFrontPorchScans;
    ULONG   dwVSyncScans;
    ULONG   dwVBackPorchScans;
    ULONG   dwVBlankEndScan;
    ULONG   dwPixelClockIn10KHertz;
} GTFOUT;

typedef GTFOUT  FAR *LPGTFOUT;

// For those display devices which don't really need front and back
// porches, those fields can be ignored but they are always valid.


extern ULONG WINAPI ComputeGTFParameters(LPGTFIN lpGtfIn, LPGTFOUT lpGtfOut);
extern ULONG WINAPI Divide32By32(ULONG dwDividend, ULONG dwDivisor);
extern ULONG WINAPI Multiply32By32(ULONG dwMult1, ULONG dwMult2);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\EDID.C ===
/*
    FILE:   edid.c
    DATE:   4/8/99

    This file is the generic entry point for the edid modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "edid.h"
#include "dmt.h"
#include "gtf.h"
#include "gtfmath.h"
#include "restime.h"
#include "utils.h"

//*****************************************************************************
//
// EDID Established Timings
//
// These are the timings from the VESA Monitor Timing Specification
// (Version 1.0, Revision 0.8) which correspond to the modes in the
// Established Timings block of the EDID.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity
// VSync polarity
//
// NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
// Blank End == Total.
//

MODESTRUC sZeroMode[] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

MODESTRUC EDIDEstablishedTimingTbl[] =
{
    // Settings for 1280x1024:
    1280,1024,75, 1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1024x768:
    1024,768,75, 1312,1024,1040,1136,1312,800,768,769,772,800,7875,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1024,768,70, 1328,1024,1048,1184,1328,806,768,771,777,806,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,60, 1344,1024,1048,1184,1344,806,768,771,777,806,6500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 800x600:
    800,600,75, 1056,800,816,896,1056,625,600,601,604,625,4950,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,72, 1040,800,856,976,1040,666,600,637,643,666,5000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,60, 1056,800,840,968,1056,628,600,601,605,628,4000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,56, 1024,800,824,896,1040,625,600,601,603,625,3600,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x480:
    640,480,75, 840,640,656,720,840,500,480,481,484,500,3150,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,72, 832,648,664,704,824,520,488,489,492,512,3150,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

MODESTRUC EDIDDetailedTimingTable[9] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

MODESTRUC EDIDEstablishedTimingTable[11] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

MODESTRUC EDIDStandardTimingTable[9] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};



/*
    Function:   EdidGetVersion

    Purpose:    Returns EDID version multiplied by 0x100 so 1.10 is 0x110.

    Arguments:  NONE

    Returns:    EDID version multiplied by 100 if one exists.
                FALSE if no valid EDID

    Preserve:
*/
int CFUNC
EdidGetVersion (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int     nEdidVersion;

    // Edid Version is 1.x if the very first byte is a 0.
    if (lpEdidBuffer[0] == 0x00)
    {
        LPEDIDV1STRUC   lpV1;

        lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // For Version 1.x, first 8 bytes of EDID must be
        // 00h, FFh, FFh, FFh, FFh, FFh, FFh, 00h
        if  ((lpEdidBuffer[1] != 0x0FF) || (lpEdidBuffer[2] != 0x0FF) ||
             (lpEdidBuffer[3] != 0x0FF) || (lpEdidBuffer[4] != 0x0FF) ||
             (lpEdidBuffer[5] != 0x0FF) || (lpEdidBuffer[6] != 0x0FF) ||
             (lpEdidBuffer[7] != 0x000))
        {
            DBG_PRINT0(DL_1, "\r\nBad Edid Version 1.X");
            return  (FALSE);
        }

        nEdidVersion = (int) ((((USHORT) lpV1->bVersionNumber) << 8) +
                       ((USHORT) lpV1->bRevisionNumber));
    }
    else
    {
        if ((lpEdidBuffer[0] & 0xF0) == 0x20)     // Version 2.x?
        {
            nEdidVersion = (int) ((USHORT) lpEdidBuffer[0] << 4);
        }
        else                                    // Invalid Version number
        {
            DBG_PRINT0(DL_1, "\r\nBad Edid Version 2.X");
            return  (FALSE);
        }
    }

    DBG_PRINT1(DL_1, "\r\nEdid Version %x", nEdidVersion);
    return (nEdidVersion);
}


/*
    Function:   EdidFindNumTimingCodes

    Purpose:    Finds the number of luminance tables, size of luminance
                table, number of frequency ranges, number of detailed
                range limits, number of timing codes, and number of
                detailed timings. This is only valid for Version 2.x
                EDIDs.

    Arguments:  lpEdidBuffer    EDID data
                dwEdidSize      length of EDID
                lpTC            Ptr to array for Timing Code return values.

    Returns:    TRUE    timing codes were located and lpTC was fiiled in
                FALSE   no timing codes were found

    Preserve:
*/

int CFUNC
EdidFindNumTimingCodes (
    LPCHAR          lpEdidBuffer,
    ULONG           dwEdidSize,
    LPTIMINGCODES   lpTC)
{
    ULONG           dwInfo;
    USHORT          wLuminanceInfo;
    LPEDIDV2STRUC   lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

    dwInfo = (ULONG) lpV2->wTimingInfoMap;

    // Calculate Luminance Table. There is one table if bit 5 is set.
    if (dwInfo & 0x20)
    {
        lpTC->dwNumLuminanceTables = 1;

        // Let n = EdidBuffer[0x80] bits [4:0]
        // if EdidBuffer[0x80] bit 7 = 0
        //    then the size of the luminance table is n + 1
        // if EdidBuffer[0x80] bit 7 = 1
        //    then the size of the luminance table is 3n + 1
        wLuminanceInfo = (USHORT) lpV2->bTableDescriptors[0];
        if (wLuminanceInfo & 0x80)
            lpTC->dwSizeLuminanceTables =
                        (ULONG) (3 * (wLuminanceInfo & 0x1F) + 1);
        else
            lpTC->dwSizeLuminanceTables = (ULONG) (wLuminanceInfo + 1);
    }
    else
    {
        lpTC->dwNumLuminanceTables  = 0;
        lpTC->dwSizeLuminanceTables = 0;
    }

    lpTC->dwNumFreqRanges      = (dwInfo  >> 2) & 7;
    lpTC->dwNumRangeLimits     = dwInfo & 0x03;
    lpTC->dwNumTimingCodes     = (dwInfo >> (8 + 3)) & 0x1F;
    lpTC->dwNumDetailedTimings = (dwInfo >> 8) & 0x07;

    return  (TRUE);
}


/*
    Function:   EdidGetMonitorLimits

    Purpose:    Find the limits of operation by searching for a Monitor
                Descriptor Block with a Data Tag of FDh (Monitor Range
                Limits).

    Arguments:  EdidVersion     Version of EDID block.
                MonitorLimits   Ptr to array of monitor limits.

    Returns:    TRUE    Monitor Limits
                FALSE   No Monitor Limits

    Preserve:
*/

int CFUNC
EdidGetMonitorLimits (
    LPCHAR          lpEdidBuffer,
    ULONG           dwEdidSize,
    LPMONITORLIMITS lpML)
{
    int             i;
    int             nEdidVersion;
    TIMINGCODES     TimingCodes;
    ULONG           dwMinFrame, dwMaxFrame;
    ULONG           dwMinLine, dwMaxLine;
    ULONG           dwMinClock, dwMaxClock;

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // there are no monitor range limits.
    if  (!nEdidVersion)
        return  (FALSE);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC       lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;
        LPMONITORDESCRITOR  lpMD = (LPMONITORDESCRITOR) lpV1->DetailedTimingDesc;

        // Start all the mins high and the maxs low, so they
        // will get changed when we find something more restrictive.
        lpML->dwMinHorz = 0x00;
        lpML->dwMaxHorz = 0x0FFFFFFFF;
        lpML->dwMinVert = 0x00;
        lpML->dwMaxVert = 0x0FFFFFFFF;

        // Start out with the maximum pixel clock being the largest
        // pixel clock found in all EDID timings.
        lpML->dwMaxPixelClock = EdidFindLargestPixelClock (lpEdidBuffer, dwEdidSize);
        lpML->dwMaxPixelClock = Multiply32By32 (lpML->dwMaxPixelClock, 10000);

        // There are 4 detailed timing descriptors in a version 1.X edid.
        // The detailed timing descriptor blocks do double duty as a
        // monitor range descriptor block when the first three bytes are 0,
        // and the fourth byte is FDh.
        for (i = 0; i < 4; i++, lpMD++)
        {
           // For Monitor Descriptor, the first 3 bytes must all be zero
           // and the monitor descriptor type must be a range limit.
           if   ((lpMD->wZeroFlag == 0) && (lpMD->bZeroFlag == 0) &&
                 (lpMD->bTypeDescriptorBlock == DT_MONITOR_RANGE_LIMITS))
           {
                dwMinLine  = Multiply32By32 (lpMD->bMinHorzRateInKHz, 1000);
                dwMaxLine  = Multiply32By32 (lpMD->bMaxHorzRateInKHz, 1000);
                dwMinFrame = (ULONG) lpMD->bMinVertRateInHz;
                dwMaxFrame = (ULONG) lpMD->bMaxVertRateInHz;

                // Now do an intersection
                if  (dwMinFrame > lpML->dwMinVert)
                    lpML->dwMinVert = dwMinFrame;

                if  (dwMaxFrame < lpML->dwMaxVert)
                    lpML->dwMaxVert = dwMaxFrame;

                if  (dwMinLine > lpML->dwMinHorz)
                    lpML->dwMinHorz = dwMinLine;

                if  (dwMaxLine < lpML->dwMaxHorz)
                    lpML->dwMaxHorz = dwMaxLine;

                // If the bMaxPixelClockInCKHz in the EDID range limits is
                // 0xFF, then the pixel clock is not specified.
                if (lpMD->bMaxPixelClockInCKHz != 0xFF)
                {
                    dwMaxClock = Multiply32By32 (lpMD->bMaxPixelClockInCKHz, 10000000);
                    if  (dwMaxClock < lpML->dwMaxPixelClock)
                        lpML->dwMaxPixelClock = dwMaxClock;
                }
                else
                {
                    MODEINFO    sMI;

                    // Find a pixel clock using largest mode from EDID. 
                    // GetMaximumRefreshRate fills out lpML->dwMaxPixelClock.
                    // 640 and 480 are being used for dwTargetXRes and
                    // dwTargetYRes respectively, but these parameters are
                    // irrelevant because we just want the pixel clock and
                    // not the refresh rate. Be sure to zero out
                    // lpML->dwMaxPixelClock, or GetMaximumRefreshRate will
                    // not a calculate a pixel clock.
                    sMI.dwRefreshRate = 0;
                    EdidFindLargestEdidMode (lpEdidBuffer, dwEdidSize, &sMI);

                    lpML->dwMaxPixelClock = 0;
                    GetMaximumRefreshRate (sMI.dwXRes, sMI.dwYRes,
                                           sMI.dwRefreshRate, lpML, 640, 480);

                }
            }
        }

        // If we didn't find any reasonable values, then outta here
        if  ((lpML->dwMinVert == 0x00) ||
             (lpML->dwMaxVert == 0x0FFFFFFFF))
        {
            return  (FALSE);
        }

        return  (TRUE);
    }


    if  (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC           lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;
        LPDISPLAYTIMINGRANGE    lpTR;
        LPDETAILEDTIMINGRANGE   lpDT;
        ULONG                   dwExtra;
        ULONG                   dwClockExtra;
        ULONG                   dwLargestHBlank, dwLargestVBlank;
        ULONG                   dwLargestHTotal, dwLargestVTotal;
        ULONG                   dwSmallestHBlank, dwSmallestVBlank;
        ULONG                   dwSmallestHTotal, dwSmallestVTotal;
        ULONG                   j, k;
        LPCHAR                  lpC;
        int                     nSum;

        EdidFindNumTimingCodes (lpEdidBuffer, dwEdidSize, &TimingCodes);

        // If there were no monitor range limits, then outta here
        if  ((TimingCodes.dwNumFreqRanges == 0) &&
             (TimingCodes.dwNumRangeLimits == 0))
            return  (FALSE);

        // There are two types of monitor range limits in a
        // version 2.XX EDID. The first is a simple min/max
        // horz frequemcy, min/max vertical frequency, and
        // min/max pixel clock. The second includes this
        // and also specifies min/max values for sync offsets,
        // sync pulse widths, blanking, image size, borders
        // interlaced/non-interlaced, and sync polarities.
        // In any case, what we want to do is return a
        // MONITORLIMITS structure that is the intersection
        // of any and all these. The point is that we assume
        // that all of them apply and hence we want to restrict
        // by every one of them. NOTE that MONITORLIMITS
        // doesn't deal with all the blanking, sync pulses,
        // etc in the more detailed type of range limit struct
        // in the EDID, so we will ignore that for now. All
        // we care about are the min and max for each of
        // pixel clock, horz freq and vert freq.

        // In version 2.XX of the EDID, there is a section which
        // can contain 5 different types of objects. The first,
        // if it exists, are luminance tables which we just skip over.

        i = (int) (TimingCodes.dwNumLuminanceTables *
                 TimingCodes.dwSizeLuminanceTables);

        // Start all the mins high and the maxs low, so they
        // will get changed when we find something more restrictive.
        lpML->dwMinHorz = 0x00;
        lpML->dwMaxHorz = 0x0FFFFFFFF;
        lpML->dwMinVert = 0x00;
        lpML->dwMaxVert = 0x0FFFFFFFF;
        lpML->dwMaxPixelClock = 0x0FFFFFFFF;

        // The next is the simple range limit structures
        // There can be more than one.
        for (j = 0; j < TimingCodes.dwNumFreqRanges; j++)
        {
            lpTR = (LPDISPLAYTIMINGRANGE) &(lpV2->bTableDescriptors[i]);
            lpC  = (LPCHAR) lpTR;

            // Be careful here. For fixed frequency devices, all these
            // fields are set to 0.
            for (nSum = 0, k = 0; k < 8; k++)
                nSum += (int) lpC[k];

            if  (nSum != 0)
            {
                dwExtra    = ((ULONG) lpTR->bLoHV);
                dwMinFrame = (((ULONG) lpTR->bHiMinVert) << 2) + ((dwExtra >> 6) & 0x03);
                dwMaxFrame = (((ULONG) lpTR->bHiMaxVert) << 2) + ((dwExtra >> 4) & 0x03);
                dwMinLine  = (((ULONG) lpTR->bHiMinHorz) << 2) + ((dwExtra >> 2) & 0x03);
                dwMinLine  = Multiply32By32 (dwMinLine, 1000);
                dwMaxLine  = (((ULONG) lpTR->bHiMaxHorz) << 2) + ((dwExtra >> 0) & 0x03);
                dwMaxLine  = Multiply32By32 (dwMaxLine, 1000);

                dwClockExtra = ((ULONG) lpTR->bHiMinMaxPixClock);
                dwMaxClock   = ((ULONG) lpTR->bLoMaxPixClock) + ((dwClockExtra & 0x0F) << 8);
                dwMaxClock   = Multiply32By32 (dwMaxClock, 1000000);

                // Now do an intersection
                if  (dwMinFrame > lpML->dwMinVert)
                    lpML->dwMinVert = dwMinFrame;

                if  (dwMaxFrame < lpML->dwMaxVert)
                    lpML->dwMaxVert = dwMaxFrame;

                if  (dwMinLine > lpML->dwMinHorz)
                    lpML->dwMinHorz = dwMinLine;

                if  (dwMaxLine < lpML->dwMaxHorz)
                    lpML->dwMaxHorz = dwMaxLine;

                if  (dwMaxClock < lpML->dwMaxPixelClock)
                    lpML->dwMaxPixelClock = dwMaxClock;
            }

            i += sizeof(DISPLAYTIMINGRANGE);
        }

        // Now, handle any of the more complicated monitor limit structs.
        for (j = 0; j < TimingCodes.dwNumRangeLimits; j++)
        {
            lpDT = (LPDETAILEDTIMINGRANGE) &(lpV2->bTableDescriptors[i]);

            dwMinClock = ((ULONG) lpDT->wMinPixelClock) * 10000;
            dwMaxClock = ((ULONG) lpDT->wMaxPixelClock) * 10000;

            // The highest vertical frequency is obtained by using
            // dividing the maximum pixel clock by the smallest
            // total pixel count.
            dwSmallestHBlank = ((ULONG) lpDT->bLowMinHBlank) +
                                ((((ULONG) lpDT->bHiMinHVBlank) & 0xF0) << 4);
            dwSmallestVBlank = ((ULONG) lpDT->bLowMinVBlank) +
                                ((((ULONG) lpDT->bHiMinHVBlank) & 0x0F) << 8);
            dwSmallestHTotal = dwSmallestHBlank + ((ULONG) lpDT->bLowHActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0xF0) << 4);
            dwSmallestVTotal = dwSmallestVBlank + ((ULONG) lpDT->bLowVActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0x0F) << 8);
            dwMaxFrame = dwMaxClock / (dwSmallestVTotal * dwSmallestHTotal);
            dwMaxLine  = dwMaxClock / dwSmallestHTotal;

            dwLargestHBlank = ((ULONG) lpDT->bLowMaxHBlank) +
                                ((((ULONG) lpDT->bHiMaxHVBlank) & 0xF0) << 4);
            dwLargestVBlank = ((ULONG) lpDT->bLowMaxVBlank) +
                                ((((ULONG) lpDT->bHiMaxHVBlank) & 0x0F) << 8);
            dwLargestHTotal = dwLargestHBlank + ((ULONG) lpDT->bLowHActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0xF0) << 4);
            dwLargestVTotal = dwLargestVBlank + ((ULONG) lpDT->bLowVActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0x0F) << 8);
            dwMinFrame = dwMinClock / (dwLargestVTotal * dwLargestHTotal);
            dwMinLine  = dwMinClock / dwLargestHTotal;

            // Now do an intersection
            if  (dwMinFrame > lpML->dwMinVert)
                lpML->dwMinVert = dwMinFrame;

            if  (dwMaxFrame < lpML->dwMaxVert)
                lpML->dwMaxVert = dwMaxFrame;

            if  (dwMinLine > lpML->dwMinHorz)
                lpML->dwMinHorz = dwMinLine;

            if  (dwMaxLine < lpML->dwMaxHorz)
                lpML->dwMaxHorz = dwMaxLine;

            if  (dwMaxClock < lpML->dwMaxPixelClock)
            {
                // Add about 5% to their max pixel clock because
                // if this is a fixed freq timing, will never match
                // it exactly.
                lpML->dwMaxPixelClock = (dwMaxClock * 21) / 20;
            }

            i += sizeof(DETAILEDTIMINGRANGE);
        }

        // If we didn't find any reasonable values, then outta here
        if  ((lpML->dwMinVert == 0x00) ||
             (lpML->dwMaxVert == 0x0FFFFFFFF))
        {
            return  (FALSE);
        }

        return  (TRUE);
    }

    return (FALSE);
}



/*
    Function:   EdidIsGtfMonitor

    Purpose:    Checks EDID block to see if display type supports GTF.

    Arguments:  lpEdidBuffer    The EDID
                dwEdidSize      EDID size in bytes

    Returns:    TRUE            Display type supports GTF.
                FALSE           Display type does not support GTF.

    Preserve:
*/

int CFUNC
EdidIsGtfMonitor (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int             nEdidVersion;
    MONITORLIMITS   sML;

    // Get the EDID version
    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // the monitor is not GTF.
    if  (!nEdidVersion)
        return  (FALSE);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // Edid version 1.X check for GTF monitor
        if  (lpV1->bFeatureSupport & 0x01)
            return  (TRUE);

        return (FALSE);
    }

    if (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

        // Edid version 2.X check for GTF monitor
        if  (lpV2->bGTFSupportInfo & 0xF0)
        {
            // The GTF monitor bits are set! But the spec also
            // says that the monitor is not truly GTF compliant
            // unless there is also a MONITORLIMITS descriptor
            if  (EdidGetMonitorLimits(lpEdidBuffer, dwEdidSize, &sML))
            {
                return  (TRUE);
            }
        }

        return (FALSE);
    }

    return  (FALSE);
}



/*
    Function:   EdidGetMonitorId

    Purpose:    This returns the monitorID from the EDID. The monitor
                ID is defined as a DWORD from high byte to low byte
                as follows:
                high byte of product code, low byte of product code, high
                byte of manufacturer code, low byte of manufacturer code.

                If there is any kind of error then return UKWN_ID which
                is defined in restime.h  It means any monitor for which
                an EDID is not defined. Since you can't parse the EDID
                for some reason, this is a reasonable return value.

    Arguments:  lpEdidBuffer    The EDID
                dwEdidSize      EDID size in bytes

    Returns:    TRUE            Display type supports GTF.
                FALSE           Display type does not support GTF.

    Preserve:
*/

ULONG CFUNC
EdidGetMonitorId (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int     nEdidVersion;
    ULONG   dwMonitorID;

    // Get the EDID version
    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // the monitor is not GTF.
    if  (!nEdidVersion)
        return  (UKWN_ID);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        dwMonitorID = (((ULONG) lpV1->wIDProductCode) << 16) |
                      ((ULONG) lpV1->wIDManufName);

        return  (dwMonitorID);
    }

    if (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

        dwMonitorID = (((ULONG) lpV2->wIDProductCode) << 16) |
                      ((ULONG) lpV2->wIDManufName);

        return  (dwMonitorID);
    }

    return  (UKWN_ID);
}



/*
    Function:   EdidBuildStandardTimingTable

    Purpose:    Using the Standard Timings field of the EDID block,
                create a table for the standard timings. NOTE: This
                procedure is only valid for Version 1.x EDID structures
                and the timings associated with these modes are assumed
                to be GTF timings.

    Arguments:  NONE

    Returns:    Nothing but copies supported modes to EDIDStandardTimingTable.

    Preserve:
*/

int CFUNC
EdidBuildStandardTimingTable (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    USHORT          wHorizontalRes;
    USHORT          wVerticalRes;
    USHORT          wRefreshRate;
    int             i, j, nIndex;
    int             FoundMode;
    int             nEdidVersion;
    GTFIN           GTFIn;
    GTFOUT          GTFOut;
    MODESTRUC       sGTF;
    LPMODESTRUC     lpDmtTable;
    LPEDIDV1STRUC   lpV1;

    lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

    // First, zero out all entries
    for (i = 0; i < 8; i++)
        EDIDStandardTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        for (nIndex = 0, i = 0; i < 8; i++)
        {
            wHorizontalRes = lpV1->wStandardTimingID[i] & 0x0FF;
            if  (wHorizontalRes != 0x01)                // Unused fields = 01
            {
                // The value in the EDID = (Horizontal active pixels/8) - 31
                wHorizontalRes += 31;
                wHorizontalRes <<= 3;
                wVerticalRes = lpV1->wStandardTimingID[i] >> 8;
                wRefreshRate = (wVerticalRes & 0x1F) + 60;

                switch (wVerticalRes & 0xC0)         // Aspect Ratio in 7:6
                {
                    case    0x00:
                        wVerticalRes = wHorizontalRes;          // 1:1
                        break;
                    case    0x40:
                        wVerticalRes = wHorizontalRes * 3 / 4;  // 4:3
                        break;
                    case    0x80:
                        wVerticalRes = wHorizontalRes * 4 / 5;  // 5:4
                        break;
                    case    0xC0:
                        wVerticalRes = wHorizontalRes * 9 / 16; // 16:9
                        break;
                }

                FoundMode = FALSE;

                // If monitor is not GTF, try DMT timings first.
                if (!EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize))
                {
                    //First try to find matching DMT mode.
                    DmtGetDmtTablePointer (&lpDmtTable);

                    j = FindMode(lpDmtTable, (ULONG) wHorizontalRes,
                                    (ULONG) wVerticalRes, (ULONG) wRefreshRate);

                    // If a DMT mode was found.
                    if  (j >= 0)
                    {
                        sGTF.wHorizVisible    = lpDmtTable[j].wHorizVisible;
                        sGTF.wVertVisible     = lpDmtTable[j].wVertVisible;
                        sGTF.wRefresh         = lpDmtTable[j].wRefresh;
                        sGTF.wHorizTotal      = lpDmtTable[j].wHorizTotal;
                        sGTF.wHorizBlankStart = lpDmtTable[j].wHorizBlankStart;
                        sGTF.wHorizSyncStart  = lpDmtTable[j].wHorizSyncStart;
                        sGTF.wHorizSyncEnd    = lpDmtTable[j].wHorizSyncEnd;
                        sGTF.wHorizBlankEnd   = lpDmtTable[j].wHorizBlankEnd;
                        sGTF.wVertTotal       = lpDmtTable[j].wVertTotal;
                        sGTF.wVertBlankStart  = lpDmtTable[j].wVertBlankStart;
                        sGTF.wVertSyncStart   = lpDmtTable[j].wVertSyncStart;
                        sGTF.wVertSyncEnd     = lpDmtTable[j].wVertSyncEnd;
                        sGTF.wVertBlankEnd    = lpDmtTable[j].wVertBlankEnd;
                        sGTF.wDotClock        = lpDmtTable[j].wDotClock;
                        sGTF.wHSyncPolarity   = lpDmtTable[j].wHSyncPolarity;
                        sGTF.wVSyncPolarity   = lpDmtTable[j].wVSyncPolarity;

                        FoundMode = TRUE;
                    }

                }

                // No DMT mode was found--use GTF.
                if (!FoundMode)
                {
                    // Get GTF timings for mode.
                    GTFIn.dwHPixels      = (ULONG) wHorizontalRes;
                    GTFIn.dwVLines       = (ULONG) wVerticalRes;
                    GTFIn.dwMarginsRqd   = FALSE;
                    GTFIn.dwIntRqd       = FALSE;
                    GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
                    GTFIn.dwIPFreqRqd    = (ULONG) wRefreshRate;
                    ComputeGTFParameters(&GTFIn, &GTFOut);

                    // Store all parameters in temporary MODESTRUC buffer. Note that
                    // horizontal GTF parameters are returned in character clocks and
                    // need to be converted to pixels.
                    sGTF.wHorizVisible    = (USHORT) (GTFOut.dwHActiveChars << 3);
                    sGTF.wVertVisible     = (USHORT) GTFOut.dwVActiveScans;
                    sGTF.wRefresh         = (USHORT) wRefreshRate;
                    sGTF.wHorizTotal      = (USHORT) (GTFOut.dwHTotalChars << 3);
                    sGTF.wHorizBlankStart = (USHORT) (GTFOut.dwHBlankStartChar << 3);
                    sGTF.wHorizSyncStart  = (USHORT) ((GTFOut.dwHBlankStartChar
                                                     + GTFOut.dwHFrontPorchChars) << 3);
                    sGTF.wHorizSyncEnd    = (USHORT) (sGTF.wHorizSyncStart
                                                     + (GTFOut.dwHSyncChars << 3));
                    sGTF.wHorizBlankEnd   = (USHORT) (GTFOut.dwHBlankEndChar << 3);
                    sGTF.wVertTotal       = (USHORT) GTFOut.dwVTotalScans;
                    sGTF.wVertBlankStart  = (USHORT) GTFOut.dwVBlankStartScan;
                    sGTF.wVertSyncStart   = (USHORT) (GTFOut.dwVBlankStartScan
                                                     + GTFOut.dwVFrontPorchScans);
                    sGTF.wVertSyncEnd     = (USHORT) (sGTF.wVertSyncStart
                                                     + GTFOut.dwVSyncScans);
                    sGTF.wVertBlankEnd    = (USHORT) GTFOut.dwVBlankEndScan;
                    sGTF.wDotClock        = (USHORT) GTFOut.dwPixelClockIn10KHertz;
                    sGTF.wHSyncPolarity   = BUFFER_HSYNC_NEGATIVE;
                    sGTF.wVSyncPolarity   = BUFFER_VSYNC_POSITIVE;


                }

                EDIDStandardTimingTable[nIndex++] = sGTF;
            }
        }
    }


    return  (TRUE);
}


/*
    Function:   EdidFindStandardMode

    Purpose:    This routine finds if the mode exists in the EDID
                standard mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindStandardMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i, nEdidVersion;

    // First, zero out all entries
    for (i = 0; i < 8; i++)
        EDIDStandardTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    }

    i = FindMode (EDIDStandardTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDStandardTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}


/*
    Function:   EdidBuildEstablishedTimingTable

    Purpose:    Using the Established Timings field of the EDID block,
                create a table for the established timings. NOTE: This
                procedure is only valid for Version 1.x EDID structures.

    Arguments:  NONE

    Returns:    Nothing but copies supported modes from
                EDIDEstablishedTimingTable to EDIDEstablishedTimingTbl.

    Preserve:
*/

int CFUNC
EdidBuildEstablishedTimingTable (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    ULONG           dwTimingBits, dwT1, dwT2;
    int             i, nIndex;
    int             nEdidVersion;
    LPEDIDV1STRUC   lpV1;

    // Only use VESA Established timings and put them in contiguous
    // order from highest resolution to lowest resolution so they will
    // match the order of EDIDEstablishedTimingTable[].
    lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

    dwT1 = (ULONG) (lpV1->bEstablishedTimings1);
    dwT2 = (ULONG) (lpV1->bEstablishedTimings2);
    dwTimingBits  =  (dwT2 & 0x0F) + ((dwT2 & 0xC0) >> 2);
    dwTimingBits  |= ((dwT1 & 0x0F) << 6);

    // First, zero out all entries
    for (i = 0; i < 10; i++)
        EDIDEstablishedTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Standard timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        for (nIndex = 0, i = 9; i >= 0; i--)
        {
            if (dwTimingBits & (1 << i))    // is this mode supported?
            {
                EDIDEstablishedTimingTable[nIndex++] = EDIDEstablishedTimingTbl[i];
            }
        }
    }

    return  (TRUE);
}


/*
    Function:   EdidFindEstablishedMode

    Purpose:    This routine finds if the mode exists in the EDID
                established mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindEstablishedMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i, nEdidVersion;

    // First, zero out all entries
    for (i = 0; i < 10; i++)
        EDIDEstablishedTimingTable[i] = sZeroMode[0];

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // Please note that Established timings are only valid on Version 1.x
    // EDIDs. Zeroing out the table above provides protection for
    // Version 2.x EDIDs.
    if  (nEdidVersion < 0x200)
    {
        EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    }

    i = FindMode (EDIDEstablishedTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDEstablishedTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}



/*
    Function:   EdidBuildDetailedTimingTable

    Purpose:    Using the Detailed Timing section of the EDID block,
                create a table for the detailed timings.

    Arguments:  EdidVersion     Version of EDID block.

    Returns:    Nothing but copies detailed timing modes to
                EDIDDetailedTimingTable.

    Preserve:
*/

int CFUNC
EdidBuildDetailedTimingTable(LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int         nEdidVersion;
    ULONG       dwNumTimings;
    ULONG       dwOffset;
    ULONG       i, j;
    ULONG       dwPixelClock;
    ULONG       dwHorizVertTotal;
    MODESTRUC   sTS;
    LPDETAILEDTIMINGDESCRIPTOR  lpDTD;
    LPEDIDV1STRUC   lpV1;
    TIMINGCODES     tc;
    LPCHAR          lpB;

    // First, zero out all entries in the detailed timing table
    for (i = 0; i < 10; i++)
        EDIDDetailedTimingTable[i] = sZeroMode[0];

    // Get the version
    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    if  (nEdidVersion < 0x200)
    {
        // Version 1.x
        lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // In version 1.XX, the detailed timings are at a fixed offset
        dwOffset = (ULONG)((LPCHAR) &(lpV1->DetailedTimingDesc[0]) - (LPCHAR) lpV1);

        // With version 1.XX of the EDID, there are 4 detailed timing
        // descriptor slots. Any or all of them can be used. Unused
        // ones are marked with a 0 in the first three bytes.
        dwNumTimings = 4;
    }
    else
    {
        // Version 2.XX of the EDID
        EdidFindNumTimingCodes (lpEdidBuffer, dwEdidSize, &tc);

        // In version 2.XX, the detailed timings are in a section of
        // the EDID which holds many items that are not required.
        // Hence, it is necessary to compute the offset based upon
        // which of the optional items is present. These items begin
        // at offset 80h in the EDID.
        dwOffset = (tc.dwNumLuminanceTables * tc.dwSizeLuminanceTables +
                   tc.dwNumFreqRanges * 8 + tc.dwNumRangeLimits * 27 +
                   tc.dwNumTimingCodes * 4) + 0x80;

        // With version 2.XX of the EDID, there are a variable number
        // of detailed timing descriptor slots. All of them are used.
        // There needn't be any checking for leading zeros.
        dwNumTimings = tc.dwNumDetailedTimings;
    }

    for (j = 0, i = 0; i < dwNumTimings; i++)
    {
        lpDTD = (LPDETAILEDTIMINGDESCRIPTOR) &(lpEdidBuffer[dwOffset]);
        lpB = (LPCHAR) lpDTD;

        // Although technically we should only do the "three leading zeros"
        // check for version 1 of the EDID, if the first three bytes of a
        // detailed timing are zeros, then we should probably ignore the
        // timing for version 2.XX of the EDID since the first two bytes
        // are the pixel clock!
        if  ((lpB[0]) || (lpB[1]) || (lpB[2]))
        {
            sTS.wHorizVisible    = (USHORT) (lpDTD->bDTHorizontalActive
                                    + ((lpDTD->bDTHorizActiveBlank & 0xF0) << 4));
            sTS.wVertVisible     = (USHORT)(lpDTD->bDTVerticalActive
                                    + ((lpDTD->bDTVertActiveBlank & 0xF0) << 4));
            sTS.wHorizTotal      = sTS.wHorizVisible
                                    + (USHORT)(lpDTD->bDTHorizontalBlanking
                                    + ((lpDTD->bDTHorizActiveBlank & 0x0F) << 8));
            sTS.wHorizBlankStart = sTS.wHorizVisible;
            sTS.wHorizSyncStart  = sTS.wHorizBlankStart
                                    + (USHORT)(lpDTD->bDTHorizontalSync
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0xC0) << 2));
            sTS.wHorizSyncEnd    = sTS.wHorizSyncStart
                                    + (USHORT)(lpDTD->bDTHorizontalSyncWidth
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x30) << 4));
            sTS.wHorizBlankEnd   = sTS.wHorizTotal;
            sTS.wVertTotal       = sTS.wVertVisible
                                    + (USHORT)(lpDTD->bDTVerticalBlanking
                                    + ((lpDTD->bDTVertActiveBlank & 0x0F) << 8));
            sTS.wVertBlankStart  = sTS.wVertVisible;
            sTS.wVertSyncStart   = sTS.wVertBlankStart
                                    + (USHORT)(((lpDTD->bDTVerticalSync & 0xF0) >> 4)
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x0C) << 2));
            sTS.wVertSyncEnd     = sTS.wVertSyncStart
                                    + (USHORT)((lpDTD->bDTVerticalSync & 0x0F)
                                    + ((lpDTD->bDTHorizVertSyncOverFlow & 0x03) << 4));
            sTS.wVertBlankEnd    = sTS.wVertTotal;
            sTS.wDotClock        = lpDTD->wDTPixelClock;

            if ((lpDTD->bDTFlags & 0x18) == 0x18)
            {
                sTS.wHSyncPolarity  = (lpDTD->bDTFlags & 0x2) >> 1;
                sTS.wVSyncPolarity  = (lpDTD->bDTFlags & 0x4) >> 2;
            }
            else if ((lpDTD->bDTFlags & 0x18) == 0x10)
            {
                sTS.wHSyncPolarity  = (lpDTD->bDTFlags & 0x2) >> 1;
                sTS.wVSyncPolarity  = BUFFER_VSYNC_POSITIVE;
            }
            else
            {
                sTS.wHSyncPolarity  = BUFFER_HSYNC_NEGATIVE;
                sTS.wVSyncPolarity  = BUFFER_VSYNC_POSITIVE;
            }

            dwPixelClock = Multiply32By32 (lpDTD->wDTPixelClock, 10000);
            dwHorizVertTotal = Multiply32By32 (sTS.wHorizTotal, sTS.wVertTotal);
            sTS.wRefresh = (USHORT) Divide32By32 (dwPixelClock +
                                    dwHorizVertTotal / 2, dwHorizVertTotal);

            EDIDDetailedTimingTable[j++] = sTS;
        }

        dwOffset += sizeof(DETAILEDTIMINGDESCRIPTOR);
    }

    return  (TRUE);
}


/*
    Function:   EdidFindDetailedMode

    Purpose:    This routine finds if the mode exists in the EDID
                detailed mode table.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match
                lpModeOut       ptr to MODEOUT structure
                                put timing argumetns here if there is
                                a match on the input mode

    Returns:    TRUE if there was a match and lpModeOut was filled
                FALSE if there was no match

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindDetailedMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc,
        LPMODEOUT   lpModeOut)
{
    int i;

    if  (!EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize))
        return  (FALSE);

    i = FindMode (EDIDDetailedTimingTable, lpModeDesc->dwXRes,
                    lpModeDesc->dwYRes, lpModeDesc->dwRefreshRate);

    if  (i < 0)
        return  (FALSE);

    SetupParamsForVidLutClass (EDIDDetailedTimingTable + i, lpModeOut,
                               lpModeDesc);

    return  (TRUE);
}


/*
    Function:   EdidFindExactModeWithHighestRR

    Purpose:    This routine searches for the highest refresh rate
                in the detailed, established, or standard timing
                sections that has a resolution exactly equal to the
                dwXRes and dwYRes in lpModeDesc. The refresh rate
                for that mode is returned. If there is no matching xres,
                yres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindExactModeWithHighestRR (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc)
{
    int             i, nHighestRR;

    nHighestRR = 0;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDDetailedTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        nHighestRR = EDIDDetailedTimingTable[i].wRefresh;

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDEstablishedTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        if  (EDIDEstablishedTimingTable[i].wRefresh > (USHORT) nHighestRR)
            nHighestRR = EDIDEstablishedTimingTable[i].wRefresh;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    if ((i = FindModeWithoutRR (EDIDStandardTimingTable, lpModeDesc->dwXRes,
                      lpModeDesc->dwYRes)) != -1)
        if  (EDIDStandardTimingTable[i].wRefresh > (USHORT) nHighestRR)
            nHighestRR = EDIDStandardTimingTable[i].wRefresh;

    if  (nHighestRR)
        return (nHighestRR);

    return  (FALSE);
}


/*
    Function:   EdidFindSameModeOrLargerWithHighestRR

    Purpose:    This routine searches for the highest refresh rate
                in the detailed, established, or standard timing
                sections that has a resolution greater than or equal
                to the dwXRes and dwYRes in lpModeDesc. The refresh rate
                for that mode is returned. If there is no matching xres,
                yres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindSameModeOrLargerWithHighestRR (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeDesc)
{
    int             nHighestRR, nCurrentRR;
    MONITORLIMITS   ML;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    nHighestRR = EdidFindHighestRRinTable (EDIDDetailedTimingTable, lpModeDesc);

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    nCurrentRR = EdidFindHighestRRinTable (EDIDEstablishedTimingTable, lpModeDesc);
    if  (nCurrentRR > nHighestRR)
        nHighestRR = nCurrentRR;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    nCurrentRR = EdidFindHighestRRinTable (EDIDStandardTimingTable, lpModeDesc);
    if  (nCurrentRR > nHighestRR)
        nHighestRR = nCurrentRR;

    if  (nHighestRR < 60)
        nHighestRR = 60;

    if  (!EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &ML))
        return (nHighestRR);

    if  ((ML.dwMaxHorz) && (ML.dwMaxVert))
    {
        // NOTE: If the MonitorLimits ptr passed in to the function
        // GetMaximumRefreshRate has a non-0 dwMaxPixelClock field,
        // then the first three arguments to GetMaximumRefreshRate
        // are irrelevant. We know that ML.dwMaxPixelClock is non-0
        // at this time, so we just pass in 0s for the parameters.
        nCurrentRR = (int) GetMaximumRefreshRate (0, 0, 0, &ML,
                                lpModeDesc->dwXRes, lpModeDesc->dwYRes);


        if (nCurrentRR > nHighestRR)
            nHighestRR = nCurrentRR;
    }

    return  (nHighestRR);
}


/*
    Function:   EdidFindHighestRRinTable

    Purpose:    This routine searches for the highest refresh rate
                in the table passed in. If there is no mode mode greater
                than or equal to dwXRes dwYres, then 0 is returned.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:    a non-0 is the highest refresh rate found in the detailed,
                established, or standard timing sections greater than
                or equal to the XRES, YRES given.
                0 if there was an error or a matching mode was not found

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidFindHighestRRinTable (
        LPMODESTRUC lpMS,
        LPMODEINFO  lpModeDesc)
{
    int          i, nBestIndex;

    nBestIndex = -1;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible >= lpModeDesc->dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible >= lpModeDesc->dwYRes))
        {
            if  (nBestIndex != -1)
            {
                if  (lpMS[i].wRefresh > lpMS[nBestIndex].wRefresh)
                    nBestIndex = i;
            }
            else
            {
                nBestIndex = i;
            }
        }
    }

    // If we didn't even find a mode greater than or equal to dwXRes
    // and dwYRes ...
    if  (nBestIndex == -1)
        return  (0);

    // We found one. Return the refresh rate.
    return  ((int) lpMS[nBestIndex].wRefresh);
}


/*
    Function:   EdidFindLargestEdidMode

    Purpose:    This routine searches the EDID for the largest mode of
                the detailed, established, and standard timings.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeInfo      pointer to buffer for return parameters

    Returns:    TRUE and lpModeInfo filled out with largest XRes and YRes
                     found in EDID or 640x480.

*/
int CFUNC
EdidFindLargestEdidMode (
        LPCHAR      lpEdidBuffer,
        ULONG       dwEdidSize,
        LPMODEINFO  lpModeInfo)
{
    // Start with 640x480. Color depth is specified in registry.
    lpModeInfo->dwXRes          = 640;
    lpModeInfo->dwYRes          = 480;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDDetailedTimingTable, lpModeInfo);

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDEstablishedTimingTable, lpModeInfo);

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    EdidFindLargestModeinTable (EDIDStandardTimingTable, lpModeInfo);

    return  (TRUE);
}


/*
    Function:   EdidFindLargestModeinTable

    Purpose:    This routine searches the table pointed to by lpMS for
                a mode that is larger than the mode pointed to by
                lpModeInfo.

    Arguments:  lpMS            pointer to table to search
                lpModeInfo      pointer to mode to compare and to return
                                parameters.

    Returns:    TRUE and lpModeInfo filled out with largest XRes and YRes
                     found in table or mode originally in ModeInfo.

*/
int CFUNC
EdidFindLargestModeinTable (
        LPMODESTRUC lpMS,
        LPMODEINFO  lpModeInfo)
{
    int i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if ((ULONG) lpMS[i].wHorizVisible >= lpModeInfo->dwXRes)
        {
            if ((ULONG) lpMS[i].wVertVisible >= lpModeInfo->dwYRes)
            {
                lpModeInfo->dwXRes = (ULONG) lpMS[i].wHorizVisible;
                lpModeInfo->dwYRes = (ULONG) lpMS[i].wVertVisible;
                if (lpMS[i].wRefresh > (USHORT) lpModeInfo->dwRefreshRate)
                     lpModeInfo->dwRefreshRate = (ULONG) lpMS[i].wRefresh;
            }
        }
    }

    return  (TRUE);
}


/*
    Function:   EdidCmpToLargestEdidMode

    Purpose:    This routine searches the EDID for the largest mode
                of the detailed, established, and standard timings
                to determine if the requested mode is less than or
                equal to the largest mode found in the EDID.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer
                lpModeDesc      mode to match

    Returns:
        The return value can be a logical OR of one of the first three
        flags with one of the second three flags.
        REQUESTED_MODE_SMALLER_XYRES_THAN_LARGEST_EDID_MODE
        REQUESTED_MODE_SAME_XYRES_AS_LARGEST_EDID_MODE
        REQUESTED_MODE_LARGER_XYRES_THAN_LARGEST_EDID_MODE

        REQUESTED_MODE_SMALLER_PXCLK_THAN_LARGEST_EDID_MODE
        REQUESTED_MODE_SAME_PXCLK_AS_LARGEST_EDID_MODE
        REQUESTED_MODE_LARGER_PXCLK_THAN_LARGEST_EDID_MODE

    Preserve:   Do not change any fields in lpModeDesc.
*/
int CFUNC
EdidCmpToLargestEdidMode (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpMD)
{
    int         i, j, nRet;
    ULONG       dwMaxXRes, dwMaxYRes;
    ULONG       dwMaxPixelClock, dwMatchingPixelClock;
    LPMODESTRUC lpMS;
    MODEOUT     MO;

    // Start this off at 0
    nRet = 0;

    // Build all EDID tables.
    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);

    // Find the maximum pixel clock in the detailed timings.
    lpMS = EDIDDetailedTimingTable;
    dwMatchingPixelClock = 0;
    dwMaxPixelClock = (ULONG) lpMS[0].wDotClock;
    dwMaxXRes = (ULONG) lpMS[0].wHorizVisible;
    dwMaxYRes = (ULONG) lpMS[0].wVertVisible;
    for (j = 0; j < 3; j++)
    {
        if  (j == 0)
            lpMS = EDIDDetailedTimingTable;
        else if  (j == 1)
            lpMS = EDIDEstablishedTimingTable;
        else if  (j == 2)
            lpMS = EDIDStandardTimingTable;

        for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
        {
            // Find the largest resolution of the mode in this list
            if  ((lpMS[i].wHorizVisible > dwMaxXRes) &&
                 (lpMS[i].wVertVisible > dwMaxYRes))
            {
                dwMaxXRes = lpMS[i].wHorizVisible;
                dwMaxYRes = lpMS[i].wVertVisible;
            }

            // Find the largest pixel clock of the modes in this list
            if (lpMS[i].wDotClock > dwMaxPixelClock)
                dwMaxPixelClock = (ULONG) lpMS[i].wDotClock;

            // Remember if any of the EDID modes exactly matches
            // the mode passed in. Remember the pixel clock of the
            // matching mode.
            if  ((lpMS[i].wHorizVisible == lpMD->dwXRes) &&
                 (lpMS[i].wVertVisible == lpMD->dwYRes))
            {
                nRet = REQUESTED_MODE_XYRES_EXACTLY_MATCHES_AN_EDID_MODE;
                dwMatchingPixelClock = (ULONG) lpMS[i].wDotClock;
            }
        }
    }

    // Now, how does the mode passed in compare?
    if  ((lpMD->dwXRes == dwMaxXRes) && (lpMD->dwYRes == dwMaxYRes))
        nRet |= REQUESTED_MODE_SAME_XYRES_AS_LARGEST_EDID_MODE;
    else if  ((lpMD->dwXRes <= dwMaxXRes) && (lpMD->dwYRes <= dwMaxYRes))
        nRet |= REQUESTED_MODE_SMALLER_XYRES_THAN_LARGEST_EDID_MODE;
    else
        nRet |= REQUESTED_MODE_LARGER_XYRES_THAN_LARGEST_EDID_MODE;

    // We need to find a pixel clock for the mode passed in.
    if  (dwMatchingPixelClock == 0)
    {
        // The XRes and YRes of the mode passed in did not exactly
        // match any of the EDID modes, so we don't know what the
        // pixel clock of the passed in mode should be! Use the
        // pixel clock generated by Gtf in this case.
        GtfFindMode (lpMD, (LPMODEOUT) &MO);
        dwMatchingPixelClock = MO.dwPixelClock;
    }

    // Now we can compare the pixel clocks.
    if  (dwMatchingPixelClock < dwMaxPixelClock)
        nRet |= REQUESTED_MODE_SMALLER_PXCLK_THAN_LARGEST_EDID_MODE;
    else if (dwMatchingPixelClock == dwMaxPixelClock)
        nRet |= REQUESTED_MODE_SAME_PXCLK_AS_LARGEST_EDID_MODE;
    else
        nRet |= REQUESTED_MODE_LARGER_PXCLK_THAN_LARGEST_EDID_MODE;

    return  (nRet);
}


/*
    Function:   EdidFindLargestPixelClock

    Purpose:    This routine searches the EDID for the mode
                with the largest pixel clock and returns that
                largest pixel clock.

    Arguments:  lpEdidBuffer    EDID
                dwEdidSize      size of EDID buffer

    Returns:    largest pixel clock (may be 0 if the EDID has
                no modes init)

    Preserve:
*/
ULONG CFUNC
EdidFindLargestPixelClock (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize)
{
    ULONG   dwMaxPixelClock;
    int     j;

    // Start out at 0
    dwMaxPixelClock = 0;

    EdidBuildDetailedTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDDetailedTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDDetailedTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDDetailedTimingTable[j].wDotClock;

    EdidBuildEstablishedTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDEstablishedTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDEstablishedTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDEstablishedTimingTable[j].wDotClock;

    EdidBuildStandardTimingTable (lpEdidBuffer, dwEdidSize);
    for (j = 0; EDIDStandardTimingTable[j].wHorizVisible != 0x00; j++)
        if  (dwMaxPixelClock < (ULONG) EDIDStandardTimingTable[j].wDotClock)
            dwMaxPixelClock = (ULONG) EDIDStandardTimingTable[j].wDotClock;

    return  (dwMaxPixelClock);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\EDID.H ===
/*
    FILE:   edid.h
    DATE:   4/8/99

    This file contains the includes for the EDID code.
    Os Independent
*/

#ifdef WINNT
// This disables any packing optimizations of the compiler.
// We achieve this by telling the compiler to pack on a 1-byte boundary.
// Note: There must be a corresponding pragma call at the end of this file to
// restore the default compiler packing (specified by /Zp).
#pragma pack(1)
#endif

struct  _tagDETAILEDTIMINGDESCRIPTOR
{
    USHORT  wDTPixelClock;              // 0x00
    UCHAR   bDTHorizontalActive;        // 0x02
    UCHAR   bDTHorizontalBlanking;      // 0x03
    UCHAR   bDTHorizActiveBlank;        // 0x04
    UCHAR   bDTVerticalActive;          // 0x05
    UCHAR   bDTVerticalBlanking;        // 0x06
    UCHAR   bDTVertActiveBlank;         // 0x07
    UCHAR   bDTHorizontalSync;          // 0x08
    UCHAR   bDTHorizontalSyncWidth;     // 0x09
    UCHAR   bDTVerticalSync;            // 0x0A
    UCHAR   bDTHorizVertSyncOverFlow;   // 0x0B
    UCHAR   bDTHorizontalImage;         // 0x0C
    UCHAR   bDTVerticalImage;           // 0x0D
    UCHAR   bDTHorizVertImage;          // 0x0E
    UCHAR   bDTHorizontalBorder;        // 0x0F
    UCHAR   bDTVerticalBorder;          // 0x10
    UCHAR   bDTFlags;                   // 0x11
} __STRUCTURE_PACKING__;

typedef struct _tagDETAILEDTIMINGDESCRIPTOR DETAILEDTIMINGDESCRIPTOR;
typedef DETAILEDTIMINGDESCRIPTOR FAR *LPDETAILEDTIMINGDESCRIPTOR;


struct  _tagMONITORDESCRITOR
{
    USHORT  wZeroFlag;                  // 0x00
    UCHAR   bZeroFlag;                  // 0x02
    UCHAR   bTypeDescriptorBlock;       // 0x03
    UCHAR   bZeroFlag2;                 // 0x04
    UCHAR   bMinVertRateInHz;           // 0x05
    UCHAR   bMaxVertRateInHz;           // 0x06
    UCHAR   bMinHorzRateInKHz;          // 0x07
    UCHAR   bMaxHorzRateInKHz;          // 0x08
    UCHAR   bMaxPixelClockInCKHz;       // 0x09
    UCHAR   bUnused[8];                 // 0x0A
} __STRUCTURE_PACKING__;

typedef struct _tagMONITORDESCRITOR MONITORDESCRITOR;
typedef MONITORDESCRITOR FAR *LPMONITORDESCRITOR;

// Note: The bMaxPixelClockInCKHz is in centi-kilohertz which is
// Megahertz divided by 10. This field may not be specified in which
// case it is set to 0x0FF.

// These are the values that can be in the bTypeDescriptorBlock field.
// Note: 0x10-0xF9 are currently undefined. 0x00-0x09 are monitor-
// manufacturer specific.
#define DT_MONITOR_SERIAL_NUMBER        0x0FF
#define DT_ASCII_STRING_DATA            0x0FE
#define DT_MONITOR_RANGE_LIMITS         0x0FD
#define DT_MONITOR_NAME_AS_ASCII        0x0FC
#define DT_EXTRA_COLOR_POINT_DATA       0x0FB
#define DT_EXTRA_STANDARD_TIMINGS       0x0FA


struct  _tagEDIDV1STRUC
{
    UCHAR   bHeaderByte0;               // 0x00
    UCHAR   bHeaderByte1;               // 0x01
    UCHAR   bHeaderByte2;               // 0x02
    UCHAR   bHeaderByte3;               // 0x03
    UCHAR   bHeaderByte4;               // 0x04
    UCHAR   bHeaderByte5;               // 0x05
    UCHAR   bHeaderByte6;               // 0x06
    UCHAR   bHeaderByte7;               // 0x07
    USHORT  wIDManufName;               // 0x08
    USHORT  wIDProductCode;             // 0x0A
    ULONG   wIDSerialNumber;            // 0x0C
    UCHAR   bWeekManuf;                 // 0x10
    UCHAR   bYearManuf;                 // 0x11
    UCHAR   bVersionNumber;             // 0x12
    UCHAR   bRevisionNumber;            // 0x13
    UCHAR   bVideoInputDef;             // 0x14
    UCHAR   bMaxHorizImageSize;         // 0x15
    UCHAR   bMaxVertImageSize;          // 0x16
    UCHAR   bDisplayXferChar;           // 0x17
    UCHAR   bFeatureSupport;            // 0x18
    UCHAR   bRedGreenLowBits;           // 0x19
    UCHAR   bBlueWhiteLowBits;          // 0x1A
    UCHAR   bRedX;                      // 0x1B
    UCHAR   bRedY;                      // 0x1C
    UCHAR   bGreenX;                    // 0x1D
    UCHAR   bGreenY;                    // 0x1E
    UCHAR   bBlueX;                     // 0x1F
    UCHAR   bBlueY;                     // 0x20
    UCHAR   bWhiteX;                    // 0x21
    UCHAR   bWhiteY;                    // 0x22
    UCHAR   bEstablishedTimings1;       // 0x23
    UCHAR   bEstablishedTimings2;       // 0x24
    UCHAR   bManufReservedTimings;      // 0x25
    USHORT  wStandardTimingID[8];       // 0x26
    DETAILEDTIMINGDESCRIPTOR    DetailedTimingDesc[4];  // 0x36
    UCHAR   bExtensionFlag;             // 0x7E
    UCHAR   bChecksum;                  // 0x7F
} __STRUCTURE_PACKING__;

typedef struct _tagEDIDV1STRUC EDIDV1STRUC;
typedef EDIDV1STRUC FAR *LPEDIDV1STRUC;


struct  _tagEDIDV2STRUC
{
    UCHAR   bHeader;                        // 0x00
    USHORT  wIDManufName;                   // 0x01
    USHORT  wIDProductCode;                 // 0x03
    UCHAR   bWeekManuf;                     // 0x05
    USHORT  wYearManuf;                     // 0x06
    UCHAR   bProductIDString[32];           // 0x08
    UCHAR   bSerialNumber[16];              // 0x28
    UCHAR   bReserved1[8];                  // 0x38
    UCHAR   bPhysicalInterfaceType;         // 0x40
    UCHAR   bVideoInterfaceType;            // 0x41
    UCHAR   bInterfaceDataFormat[8];        // 0x42
    UCHAR   bInterfaceColor[5];             // 0x4A
    UCHAR   bDisplayTechType;               // 0x4F
    UCHAR   bMajorDisplayChar;              // 0x50
    UCHAR   bFeaturesSupported[3];          // 0x51
    USHORT  wDisplayResponseTime;           // 0x54
    ULONG   dwDisplayXferChar;              // 0x56
    ULONG   dwMaxLuminance;                 // 0x5A
    UCHAR   bColorimetry[20];               // 0x5E
    ULONG   dwMaxImageSize;                 // 0x72
    ULONG   dwMaxAddressability;            // 0x76
    USHORT  wDotPixelPitch;                 // 0x7A
    UCHAR   bReserved2;                     // 0x7C
    UCHAR   bGTFSupportInfo;                // 0x7D
    USHORT  wTimingInfoMap;                 // 0x7E
    UCHAR   bTableDescriptors[127];         // 0x80
    UCHAR   bChecksum;                      // 0xFF
} __STRUCTURE_PACKING__;

typedef struct _tagEDIDV2STRUC EDIDV2STRUC;
typedef EDIDV2STRUC FAR *LPEDIDV2STRUC;


struct  _tagTIMINGCODES
{
    ULONG   dwNumLuminanceTables;
    ULONG   dwSizeLuminanceTables;
    ULONG   dwNumFreqRanges;
    ULONG   dwNumRangeLimits;
    ULONG   dwNumTimingCodes;
    ULONG   dwNumDetailedTimings;
} __STRUCTURE_PACKING__;

typedef struct _tagTIMINGCODES TIMINGCODES;
typedef TIMINGCODES FAR *LPTIMINGCODES;


struct  _tagDISPLAYTIMINGRANGE
{
    UCHAR   bHiMinVert;
    UCHAR   bHiMaxVert;
    UCHAR   bHiMinHorz;
    UCHAR   bHiMaxHorz;
    UCHAR   bLoHV;
    UCHAR   bLoMinPixClock;
    UCHAR   bLoMaxPixClock;
    UCHAR   bHiMinMaxPixClock;
}  __STRUCTURE_PACKING__;

typedef struct _tagDISPLAYTIMINGRANGE DISPLAYTIMINGRANGE;
typedef DISPLAYTIMINGRANGE FAR *LPDISPLAYTIMINGRANGE;


struct  _tagDETAILEDTIMINGRANGE
{
    USHORT  wMinPixelClock;
    UCHAR   bLowMinHBlank;
    UCHAR   bLowMinVBlank;
    UCHAR   bHiMinHVBlank;
    UCHAR   bMinHSyncOffsetFromBlankStart;
    UCHAR   bLowMinHSyncPulseWidth;
    UCHAR   bLowMinVSyncPulseOffsetAndWidth;
    UCHAR   bHiMinSyncPulseOffsetsAndWidths;
    USHORT  wMaxPixelClock;
    UCHAR   bLowMaxHBlank;
    UCHAR   bLowMaxVBlank;
    UCHAR   bHiMaxHVBlank;
    UCHAR   bMaxHSyncOffset;
    UCHAR   bLowMaxHSyncPulseWidth;
    UCHAR   bLowMaxVSyncPulseOffsetAndWidth;
    UCHAR   bHiMaxSyncPulseOffsetsAndWidths;
    UCHAR   bLowHImageSizeInMM;
    UCHAR   bLowVImageSizeInMM;
    UCHAR   bHiHVImageSizeInMM;
    UCHAR   bLowHActive;
    UCHAR   bLowVActive;
    UCHAR   bHiHVActive;
    UCHAR   bHBorder;
    UCHAR   bVBorder;
    UCHAR   bFlags;
}   __STRUCTURE_PACKING__;

typedef struct _tagDETAILEDTIMINGRANGE DETAILEDTIMINGRANGE;
typedef DETAILEDTIMINGRANGE FAR *LPDETAILEDTIMINGRANGE;


extern int CFUNC EdidFindDetailedMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                            LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC EdidFindStandardMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                            LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC EdidFindEstablishedMode (LPCHAR lpEdidBuffer,
                            ULONG dwEdidSize, LPMODEINFO lpModeDesc,
                            LPMODEOUT lpModeOut);
extern int CFUNC EdidIsGtfMonitor (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine returns TRUE if the Monitor is a GTF monitor and
// FALSE, otherwise. Remember that the DOCS said that technically,
// a monitor is not fully GTF compliant unless in addition to the
// GTF bit, there was also a MONITORRANGELIMITS structure.

extern int CFUNC EdidGetMonitorLimits (LPCHAR lpEdidBuffer,
                            ULONG dwEdidSize, LPMONITORLIMITS lpML);
// This routine gets a MONITORLIMITS structure out of the EDID if
// the EDID is the correct version and a MONITORLIMITS structure
// is present (the structure is optional in v 2.x). If one is
// obtained the function returns TRUE; else it returns FALSE.

extern int CFUNC EdidFindSameModeOrLargerWithHighestRR (LPCHAR lpEdidBuffer,
                    ULONG dwEdidSize, LPMODEINFO lpModeDesc);
// EdidFindModeHighestRR should find a the highest refresh rate in
// the detailed, established, or standard timing sections that has a
// resolution greater than or equal to the dwXRes and dwYRes in
// lpModeDesc. The refresh rate for that mode is returned. If there
// is no matching xres, yres, then 0 is returned.

extern int CFUNC EdidFindHighestRRinTable (LPMODESTRUC lpMS,
                    LPMODEINFO  lpModeDesc);
// EdidFindHighestRRinTable should return the highest refresh rate
// in the table passed in which corresponds to a resolution which is
// greater than or equal to the requested mode.

extern int CFUNC EdidFindLargestEdidMode (LPCHAR lpEdidBuffer,
                    ULONG dwEdidSize, LPMODEINFO lpModeInfo);
// EdidFindLargestEdidMode should return the largest XRes and YRes
// that can be found in the EDID.

extern int CFUNC EdidFindLargestModeinTable (LPMODESTRUC lpMS,
                    LPMODEINFO lpModeInfo);
// EdidFindLargestModeinTable should return the largest XRes and YRes
// that can be found in the table.

extern int CFUNC EdidCmpToLargestEdidMode (LPCHAR lpEdidBuffer,
                    ULONG dwEdidSize, LPMODEINFO lpModeDesc);
// The return value can be a logical OR of one of the first three
// flags with one of the second three flags with the last flag.
#define REQUESTED_MODE_SMALLER_XYRES_THAN_LARGEST_EDID_MODE 0x01
#define REQUESTED_MODE_SAME_XYRES_AS_LARGEST_EDID_MODE      0x02
#define REQUESTED_MODE_LARGER_XYRES_THAN_LARGEST_EDID_MODE  0x04

#define REQUESTED_MODE_SMALLER_PXCLK_THAN_LARGEST_EDID_MODE 0x08
#define REQUESTED_MODE_SAME_PXCLK_AS_LARGEST_EDID_MODE      0x10
#define REQUESTED_MODE_LARGER_PXCLK_THAN_LARGEST_EDID_MODE  0x20

#define REQUESTED_MODE_XYRES_EXACTLY_MATCHES_AN_EDID_MODE   0x40

extern int CFUNC EdidCheckIfModeIsSmaller (LPMODESTRUC lpMS,
                    LPMODEINFO  lpModeDesc);
// EdidCheckIfModeIsSmaller should return TRUE if an lpMS timing
// mode exists which is greater than or equal to the requested mode.

extern int CFUNC EdidFindTimingCodesHighestRR (LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPMODEINFO lpModeDesc,
                        LPMODEOUT lpModeOut);
// EdidTimingCodesHighestRR should find a mode in the timing codes
// section (only in version 2.X of the EDID) that matches the dwXRes
// and dwYRes in lpModeDesc and has the highest refresh rate. That
// mode should be returned in lpModeOut.

extern int CFUNC EdidGetVersion (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine should return the EDID version multiplied by 0x100.
// So, for example, version 1.10 should be returned as 0x110.

extern ULONG CFUNC EdidGetMonitorId (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// This routine should return the monitorID from the EDID. This is
// defined as a DWORD from high byte to low byte as follows:
// high byte of product code, low byte of product code, high byte of
// manufacturer code, low byte of manufacturer code. ASsemble these
// four bytes into a ULONG and return. If there is any kind of error
// then return XXXX_ID which is defined in restime.h  It means any
// monitor for which an EDID is not defined. Since you can't parse
// the EDID for some reason, this is a reasonable return value.

extern ULONG CFUNC EdidFindLargestPixelClock (LPCHAR lpEdidBuffer, ULONG dwEdidSize);
// Finds the EDID mode with the largest pixel clock and returns
// the pixel clock.

extern int CFUNC EdidFindExactModeWithHighestRR (LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPMODEINFO lpModeDesc);
// This routine searches for the highest refresh rate in the detailed,
// established, or standard timing sections that has a resolution exactly
// equal to the dwXRes and dwYRes in lpModeDesc. The refresh rate for that
// mode is returned. If there is no matching Xres, Yres, then 0 is returned.

#ifdef WINNT
// Restore the compiler's default specified packing mode (specified by /Zp).
// This directive needs the corresponding directive in the beginning of this file.
#pragma pack()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\DMT.C ===
/*
    FILE:   dmt.c
    DATE:   4/8/99

    This file is the generic entry point for the dmt modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "debug.h"

//*****************************************************************************
//
// VESA 1.0 rev 0.7 DMT timings
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7
// Monitor Timing Specifications.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity
// VSync polarity
//
// NOTE: Unlike GTF timings, DMT does not dictate zero border widths.
// Therefore we must include blank start and end positions.
//
MODESTRUC    DMTTimingTable[] =
{
    // Settings for 320x200 (mode doubled 640x400):
    //  NOTE: There is no 60Hz 320x200, so use 70Hz if anyone wants 60Hz
    320,200,60,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    320,200,70,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    320,200,85,832/2,640/2,672/2,736/2,832/2,445,400,401,404,445,3150/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 320x240 (mode doubled 640x480):
    320,240,60,800/2,648/2,656/2,752/2,792/2,525,488,490,492,517,2518/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,72,832/2,648/2,664/2,704/2,824/2,520,488,489,492,512,3150/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,75,840/2,640/2,656/2,720/2,840/2,500,480,481,484,500,3150/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    320,240,85,832/2,640/2,696/2,752/2,832/2,509,480,481,484,509,3600/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 400x300 (mode doubled 800x600):
    400,300,60,1056/2,800/2,840/2,968/2,1056/2,628,600,601,605,628,4000/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,72,1040/2,800/2,856/2,976/2,1040/2,666,600,637,643,666,5000/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,75,1056/2,800/2,816/2,896/2,1056/2,625,600,601,604,625,4950/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    400,300,85,1048/2,800/2,832/2,896/2,1048/2,631,600,601,604,631,5625/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 512x384 (mode doubled 1024x768):
    512,384,60,1344/2,1024/2,1048/2,1184/2,1344/2,806,768,771,777,806,6500/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    512,384,70,1328/2,1024/2,1048/2,1184/2,1328/2,806,768,771,777,806,7500/2,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    512,384,75,1312/2,1024/2,1040/2,1136/2,1312/2,800,768,769,772,800,7875/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    512,384,85,1376/2,1024/2,1072/2,1168/2,1376/2,808,768,769,772,808,9450/2,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x350:
    640,350,85,832,640,672,736,832,445,350,382,385,445,3150,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 640x400:
    640,400,60,800,640,656,752,288,449,400,412,414,449,2518,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE,
    640,400,85,832,640,672,736,832,445,400,401,404,445,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x480:
    640,480,60,800,648,656,752,792,525,488,490,492,517,2518,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,72,832,648,664,704,824,520,488,489,492,512,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,75,840,640,656,720,840,500,480,481,484,500,3150,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,85,832,640,696,752,832,509,480,481,484,509,3600,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 720x400:
    720,400,85,936,720,756,828,936,446,400,401,404,446,3550,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 720x480
    720,480,60,800,728,744,776,792,525,488,490,492,517,2518,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 800x600:
    800,600,56,1024,800,824,896,1024,625,600,601,603,625,3600,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,60,1056,800,840,968,1056,628,600,601,605,628,4000,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,72,1040,800,856,976,1040,666,600,637,643,666,5000,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,75,1056,800,816,896,1056,625,600,601,604,625,4950,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,85,1048,800,832,896,1048,631,600,601,604,631,5625,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1024x768:
    1024,768,60,1344,1024,1048,1184,1344,806,768,771,777,806,6500,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,70,1328,1024,1048,1184,1328,806,768,771,777,806,7500,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,75,1312,1024,1040,1136,1312,800,768,769,772,800,7875,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1024,768,85,1376,1024,1072,1168,1376,808,768,769,772,808,9450,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1152x864:
    1152,864,75,1600,1152,1216,1344,1600,900,864,865,868,900,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1280x960:
    1280,960,60,1800,1280,1376,1488,1800,1000,960,961,964,1000,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,960,85,1728,1280,1344,1504,1728,1011,960,961,964,1011,14850,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1280x1024:
    1280,1024,60,1688,1280,1328,1440,1688,1066,1024,1025,1028,1066,10800,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,1024,75,1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1280,1024,85,1728,1280,1344,1504,1728,1072,1024,1025,1028,1072,15750,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1600x1200:
    1600,1200,60,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,16200,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,65,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,17550,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,70,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,18900,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,75,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,20250,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1600,1200,85,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,22950,
        BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1792x1344:
    1792,1344,60,2448,1792,1920,2120,2448,1394,1344,1345,1348,1394,20475,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1792,1344,75,2456,1792,1888,2104,2456,1417,1344,1345,1348,1417,26100,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1856x1392:
    1856,1392,60,2528,1856,1952,2176,2528,1439,1392,1393,1396,1439,21825,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1856,1392,75,2560,1856,1984,2208,2560,1500,1392,1393,1396,1500,28800,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1920x1440:
    1920,1440,60,2600,1920,2048,2256,2600,1500,1440,1441,1444,1500,23400,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1920,1440,75,2640,1920,2064,2288,2640,1500,1440,1441,1444,1500,29700,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    // Flag end of table
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00
};
                   
/*
    Function:   DmtFindMode

    Purpose:    This routine looks for a mode in the DMT list of modes.

    Arguments:  lpModeIn    ptr to MODEINFO structure
                lpModeOut   ptr to MODEOUT  structure

    Returns:    If an DMT mode is found which matches the dwXRes, dwYRes,
                dwBpp, and dwRefreshRate fields in the MODEINFO structure
                pointed to by lpModeIn, then fill in the timing parameters
                in the lpModeOut structure and return TRUE.

                If there is no DMT mode match found, then return FALSE.

    Preserve:   Do not change any fields in lpModeIn.
*/

int CFUNC
DmtFindMode (LPMODEINFO lpModeIn, LPMODEOUT lpModeOut)
{
    int     i;

    i = FindMode(DMTTimingTable, lpModeIn->dwXRes,
                    lpModeIn->dwYRes, lpModeIn->dwRefreshRate);

    // Was the mode found?
    if  (i < 0)
        return  (FALSE);

    // Yes! Convert to final output format
    SetupParamsForVidLutClass (DMTTimingTable + i, lpModeOut, lpModeIn);

    return  (TRUE);
}


/*
    Function:   DmtGetDmtTablePointer

    Purpose:    This routine returns a long pointer to the DMTTimingTable.

    Arguments:  lplpDmtTable    ptr to DMT Table pointer

    Returns:    Pointer to the DMT table.
*/

int CFUNC
DmtGetDmtTablePointer (LPMODESTRUC FAR *lplpDmtTable)
{

    *lplpDmtTable = DMTTimingTable;
    return  (TRUE);
}


/*
    DmtGetMaximumRefreshRate

    This routine calculates the maximum refresh rate for the target mode
    specified given the maimum XRes and YRes, and the maximum horizontal
    and vertical frequencies.

*/

int CFUNC
DmtGetMaximumRefreshRate (ULONG dwXRes, ULONG dwYRes, ULONG dwPixelClk,
                          ULONG *dwRefreshRate)
{
    ULONG   i;

    // Assume at least 60 Hz.
    *dwRefreshRate = 60;

    i = FindModeWithoutRR(DMTTimingTable, dwXRes, dwYRes);

    // Was the mode found?
    if  (i < 0)
        return  (FALSE);

    // Find the mode with the greatest refresh rate which has a pixel
    // clock less than or equal to dwPixelClock.
    for (;DMTTimingTable[i].wHorizVisible != 0x00; i++)
    {
        if ((DMTTimingTable[i].wHorizVisible == (USHORT) dwXRes) &&
            (DMTTimingTable[i].wVertVisible == (USHORT) dwYRes))
        {
            if ((ULONG)DMTTimingTable[i].wDotClock <= dwPixelClk)
                *dwRefreshRate = (ULONG) DMTTimingTable[i].wRefresh;
        }
    }

    return  (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\digmode.c ===
/*
    FILE:   digmode.c
    DATE:   4/8/99

    This file contains the code for mode setting/determination
    ona CRT or FLAT PANEL.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "digmode.h"
#include "dmt.h"
#include "edid.h"
#include "gtf.h"
#include "gtfmath.h"
#include "osapi.h"

#define     BACKOFF_MODE        0x01
#define     GOT_TIMINGS         0x02
#define     RANGE_CHECK_MODE    0x04

/*==========================================================================
    Function:   FindDigModeEntry

    Purpose:    Finds a set of timings for a mode for a CRT or DFP
                that will work on the device.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpDispData      ptr to DISPDATA struct descirbing board
                lpModeOrig      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for final
                                mode decided upon (not necessarily the
                                same mode as given by lpModeOrig)
                lpModeList      ptr to a MODEENTRY array -- master mode list
                lpRTList        ptr to a RESTIME array -- R&T list

    Returns:    some bitwise ORing of the flags in modeext.h
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
===========================================================================*/
int CFUNC
FindDigModeEntry (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeOrig,
    LPMODEOUT   lpModeOut,
    LPMODEENTRY lpModeList,
    LPRESTIME   lpRTList)
{
    int             i, nFlag, nIndex, bDoneRT, iRRFlag;
    MODEINFO        ModeDesc, LimitMode;
    RTMODE          sRTMode;
    ULONG           dwMonitorID, dwMemoryUsed, dwPitch;
    ULONG           dwDacSpeedInHertz, dwDacSpeedLimitInHertz;
    ULONG           dwEdidModeCompareFlag;
    USHORT          wActFlags;
    ULONG           wAllowAllModes;
    MONITORLIMITS   sML;

    // Put out a bit of useful logging information.
    DBG_PRINT0(DL_0, "\r\nEntering FindDigModeEntry.");

    // Make a copy so we can modify the mode as we go along without
    // changing the original requested mode.
    ModeDesc = lpModeOrig[0];

    wAllowAllModes = GetAllowAllModesFlag(lpDispData);

  do
  {
    // We will be modifying this as we go along.
    wActFlags = RANGE_CHECK_MODE;
    dwEdidModeCompareFlag = 0;

    // Decrease refresh rate in BackOffDigModeEntry() by default.
    iRRFlag = 1;

    /////////////////////////////////////////////////////////////////
    // First, see if this mode is in the master mode list
    DBG_PRINT0(DL_1, "\r\nSearching for Mode in Master Mode List.");
    DBG_PRINT1(DL_1, "\r\nXRes = %ld", ModeDesc.dwXRes);
    DBG_PRINT1(DL_1, "\r\nYRes = %ld", ModeDesc.dwYRes);
    DBG_PRINT1(DL_1, "\r\nBpp  = %ld", ModeDesc.dwBpp);
    DBG_PRINT1(DL_1, "\r\nRefR = %ld", ModeDesc.dwRefreshRate);
    if (!wAllowAllModes)
    {
        for (i = 0; lpModeList[i].dwXRes != 0; i++)
        {
            if  ((lpModeList[i].dwXRes == ModeDesc.dwXRes) &&
                 (lpModeList[i].dwYRes == ModeDesc.dwYRes) &&
                 (lpModeList[i].dwBpp  == ModeDesc.dwBpp)  &&
                 (lpModeList[i].dwRefreshRate  == ModeDesc.dwRefreshRate))
                break;
        }

        // Did we find the mode in the list?
        if  (lpModeList[i].dwXRes == 0)
        {
            DBG_PRINT0(DL_1, "\r\nFound Mode in Master List.");
            wActFlags |= BACKOFF_MODE;
        }
    }
    /////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    if  (!(wActFlags & BACKOFF_MODE) && (dwEdidSize != 0))
    {
        // For many things that happen later, we will need information
        // about how the current mode comares to any EDID modes.
        dwEdidModeCompareFlag = EdidCmpToLargestEdidMode (lpEdidBuffer,
                                                dwEdidSize, &ModeDesc);
    }
    /////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // NO EDID AND NO INF blocks certain modes
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize == 0) &&
          (lpDispData->dwMonitorInfType != SPECIFIC_DEVICE))
    {
        if  (ModeDesc.MIDevData.cType == DEVTYPE_CRT)
        {
            // If the CRT has no inf and no edid, then we
            // check the registry to see what the upper limit
            // should be in this situation.
            if  (GetMonitorLimitMode (lpDispData, &LimitMode))
            {
                if  ((ModeDesc.dwRefreshRate > LimitMode.dwRefreshRate) ||
                     (ModeDesc.dwXRes > LimitMode.dwXRes) ||
                     (ModeDesc.dwYRes > LimitMode.dwYRes))
                {
                    wActFlags |= BACKOFF_MODE;
                }
                else
                {
                    wActFlags &= ~RANGE_CHECK_MODE;
                }
            }
            else
            {
                wActFlags &= ~RANGE_CHECK_MODE;
            }
        }

        if  (ModeDesc.MIDevData.cType == DEVTYPE_DFP)
        {
            // If the DFP has no inf and no edid, then we block any
            // refreshrate higher than 60Hz and block all resolutions
            // higher than 1024x768.
            if  ((ModeDesc.dwRefreshRate > 60) ||
                 (ModeDesc.dwXRes > 1024) ||
                 (ModeDesc.dwYRes > 768))
            {
                wActFlags |= BACKOFF_MODE;
            }
            else
            {
                wActFlags &= ~RANGE_CHECK_MODE;
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // NO EDID AND YES INF means trust the INF on everything.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize == 0) &&
          (lpDispData->dwMonitorInfType == SPECIFIC_DEVICE))
    {
        // Nothing to do here right now.
        // We just assume that whatever we are asked to set
        // can be done because Windows wouldn't call us with
        // some mode that is not in the .inf.
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // YES EDID AND NO INF means trust the EDID on everything.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize != 0) &&
          (lpDispData->dwMonitorInfType != SPECIFIC_DEVICE))
    {
        // Does this EDID have a range limits descriptor?
        // If it does, then we can keep going because the range limit
        // check that happens later will catch unsettable modes.
        if  (!EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &sML))
        {
            // No range limits. Is the requested mode greater than
            // all modes in the EDID? If so, then backoff.
            if  (dwEdidModeCompareFlag &
                (REQUESTED_MODE_LARGER_XYRES_THAN_LARGEST_EDID_MODE |
                 REQUESTED_MODE_LARGER_PXCLK_THAN_LARGEST_EDID_MODE))
            {
                // This EDID has no range limits and the requested
                // mode is larger than all the EDID modes.
                wActFlags |= BACKOFF_MODE;
                DBG_PRINT0(DL_0, "\r\nNo monitor .inf installed, no range limits, no larger EDID mode. Failing.");
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // YES EDID AND YES INF is a bit tricky. If there are monitor
    // limits in the EDID, then we will trust those to block
    // modes that would exceed the monitor capabilities. If there
    // are no monitor range limits in the EDID, then we will allow
    // modes to get set that exceed the largest mode listed in the
    // EDID because at that point we will trust the .inf file to
    // know. The rule here is: Monitor range limits have top
    // priority, then the .inf file, and lastly largest mode
    // listed in the EDID.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize != 0) &&
          (lpDispData->dwMonitorInfType == SPECIFIC_DEVICE))
    {
        // Note that there is nothing to do here right now.
        // Why? Because, if there are range limits, they
        // will be checked against the timings later on.
        // If there aren't, then we are trusting the .inf file.
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    // We need to block certain modes on DFPs.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (ModeDesc.MIDevData.cType == DEVTYPE_DFP))
    {
        // We are failing any mode that is a multiple of
        // 480x360. This includes 960x720. These modes never
        // seem to sync on DFPs.
        if  ((((ModeDesc.dwXRes / 480) * 480) == ModeDesc.dwXRes) &&
             (((ModeDesc.dwYRes / 360) * 360) == ModeDesc.dwYRes))
            wActFlags |= BACKOFF_MODE;

        if  (dwEdidModeCompareFlag &
            (REQUESTED_MODE_LARGER_XYRES_THAN_LARGEST_EDID_MODE |
             REQUESTED_MODE_LARGER_PXCLK_THAN_LARGEST_EDID_MODE))
        {
            wActFlags |= BACKOFF_MODE;
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // We need to block certain modes according to restriction
    // and timing strings.

    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE))
    {
        // See if we find a matching R&T string
        sRTMode.dwXRes = ModeDesc.dwXRes;
        sRTMode.dwYRes = ModeDesc.dwYRes;
        sRTMode.dwBpp  = ModeDesc.dwBpp;
        sRTMode.dwRefreshRate = ModeDesc.dwRefreshRate;

        if  (dwEdidSize)
            dwMonitorID = EdidGetMonitorId (lpEdidBuffer, dwEdidSize);
        else
            dwMonitorID = UKWN_ID;

        for (nIndex = 0, bDoneRT = FALSE; !bDoneRT;)
        {
            nIndex = RTFindNextMatchingString (lpRTList, nIndex + 1,
                        lpDispData, &sRTMode, dwMonitorID);

            if  (nIndex != RTERR_NOT_FOUND)
            {
                DBG_PRINT1(DL_0, "\r\nFound R&T string matching board data # %ld", (ULONG) nIndex);

                // There was. Let's see what that tells us.
                nFlag = ProcessRTWithDigModeEntry (lpDispData,
                                lpEdidBuffer, dwEdidSize,
                                lpRTList + nIndex, &ModeDesc, lpModeOut);

                // > 0 means that the R&T string accepted the mode and
                // we have a set of timings in lpModeOut. We're done!
                if  (nFlag > 0)
                {
                    wActFlags |= GOT_TIMINGS;
                    bDoneRT = TRUE;
                }

                if  (nFlag == 2)
                    wActFlags &= ~RANGE_CHECK_MODE;

                // < 0 means that this mode was explicitly rejected by
                // the R&T string -- probably a NONE in the Timing
                // Standard field. We need to back off the mode.
                if  (nFlag < 0)
                {
                    wActFlags |= BACKOFF_MODE;
                    bDoneRT = TRUE;
                }
            }
            else
                bDoneRT = TRUE;
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // At this point, check to see if we want to override any
    // timing standards that were already selected.
    if  (!(wActFlags & BACKOFF_MODE) && !(wActFlags & GOT_TIMINGS))
    {
        nFlag = CheckTimingStandardOverride (lpEdidBuffer, dwEdidSize,
                                    lpDispData, &ModeDesc, lpModeOut);
        if  (nFlag > 0)
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nOverride Timing Found!");
        }

        if  (nFlag == 2)
            wActFlags &= ~RANGE_CHECK_MODE;
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // If an R&T string established the timing parameters, we
    // would not have gotten here. So at this point, just use
    // the "normal" logic to get the timing parameters.

    if  ((!(wActFlags & BACKOFF_MODE)) && !(wActFlags & GOT_TIMINGS) && (dwEdidSize == 0))
    {
        if  (DmtFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            wActFlags |= RANGE_CHECK_MODE;
            DBG_PRINT0(DL_0, "\r\nDmt timing found.");
        }

        if  (!(wActFlags & GOT_TIMINGS))
        {
            if  (GtfFindMode (&ModeDesc, lpModeOut))
            {
                wActFlags |= GOT_TIMINGS;
                wActFlags |= RANGE_CHECK_MODE;
                DBG_PRINT0(DL_0, "\r\nGtf timing found.");
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // If an R&T string established the timing parameters, we
    // would not have gotten here. So at this point, just use
    // the "normal" logic to get the timing parameters.

    if  ((!(wActFlags & BACKOFF_MODE)) && (!(wActFlags & GOT_TIMINGS)) && (dwEdidSize != 0))
    {
        if  (EdidFindDetailedMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidDetailedTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  (EdidFindStandardMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidStandardTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  (EdidFindEstablishedMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidEstablishedTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  ((EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize)) && GtfFindMode (&ModeDesc, lpModeOut)
                  && (ModeDesc.dwXRes > 400) && (ModeDesc.dwYRes > 300))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nGtf timing found.");
        }
        else if  (DmtFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nDmt timing found.");
        }
        else if  (GtfFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nGtf timing found.");
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    if  (!(wActFlags & BACKOFF_MODE) && (wActFlags & GOT_TIMINGS))
    {
        if (!wAllowAllModes)
        {
            // We weren't explicitly asked to back off and we have some
            // timings, so range check them if requested.
            if  (!(wActFlags & RANGE_CHECK_MODE) ||
                (iRRFlag = ModeWithinMonitorTimingLimits (lpDispData, lpModeOut, lpEdidBuffer, dwEdidSize)) == 0)
            {
                // Now verify that there is enough memory and that
                // the DAC is fast enough to handle the mode.
                GetPitchAndSize (lpDispData, ModeDesc.dwXRes,
                                    ModeDesc.dwYRes, ModeDesc.dwBpp,
                                    &dwPitch, &dwMemoryUsed);
                dwDacSpeedInHertz = Multiply32By32 (lpModeOut->dwPixelClock, 10000);

                // Get the dac speed limit for the given pixel depth
                if  (ModeDesc.dwBpp == 8)
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz8bpp;

                if  ((ModeDesc.dwBpp == 16) || (ModeDesc.dwBpp == 15))
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz16bpp;

                if  (ModeDesc.dwBpp == 32)
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz32bpp;

                if  ((lpDispData->dwVideoMemoryInBytes >= dwMemoryUsed) &&
                     (dwDacSpeedLimitInHertz >= dwDacSpeedInHertz))
                    return  (GetModeFlags (lpModeOrig, &ModeDesc));
                else
                {
		    iRRFlag = 1;
                    wActFlags |= BACKOFF_MODE;
                }
            }
            else
            {
                wActFlags |= BACKOFF_MODE;
            }
        }
        else
            return  (GetModeFlags (lpModeOrig, &ModeDesc));
    }

    if  ((wActFlags & BACKOFF_MODE) || !(wActFlags & GOT_TIMINGS))
    {
        // If we are directed to backoff explicitly, or we didn't
        // find any timings, then go ahead and backoff.
        if  (!BackOffDigModeEntry (lpModeList, &ModeDesc, lpModeOrig, iRRFlag))
        {
            // Just return safe settings if we couldn't back off
            return  (GetSafeTiming (&ModeDesc, lpModeOut));
        }
    }
    /////////////////////////////////////////////////////////////

  } while (TRUE);

}


/*==========================================================================
    Function:   CheckTimingStandardOverride

    Purpose:    Checks to see if we are supposed to use a particular
                timing standard (like DMT or GTF). If we are, sees if
                there is a set of timings to match the requested mode.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpDispData      ptr to DISPDATA struct descirbing board
                lpModeDesc      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for
                                lpModeDesc mode if needed.

    Returns:    > 0     then a timing standard override was requested
                        and lpModeOut has the set of timings for the
                        mode passed in in lpModeDesc
                        if 1 then range check mode
                        if 2 then dont range check mode
                0       Either no timing standard override was requested
                        or one was but there was no set of timings in
                        that timing standard for the mode given by
                        lpModeDesc

    Preserve:
===========================================================================*/
int CFUNC
CheckTimingStandardOverride (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut)
{
    ULONG   dwTimingStandard;
    MODEOUT sModeOutTemp;
    int     nRet;

    dwTimingStandard = GetTimingStandardOverride (lpDispData);

    if  (dwTimingStandard == DMTV_ID)
    {
        if  (DmtFindMode (lpModeDesc, lpModeOut))
        {
            nRet = 1;

            if  (dwEdidSize)
            {
                if  (EdidFindStandardMode (lpEdidBuffer, dwEdidSize,lpModeDesc,lpModeOut))
                    nRet = 2;
                
                if  (EdidFindEstablishedMode (lpEdidBuffer, dwEdidSize, lpModeDesc, lpModeOut))
                    nRet = 2;
            }
    
            DBG_PRINT0(DL_0, "\r\nDmt Timing Found!");
            return  (nRet);
        }
    }

    if  (dwTimingStandard == GTFV_ID)
    {
        if  (GtfFindMode (lpModeDesc, lpModeOut))
        {
            nRet = 1;

            if  (EdidFindStandardMode (lpEdidBuffer, dwEdidSize, lpModeDesc, &sModeOutTemp))
                if  (!DmtFindMode (lpModeDesc, &sModeOutTemp))
                    nRet = 2;

            DBG_PRINT0(DL_0, "\r\nGtf Timing Found!");
            return  (nRet);
        }
    }

    return  (FALSE);
}



/*==========================================================================
    Functiom:   ProcessRTWithDigModeEntry

    Purpose:    Checks to see if we are supposed to use a particular
                timing standard (like DMT or GTF). If we are, sees if
                there is a set of timings to match the requested mode.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpRTList        ptr to RESTIME structure we are processing
                lpModeDesc      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for
                                lpModeDesc mode if needed.

    Returns:
        There are three return values possible.
        > 0     This indicates that the mode was accepted by the R&T
                string and a set of timings have been placed in
                lpModeOut.
                If 2 then mode must not be range checked
                if 1, then mode should be range checked
        = 0     This R&T string did not apply to the lpModeDesc.
        < 0     The lpModeDesc mode was rejected by the R&T string.

    Preserve:
===========================================================================*/
int CFUNC
ProcessRTWithDigModeEntry (
            LPDISPDATA  lpDispData,
            LPCHAR      lpEdidBuffer,
            ULONG       dwEdidSize,
            LPRESTIME   lpRTList,
            LPMODEINFO  lpModeDesc,
            LPMODEOUT   lpModeOut)
{
    int i;

    // R&T string applies to this mode.
    // Let's walk through the timing standards.
    for (i = 0; i < MAX_DOT_FIELDS; i++)
    {
        switch (lpRTList->dwTimingStandard[i])
        {
            case NONE_ID:
                // This mode is prohibited. Fail it.
                DBG_PRINT0(DL_0, "\r\nR&T string specifies NONE timing.");
                return  (-1);

            case EDID_ID:
                DBG_PRINT0(DL_0, "\r\nR&T string specifies EDID timing.");

                if  (dwEdidSize)
                {
                    // Use an EDID detailed timing if present
                    if  (EdidFindDetailedMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidDetailedTiming Found!");
                        return  (1);
                    }

                    if  (EdidFindStandardMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidStandardTiming Found!");
                        return  (1);
                    }

                    if  (EdidFindEstablishedMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidEstablishedTiming Found!");
                        return  (1);
                    }
                }
                break;

            case DMTV_ID:
            case DMTR_ID:
                // Use a DMT timing if present
                DBG_PRINT0(DL_0, "\r\nR&T string specifies DMT timing.");

                if  (DmtFindMode (lpModeDesc, lpModeOut))
                {
                    if  (lpRTList->dwTimingStandard[i] == DMTR_ID)
                    {
                        // If there is an EDID, then make sure we
                        // are within the monitor limits
                        if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                            lpModeOut, lpEdidBuffer,
                                            dwEdidSize))
                        {
                            DBG_PRINT0(DL_0, "\r\nDmt Timing rejected by monitor limits!");
                            break;
                        }
                    }

                    DBG_PRINT0(DL_0, "\r\nDmt Timing Found!");
                    if  (lpRTList->dwTimingStandard[i] == DMTR_ID)
                        return  (1);
                    else
                        return  (2);
                }
                break;

            case GTFV_ID:
            case GTFR_ID:
                // Use GTF unless we couldn't get an
                // Edid or unless the Edid indicated
                // the monitor was not GTF.
                DBG_PRINT0(DL_0, "\r\nR&T string specifies GTF timing.");

                if  (!dwEdidSize)
                {
                    DBG_PRINT0(DL_0, "\r\nNo Edid: Cannot use GTFV timing.");
                    break;
                }

                if  (!EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize))
                {
                    DBG_PRINT0(DL_0, "\r\nNot GTF monitor: Cannot use GTFV timing.");
                    break;
                }

            // Fall through to FGTF case
            case FGTF_ID:
            case FGTR_ID:
                // Use a GTF timing regardless
                DBG_PRINT0(DL_0, "\r\nR&T string specifies FGTF timing.");

                if  (GtfFindMode (lpModeDesc, lpModeOut))
                {
                    if  ((lpRTList->dwTimingStandard[i] == GTFR_ID) ||
                         (lpRTList->dwTimingStandard[i] == FGTR_ID))
                    {
                        // If there is an EDID, then make sure we
                        // are within the monitor limits
                        if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                            lpModeOut, lpEdidBuffer,
                                            dwEdidSize))
                        {
                            DBG_PRINT0(DL_0, "\r\nGtf Timing rejected by monitor limits!");
                            break;
                        }
                    }

                    // If there is no edid, or there are no
                    // monitor limits, or the GTF mode is
                    // within the monitor limits, then we
                    // have found the mode and are done!
                    DBG_PRINT0(DL_0, "\r\nGtf Timing found!");
                    if  ((lpRTList->dwTimingStandard[i] == FGTR_ID) ||
                         (lpRTList->dwTimingStandard[i] == GTFR_ID))
                        return  (1);
                    else
                        return  (2);
                }
                break;

            case OEMX_ID:
            case OEMR_ID:
                // Use the OEM timing in the TimingParameters
                DBG_PRINT0(DL_0, "\r\nR&T string specifies OEM timing.");

                lpModeOut[0] = lpRTList->sModeOut;

                if  (lpRTList->dwTimingStandard[i] == OEMR_ID) 
                {
                    // If there is an EDID, then make sure we
                    // are within the monitor limits
                    if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                        lpModeOut, lpEdidBuffer,
                                        dwEdidSize))
                    {
                        DBG_PRINT0(DL_0, "\r\nOem Timing rejected by monitor limits!");
                        break;
                    }
                }

                DBG_PRINT0(DL_0, "\r\nOem Timing Found!");
                if  (lpRTList->dwTimingStandard[i] == OEMR_ID)                
                    return  (1);
                else
                    return  (2);

            default:
                // Bad Timing Standard Encountered
                DBG_PRINT0(DL_0, "\r\nBad Timing Standard. Ignoring it.");
        }
    }

    return  (0);
}


/*==========================================================================
;
; Function: BackOffDigModeEntry
;
; Purpose:  This routine backs off the current mode, first by the
;           refresh rate. If it can't do that, then it restores the
;           original refresh rate and backs off on the spatial
;           resolution. If it can't do that, then it returns a failure
;           code.
;
; Arguments:
;       lpModeList  LPMODEENTRY ptr points to mode list used to
;                   fetch next lower refresh rate/resolution from
;       lpModeDesc  Description of mode from which we should back off.
;       lpModeOrig  This was the original mode that the user called
;                   the modeset DLL with originally. It can be used
;                   in the back off algorithm as well. For example
;                   when the refresh rate cannot be backed off
;                   anymore, it may be desirable to restore the
;                   original refresh rate the user requested and
;                   then back off the reolution one notch.
;
; Returns:      0   this indicates that there was no mode that could
;                   be backed off to. We are at the end of our rope.
;               1   then lpModeDesc has been modified to hold the new
;                   backed off mode.
;
; Preserve:     All registers
;==========================================================================*/
int CFUNC
BackOffDigModeEntry (
        LPMODEENTRY lpModeList,
        LPMODEINFO  lpModeDesc,
        LPMODEINFO  lpModeOrig,
	int         iRRFlag)
{
    if(iRRFlag < 0 && FindNextLargerRefreshRate (lpModeList, lpModeDesc))
    {
	DBG_PRINT0(DL_0, "\r\nBacking off to mode with a larger refresh rate.");
    }
    else if (iRRFlag > 0 && FindNextSmallerRefreshRate (lpModeList, lpModeDesc))
    {
	DBG_PRINT0(DL_0, "\r\nBacking off to mode with a lower refresh rate.");
    }
    else
    {
        // We couldn't find a the same resolution and pixel depth
        // with a lower refresh rate. This may happen, for example,
        // if we were already at 60Hz. Let's reset the refresh rate
        // to what was originally requested and find the next lower
        // spatial resolution resolution at the same pixel depth.
        lpModeDesc[0].dwRefreshRate = lpModeOrig[0].dwRefreshRate;

        if  (FindNextSmallerResolution (lpModeList, lpModeDesc))
        {
            DBG_PRINT0(DL_0, "\r\nBacking off to mode with a lower resolution.");
        }
        else
        {
            // OK, if this doesn't happen, then we had already
            // scanned down from the mode/refresh rate requested
            // through all all lower resolutions/refresh rates and
            // none of them were settable.
            // Inidicate that there are no more modes to try.
            return  (FALSE);
        }
    }

    return  (TRUE);
}


/*==========================================================================
    Function:   ModeWithinMonitorTimingLimits

    Purpose:    Checks to see if a given mode is within the timing
                limits for the monitor.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpModeOut       timings to check

    Returns:    0   mode is within monitor limits
                #0   mode is not within limits
		( > 0 - try to decrease refresh rate first )

    Preserve:
===========================================================================*/
int CFUNC
ModeWithinMonitorTimingLimits (
                LPDISPDATA  lpDispData,
                LPMODEOUT lpModeOut,
                LPCHAR    lpEdidBuffer,
                ULONG     dwEdidSize)
{
    ULONG           dwPixelClockInHertz;
    MONITORLIMITS   sML;
    ULONG           dwHorzRate, dwMaxXRes, dwMaxYRes;

    if  ((dwEdidSize == 0) ||
         (!EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &sML)))
    {
        if  ((lpDispData->dwMonitorInfType != SPECIFIC_DEVICE) ||
             (!GetMonitorInfRangeLimits (lpDispData, &sML, &dwMaxXRes, &dwMaxYRes)))
        {
            // There are no monitor limits, from either an EDID
            // or an .inf, so just say YES.
            return  0;
        }
    }


    // First check the pixel clock
    dwPixelClockInHertz = Multiply32By32 (lpModeOut->dwPixelClock, 10000);
    if  (dwPixelClockInHertz > sML.dwMaxPixelClock)
        return  1;

    // If the maximum vertical is not zero, check the vertical
    // refresh rate directly. If the maximum vertical refresh rate
    // is zero, there are no limits so skip check.
    if (sML.dwMaxVert)
    {
        // If the minimum vertical is the same as the maximum vertical,
        // only check against the maximum vertical.
        if (sML.dwMinVert == sML.dwMaxVert)
        {
            if (lpModeOut->wRefreshRate > sML.dwMaxVert)
                return 1;
        }
        else
        {
            if  (lpModeOut->wRefreshRate < sML.dwMinVert)
		return -1;
            if  (lpModeOut->wRefreshRate > sML.dwMaxVert)
		return 1;
        }
    }

    // The horizontal refresh rate is the scan rate per frame.
    dwHorzRate = Divide32By32 (dwPixelClockInHertz + ((ULONG)lpModeOut->wHTotal / 2), (ULONG)lpModeOut->wHTotal);

    // Use integer part only
    dwHorzRate = Divide32By32(dwHorzRate , 1000) ;
    dwHorzRate = Multiply32By32(dwHorzRate , 1000) ;

    // If the maximum horizontal is not zero, check the horizontal
    // refresh rate directly. If the maximum horizontal refresh rate
    // is zero, there are no limits so skip check.
    if (sML.dwMaxHorz)
    {
        if (sML.dwMinHorz == sML.dwMaxHorz)
        {
            if  (dwHorzRate > sML.dwMaxHorz)
                return 1;
        }
        else
        {
            if  (dwHorzRate < sML.dwMinHorz)
                return -1;
	    if  (dwHorzRate > sML.dwMaxHorz)
                return 1;
        }
    }

    return  0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\tvmode.c ===
/*
    FILE:   tvmode.c
    DATE:   4/8/99

    This file contains the high level logic for the tv modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "tvmode.h"
#include "dmt.h"
#include "gtf.h"

extern int CFUNC IsTvModeAccepted (LPDISPDATA lpDispData,
                                   LPMODEINFO lpModeDesc, LPRESTIME lpRTList);

extern int CFUNC SetupParamsForVidLutClass (LPMODESTRUC         lpMS,
                                            LPMODEOUT           lpModeOut,
                                            LPMODEINFO          lpModeIn);

/*
    FindTVModeEntry

    Timing info for NTSC and PAL modes is always DMT. The thing
    to remember here is that both are restricted to be 800x600
    or less.
*/

int CFUNC
FindTVModeEntry (
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEENTRY lpModeList,
    LPRESTIME   lpRTList)
{
    int         nRet, nIsNtsc;
    ULONG       MaxXRes;
    ULONG       MaxYRes;
    MODEINFO    ModeDesc;

    // Copy to a local
    MaxXRes = (lpDispData->dwMaxTVOutResolution >> 16) & 0xffff;
    MaxYRes = lpDispData->dwMaxTVOutResolution & 0xffff;
    ModeDesc = lpModeDesc[0];

    // Since this is a TV, which is a fixed frequency device, force the
    // refresh rate to appropriate refresh rate.
    if  ((lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCM) ||
         (lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCJ))
        nIsNtsc = TRUE;
    else
        nIsNtsc = FALSE;


    if  (nIsNtsc)
    {
        ModeDesc.dwRefreshRate = 60;
    }
    else
    {
        // 60 Hz works, 50 Hz doesn't (on Bt869), don't know why
        ModeDesc.dwRefreshRate = 60;
    }

    // Set this up
    nRet = MODE_EXACT_MATCH;

    // If the input resolution is greater than 800x600,
    // then drop it to 800x600.
    if  ((ModeDesc.dwXRes > MaxXRes) || (ModeDesc.dwYRes > MaxYRes))
    {
        ModeDesc.dwXRes = MaxXRes;
        ModeDesc.dwYRes = MaxYRes;
        nRet |= MODE_RESOLUTION_ADJUSTED;
    }

    do
    {
        // Start with the current mode. See if we can set this mode.
        // To do this, we process the RTList and see if this mode is
        // allowed or restricted in some way. At the time of this
        // writing the only way to restrict a TV mode is if there is
        // a NONE in the TimingStandard field of an R&T string. Then
        // the mode is rejected. Let's see if this happens with the
        // requested mode.
        if  (IsTvModeAccepted (lpDispData, &ModeDesc, lpRTList))
        {
            // Great! Return appropriately.
            if  (!DmtFindMode (&ModeDesc, lpModeOut))
            {
                // Bt 868/9
                MODESTRUC ntscModeBt = {720,512,60,870,720,770,820,870,525,512,518,520,525,2738,
                                        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                MODESTRUC palModeBt = {720,544,60,840,720,770,820,840,550,544,546,548,550,2775,
                                       BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                // Chrontel 7007/8
                MODESTRUC ntscModeChrontel = {720,576,60,880,720,760,840,880,597,576,585,588,597,3150,
                                              BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};
                MODESTRUC palModeChrontel = {720,576,60,880,720,760,840,880,597,576,585,588,597,3150,
                                             BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE};

                MODESTRUC *pNtscMode, *pPalMode, *pMode;
                switch (lpDispData->dwTVEncoderType & 0xFF00) {
                case TV_ENCODER_BROOKTREE:
                    pNtscMode = &ntscModeBt;
                    pPalMode = &palModeBt;
                    break;
                case TV_ENCODER_CHRONTEL:
                default:
                    pNtscMode = &ntscModeChrontel;
                    pPalMode = &palModeChrontel;
                    break;
                }

                pMode = nIsNtsc ? pNtscMode : pPalMode;

                // safe mode is 720x480 on NTSC, or 720x576 on PAL
                SetupParamsForVidLutClass (pMode, lpModeOut, lpModeDesc);
	        if(lpModeOut->wXRes != lpModeDesc->dwXRes)
	            nRet |= MODE_RESOLUTION_ADJUSTED;
            }
            return  (nRet);
        }

        // The TV mode wasn't accepted. Go to the registry mode
        // list and get the next lower resolution mode at the
        // pixel depth requested. We shall try that for the TV.
        nRet |= MODE_RESOLUTION_ADJUSTED;

        if  (!FindNextSmallerResolution (lpModeList, &ModeDesc))
        {
            // OK, if this doesn't happen, then we are already at
            // the losest mode available. Use a safe setting.
            DBG_PRINT0(DL_0, "\r\nNo lower resolution found.");
            DBG_PRINT0 (DL_0, "\r\nFailing TV Timing Standards. Use Safe Settings.");
            nRet = GetSafeTiming (lpModeDesc, lpModeOut);
            return  (nRet);
        }
    }
    while (TRUE);
}


/*
    IsTvModeAccepted

    This routine determines whether the mode in lpModeDesc is
    a valid TV mode (PAL or NTSC as determined by lpModeDesc->dwDevType.)
*/
int CFUNC
IsTvModeAccepted (
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPRESTIME   lpRTList)
{
    int     nIndex, nIsNtsc;
    RTMODE  sRTMode;
    ULONG   dwMonitorID;

    // Start with the first restriction string
    nIndex = 1;

    if  ((lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCM) ||
         (lpModeDesc->MIDevData.cFormat == TVTYPE_NTSCJ))
        nIsNtsc = TRUE;
    else
        nIsNtsc = FALSE;

    do
    {
        // There is an R&T string for this graphics board.
        // Does this string also match the mode requested?
        sRTMode.dwXRes = lpModeDesc->dwXRes;
        sRTMode.dwYRes = lpModeDesc->dwYRes;
        sRTMode.dwBpp  = lpModeDesc->dwBpp;
        sRTMode.dwRefreshRate = lpModeDesc->dwRefreshRate;


	// Reject the modes 720x576 & 720x480 for unsupported encoders
	if  ((lpDispData->dwTVEncoderType & 0xFF00) != TV_ENCODER_BROOKTREE &&
         (lpDispData->dwTVEncoderType & 0xFF00) != TV_ENCODER_CHRONTEL &&
	      sRTMode.dwXRes == 720)
		return  (FALSE);

        if  (nIsNtsc)
	{
            dwMonitorID = NTSC_ID;

	    // Reject 720x576 for NTSC
//	    if(sRTMode.dwXRes == 720 && sRTMode.dwYRes == 576)
//		return  (FALSE);
	}
        else
	{
            dwMonitorID = PALX_ID;

	    // Reject 720x480 for PAL
//	    if(sRTMode.dwXRes == 720 && sRTMode.dwYRes == 480)
//		return  (FALSE);
	}

        // Find a restriction string that matches the board data.
        nIndex = RTFindNextMatchingString (lpRTList, nIndex,
                    lpDispData, &sRTMode, dwMonitorID);

        if  (nIndex == RTERR_NOT_FOUND)
        {
            // If there were no R&T strings found for the graphics board
            // installed, then the mode is OK.
            return  (TRUE);
        }

        // See if there is a NONE entry in the TimingStandard
        // Field. If there isn't then the mode is OK
        if  (RTRestrictByTimingStandard (lpRTList, nIndex, NONE_ID))
            return  (FALSE);

        // This R&T string did not prohibit this mode. However,
        // since there might be another R&T string that restricts
        // NTSC or PAL, we continue with the rest of the RTList.
        nIndex++;
    }
    while   (nIndex <= (int) lpRTList[0].dwXRes);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\gtfmath.c ===
/*
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtfmath.c (ported from gtfmath.asm)
;
; Purpose:      This file implements the GTF algorithm
;
;       Just some important comments and definitions extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
*/
#include "cmntypes.h"
#include "gtfmath.h"

/*
 * These math routines need to be defined in the OS specific code.
 */
float calcROUND(float);
float calcFLOOR(float);
float calcSQRT(float);

#define const_fZero                     0.0f
#define const_fZeroPointFour            0.4f
#define const_fZeroPointFive            0.5f
#define const_fOne                      1.0f
#define const_fOnePointEight            1.8f
#define const_fTwo                      2.0f
#define const_fThree                    3.0f
#define const_fEight                    8.0f
#define const_fTwenty                   20.0f
#define const_fForty                    40.0f
#define const_fOneHundred               100.0f
#define const_fOneHundredTwentyEight    128.0f
#define const_fTwoHundredFiftySix       256.0f
#define const_fFiveHundredFifty         550.0f
#define const_fSixHundred               600.0f
#define const_fOneThousand              1000.0f
#define const_fOneMillion               1000000.0f

static float    fTemp;
static float    fVLinesRnd;
static float    fAddrLinesPerFrame;
static float    fCellGran;
static float    fPixelFreq;
static float    fCharTime;
static float    fTopMarginLines;
static float    fBottomMarginLines;
static float    fVSyncPlusBackPorch;
static float    fMinPorch;
static float    fInterlace;
static float    fTotalLinesPerFrame;
static float    fTotalPixels;
static float    fTotalHTimeChars;
static float    fHPixelsRnd;
static float    fHAddrTime;
static float    fHAddrTimeChars;
static float    fHBlankPixels;
static float    fHBlank;
static float    fHBlankChars;
static float    fLeftMarginPixels;
static float    fRightMarginPixels;
static float    fHBlankPlusMargin;
static float    fHBlankPlusMarginChars;
static float    fActualDutyCycle;
static float    fBlankPlusMarginDutyCycle;
static float    fLeftMargin;
static float    fLeftMarginChars;
static float    fRightMargin;
static float    fRightMarginChars;
static float    fHSyncPercent;
static float    fHSyncPixels;
static float    fHFrontPorchPixels;
static float    fHBackPorchPixels;
static float    fHSyncChars;
static float    fHSync;
static float    fHFrontPorchChars;
static float    fHFrontPorch;
static float    fHBackPorchChars;
static float    fHBackPorch;
static float    fTotalVLines;
static float    fHPeriod;
static float    fVFramePeriod;
static float    fVFieldPeriod;
static float    fVAddrTimePerFrame;
static float    fVAddrTimePerField;
static float    fVOddBlankingLines;
static float    fVOddBlanking;
static float    fVEvenBlankingLines;
static float    fVEvenBlanking;
static float    fTopMargin;
static float    fVOddFrontPorch;
static float    fVOddFrontPorchLines;
static float    fVEvenFrontPorch;
static float    fVSyncRqd;
static float    fVSync;
static float    fVEvenBackPorch;
static float    fVBackPorch;
static float    fVEvenBackPorchLines;
static float    fVOddBackPorch;
static float    fBottomMargin;
static float    fMarginPercent;
static float    fMinVSyncPlusBackPorch;
static float    fGTF_M;
static float    fGTF_C;
static float    fGTF_J;
static float    fGTF_K;
static float    fGTF_CPrime;
static float    fGTF_MPrime;
static float    fVFieldRateRqd;
static float    fHPeriodEst;
static float    fVFieldRateEst;
static float    fVFieldRate;
static float    fVFrameRate;
static float    fTotalActivePixels;
static float    fIdealDutyCycle;
static float    fHFreq;
static float    fIdealHPeriod;
/*
;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
; Returns:      None
;
;==============================================================================
*/
static void SetupGTFConstants
(
    void
)
{
    /*
     * This is the size of the top (or bottom -- they are the same)
     * overscan area as a percentage of the total vertcical time.
     */
    fMarginPercent = const_fOnePointEight;
    /*
     * Number of pixels per character cell
     */
    fCellGran = const_fEight;
    /*
     * Minimum horizontal front porch in character cells and
     * minimum vertical front porch in scanlines (they are the same.)
     */
    fMinPorch = const_fOne;
    /*
     * Width of vsync pulse in scanlines
     */
    fVSyncRqd = const_fThree;
    /*
     * Width of the hsync pulse as a percentage of horizontal line time
     */
    fHSyncPercent = const_fEight;
    /*
     * minimum time for vertical sync plus back porch in microseconds
     */
    fMinVSyncPlusBackPorch = const_fFiveHundredFifty;
    /*
     * These apply to the Basic Blanking Duty Cycle Equation.
     * See the top of the file.
     */
    fGTF_M = const_fSixHundred;
    fGTF_C = const_fForty;
    fGTF_K = const_fOneHundredTwentyEight;
    fGTF_J = const_fTwenty;
    /*
     * This is forced by GTF definitions
     * C' = ((C - J) * (K / 256) + J
     *         fld     fGTF_K
     *         fdiv    fTwoHundredFiftySix
     *         fld     fGTF_C
     *         fsub    fGTF_J
     *         fmulp   ST(1),ST(0)
     *         fadd    fGTF_J
     *         fstp    fGTF_CPrime
     */
    fGTF_CPrime = ((fGTF_C - fGTF_J) 
                *  (fGTF_K / const_fTwoHundredFiftySix))
                + fGTF_J;
    /*
     * This is forced by GTF definitions
     * M' = (K / 256) * M
     */
    fGTF_MPrime = (fGTF_K / const_fTwoHundredFiftySix) * fGTF_M;
    return;
}
/*
;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Returns:      None
;
;==============================================================================
*/
static void VerticalRefreshToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *
     * [H PIXELS RND] = ROUND([H PIXELS] / [CELL GRAN RND], 0) * [CELL GRAN RND]
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran) * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *
     * [V LINES RND] = IF([INT RQD?]="y", ROUND([V LINES] / 2, 0),
     *                                    ROUND([V LINES], 0))
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the frame rate required
     *
     * [V FIELD RATE RQD] = IF([INT RQD?]="y", [I/P FREQ RQD] * 2,
     *                                         [I/P FREQ RQD])
     */
    fVFieldRateRqd = (float)lpGtfIn->dwIPFreqRqd;
    if (lpGtfIn->dwIntRqd != 0)
        fVFieldRateRqd += fVFieldRateRqd;
    /*
     * 4) Find the number of lines in the top margin
     *
     * [TOP MARGIN (LINES)] = IF([MARGINS RQD?]="Y", ROUND(([MARGIN%] / 100 * [V LINES RND]), 0),
     *                                               0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 5) Find the number of lines in the bottom margin
     *
     * [BOT MARGIN (LINES)] = IF([MARGINS RQD?]="Y", ROUND(([MARGIN%] / 100 * [V LINES RND]), 0),
     *                                               0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fBottomMarginLines = const_fZero;
    /*
     * 6) If interlace is required, set dwInterlace to 0.5
     *
     * [INTERLACE]=IF([INT RQD?] = "y", 0.5,
     *                                  0)
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 7) Estimate the horizontal period
     *
     * [H PERIOD EST] = ((1 / [V FIELD RATE RQD]) - [MIN VSYNC+BP] / 1000000)
     *                / ([V LINES RND] + (2 * [TOP MARGIN (LINES)]) + [MIN PORCH RND] + [INTERLACE])
     *                * 1000000
     */
    fHPeriodEst = ((const_fOne / fVFieldRateRqd) - fMinVSyncPlusBackPorch / const_fOneMillion)
                / (fVLinesRnd + (const_fTwo * fTopMarginLines) + fMinPorch + fInterlace)
                * const_fOneMillion;
    /*
     * 8) Find the number of lines in fMinVSyncPlusBackPorch
     *
     * [V SYNC+BP] = ROUND(([MIN VSYNC+BP] / [H PERIOD EST]) ,0)
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch / fHPeriodEst);
    /*
     * 9) Find the number of lines in VBackPorch alone
     *
     * [V BACK PORCH] = [V SYNC+BP] - [V SYNC RND]
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 10) Find the total number of lines in the vertical field
     *
     * [TOTAL V LINES] = [V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)]
     *                 + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fVSyncPlusBackPorch
                 + fInterlace
                 + fMinPorch;
    /*
     * 11) Estimate the vertical field frequency
     *
     * [V FIELD RATE EST] = 1 / [H PERIOD EST] / [TOTAL V LINES] * 1000000
     */
    fVFieldRateEst = const_fOne / fHPeriodEst / fTotalVLines * const_fOneMillion;
    /*
     * 12) Find the actual horizontal period
     *
     * [H PERIOD] = [H PERIOD EST] / ([V FIELD RATE RQD] / [V FIELD RATE EST])
     */
    fHPeriod = fHPeriodEst / (fVFieldRateRqd / fVFieldRateEst);
    /*
     * 13) Find the actual vertical field frequency
     *
     * [V FIELD RATE] = 1 / [H PERIOD] / [TOTAL V LINES] * 1000000
     */
    fVFieldRate = const_fOne / fHPeriod / fTotalVLines * const_fOneMillion;
    /*
     * 14) Find the vertical frame frequency
     *
     * [V FRAME RATE] = IF([INT RQD?]="y", [V FIELD RATE] / 2,
     *                                     [V FIELD RATE])
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    /*
     * 15) Find the number of pixels in the left margin
     *
     * [LEFT MARGIN (PIXELS)] = IF([MARGINS RQD?]="Y", ROUND([H PIXELS RND] * [MARGIN%] / 100 / [CELL GRAN RND], 0) * [CELL GRAN RND],
     *                                                 0)
     */
    if (lpGtfIn->dwMarginsRqd)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 16) Find the number of pixels in the right margin
     *
     * [RIGHT MARGIN (PIXELS)] = IF([MARGINS RQD?]="Y", ROUND([H PIXELS RND] * [MARGIN%] / 100 / [CELL GRAN RND], 0) * [CELL GRAN RND],
     *                                                  0)
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 17) Find total number of active pixels in image+left+right margin
     *
     * [TOTAL ACTIVE PIXELS] = [H PIXELS RND] + [LEFT MARGIN (PIXELS)] + [RIGHT MARGIN (PIXELS)]
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 18) Find the ideal Blanking duty cycle
     *
     * [IDEAL DUTY CYCLE] = [C'] - ([M'] * [H PERIOD] / 1000)
     */
    fIdealDutyCycle = fGTF_CPrime
                    - (fGTF_MPrime * fHPeriod / const_fOneThousand);
    /*
     * 19) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *
     * [H BLANK (PIXELS)] = ROUND([TOTAL ACTIVE PIXELS] * [IDEAL DUTY CYCLE]
     *                    /       (100 - [IDEAL DUTY CYCLE])
     *                    /       (2 * [CELL GRAN RND]), 0)
     *                    * (2 * [CELL GRAN RND])
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo * fCellGran);
    /*
     * 20) Find the total number of pixels
     *
     * [TOTAL PIXELS] = [TOTAL ACTIVE PIXELS] + [H BLANK (PIXELS)]
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 21) Find the pixel clock frequency
     *
     * [PIXEL FREQ] = [TOTAL PIXELS] / [H PERIOD]
     */
    fPixelFreq = fTotalPixels / fHPeriod;
    /*
     * 22) Find the horizontal frequency
     *
     * [H FREQ] = 1000 / [H PERIOD]
     */
    fHFreq = const_fOneThousand / fHPeriod;
    return;
}
/*
;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Returns:      None
;
;==============================================================================
*/
static void HorizontalRefreshToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *         fild    ds:[ebx].GTFIN.dwHPixels
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     *         fstp    fHPixelsRnd
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran)
                * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *         fild    ds:[ebx].GTFIN.dwVLines
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVLinesRnd
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the horizontal freqency required
     *         fild    ds:[ebx].GTFIN.dwIPFreqRqd
     *         fstp    fHFreq
     */
    fHFreq = (float)lpGtfIn->dwIPFreqRqd;
    /*
     * 4) Find the number of lines in the top margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fTopMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 5) Find the number of lines in the bottom margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fBottomMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = fMarginPercent / const_fOneHundred * fVLinesRnd;
    else
        fBottomMarginLines = const_fZero;
    /*
     * 6) If interlace is required, set dwInterlace to 0.5
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fZeroPointFive
     * @@:     fstp    fInterlace
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 7) Find the number of lines in fMinVSyncPlusBackPorch
     *         fld     fMinVSyncPlusBackPorch
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fstp    fVSyncPlusBackPorch
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch * fHFreq / const_fOneThousand);
    /*
     * 8) Find the number of lines in VBackPorch alone
     *         fld     fVSyncPlusBackPorch
     *         fsub    fVSyncRqd
     *         fstp    fVBackPorch
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 9) Find the total number of lines in the vertical field
     *         fld     fVLinesRnd
     *         fadd    fTopMarginLines
     *         fadd    fBottomMarginLines
     *         fadd    fVSyncPlusBackPorch
     *         fadd    fMinPorch
     *         fadd    fInterlace
     *         fstp    fTotalVLines
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fInterlace
                 + fVSyncPlusBackPorch
                 + fMinPorch;
    /*
     * 10) Find the actual vertical field frequency
     *         fld     fHFreq
     *         fdiv    fTotalVLines
     *         fmul    fOneThousand
     *         fstp    fVFieldRate
     */
    fVFieldRate = fHFreq / fTotalVLines * const_fOneThousand;
    /*
     * 11) Find the vertical frame frequency
     *         fld     fVFieldRate
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVFrameRate
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    /*
     * 12) Find the number of pixels in the left margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fLeftMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 13) Find the number of pixels in the right margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fRightMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 14) Find total number of active pixels in image+left+right margin
     *         fld     fHPixelsRnd
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fstp    fTotalActivePixels
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 15) Find the ideal Blanking duty cycle
     *         fld     fGTF_CPrime
     *         fld     fGTF_MPrime
     *         fdiv    fHFreq
     *         fsubp   ST(1),ST(0)
     *         fstp    fIdealDutyCycle
     */
    fIdealDutyCycle = fGTF_CPrime - (fGTF_MPrime / fHFreq);
    /*
     * 16) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *         fld     fTotalActivePixels
     *         fmul    fIdealDutyCycle
     *         fld     fOneHundred
     *         fsub    fIdealDutyCycle
     *         fdivp   ST(1),ST(0)
     *         fld     fCellGran
     *         fadd    ST(0),ST(0)
     *         fdivp   ST(1),ST(0)
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fadd    ST(0),ST(0)
     *         fmul    fCellGran
     *         fstp    fHBlankPixels
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo *fCellGran);
    /*
     * 17) Find the total number of pixels
     *         fld     fTotalActivePixels
     *         fadd    fHBlankPixels
     *         fstp    fTotalPixels
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 18) Find the horizontal frequency
     *         fld     fOneThousand
     *         fdiv    fHFreq
     *         fstp    fHPeriod
     */
    fHPeriod = const_fOneThousand / fHFreq;
    /*
     * 19) Find the pixel clock frequency
     *         fld     fTotalPixels
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fstp    fPixelFreq
     */
    fPixelFreq = fTotalPixels * fHFreq / const_fOneThousand;
    return;
}
/*
;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Returns:      None
;
;==============================================================================
*/
static void PixelClockToStage1Parameters
(
    LPGTFIN  lpGtfIn
)
{
    /*
     * 1) Make sure that the XResolution is a multiple of char cell size
     *         fild    ds:[ebx].GTFIN.dwHPixels
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     *         fstp    fHPixelsRnd
     */
    fHPixelsRnd = calcROUND((float)lpGtfIn->dwHPixels / fCellGran)
                * fCellGran;
    /*
     * 2) If interlace is requested, half the number of vertical lines
     *    since the calculation is really vertical lines per field
     *         fild    ds:[ebx].GTFIN.dwVLines
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVLinesRnd
     */
    fVLinesRnd = (float)lpGtfIn->dwVLines;
    if (lpGtfIn->dwIntRqd != 0)
        fVLinesRnd /= const_fTwo;
    fVLinesRnd = calcROUND(fVLinesRnd);
    /*
     * 3) Find the horizontal freqency required
     *         fild    ds:[ebx].GTFIN.dwIPFreqRqd
     *         fstp    fPixelFreq
     */
    fPixelFreq = (float)lpGtfIn->dwIPFreqRqd;
    /*
     * 4) Find the number of pixels in the left margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fLeftMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fLeftMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                          * fCellGran;
    }
    else
        fLeftMarginPixels = const_fZero;
    /*
     * 5) Find the number of pixels in the right margin
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fHPixelsRnd
     *         fmul    fMarginPercent
     *         fdiv    fOneHundred
     *         fdiv    fCellGran
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fmul    fCellGran
     * @@:     fstp    fRightMarginPixels
     */
    if (lpGtfIn->dwMarginsRqd != 0)
    {
        fRightMarginPixels = calcROUND(fHPixelsRnd * fMarginPercent / const_fOneHundred / fCellGran)
                           * fCellGran;
    }
    else
        fRightMarginPixels = const_fZero;
    /*
     * 6) Find total number of active pixels in image+left+right margin
     *         fld     fHPixelsRnd
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fstp    fTotalActivePixels
     */
    fTotalActivePixels = fHPixelsRnd
                       + fLeftMarginPixels
                       + fRightMarginPixels;
    /*
     * 7) Find the ideal horizontal period from blanking duty cycle Eq
     *         fld     fOneHundred
     *         fsub    fGTF_CPrime
     *         fmul    ST(0),ST(0)
     *         fld     fTotalActivePixels
     *         fadd    fLeftMarginPixels
     *         fadd    fRightMarginPixels
     *         fmul    fGTF_MPrime
     *         fmul    fZeroPointFour
     *         fdiv    fPixelFreq
     *         faddp   ST(1),ST(0)
     *         fsqrt
     *         fadd    fGTF_CPrime
     *         fsub    fOneHundred
     *         fdiv    fTwo
     *         fmul    fGTF_MPrime
     *         fmul    fOneThousand
     *         fstp    fIdealHPeriod
     */
    fTemp         = const_fOneHundred - fGTF_CPrime;
    fTemp        *= fTemp;
    fTemp         = fTemp
                  + (const_fZeroPointFour * fGTF_MPrime 
                  *  (fTotalActivePixels + fLeftMarginPixels + fRightMarginPixels)
                  /  fPixelFreq);
    fIdealHPeriod = ((fGTF_CPrime - const_fOneHundred)
                  +  (float)calcSQRT(fTemp))
                  / const_fTwo
                  / fGTF_MPrime
                  * const_fOneThousand;
    /*
     * 8) Find the ideal Blanking duty cycle
     *         fld     fGTF_CPrime
     *         fld     fGTF_MPrime
     *         fmul    fIdealHPeriod
     *         fdiv    fOneThousand
     *         fsubp   ST(1),ST(0)
     *         fstp    fIdealDutyCycle
     */

    fIdealDutyCycle = fGTF_CPrime - 
                      (fGTF_MPrime * fIdealHPeriod / const_fOneThousand);
    /*
     * 9) Find the number of pixels in the blanking time to the
     * nearest double character cell
     *         fld     fTotalActivePixels
     *         fmul    fIdealDutyCycle
     *         fld     fOneHundred
     *         fsub    fIdealDutyCycle
     *         fdivp   ST(1),ST(0)
     *         fld     fCellGran
     *         fadd    ST(0),ST(0)
     *         fdivp   ST(1),ST(0)
     *         fistp   dwTemp
     *         fild    dwTemp
     *         fadd    ST(0),ST(0)
     *         fmul    fCellGran
     *         fstp    fHBlankPixels
     */
    fHBlankPixels = calcROUND((fTotalActivePixels * fIdealDutyCycle
                  /            (const_fOneHundred - fIdealDutyCycle)
                  /            (const_fTwo * fCellGran)))
                  * (const_fTwo * fCellGran);
    /*
     * 10) Find the total number of pixels
     *         fld     fTotalActivePixels
     *         fadd    fHBlankPixels
     *         fstp    fTotalPixels
     */
    fTotalPixels = fTotalActivePixels + fHBlankPixels;
    /*
     * 11) Find the horizontal frequency
     *         fld     fPixelFreq
     *         fdiv    fTotalPixels
     *         fmul    fOneThousand
     *         fstp    fHFreq
     */
    fHFreq = fPixelFreq / fTotalPixels * const_fOneThousand;
    /*
     * 12) Find the horizontal period
     *         fld     fOneThousand
     *         fdiv    fHFreq
     *         fstp    fHPeriod
     */
    fHPeriod = const_fOneThousand / fHFreq;
    /*
     * 13) Find the number of lines in the top margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fTopMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fTopMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fTopMarginLines = const_fZero;
    /*
     * 14) Find the number of lines in the bottom margin
     *         sub     eax,eax
     *         cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
     *         je      @F
     *         fld     fMarginPercent
     *         fmul    fVLinesRnd
     *         fdiv    fOneHundred
     * @@:     fstp    fBottomMarginLines
     */
    if (lpGtfIn->dwMarginsRqd != 0)
        fBottomMarginLines = calcROUND(fMarginPercent / const_fOneHundred * fVLinesRnd);
    else
        fBottomMarginLines = const_fZero;
    /*
     * 15) If interlace is required, set dwInterlace to 0.5
     *         fldz
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         faddp   ST(0),ST(0)             ; pop the stack
     *         fld     fZeroPointFive
     * @@:     fstp    fInterlace
     */
    if (lpGtfIn->dwIntRqd != 0)
        fInterlace = const_fZeroPointFive;
    else
        fInterlace = const_fZero;
    /*
     * 16) Find the number of lines in fMinVSyncPlusBackPorch
     *         fld     fMinVSyncPlusBackPorch
     *         fmul    fHFreq
     *         fdiv    fOneThousand
     *         fstp    fVSyncPlusBackPorch
     */
    fVSyncPlusBackPorch = calcROUND(fMinVSyncPlusBackPorch * fHFreq / const_fOneThousand);
    /*
     * 17) Find the number of lines in VBackPorch alone
     *         fld     fVSyncPlusBackPorch
     *         fsub    fVSyncRqd
     *         fstp    fVBackPorch
     */
    fVBackPorch = fVSyncPlusBackPorch - fVSyncRqd;
    /*
     * 18) Find the total number of lines in the vertical field
     *         fld     fVLinesRnd
     *         fadd    fTopMarginLines
     *         fadd    fBottomMarginLines
     *         fadd    fVSyncPlusBackPorch
     *         fadd    fMinPorch
     *         fadd    fInterlace
     *         fstp    fTotalVLines
     */
    fTotalVLines = fVLinesRnd
                 + fTopMarginLines
                 + fBottomMarginLines
                 + fVSyncPlusBackPorch
                 + fMinPorch
                 + fInterlace;
    /*
     * 19) Find the actual vertical field frequency
     *         fld     fHFreq
     *         fdiv    fTotalVLines
     *         fmul    fOneThousand
     *         fstp    fVFieldRate
     */
    fVFieldRate = fHFreq /fTotalVLines * const_fOneThousand;
    /*
     * 20) Find the vertical frame frequency
     *         fld     fVFieldRate
     *         cmp     ds:[ebx].GTFIN.dwIntRqd,0
     *         je      @F
     *         fdiv    fTwo
     * @@:     fstp    fVFrameRate
     */
    fVFrameRate = fVFieldRate;
    if (lpGtfIn->dwIntRqd != 0)
        fVFrameRate /= const_fTwo;
    return;
}
/*
;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Returns:      0       failure and lpGTFOut was not filled in
;               non-0   success and lpGTFOut was filled in
;
;==============================================================================
*/
ULONG WINAPI ComputeGTFParameters
(
        LPGTFIN  lpGtfIn,
        LPGTFOUT lpGtfOut
)
{
    /*
     * Set up all the constants we need
     */
    SetupGTFConstants();
    /*
     * Now we compute the stage 1 parameters. There are three cases
     * depending upon the IPParm which gives the type of the IPFreqRqd.
     */
    switch (lpGtfIn->dwIPParmType)
    {
        case IPTYPE_VERTICAL_REFRESH_RATE:
            VerticalRefreshToStage1Parameters(lpGtfIn);
            break;
        case IPTYPE_HORIZONTAL_REFRESH_RATE:
            HorizontalRefreshToStage1Parameters(lpGtfIn);
            break;
        case IPTYPE_PIXEL_CLOCK_RATE:
            PixelClockToStage1Parameters(lpGtfIn);
            break;
    }
    /*
     * Convert stage 1 to stage 2 parameters
     *
     * 1) Find the adressable lines per frame
     *
     * [ADDR LINES PER FRAME] = IF([INT RQD?]="y", [V LINES RND] * 2,
     *                                             [V LINES RND])
     */
    fAddrLinesPerFrame = fVLinesRnd;
    if (lpGtfIn->dwIntRqd != 0)
        fAddrLinesPerFrame += fVLinesRnd;
    /*
     * 2) Find the character time in nanoseconds
     *
     * [CHAR TIME] = [CELL GRAN RND] / [PIXEL FREQ] * 1000
     */
    fCharTime = fCellGran / fPixelFreq * const_fOneThousand;
    /*
     * 3) Find total number of lines in a frame
     *
     * [TOTAL LINES PER FRAME] = IF([INT RQD?]="y", 2 * ([V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)] + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]),
     *                                              ([V LINES RND] + [TOP MARGIN (LINES)] + [BOT MARGIN (LINES)] + [V SYNC+BP] + [INTERLACE] + [MIN PORCH RND]))
     */
    fTotalLinesPerFrame = fVLinesRnd
                        + fTopMarginLines
                        + fBottomMarginLines
                        + fVSyncPlusBackPorch
                        + fInterlace
                        + fMinPorch;
    if (lpGtfIn->dwIntRqd != 0)
        fTotalLinesPerFrame += fTotalLinesPerFrame;
    /*
     * 4) Find total number of chars in a horizontal line
     *
     * [TOTAL H TIME (CHARS)] = ROUND([TOTAL PIXELS] / [CELL GRAN RND], 0)
     */
    fTotalHTimeChars = calcROUND(fTotalPixels / fCellGran);
    /*
     * 5) Find the horizontal addressable time in microseconds
     *
     * [H ADDR TIME] = [H PIXELS RND] / [PIXEL FREQ]
     */
    fHAddrTime = fHPixelsRnd / fPixelFreq;
    /*
     * 6) Find the horizontal addressable time in chars
     *
     * [H ADDR TIME (CHARS)] = ROUND([H PIXELS RND] / [CELL GRAN RND], 0)
     */
    fHAddrTimeChars = calcROUND(fHPixelsRnd / fCellGran);
    /*
     * 7) Find horizontal blanking time in microseconds
     *
     * [H BLANK] = [H BLANK (PIXELS)] / [PIXEL FREQ]
     */
    fHBlank = fHBlankPixels / fPixelFreq;
    /*
     * 8) Find horizontal blanking time in chars
     *
     * [H BLANK (CHARS)] = ROUND([H BLANK (PIXELS)] / [CELL GRAN RND], 0)
     */
    fHBlankChars = calcROUND(fHBlankPixels / fCellGran);
    /*
     * 9) Find the horizontal blanking plus margin time in microseconds
     *
     * [H BLANK + MARGIN] = ([H BLANK (PIXELS)] + [RIGHT MARGIN (PIXELS)] + [LEFT MARGIN (PIXELS)])
     *                    / [PIXEL FREQ]
     */
    fHBlankPlusMargin = (fHBlankPixels + fRightMarginPixels + fLeftMarginPixels)
                      / fPixelFreq;
    /*
     * 10) Find the horizontal blanking plus margin time in chars
     *
     * [H BLANK + MARGIN(CHARS)] = ROUND(([H BLANK (PIXELS)] + [RIGHT MARGIN (PIXELS)] + [LEFT MARGIN (PIXELS)]) / [CELL GRAN RND], 0)
     */
    fHBlankPlusMarginChars = calcROUND((fHBlankPixels + fRightMarginPixels + fLeftMarginPixels) / fCellGran);
    /*
     * 11) Find the actual horizontal active video duty cycle in %
     *
     * [ACTUAL DUTY CYCLE] = [H BLANK (CHARS)] / [TOTAL H TIME (CHARS)] * 100
     */
    fActualDutyCycle = fHBlankChars / fTotalHTimeChars * const_fOneHundred;
    /*
     * 12) Find the image video duty cycle in %
     *
     * [BLANK + MARGIN DUTY CYCLE] = [H BLANK + MARGIN(CHARS)] / [TOTAL H TIME (CHARS)] * 100
     */
    fBlankPlusMarginDutyCycle = fHBlankPlusMarginChars / fTotalHTimeChars * const_fOneHundred;
    /*
     * 13) Find the left margin time in microseconds
     *
     * [LEFT MARGIN] = [LEFT MARGIN (PIXELS)] / [PIXEL FREQ] * 1000
     */
    fLeftMargin = fLeftMarginPixels * fPixelFreq * const_fOneThousand;
    /*
     * 14) Find the number of chars in the left margin
     *
     * [LEFT MARGIN (CHARS)] = [LEFT MARGIN (PIXELS)] / [CELL GRAN RND]
     */
    fLeftMarginChars = fLeftMarginPixels / fCellGran;
    /*
     * 15) Find the right margin time in microseconds
     *
     * [RIGHT MARGIN] = [RIGHT MARGIN (PIXELS)] / [PIXEL FREQ] * 1000
     */
    fRightMargin = fRightMarginPixels * fPixelFreq * const_fOneThousand;
    /*
     * 16) Find the number of chars in the rightt margin
     *
     * [RIGHT MARGIN (CHARS)] = [RIGHT MARGIN (PIXELS)] / [CELL GRAN RND]
     */
    fRightMarginChars = fRightMarginPixels / fCellGran;
    /*
     * 17) Find the number of pixels inteh horizontal sync period
     *
     * [H SYNC (PIXELS)] = ROUND(([H SYNC%] / 100 * [TOTAL PIXELS] / [CELL GRAN RND]), 0)
     *                   * [CELL GRAN RND]
     */
    fHSyncPixels = calcROUND(fHSyncPercent / const_fOneHundred * fTotalPixels / fCellGran)
                 * fCellGran;
    /*
     * 18) Find number of pixels in horizontal front porch period
     *
     * [H FRONT PORCH (PIXELS)] = ([H BLANK (PIXELS)] / 2) - [H SYNC (PIXELS)]
     */
    fHFrontPorchPixels = (fHBlankPixels / const_fTwo) - fHSyncPixels;
    /*
     * 19) Find number of pixels in horizontal front porch period
     *
     * [H BACK PORCH (PIXELS)] = [H FRONT PORCH (PIXELS)] + [H SYNC (PIXELS)]
     */
    fHBackPorchPixels = fHFrontPorchPixels + fHSyncPixels;
    /*
     * 20) Find number of characters in the horizontal sync period
     *
     * [H SYNC (CHARS)] = [H SYNC (PIXELS)] / [CELL GRAN RND]
     */
    fHSyncChars = fHSyncPixels / fCellGran;
    /*
     * 21) Find the horizontal sync period in microseconds
     *
     * [H SYNC] = [H SYNC (PIXELS)] / [PIXEL FREQ]
     */
    fHSync = fHSyncPixels / fPixelFreq;
    /*
     * 22) Find the number of chars in the horizontal front porch
     *
     * [H FRONT PORCH (CHARS)] = [H FRONT PORCH (PIXELS)] / [CELL GRAN RND]
     */
    fHFrontPorchChars = fHFrontPorchPixels / fCellGran;
    /*
     * 23) Find the horizontal front porch period in microseconds
     *
     * [H FRONT PORCH] = [H FRONT PORCH (PIXELS)] / [PIXEL FREQ]
     */
    fHFrontPorch = fHFrontPorchPixels / fPixelFreq;
    /*
     * 24) Find the number of chars in the horizontal back porch
     *
     * [H BACK PORCH (CHARS)] = [H BACK PORCH (PIXELS)] / [CELL GRAN RND]
     */
    fHBackPorchChars = fHBackPorchPixels / fCellGran;
    /*
     * 25) Find the horizontal front back period in microseconds
     *
     * [H BACK PORCH] = [H BACK PORCH (PIXELS)] / [PIXEL FREQ]
     */
    fHBackPorch = fHBackPorchPixels / fPixelFreq;
    /*
     * 26) Find the vertical frame period in milliseconds
     *
     * [V FRAME PERIOD] = IF([INT RQD?]="y", [TOTAL V LINES] * [H PERIOD] / 1000 * 2,
     *                                       [TOTAL V LINES] * [H PERIOD] / 1000)
     */
    fVFramePeriod = fTotalVLines * fHPeriod / const_fOneThousand;
    if (lpGtfIn->dwIntRqd != 0)
        fVFramePeriod += fVFramePeriod;
    /*
     * 27) Find the vertical field period in milliseconds
     *
     * [V FIELD PERIOD] = [TOTAL V LINES] * [H PERIOD] / 1000
     */
    fVFieldPeriod = fTotalVLines * fHPeriod / const_fOneThousand;
    /*
     * 28) Find the addressable vertical period per frame in milliseconds
     *
     * [V ADDR TIME PER FRAME] = IF([INT RQD?]="y", [V LINES RND] * [H PERIOD] / 1000 * 2,
     *                                              [V LINES RND] * [H PERIOD] / 1000)
     */
    fVAddrTimePerFrame = fVLinesRnd * fHPeriod / const_fOneThousand;
    if (lpGtfIn->dwIntRqd != 0)
        fVAddrTimePerFrame += fVAddrTimePerFrame;
    /*
     * 29) Find the addressable vertical period per field in milliseconds
     *
     * [V ADDR TIME PER FIELD] = [V LINES RND] * [H PERIOD] / 1000
     */
    fVAddrTimePerField = fVLinesRnd * fHPeriod / const_fOneThousand;
    /*
     * 30) Find the number of lines in teh odd blanking period
     *
     * [V ODD BLANKING (LINES)] = [V SYNC+BP] + [MIN PORCH RND]
     */
    fVOddBlankingLines = fVSyncPlusBackPorch + fMinPorch;
    /*
     * 31) Find the odd blanking period in milliseconds
     *
     * [V ODD BLANKING] = ([V SYNC+BP] + [MIN PORCH RND]) * [H PERIOD] / 1000
     */
    fVOddBlanking = (fVSyncPlusBackPorch + fMinPorch) * fHPeriod / const_fOneThousand;
    /*
     * 32) Find the number of lines in the even blanking period
     *
     * [V EVEN BLANKING (LINES)] = [V SYNC+BP] + (2 * [INTERLACE]) + [MIN PORCH RND]
     */
    fVEvenBlankingLines = fVSyncPlusBackPorch
                        + (const_fTwo * fInterlace)
                        + fMinPorch;
    /*
     * 33) Find the even blanking period in milliseconds
     *
     * [V EVEN BLANKING] = ([V SYNC+BP] + (2 * [INTERLACE]) + [MIN PORCH RND])
     *                   / 1000 * [H PERIOD]
     */
    fVEvenBlanking = (fVSyncPlusBackPorch + (const_fTwo * fInterlace) + fMinPorch)
                   / const_fOneThousand
                   *  fHPeriod;
    /*
     * 34) Find the top margin period in microseconds
     *
     * [TOP MARGIN ] = [TOP MARGIN (LINES)] * [H PERIOD]
     */
    fTopMargin = fTopMarginLines * fHPeriod;
    /*
     * 35) Find the odd front porch in microseconds
     *
     * [V ODD FRONT PORCH] = ([MIN PORCH RND] + [INTERLACE]) * [H PERIOD]
     */
    fVOddFrontPorch = (fMinPorch + fInterlace) * fHPeriod;
    /*
     * 36) Find the number of lines in the odd front porch period
     *
     * [V ODD FRONT PORCH(LINES)] = [MIN PORCH RND] + [INTERLACE]
     */
    fVOddFrontPorchLines = fMinPorch + fInterlace;
    /*
     * 37) Find the even front porch period
     *
     * [V EVEN FRONT PORCH] = [MIN PORCH RND] * [H PERIOD]
     */
    fVEvenFrontPorch = fMinPorch * fHPeriod;
    /*
     * 38) Find the vertcial sync period in microseconds
     *
     * [V SYNC] = [V SYNC RND] * [H PERIOD]
     */
    fVSync = fVSyncRqd * fHPeriod;
    /*
     * 39) Find the even front porch period in microseconds
     *
     * [V EVEN BACK PORCH] = ([V BACK PORCH] + [INTERLACE]) * [H PERIOD]
     */
    fVEvenBackPorch = (fVBackPorch + fInterlace) * fHPeriod;
    /*
     * 40) Find the number of lines in the even fron tporch period
     *
     * [V EVEN BACK PORCH (LINES)] = [V BACK PORCH] + [INTERLACE]
     */
    fVEvenBackPorchLines = fVBackPorch + fInterlace;
    /*
     * 41) Find the odd back porch period in microseconds
     *
     * [V ODD BACK PORCH] = [V BACK PORCH] * [H PERIOD]
     */
    fVOddBackPorch = fVBackPorch * fHPeriod;
    /*
     * 42) Find the bottom margin period in microseconds
     *
     * [BOT MARGIN] = [BOT MARGIN (LINES)] * [H PERIOD]
     */
    fBottomMargin = fBottomMarginLines * fHPeriod;
    /*
     * Cram all the data into GTFOut
     */
    lpGtfOut->dwHTotalChars          = (ULONG)fTotalHTimeChars;
    lpGtfOut->dwVTotalScans          = (ULONG)fTotalLinesPerFrame;
    lpGtfOut->dwHActiveChars         = (ULONG)fHAddrTimeChars;
    lpGtfOut->dwVActiveScans         = (ULONG)fVLinesRnd;
    lpGtfOut->dwHBlankStartChar      = (ULONG)(fHAddrTimeChars + fRightMarginChars);
    lpGtfOut->dwHFrontPorchChars     = (ULONG)fHFrontPorchChars;
    lpGtfOut->dwHSyncChars           = (ULONG)fHSyncChars;
    lpGtfOut->dwHBackPorchChars      = (ULONG)fHBackPorchChars;
    lpGtfOut->dwHBlankEndChar        = (ULONG)(fTotalHTimeChars - fLeftMarginChars);
    lpGtfOut->dwVBlankStartScan      = (ULONG)(fVLinesRnd + fBottomMarginLines);
    lpGtfOut->dwVFrontPorchScans     = (ULONG)fVOddFrontPorchLines;
    lpGtfOut->dwVSyncScans           = (ULONG)fVSyncRqd;
    lpGtfOut->dwVBackPorchScans      = (ULONG)fVEvenBackPorchLines;
    lpGtfOut->dwVBlankEndScan        = (ULONG)(fTotalLinesPerFrame - fTopMarginLines);
    lpGtfOut->dwPixelClockIn10KHertz = (ULONG)(fPixelFreq * const_fOneHundred);
    /*
     * Return success
     */
    return(1);
}
ULONG WINAPI Divide32By32
(
        ULONG dwDividend,
        ULONG dwDivisor
)
{
    return (dwDividend / dwDivisor);
}
ULONG WINAPI Multiply32By32
(
        ULONG dwMult1,
        ULONG dwMult2
)
{
    return (dwMult1 * dwMult2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\GTFMATH.ASM ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtf.asm
;
; Purpose:      This file implements the GTF algorithm
;
;       Just come important comments and definitions I extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
.586
include macros.dat
include gtfmath.inc

.listall

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, USE32, CODE

fZeroPointFour                  REAL4   0.4
fZeroPointFive                  REAL4   0.5
fOne                            REAL4   1.0
fOnePointEight                  REAL4   1.8
fTwo                            REAL4   2.0
fThree                          REAL4   3.0
fEight                          REAL4   8.0
fTwenty                         REAL4   20.0
fForty                          REAL4   40.0
fOneHundred                     REAL4   100.0
fOneHundredTwentyEight          REAL4   128.0
fTwoHundredFiftySix             REAL4   256.0
fFiveHundredFifty               REAL4   550.0
fSixHundred                     REAL4   600.0
fOneThousand                    REAL4   1000.0
fOneMillion                     REAL4   1000000.0

;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    lpGTFIn         FAR ptr to GTFIN structure
;               lpGTFOut        FAR ptr to GTFOUT structure
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
IFDEF  _WIN32
DECPROC ComputeGTFParameters, STANDARD, FRAME, NEAR
ELSE
DECPROC ComputeGTFParameters, PASCAL, FRAME, FAR16
ENDIF
PARMD   lpGTFIn
PARMD   lpGTFOut
OPENPROC
        PUSHR   ds,ebx,esi,edi
IFDEF _WIN32
        mov     ebx,lpGTFIn
        mov     esi,lpGTFOut
ELSE
        sub     ebx,ebx
        lds     bx,lpGTFIn
        sub     esi,esi
        les     si,lpGTFOut
ENDIF
        call    ComputeGTFParameters1
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     ComputeGTFParameters1
;
; Purpose:      This function computes the data for the GTFOut structure
;               from teh arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    ds:ebx  GTFIN ptr
;               es:esi  GTFOUT ptr
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
DECPROC ComputeGTFParameters1, PASCAL, FRAME, NEAR
LOCALD  dwTemp
LOCALR4 fVLinesRnd
LOCALR4 fAddrLinesPerFrame
LOCALR4 fCellGran
LOCALR4 fPixelFreq
LOCALR4 fCharTime
LOCALR4 fTopMarginLines
LOCALR4 fBottomMarginLines
LOCALR4 fVSyncPlusBackPorch
LOCALR4 fMinPorch
LOCALR4 fInterlace
LOCALR4 fTotalLinesPerFrame
LOCALR4 fTotalPixels
LOCALR4 fTotalHTimeChars
LOCALR4 fHPixelsRnd
LOCALR4 fHAddrTime
LOCALR4 fHAddrTimeChars
LOCALR4 fHBlankPixels
LOCALR4 fHBlank
LOCALR4 fHBlankChars
LOCALR4 fLeftMarginPixels
LOCALR4 fRightMarginPixels
LOCALR4 fHBlankPlusMargin
LOCALR4 fHBlankPlusMarginChars
LOCALR4 fActualDutyCycle
LOCALR4 fBlankPlusMarginDutyCycle
LOCALR4 fLeftMargin
LOCALR4 fLeftMarginChars
LOCALR4 fRightMargin
LOCALR4 fRightMarginChars
LOCALR4 fHSyncPercent
LOCALR4 fHSyncPixels
LOCALR4 fHFrontPorchPixels
LOCALR4 fHBackPorchPixels
LOCALR4 fHSyncChars
LOCALR4 fHSync
LOCALR4 fHFrontPorchChars
LOCALR4 fHFrontPorch
LOCALR4 fHBackPorchChars
LOCALR4 fHBackPorch
LOCALR4 fTotalVLines
LOCALR4 fHPeriod
LOCALR4 fVFramePeriod
LOCALR4 fVFieldPeriod
LOCALR4 fVAddrTimePerFrame
LOCALR4 fVAddrTimePerField
LOCALR4 fVOddBlankingLines
LOCALR4 fVOddBlanking
LOCALR4 fVEvenBlankingLines
LOCALR4 fVEvenBlanking
LOCALR4 fTopMargin
LOCALR4 fVOddFrontPorch
LOCALR4 fVOddFrontPorchLines
LOCALR4 fVEvenFrontPorch
LOCALR4 fVSyncRqd
LOCALR4 fVSync
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorch
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorchLines
LOCALR4 fVOddBackPorch
LOCALR4 fBottomMargin
LOCALR4 fMarginPercent
LOCALR4 fMinVSyncPlusBackPorch
LOCALR4 fGTF_M
LOCALR4 fGTF_C
LOCALR4 fGTF_J
LOCALR4 fGTF_K
LOCALR4 fGTF_CPrime
LOCALR4 fGTF_MPrime
LOCALR4 fVFieldRateRqd
LOCALR4 fHPeriodEst
LOCALR4 fVFieldRateEst
LOCALR4 fVFieldRate
LOCALR4 fVFrameRate
LOCALR4 fTotalActivePixels
LOCALR4 fIdealDutyCycle
LOCALR4 fHFreq
LOCALR4 fIdealHPeriod
OPENPROC
        PUSHR   ds,ebx,esi,edi

        ; Reset the floating point unit
        fninit

        ; Set up all the constants we need
        call    SetupGTFConstants

        ; Now we compute the stage 1 parameters. There are three cases
        ; depending upon the IPParm which gives the type of the IPFreqRqd.
        push    OFFSET DoneStage1Parms
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_VERTICAL_REFRESH_RATE
        je      VerticalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_HORIZONTAL_REFRESH_RATE
        je      HorizontalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_PIXEL_CLOCK_RATE
        je      PixelClockToStage1Parameters
        pop     eax
        sub     eax,eax
        jmp     Done

DoneStage1Parms:
        ; Convert stage 1 to stage 2 parameters

        ; 1) Find the adressable lines per frame
        fld     fVLinesRnd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fAddrLinesPerFrame

        ; 2) Find the character time in nanoseconds
        fld     fCellGran
        fdiv    fPixelFreq
        fmul    fOneThousand
        fstp    fCharTime

        ; 3) Find total number of lines in a frame
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fTotalLinesPerFrame

        ; 4) Find total number of chars in a horizontal line
        fld     fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fTotalHTimeChars

        ; 5) Find the horizontal addressable time in microseconds
        fld     fHPixelsRnd
        fdiv    fPixelFreq
        fstp    fHAddrTime

        ; 6) Find the horizontal addressable time in chars
        fld     fHPixelsRnd
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHAddrTimeChars

        ; 7) Find horizontal blanking time in microseconds
        fld     fHBlankPixels
        fdiv    fPixelFreq
        fstp    fHBlank

        ; 8) Find horizontal blanking time in chars
        fld     fHBlankPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankChars

        ; 9) Find the horizontal blanking plus margin time in microseconds
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fPixelFreq
        fstp    fHBlankPlusMargin

        ; 10) Find the horizontal blanking plus margin time in chars
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankPlusMarginChars

        ; 11) Find the actual horizontal active video duty cycle in %
        fld     fHBlankChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fActualDutyCycle

        ; 12) Find the image video duty cycle in %
        fld     fHBlankPlusMarginChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fBlankPlusMarginDutyCycle

        ; 13) Find the left margin time in microseconds
        fld     fLeftMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fLeftMargin

        ; 14) Find the number of chars in the left margin
        fld     fLeftMarginPixels
        fdiv    fCellGran
        fstp    fLeftMarginChars

        ; 15) Find the right margin time in microseconds
        fld     fRightMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fRightMargin

        ; 16) Find the number of chars in the rightt margin
        fld     fRightMarginPixels
        fdiv    fCellGran
        fstp    fRightMarginChars

        ; 17) Find the number of pixels inteh horizontal sync period
        fld     fHSyncPercent
        fdiv    fOneHundred
        fmul    fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHSyncPixels

        ; 18) Find number of pixels in horizontal front porch period
        fld     fHBlankPixels
        fdiv    fTwo
        fsub    fHSyncPixels
        fstp    fHFrontPorchPixels

        ; 19) Find number of pixels in horizontal front porch period
        fld     fHFrontPorchPixels
        fadd    fHSyncPixels
        fstp    fHBackPorchPixels

        ; 20) Find number of characters in the horizontal sync period
        fld     fHSyncPixels
        fdiv    fCellGran
        fstp    fHSyncChars

        ; 21) Find the horizontal sync period in microseconds
        fld     fHSyncPixels
        fdiv    fPixelFreq
        fstp    fHSync

        ; 22) Find the number of chars in the horizontal front porch
        fld     fHFrontPorchPixels
        fdiv    fCellGran
        fstp    fHFrontPorchChars

        ; 23) Find the horizontal front porch period in microseconds
        fld     fHFrontPorchPixels
        fdiv    fPixelFreq
        fstp    fHFrontPorch

        ; 24) Find the number of chars in the horizontal back porch
        fld     fHBackPorchPixels
        fdiv    fCellGran
        fstp    fHBackPorchChars

        ; 25) Find the horizontal front back period in microseconds
        fld     fHBackPorchPixels
        fdiv    fPixelFreq
        fstp    fHBackPorch

        ; 26) Find the vertical frame period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVFramePeriod

        ; 27) Find the vertical field period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVFieldPeriod

        ; 28) Find the addressable vertical period per frame in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVAddrTimePerFrame

        ; 29) Find the addressable vertical period per field in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVAddrTimePerField

        ; 30) Find the number of lines in teh odd blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fstp    fVOddBlankingLines

        ; 31) Find the odd blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVOddBlanking

        ; 32) Find the number of lines in the even blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fstp    fVEvenBlankingLines

        ; 33) Find the even blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVEvenBlanking

        ; 34) Find the top margin period in microseconds
        fld     fTopMarginLines
        fmul    fHPeriod
        fstp    fTopMargin

        ; 35) Find the odd front porch in microseconds
        fld     fMinPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVOddFrontPorch

        ; 36) Find the number of lines in the odd front porch period
        fld     fMinPorch
        fadd    fInterlace
        fstp    fVOddFrontPorchLines

        ; 37) Find the even front porch period
        fld     fMinPorch
        fmul    fHPeriod
        fstp    fVEvenFrontPorch

        ; 38) Find the vertcial sync period in microseconds
        fld     fVSyncRqd
        fmul    fHPeriod
        fstp    fVSync

        ; 39) Find the even front porch period in microseconds
        fld     fVBackPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVEvenBackPorch

        ; 40) Find the number of lines in the even fron tporch period
        fld     fVBackPorch
        fadd    fInterlace
        fstp    fVEvenBackPorchLines

        ; 41) Find the odd back porch period in microseconds
        fld     fVBackPorch
        fmul    fHPeriod
        fstp    fVOddBackPorch

        ; 42) Find the bottom margin period in microseconds
        fld     fBottomMarginLines
        fmul    fHPeriod
        fstp    fBottomMargin

        ; Cram all the data into GTFOut
        fld     fTotalHTimeChars
        fistp   es:[esi].GTFOUT.dwHTotalChars
        fld     fTotalLinesPerFrame
        fistp   es:[esi].GTFOUT.dwVTotalScans
        fld     fHAddrTimeChars
        fistp   es:[esi].GTFOUT.dwHActiveChars
        fld     fVLinesRnd
        fistp   es:[esi].GTFOUT.dwVActiveScans
        fld     fHAddrTimeChars
        fadd    fRightMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankStartChar
        fld     fHFrontPorchChars
        fistp   es:[esi].GTFOUT.dwHFrontPorchChars
        fld     fHSyncChars
        fistp   es:[esi].GTFOUT.dwHSyncChars
        fld     fHBackPorchChars
        fistp   es:[esi].GTFOUT.dwHBackPorchChars
        fld     fTotalHTimeChars
        fsub    fLeftMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankEndChar
        fld     fVLinesRnd
        fadd    fBottomMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankStartScan
        fld     fVOddFrontPorchLines
        fistp   es:[esi].GTFOUT.dwVFrontPorchScans
        fld     fVSyncRqd
        fistp   es:[esi].GTFOUT.dwVSyncScans
        fld     fVEvenBackPorchLines
        fistp   es:[esi].GTFOUT.dwVBackPorchScans
        fld     fTotalLinesPerFrame
        fsub    fTopMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankEndScan
        fld     fPixelFreq
;;;        fmul    fOneMillion
        fmul    fOneHundred
        fistp   es:[esi].GTFOUT.dwPixelClockIn10KHertz

        ; Return success
        mov     eax,1

Done:
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC SetupGTFConstants, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; This is the size of the top (or bottom -- they are the same)
        ; overscan area as a percentage of the total vertcical time.
        fld     fOnePointEight
        fstp    fMarginPercent

        ; Number of pixels per character cell
        fld     fEight
        fstp    fCellGran

        ; Minimum horizontal front porch in character cells and
        ; minimum vertical front porch in scanlines (they are the same.)
        fld     fOne
        fstp    fMinPorch

        ; Width of vsync pulse in scanlines
        fld     fThree
        fstp    fVSyncRqd

        ; Width of the hsync pulse as a percentage of horizontal line time
        fld     fEight
        fstp    fHSyncPercent

        ; minimum time for vertical sync plus back porch in microseconds
        fld     fFiveHundredFifty
        fstp    fMinVSyncPlusBackPorch

        ; These apply to the Basic Blanking Duty Cycle Equation.
        ; See the top of the file.
        fld     fSixHundred
        fstp    fGTF_M
        fld     fForty
        fstp    fGTF_C
        fld     fOneHundredTwentyEight
        fstp    fGTF_K
        fld     fTwenty
        fstp    fGTF_J

        ; This is forced by GTF definitions
        ; C' = ((C - J) * (K / 256) + J
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fld     fGTF_C
        fsub    fGTF_J
        fmulp   ST(1),ST(0)
        fadd    fGTF_J
        fstp    fGTF_CPrime

        ; This is forced by GTF definitions
        ; M' = (K / 256) * M
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fmul    fGTF_M
        fstp    fGTF_MPrime

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Arguments:    ds:ebx  ptr to lpGTFIn structure
;               You have the stack frame available to ComputeGTFParameters
;               but be careful about ptrs, because they are flat 32bit ptrs
;               if you are running under WinNT and 16:16 ptrs if you are
;               running under Win9X. You shouldn't need to load any ptrs
;               since lpGTFIn is already passed into this routine in the
;               correct format.
;
; Returns:      None
;
; Preserve:     ds,esi,edi,ebx
;==============================================================================
DECPROC VerticalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the frame rate required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fVFieldRateRqd

        ; 4) Find the number of lines in the top margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Estimate the horizontal period
        fld1
        fdiv    fVFieldRateRqd
        fld     fMinVSyncPlusBackPorch
        fdiv    fOneMillion
        fsubp   ST(1),ST(0)
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fTopMarginLines
        fadd    fMinPorch
        fadd    fInterlace
        fdivp   ST(1),ST(0)
        fmul    fOneMillion
        fstp    fHPeriodEst

        ; 8) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fdiv    fHPeriodEst
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 9) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 10) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 11) Estimate the vertical field frequency
        fld1
        fdiv    fHPeriodEst
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRateEst

        ; 12) Find the actual horizontal period
        fld     fHPeriodEst
        fmul    fVFieldRateEst
        fdiv    fVFieldRateRqd
        fstp    fHPeriod

        ; 13) Find the actual vertical field frequency
        fld1
        fdiv    fHPeriod
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRate

        ; 14) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 15) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 16) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 17) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 18) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 19) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 20) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 21) Find the pixel clock frequency
        fld     fTotalPixels
        fdiv    fHPeriod
        fstp    fPixelFreq

        ; 22) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHPeriod
        fstp    fHFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC HorizontalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fHFreq

        ; 4) Find the number of lines in the top margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 8) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 9) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 10) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 11) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 12) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 13) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 14) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 15) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fdiv    fHFreq
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 16) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 17) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 18) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 19) Find the pixel clock frequency
        fld     fTotalPixels
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fPixelFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC PixelClockToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fPixelFreq

        ; 4) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 5) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 6) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 7) Find the ideal horizontal period from blanking duty cycle Eq
        fld     fOneHundred
        fsub    fGTF_CPrime
        fmul    ST(0),ST(0)
        fld     fTotalActivePixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fmul    fGTF_MPrime
        fmul    fZeroPointFour
        fdiv    fPixelFreq
        faddp   ST(1),ST(0)
        fsqrt
        fadd    fGTF_CPrime
        fsub    fOneHundred
        fdiv    fTwo
        fdiv    fGTF_MPrime
        fmul    fOneThousand
        fstp    fIdealHPeriod

        ; 8) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fIdealHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 9) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 10) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 11) Find the horizontal frequency
        fld     fPixelFreq
        fdiv    fTotalPixels
        fmul    fOneThousand
        fstp    fHFreq

        ; 12) Find the horizontal period
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 13) Find the number of lines in the top margin
        fldz    
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 14) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 15) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 16) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fVSyncPlusBackPorch

        ; 17) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 18) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 19) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 20) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     Divide32By32
;
; Purpose:      This function divides a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Divide32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Divide32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwDividend
PARMD   dwDivisor
OPENPROC
        sub     edx,edx
        mov     eax,dwDividend
        cmp     dwDivisor,edx
        jne     valid
divbyzero:
        cmp     eax,edx                 ; is numerator zero?
        je      done                    ; yes - eax:edx = 0
        mov     eax,-1                  ; no - call it infinity
        mov     edx,-1                  ; eax:edx = -1
        jmp     done
valid:  
        div     dwDivisor
done:
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC


;==============================================================================
;
; Function:     Multiply32By32
;
; Purpose:      This function multiplies a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Multiply32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Multiply32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwMult1
PARMD   dwMult2
OPENPROC
        mov     eax,dwMult1
        imul    eax,dwMult2
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\tvmode.h ===
/*
    FILE:   tvmode.h
    DATE:   4/8/99

    This file contains the high level logic for the tv modeset code.
    OS Independent.
*/

extern int CFUNC FindTVModeEntry (LPDISPDATA lpDispData,
                                LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut,
                                LPMODEENTRY lpModeList, LPRESTIME lpRTList);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\display\winnt4\miniport\nv_mini\vpewrap.c ===
//***************************************************************************
//  Module Name:
//
//      vpewrap.c
//
//  Abstract:
//
//      This module contains the miniport parts of the DXAPI "kernel-mode
//      VPE" interface for the .
//
//      The DirectDraw Video Port Extensions (VPE) are the services that
//      control hardware videoports, where video data is streamed into
//      off-screen memory from an external device such as a TV tuner or
//      MPEG decoder, and then displayed on the screen by a video overlay.
//
//      To support VPE, you'll need the following:
//
//          1. A 2-D driver with DirectDraw overlay support;
//          2. A video input device that interfaces with the videoport;
//          3. A bunch of VPE code in the display driver;
//          4. A bunch of VPE code here in the miniport.
//
//      The miniport code here comprises part of the DXAPI "kernel-mode
//      VPE" interface that can be called by other WDM drivers, such as
//      an MPEG driver.
//
// IMPORTANT NOTE ABOUT HARDWARE REQUIREMENTS:
//
//      Almost all of these miniport "kernel-mode VPE" routines may be
//      called asynchronously to what the display driver is currently
//      doing.  For example, a thread may be in the display driver in the
//      middle of programming an accelerated Blt at the exact moment that
//      the miniport gets called to do a videoport flip call.  Consequently,
//      your hardware MUST be able to handle these commands at any time
//      regardless of the state of the display driver.  So this means:
//
//          1. Your hardware has to be able to allow the programming of any
//             "kernel-mode VPE" command even while Blts or direct frame
//             buffer accesses or DMAs or whatever are occuring, without
//             hanging or incorrect drawing.
//
//          2. The registers used to program any of the "kernel-mode VPE"
//             services must be disjoint and separate from those used by
//             the display driver.  If you must program an indexed register
//             that is also used by the display driver (such as 0x3d4/0x3d5),
//             *YOU ARE PROBABLY TOAST*.  Both a thread in the display driver
//             and a thread calling these miniport services are preemptible,
//             meaning that even if you save and restore the index register,
//             there's no guarantee that the other thread won't wake up in
//             the middle and try to use the same (now incorrectly set)
//             register.
//
//      If your hardware does not guarantee both of the above, you CANNOT
//      support the "kernel-mode VPE" interface!  Go yell at your hardware
//      designers and get them to fix the hardware.  If both of the above
//      are not guaranteed, it's inevitable that your customers will randomly
//      hit system hangs and crashes while using VPE.  Your customers will
//      not be happy!
//
//      Also note that the likelihood of hitting a problem is significantly
//      increased when running on a multiple-processor machine.  Consequently,
//      you should try to test VPE on an MP machine while applications (such
//      as Winstone) are running in the background.
//
//      (Okay, okay, so I exaggerated a bit about pointer number 2.  You can
//      in fact use shared indexed registers in these VPE routines if you do
//      one of the following:
//
//          1. Disable VPE on multiple-processor machines.  (As of the time
//             of this writing, we haven't yet implemented a VideoPort or
//             Eng function that you can call to determine whether you're
//             running on a UP or MP machine, otherwise I would tell you
//             the name of the function to call.  But by the time you read
//             this, it will probably exist -- so have a look through the
//             VideoPort and Eng calls...)
//
//             You'll also have to save and restore the index register when
//             you're done.  Because a thread that calls a miniport function
//             is at raised IRQL, it may interrupt a thread in the display
//             driver at any point, but on a UP machine it's guaranteed that
//             the display driver thread will not interrupt the miniport
//             thread.
//
//          2. Use the CRTC register only in the DxEnableIrq routine --
//             DirectDraw automatically synchronizes with the display driver
//             before calling DxEnableIrq (this is not true for any other
//             Dx miniport calls).
//
// NOTE:
//
//      Most "kernel-mode VPE" routines can be called at raised IRQL, meaning
//      that they MUST be non-paged, and cannot call any pageable functions.
//
//  Environment:
//
//      Kernel mode
//
//  Copyright (c) 1997 Microsoft Corporation
//
//***************************************************************************

#ifdef VPE_NT

#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
// Commented out benign redefinition// typedef int      BOOL;

#define INITGUID     // Instantiate GUID_DxApi
#include "dxmini.h"

#include "nv.h"

DWORD
GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo
    );

VP_STATUS
nvVPEQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    );

//
// Mark those routines that we can as pageable.  Remember that most
// "kernel-mode VPE" routines can be called at raised IRQL, which means
// that they must be kept non-paged.
//
// Note that these are the only two VPE miniport routines which may be
// pageable:
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,nvVPEQueryInterface)
#pragma alloc_text(PAGE,GetIrqInfo)
#endif

// !!! Not hooking Lock is success, but not hooking SetPattern is failure?
// !!! Should dwFlags be ANDed or EQUALed?  (SkipNextField)
// !!! Should we mark the interrupt as unsharable?

DWORD
GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo
    )

/*++

Routine Description:

    On NT, the miniport always has to "manage the IRQ" (to borrow from the
    Win95 terminology).  Consequently, this routine simply tells DirectDraw
    what interrupts we support.

    It's actually pretty easy to enable interrupts, in part because you
    don't have to tell the system what interrupt vector you're using, as
    PNP already knows that.  However, you *do* have to check whether PNP
    successfully assigned you an interrupt vector, before you tell DirectDraw
    that you support interrupts.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DWORD status = DXERR_UNSUPPORTED;

    //
    // Sometimes, the motherboard BIOS or PNP may conspire to refuse to
    // allocate an interrupt to us.  So before we tell DirectDraw that
    // we support interrupts, we must first check if we've actually been
    // assigned one!
    //

    if ((hwDeviceExtension->BusInterruptLevel != 0) ||
        (hwDeviceExtension->BusInterruptVector != 0)) {

        GetIrqInfo->dwFlags = IRQINFO_HANDLED;

        status = DX_OK;
    }

    return status;
}

BOOLEAN
Interrupt(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine is the interrupt service routine for the kernel video
    driver.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    TRUE if the interrupt is serviced; FALSE if it wasn't ours (this is done
    to support chained interrupts).

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    // add your IRQ handling code here
}

DWORD
EnableIrq(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PDDENABLEIRQINFO EnableIrqInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function notifies the miniport when it should enable or disable
    interrupts for VPE.  If an IRQ is not specified in this call, it
    should be disabled.

    On NT, since miniports always "manage the IRQ", we must call DirectDraw's
    IRQCallback routine from our HwInterrupt routine to notify DirectDraw
    whenever an interrupt occurs.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    EnableIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // First make sure we stash IRQCallback in our device extension before
    // enabling interrupts for the first time, otherwise we may call a NULL
    // pointer from our HwInterrupt routine!
    //
    // (Note that DirectDraw will give us a valid IRQCallback and lpIRQData
    // even when disabling interrupts, which means we won't crash if an
    // interrupt is taken between this point and the actual disabling of the
    // interrupt.)
    //

    hwDeviceExtension->IRQCallback = EnableIrqInfo->IRQCallback;
    hwDeviceExtension->pIRQData = EnableIrqInfo->lpIRQData;

    //
    // Clear any existing interrupts, turn off all interrupts by default,
    // and enable the new requested interrupts.
    //
    // NOTE: Be very careful if your driver uses interrupts for purposes
    //       other than VPE.  For example, if your display driver uses DMA,
    //       you probably won't want to clear the DMA interrupt flag here!
    //

    // Now enable the master interrupt switch.  Again, be careful if your
    // display driver uses interrupt for purposes other than VPE -- you
    // probably won't want to disable all video interrupts here like we
    // do!
    //
    // Note: DxEnableIrq is the only routine that may access the CRTC
    //       registers!  For more details, read the large note at the
    //       top of this file.
    //

    // If the vsync interrupt has been disabled, but a deferred overlay
    // offset is pending, flush it now.
    //

    return DX_OK;
}


DWORD
FlipVideoPort(
    PVOID HwDeviceExtension,
    PDDFLIPVIDEOPORTINFO FlipVideoPortInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    ULONG offset;

    //
    // Get offset (from framebuffer) and add offset from surface:
    //

    offset = FlipVideoPortInfo->lpTargetSurface->dwSurfaceOffset
           + FlipVideoPortInfo->lpVideoPortData->dwOriginOffset;

    // flip the actual hw surface here

    return DX_OK;
}


DWORD
FlipOverlay(
    PVOID HwDeviceExtension,
    PDDFLIPOVERLAYINFO FlipOverlayInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
BobNextField(
    PVOID HwDeviceExtension,
    PDDBOBNEXTFIELDINFO BobNextFieldInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
SetState(
    PVOID HwDeviceExtension,
    PDDSETSTATEININFO SetStateInInfo,
    PDDSETSTATEOUTINFO SetStateOutInfo
    )

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
SkipNextField(
    PVOID HwDeviceExtension,
    PDDSKIPNEXTFIELDINFO SkipNextFieldInfo,
    PVOID lpOutput
    )

/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
GetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO GetPolarityInInfo,
    PDDGETPOLARITYOUTINFO GetPolarityOutInfo
    )

/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}

DWORD
GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PDDGETCURRENTAUTOFLIPININFO GetCurrentAutoflipInInfo,
    PDDGETCURRENTAUTOFLIPOUTINFO GetCurrentAutoflipOutInfo
    )

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


DWORD
GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PDDGETPREVIOUSAUTOFLIPININFO GetPreviousAutoflipInInfo,
    PDDGETPREVIOUSAUTOFLIPOUTINFO GetPreviousAutoflipOutInfo
    )

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    return DX_OK;
}


VP_STATUS
nvVPEQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface
    )

/*++

Routine Description:

    Generic method for obtaining interfaces from the miniport.

    Among other things, it's used for exporting the DXAPI "kernel-mode
    VPE" interface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    QueryInterface - Pointer to structure that describes the requested
        interface.

Return Value:

    DX_OK if successful.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PDXAPI_INTERFACE DxApiInterface;
    VP_STATUS status;

    status = DXERR_UNSUPPORTED;

    if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_DxApi)) {

        DxApiInterface = (PDXAPI_INTERFACE) QueryInterface->Interface;

        //
        // We are queried here for our "kernel-mode VPE" support only after
        // the display driver has already enabled VPE.  Consequently, we let
        // the display driver control what chips VPE is enabled on -- we
        // don't have to do that here.
        //

        DxApiInterface->Size    = sizeof(DXAPI_INTERFACE);
        DxApiInterface->Version = DXAPI_HALVERSION;
        DxApiInterface->Context = hwDeviceExtension;

        DxApiInterface->DxGetIrqInfo          = GetIrqInfo;
        DxApiInterface->DxEnableIrq           = EnableIrq;
        DxApiInterface->DxSkipNextField       = SkipNextField;
        DxApiInterface->DxBobNextField        = BobNextField;
        DxApiInterface->DxSetState            = SetState;
        DxApiInterface->DxFlipOverlay         = FlipOverlay;
        DxApiInterface->DxFlipVideoPort       = FlipVideoPort;
        DxApiInterface->DxGetPolarity         = GetPolarity;
        DxApiInterface->DxGetCurrentAutoflip  = GetCurrentAutoflip;
        DxApiInterface->DxGetPreviousAutoflip = GetPreviousAutoflip;

        status = DX_OK;
    }

    return status;
}

#endif /* VPE_NT */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\i386\gtfmath.inc ===
option expr32
option casemap:none

; Begin of file temp.h
ULONG		TYPEDEF		DWORD

tagGTFIN		STRUCT 2t
dwHPixels		ULONG		?
dwVLines		ULONG		?
dwMarginsRqd		ULONG		?
dwIntRqd		ULONG		?
dwIPParmType		ULONG		?
dwIPFreqRqd		ULONG		?
tagGTFIN		ENDS

GTFIN		TYPEDEF		tagGTFIN

LPGTFIN		TYPEDEF		PTR GTFIN

IPTYPE_VERTICAL_REFRESH_RATE		EQU		1t
IPTYPE_HORIZONTAL_REFRESH_RATE		EQU		2t
IPTYPE_PIXEL_CLOCK_RATE		EQU		3t
tagGTFOUT		STRUCT 2t
dwHTotalChars		ULONG		?
dwVTotalScans		ULONG		?
dwHActiveChars		ULONG		?
dwVActiveScans		ULONG		?
dwHBlankStartChar		ULONG		?
dwHFrontPorchChars		ULONG		?
dwHSyncChars		ULONG		?
dwHBackPorchChars		ULONG		?
dwHBlankEndChar		ULONG		?
dwVBlankStartScan		ULONG		?
dwVFrontPorchScans		ULONG		?
dwVSyncScans		ULONG		?
dwVBackPorchScans		ULONG		?
dwVBlankEndScan		ULONG		?
dwPixelClockIn10KHertz		ULONG		?
tagGTFOUT		ENDS

GTFOUT		TYPEDEF		tagGTFOUT

LPGTFOUT		TYPEDEF		PTR GTFOUT

; End of file temp.h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\gtfmathstubs.c ===
#if defined(_WIN64)

#include "cmntypes.h"
#include "gtfmath.h"

/*
;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
;               This is currently just stubbed out for Win64.
;
; Returns:      0       failure and lpGTFOut was not filled in
;
;==============================================================================
*/
ULONG WINAPI ComputeGTFParameters
(
        LPGTFIN  lpGtfIn,
        LPGTFOUT lpGtfOut
)
{
    return(0);
}
ULONG WINAPI Divide32By32
(
        ULONG dwDividend,
        ULONG dwDivisor
)
{
    return (dwDividend / dwDivisor);
}
ULONG WINAPI Multiply32By32
(
        ULONG dwMult1,
        ULONG dwMult2
)
{
    return (dwMult1 * dwMult2);
}
#endif // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\include\MODESET.H ===
/*
    FILE:   modeset.h
    DATE:   4/8/99

    This file holds the format for some tables and structures used
    internally by the DLL. OS independent.
*/

// This is the structure format in which we the mode timing tables
// in this DLL are stored. This should never need to be changed.
typedef struct  _tagMODESTRUC
{
    USHORT  wHorizVisible;
    USHORT  wVertVisible;
    USHORT  wRefresh;
    USHORT  wHorizTotal;
    USHORT  wHorizBlankStart;
    USHORT  wHorizSyncStart;
    USHORT  wHorizSyncEnd;
    USHORT  wHorizBlankEnd;
    USHORT  wVertTotal;
    USHORT  wVertBlankStart;
    USHORT  wVertSyncStart;
    USHORT  wVertSyncEnd;
    USHORT  wVertBlankEnd;
    USHORT  wDotClock;
    USHORT  wHSyncPolarity;
    USHORT  wVSyncPolarity;
} MODESTRUC;

typedef MODESTRUC FAR *LPMODESTRUC;

// These constants are used in internal tables
#define BUFFER_HSYNC_NEGATIVE           0
#define BUFFER_HSYNC_POSITIVE           1
#define BUFFER_VSYNC_NEGATIVE           0
#define BUFFER_VSYNC_POSITIVE           1


// This information can often be gotten from an EDID. It can be
// used to restrict mode settings.
typedef struct  _tagMONITORLIMITS
{
    ULONG   dwMinHorz;
    ULONG   dwMaxHorz;
    ULONG   dwMinVert;
    ULONG   dwMaxVert;
    ULONG   dwMaxPixelClock;
} MONITORLIMITS;

typedef MONITORLIMITS FAR *LPMONITORLIMITS;


// Here are the external functions
extern int CFUNC  FindNextSmallerResolution (LPMODEENTRY lpModeList,
                                            LPMODEINFO lpModeDesc);

extern int CFUNC  FindNextSmallerRefreshRate (LPMODEENTRY lpModeList,
                                            LPMODEINFO  lpModeDesc);
extern int CFUNC  FindNextLargerRefreshRate (LPMODEENTRY lpModeList,
                                            LPMODEINFO  lpModeDesc);
extern int WINAPI GetSafeTiming (LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC  GetModeFlags (LPMODEINFO lpModeOrig, LPMODEINFO lpModeFound);
extern int WINAPI FormatModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType, LPMODEENTRY lpME);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\include\cmntypes.h ===
/*
    FILE:   cmntypes.h
    DATE:   10/12/1999

    This file contains common type definitions needed in other
    include files and source files so that they don't need to be
    defined in multiple places.
*/

// A few constants
#define TRUE    1
#define FALSE   0
#define NULL    0

// Need these for C To ASM conversion reason.
#ifndef FAR
#ifdef _WIN32
#define FAR
#define CFUNC   __cdecl
#define WINAPI  _stdcall
#else   // !_WIN32

#if     defined(LINUX) | defined(MAC)

#define FAR 
#define CFUNC
#define WINAPI

#else   // !LINUX
#define FAR __far
#define CFUNC   __cdecl  _loadds
#define WINAPI  _far _pascal  _loadds
#endif  // !LINUX
#endif  // !WIN32
#endif  // FAR

// A few basic types
#ifndef ULONG
typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef UCHAR  FAR *    LPCHAR;
typedef USHORT FAR *    LPUSHORT;
typedef ULONG  FAR *    LPULONG;
#endif  // ULONG



#ifdef LINUX
#define __STRUCTURE_PACKING__ __attribute__((packed))
#else
#define __STRUCTURE_PACKING__
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\include\DEBUG.H ===
/*
    FILE:   debug.h
    DATE:   4/8/99

    This file has some things in it for debug.  Since the debug
    facilities are OS dependent, the macros invoke functions that
    can be written in the OS specific libraries.
*/

extern  char    szDebug[512];
extern  ULONG   dwDebugLevel;

// A little bit of debugging support.
#ifdef DEBUG
#define DL_0    1
#define DL_1    2
#define DL_2    3
#define DL_3    4
#define DL_4    5
#define DL_5    6

#define DBG_PRINT0(x,y)     {                                   \
                                if  ((x) <= dwDebugLevel)       \
                                    PrintString0(y);            \
                            }

#define DBG_PRINT1(x,y,z)   {                                   \
                                if  ((x) <= dwDebugLevel)       \
                                    PrintString1(y,z);          \
                            }
#else
#define DBG_PRINT0(x,y)
#define DBG_PRINT1(x,y,z)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\i386\gtfmath.asm ===
;==============================================================================
;
; Copyright (C) 1998, Nvidia Corporation
;
; File:         gtf.asm
;
; Purpose:      This file implements the GTF algorithm
;
;       Just come important comments and definitions I extracted from
;       the GTF document.
;
;       Horizontal - negative
;       Vertical - positive
;       composite - negative
;
;       Blanking Duty Cycle = (1 - tA / T) * 100%
;                     = (       1 - (F * n) / p) * 100%
;               tA = active video time
;               T  = Horizontal period
;               F  = horizontal frequency
;               n  = number of active pixels (Xresolution)
;               p = pixel clock frequency
;
;       Basic form of equation is:
;       Blanking Duty Cycle = C' - (M' / F)
;
;       C' = ((C - J) * (K / 256) + J
;       M' = (K / 256) * M
;
;       Margin% = 1.8%
;       size of top and bottom overscan margin as % of active vertical
;       size of left and right overscan margin as % of active vertical
;
;       CellGran = 8 pixels
;       character cell granularity
;
;       MinPorch = 1 line / 1 char cell
;       Minimum front porch in lines and character cells
;
;       VsyncRqd = 3 lines
;       width of the vsync pulse in scanlines
;
;       HSyncPercent = 8%
;       The width of HSync as a percentage of the total line period
;
;       MinVSyncPlusBackPorch  550us
;       minimum time for vertical sync plus back porch
;
;       M       600% / Khz
;       blanking formula gradient
;
;       C       40%
;       blanking formula offset
;
;       K       128
;       blanking formula scaling factor
;
;       J       20%
;       blanking formula scaling factor weighting
;
;       HPixels    - the horizontal resolution
;       VLines     - the vertical resolution
;       MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;       IntRqd     - this is a flag -- TRUE if interlace, FALSE otherwise
;       IPParm     - this indicates what the last specifying parm will be
;               1  - VFrameRateRqd
;               2  - HFreq
;               3  - PixelClock
;       IPFreqRqd  - Depends upon VPParm
;               If IPParm is this       IPFreqRqd is this
;               1                       vertical refresh rate in hz
;               2                       horizontal refresh rate in Kilohz
;               3                       pixel clock rate in Megahz
;
;       Interestingly enough, the GTF spec says that any monitor that
;       has the GTF bit set, MUST have a Monitor Description Block in
;       the EDID that tells the monitor frequency limits. If this block
;       does not exist, then the monitor should be trated as non-GTF
;       compliant. Byte 10, bit 0 = 1 means that overscan margins are
;       required.
;==============================================================================
.586
include ..\include\macros.dat
include gtfmath.inc

.listall

OPENSEG  _DATA, USE16, DATA
CLOSESEG _DATA

OPENSEG  _NVTEXT32, USE32, CODE

fZeroPointFour                  REAL4   0.4
fZeroPointFive                  REAL4   0.5
fOne                            REAL4   1.0
fOnePointEight                  REAL4   1.8
fTwo                            REAL4   2.0
fThree                          REAL4   3.0
fEight                          REAL4   8.0
fTwenty                         REAL4   20.0
fForty                          REAL4   40.0
fOneHundred                     REAL4   100.0
fOneHundredTwentyEight          REAL4   128.0
fTwoHundredFiftySix             REAL4   256.0
fFiveHundredFifty               REAL4   550.0
fSixHundred                     REAL4   600.0
fOneThousand                    REAL4   1000.0
fOneMillion                     REAL4   1000000.0

;==============================================================================
;
; Function:     ComputeGTFParameters
;
; Purpose:      This function computes the data for the GTFOut structure
;               from the arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    lpGTFIn         FAR ptr to GTFIN structure
;               lpGTFOut        FAR ptr to GTFOUT structure
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
IFDEF  _WIN32
DECPROC ComputeGTFParameters, STANDARD, FRAME, NEAR
ELSE
DECPROC ComputeGTFParameters, PASCAL, FRAME, FAR16
ENDIF
PARMD   lpGTFIn
PARMD   lpGTFOut
OPENPROC
        PUSHR   ds,ebx,esi,edi
IFDEF _WIN32
        mov     ebx,lpGTFIn
        mov     esi,lpGTFOut
ELSE
        sub     ebx,ebx
        lds     bx,lpGTFIn
        sub     esi,esi
        les     si,lpGTFOut
ENDIF
        call    ComputeGTFParameters1
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     ComputeGTFParameters1
;
; Purpose:      This function computes the data for the GTFOut structure
;               from teh arguments in the GTFIn structure provided
;               according to the GTF formula.
;
; Arguments:    ds:ebx  GTFIN ptr
;               es:esi  GTFOUT ptr
;
; Returns:      eax     0       failure and lpGTFOut was not filled in
;                       non-0   success and lpGTFOut was filled in
;
; Preserve:     All registers
;==============================================================================
DECPROC ComputeGTFParameters1, PASCAL, FRAME, NEAR
LOCALD  dwTemp
LOCALR4 fVLinesRnd
LOCALR4 fAddrLinesPerFrame
LOCALR4 fCellGran
LOCALR4 fPixelFreq
LOCALR4 fCharTime
LOCALR4 fTopMarginLines
LOCALR4 fBottomMarginLines
LOCALR4 fVSyncPlusBackPorch
LOCALR4 fMinPorch
LOCALR4 fInterlace
LOCALR4 fTotalLinesPerFrame
LOCALR4 fTotalPixels
LOCALR4 fTotalHTimeChars
LOCALR4 fHPixelsRnd
LOCALR4 fHAddrTime
LOCALR4 fHAddrTimeChars
LOCALR4 fHBlankPixels
LOCALR4 fHBlank
LOCALR4 fHBlankChars
LOCALR4 fLeftMarginPixels
LOCALR4 fRightMarginPixels
LOCALR4 fHBlankPlusMargin
LOCALR4 fHBlankPlusMarginChars
LOCALR4 fActualDutyCycle
LOCALR4 fBlankPlusMarginDutyCycle
LOCALR4 fLeftMargin
LOCALR4 fLeftMarginChars
LOCALR4 fRightMargin
LOCALR4 fRightMarginChars
LOCALR4 fHSyncPercent
LOCALR4 fHSyncPixels
LOCALR4 fHFrontPorchPixels
LOCALR4 fHBackPorchPixels
LOCALR4 fHSyncChars
LOCALR4 fHSync
LOCALR4 fHFrontPorchChars
LOCALR4 fHFrontPorch
LOCALR4 fHBackPorchChars
LOCALR4 fHBackPorch
LOCALR4 fTotalVLines
LOCALR4 fHPeriod
LOCALR4 fVFramePeriod
LOCALR4 fVFieldPeriod
LOCALR4 fVAddrTimePerFrame
LOCALR4 fVAddrTimePerField
LOCALR4 fVOddBlankingLines
LOCALR4 fVOddBlanking
LOCALR4 fVEvenBlankingLines
LOCALR4 fVEvenBlanking
LOCALR4 fTopMargin
LOCALR4 fVOddFrontPorch
LOCALR4 fVOddFrontPorchLines
LOCALR4 fVEvenFrontPorch
LOCALR4 fVSyncRqd
LOCALR4 fVSync
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorch
LOCALR4 fVBackPorch
LOCALR4 fVEvenBackPorchLines
LOCALR4 fVOddBackPorch
LOCALR4 fBottomMargin
LOCALR4 fMarginPercent
LOCALR4 fMinVSyncPlusBackPorch
LOCALR4 fGTF_M
LOCALR4 fGTF_C
LOCALR4 fGTF_J
LOCALR4 fGTF_K
LOCALR4 fGTF_CPrime
LOCALR4 fGTF_MPrime
LOCALR4 fVFieldRateRqd
LOCALR4 fHPeriodEst
LOCALR4 fVFieldRateEst
LOCALR4 fVFieldRate
LOCALR4 fVFrameRate
LOCALR4 fTotalActivePixels
LOCALR4 fIdealDutyCycle
LOCALR4 fHFreq
LOCALR4 fIdealHPeriod
OPENPROC
        PUSHR   ds,ebx,esi,edi

        ; Reset the floating point unit
        fninit

        ; Set up all the constants we need
        call    SetupGTFConstants

        ; Now we compute the stage 1 parameters. There are three cases
        ; depending upon the IPParm which gives the type of the IPFreqRqd.
        push    OFFSET DoneStage1Parms
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_VERTICAL_REFRESH_RATE
        je      VerticalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_HORIZONTAL_REFRESH_RATE
        je      HorizontalRefreshToStage1Parameters
        cmp     ds:[ebx].GTFIN.dwIPParmType,IPTYPE_PIXEL_CLOCK_RATE
        je      PixelClockToStage1Parameters
        pop     eax
        sub     eax,eax
        jmp     Done

DoneStage1Parms:
        ; Convert stage 1 to stage 2 parameters

        ; 1) Find the adressable lines per frame
        fld     fVLinesRnd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fAddrLinesPerFrame

        ; 2) Find the character time in nanoseconds
        fld     fCellGran
        fdiv    fPixelFreq
        fmul    fOneThousand
        fstp    fCharTime

        ; 3) Find total number of lines in a frame
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fTotalLinesPerFrame

        ; 4) Find total number of chars in a horizontal line
        fld     fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fTotalHTimeChars

        ; 5) Find the horizontal addressable time in microseconds
        fld     fHPixelsRnd
        fdiv    fPixelFreq
        fstp    fHAddrTime

        ; 6) Find the horizontal addressable time in chars
        fld     fHPixelsRnd
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHAddrTimeChars

        ; 7) Find horizontal blanking time in microseconds
        fld     fHBlankPixels
        fdiv    fPixelFreq
        fstp    fHBlank

        ; 8) Find horizontal blanking time in chars
        fld     fHBlankPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankChars

        ; 9) Find the horizontal blanking plus margin time in microseconds
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fPixelFreq
        fstp    fHBlankPlusMargin

        ; 10) Find the horizontal blanking plus margin time in chars
        fld     fHBlankPixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fstp    fHBlankPlusMarginChars

        ; 11) Find the actual horizontal active video duty cycle in %
        fld     fHBlankChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fActualDutyCycle

        ; 12) Find the image video duty cycle in %
        fld     fHBlankPlusMarginChars
        fdiv    fTotalHTimeChars
        fmul    fOneHundred
        fstp    fBlankPlusMarginDutyCycle

        ; 13) Find the left margin time in microseconds
        fld     fLeftMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fLeftMargin

        ; 14) Find the number of chars in the left margin
        fld     fLeftMarginPixels
        fdiv    fCellGran
        fstp    fLeftMarginChars

        ; 15) Find the right margin time in microseconds
        fld     fRightMarginPixels
        fmul    fPixelFreq
        fmul    fOneThousand
        fstp    fRightMargin

        ; 16) Find the number of chars in the rightt margin
        fld     fRightMarginPixels
        fdiv    fCellGran
        fstp    fRightMarginChars

        ; 17) Find the number of pixels inteh horizontal sync period
        fld     fHSyncPercent
        fdiv    fOneHundred
        fmul    fTotalPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHSyncPixels

        ; 18) Find number of pixels in horizontal front porch period
        fld     fHBlankPixels
        fdiv    fTwo
        fsub    fHSyncPixels
        fstp    fHFrontPorchPixels

        ; 19) Find number of pixels in horizontal front porch period
        fld     fHFrontPorchPixels
        fadd    fHSyncPixels
        fstp    fHBackPorchPixels

        ; 20) Find number of characters in the horizontal sync period
        fld     fHSyncPixels
        fdiv    fCellGran
        fstp    fHSyncChars

        ; 21) Find the horizontal sync period in microseconds
        fld     fHSyncPixels
        fdiv    fPixelFreq
        fstp    fHSync

        ; 22) Find the number of chars in the horizontal front porch
        fld     fHFrontPorchPixels
        fdiv    fCellGran
        fstp    fHFrontPorchChars

        ; 23) Find the horizontal front porch period in microseconds
        fld     fHFrontPorchPixels
        fdiv    fPixelFreq
        fstp    fHFrontPorch

        ; 24) Find the number of chars in the horizontal back porch
        fld     fHBackPorchPixels
        fdiv    fCellGran
        fstp    fHBackPorchChars

        ; 25) Find the horizontal front back period in microseconds
        fld     fHBackPorchPixels
        fdiv    fPixelFreq
        fstp    fHBackPorch

        ; 26) Find the vertical frame period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVFramePeriod

        ; 27) Find the vertical field period in milliseconds
        fld     fTotalVLines
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVFieldPeriod

        ; 28) Find the addressable vertical period per frame in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fmul    fTwo
@@:     fstp    fVAddrTimePerFrame

        ; 29) Find the addressable vertical period per field in milliseconds
        fld     fVLinesRnd
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVAddrTimePerField

        ; 30) Find the number of lines in teh odd blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fstp    fVOddBlankingLines

        ; 31) Find the odd blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVOddBlanking

        ; 32) Find the number of lines in the even blanking period
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fstp    fVEvenBlankingLines

        ; 33) Find the even blanking period in milliseconds
        fld     fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fadd    fInterlace
        fmul    fHPeriod
        fdiv    fOneThousand
        fstp    fVEvenBlanking

        ; 34) Find the top margin period in microseconds
        fld     fTopMarginLines
        fmul    fHPeriod
        fstp    fTopMargin

        ; 35) Find the odd front porch in microseconds
        fld     fMinPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVOddFrontPorch

        ; 36) Find the number of lines in the odd front porch period
        fld     fMinPorch
        fadd    fInterlace
        fstp    fVOddFrontPorchLines

        ; 37) Find the even front porch period
        fld     fMinPorch
        fmul    fHPeriod
        fstp    fVEvenFrontPorch

        ; 38) Find the vertcial sync period in microseconds
        fld     fVSyncRqd
        fmul    fHPeriod
        fstp    fVSync

        ; 39) Find the even front porch period in microseconds
        fld     fVBackPorch
        fadd    fInterlace
        fmul    fHPeriod
        fstp    fVEvenBackPorch

        ; 40) Find the number of lines in the even fron tporch period
        fld     fVBackPorch
        fadd    fInterlace
        fstp    fVEvenBackPorchLines

        ; 41) Find the odd back porch period in microseconds
        fld     fVBackPorch
        fmul    fHPeriod
        fstp    fVOddBackPorch

        ; 42) Find the bottom margin period in microseconds
        fld     fBottomMarginLines
        fmul    fHPeriod
        fstp    fBottomMargin

        ; Cram all the data into GTFOut
        fld     fTotalHTimeChars
        fistp   es:[esi].GTFOUT.dwHTotalChars
        fld     fTotalLinesPerFrame
        fistp   es:[esi].GTFOUT.dwVTotalScans
        fld     fHAddrTimeChars
        fistp   es:[esi].GTFOUT.dwHActiveChars
        fld     fVLinesRnd
        fistp   es:[esi].GTFOUT.dwVActiveScans
        fld     fHAddrTimeChars
        fadd    fRightMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankStartChar
        fld     fHFrontPorchChars
        fistp   es:[esi].GTFOUT.dwHFrontPorchChars
        fld     fHSyncChars
        fistp   es:[esi].GTFOUT.dwHSyncChars
        fld     fHBackPorchChars
        fistp   es:[esi].GTFOUT.dwHBackPorchChars
        fld     fTotalHTimeChars
        fsub    fLeftMarginChars
        fistp   es:[esi].GTFOUT.dwHBlankEndChar
        fld     fVLinesRnd
        fadd    fBottomMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankStartScan
        fld     fVOddFrontPorchLines
        fistp   es:[esi].GTFOUT.dwVFrontPorchScans
        fld     fVSyncRqd
        fistp   es:[esi].GTFOUT.dwVSyncScans
        fld     fVEvenBackPorchLines
        fistp   es:[esi].GTFOUT.dwVBackPorchScans
        fld     fTotalLinesPerFrame
        fsub    fTopMarginLines
        fistp   es:[esi].GTFOUT.dwVBlankEndScan
        fld     fPixelFreq
;;;        fmul    fOneMillion
        fmul    fOneHundred
        fistp   es:[esi].GTFOUT.dwPixelClockIn10KHertz

        ; Return success
        mov     eax,1

Done:
        POPR    ds,ebx,esi,edi
CLOSEPROC


;==============================================================================
;
; Function:     SetupGTFConstants
;
; Purpose:      This function sets up all the "constants" used by
;               the GTF calculation. I make these constants into
;               variables because the spec says to -- at some point
;               in the future the GTF spec may be extended and they
;               want the flexibility to adjust these "constants" to
;               new values. By making the constants into variables
;               I just make the upgrade path easy.
;
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC SetupGTFConstants, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; This is the size of the top (or bottom -- they are the same)
        ; overscan area as a percentage of the total vertcical time.
        fld     fOnePointEight
        fstp    fMarginPercent

        ; Number of pixels per character cell
        fld     fEight
        fstp    fCellGran

        ; Minimum horizontal front porch in character cells and
        ; minimum vertical front porch in scanlines (they are the same.)
        fld     fOne
        fstp    fMinPorch

        ; Width of vsync pulse in scanlines
        fld     fThree
        fstp    fVSyncRqd

        ; Width of the hsync pulse as a percentage of horizontal line time
        fld     fEight
        fstp    fHSyncPercent

        ; minimum time for vertical sync plus back porch in microseconds
        fld     fFiveHundredFifty
        fstp    fMinVSyncPlusBackPorch

        ; These apply to the Basic Blanking Duty Cycle Equation.
        ; See the top of the file.
        fld     fSixHundred
        fstp    fGTF_M
        fld     fForty
        fstp    fGTF_C
        fld     fOneHundredTwentyEight
        fstp    fGTF_K
        fld     fTwenty
        fstp    fGTF_J

        ; This is forced by GTF definitions
        ; C' = ((C - J) * (K / 256) + J
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fld     fGTF_C
        fsub    fGTF_J
        fmulp   ST(1),ST(0)
        fadd    fGTF_J
        fstp    fGTF_CPrime

        ; This is forced by GTF definitions
        ; M' = (K / 256) * M
        fld     fGTF_K
        fdiv    fTwoHundredFiftySix
        fmul    fGTF_M
        fstp    fGTF_MPrime

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     VerticalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given in the GTFIn struct.
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - This value is IPTYPE_VERTICAL_REFRESH_RATE
;               IPFreqRqd  - vertical refresh rate in hertz
;
; Arguments:    ds:ebx  ptr to lpGTFIn structure
;               You have the stack frame available to ComputeGTFParameters
;               but be careful about ptrs, because they are flat 32bit ptrs
;               if you are running under WinNT and 16:16 ptrs if you are
;               running under Win9X. You shouldn't need to load any ptrs
;               since lpGTFIn is already passed into this routine in the
;               correct format.
;
; Returns:      None
;
; Preserve:     ds,esi,edi,ebx
;==============================================================================
DECPROC VerticalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the frame rate required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fadd    ST(0),ST(0)
@@:     fstp    fVFieldRateRqd

        ; 4) Find the number of lines in the top margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fMarginPercent
        fdiv    fOneHundred
        fmul    fVLinesRnd
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Estimate the horizontal period
        fld1
        fdiv    fVFieldRateRqd
        fld     fMinVSyncPlusBackPorch
        fdiv    fOneMillion
        fsubp   ST(1),ST(0)
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fTopMarginLines
        fadd    fMinPorch
        fadd    fInterlace
        fdivp   ST(1),ST(0)
        fmul    fOneMillion
        fstp    fHPeriodEst

        ; 8) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fdiv    fHPeriodEst
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 9) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 10) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 11) Estimate the vertical field frequency
        fld1
        fdiv    fHPeriodEst
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRateEst

        ; 12) Find the actual horizontal period
        fld     fHPeriodEst
        fmul    fVFieldRateEst
        fdiv    fVFieldRateRqd
        fstp    fHPeriod

        ; 13) Find the actual vertical field frequency
        fld1
        fdiv    fHPeriod
        fdiv    fTotalVLines
        fmul    fOneMillion
        fstp    fVFieldRate

        ; 14) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 15) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 16) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 17) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 18) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 19) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 20) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 21) Find the pixel clock frequency
        fld     fTotalPixels
        fdiv    fHPeriod
        fstp    fPixelFreq

        ; 22) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHPeriod
        fstp    fHFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     HorizontalRefreshToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_HORIZONTAL_REFRESH_RATE
;               IPFreqRqd  - horizontal refresh rate in Kilohertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC HorizontalRefreshToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fHFreq

        ; 4) Find the number of lines in the top margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 5) Find the number of lines in the bottom margin
        sub     eax,eax
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 6) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 7) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fistp   dwTemp
        fild    dwTemp
        fstp    fVSyncPlusBackPorch

        ; 8) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 9) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 10) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 11) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        ; 12) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 13) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 14) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 15) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fdiv    fHFreq
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 16) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 17) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 18) Find the horizontal frequency
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 19) Find the pixel clock frequency
        fld     fTotalPixels
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fPixelFreq

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     PixelClockToStage1Parameters
;
; Purpose:      This function compautes GTF stage 1 parameters assuming
;               that the following parameters are given:
;
;               These are always required by GTF:
;               HPixels    - the horizontal resolution
;               VLines     - the vertical resolution
;               MarginsRqd - this is a flag -- TRUE if borders, FLASE if none
;               IntRqd     - this is a flag -- TRUE if interlace, else FALSE
;
;               For this computation these parameters are:
;               IPParm     - IPTYPE_PIXEL_CLOCK_RATE
;               IPFreqRqd  - pixel clock rate in Megahertz
;
; Arguments:
;
; Returns:      None
;
; Preserve:     ds,ebx,es,esi
;==============================================================================
DECPROC PixelClockToStage1Parameters, PASCAL, NOFRAME, NEAR
OPENPROC
        PUSHR   ds,ebx,es,esi

        ; 1) Make sure that the XResolution is a multiple of char cell size
        fild    ds:[ebx].GTFIN.dwHPixels
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
        fstp    fHPixelsRnd

        ; 2) If interlace is requested, half the number of vertical lines
        ;    since the calculation is really vertical lines per field
        fild    ds:[ebx].GTFIN.dwVLines
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVLinesRnd

        ; 3) Find the horizontal freqency required
        fild    ds:[ebx].GTFIN.dwIPFreqRqd
        fstp    fPixelFreq

        ; 4) Find the number of pixels in the left margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fLeftMarginPixels

        ; 5) Find the number of pixels in the right margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fHPixelsRnd
        fmul    fMarginPercent
        fdiv    fOneHundred
        fdiv    fCellGran
        fistp   dwTemp
        fild    dwTemp
        fmul    fCellGran
@@:     fstp    fRightMarginPixels

        ; 6) Find total number of active pixels in image+left+right margin
        fld     fHPixelsRnd
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fstp    fTotalActivePixels

        ; 7) Find the ideal horizontal period from blanking duty cycle Eq
        fld     fOneHundred
        fsub    fGTF_CPrime
        fmul    ST(0),ST(0)
        fld     fTotalActivePixels
        fadd    fLeftMarginPixels
        fadd    fRightMarginPixels
        fmul    fGTF_MPrime
        fmul    fZeroPointFour
        fdiv    fPixelFreq
        faddp   ST(1),ST(0)
        fsqrt
        fadd    fGTF_CPrime
        fsub    fOneHundred
        fdiv    fTwo
        fdiv    fGTF_MPrime
        fmul    fOneThousand
        fstp    fIdealHPeriod

        ; 8) Find the ideal Blanking duty cycle
        fld     fGTF_CPrime
        fld     fGTF_MPrime
        fmul    fIdealHPeriod
        fdiv    fOneThousand
        fsubp   ST(1),ST(0)
        fstp    fIdealDutyCycle

        ; 9) Find the number of pixels in the blanking time to the
        ; nearest double character cell
        fld     fTotalActivePixels
        fmul    fIdealDutyCycle
        fld     fOneHundred
        fsub    fIdealDutyCycle
        fdivp   ST(1),ST(0)
        fld     fCellGran
        fadd    ST(0),ST(0)
        fdivp   ST(1),ST(0)
        fistp   dwTemp
        fild    dwTemp
        fadd    ST(0),ST(0)
        fmul    fCellGran
        fstp    fHBlankPixels

        ; 10) Find the total number of pixels
        fld     fTotalActivePixels
        fadd    fHBlankPixels
        fstp    fTotalPixels

        ; 11) Find the horizontal frequency
        fld     fPixelFreq
        fdiv    fTotalPixels
        fmul    fOneThousand
        fstp    fHFreq

        ; 12) Find the horizontal period
        fld     fOneThousand
        fdiv    fHFreq
        fstp    fHPeriod

        ; 13) Find the number of lines in the top margin
        fldz    
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fTopMarginLines

        ; 14) Find the number of lines in the bottom margin
        fldz
        cmp     ds:[ebx].GTFIN.dwMarginsRqd,0
        je      @F
        fld     fMarginPercent
        fmul    fVLinesRnd
        fdiv    fOneHundred
@@:     fstp    fBottomMarginLines

        ; 15) If interlace is required, set dwInterlace to 0.5
        fldz
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        faddp   ST(0),ST(0)             ; pop the stack
        fld     fZeroPointFive
@@:     fstp    fInterlace

        ; 16) Find the number of lines in fMinVSyncPlusBackPorch
        fld     fMinVSyncPlusBackPorch
        fmul    fHFreq
        fdiv    fOneThousand
        fstp    fVSyncPlusBackPorch

        ; 17) Find the number of lines in VBackPorch alone
        fld     fVSyncPlusBackPorch
        fsub    fVSyncRqd
        fstp    fVBackPorch

        ; 18) Find the total number of lines in the vertical field
        fld     fVLinesRnd
        fadd    fTopMarginLines
        fadd    fBottomMarginLines
        fadd    fVSyncPlusBackPorch
        fadd    fMinPorch
        fadd    fInterlace
        fstp    fTotalVLines

        ; 19) Find the actual vertical field frequency
        fld     fHFreq
        fdiv    fTotalVLines
        fmul    fOneThousand
        fstp    fVFieldRate

        ; 20) Find the vertical frame frequency
        fld     fVFieldRate
        cmp     ds:[ebx].GTFIN.dwIntRqd,0
        je      @F
        fdiv    fTwo
@@:     fstp    fVFrameRate

        POPR    ds,ebx,es,esi
CLOSEPROC


;==============================================================================
;
; Function:     Divide32By32
;
; Purpose:      This function divides a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Divide32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Divide32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwDividend
PARMD   dwDivisor
OPENPROC
        sub     edx,edx
        mov     eax,dwDividend
        cmp     dwDivisor,edx
        jne     valid
divbyzero:
        cmp     eax,edx                 ; is numerator zero?
        je      done                    ; yes - eax:edx = 0
        mov     eax,-1                  ; no - call it infinity
        mov     edx,-1                  ; eax:edx = -1
        jmp     done
valid:  
        div     dwDivisor
done:
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC


;==============================================================================
;
; Function:     Multiply32By32
;
; Purpose:      This function multiplies a 32bit number by another 32bit
;               number. The problem is that the 16bit compiler can't do
;               this without linking in a library.
;
; Arguments:
;
; Returns:      quotient.
;
; Preserve:     All registers
;==============================================================================
IFDEF _WIN32
DECPROC Multiply32By32, STANDARD, FRAME, NEAR
ELSE
DECPROC Multiply32By32, PASCAL, FRAME, FAR16
ENDIF
PARMD   dwMult1
PARMD   dwMult2
OPENPROC
        mov     eax,dwMult1
        imul    eax,dwMult2
IFNDEF _WIN32
        mov     edx,eax
        shr     edx,10H
ENDIF
CLOSEPROC

CLOSESEG _NVTEXT32

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\UTILS.C ===
/*
    FILE:   utils.c
    DATE:   4/8/99

    This file provides common utilities other modules.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "debug.h"
#include "gtfmath.h"

/*
    Function:   FindMode

    Purpose:    This routine searches the table passed in lpMS for the
                XRes, YRes, and RRate specified.

    Arguments:  lpMS        ptr to current MODESTRUC table
                lpModeOut   ptr to MODEOUT structure where timing
                            parameters are placed if the mode given
                            by lpMS is found.
                dwXRes      X-Resolution
                dwYRes      Y-Resolution
                dwRRate     Refresh Rate

    Returns:    Index into MODESTRUC table if a matching mode is found.
                -1 if no matching mode is found.
*/

int CFUNC
FindMode (
    LPMODESTRUC lpMS,
    ULONG       dwXRes,
    ULONG       dwYRes,
    ULONG       dwRRate)
{
    int     i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible == dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible == dwYRes)  &&
            ((ULONG) lpMS[i].wRefresh == dwRRate))
        return  (i);
    }

    return  (-1);
}



/*
    Function:   FindModeWithoutRR

    Purpose:    This routine searches the table passed in lpMS for the
                XRes, YRes specified with the highest RRate.

    Arguments:  lpMS        ptr to current MODESTRUC table
                dwXRes      X-Resolution
                dwYRes      Y-Resolution
                dwRRate     Refresh Rate

    Returns:    Index into MODESTRUC table if a matching mode is found.
                -1 if no matching mode is found.
*/

int CFUNC
FindModeWithoutRR (
    LPMODESTRUC lpMS,
    ULONG       dwXRes,
    ULONG       dwYRes)
{
    int     i;

    for (i = 0; lpMS[i].wHorizVisible != 0x00; i++)
    {
        if (((ULONG) lpMS[i].wHorizVisible == dwXRes) &&
            ((ULONG) lpMS[i].wVertVisible == dwYRes))
        return  (i);
    }

    return  (-1);
}



/*
    Function:   SetupParamsForVidLutClass

    Purpose:    This routine translates the mode found into the
                parameter format of the VIDEOLUTCURSORDAC class.

    Arguments:  lpMS        ptr to MODESTRUC structure
                lpModeOut   ptr to MODEOUT structure where parameters go.
                lpModeIn    MODEINFO ptr describing mode

    Returns:    Ptr to table with parameters in proper format for the
                VIDEOLUTCURSORDAC class.
*/

int CFUNC
SetupParamsForVidLutClass (
    LPMODESTRUC         lpMS,
    LPMODEOUT           lpModeOut,
    LPMODEINFO          lpModeIn)
{
    ULONG   dwFormat;

    lpModeOut->wXRes        = lpMS->wHorizVisible;
    lpModeOut->wYRes        = lpMS->wVertVisible;
    lpModeOut->wRefreshRate = lpMS->wRefresh;
    lpModeOut->wHBlankStart = lpMS->wHorizBlankStart;
    lpModeOut->wHBlankWidth = lpMS->wHorizBlankEnd - lpMS->wHorizBlankStart;
    lpModeOut->wHSyncStart  = lpMS->wHorizSyncStart;
    lpModeOut->wHSyncWidth  = lpMS->wHorizSyncEnd - lpMS->wHorizSyncStart;
    lpModeOut->wVBlankStart = lpMS->wVertBlankStart;
    lpModeOut->wVBlankWidth = lpMS->wVertBlankEnd - lpMS->wVertBlankStart;
    lpModeOut->wVSyncStart  = lpMS->wVertSyncStart;
    lpModeOut->wVSyncWidth  = lpMS->wVertSyncEnd - lpMS->wVertSyncStart;
    lpModeOut->wHTotal      = lpMS->wHorizTotal;
    lpModeOut->wVTotal      = lpMS->wVertTotal;

    lpModeOut->dwPixelClock = (ULONG) lpMS->wDotClock;

    dwFormat = 0;
    if  (lpModeOut->wYRes < 400)    // if YRes < 400 then this is a double
        dwFormat |= 1;              // scan mode, set dwFormat[0] = 1
    if  (!lpMS->wHSyncPolarity)     // 1 = positive polarity in tbl
        dwFormat |= 4;              // 1 = negative polarity in format field
    if  (!lpMS->wVSyncPolarity)     // 1 = positive polarity in tbl
        dwFormat |= 8;              // 1 = negative polarity in format field

    if  (lpModeIn->dwBpp == 15)
        dwFormat |= 0x20000;        // 15 BPP
    if  (lpModeIn->dwBpp == 16)
        dwFormat |= 0x10000;        // 16 BPP
    if  (lpModeIn->dwBpp == 32)
        dwFormat |= 0x30000;        // 32 BPP

    // Set the display type. Note: DEVTYPE_CRT = 0 so no bits need to be
    // set in dwFormat.
    if  (lpModeIn->MIDevData.cType == DEVTYPE_DFP)
        dwFormat |= 0x300000;
    if  (lpModeIn->MIDevData.cType == DEVTYPE_TV)
    {
        dwFormat |= 0x100000;
        // Set the TV Format
        dwFormat |= ((ULONG) (lpModeIn->MIDevData.cFormat)) << 22;
    }

    lpModeOut->dwFormat = dwFormat; // Store Format

    return  (TRUE);
}



/*
    Function:   SetupParamsForModeINfo

    Purpose:    This routine translates the mode found into the
                parameter format of the MODEINFO structure.

    Arguments:  lpModeOut   MODEOUT ptr to mode found
                lpModeOrig  This is the originally requested mode
                lpModeIn    This will be a MODEINFO structure that
                            describes the same thing as the lpModeOut
                            describes

    Returns:    dwXRes, dwYRes, dwBpp, dwRefreshRate from MODEOUT structure
                in MODEINFO structure.
*/

int CFUNC
SetupParamsForModeInfo (
    LPMODEOUT           lpModeOut,
    LPMODEINFO          lpModeOrig,
    LPMODEINFO          lpModeIn)
{
    ULONG   dwBpp;

    *lpModeIn = *lpModeOrig;

    dwBpp = 0;
    if ((lpModeOut->dwFormat & 0x30000) == 0x00000)
        dwBpp = 8;
    if ((lpModeOut->dwFormat & 0x30000) == 0x20000)
        dwBpp = 15;
    if ((lpModeOut->dwFormat & 0x30000) == 0x10000)
        dwBpp = 16;
    if ((lpModeOut->dwFormat & 0x30000) == 0x30000)
        dwBpp = 32;

    lpModeIn->dwXRes        = (ULONG) lpModeOut->wXRes;
    lpModeIn->dwYRes        = (ULONG) lpModeOut->wYRes;
    lpModeIn->dwBpp         = dwBpp;
    lpModeIn->dwRefreshRate = (ULONG) lpModeOut->wRefreshRate;

    return  (TRUE);
}


/*
    ParseDecimalSeparator

    This routine parses a decimal number from the string passed in. It
    assigns it into lpNum. Upon returning lpIndex is adjusted so that it
    points to the first char after the separator following the number
    parsed. If a NULL followed the number parse (i.e. end of the string),
    lpIndex is left pointing to the NULL, but the routine still
    succeeds. If the number was bad or wasn't found before the comma
    separatorthe separator wasn't a could not be found before the end of
    the string or before the next comma, FALSE is returned. If a number
    was found and everything is fine, TRUE is returned.
*/
int CFUNC
ParseDecimalSeparator (
    LPCHAR  lpStr,
    LPULONG lpIndex,
    LPULONG lpNum,
    char    cSeparator1,
    char    cSeparator2)
{
    ULONG   dwIsNum;
    USHORT  wDec;

    *lpNum  = 0;
    dwIsNum = FALSE;
    while   (TRUE)
    {
        if  ((lpStr[*lpIndex] == cSeparator1) ||
             (lpStr[*lpIndex] == cSeparator2))
        {
            // If we did not find at least one decimal digit, then
            // the Num field was not present -- this is an error.
            if  (!dwIsNum)
            {
                DBG_PRINT1(DL_5, "\r\nNo Num found before comma in %s", lpStr);
                return  (FALSE);
            }

            DBG_PRINT1(DL_5, "\r\nParseDecimal found %ld.", *lpNum);

            // Only bump to after the separator if the separator was
            // not the end of the string
            if  (lpStr[*lpIndex] != 0)
                *lpIndex += 1;

            return  (TRUE);
        }

        wDec = (USHORT) GetDecimalValue (lpStr[*lpIndex]);
        if  (wDec == 0x0FFFF)
        {
            DBG_PRINT1(DL_5, "\r\nNon-decimal digit found in Num in %s", lpStr);
            return  (FALSE);
        }

        // We have found at least one decimal digit
        dwIsNum = TRUE;

        // Keep a running computation going here.
        *lpNum = *lpNum * 10 + (ULONG) wDec;

        // go to next char
        *lpIndex += 1;
    }

    return  (TRUE);
}


/*
    ParseDecimalNumberAndFractionAndSeparator

    This routine parses a decimal number from the string passed in. It
    assigns it into lpNum. Upon returning lpIndex is adjusted so that it
    points to the first char after the separator following the number
    parsed. If the number has a decimal point and some fraction following
    it, like 50.03, the fractional portion is parsed but discarded and
    *lpIndex is updated to the first character after the separator
    following 50.03
    If a NULL followed the number parse (i.e. end of the string),
    lpIndex is left pointing to the NULL, but the routine still
    succeeds. If the number was bad or wasn't found before the
    separator or the separator couldd not be found before the end of
    the string , FALSE is returned. If a number
    was found and everything is fine, TRUE is returned.
*/
int CFUNC
ParseDecimalNumberAndFractionAndSeparator (
    LPCHAR  lpStr,
    LPULONG lpIndex,
    LPULONG lpNum,
    char    cSeparator1,
    char    cSeparator2)
{

    ParseDecimalSeparator (lpStr, lpIndex, lpNum, cSeparator1, cSeparator2);

    if  (lpStr[*lpIndex] == '.')
    {
        do
        {
            (*lpIndex)++;
        }
        while   ((lpStr[*lpIndex] != '-') && (lpStr[*lpIndex] != ','));

        (*lpIndex)++;
    }

    return  (TRUE);
}


/*
    GetDecimalValue

    This routine accepts a single char as an argument and returns
    the decimal value of that character.  If the char is not
    0-9 then 0x0FFFF is returned.
*/
ULONG CFUNC
GetDecimalValue (char cDigit)
{
    if  ((cDigit >= '0') && (cDigit <= '9'))
    {
        return  ((ULONG) (cDigit - '0'));
    }

    return  (0x0FFFFFFFF);
}


/*
    GetHexValue

    This routine accepts a single char as an argument and returns
    the hexidecimal value of that character.  If the char is not
    0-9,A-F,or a-f, then 0x0FFFF is returned.
*/
ULONG CFUNC
GetHexValue (char cDigit)
{
    if  ((cDigit >= '0') && (cDigit <= '9'))
    {
        return  ((ULONG) (cDigit - '0'));
    }
    else
    {
        if  ((cDigit >= 'A') && (cDigit <= 'F'))
        {
            return  ((ULONG) (cDigit - 'A' + 10));
        }
        else
        {
            if  ((cDigit >= 'a') && (cDigit <= 'f'))
            {
                return  ((ULONG) (cDigit - 'a' + 10));
            }
            else
            {
                return  (0x0FFFFFFFF);
            }
        }
    }
}


/*
    ParseHexSeparator

    This routine parses up to 8 hex digits from the string passed in.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the separator following the
    number parsed. If the number was bad, or if the separator was not
    one of two possible types or if the end of string was not found
    (i.e. NULL) immediately after it, then a FALSE is returned.
    Otherwise TRUE is returned.
*/
int CFUNC
ParseHexSeparator (
        LPCHAR  lpStr,
        LPULONG lpIndex,
        LPULONG lpNum,
        ULONG   dwLen,
        char    cSeparator1,
        char    cSeparator2)
{
    ULONG   dwI;
    ULONG   bFoundDigit;
    ULONG   dwHex;

    // We have to find at least one digit or there is an error.
    bFoundDigit = FALSE;

    // Start off lpNum at 0
    *lpNum = 0;

    // Get the value of the next eight hex digits.
    for (dwI = 0; dwI < dwLen; dwI++)
    {
        if  ((lpStr[*lpIndex] == cSeparator1) ||
             (lpStr[*lpIndex] == cSeparator2))
        {
            if  (!bFoundDigit)
            {
                DBG_PRINT1(DL_5, "\r\nBad Hex value in %s", lpStr);
                return  (FALSE);
            }

            DBG_PRINT1(DL_5, "\r\nParseHex found %lx.", *lpNum);

            // Only bump to after the separator if the separator was
            // not the end of the string
            if  (lpStr[*lpIndex] != 0)
                *lpIndex += 1;

            return  (TRUE);
        }

        // See if it is a hex digit
        dwHex = GetHexValue(lpStr[*lpIndex]);
        if  (dwHex == 0x0FFFFFFFF)
        {
            DBG_PRINT1(DL_5, "\r\nBad Hex value in %s", lpStr);
            return  (FALSE);
        }

        // We have found at least one decimal digit
        bFoundDigit = TRUE;

        *lpNum = (*lpNum << 4) + dwHex;

        // go to next char
        *lpIndex += 1;
    }

    // We fell out of the loop. That means that the maximum number of
    // hex digits has been seen. That is OK, but if the next char is
    // not one of the separators, then there is a parse error.
    if  ((lpStr[*lpIndex] != cSeparator1) &&
         (lpStr[*lpIndex] != cSeparator2))
    {
        DBG_PRINT1(DL_5, "\r\nHex value too big in %s", lpStr);
        return (FALSE);
    }

    // Only bump to after the separator if it was there
    if  ((lpStr[*lpIndex] == cSeparator1) ||
         (lpStr[*lpIndex] == cSeparator2))
        *lpIndex += 1;

    return  (TRUE);
}


/*
    ParseHexWord

    This routine parses up to 4 hex digits from the string passed in.
    If there are more than 4, then it is a parse error.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the semicolon following the
    number parsed. If the number was bad, or there was no semicolon
    or end of string (i.e. NULL) immediately after it, then a FALSE
    is returned. Otherwise TRUE is returned.
*/
int CFUNC
ParseHexWord (LPCHAR lpStr, LPULONG lpIndex, LPUSHORT lpNum)
{
    int     nRet;
    ULONG   dwNum;

    nRet = ParseHexSeparator (lpStr, lpIndex, &dwNum, 4, ';', ';');
    *lpNum = (USHORT) dwNum;

    return  (nRet);
}


/*
    ParseHexDWord

    This routine parses up to 8 hex digits from the string passed in.
    If there are more than 8, then it is a parse error.
    It assigns it into lpNum. Upon returning lpIndex is adjusted so
    that it points to the first char after the semicolon following the
    number parsed. If the number was bad, or there was no semicolon
    or end of string (i.e. NULL) immediately after it, then a FALSE
    is returned. Otherwise TRUE is returned.
*/
int CFUNC
ParseHexDWord (LPCHAR lpStr, LPULONG lpIndex, LPULONG lpNum)
{
    return  (ParseHexSeparator (lpStr, lpIndex, lpNum, 8, ';', 0));
}


/*
    GetMaximumRefreshRate

    This routine calculates the maximum refresh rate for the target mode
    specified given the maimum XRes and YRes, and the maximum horizontal
    and vertical frequencies.

*/

ULONG CFUNC
GetMaximumRefreshRate (ULONG dwPixelClkXRes,
                       ULONG dwPixelClkYRes,
                       ULONG dwPixelClkRR,
                       LPMONITORLIMITS lpML,
                       ULONG dwTargetXRes,
                       ULONG dwTargetYRes)
{
    ULONG   i;
    ULONG   dwRefreshRate;
    GTFIN   GTFIn;
    GTFOUT  GTFOut;
    ULONG   dwTotalPixels;
    ULONG   dwPixelClockInHz;
    ULONG   dwPixelClockInMHz;
    ULONG   dwHorizRR;
    ULONG   dwHTotalPixels;
    char    FoundRR;

    // If no pixel clock was passed in, calculate one.
    if (!lpML->dwMaxPixelClock)
    {
        // Find a pixel clock from the dwPixelClkXRes, dwPixelClkXRes, and
        // dwPixelClkRR.
        GTFIn.dwHPixels      = dwPixelClkXRes;
        GTFIn.dwVLines       = dwPixelClkYRes;
        GTFIn.dwMarginsRqd   = FALSE;
        GTFIn.dwIntRqd       = FALSE;
        GTFIn.dwIPParmType   = IPTYPE_VERTICAL_REFRESH_RATE;
        GTFIn.dwIPFreqRqd    = dwPixelClkRR;

        // Get the timing parameters.
        ComputeGTFParameters(&GTFIn, &GTFOut);
        dwPixelClockInHz = Multiply32By32(GTFOut.dwPixelClockIn10KHertz,
                                          10000);
        lpML->dwMaxPixelClock = dwPixelClockInHz;
    }
    else
        dwPixelClockInHz = lpML->dwMaxPixelClock;

    for (i = 0, FoundRR = FALSE; (FoundRR != TRUE) && i < 50; i++)
    {
        dwPixelClockInMHz = Divide32By32(dwPixelClockInHz + 1000000/2, 1000000);
    
        GTFIn.dwHPixels      = dwTargetXRes;
        GTFIn.dwVLines       = dwTargetYRes;
        GTFIn.dwMarginsRqd   = FALSE;
        GTFIn.dwIntRqd       = FALSE;
        GTFIn.dwIPParmType   = IPTYPE_PIXEL_CLOCK_RATE;
        GTFIn.dwIPFreqRqd    = dwPixelClockInMHz;
    
        // Get the timing parameters.
        ComputeGTFParameters(&GTFIn, &GTFOut);
    
        dwTotalPixels = Multiply32By32((GTFOut.dwHTotalChars << 3), GTFOut.dwVTotalScans);
    
        dwPixelClockInHz = Multiply32By32(GTFOut.dwPixelClockIn10KHertz, 10000);
        dwRefreshRate = Divide32By32(dwPixelClockInHz + dwTotalPixels/2, dwTotalPixels);
    
        if (dwRefreshRate < 56)
          dwRefreshRate = 60;

        dwHTotalPixels = GTFOut.dwHTotalChars << 3;
        dwHorizRR = Divide32By32(dwPixelClockInHz + dwHTotalPixels/2, dwHTotalPixels);
        if (dwHorizRR > lpML->dwMaxHorz)
        {
          dwPixelClockInHz = Multiply32By32(lpML->dwMaxHorz, dwHTotalPixels);
        }
        else if (dwRefreshRate > lpML->dwMaxVert)
        {
          dwPixelClockInHz = Multiply32By32(lpML->dwMaxVert, dwHTotalPixels);
          dwPixelClockInHz = Multiply32By32(dwPixelClockInHz, GTFOut.dwVTotalScans);
        }
        else
          FoundRR = TRUE;
    }
            
    if  (dwRefreshRate != 0)
        return  (dwRefreshRate);

    return  (60);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\MODESET.C ===
/*
    FILE:   modeset.c
    DATE:   4/8/99

    This file is the generic entry point for the modeset code.
    It contains all the high level logic when modesetting.

    The main entry point is
    FindModeEntry (lpDispData,lpEdidBuffer,dwEdidSize,lpModeDesc,lpModeOut);

    You should consult the header for FindModeEntry for specific details
    about the arguments.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "tvmode.h"
#include "digmode.h"
#include "dmt.h"
#include "osapi.h"
#include "utils.h"

char    szDebug[512];
ULONG   dwDebugLevel = 0;

/*
    Function:   FindModeEntry

    Purpose:

    This routine validates and/or sets the mode. General idea:

    1) For NTSC and PAL devices, the requested mode is compared
       against the restriction list and the master mode list.
       The resolution is adjusted downward as necessary to find
       a mode that is allowed. If no mode is found that is
       permitted, the safe timing is returned.
       MODE_RESOLUTION_ADJUSTED is the actual return value if
       the mode timings returned are not for the mode that was
       requested.

       For NTSC and PAL, the only relevant input fields are:
       lpDispData (all fields), lpEdidBuffer should be NULL,
       dwEdidSize should be 0, lpModeDesc->nXRes, lpModeDesc->nYRes,
       lpModeDesc->nBpp, lpModeDesc->dwDevType should be DEVTYPE_NTSC
       or DEVTYPE_PAL as appropriate.

       On Exit, lpModeOut->rXRes and lpModeOut->rYRes will be assigned
       with the "best fit" mode that can be set. If you are validating
       an NTSC or PAL mode, then if this routine returns anything
       except MODE_EXACT_MATCH, the mode did not validate.

    2) For CRT and PANEL devices, the requested mode is compared
       against the restriction list and the master mode list.
       If necessary, first the refresh rate and as a last resort
       the resolution can be adjusted downward to find a mode that
       is allowed. If no mode is found that is permitted, a set of
       safe settings for some default mode is returned.

       For CRT and PANEL, the only relevant input fields are:
       lpDispData (all fields), lpEdidBuffer should point to a
       valid EDID if the device has one -- otherwise it shoud be NULL,
       dwEdidSize should be the size of the EDID in bytes -- otherwise
       it should be 0, lpModeDesc->nXRes, lpModeDesc->nYRes,
       lpModeDesc->nBpp, lpModeDesc->dwRefreshRate, lpModeDesc->dwDevType
       should be DEVTYPE_CRT or DEVTYPE_PANEL as appropriate,
       lpModeDesc->dwRefreshRate is a specific refresh rate value.

       For CRT and PANEL, the only possible return values are:
       MODE_RESOLUTION_ADJUSTED, MODE_REFRESH_RATE_ADJUSTED,
       or MODE_RESOLUTION_ADJUSTED | MODE_REFRESH_RATE_ADJUSTED.
       This flavor of the routine can NEVER fail. The lpModeOut
       structure should be filled out in its entirety -- all fields
       need to have describe a coherent valid timing. No exceptions.

    Arguments:
        LPDISPDATA      lpDispData
        LPCHAR          lpEdidBuffer
        ULONG           dwEdidSize
        LPMODEINFO      lpModeDesc
        LPMODEOUT       lpModeOut

    Preserve:   Do not change any fields in any of the arguments except
                to pass back the actual mode that was set in lpModeOut.
*/

int WINAPI
FindModeEntry (
    LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew)
{
    int         nRet;
    LPRESTIME   lpRTList;
    LPMODEENTRY lpModeList;
    MODEINFO    ModeDesc;
    ULONG       dwModeSize;

    // Dump out what we are searching for
    DBG_PRINT0(DL_0, "\r\nSearching to match the following mode:");
    DBG_PRINT1(DL_0, "\r\nXRes           = %ld", lpModeDesc->dwXRes);
    DBG_PRINT1(DL_0, "\r\nYRes           = %ld", lpModeDesc->dwYRes);
    DBG_PRINT1(DL_0, "\r\nBpp            = %ld", lpModeDesc->dwBpp);
    DBG_PRINT1(DL_0, "\r\nRefreshRate    = %ld", lpModeDesc->dwRefreshRate);
    DBG_PRINT1(DL_0, "\r\ndwDevType      = %ld", lpModeDesc->MIDevData.cType);

    DBG_PRINT0(DL_0, "\r\n\nFor the following board:");
    DBG_PRINT1(DL_0, "\r\nDeviceID                = %lx", lpDispData->dwDeviceID);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz8bpp  = %lx", lpDispData->dwMaxDacSpeedInHertz8bpp);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz16bpp = %lx", lpDispData->dwMaxDacSpeedInHertz16bpp);
    DBG_PRINT1(DL_0, "\r\nMaxDacSpeedInHertz32bpp = %lx", lpDispData->dwMaxDacSpeedInHertz32bpp);
    DBG_PRINT1(DL_0, "\r\nVideoMemorySize         = %lx", lpDispData->dwVideoMemoryInBytes);

    // Grab the restriction and timing list
    lpRTList = GetMasterRTList (lpDispData);

    // Next, grab the mode list
    lpModeList = GetMasterModeList (lpDispData);

    // Let's assign this to a local so we can change it if we need
    // to without affecting the source.
    ModeDesc = lpModeDesc[0];

    // Let's handle the NTSC/PAL cases here, and be done with them.
    if  (lpModeDesc->MIDevData.cType == DEVTYPE_TV)
    {
        DBG_PRINT0 (DL_0, "\r\nDevice type is NTSC or PAL.");
        nRet = FindTVModeEntry (lpDispData, &ModeDesc, lpModeOut,
                                lpModeList, lpRTList);
    }
    else
    {
        // At this point, we know we are a CRT or FLAT PANEL.
        DBG_PRINT0 (DL_0, "\r\nDevice type is CRT or FLAT PANEL.");

        nRet = FindDigModeEntry (lpEdidBuffer, dwEdidSize, lpDispData,
                          &ModeDesc, lpModeOut, lpModeList, lpRTList);
    }

    // We need to set the pitch in the MODEOUT
    GetPitchAndSize (lpDispData, ModeDesc.dwXRes, ModeDesc.dwYRes,
                ModeDesc.dwBpp, &(lpModeOut->dwPitchInBytes), &dwModeSize);

    // Convert the MODEOUT structure back into a MODEINFO structure
    SetupParamsForModeInfo (lpModeOut, &ModeDesc, lpModeNew);

    FreeMasterRTList (lpRTList);
    FreeMasterModeList (lpModeList);

    return  (nRet);
}


/*
    Function:   FindVirtualModeEntry

    Purpose:

    This routine validates modes just against the amount of memory
    they will consume.No checking is done to see if the mode is
    settable on a CRTC or to get timing parameters for the mode.

    If the mode does not fit in the size specified, the mode is
    backed off progressively in resolution until it will fit.

    Arguments:
                lpRegData       LPREGDATA
                lpModeToTest    LPMODEINFO desribing the mode we want to
                                start out with
                lpModeThatFit   This will hold the mode that actually
                                will fit in dwAvailableMemory. It might
                                be the same as lpModeToTest.
                dwAvailableMemory memory available for the mode
                pfnGetModeMemory  Callback function to get the amount
                                of memory a mode takes up
                dwContext1      data to be passed into callback
                dwContext2      data to be passed into callback

        The format of the callback is:
        pfnGetModeMemory (dwContext1, dwContext2, xres, yres, bpp)
        It returns a ULONG that specifies the memory required to set
        the mode.

    Returns:    TRUE
    Preserve:
*/
typedef int (WINAPI *PFNGETMODEMEMORY) (ULONG, ULONG, ULONG, ULONG, ULONG);

int WINAPI
FindVirtualModeEntry (LPDISPDATA lpDispData, LPMODEINFO lpModeToTest,
                      LPMODEINFO lpModeThatFit, ULONG dwAvailableMemory)
{
    LPMODEENTRY lpModeList;
    ULONG       dwModeMemory, dwPitch;

    // Next, grab the mode list
    lpModeList = GetMasterModeList (lpDispData);

    // Let's assign this to a local so we can change it if we need
    // to without affecting the source.
    *lpModeThatFit = *lpModeToTest;

    do
    {
        GetPitchAndSize (lpDispData, lpModeThatFit->dwXRes,
                        lpModeThatFit->dwYRes, lpModeThatFit->dwBpp,
                        &dwPitch, &dwModeMemory);

        if  (dwModeMemory <= dwAvailableMemory)
            break;
    }
    while   (BackOffDigModeEntry (lpModeList, lpModeThatFit, lpModeToTest, 0));

    // Free this up
    FreeMasterModeList (lpModeList);

    return  (TRUE);
}


/*
    Function:   FindNextSmallerResolution

    Purpose:    This routine finds the next lower resolution at the
                same refresh rate and pixel depth as requested. If
                it finds one, it modifies lpModeDesc to reflect the
                new mode and returns TRUE, else it returns FALSE.

                There are certain modes that the other code in the
                modeset DLL will accept if they are received exactly
                as requested, but which we will never "back off" to
                reach. These modes are the non-desktop modes --
                things like modes smaller.than 640x480 and also the
                960x720 mode for DirectX. These modes will not be
                "found" as next smaller resolutions.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/
int CFUNC
FindNextSmallerResolution (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeSmaller;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next smaller spatial resolution mode in lpModeList
    // that is at the same pixel depth. Smaller mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    // Set up the smaller mode to be 0 initially
    ModeSmaller.dwXRes = 0;
    ModeSmaller.dwYRes = 0;

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes >= 640) &&
             (lpModeList[i].dwYRes >= 480) &&
             (lpModeList[i].dwXRes != 960) &&
             (((lpModeList[i].dwXRes <= ModeIn.dwXRes) && (lpModeList[i].dwYRes <  ModeIn.dwYRes)) ||
              ((lpModeList[i].dwXRes < ModeIn.dwXRes) && (lpModeList[i].dwYRes <=  ModeIn.dwYRes))))
        {
            // The lpModeList resolution is smaller. But is it the
            // largest of the smaller modes? Remember we are looking
            // for the next immediate smaller mode.
            if  ((ModeSmaller.dwXRes < lpModeList[i].dwXRes) ||
                 ((ModeSmaller.dwXRes == lpModeList[i].dwXRes) &&
                  (ModeSmaller.dwYRes <  lpModeList[i].dwYRes)))
            {
                ModeSmaller.dwXRes = lpModeList[i].dwXRes;
                ModeSmaller.dwYRes = lpModeList[i].dwYRes;
                ModeSmaller.dwBpp  = lpModeList[i].dwBpp;
                ModeSmaller.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            }
        }
    }

    if  (ModeSmaller.dwXRes != 0)
    {
        ModeSmaller.MIDevData.cType = lpModeDesc->MIDevData.cType;
        lpModeDesc[0] = ModeSmaller;
        return  (TRUE);
    }

    return  (FALSE);
}


/*
    FindNextSmallerRefreshRate

    Purpose:    This routine finds the next lower refresh rate at
                the same resolution and pixel depth as requested.
                If it finds one, it modifies lpModeDesc to reflect
                the new mode and returns TRUE, else it returns FALSE.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/

int CFUNC
FindNextSmallerRefreshRate (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeSmaller;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next smaller spatial resolution mode in lpModeList
    // that is at the same pixel depth. Smaller mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    // Set up the smaller mode to be 0 initially
    ModeSmaller.dwRefreshRate = 0;

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes == ModeIn.dwXRes) &&
             (lpModeList[i].dwYRes == ModeIn.dwYRes) &&
             (lpModeList[i].dwRefreshRate < ModeIn.dwRefreshRate))
        {
            // The lpModeList refreshRate is smaller. But is it the
            // largest of the smaller modes? Remember we are looking
            // for the next immediate smaller mode.
            if  ((ModeSmaller.dwRefreshRate < lpModeList[i].dwRefreshRate))
            {
                ModeSmaller.dwXRes = lpModeList[i].dwXRes;
                ModeSmaller.dwYRes = lpModeList[i].dwYRes;
                ModeSmaller.dwBpp  = lpModeList[i].dwBpp;
                ModeSmaller.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            }
        }
    }

    if  (ModeSmaller.dwRefreshRate != 0)
    {
        ModeSmaller.MIDevData.cType = lpModeDesc->MIDevData.cType;
        lpModeDesc[0] = ModeSmaller;
        return  (TRUE);
    }

    return  (FALSE);
}


/*
    FindNextLargerRefreshRate

    Purpose:    This routine finds the next higher refresh rate at
                the same resolution and pixel depth as requested.
                If it finds one, it modifies lpModeDesc to reflect
                the new mode and returns TRUE, else it returns FALSE.

    Arguments:
                lpModeList  ptr to MODEENTRY array -- master mode list
                lpModeDesc  ptr to MODEINFO -- mode to back off

    Returns:    TRUE    lpModeDesc has new backed off mode
                FALSE   there was no smaller mode in the lpModeList

    Preserve:
*/

int CFUNC
FindNextLargerRefreshRate (
    LPMODEENTRY lpModeList,
    LPMODEINFO  lpModeDesc)
{
    int         i;
    MODEINFO    ModeIn, ModeLarger;

    // This should be easy. We look at the mode in lpModeDesc and
    // Find the next larger spatial resolution mode in lpModeList
    // that is at the same pixel depth. Larger mode is defined as:
    // A lower value for the X-Res is definitely smaller
    // A same value for the X-Res forces a look at the Y-Res
    //      A lower value for the Y-Res is smaller

    // Save the passed in mode because we are going to change it.
    ModeIn = lpModeDesc[0];

    for (i = 0; lpModeList[i].dwXRes != 0; i++)
    {
        if  ((lpModeList[i].dwBpp == ModeIn.dwBpp) &&
             (lpModeList[i].dwXRes == ModeIn.dwXRes) &&
             (lpModeList[i].dwYRes == ModeIn.dwYRes) &&
             (lpModeList[i].dwRefreshRate > ModeIn.dwRefreshRate))
        {
            // The lpModeList refreshRate is larger.
            ModeLarger.dwXRes = lpModeList[i].dwXRes;
            ModeLarger.dwYRes = lpModeList[i].dwYRes;
            ModeLarger.dwBpp  = lpModeList[i].dwBpp;
            ModeLarger.dwRefreshRate  = lpModeList[i].dwRefreshRate;
            ModeLarger.MIDevData.cType = lpModeDesc->MIDevData.cType;
            lpModeDesc[0] = ModeLarger;
            return  (TRUE);
        }
    }

    return  (FALSE);
}


/*
    Function:   GetSafeTiming

    Purpose:    This routine returns a "safe" set of timings for
                a special default mode. At the time this was
                written, that was 640x480 @ 60Hz DMT timing.

    Arguments:
                lpModeOrig  ptr to MODEINFO -- requested mode
                lpModeOut   ptr to MODEOUT  -- place to store
                            timings for safe mode

    Returns:    This routine returns the difference betweeen the
                mode specified by lpModeDesc and the mode
                specified by lpModeOut as logical ORs of the
                flags in modeext.h.
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
*/
int WINAPI
GetSafeTiming (LPMODEINFO lpModeOrig, LPMODEOUT lpModeOut)
{
    MODEINFO    ModeDesc;

    DBG_PRINT0(DL_0, "\r\nEntering GetSafeTiming.");

    ModeDesc.dwXRes = 640;
    ModeDesc.dwYRes = 480;
    ModeDesc.dwBpp  = lpModeOrig->dwBpp;
    ModeDesc.dwRefreshRate = 60;
    ModeDesc.MIDevData.cType = lpModeOrig->MIDevData.cType;
    ModeDesc.dwOriginalRefreshRate = lpModeOrig->dwOriginalRefreshRate;

    // Account for case where pixel depth is 24-bit which is not supported.
    if  (lpModeOrig->dwBpp == 24)
        ModeDesc.dwBpp  = 16;

    DmtFindMode (&ModeDesc, lpModeOut);

    return  (GetModeFlags (lpModeOrig, &ModeDesc));
}


/*
    Function:   GetModeFlags

    Purpose:    This routine computes the difference betweeen the
                mode specified by lpModeOrig and the mode
                specified by lpModeFound as logical ORs of the
                flags in modeext.h.

    Purpose:    This routine returns a "safe" set of timings for
                a special default mode. At the time this was
                written, that was 640x480 @ 60Hz DMT timing.

    Arguments:
                lpModeDesc  ptr to MODEINFO -- requested mode
                lpModeOut   ptr to MODEOUT  -- place to store
                            timings for safe mode

    Returns:    This routine returns the difference betweeen the
                mode specified by lpModeOrig and the mode
                specified by lpModeFound as logical ORs of the
                flags in modeext.h.
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
*/
int CFUNC
GetModeFlags (LPMODEINFO lpModeOrig, LPMODEINFO lpModeFound)
{
    int     nRet;

    // Figure out how the input mode differs from the safe mode and
    // return flags indicating the differences.
    nRet = 0;

    if  ((lpModeOrig->dwXRes != lpModeFound->dwXRes) ||
         (lpModeOrig->dwYRes != lpModeFound->dwYRes))
        nRet |= MODE_RESOLUTION_ADJUSTED;

    if  (lpModeOrig->dwRefreshRate != lpModeFound->dwRefreshRate)
        nRet |= MODE_REFRESH_RATE_ADJUSTED;

    if  (lpModeOrig->dwBpp != lpModeFound->dwBpp)
        nRet |= MODE_PIXEL_DEPTH_ADJUSTED;

    return  (nRet);
}


/*
    FormatModeList

    This routine parses the passed in modelist into the desired
    mode structure format.

    The modes are returned as either MODEENTRY, MODEENTRYNORR, or
    MODEENTRYANDPITCH structures depending upon the value of dwType.

    If dwType is MODETYPE_MODEENTRY, then MODEENTRY structures are
    returned. If dwType is MODETYPE_MODEENTRYNORR, then MODEENTRYNORR
    structures are returned. If dwType is MODETYPE_MODEENTRYANDPITCH,
    then MODEENTRYANDPITCH structures are returned.
*/
int WINAPI
FormatModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType, LPMODEENTRY lpME)
{
    int         j;
    ULONG       dwModeSize;

    switch  (dwType)
    {
        case MODETYPE_MODEENTRY:
        {
            LPMODEENTRY lpDst;
            lpDst = (LPMODEENTRY) lpModes;

            // Just copy the list if they provide a ptr
            // If not, at least count the items
            for (j = 0; lpME[j].dwXRes != 0; j++)
                if  (lpDst)
                    lpDst[j] = lpME[j];

            break;
        }

        case MODETYPE_MODEENTRYNORR:
        {
            // Only one mode per refresh rate

            int             k, l;
            int             nDuplicate;
            LPMODEENTRYNORR lpDst;

            lpDst = (LPMODEENTRYNORR) lpModes;
            j = 0;

            for (k = 0; lpME[k].dwXRes != 0; k++)
            {
                nDuplicate = FALSE;

                for (l = 0; l < j; l++)
                {
                    if  ((lpDst[l].dwXRes == lpME[k].dwXRes) &&
                         (lpDst[l].dwYRes == lpME[k].dwYRes) &&
                         (lpDst[l].dwBpp  == lpME[k].dwBpp))
                    {
                        nDuplicate = TRUE;
                        break;
                    }
                }

                if  (!nDuplicate)
                {
                    // Copy the entry if it is a valid ptr.
                    // Otherwise just count them.
                    if  (lpDst)
                    {
                        lpDst[j].dwXRes = lpME[k].dwXRes;
                        lpDst[j].dwYRes = lpME[k].dwYRes;
                        lpDst[j].dwBpp  = lpME[k].dwBpp;
                    }
                    j++;
                }
            }
            break;
        }

        case MODETYPE_MODEENTRYANDPITCH:
        {
            // We don't actually fill in the pitch here, but
            // we use the correct structure so that the caller can.
            // Only one mode per refresh rate

            int                 k, l;
            int                 nDuplicate;
            LPMODEENTRYANDPITCH lpDst;

            lpDst = (LPMODEENTRYANDPITCH) lpModes;
            j = 0;

            for (k = 0; lpME[k].dwXRes != 0; k++)
            {
                nDuplicate = FALSE;

                for (l = 0; l < j; l++)
                {
                    if  ((lpDst[l].dwXRes == lpME[k].dwXRes) &&
                         (lpDst[l].dwYRes == lpME[k].dwYRes) &&
                         (lpDst[l].dwBpp  == lpME[k].dwBpp))
                    {
                        nDuplicate = TRUE;
                        break;
                    }
                }

                if  (!nDuplicate)
                {
                    // Copy the entry if it is a valid ptr.
                    // Otherwise just count them.
                    if  (lpDst)
                    {
                        lpDst[j].dwXRes  = lpME[k].dwXRes;
                        lpDst[j].dwYRes  = lpME[k].dwYRes;
                        lpDst[j].dwBpp   = lpME[k].dwBpp;
                        GetPitchAndSize (lpDispData, lpME[k].dwXRes,
                                    lpME[k].dwYRes, lpME[k].dwBpp,
                                    &(lpDst[j].dwPitch), &dwModeSize);
                    }
                    j++;
                }
            }
            break;
        }
    }

    return  (j);
}


/*
    GetModeList

    This routine gets the master mode list and returns it.

    The modes are returned as either MODEENTRY, MODEENTRYNORR, or
    MODEENTRYANDPITCH structures depending upon the value of dwType.

    If dwType is MODETYPE_MODEENTRY, then MODEENTRY structures are
    returned. If dwType is MODETYPE_MODEENTRYNORR, then MODEENTRYNORR
    structures are returned. If dwType is MODETYPE_MODEENTRYANDPITCH,
    then MODEENTRYANDPITCH structures are returned.
*/
int WINAPI
GetModeList (LPDISPDATA lpDispData, LPCHAR lpModes, ULONG dwType)
{
    LPMODEENTRY lpME;
    int         j;

    lpME = GetMasterModeList (lpDispData);

    j = FormatModeList (lpDispData, lpModes, dwType, lpME);

    FreeMasterModeList (lpME);
    return  (j);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\include\UTILS.H ===
/*
    FILE:   utils.h

    DATE:   4/8/99

    This file holds some utility routines.  OS independent
*/

extern int CFUNC FindMode (LPMODESTRUC lpMS, ULONG dwXRes,
                            ULONG dwYRes, ULONG dwRRate);
extern int CFUNC FindModeWithoutRR (LPMODESTRUC lpMS, ULONG dwXRes,
                            ULONG dwYRes);
extern int CFUNC SetupParamsForVidLutClass (LPMODESTRUC lpMS,
                            LPMODEOUT lpModeOut,
                            LPMODEINFO lpModeIn);
extern int CFUNC SetupParamsForModeInfo (LPMODEOUT lpModeOut,
                            LPMODEINFO lpModeOrig, LPMODEINFO lpModeIn);
extern int CFUNC ParseDecimalNumber (LPCHAR szRTString, LPULONG lpIndex,
                            LPULONG lpNum);
extern ULONG CFUNC GetDecimalValue (char cDigit);
extern int CFUNC ParseHexWord (LPCHAR szRTString, LPULONG lpIndex,
                            LPUSHORT lpNum);
extern int CFUNC ParseHexDWord (LPCHAR szRTString, LPULONG lpIndex,
                            LPULONG lpNum);
extern int CFUNC ParseDecimalSeparator (LPCHAR lpStr, LPULONG lpIndex,
                            LPULONG lpNum, char cSeparator1,
                            char cSeparator2);
extern int CFUNC ParseDecimalNumberAndFractionAndSeparator (LPCHAR  lpStr,
                            LPULONG lpIndex, LPULONG lpNum,
                            char    cSeparator1, char    cSeparator2);
extern int CFUNC ParseHexSeparator (LPCHAR  lpStr, LPULONG lpIndex,
                            LPULONG lpNum, ULONG   dwLen,
                            char cSeparator1, char cSeparator2);
extern ULONG CFUNC GetHexValue (char cDigit);

extern ULONG CFUNC GetMaximumRefreshRate (ULONG dwPixelClkXRes,
                            ULONG dwPixelClkYRes, ULONG dwPixelClkRR,
                            LPMONITORLIMITS lpML, ULONG dwTargetXRes,
                            ULONG dwTargetYRes);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\include\MODEEXT.H ===
/*
    FILE:   modeext.h
    DATE:   4/8/99

    This file is the external API to the world for the
    FindModeExtry and GetModeList functions in the modeset DLL.
    There can be other EXTERNAL function that are OS specific,
    but they should be defined in other header files.
*/

#if defined(LINUX) | defined(MAC)

#define FAR

#if defined(MAC)
typedef unsigned short  USHORT;
#endif

#else
// Need these for C To ASM conversion reason.
#ifndef ULONG
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR             __far
#endif
#endif

typedef unsigned short  USHORT;
typedef unsigned long   ULONG;
typedef unsigned char   UCHAR;
typedef UCHAR FAR   *   LPCHAR;
typedef void        *   PVOID;
#endif
#endif  // !linux


// Here is the calling format for both 16bit and 32bit land.
// ULONG __cdecl
// FindModeEntry (
//              LPDISPDATA  lpDispData,
//              LPCHAR      lpEdidBuffer,
//              ULONG       dwEdidSize,
//              LPMODEINFO  lpModeDesc,
//              LPMODEOUT   lpModeOut)
//
// All the structures and types you need are defined in this file.
//
// The FindModeEntry function will always return some legal set of
// values to program in the lpModeOut structure. It may not be the
// requested mode, but the function will never fail to return some
// legitimate values. The actual number returned by the function can
// be a logical OR of the following to indicate whether the parameters
// being returned in lpModeOut are for the requested mode or are for
// a different mode (because the requested mode was not allowed.)
// Note that the return value tells you how different the mode
// returned is from the requested mode -- i.e. whether the mode is
// the same, differes only in the resolution, differes in the pixel
// depth, differs in the refresh rate or some combination thereof.

#define MODE_EXACT_MATCH            0x00
#define MODE_RESOLUTION_ADJUSTED    0x01
#define MODE_PIXEL_DEPTH_ADJUSTED   0x02
#define MODE_REFRESH_RATE_ADJUSTED  0x04

// Although this is kind of Win9X/WinNT specific, it won't hurt to
// put in here. This structure is only used for some calls in the
// Win9X and WinNT specific portion of the modeset dll.
typedef struct  tagREGDATA
{
    ULONG   dwMainKey;
    char    szRegPath[128];
}   REGDATA;
typedef REGDATA FAR *LPREGDATA;

typedef struct  tagDISPDATA
{
    // Every OS probably uses these
    ULONG       dwDeviceID;
    ULONG       dwCRTCIndex;
    ULONG       dwMaxTVOutResolution;
    ULONG       dwVideoMemoryInBytes;
    ULONG       dwMaxDacSpeedInHertz8bpp;
    ULONG       dwMaxDacSpeedInHertz16bpp;
    ULONG       dwMaxDacSpeedInHertz32bpp;
    ULONG       dwMaxDfpScaledXResInPixels;
    ULONG       dwTVEncoderType;
    PVOID       lpfnGetModeSize;
    PVOID       dwContext1;
    PVOID       dwContext2;

    /////////////////////////////////////////////////////////////
    // Win9X uses these
    // Registry base path to ...DISPLAY\000X and MONITOR\000X key.
    REGDATA     *lpBoardRegistryData;
    REGDATA     *lpMonitorRegistryData;
    ULONG       dwMonitorInfType;
    ULONG       lpDevData;
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // MAC uses these
    ULONG       edidSize;
    // MAC Done
    /////////////////////////////////////////////////////////////
}   DISPDATA;

typedef DISPDATA FAR *LPDISPDATA;

// dwInfType can have one of the following three values
#define SPECIFIC_DEVICE         0
#define UNKNOWN_DEVICE          1
#define PLUG_AND_PLAY_DEVICE    2

typedef struct  tagDEVDATA
{
    char    cType;
    char    cNumber;
    char    cFormat;
    char    cReserved;
}   DEVDATA;

typedef DEVDATA   FAR *LPDEVDATA;


// Unfortunately we need to pass the TVEncoderType in here. Optimal
// mode timing paramteres for the different TVEncoders are different.
// I hate having aliased constant, but I dont wat to include the
// RM files right now. I'm thinking about how to do this whole thing
// in a bit better a fashion.
#define TV_ENCODER_NONE                 0x000
#define TV_ENCODER_BROOKTREE            0x100
#define TV_ENCODER_CHRONTEL             0x200
#define TV_ENCODER_PHILIPS              0x400
#define NV_ENCODER_NONE                 TV_ENCODER_NONE
#define NV_ENCODER_BROOKTREE_868        (TV_ENCODER_BROOKTREE + 1)
#define NV_ENCODER_BROOKTREE_869        (TV_ENCODER_BROOKTREE + 2)
#define NV_ENCODER_BROOKTREE_871        (TV_ENCODER_BROOKTREE + 3)
#define NV_ENCODER_CHRONTEL_7003        (TV_ENCODER_CHRONTEL + 3)
#define NV_ENCODER_CHRONTEL_7004        (TV_ENCODER_CHRONTEL + 4)
#define NV_ENCODER_CHRONTEL_7005        (TV_ENCODER_CHRONTEL + 5)
#define NV_ENCODER_CHRONTEL_7006        (TV_ENCODER_CHRONTEL + 6)
#define NV_ENCODER_CHRONTEL_7007        (TV_ENCODER_CHRONTEL + 7)
#define NV_ENCODER_CHRONTEL_7008        (TV_ENCODER_CHRONTEL + 8)
#define NV_ENCODER_PHILIPS_7102	        (TV_ENCODER_PHILIPS + 2)
#define NV_ENCODER_PHILIPS_7103	        (TV_ENCODER_PHILIPS + 3)
// = 7102 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7108	        (TV_ENCODER_PHILIPS + 8)
// = 7103 encoder + 7114 decoder
#define NV_ENCODER_PHILIPS_7109	        (TV_ENCODER_PHILIPS + 9)
// early version of 7108 with clock active edge reversed
#define NV_ENCODER_PHILIPS_7108B        (TV_ENCODER_PHILIPS + 8 + 0x10)


// This is a description of the incoming mode to try and validate/set.
// The dwXRes, dwYRes, and dwBpp fields should be filled in with the
// desired values. dwRefreshRate must be an actual refresh rate in hertz.
// dwDevType should be set to one of the special device type constants
// (CRT, NTSC, PAL, FLAT_PANEL, etc.) given later in this file.
// The dwOriginalRefreshRate is not used as an input parameter, but
// some of the functions in the modeset DLL that return a MODEINFO
// structure return information in this field. Also, dwCRTCIndex is
// not used by the modeset DLL, but by other modules that utilize
// this structure.
typedef struct  tagMODEINFO
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
    ULONG   dwDevType;
    ULONG   dwTVFormat;
    DEVDATA MIDevData;
    ULONG   dwOriginalRefreshRate;
}   MODEINFO;

typedef MODEINFO FAR *LPMODEINFO;

// Display Device Types which can be in MODEINFO.dwDevType
#define DEVTYPE_CRT         0x00
#define DEVTYPE_TV          0x01
#define DEVTYPE_DFP         0x02
#define MAX_DEVTYPES        0x03

// These are for the TvType -- they weren't being used in the generic
// code at the time they were added, but they may be needed in the
// future, or the OS-specific sections may need them. We might as well
// all agree on their values.
#define TVTYPE_NTSCM                0x00
#define TVTYPE_NTSCJ                0x01
#define TVTYPE_PALM                 0x02
#define TVTYPE_PALA                 0x03
#define TVTYPE_PALN                 0x04
#define TVTYPE_PALNC                0x05
#define MAX_TVTYPES                 0x06

// This is the format that the mode timing parameters are handed back
// to the caller. This format was chosen because, as of the time of
// this writing, it matches the format of an NVidia object -- class 46.
typedef struct  _tagMODEOUT
{
    USHORT  wXRes;
    USHORT  wYRes;
    USHORT  wHBlankStart;
    USHORT  wHBlankWidth;
    USHORT  wHSyncStart;
    USHORT  wHSyncWidth;
    USHORT  wVBlankStart;
    USHORT  wVBlankWidth;
    USHORT  wVSyncStart;
    USHORT  wVSyncWidth;
    USHORT  wHTotal;
    USHORT  wVTotal;
    ULONG   dwPixelClock;
    ULONG   dwFormat;
    USHORT  wRefreshRate;
    ULONG   dwPitchInBytes;
} MODEOUT;

typedef MODEOUT FAR *LPMODEOUT;


// There is an API call in this DLL --
// int GetModeList (LPDISPDATA lpDD, LPCHAR lpModes, ULONG dwType)
// lpDD specifies the board to fetch the modelist for.
// If lpModes is NULL, the routine returns the number of modes.
// If lpModes is not NULL, the routine returns the number of modes
// and fills in lpModes with an array of either MODEENTRY, MODEENTRYNORR,
// or MODEENTRYANDPITCH structures depending upon the value of dwType.

// The routine will never return more than this number of modes
#define MAX_MODEENTRYS  2048

// dwType can be one of these values.
#define MODETYPE_MODEENTRYNORR      0
#define MODETYPE_MODEENTRY          1
#define MODETYPE_MODEENTRYANDPITCH  2

// dwType of MODETYPE_MODEENTRYNORR causes these structurs to be returned
typedef struct  tagMODEENTRYNORR
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
} MODEENTRYNORR;

typedef MODEENTRYNORR FAR *LPMODEENTRYNORR;

// dwType of MODETYPE_MODEENTRY causes these structurs to be returned
typedef struct  tagMODEENTRY
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
} MODEENTRY;

typedef MODEENTRY FAR *LPMODEENTRY;

// dwType of MODETYPE_MODEENTRYANDPITCH causes these structurs to be returned
typedef struct  tagMODEENTRYANDPITCH
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwPitch;
} MODEENTRYANDPITCH;

typedef MODEENTRYANDPITCH FAR *LPMODEENTRYANDPITCH;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\include\RESTIME.H ===
/*
    FILE:   restime.h
    DATE:   4/8/99

    This file has routines to support getting and parsing the restriction
    and timing strings. OS independent stuff.
*/

// This is the maximum number of R&T strings allowed.
#define MAX_RESTIMES    128

// For any of the fields in the R&T string that can be separated by a
// '.' (see specification for details), there can be at most the
// following number of DOT separated values per field. For example,
// the MonitorID field can have up to MAX_DOT_FIELDS monitorIDs.
// Example DT71.SN17.VS85 is three monitor IDS.
#define MAX_DOT_FIELDS  16

// For those R&T strings which allow a wildcard indicating ALL, this
// is the wildcard character.
#define ALL_WILDCARD    ('*')

// For each restriction and timing string that gets parsed, the string
// is parsed into the following structure.
typedef struct  tagRESTIME
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwPixelDepth;
    ULONG   dwRefreshRate;
    USHORT  wDeviceID[MAX_DOT_FIELDS];
    ULONG   dwMonitorID[MAX_DOT_FIELDS];
    ULONG   dwTimingStandard[MAX_DOT_FIELDS];
    MODEOUT sModeOut;
} RESTIME;

typedef RESTIME FAR *LPRESTIME;

// A couple of special MonitorIDs. UKWN_ID is a monitor ID which matches
// all monitors that do not have an EDID.
// A couple of special MonitorIDs. UKWN_ID is a monitor ID which matches
// all monitors that do not have an EDID.
#define UKWN_ID ((ULONG) 'U') + (((ULONG) 'K') << 8) + (((ULONG) 'W') << 16) + (((ULONG) 'N') << 24)
#define NTSC_ID ((ULONG) 'N') + (((ULONG) 'T') << 8) + (((ULONG) 'S') << 16) + (((ULONG) 'C') << 24)
#define PALX_ID ((ULONG) 'P') + (((ULONG) 'A') << 8) + (((ULONG) 'L') << 16) + (((ULONG) 'X') << 24)
#define PANL_ID ((ULONG) 'P') + (((ULONG) 'A') << 8) + (((ULONG) 'N') << 16) + (((ULONG) 'L') << 24)

// Several TimingStandardIDs.
#define NONE_ID ((ULONG) 'N') + (((ULONG) 'O') << 8) + (((ULONG) 'N') << 16) + (((ULONG) 'E') << 24)
#define EDID_ID ((ULONG) 'E') + (((ULONG) 'D') << 8) + (((ULONG) 'I') << 16) + (((ULONG) 'D') << 24)
#define DMTV_ID ((ULONG) 'D') + (((ULONG) 'M') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'V') << 24)
#define DMTR_ID ((ULONG) 'D') + (((ULONG) 'M') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'R') << 24)
#define GTFV_ID ((ULONG) 'G') + (((ULONG) 'T') << 8) + (((ULONG) 'F') << 16) + (((ULONG) 'V') << 24)
#define GTFR_ID ((ULONG) 'G') + (((ULONG) 'T') << 8) + (((ULONG) 'F') << 16) + (((ULONG) 'R') << 24)
#define OEMX_ID ((ULONG) 'O') + (((ULONG) 'E') << 8) + (((ULONG) 'M') << 16) + (((ULONG) 'X') << 24)
#define OEMR_ID ((ULONG) 'O') + (((ULONG) 'E') << 8) + (((ULONG) 'M') << 16) + (((ULONG) 'R') << 24)
#define FGTF_ID ((ULONG) 'F') + (((ULONG) 'G') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'F') << 24)
#define FGTR_ID ((ULONG) 'F') + (((ULONG) 'G') << 8) + (((ULONG) 'T') << 16) + (((ULONG) 'R') << 24)

// A few of the R&T parsing functions require that a mode be passed in.
// This is the structure that the R&T functions require the mode to be in.
typedef struct  tagRTMODE
{
    ULONG   dwXRes;
    ULONG   dwYRes;
    ULONG   dwBpp;
    ULONG   dwRefreshRate;
} RTMODE;

typedef RTMODE FAR *LPRTMODE;

extern int CFUNC RTFindNextMatchingString (LPRESTIME lpRTList,
                        int nIndex, LPDISPDATA lpDispData,
                        LPRTMODE lpRTMode, ULONG dwMonitorID);;

// Return values for a successful RTFindNextMatchingString are any
// positive integer which represents the index of the RTstring in the
// RTList that was a match. The value below is returned if there was no
// match.
#define RTERR_NOT_FOUND -1

extern int CFUNC RTRestrictByTimingStandard (LPRESTIME lpRTList, int nIndex,
                                    ULONG dwTimingStandard);

int CFUNC ParseRTString (LPRESTIME lpRT, LPCHAR szRTString);
int CFUNC ParseDecimalNumberOrWildcard (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
int CFUNC ParseDeviceIDs (LPCHAR szRTString, LPULONG lpIndex,
                                LPUSHORT lpNum);
int CFUNC ParseMonitorIDs (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
int CFUNC ParseTimingStandards (LPCHAR szRTString,
                                LPULONG lpIndex, LPULONG lpNum);
int CFUNC ParseDecimalNumberComma (LPCHAR szRTString, LPULONG lpIndex,
                                LPULONG lpNum);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\code\RESTIME.C ===
/*
    FILE:   restime.c
    DATE:   4/8/99

    This file holds code to process restriction and timing lists
    and also a few utility routines to get mode lists from the
    registry, etc.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "utils.h"
#include "restime.h"
#include "debug.h"

// Just in cae we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    ParseRTString

    This routine parses an R&T string given by szRTString into the
    RESTIME structure pointed to by lpRT. The function returns
    TRUE if the szRTString was a valid R&T string and parsed with
    no errors. Otherwise the routine returns FALSE.
*/
int CFUNC
ParseRTString (LPRESTIME lpRT, LPCHAR szRTString)
{
    int     nRet;
    ULONG   dwIndex;

    DBG_PRINT1(DL_5, "\r\nParsing R&T string %s", szRTString);

    // dwIndex is the offset into the szRTString we are currently looking at
    dwIndex = 0;

    // The first thing in an R&T string is the X-resolution. Make sure
    // it is there and get its value.
    if  (!ParseDecimalNumberComma (szRTString, &dwIndex, &(lpRT->dwXRes)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nXRes found to be %ld", lpRT->dwXRes);

    // The next thing in an R&T string is the Y-resolution. Make sure
    // it is there and get its value.
    if  (!ParseDecimalNumberComma (szRTString, &dwIndex, &(lpRT->dwYRes)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nYRes found to be %ld", lpRT->dwYRes);

    // The next thing in an R&T string is the pixel depth. This
    // is also allowed to be a wildcard indicating everything.
    if  (!ParseDecimalNumberOrWildcard (szRTString, &dwIndex, &(lpRT->dwPixelDepth)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nPixelDepth found to be %ld", lpRT->dwPixelDepth);

    // The next thing in an R&T string is the refresh rate. This
    // is also allowed to be a wildcard indicating everything.
    if  (!ParseDecimalNumberOrWildcard (szRTString, &dwIndex, &(lpRT->dwRefreshRate)))
        return  (FALSE);
    DBG_PRINT1(DL_5, "\r\nRefreshRate found to be %ld", lpRT->dwRefreshRate);

    // The next thing in an R&T string is a dot separated list
    // of Device IDs.
    if  (!ParseDeviceIDs (szRTString, &dwIndex, lpRT->wDeviceID))
        return  (FALSE);

    // The next thing in an R&T string is a dot separated list
    // of Monitor IDs.
    if  (!ParseMonitorIDs (szRTString, &dwIndex, lpRT->dwMonitorID))
        return  (FALSE);

    // The next thing in an R&T string is a dot separated list
    // of Timing Standards.
    nRet = ParseTimingStandards (szRTString, &dwIndex, lpRT->dwTimingStandard);
    if  (!nRet)
        return  (FALSE);

    // If one of the timing standards was OEM, then there must be a set
    // of timing parameters in a MODEOUT format as the last thing in the
    // R&T string. We know if there was an OEM timing standard because
    // ParseTimingStandard returns a number greater than 1 if there was
    // an OEM timing standard listed.
    if  (nRet > 1)
    {
        // The timing parameter format is hexdigits;hexdigits; etc
        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHBlankStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHBlankStart found to be %lx", (ULONG) lpRT->sModeOut.wHBlankStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHBlankWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHblankWidth found to be %lx", (ULONG) lpRT->sModeOut.wHBlankWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHSyncStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHSyncStart found to be %lx", (ULONG) lpRT->sModeOut.wHSyncStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHSyncWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHSyncWidth found to be %lx", (ULONG) lpRT->sModeOut.wHSyncWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVBlankStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVBlankStart found to be %lx", (ULONG) lpRT->sModeOut.wVBlankStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVBlankWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nHblankWidth found to be %lx", (ULONG) lpRT->sModeOut.wVBlankWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVSyncStart)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVSyncStart found to be %lx", (ULONG) lpRT->sModeOut.wVSyncStart);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVSyncWidth)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nVSyncWidth found to be %lx", (ULONG) lpRT->sModeOut.wVSyncWidth);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wHTotal)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nXTotal found to be %lx", (ULONG) lpRT->sModeOut.wHTotal);

        if  (!ParseHexWord (szRTString, &dwIndex, &(lpRT->sModeOut.wVTotal)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nYTotal found to be %lx", (ULONG) lpRT->sModeOut.wVTotal);

        if  (!ParseHexDWord (szRTString, &dwIndex, &(lpRT->sModeOut.dwPixelClock)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nPixelClock found to be %lx", lpRT->sModeOut.dwPixelClock);

        if  (!ParseHexDWord (szRTString, &dwIndex, &(lpRT->sModeOut.dwFormat)))
            return  (FALSE);
        DBG_PRINT1(DL_5, "\r\nFormat found to be %lx", lpRT->sModeOut.dwFormat);

        lpRT->sModeOut.wXRes = (USHORT) lpRT->dwXRes;
        lpRT->sModeOut.wYRes = (USHORT) lpRT->dwYRes;
        lpRT->sModeOut.wRefreshRate = (USHORT) lpRT->dwRefreshRate;
    }

    return  (TRUE);
}


/*
    ParseDecimalNumberComma

    This routine parses a field that can either be a decimal number
    or the wildcard character. Basically, if it isn't the wildcard
    character, then it is assumed to be a decimal number
    This routine parses a decimal number from the string passed in.
    It assigns it into lpNum. Upkn returning lpIndex is adjusted so
    that it points to the first char after the comma following the
    number parsed. If the number was bad, could not be found before
    the end of the string or before the next comma, FALSE is returned.
    If a number was found and everything is fine, TRUE is returned.
    in RESTIME structures of the array pointed to by lpRTList.
*/
int CFUNC
ParseDecimalNumberComma (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    return  (ParseDecimalSeparator (szRTString, lpIndex, lpNum, ',', ','));
}



/*
    ParseDecimalNumberOrWildcard

    This routine parses a field that can either be a decimal number
    or the wildcard character. Basically, if it isn't the wildcard
    character, then it is assumed to be a decimal number
    This routine parses a decimal number from the string passed in.
    It assigns it into lpNum. Upkn returning lpIndex is adjusted so
    that it points to the first char after the comma following the
    number parsed. If the number was bad, could not be found before
    the end of the string or before the next comma, FALSE is returned.
    If a number was found and everything is fine, TRUE is returned.
    in RESTIME structures of the array pointed to by lpRTList.
*/
int CFUNC
ParseDecimalNumberOrWildcard (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    if  (szRTString[*lpIndex] == ALL_WILDCARD)
    {
        *lpNum = ALL_WILDCARD;

        // If the next char is not immediately a comma, then error
        if  (szRTString[*lpIndex + 1] != ',')
        {
            DBG_PRINT1(DL_5, "\r\nComma not found after wildcard number in %s.", szRTString);
            return  (FALSE);
        }

        *lpIndex += 2;
    }
    else
    {
        // Not a wildcard, so parse a number
        if  (!ParseDecimalNumberComma (szRTString, lpIndex, lpNum))
            return  (FALSE);
    }

    return  (TRUE);
}



/*
    ParseDeviceIDs

    This routine parses a '.' separated list of DeviceIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each deviceID is assumed to be exactly four hex
    digits long. The alphabetic characters can be upper or lower case.
*/
int CFUNC
ParseDeviceIDs (LPCHAR szRTString, LPULONG lpIndex, LPUSHORT lpNum)
{
    int     nRet;
    ULONG   dwID, dwNum;

    // Set all the device IDs to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // The deviceID can be a WILDCARD char
        if  (szRTString[*lpIndex] == ALL_WILDCARD)
        {
            lpNum[dwID] = ALL_WILDCARD;
            *lpIndex += 1;
        }
        else
        {
            nRet = ParseHexSeparator (szRTString, lpIndex,
                                     &dwNum, 4, ',', '.');

            if  (!nRet)
            {
                DBG_PRINT1(DL_5, "\r\nBad DeviceID in %s", szRTString);
                return  (FALSE);
            }

            // We found a number!
            lpNum[dwID] = (USHORT) dwNum;

            // Backup pointer to put to separator.
            *lpIndex = *lpIndex - 1;
        }

        // If the next char is not either a '.' indicating another
        // deviceID follows, or a ',' indicating we are done with the
        // deviceID parsing, then there is a parse error.
        if  (szRTString[*lpIndex] == ',')
        {
            *lpIndex += 1;
            DBG_PRINT1(DL_5, "\r\nFound %ld DeviceIDs.", dwID + 1);
            return  (TRUE);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad DeviceID separator in %s", szRTString);
            return  (FALSE);
        }

        // Skip over the '.' and keep going for the next deviceID
        *lpIndex += 1;

    }

    DBG_PRINT1(DL_5, "\r\nFound %ld deviceIDs.", dwID + 1);
    return  (TRUE);
}


/*
    ParseMonitorIDs

    This routine parses a '.' separated list of MonitorIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each MonitorID is assumed to be exactly four byte
    characters long. An ALL_WILDCARD character is allowed.
*/
ULONG CFUNC
ParseIsHexChar (UCHAR c)
{
    if  ((c >= '0') && (c <= '9'))
        return  (c - '0');

    if  ((c >= 'A') && (c <= 'F'))
        return  ((c - 'A') + 10);
    
    if  ((c >= 'a') && (c <= 'f'))
        return  ((c - 'a') + 10);

    return  (0xFFFFFFFF);
}


/*
    ParseMonitorIDs

    This routine parses a '.' separated list of MonitorIDs. There can
    be up to MAX_DOT_FIELDS deviceIDs. Any more than this constitutes
    a parse error. Each MonitorID is assumed to be exactly four byte
    characters long. An ALL_WILDCARD character is allowed.
*/
int CFUNC
ParseMonitorIDs (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    ULONG   c1, c2;
    int     i;
    ULONG   dwID;

    // Set all the monitor IDs to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // The monitorID can be a WILDCARD char
        if  (szRTString[*lpIndex] == ALL_WILDCARD)
        {
            lpNum[dwID] = ALL_WILDCARD;
            *lpIndex += 1;
        }
        else
        {
            for (i = 0; i < 4; i++)
            {
                c1 = ParseIsHexChar(szRTString[*lpIndex + i * 2 + 0]);
                c2 = ParseIsHexChar(szRTString[*lpIndex + i * 2 + 1]);

                if  ((c1 == 0xFFFFFFFF) || (c2 == 0xFFFFFFFF))
    
                {
                    DBG_PRINT1(DL_5, "\r\nBad MonitorID in %s", szRTString);
                    return  (FALSE);
                }

                lpNum[dwID] |= ((c1 * 0x10) + c2) << (24 - i * 8);
            }

            *lpIndex += 8;
        }

        // If the next char is not either a '.' indicating another
        // monitorID follows, or a ',' indicating we are done with the
        // monitorID parsing, then there is a parse error.
        if  (szRTString[*lpIndex] == ',')
        {
            *lpIndex += 1;
            DBG_PRINT1(DL_5, "\r\nFound %ld monitorIDs.", dwID + 1);
            return  (TRUE);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad MonitorID separator in %s", szRTString);
            return  (FALSE);
        }

        // Skip over the '.' and keep going for the next monitorID
        *lpIndex += 1;
    }

    return  (TRUE);
}


/*
    ParseTimingStandards

    This routine parses a '.' separated list of Timing Standards. There
    can be up to MAX_DOT_FIELDS Timing Standards. Any more than this
    constitutes a parse error. Each Timing Standard is up to four
    characters long. The permissable ones are in restime.h

    Returns: 0 is returned if there was any parse error
             1 is returned if there were no parse errors but OEMN was
                 not one of the timing standards
             2 is returned if there were no parse errors and OEMN was
                 one of the timing standards.
*/
int CFUNC
ParseTimingStandards (LPCHAR szRTString, LPULONG lpIndex, LPULONG lpNum)
{
    ULONG   dwID, dwTS;
    int     nRet;

    nRet = 1;

    // Set all the Timing Standards to 0
    for (dwID = 0; dwID < MAX_DOT_FIELDS; dwID++)
        lpNum[dwID] = 0;

    for (dwID = 0; TRUE; dwID++)
    {
        // Make sure the next thing is a Timing Stndard
        dwTS = * ((LPULONG) (szRTString + *lpIndex));

        if  ((dwTS != NONE_ID) &&
             (dwTS != EDID_ID) &&
             (dwTS != DMTV_ID) &&
             (dwTS != DMTR_ID) &&
             (dwTS != GTFV_ID) &&
             (dwTS != GTFR_ID) &&
             (dwTS != OEMX_ID) &&
             (dwTS != OEMR_ID) &&
             (dwTS != FGTF_ID) &&
             (dwTS != FGTR_ID))
        {
            DBG_PRINT1(DL_5, "\r\nBad Timing Standard in %s", szRTString);
            return  (0);
        }

        if  ((dwTS == OEMX_ID) || (dwTS == OEMR_ID))
            nRet = 2;

        lpNum[dwID] = dwTS;
        *lpIndex += 4;

        // If the next char is not either a '.' indicating another
        // TimingStandard follows, or a ',' indicating we are done
        // with the TimingStandard parsing, then there is a parse error.
        if  ((szRTString[*lpIndex] == ',') || (szRTString[*lpIndex] == 0))
        {
            DBG_PRINT1(DL_5, "\r\nFound %ld Timing Standards.", dwID + 1);

            // If a comma follows, skip over it
            if  (szRTString[*lpIndex] == ',')
                *lpIndex += 1;

            return  (nRet);
        }

        if  (szRTString[*lpIndex] != '.')
        {
            DBG_PRINT1(DL_5, "\r\nBad Timing Standard separator in %s", szRTString);
            return (0);
        }

        // Skip over the '.' and keep going for the next timing standard
        *lpIndex += 1;
    }

    return  (TRUE);
}




/*
    RTFindNextMatchingString

    This procedure finds a string in the RTList that matches all the
    parameters in the R&T string. This is board data, mode, and
    monitor id. It returns an index into the list. If no match is
    found, then RTERR_NOT_FOUND is returned.
*/

int CFUNC
RTFindNextMatchingString (
    LPRESTIME   lpRTList,
    int         nIndex,
    LPDISPDATA  lpDispData,
    LPRTMODE    lpRTMode,
    ULONG       dwMonitorID)
{
    int i, b;
    int bMatchDevice, bMatchMode, bMatchMonitor;

    if  ((ULONG) nIndex > lpRTList->dwXRes)
    {
        // The requested index of the string at which to begin
        // searching is larger than the total number of R&T
        // strings in the array. So return error.
        return  (RTERR_NOT_FOUND);
    }

    for  (i = nIndex; i <= (int) lpRTList->dwXRes; i++)
    {
        bMatchDevice  = FALSE;
        bMatchMode    = FALSE;
        bMatchMonitor = FALSE;
        for (b = 0; b < MAX_DOT_FIELDS; b++)
        {
            // Return index if there is a wildcard match
            if  (lpRTList[i].wDeviceID[b] == ALL_WILDCARD)
                bMatchDevice = TRUE;

            // Return index if there is an exact match
            if  (lpRTList[i].wDeviceID[b] == (USHORT) lpDispData->dwDeviceID)
                bMatchDevice = TRUE;
        }

        // Match on the mode
        if  ((lpRTList[i].dwXRes == lpRTMode->dwXRes) &&
             (lpRTList[i].dwYRes == lpRTMode->dwYRes) &&
             ((lpRTList[i].dwPixelDepth == ALL_WILDCARD) ||
              (lpRTList[i].dwPixelDepth == lpRTMode->dwBpp)) &&
             ((lpRTList[i].dwRefreshRate == ALL_WILDCARD) ||
              (lpRTList[i].dwRefreshRate == lpRTMode->dwRefreshRate)))
            bMatchMode = TRUE;

        for (b = 0; b < MAX_DOT_FIELDS; b++)
        {
            // Return success on a wildcard match
            if  (lpRTList[i].dwMonitorID[b] == ALL_WILDCARD)
                bMatchMonitor = TRUE;;

            // Return success on an exact match
            if  (lpRTList[i].dwMonitorID[b] == dwMonitorID)
                bMatchMonitor = TRUE;;
        }
        
        if  (bMatchDevice && bMatchMode & bMatchMonitor)
            return  (i);
    }

    return  (RTERR_NOT_FOUND);
}


/*
    RTRestrictByTimingStandard

    This procedure looks at the R&T string given by nIndex in the
    lpRTList and sees if there is a match on the TimingStandard given
    by dwTimingStandard. If there is, TRUE is returned, else FALSE is
    returned.
*/
int CFUNC
RTRestrictByTimingStandard (
    LPRESTIME   lpRTList,
    int         nIndex,
    ULONG       dwTimingStandard)
{
    int b;

    for (b = 0; b < MAX_DOT_FIELDS; b++)
        if  (lpRTList[1].dwTimingStandard[b] == dwTimingStandard)
            return  (TRUE);

    return  (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\modeset.mhd\include\OSAPI.H ===
/*
    FILE:   osapi.h
    DATE:   4/8/99

    This file holds the externs for the os-specific routines that
    support the mode set code.
*/

extern LPMODEENTRY CFUNC GetMasterModeList (LPDISPDATA lpDispData);
extern int CFUNC FreeMasterModeList (LPMODEENTRY lpModeList);

extern LPRESTIME CFUNC GetMasterRTList (LPDISPDATA lpDispData);
extern int CFUNC FreeMasterRTList (LPRESTIME lpRTList);

extern ULONG CFUNC GetTimingStandardOverride (LPDISPDATA lpDispData);
extern ULONG CFUNC GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes,
            ULONG dwYRes, ULONG dwBpp, ULONG *dwPitch, ULONG *dwModeSize);

extern int CFUNC GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo);

int CFUNC GetMonitorInfRangeLimits (LPDISPDATA lpDispData,
                     LPMONITORLIMITS lpML, ULONG *lpdwXRes, ULONG *lpdwYRes);

ULONG CFUNC GetAllowAllModesFlag(LPDISPDATA lpDispData);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\nvcmrsvd.h ===
#ifndef _NVCMRSVD_H_
#define _NVCMRSVD_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NVTYPES_INCLUDED
#include "nvtypes.h"
#endif

//------------------------------------------------------------------------------
// Configuration manager reserved properties.
//
// #define NV_CFGEX_RESERVED 150
//------------------------------------------------------------------------------

typedef struct
{
    U032   Property;
    U032 * In;
    U032 * Out;
} NV_CFGEX_RESERVED_PROPERTY;

enum
{
    // Register read and write.
     PROPERTY_REG_RD08              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_RD16              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_RD32              // In:[Offset]       Out:[Data]
    ,PROPERTY_REG_WR08              // In:[Offset, Data] Out:[]
    ,PROPERTY_REG_WR16              // In:[Offset, Data] Out:[]
    ,PROPERTY_REG_WR32              // In:[Offset, Data] Out:[]

    // Frame buffer read and write.
    ,PROPERTY_FB_RD08               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_RD16               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_RD32               // In:[Offset]       Out:[Data]
    ,PROPERTY_FB_WR08               // In:[Offset, Data] Out:[]
    ,PROPERTY_FB_WR16               // In:[Offset, Data] Out:[]
    ,PROPERTY_FB_WR32               // In:[Offset, Data] Out:[]

    // PCI read and write.
    ,PROPERTY_PCI_RD08              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PCI_RD16              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PCI_RD32              // In:[Bus, Device, Function, Offset]       Out:[Data]
    ,PROPERTY_PCI_WR08              // In:[Bus, Device, Function, Offset, Data] Out:[]
    ,PROPERTY_PCI_WR16              // In:[Bus, Device, Function, Offset, Data] Out:[]
    ,PROPERTY_PCI_WR32              // In:[Bus, Device, Function, Offset, Data] Out:[]

    // Set clocks.
    ,PROPERTY_SET_GRAPHICS_CLOCK    // In:[Frequency (Hz)]       Out:[]
    ,PROPERTY_SET_MEMORY_CLOCK      // In:[Frequency (Hz)]       Out:[]
    ,PROPERTY_SET_PIXEL_CLOCK       // In:[Head, Frequency (Hz)] Out:[]
};

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _NVCMRSVD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\nvrmint.h ===
/*
 * nvrmint.h
 *
 * NVidia resource manager API header file for internal builds.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
 * _DWTYPE is returned from GetVersionEx(&osVer) and it is stored in dwWinType
 * in the __GLNVstate structure.
 */
#define NV_WIN_IS_9X(_DWTYPE) (_DWTYPE == VER_PLATFORM_WIN32_WINDOWS)
#define NV_WIN_IS_NT(_DWTYPE) (_DWTYPE == VER_PLATFORM_WIN32_NT)

typedef HANDLE NVDESCRIPTOR;
#define NV_DEVICE_NAME_LENGTH_MAX 127
#define NVARCH_INVALID_NVDESCRIPTOR 0
#define NVARCH_INVALID_CLIENT_HANDLE 0


/*
 * Control codes
 */
#define NVRM_IOCTL_BASE                 0x10
#define NVRM_IOCTL_NV_ARCH              (NVRM_IOCTL_BASE + 5)

#define NVRM_ARCH_NV01FREE              0
#define NVRM_ARCH_NV01ALLOCROOT         1
#define NVRM_ARCH_NV01ALLOCMEMORY       2
#define NVRM_ARCH_NV01ALLOCCONTEXTDMA   3
#define NVRM_ARCH_NV01ALLOCCHANNELPIO   4
#define NVRM_ARCH_NV01ALLOCOBJECT       5
#define NVRM_ARCH_NV01ALLOCDEVICE       6
#define NVRM_ARCH_NV03ALLOCCHANNELDMA   7
#define NVRM_ARCH_NV03DMAFLOWCONTROL    8
#define NVRM_ARCH_NV01INTERRUPT         9
#define NVRM_ARCH_NV01ALLOCEVENT        10
#define NVRM_ARCH_NV01HEAP              11
#define NVRM_ARCH_NV01CONFIGVERSION     12
#define NVRM_ARCH_NV01CONFIGGET         13
#define NVRM_ARCH_NV01CONFIGSET         14
#define NVRM_ARCH_NV01CONFIGUPDATE      15
#define NVRM_ARCH_RING0CALLBACK         16
#define NVRM_ARCH_NV04CONFIGGETEX       17
#define NVRM_ARCH_NV04CONFIGSETEX       18
#define NVRM_ARCH_NV04I2CACCESS         19
#define NVRM_ARCH_NV01DEBUGCONTROL      20
#define NVRM_ARCH_NV04ALLOC             21
// audio stuff
#define NVRM_ARCH_UNIFIEDFREE           30

/*
 * Win 9x data structure.
 */
typedef struct
{
    ULONG function;
    ULONG pParameters;
} NvIoctlArch, *PNvIoctlArch;

typedef struct
{
    ULONG p0;
    ULONG p1;
    ULONG p2;
    ULONG p3;
    ULONG p4;
    ULONG p5;
    ULONG p6;
} NVWATCHAPI_PARAMETERS;

ULONG   NvAlloc             (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID);
ULONG   NvAllocRoot         (HANDLE, ULONG*);
ULONG   NvAllocDevice       (HANDLE, ULONG, ULONG, ULONG, PUCHAR);
ULONG   NvAllocContextDma   (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG   NvAllocChannelPio   (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG);
ULONG   NvAllocChannelDma   (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*);
ULONG   NvAllocMemory       (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG*);
ULONG   NvAllocObject       (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG   NvFree              (HANDLE, ULONG, ULONG, ULONG);
ULONG   NvDmaFlowControl    (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG   NvAllocEvent        (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
ULONG   NvWatchApiFrontEnd  (ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
//ULONG     NvDmaPushMutexState (HANDLE, DWORD);

/*
 * Internal, platform dependent implementation of API routines
 */

HANDLE NvRmOpenWin9x(VOID);
HANDLE NvRmOpenWinNt(VOID);

VOID NvRmCloseWin9x(HANDLE);
VOID NvRmCloseWinNt(VOID);

ULONG NvRmAllocWin9x(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);
ULONG NvRmAllocWinNt(ULONG hClient, ULONG hParent, ULONG hObject, ULONG hClass, PVOID pAllocParms);

ULONG NvRmAllocRootWin9x(ULONG *phClient);
ULONG NvRmAllocRootWinNt(ULONG *phClient);

ULONG NvRmAllocDeviceWin9x(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);
ULONG NvRmAllocDeviceWinNt(ULONG hClient, ULONG hDevice, ULONG hClass, PUCHAR szName);

ULONG NvRmAllocContextDmaWin9x(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);
ULONG NvRmAllocContextDmaWinNt(ULONG hClient, ULONG hDma, ULONG hClass, ULONG flags, PVOID base, ULONG limit);

ULONG NvRmAllocChannelPioWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);
ULONG NvRmAllocChannelPioWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, PVOID *ppChannel, ULONG flags);

ULONG NvRmAllocChannelDmaWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);
ULONG NvRmAllocChannelDmaWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hClass, ULONG hErrorCtx, ULONG hDataCtx, ULONG offset, PVOID *ppChannel);

ULONG NvRmAllocMemoryWin9x(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);
ULONG NvRmAllocMemoryWinNt(ULONG hClient, ULONG hParent, ULONG hMemory, ULONG hClass, ULONG flags, PVOID *ppAddress, ULONG *pLimit);

ULONG NvRmAllocObjectWin9x(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);
ULONG NvRmAllocObjectWinNt(ULONG hClient, ULONG hChannel, ULONG hObject, ULONG hClass);

ULONG NvRmFreeWin9x(ULONG hClient, ULONG hParent, ULONG hObject);
ULONG NvRmFreeWinNt(ULONG hClient, ULONG hParent, ULONG hObject);

ULONG Nv3RmGetDmaPushInfoWin9x(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);
ULONG Nv3RmGetDmaPushInfoWinNt(ULONG hClient, ULONG hDevice, ULONG hChannel, ULONG hDmaContext, ULONG get);

ULONG NvRmAllocEventWin9x(ULONG hClient, ULONG hObjectParent, ULONG hObjectNew, ULONG hClass, ULONG index, ULONG data);
ULONG NvRmAllocEventWinNt(ULONG hClient, ULONG hObjectParent, ULONG hObjectNew, ULONG hClass, ULONG index, ULONG data);

ULONG NvRmArchHeapWin9x(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type,
                               ULONG height, ULONG size, ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG NvRmArchHeapWinNt(ULONG hClient, ULONG hParent, ULONG function, ULONG owner, ULONG type,
                               ULONG height, ULONG size, ULONG *pitch, ULONG *offset, ULONG *address, ULONG *limit, ULONG *free, ULONG *total);
ULONG NvRmConfigGetWin9x(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG NvRmConfigGetWinNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG *pValue);
ULONG NvRmConfigSetWin9x(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);
ULONG NvRmConfigSetWinNt(ULONG hClient, ULONG hDevice, ULONG index, ULONG newValue, ULONG *pOldValue);

ULONG NvRmConfigGetExWin9x(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigGetExWinNt(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigSetExWin9x(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);
ULONG NvRmConfigSetExWinNt(ULONG hClient, ULONG hDevice, ULONG index, VOID *paramStructPtr, ULONG paramSize);

ULONG NvRmInterruptExWin9x(ULONG hClient, ULONG device);
ULONG NvRmInterruptExWinNt(ULONG hClient, ULONG device);

// Unpublished hook for driver to call a ring0 function.
ULONG NvRmRing0CallbackWin9x(ULONG hClient, ULONG device, ULONG procAddr, ULONG param1, ULONG param2);
ULONG NvRmRing0CallbackWinNt(ULONG hClient, ULONG device, ULONG procAddr, ULONG param1, ULONG param2);

ULONG NvRmInterruptWin9x(ULONG, ULONG);
ULONG NvRmInterruptWinNt(ULONG, ULONG);

// Unpublished I2C access routine
ULONG NvRmI2CAccessWin9x(ULONG hClient, ULONG device, VOID *paramStructPtr );
ULONG NvRmI2CAccessWinNt(ULONG hClient, ULONG device, VOID *paramStructPtr );

// Unpublished debug control
ULONG NvRmDebugControlWin9x( ULONG hRoot, ULONG command, VOID *pArgs);
ULONG NvRmDebugControlWinNt( ULONG hRoot, ULONG command, VOID *pArgs);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\rmfail.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * header file for resource manager failure injection (testing) support
 */

#ifdef DEBUG_RM_FAILURES

#define RM_FAILURES_MAX 1024  /* or whatever */
int rm_failure[RM_FAILURES_MAX];
int rm_failure_counts[RM_FAILURES_MAX];

// personality flags for the triggers
#define RM_FAILURES_FLAG_BREAK_ON_TRIGGER        0x80000000
#define RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER 0x40000000

// these occupy the bottom half of the word
#define RM_FAILURES_MASK_PERCENT 0x8000
#define RM_FAILURES_MAX_COUNT    0x7fff
#define RM_FAILURES_MASK_COUNT   0x7fff

#define RM_FAILURE_TRIGGER_ENABLED(n) \
          (rm_failure[(n)] != 0)

#define RM_FAILURE_TRIGGERED(n) \
          RmFailureTriggered((n))

#define RM_FAILURE_TRIGGER_DISABLE(n) \
          rm_failure[(n)] = 0

#define RM_FAILURE_TEST(n, trigger) \
    do { \
        if (RM_FAILURE_TRIGGER_ENABLED((n))) { \
             if (RM_FAILURE_TRIGGERED((n))) { \
                trigger;	/* trigger the error */ \
             } \
         } \
    } while (0)
        

#define RM_FAILURE_ENABLE()  RmFailuresEnable()
#define RM_FAILURE_DISABLE() RmFailuresDisable()

int RmFailureTriggered(int n);
void RmFailuresEnable(void);
void RmFailuresDisable(void);
 
// how do the RM_FAILURE routines "printf" ?

#define RM_FAILURE_PRINTF(args)  DbgPrint args

#else	/* ! DEBUG_RM_FAILURES */
#define RM_FAILURE_TEST(n, trigger)
#define RM_FAILURE_ENABLE()
#define RM_FAILURE_DISABLE()

#endif  /* DEBUG_RM_FAILURES */

//
// convenience macros to assign ranges to tests
//

#define RM_FAILURE_OS(n, trig)          RM_FAILURE_TEST( 00+(n), trig)
#define RM_FAILURE_DAC(n, trig)         RM_FAILURE_TEST( 20+(n), trig)
#define RM_FAILURE_BTREE(N, TRIG)       RM_FAILURE_TEST( 40+(N), TRIG)
#define RM_FAILURE_CLASS(N, TRIG)       RM_FAILURE_TEST( 60+(N), TRIG)
#define RM_FAILURE_DEVINIT(N, TRIG)     RM_FAILURE_TEST( 80+(N), TRIG)
#define RM_FAILURE_DMA(N, TRIG)         RM_FAILURE_TEST(100+(N), TRIG)
#define RM_FAILURE_FB(N, TRIG)          RM_FAILURE_TEST(120+(N), TRIG)
#define RM_FAILURE_FIFO(N, TRIG)        RM_FAILURE_TEST(140+(N), TRIG)
#define RM_FAILURE_GR(N, TRIG)          RM_FAILURE_TEST(160+(N), TRIG)
#define RM_FAILURE_HEAP(N, TRIG)        RM_FAILURE_TEST(180+(N), TRIG)
#define RM_FAILURE_MC(N, TRIG)          RM_FAILURE_TEST(200+(N), TRIG)
#define RM_FAILURE_MODULAR(N, TRIG)     RM_FAILURE_TEST(220+(N), TRIG)
#define RM_FAILURE_MP(N, TRIG)          RM_FAILURE_TEST(240+(N), TRIG)
#define RM_FAILURE_NVKERNEL(N, TRIG)    RM_FAILURE_TEST(260+(N), TRIG)
#define RM_FAILURE_STATE(N, TRIG)       RM_FAILURE_TEST(280+(N), TRIG)
#define RM_FAILURE_TMR(N, TRIG)         RM_FAILURE_TEST(300+(N), TRIG)
#define RM_FAILURE_VBLANK(N, TRIG)      RM_FAILURE_TEST(320+(N), TRIG)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\nvutypes.h ===
#ifndef NVUTYPES_INCLUDED
#define NVUTYPES_INCLUDED
/*
 * nvutypes.h
 *
 * Copyright (C) 1995,1996 NVIDIA Corporation.
 *
 * This file contains unpacked types corresponding to the packed 32-bit 
 * types in <nv32.h>.  For example, the byte/bit alignment of Nvu1Pt16
 * is the same as required by renderSolidRectangle.Rectangle[0].y_x.
 *
 * If you want to manipulate elements smaller than 32 bits in your code, 
 * use these structures or define similar structures.  But when
 * you make assignments to hardware offsets in the NV Architecture,
 * you must use at least 32-bit wide quantities -- you must perform 
 * 32-bit writes.  You can cast these structures to 32 bits or combine
 * them in a union with pure 32-bit elements.
 *
 * An alternative to using these structures is to store values in your
 * own chosen format, and use the macros in <nvmacros.h> to assemble 
 * them into 32-bit values before writing to the chip.  But such macros 
 * take CPU cycles (except for constant values).
 */

/* Note that in the type names, "u" means unpacked, not "U" for unsigned". */

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for V008, U032, etc. typedefs */
#endif

typedef short	S016;

typedef struct {
	V008                c0;                               /*0000-0000*/
	V008                reserved01[0x003];                /*0001-0003*/
} Nvu1Color08;
typedef struct {
	V008                c0;                               /*0000-0000*/
	V008                c1;                               /*0001-0001*/
	V008                c2;                               /*0002-0002*/
	V008                c3;                               /*0003-0003*/
} Nvu4Color08;
typedef struct {
	V016                c0;                               /*0000-0001*/
	V016                reserved01[0x001];                /*0002-0003*/
} Nvu1Color16;
typedef struct {
	V016                c0;                               /*0000-0001*/
	V016                c1;                               /*0002-0003*/
} Nvu2Color16;
typedef struct {
	V032                c0;                               /*0000-0003*/
} Nvu1Color32;
typedef union {
	Nvu1Color08         v008;                             /*0000-0003*/
	Nvu1Color16         v016;                             /*0000-0003*/
	Nvu1Color32         v032;                             /*0000-0003*/
	V032                p;                                /*0000-0003*/
} Nvu1Color;

typedef union {
	Nvu4Color08         v_4_008;                          /*0000-0003*/
	Nvu2Color16         v_2_016;                          /*0000-0003*/
	Nvu1Color32         v_1_032;                          /*0000-0003*/
	Nvu1Color16         v_1_016;                          /*0000-0003*/
	Nvu1Color08         v_1_008;                          /*0000-0003*/
	V032                p;                                /*0000-0003*/
} NvuColor;

typedef struct {
	U016                fractHertz;                       /*0000-0001*/
	U016                intHertz;                         /*0002-0003*/
} NvuHertz;

typedef struct {
	U016                fractPart;                        /*0000-0001*/
	U016                intPart;                          /*0002-0003*/
} NvuFract;

typedef struct {
	S016                x;                                /*0000-0001*/
	S016                y;                                /*0002-0003*/
	U016                w;                                /*0004-0005*/
	U016                h;                                /*0006-0007*/
} NvuRect16;

typedef struct {
	S016                x;                                /*0000-0001*/
	S016                y;                                /*0002-0003*/
} Nvu1Pt16;

typedef struct {
	U016                w;                                /*0000-0001*/
	U016                h;                                /*0002-0003*/
} NvuDim16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
} Nvu2Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
} Nvu3Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
	S016                x3;                               /*000c-000d*/
	S016                y3;                               /*000e-000f*/
} Nvu4Pt16;

typedef struct {
	S016                x0;                               /*0000-0001*/
	S016                y0;                               /*0002-0003*/
	S016                x1;                               /*0004-0005*/
	S016                y1;                               /*0006-0007*/
	S016                x2;                               /*0008-0009*/
	S016                y2;                               /*000a-000b*/
	S016                x3;                               /*000c-000d*/
	S016                y3;                               /*000e-000f*/
	S016                x4;                               /*0010-0011*/
	S016                y4;                               /*0012-0013*/
	S016                x5;                               /*0014-0015*/
	S016                y5;                               /*0016-0017*/
	S016                x6;                               /*0018-0019*/
	S016                y6;                               /*001a-001b*/
	S016                x7;                               /*001c-001d*/
	S016                y7;                               /*001e-001f*/
	S016                x8;                               /*0020-0021*/
	S016                y8;                               /*0022-0023*/
} Nvu9Pt16;


#endif /* NVUTYPES_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\client.h ===
#ifndef _CLIENT_H_
#define _CLIENT_H_
/******************************************************************************
*
*   File:  client.h
*
*   Description:
*       This file contains the data structures needed to describe all
*   client information.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#define NUM_CLIENTS 160
#define NUM_DEVICES 8

typedef struct _def_client_memory_info
{
    U032                Handle;
    U032                Parent;
    U032                Class;
    VOID*               Address;
    U032                Length;
    U032                Type;
    U032                Physicality;
    U032                Coherency;
    U032                Instance;
    U032                version;   // used to keep track of how an instance of class NV01_MEMORY_LOCAL_USER was allocated - C.Moidel
    U032                HeapOwner; /* if version > 0 then HeapOwner is the handle to a valid instance of NV04_HEAP_OWNER
                                                     This means that both the memory and HeapOwner were allocated with RmAlloc()
                                      if version = 0 then HeapOwner is a non-unique user created ID and there 
                                                     is NOT a HeapOwner object behind that ID.  Do not register and unregister with the HeapOwner!
                                                     This means that the memory was allocated with either RmAllocMemory() or RmArchHeap()  - C.Moidel*/  
    VOID*               MemData;   // private per-alloc data
    struct _def_client_memory_info* Next;
    struct _def_client_memory_info* Prev;

} CLI_MEMORY_INFO, *PCLI_MEMORY_INFO;

// FIFO channel info
typedef struct _def_client_fifo_info
{
    U032                Handle;
    U032                Device;
    U032                Class;
    U032                ErrorDmaContext;
    U032                DataDmaContext;
    VOID*               FifoPtr;
    U032                DevID;
    U032                InUse;
    U032                ChID;
    U032                AppID;
    void               *AppHandle;
    U032                Selector;
    VOID*               Flat;
    U032                heventWait;
    V032                hwndNotify;
    V032                hwndError;
    U032                msgNotify;
    U032                msgError;
    VOID*               lpSysCallback;
    U032                eventNotify;
    VOID*               pDmaObject;

} CLI_FIFO_INFO, *PCLI_FIFO_INFO;

// device information
typedef struct _def_client_device_info
{
    U032                Handle;
    U032                Client;
    U032                Class;
    U032                InUse;
    U032                AppID;
    U032                DevID;
    void               *AppHandle;
    PCLI_FIFO_INFO      DevFifoList;
    PCLI_MEMORY_INFO    DevMemoryList;

} CLI_DEVICE_INFO, *PCLI_DEVICE_INFO;

typedef struct _def_client_event_user
{
    U032                Handle;
    U032                Channel;
    struct _def_client_event_user* Next;
    struct _def_client_event_user* Prev;

} CLI_EVENT_USER, *PCLI_EVENT_USER;

typedef struct _def_client_event_info
{
    U032                Handle;
    U032                Class;
    PCLI_EVENT_USER     UserList;
    struct _def_client_event_info* Next;
    struct _def_client_event_info* Prev;

} CLI_EVENT_INFO, *PCLI_EVENT_INFO;


//Heap Owner info structure - added by Chuck Moidel
/* TODO: Create a heap_owner data structure that stores device & handle information about allocations
   that it "ownes" rather than doing a search throughout the data structres. */

typedef struct _def_client_heap_owner_info
{
    U032                Handle;
    U032                Client;
    U032                Class;
    U032                BlockReferenceCount;
//  PCLI_MEMORY_INFO    HeapOwnerMemoryList; 
//  PCLI_DEVICE_INFO    CliDeviceList;
    struct _def_client_heap_owner_info* Next;
    struct _def_client_heap_owner_info* Prev;

} CLI_HEAP_OWNER_INFO, *PCLI_HEAP_OWNER_INFO;

// client information
typedef struct _def_client_info
{
    U032                 Handle;
    U032                 Class;
    U032                 InUse;
    U032                 AppID;
    U032                 ProcID;
    void                *AppHandle;
    U032                 ProcContext;
    U032                 FifoCount;
    PCLI_DMA_INFO        CliDmaList;
    PCLI_DEVICE_INFO     CliDeviceList;
    PCLI_MEMORY_INFO     CliMemoryList;
    PCLI_EVENT_INFO      CliEventList;
    PCLI_HEAP_OWNER_INFO CliHeapOwnerList;   // modified by Chuck Moidel

} CLIENTINFO, *PCLIENTINFO;

//
// FIFO channel info.
//

typedef struct _def_channel_info
{
    U032  InUse;
    U032  ChID;
    U032  AppID;
    VOID *AppHandle;
    U032  Selector;
    VOID* Flat;
    U032  heventWait;
    V032  hwndNotify;
    V032  hwndError;
    U032  msgNotify;
    U032  msgError;
    VOID* lpSysCallback;
} CHANNELINFO, *PCHANNELINFO;


RM_STATUS           CliAddClient            (U032*, U032);
BOOL                CliDelClient            ();
BOOL                CliGetClientHandle      (U032*);
BOOL                CliGetClientIndex       (U032, U032*);
BOOL                CliGetClientAppHandle   (U032, void**);
BOOL                CliSetClientContext     (U032);
BOOL                CliSetClientAppHandle   (U032, void*);
BOOL                CliSetClientInstance    (U032);
RM_STATUS           CliGetClientHandleFromChID(PHWINFO, U032, U032*);
RM_STATUS           CliAddDevice            (U032, U032, U032);
BOOL                CliDelDevice            (U032);
BOOL                CliMakeDeviceList       (U032, U032, PCLI_DEVICE_INFO*);
BOOL                CliGetDeviceInfo        (U032, PCLI_DEVICE_INFO*);
PCLI_DEVICE_INFO    CliGetDeviceList        ();
BOOL                CliGetDeviceHandle      (U032, U032*);
BOOL                CliGetDeviceAppHandle   (U032, void**);
BOOL                CliSetDeviceContext     (U032, PHWINFO*);
BOOL                CliSetDeviceAppHandle   (U032, void*);
BOOL                CliGetDeviceClassString (U032, char*);
RM_STATUS           CliAddDeviceFifo        (PHWINFO, U032, U032, U032, U032, U032, U032, U032, U032, VOID*);
BOOL                CliDelDeviceFifo        (U032, U032);
BOOL                CliMakeDeviceFifoList   (U032, U032, U032, PCLI_FIFO_INFO*);
BOOL                CliGetDeviceFifoInfo    (U032, U032, PCLI_FIFO_INFO*);
BOOL                CliGetDeviceFifoList    (U032, PCLI_FIFO_INFO*);
RM_STATUS           CliAddDeviceMemory      (U032, U032, U032, VOID*, U032, U032, U032, U032);
BOOL                CliDelDeviceMemory      (U032, U032);
BOOL                CliDelDeviceHeapOwner   (U032, U032);
BOOL                CliGetDeviceMemoryInfo  (U032, U032, PCLI_MEMORY_INFO*);
PCLI_MEMORY_INFO    CliGetDeviceMemoryList  (U032);
RM_STATUS           CliAddDma               (U032, U032, U032, U032, U032, VOID*, U032, PCLI_DMA_INFO*);
BOOL                CliDelDma               (U032);
BOOL                CliGetDmaInfo           (U032, PCLI_DMA_INFO*);
PCLI_DMA_INFO       CliGetDmaList           ();
RM_STATUS           CliAddMemory            (U032, U032, U032, U032, VOID*, U032, VOID*);
BOOL                CliDelMemory            (U032);
BOOL                CliGetMemoryInfo        (U032, PCLI_MEMORY_INFO*);
BOOL                CliGetMemoryInfoForLinAddr(VOID *, PCLI_MEMORY_INFO *);
PCLI_MEMORY_INFO    CliGetMemoryList        ();
RM_STATUS           CliAddEvent             (U032, U032, U032, U032, PCLI_EVENT_INFO*);
BOOL                CliDelEvent             (U032);
BOOL                CliDelEventUser         (U032, U032);
U032                CliGetEventUserHandle   (PCLI_EVENT_USER, U032);
BOOL                CliGetEventInfo         (U032, PCLI_EVENT_INFO*);
PCLI_EVENT_INFO     CliGetEventList         ();
BOOL                CliFindObject           (U032, POBJECT*, U032*);
BOOL                CliGetClass             (U032, U032, U032*);
BOOL                CliIsUniqueHandle       (U032, BOOL);
BOOL                CliGetPhysicalDevice    (U032, U032*);

#endif // _CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\aos.h ===
#if !defined _AUDIOOS_H_
#define _AUDIOOS_H_

#if defined __cplusplus
extern "C" {
#endif

// init calls
RM_STATUS   RmInitAudioDevice(VOID *pResList, VOID *pDevObj, PHWINFO_COMMON_FIELDS pDev);
VOID        RmShutdownAudioDevice(PHWINFO_COMMON_FIELDS pDev);


/* specifies the dont care bits from bit 12 onwards */
#define ALIGN_4K					0x00000000
#define ALIGN_8K					0x00000001		
#define ALIGN_16K					0x00000003
#define ALIGN_32K					0x00000007
#define ALIGN_64K					0x0000000F
#define ALIGN_128K					0x0000001F
#define ALIGN_DONT_CARE				0xFFFFFFFF

// exported services
RM_STATUS	aosAllocateMem(U032 uSize, U032 uAlignMask, VOID **ppLinAddr, VOID **ppPhysAddr);
VOID		aosFreeMem(VOID *pLinAddr);

RM_STATUS	aosMapLinearAddress(VOID *pPhys, U032 uSize, VOID **ppLinear);
VOID		aosUnmapLinearAddress(VOID *pLinear, U032 uSize);

RM_STATUS   aosGetPhysicalAddress(VOID *pLinAddr, U032 uSize, VOID **pPhysAddr);

VOID        aosZeroMemory(VOID *pLinAddr, U032 uSize);

// debug print stuff
VOID        aosDbgPrintString(int iDbgLevel, char *pStr);
VOID        aosDbgBreakPoint();

// OS-independent functions for doing file i/o - used for debugging drivers without real HW
VOID *      aosCreateDiskFile();
VOID        aosWriteDiskFile(VOID *pHandle, VOID *pBuffer, U032 uSize);
VOID        aosCloseDiskFile(VOID *pHandle);


#define PAGEOFF(p)			        (((U032)(p)) & 0xFFF)
#define MAX_SIMUL_ALLOCATIONS       256     /* maximum number of simultaneous memory allocations */

#if !defined PAGE_SIZE
#define PAGE_SIZE                   4096
#endif

// this is all defined in os.h for Win9x, but not for NT (??)
#if !defined DEBUGLEVEL_TRACEINFO
#define DEBUGLEVEL_TRACEINFO	    0       // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO	    1       // For informational debug setup info
#define DEBUGLEVEL_USERERRORS	    2       // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS	        3       // For RM debug warning info
#define DEBUGLEVEL_ERRORS	        4       // For RM debug error info
#endif

#if defined __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\nvarch.h ===
#ifndef _NVARCH_H
#define _NVARCH_H
/**************************************************************************************************************
*
*	File:  nvarch.h
*
*	Description:
*		Defines the functions that implement the nvalloc architecture
*
**************************************************************************************************************/


// macros for IOCTL argument passing and return values
#define ARGS_PTR(t) t *pArgs = (t*)parameters    // declare and define a pointer to the arg struct (arg struct type)
#define ARG(a) (pArgs->a)					     // reference to a member of the arg struct (element name)
#define ARG_P064(a) NvP64_VALUE(pArgs->a)	     // extraction of a pointer from a NvP64 in the arg struct (element name)
#define ARG_SELECTOR(a) NvP64_SELECTOR(pArgs->a) // extraction of a selector from a NvP64 in the arg struct (element name)
#define ARG_U064(a) NvU64_VALUE(pArgs->a)        // extraction of a value from a NvU64 in the arg struct (element name)

// macros for error checking
#define RM_SUCCESS(s) ((s) == RM_OK)

// TO DO: clean this up by retrieving values from the registry
// display info constants and structure taken from win95's vdd.h
#define REGISTRY_BPP_NOT_VALID          0x0008
#define MONITOR_INFO_NOT_VALID          0x0080
#define MONITOR_INFO_DISABLED_BY_USER   0x0100

//---------------------------------------------------------------------------
//
//  External variable definitions.
//
//---------------------------------------------------------------------------

extern PCLIENTINFO clientInfo;

extern U032         rmInService;
extern U032         osInService;
extern U032         rmInSafeService;
extern U032         rmInCallback;
extern U032       * rmStackBase;
extern U032       * rmStack;
extern U032         vmmStack;

//---------------------------------------------------------------------------
//
// Function prototypes.
//
//---------------------------------------------------------------------------

// discardable initialization routines
RM_STATUS 	initSemaphore           (VOID);
RM_STATUS	initCallbackFreeList    (VOID);
RM_STATUS	initClientInfo          (VOID);
RM_STATUS   destroyClientInfo       (VOID);
RM_STATUS 	initMemoryAllocTable    (VOID);

// exported API functions
VOID  		Nv01AllocRoot			(NVOS01_PARAMETERS*);
VOID  		Nv01AllocDevice			(NVOS06_PARAMETERS*);
VOID  		Nv01AllocContextDma		(NVOS03_PARAMETERS*);
VOID  		Nv01AllocChannelPio		(NVOS04_PARAMETERS*);
VOID  		Nv03AllocChannelDma		(NVOS07_PARAMETERS*);
VOID  		Nv01AllocMemory			(NVOS02_PARAMETERS*);
VOID		Nv01AllocObject			(NVOS05_PARAMETERS*);
VOID		Nv04Alloc               (NVOS21_PARAMETERS*);
VOID  		Nv01Free				(NVOS00_PARAMETERS*);
VOID  		Nv03DmaFlowControl		(NVOS08_PARAMETERS*);
VOID        Nv01Interrupt           (NVOS09_PARAMETERS*);
VOID  		Nv01AllocEvent  		(NVOS10_PARAMETERS*);
VOID        Nv03ArchHeap            (NVOS11_PARAMETERS*);
VOID        Nv01ConfigVersion       (NVOS12_PARAMETERS*);
VOID        Nv01ConfigGet           (NVOS13_PARAMETERS*);
VOID        Nv01ConfigSet           (NVOS14_PARAMETERS*);
VOID        Nv01ConfigUpdate        (NVOS15_PARAMETERS*);
VOID        Nv01DebugControl        (NVOS20_PARAMETERS*);
VOID        NvRing0Callback         (NVRM_RING0CALLBACK_PARAMS*);
VOID        Nv04ConfigGetEx         (NVOS_CONFIG_GET_EX_PARAMS*);
VOID        Nv04ConfigSetEx         (NVOS_CONFIG_SET_EX_PARAMS*);
VOID        Nv04I2CAccess           (NVOS_I2C_ACCESS_PARAMS*);

// RM support functions
NvV32 		RmAllocClient			(U032*, U032);
NvV32 		RmAllocDevice			(U032, U032, U032, char*);
NvV32 		RmAllocContextDma		(U032, U032, U032, U032, U032, VOID*, U032);
NvV32 		RmAllocChannelPio		(U032, U032, U032, U032, U032, VOID**, U032);
NvV32 		RmAllocChannelDma		(U032, U032, U032, U032, U032, U032, U032, VOID**);
RM_STATUS   RmAllocChannel			(U032, U032, U032, U032, U032, U032, U032, VOID**, U032);
NvV32 		RmAllocMemory			(U032, U032, U032, U032, U032, VOID**, U032*);
RM_STATUS   RmAllocSystemMemory     (PHWINFO, U032, VOID**, U032*, VOID**, U032);
RM_STATUS 	RmAllocInstanceMemory	(PHWINFO, U032, VOID**, U032*, U032*, U032*);
RM_STATUS 	RmAllocFrameBufferMapping(PHWINFO, U032, VOID**, U032*);
NvV32		RmAllocObject			(U032, U032, U032, U032);
NvV32       RmAllocEvent            (U032, U032, U032, U032, U032, U064);
NvV32		RmAlloc			        (U032, U032, U032, U032, VOID*);
RM_STATUS	RmAllocObjectEx			(U032, U032, U032, VOID*);
NvV32 		RmFree					(U032, U032, U032);
RM_STATUS 	RmFreeClient			(U032);
RM_STATUS 	RmFreeDevice			(U032, U032);
RM_STATUS 	RmFreeContextDma		(U032, U032);
RM_STATUS 	RmFreeChannel			(U032, U032, U032);
RM_STATUS	RmFreeMemory			(U032, U032, U032, U032);
RM_STATUS	RmFreeSystemMemory		(PHWINFO, U032);
RM_STATUS	RmFreeInstanceMemory	(PHWINFO, U032, U032, U032);
RM_STATUS	RmFreeFrameBuffer		(PHWINFO, U032, U032, U032);
RM_STATUS	RmFreeObject			(U032, U032);
RM_STATUS   RmFreeEvent             (U032, U032);
NvV32 		RmDmaChannelWritePut	(U032, U032);
NvV32 		RmDmaChannelWritePutWithGet(U032, U032, U032);
NvV32 		RmDmaChannelReadGet		(U032, U032*);
NvV32 		RmDmaChannelSetJump		(U032, U032);
NvV32       RmInterrupt             (U032, U032);
NvV32       RmArchHeap              (U032, U032, U032, U032, U032, U032, U032, U032, S032*, U032*, U032*, VOID**, U032*, U032*, U032*);
NvV32       RmConfigVersion         (U032, U032, U032*);
NvV32		RmConfigGet				(U032, U032, U032, U032*);
NvV32		RmConfigSet				(U032, U032, U032, U032*, U032);
NvV32       RmConfigUpdate          (U032, U032, U032);
NvV32       RmConfigGetEx           (U032, U032, U032, VOID*, U032);
NvV32       RmConfigSetEx           (U032, U032, U032, VOID*, U032);
RM_STATUS	RmAllocDeviceInstance	(U032*);
NvV32		RmArchStatus			(RM_STATUS, U032);
VOID		RmInitCpuInfo			(PHWINFO);
VOID		RmInitBusInfo			(PHWINFO);
NvV32       RmI2CAccess             (U032, U032, VOID*);
NvV32       RmDirectMethodCall      (U032, U032, U032, U032, U032);
RM_STATUS	RmDebugEx			    (U032, U032, U032, VOID*);

#endif // _NVARCH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\nvwin32.h ===
#ifndef NVWIN32_INCLUDED
#define NVWIN32_INCLUDED
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NV32_INCLUDED
#include <nv32.h>                       /* for NvChannel typedef */
#endif

/***************************************************************************
 *                   NVIDIA-supplied routines                              *
 ***************************************************************************/

/***** Hardware access *****/

/*
 * NvOpen() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpen(char *);

/*
 * NvOpenDma() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpenDma(char *, int, int, int);

/*
 * NvClose() closes the channel to the chip and attempts to
 * clean up all objects created in that channel.
 */
extern int                  __stdcall NvClose(NvChannel *);

/***** Operating Environment routines *****/
/*
 * NvWait() waits to be "awakened" after requesting notification with
 * the NV_OS_NOTIFY_WILL_SLEEP style.
 * Note that in Windows 3.1 any Windows message will wake up the
 * application.
 */
extern int  __stdcall NvWait(NvChannel *);

/*
 * NvNotifyMsg() specifies a Windows message for NV1 to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_MESSAGE style.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvNotifyMsg(NvChannel *, int, int);

/*
 * NvErrorMsg() specifies a Windows message for NV to send to the
 * application upon detecting an error.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvErrorMsg(NvChannel *, int, int);

/*
 * Although Win32 applications have a flat address space, on the X86 
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
extern int  __stdcall NvGetFlatDataSelector(void);
extern int  __stdcall NvGetFlatCodeSelector(void);

/*
 * NvConfigVersion() returns an NV version number indicating the NV version.
 * The format of this is 0x00010206, where
 *  - 0x0001 is the chip architecture
 *  -   0x02 is the software release
 *  -   0x06 is the minor revision
 */
extern int  __stdcall NvConfigVersion(void);

#define NV_CHIP_ARCH(ver)   ((ver) >> 16)
#define NV_SW_RELEASE(ver)  (((ver) >> 8) & 0xFF)
#define NV_MINOR_REV(ver)   ((ver) & 0xFF)

/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** OS-dependent constants *****/

/* This posts a new architecture event */
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

/* This puts the process to sleep awaiting notification */
#define NV_OS_NOTIFY_WILL_SLEEP	   0x00000003

/* This puts a message in the client's message queue upon notification */
#define NV_OS_NOTIFY_MESSAGE	   0x00000002

/* This posts a Win32 event to the client upon notification */
#define NV_OS_NOTIFY_EVENT  	   0x00000004

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_VM_EVENT  	   0x00000005

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_STATE_CHANGE  0x00000006


/***************************************************************************
 *                     OS Resource Strings                                 *
 ***************************************************************************/

/* Maximum length of an OS string (conservative, actual is about 24) */
#define NV_OS_MAX_NAME_LENGTH      32

/***** OS resource names for sources and sinks of samples *****/

/* for NV_VIDEO_SINK */
#define NV_OS_VIDEO_MONITOR        "CON:"

/* for NV_IMAGE_TO_VIDEO. The HWND window handle should replace %u */
#define NV_OS_CANVAS_WINDOW        "WND%u:"

/* for NV_AUDIO_SINK */
#define NV_OS_LINE_OUT_LEFT        "LIN:\\LEFT"
#define NV_OS_LINE_OUT_RIGHT       "LIN:\\RIGHT"

/* for NV_AUDIO_SOURCE */
#define NV_OS_LINE_IN_LEFT         "LIN:\\LEFT"
#define NV_OS_LINE_IN_RIGHT        "LIN:\\RIGHT"
#define NV_OS_MIC_IN_LEFT          "MIC:\\LEFT"
#define NV_OS_MIC_IN_RIGHT         "MIC:\\RIGHT"


/***** Many devices can provide samples for NV_GAME_PORT_SOURCE *****/

/* Raw potentiometer data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 8 channels (0-7) replaces %d */
/* NOTE: The NV_OS_POT O/S string changed to "POTA%d:". The 2.0 and higher
 * Resource Manager will generate NV_ERROR1_NO_SUCH_OBJECT if there is no 
 * joystick connected. This string means nothing to the 1.20 Resource Manager.
 * For backwards compatibility, use NV_OS_GAME_PORT ("POT%d:"): both the 2.0 
 * and 1.20 Resource Manager will not generate an error if no joystick is
 * connected.
 */
#define NV_OS_POT                      "POTA%d:"
/* XXX Old name preserved for compatibility, use NV_OS_POT */
#define NV_OS_GAME_PORT                "POT%d:"


/* Calibrated joystick data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_JOYSTICK_BUTTONS         "JOY%d:\\BUTTONS"

#define NV_OS_JOYSTICK_BUTTON_TRIGGER  0x0001
#define NV_OS_JOYSTICK_BUTTON_SELECT   0x0002
#define NV_OS_JOYSTICK_BUTTON_A        0x0004
#define NV_OS_JOYSTICK_BUTTON_B        0x0008

#define NV_OS_JOYSTICK_X_AXIS          "JOY%d:\\X_AXIS"
#define NV_OS_JOYSTICK_Y_AXIS          "JOY%d:\\Y_AXIS"


/* Pedal data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_PEDALS                   "PEDALS%d:"


/* Throttle data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_THROTTLE                 "THROTTLE%d:"


/* 8-button game pad data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_PAD_BUTTONS              "PAD%d:"
/* XXX Old name preserved for compatibility, use NV_OS_PAD_BUTTONS */
#define NV_OS_PAD                      "PAD%d:"

#define NV_OS_PAD_BUTTON_START         0x0001
#define NV_OS_PAD_BUTTON_RIGHT         0x0002
#define NV_OS_PAD_BUTTON_LEFT          0x0004
#define NV_OS_PAD_BUTTON_UP            0x0008
#define NV_OS_PAD_BUTTON_DOWN          0x0010
#define NV_OS_PAD_BUTTON_A             0x0020
#define NV_OS_PAD_BUTTON_B             0x0040
#define NV_OS_PAD_BUTTON_C             0x0080
#define NV_OS_PAD_BUTTON_X             0x0100
#define NV_OS_PAD_BUTTON_Y             0x0200
#define NV_OS_PAD_BUTTON_Z             0x0400
#define NV_OS_PAD_BUTTON_TOP_RIGHT     0x0800
#define NV_OS_PAD_BUTTON_TOP_LEFT      0x1000


/* 3-axis yoke data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_YOKE_BUTTONS             "YOKE%d:\\BUTTONS"

#define NV_OS_YOKE_BUTTON_START        0x0001
#define NV_OS_YOKE_BUTTON_RIGHT        0x0002
#define NV_OS_YOKE_BUTTON_LEFT         0x0004
#define NV_OS_YOKE_BUTTON_UP           0x0008
#define NV_OS_YOKE_BUTTON_DOWN         0x0010
#define NV_OS_YOKE_BUTTON_A            0x0020
#define NV_OS_YOKE_BUTTON_B            0x0040
#define NV_OS_YOKE_BUTTON_C            0x0080
#define NV_OS_YOKE_BUTTON_X            0x0100
#define NV_OS_YOKE_BUTTON_Y            0x0200
#define NV_OS_YOKE_BUTTON_Z            0x0400
#define NV_OS_YOKE_BUTTON_TOP_RIGHT    0x0800
#define NV_OS_YOKE_BUTTON_TOP_LEFT     0x1000

#define NV_OS_YOKE_X_AXIS              "YOKE%d:\\X_AXIS"
#define NV_OS_YOKE_Y_AXIS              "YOKE%d:\\Y_AXIS"
#define NV_OS_YOKE_Z_AXIS              "YOKE%d:\\Z_AXIS"

/* 2-axis gun position data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* The HWND window handle should replace %u */
#define NV_OS_GUN_BUTTONS              "GUN%dWND%u:\\BUTTONS"

#define NV_OS_GUN_BUTTON_START         0x0001
#define NV_OS_GUN_BUTTON_TRIGGER	   0x0002

#define NV_OS_GUN_X_POSITION		   "GUN%dWND%u:\\X_POS"
#define NV_OS_GUN_Y_POSITION		   "GUN%dWND%u:\\Y_POS"

/* Value returned if gun is still determing X/Y coordinate */
#define NV_OS_GUN_POSITION_COUNTING    0xFFFE
/* Value returned if gun is off screen or outside canvas) */
#define NV_OS_GUN_POSITION_OFF_SCREEN  0xFFFF

/***** WATCOM special handling *****/
/* WATCOM 10.0 compiler needs special declaration of these functions */
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvOpen "*";
#pragma aux (__stdcall) NvClose "*";
#pragma aux (__stdcall) NvWait "*";
#pragma aux (__stdcall) NvNotifyMsg "*";
#pragma aux (__stdcall) NvErrorMsg "*";
#pragma aux (__stdcall) NvGetFlatDataSelector "*";
#pragma aux (__stdcall) NvGetFlatCodeSelector "*";
#pragma aux (__stdcall) NvVpeExtras "*";
#pragma aux (__stdcall) NvDmaPushOperation "*";
#ifdef VPE_EXTRAS
#pragma aux (__stdcall) NvOverlayExtras "*";
#endif

#ifdef _WIN32  // don't do this for the DOS compile!!
#pragma aux (__stdcall) NvConfigVersion "*";
#endif
#endif /* __WATCOMC__ */

#ifdef __cplusplus
};
#endif
#endif /* NVWIN32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\nvagp.h ===
#ifndef NVAGP_H
#define NVAGP_H

#include <nvrm.h>

#include <os.h>
#ifdef LINUX
#include <os-interface.h>
#endif

// AGP memory allocation tracking
typedef struct _AGP_MEM_INFO
{
    VOID *SysAddr;              // original pages
    U032 PageCount;
    U032 Offset;                // index into AGP Bitmap
    VOID *pMdl;                  // MDL for user mapping
} AGP_MEM_INFO, *PAGP_MEM_INFO;

/* export AGP functionality to rest of resman */
BOOL RmInitAGP (PHWINFO);
BOOL RmTeardownAGP (PHWINFO);
RM_STATUS NvInitChipset(PHWINFO, U032 *handle, U032 *chipset);
RM_STATUS NvSetAGPRate(PHWINFO, U032 handle, U032 *agprate);
VOID NvUpdateAGPConfig(PHWINFO);
RM_STATUS NvGetAGPBaseLimit(PHWINFO, U032 *base, U032 *limit);
VOID NvEnableAGP(PHWINFO);
VOID NvDisableAGP(PHWINFO);
VOID NvSetupAGPConfig(PHWINFO);
RM_STATUS NvAllocAGPPages ( PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS NvFreeAGPPages ( PHWINFO, VOID **, VOID  *);
BOOL NvSetBusDeviceFunc(PHWINFO);
RM_STATUS NvSetCapIDOffset(PHWINFO, U032, U032 *);

/* OS-specific functionality imported from resman */
/* probably need to split this into a different file */
#ifdef LINUX
#include <linux/types.h>		/* for size_t */
#define flush_cache()			asm volatile("wbinvd":::"memory")
#else
#define flush_cache()
#endif

#define AgpInfo(pdev)      (((PRMINFO)(pdev)->pRmInfo)->AGP)

#define PCI_VENDOR_ID		0x00
#define PCI_DEVICE_ID		0x02
#define PCI_BASE_ADDRESS_0	0x10   /* Aperture Base */
#define PCI_BASE_ADDRESS_1	0x14   /* Aperture Base */
#define PCI_CAPABILITY_LIST     0x34
#define PCI_DEVICE_SPECIFIC     0x40

#define PCI_MAX_SLOTS            255

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_INVALID_VENDORID                0xFFFF

#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_MULTIFUNCTION                   0x80

#define AGP_NB_ADDR_VALID       0x80000000

#define AGP_CAP_ID              0x02
#define AGP_CAP_STATUS          0x04
#define AGP_CAP_COMMAND         0x08

#define PCI_VENDOR_ID_INTEL   0x8086
#define PCI_VENDOR_ID_AMD     0x1022
#define PCI_VENDOR_ID_VIA     0x1106
#define PCI_VENDOR_ID_RCC     0x1166
#define PCI_VENDOR_ID_MICRON  0x1042

#define AGP_STATUS            AgpInfo(pDev).AGPCapPtr+4
#define AGP_COMMAND           AgpInfo(pDev).AGPCapPtr+8

#define INTEL_CHIPSET_CONFIG    0x50
#define INTEL_ERRSTS            0x92
#define INTEL_GART_CONTROL      0xB0
#define INTEL_APER_SIZE         0xB4
#define INTEL_GART_BASE         0xB8
#define INTEL_MULTI_TRANS_TIMER         0xBC
#define INTEL_LOW_PRI_TRANS_TIMER       0xBD

#define VIA_GART_CONTROL        0x80
#define VIA_APER_SIZE           0x84
#define VIA_GART_BASE           0x88
#define VIA_AGP_CONTROL         0xAC

#define AMD_APER_SIZE           0xAC

/* Memory space registers - hex offsets */
#define AMD_GART_STATUS         0x02
#define AMD_GART_BASE           0x04
#define AMD_GART_CONTROL        0x10

#define RCC_APER_SIZE           0x60

#define osPciOrByte(handle, offset, value)			\
    {								\
        volatile unsigned char tmp = osPciReadByte(handle, offset);	\
        tmp |= (U008) value;						\
		osPciWriteByte(handle, offset, tmp);			\
    }

#define osPciOrWord(handle, offset, value)			\
    {								\
        volatile unsigned short tmp = osPciReadWord(handle, offset); \
        tmp |= (U016) value;						\
		osPciWriteWord(handle, offset, tmp);			\
    }

#define osPciOrDword(handle, offset, value)			\
    {								\
        volatile unsigned int tmp = osPciReadDword(handle, offset);	\
        tmp |= (U032) value;						\
		osPciWriteDword(handle, offset, tmp);		\
    }

#define osPciAndByte(handle, offset, value)			\
    {								\
        volatile unsigned char tmp = osPciReadByte(handle, offset);	\
        tmp &= (U008) value;						\
		osPciWriteByte(handle, offset, tmp);			\
    }

#define osPciAndWord(handle, offset, value)			\
    {								\
        volatile unsigned short tmp = osPciReadWord(handle, offset);	\
        tmp &= (U016) value;						\
		osPciWriteWord(handle, offset, tmp);			\
    }

#define osPciAndDword(handle, offset, value)			\
    {								\
        volatile unsigned int tmp = osPciReadDword(handle, offset);	\
        tmp &= (U032) value;						\
		osPciWriteDword(handle, offset, tmp);		\
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\cpuid-ppc.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1999 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1999 NVIDIA, Corp.    NVIDIA  design  patents           *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* CPU Information Gather Routines ***********************\
*                                                                           *
* Module: cpuid-ppc.c                                                       *
*   One time initialization code to setup the Processor type                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <nvcm.h>
#include <os.h>

/*
 * ID the CPU.
 */
VOID RmInitCpuInfo(
    PHWINFO pDev
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    pRmInfo->Processor.Type = NV_CPU_PPC603;
    
    // Calculate the frequency
    pRmInfo->Processor.Clock = osGetCpuFrequency();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\inc\nvrm_obscure.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 2000 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * Obscure resman symbols in the build by defining them away.
 *
 * Periodically should look at symbols in output to make sure no
 * new ones have snuck in.
 *
 * This should be os-independent.  Symbols that don't exist for one release
 *   or another are harmless
 *
 * TODO:
 *    need a perl script to undo this in arbitrary text (cut'n'paste
 *    debugger output for example)
 */

#define BT_Init                                      _nv_rmsym_00001
#define Bt_NC                                        _nv_rmsym_00002
#define Bt_NC400                                     _nv_rmsym_00003
#define Bt_NC480                                     _nv_rmsym_00004
#define Bt_NC600                                     _nv_rmsym_00005
#define Bt_NJ                                        _nv_rmsym_00006
#define Bt_NJ400                                     _nv_rmsym_00007
#define Bt_NJ480                                     _nv_rmsym_00008
#define Bt_NJ600                                     _nv_rmsym_00009
#define Bt_NM                                        _nv_rmsym_00010
#define Bt_NM400                                     _nv_rmsym_00011
#define Bt_NM480                                     _nv_rmsym_00012
#define Bt_NM600                                     _nv_rmsym_00013
#define Bt_PA                                        _nv_rmsym_00014
#define Bt_PA400                                     _nv_rmsym_00015
#define Bt_PA480                                     _nv_rmsym_00016
#define Bt_PA600                                     _nv_rmsym_00017
#define Bt_PM                                        _nv_rmsym_00018
#define Bt_PM400                                     _nv_rmsym_00019
#define Bt_PM480                                     _nv_rmsym_00020
#define Bt_PM600                                     _nv_rmsym_00021
#define Bt_PN                                        _nv_rmsym_00022
#define Bt_PN400                                     _nv_rmsym_00023
#define Bt_PN480                                     _nv_rmsym_00024
#define Bt_PN600                                     _nv_rmsym_00025
#define Btc_NC                                       _nv_rmsym_00026
#define Btc_NJ                                       _nv_rmsym_00027
#define Btc_NM                                       _nv_rmsym_00028
#define Btc_NM200                                    _nv_rmsym_00029
#define Btc_NM240                                    _nv_rmsym_00030
#define Btc_NM300                                    _nv_rmsym_00031
#define Btc_NM360                                    _nv_rmsym_00032
#define Btc_NM384                                    _nv_rmsym_00033
#define Btc_NM3x4                                    _nv_rmsym_00034
#define Btc_NM400                                    _nv_rmsym_00035
#define Btc_NM480                                    _nv_rmsym_00036
#define Btc_NM600                                    _nv_rmsym_00037
#define Btc_PA                                       _nv_rmsym_00038
#define Btc_PA200                                    _nv_rmsym_00039
#define Btc_PA240                                    _nv_rmsym_00040
#define Btc_PA300                                    _nv_rmsym_00041
#define Btc_PA360                                    _nv_rmsym_00042
#define Btc_PA384                                    _nv_rmsym_00043
#define Btc_PA3x4                                    _nv_rmsym_00044
#define Btc_PA400                                    _nv_rmsym_00045
#define Btc_PA480                                    _nv_rmsym_00046
#define Btc_PA600                                    _nv_rmsym_00047
#define Btc_PM                                       _nv_rmsym_00048
#define Btc_PN                                       _nv_rmsym_00049
#define CHRONTEL_NTSC                                _nv_rmsym_00050
#define CHRONTEL_PAL                                 _nv_rmsym_00051
#define CH_Disable                                   _nv_rmsym_00052
#define CH_FBC                                       _nv_rmsym_00053
#define CH_Init                                      _nv_rmsym_00054
#define CH_NTSC320X200                               _nv_rmsym_00055
#define CH_NTSC320X240                               _nv_rmsym_00056
#define CH_NTSC400X300                               _nv_rmsym_00057
#define CH_NTSC480X360                               _nv_rmsym_00058
#define CH_NTSC512X384                               _nv_rmsym_00059
#define CH_NTSC640X400                               _nv_rmsym_00060
#define CH_NTSC640X480                               _nv_rmsym_00061
#define CH_NTSC800X600                               _nv_rmsym_00062
#define CH_NULL_STRING                               _nv_rmsym_00063
#define CH_PAL320X200                                _nv_rmsym_00064
#define CH_PAL320X240                                _nv_rmsym_00065
#define CH_PAL400X300                                _nv_rmsym_00066
#define CH_PAL480X360                                _nv_rmsym_00067
#define CH_PAL512X384                                _nv_rmsym_00068
#define CH_PAL640X400                                _nv_rmsym_00069
#define CH_PAL640X480                                _nv_rmsym_00070
#define CH_PAL800X600                                _nv_rmsym_00071
#define CliAddClient                                 _nv_rmsym_00072
#define CliAddDevice                                 _nv_rmsym_00073
#define CliAddDeviceFifo                             _nv_rmsym_00074
#define CliAddDeviceMemory                           _nv_rmsym_00075
#define CliAddDma                                    _nv_rmsym_00076
#define CliAddEvent                                  _nv_rmsym_00077
#define CliAddMemory                                 _nv_rmsym_00078
#define CliDelClient                                 _nv_rmsym_00079
#define CliDelDevice                                 _nv_rmsym_00080
#define CliDelDeviceFifo                             _nv_rmsym_00081
#define CliDelDeviceHeapOwner                        _nv_rmsym_00082
#define CliDelDeviceMemory                           _nv_rmsym_00083
#define CliDelDma                                    _nv_rmsym_00084
#define CliDelEvent                                  _nv_rmsym_00085
#define CliDelEventUser                              _nv_rmsym_00086
#define CliDelMemory                                 _nv_rmsym_00087
#define CliFindObject                                _nv_rmsym_00088
#define CliGetClass                                  _nv_rmsym_00089
#define CliGetClientHandle                           _nv_rmsym_00090
#define CliGetClientHandleFromChID                   _nv_rmsym_00091
#define CliGetClientIndex                            _nv_rmsym_00092
#define CliGetDeviceClassString                      _nv_rmsym_00093
#define CliGetDeviceFifoInfo                         _nv_rmsym_00094
#define CliGetDeviceFifoList                         _nv_rmsym_00095
#define CliGetDeviceHandle                           _nv_rmsym_00096
#define CliGetDeviceInfo                             _nv_rmsym_00097
#define CliGetDeviceList                             _nv_rmsym_00098
#define CliGetDeviceMemoryInfo                       _nv_rmsym_00099
#define CliGetDeviceMemoryList                       _nv_rmsym_00100
#define CliGetDmaInfo                                _nv_rmsym_00101
#define CliGetDmaList                                _nv_rmsym_00102
#define CliGetEventInfo                              _nv_rmsym_00103
#define CliGetEventList                              _nv_rmsym_00104
#define CliGetEventUserHandle                        _nv_rmsym_00105
#define CliGetMemoryInfo                             _nv_rmsym_00106
#define CliGetMemoryList                             _nv_rmsym_00107
#define CliGetPhysicalDevice                         _nv_rmsym_00108
#define CliIsUniqueHandle                            _nv_rmsym_00109
#define CliSetClientContext                          _nv_rmsym_00110
#define CliSetClientInstance                         _nv_rmsym_00111
#define CliSetDeviceContext                          _nv_rmsym_00112
#define ClientInstance                               _nv_rmsym_00113
#define Common_ClassDescriptors                      _nv_rmsym_00114
#define Commonclass04DGetImageOffsetNotify           _nv_rmsym_00115
#define Commonclass04DGetVbiOffsetNotify             _nv_rmsym_00116
#define Commonclass04DNotify                         _nv_rmsym_00117
#define Commonclass04DSetContextDmaImage             _nv_rmsym_00118
#define Commonclass04DSetContextDmaNotifies          _nv_rmsym_00119
#define Commonclass04DSetContextDmaVbi               _nv_rmsym_00120
#define Commonclass04DSetImage                       _nv_rmsym_00121
#define Commonclass04DSetImageConfig                 _nv_rmsym_00122
#define Commonclass04DSetImageStartLine              _nv_rmsym_00123
#define Commonclass04DSetVbi                         _nv_rmsym_00124
#define Commonclass04DStopTransferImage              _nv_rmsym_00125
#define Commonclass04DStopTransferVbi                _nv_rmsym_00126
#define Commonclass04ENotify                         _nv_rmsym_00127
#define Commonclass04EReadData                       _nv_rmsym_00128
#define Commonclass04ESetContextDmaData              _nv_rmsym_00129
#define Commonclass04ESetContextDmaImage             _nv_rmsym_00130
#define Commonclass04ESetContextDmaNotifies          _nv_rmsym_00131
#define Commonclass04EStopTransfer                   _nv_rmsym_00132
#define Commonclass04EWriteImage                     _nv_rmsym_00133
#define Commonclass04FNotify                         _nv_rmsym_00134
#define Commonclass04FRead                           _nv_rmsym_00135
#define Commonclass04FSetContextDmaNotifies          _nv_rmsym_00136
#define Commonclass04FSetInterruptNotify             _nv_rmsym_00137
#define Commonclass04FStopTransfer                   _nv_rmsym_00138
#define Commonclass04FWrite                          _nv_rmsym_00139
#define Commonclass63GetOffsetNotify                 _nv_rmsym_00140
#define Commonclass63ImageScan                       _nv_rmsym_00141
#define Commonclass63SetImageCtxDma                  _nv_rmsym_00142
#define Commonclass63SetNotify                       _nv_rmsym_00143
#define Commonclass63SetNotifyCtxDma                 _nv_rmsym_00144
#define Commonclass63SetVideoOutput                  _nv_rmsym_00145
#define Commonclass63StopTransfer                    _nv_rmsym_00146
#define Commonclass64SetDeltaDuDx                    _nv_rmsym_00147
#define Commonclass64SetDeltaDvDy                    _nv_rmsym_00148
#define Commonclass64SetNotify                       _nv_rmsym_00149
#define Commonclass64SetNotifyCtxDma                 _nv_rmsym_00150
#define Commonclass64SetPoint                        _nv_rmsym_00151
#define Commonclass64SetVideoInput                   _nv_rmsym_00152
#define Commonclass64SetVideoOutput                  _nv_rmsym_00153
#define Commonclass65SetColorFormat                  _nv_rmsym_00154
#define Commonclass65SetColorKey                     _nv_rmsym_00155
#define Commonclass65SetNotify                       _nv_rmsym_00156
#define Commonclass65SetNotifyCtxDma                 _nv_rmsym_00157
#define Commonclass65SetPoint                        _nv_rmsym_00158
#define Commonclass65SetSize                         _nv_rmsym_00159
#define Commonclass65SetVideoInput                   _nv_rmsym_00160
#define Commonclass65SetVideoOutput                  _nv_rmsym_00161
#define CompatColors                                 _nv_rmsym_00162
#define DevinitCrtcToPriv                            _nv_rmsym_00163
#define DevinitExtractDataFromBios                   _nv_rmsym_00164
#define DevinitFetchByte                             _nv_rmsym_00165
#define DevinitFetchDword                            _nv_rmsym_00166
#define DevinitFetchWord                             _nv_rmsym_00167
#define DevinitGetInitTableInfo                      _nv_rmsym_00168
#define DevinitInitDataToCode                        _nv_rmsym_00169
#define DevinitInitializeDevice                      _nv_rmsym_00170
#define EDIDCopy                                     _nv_rmsym_00171
#define EDIDGetMaxRefreshRate                        _nv_rmsym_00172
#define EDIDIsMonitorGTF                             _nv_rmsym_00173
#define EDIDIsValid                                  _nv_rmsym_00174
#define EDIDRead                                     _nv_rmsym_00175
#define EDIDV1Copy                                   _nv_rmsym_00176
#define EDIDV1GetMaxRefreshRate                      _nv_rmsym_00177
#define EDIDV1IsMonitorGTF                           _nv_rmsym_00178
#define EDIDV2Copy                                   _nv_rmsym_00179
#define EDIDV2GetMaxRefreshRate                      _nv_rmsym_00180
#define EDIDV2IsMonitorGTF                           _nv_rmsym_00181
#define EngineInfos                                  _nv_rmsym_00182
#define FindRegistryKeyDisplayPosition               _nv_rmsym_00183
#define FixupColors                                  _nv_rmsym_00184
#define FlushWB                                      _nv_rmsym_00185
#define Fog_EyeDist_Passthr_Mode                     _nv_rmsym_00186
#define Fog_Passthr_Mode                             _nv_rmsym_00187
#define GetTimingFromCode                            _nv_rmsym_00188
#define GrayColors                                   _nv_rmsym_00189
#define HalRmFuncs_000                               _nv_rmsym_00190
#define ImageNotify                                  _nv_rmsym_00191

#define InitNV                                       _nv_rmsym_00193
#define IntenseTable                                 _nv_rmsym_00194
#define IsMonitorDDC                                 _nv_rmsym_00195
#define IsNV0A_NV04                                  _nv_rmsym_00196
#define IsNV10MaskRevA02orBetter_NV10                _nv_rmsym_00197
#define IsNV10MaskRevA03orBetter_NV10                _nv_rmsym_00198
#define IsNV10_NV10                                  _nv_rmsym_00199
#define IsNV15_NV10                                  _nv_rmsym_00200
#define IsNV15orBetter_NV10                          _nv_rmsym_00201
#define IsNV4_NV04                                   _nv_rmsym_00202
#define IsNV5_NV04                                   _nv_rmsym_00203
#define IsNV5orBetter_NV04                           _nv_rmsym_00204
#define IsNVXX                                       _nv_rmsym_00205
#define MTRR_Types                                   _nv_rmsym_00206
#define NTSCstr640                                   _nv_rmsym_00207
#define NTSCstr800                                   _nv_rmsym_00208
#define NV04_ClassDescriptors                        _nv_rmsym_00209
#define NV04_EngineDescriptors                       _nv_rmsym_00210
#define NV04_HalFuncs_000                            _nv_rmsym_00211
#define NV04_MultiChipFuncs                          _nv_rmsym_00212
#define NV04_NumClassDescs                           _nv_rmsym_00213
#define NV04_NumEngineDescs                          _nv_rmsym_00214
#define NV04_NvChipGetRasterPosition                 _nv_rmsym_00216
#define NV04_RmUpdateArbitrationSettings             _nv_rmsym_00217
#define NV04_class04DCreate                          _nv_rmsym_00218
#define NV04_class04DDestroy                         _nv_rmsym_00219
#define NV04_class04DGetImageOffsetNotify            _nv_rmsym_00220
#define NV04_class04DGetVbiOffsetNotify              _nv_rmsym_00221
#define NV04_class04DNotify                          _nv_rmsym_00222
#define NV04_class04DService                         _nv_rmsym_00223
#define NV04_class04DSetContextDmaImage              _nv_rmsym_00224
#define NV04_class04DSetContextDmaNotifies           _nv_rmsym_00225
#define NV04_class04DSetContextDmaVbi                _nv_rmsym_00226
#define NV04_class04DSetImage                        _nv_rmsym_00227
#define NV04_class04DSetImageConfig                  _nv_rmsym_00228
#define NV04_class04DSetImageStartLine               _nv_rmsym_00229
#define NV04_class04DSetVbi                          _nv_rmsym_00230
#define NV04_class04DStopTransferImage               _nv_rmsym_00231
#define NV04_class04DStopTransferVbi                 _nv_rmsym_00232
#define NV04_class04EAudioNotify                     _nv_rmsym_00233
#define NV04_class04ECreate                          _nv_rmsym_00234
#define NV04_class04EDestroy                         _nv_rmsym_00235
#define NV04_class04EImageNotify                     _nv_rmsym_00236
#define NV04_class04ENotify                          _nv_rmsym_00237
#define NV04_class04EReadData                        _nv_rmsym_00238
#define NV04_class04ESetContextDmaData               _nv_rmsym_00239
#define NV04_class04ESetContextDmaImage              _nv_rmsym_00240
#define NV04_class04ESetContextDmaNotifies           _nv_rmsym_00241
#define NV04_class04EStopTransfer                    _nv_rmsym_00242
#define NV04_class04EVideoNotify                     _nv_rmsym_00243
#define NV04_class04EWriteImage                      _nv_rmsym_00244
#define NV04_class04FCreate                          _nv_rmsym_00245
#define NV04_class04FDestroy                         _nv_rmsym_00246
#define NV04_class04FNotify                          _nv_rmsym_00247
#define NV04_class04FRead                            _nv_rmsym_00248
#define NV04_class04FSetContextDmaNotifies           _nv_rmsym_00249
#define NV04_class04FSetInterruptNotify              _nv_rmsym_00250
#define NV04_class04FStopTransfer                    _nv_rmsym_00251
#define NV04_class04FWrite                           _nv_rmsym_00252
#define NV04_class04F_VMI                            _nv_rmsym_00253
#define NV04_dacAGPClockTable                        _nv_rmsym_00254
#define NV04_dacProgramCursorImage                   _nv_rmsym_00255
#define NV04_dacProgramMClk                          _nv_rmsym_00256
#define NV04_dacProgramNVClk                         _nv_rmsym_00257
#define NV04_dacValidateArbitrationSettings          _nv_rmsym_00258
#define NV04_initMp                                  _nv_rmsym_00259
#define NV04_mpPriorityService                       _nv_rmsym_00260
#define NV04_mpService                               _nv_rmsym_00261
#define NV10_ClassDescriptors                        _nv_rmsym_00262
#define NV10_EngineDescriptors                       _nv_rmsym_00263
#define NV10_HalFuncs_000                            _nv_rmsym_00264
#define NV10_MultiChipFuncs                          _nv_rmsym_00265
#define NV10_NumClassDescs                           _nv_rmsym_00266
#define NV10_NumEngineDescs                          _nv_rmsym_00267
#define NV10_NvChipGetRasterPosition                 _nv_rmsym_00269
#define NV10_RmUpdateArbitrationSettings             _nv_rmsym_00270
#define NV10_class04DCreate                          _nv_rmsym_00271
#define NV10_class04DDestroy                         _nv_rmsym_00272
#define NV10_class04DGetImageOffsetNotify            _nv_rmsym_00273
#define NV10_class04DGetVbiOffsetNotify              _nv_rmsym_00274
#define NV10_class04DNotify                          _nv_rmsym_00275
#define NV10_class04DService                         _nv_rmsym_00276
#define NV10_class04DSetContextDmaImage              _nv_rmsym_00277
#define NV10_class04DSetContextDmaNotifies           _nv_rmsym_00278
#define NV10_class04DSetContextDmaVbi                _nv_rmsym_00279
#define NV10_class04DSetImage                        _nv_rmsym_00280
#define NV10_class04DSetImageConfig                  _nv_rmsym_00281
#define NV10_class04DSetImageStartLine               _nv_rmsym_00282
#define NV10_class04DSetVbi                          _nv_rmsym_00283
#define NV10_class04DStopTransferImage               _nv_rmsym_00284
#define NV10_class04DStopTransferVbi                 _nv_rmsym_00285
#define NV10_class04ECreate                          _nv_rmsym_00286
#define NV10_class04EDestroy                         _nv_rmsym_00287
#define NV10_class04EImageNotify                     _nv_rmsym_00288
#define NV10_class04ENotify                          _nv_rmsym_00289
#define NV10_class04EReadData                        _nv_rmsym_00290
#define NV10_class04ESetContextDmaData               _nv_rmsym_00291
#define NV10_class04ESetContextDmaImage              _nv_rmsym_00292
#define NV10_class04ESetContextDmaNotifies           _nv_rmsym_00293
#define NV10_class04EStopTransfer                    _nv_rmsym_00294
#define NV10_class04EVideoNotify                     _nv_rmsym_00295
#define NV10_class04EWriteImage                      _nv_rmsym_00296
#define NV10_class04FCreate                          _nv_rmsym_00297
#define NV10_class04FDestroy                         _nv_rmsym_00298
#define NV10_class04FNotify                          _nv_rmsym_00299
#define NV10_class04FRead                            _nv_rmsym_00300
#define NV10_class04FSetContextDmaNotifies           _nv_rmsym_00301
#define NV10_class04FSetInterruptNotify              _nv_rmsym_00302
#define NV10_class04FStopTransfer                    _nv_rmsym_00303
#define NV10_class04FWrite                           _nv_rmsym_00304
#define NV10_class04F_VMI                            _nv_rmsym_00305
#define NV10_dacAGPClockTable                        _nv_rmsym_00306
#define NV10_dacCalculateArbitration                 _nv_rmsym_00307
#define NV10_dacCalculateVideoCaps                   _nv_rmsym_00308
#define NV10_dacProgramCursorImage                   _nv_rmsym_00309
#define NV10_dacProgramMClk                          _nv_rmsym_00310
#define NV10_dacProgramNVClk                         _nv_rmsym_00311
#define NV10_dacValidateArbitrationSettings          _nv_rmsym_00312
#define NV10_initMp                                  _nv_rmsym_00313
#define NV10_mpPriorityService                       _nv_rmsym_00314
#define NV10_mpService                               _nv_rmsym_00315
#define NVExtractBiosImage                           _nv_rmsym_00316
#define NotifyImageBuffer                            _nv_rmsym_00317

#define NotifyVbiBuffer                              _nv_rmsym_00319

#define Nv01AllocChannelPio                          _nv_rmsym_00321
#define Nv01AllocContextDma                          _nv_rmsym_00322
#define Nv01AllocDevice                              _nv_rmsym_00323
#define Nv01AllocEvent                               _nv_rmsym_00324
#define Nv01AllocMemory                              _nv_rmsym_00325
#define Nv01AllocObject                              _nv_rmsym_00326
#define Nv01AllocRoot                                _nv_rmsym_00327
#define Nv01ConfigGet                                _nv_rmsym_00328
#define Nv01ConfigSet                                _nv_rmsym_00329
#define Nv01ConfigUpdate                             _nv_rmsym_00330
#define Nv01ConfigVersion                            _nv_rmsym_00331
#define Nv01DebugControl                             _nv_rmsym_00332
#define Nv01Free                                     _nv_rmsym_00333
#define Nv01Interrupt                                _nv_rmsym_00334
#define Nv03AllocChannelDma                          _nv_rmsym_00335
#define Nv03ArchHeap                                 _nv_rmsym_00336
#define Nv03DmaFlowControl                           _nv_rmsym_00337
#define Nv04ConfigGetEx                              _nv_rmsym_00338
#define Nv04ConfigSetEx                              _nv_rmsym_00339
#define Nv04I2CAccess                                _nv_rmsym_00340
#define Nv04MemLatchMemConfig                        _nv_rmsym_00341
#define Nv04MemResizeMemory                          _nv_rmsym_00342
#define Nv04MemResizeSdram                           _nv_rmsym_00343
#define Nv04MemResizeSgram                           _nv_rmsym_00344
#define Nv04VideoLUTCursorDACMethods                 _nv_rmsym_00345
#define Nv04VideoOverlayMethods                      _nv_rmsym_00346
#define Nv04_bmp_GenInitTbl                          _nv_rmsym_00347
#define Nv05MemLatchMemConfig                        _nv_rmsym_00348
#define Nv05MemResizeMemory                          _nv_rmsym_00349
#define Nv05VideoLUTCursorDACMethods                 _nv_rmsym_00350
#define Nv05_bmp_GenInitTbl                          _nv_rmsym_00351
#define Nv05_bmp_MemInitTbl                          _nv_rmsym_00352
#define Nv05_bmp_ScrambleTbl                         _nv_rmsym_00353
#define Nv10CelsiusPrimitiveHalMethods               _nv_rmsym_00354
#define Nv10CelsiusPrimitiveMethods                  _nv_rmsym_00355
#define Nv10ContextSurfaces2DMethods                 _nv_rmsym_00356
#define Nv10ContextSurfaces3DMethods                 _nv_rmsym_00357
#define Nv10DX5TexturedTriangleMethods               _nv_rmsym_00358
#define Nv10DX6MultiTextureTriangleMethods           _nv_rmsym_00359
#define Nv10DvdSubpictureMethods                     _nv_rmsym_00360
#define Nv10ImageFromCpuMethods                      _nv_rmsym_00361
#define Nv10MemChipPreInit                           _nv_rmsym_00362
#define Nv10MemComputeMemory                         _nv_rmsym_00363
#define Nv10MemConfigureClocks                       _nv_rmsym_00364
#define Nv10MemConfigureMemory                       _nv_rmsym_00365
#define Nv10ScaledImageFromMemoryMethods             _nv_rmsym_00366
#define Nv10TextureFromCpuMethods                    _nv_rmsym_00367
#define Nv10VideoLUTCursorDACMethods                 _nv_rmsym_00368
#define Nv10VideoOverlayMethods                      _nv_rmsym_00369
#define Nv10_DDR_Sequence_Table                      _nv_rmsym_00370
#define Nv10_SDR_Sequence_Table                      _nv_rmsym_00371
#define Nv10_bmp_GenInitTbl                          _nv_rmsym_00372
#define Nv10_bmp_MemInitTbl                          _nv_rmsym_00373
#define Nv15CelsiusPrimitiveHalMethods               _nv_rmsym_00374
#define Nv15CelsiusPrimitiveMethods                  _nv_rmsym_00375
#define Nv15ImageBlitMethods                         _nv_rmsym_00376
#define Nv15VideoLUTCursorDACMethods                 _nv_rmsym_00377
#define Nv1BetaSolidMethods                          _nv_rmsym_00378
#define Nv1ExternalParallelBusMethods                _nv_rmsym_00379
#define Nv1ImageBlitMethods                          _nv_rmsym_00380
#define Nv1ImageFromCpuMethods                       _nv_rmsym_00381
#define Nv1ImagePatternMethods                       _nv_rmsym_00382
#define Nv1ImageRectangleBlackMethods                _nv_rmsym_00383
#define Nv1ImageSolidMethods                         _nv_rmsym_00384
#define Nv1RenderSolidLinMethods                     _nv_rmsym_00385
#define Nv1RenderSolidRectangleMethods               _nv_rmsym_00386
#define Nv1RenderSolidTriangleMethods                _nv_rmsym_00387
#define Nv1TimerMethods                              _nv_rmsym_00388
#define Nv3ContextRopMethods                         _nv_rmsym_00389
#define Nv3ContextSurface0Methods                    _nv_rmsym_00390
#define Nv3ContextSurface1Methods                    _nv_rmsym_00391
#define Nv3ContextSurface2Methods                    _nv_rmsym_00392
#define Nv3ContextSurface3Methods                    _nv_rmsym_00393
#define Nv3DX3TexturedTriangleMethods                _nv_rmsym_00394
#define Nv3ExternalMonitorBusMethods                 _nv_rmsym_00395
#define Nv3ExternalVideoDecoderMethods               _nv_rmsym_00396
#define Nv3ExternalVideoDecompressorMethods          _nv_rmsym_00397
#define Nv3GDIRectangleTextMethods                   _nv_rmsym_00398
#define Nv3MemoryToMemoryFormatMethods               _nv_rmsym_00399
#define Nv3ScaledImageFromMemoryMethods              _nv_rmsym_00400
#define Nv3StretchedImageFromCPUMethods              _nv_rmsym_00401
#define Nv4ContextBetaMethods                        _nv_rmsym_00402
#define Nv4ContextColorKeyMethods                    _nv_rmsym_00403
#define Nv4ContextPatternMethods                     _nv_rmsym_00404
#define Nv4ContextSurfaceSwizzledMethods             _nv_rmsym_00405
#define Nv4ContextSurfaces2DMethods                  _nv_rmsym_00406
#define Nv4ContextSurfacesArgbZsHalMethods           _nv_rmsym_00407
#define Nv4ContextSurfacesArgbZsMethods              _nv_rmsym_00408
#define Nv4DX5TexturedTriangleMethods                _nv_rmsym_00409
#define Nv4DX6MultiTextureTriangleMethods            _nv_rmsym_00410
#define Nv4DvdSubpictureMethods                      _nv_rmsym_00411
#define Nv4ExternalSerialBusMethods                  _nv_rmsym_00412
#define Nv4GDIRectangleTextMethods                   _nv_rmsym_00413
#define Nv4ImageBlitMethods                          _nv_rmsym_00414
#define Nv4ImageFromCpuMethods                       _nv_rmsym_00415
#define Nv4IndexedImageFromCpuHalMethods             _nv_rmsym_00416
#define Nv4IndexedImageFromCpuMethods                _nv_rmsym_00417
#define Nv4RenderSolidLinMethods                     _nv_rmsym_00418
#define Nv4RenderSolidRectangleMethods               _nv_rmsym_00419
#define Nv4RenderSolidTriangleMethods                _nv_rmsym_00420
#define Nv4ScaledImageFromMemoryMethods              _nv_rmsym_00421
#define Nv4StretchedImageFromCpuMethods              _nv_rmsym_00422
#define Nv5ImageFromCpuMethods                       _nv_rmsym_00423
#define Nv5IndexedImageFromCpuMethods                _nv_rmsym_00424
#define Nv5ScaledImageFromMemoryMethods              _nv_rmsym_00425
#define Nv5StretchedImageFromCpuMethods              _nv_rmsym_00426
#define NvChipTetrisTileTable                        _nv_rmsym_00427
#define NvClassMethods                               _nv_rmsym_00428
#define NvControlClass                               _nv_rmsym_00429
#define NvControlMethods                             _nv_rmsym_00430
#define NvDBPtr_Table                                _nv_rmsym_00431
#define NvDmaFromMemoryMethods                       _nv_rmsym_00432
#define NvDmaInMemoryMethods                         _nv_rmsym_00433
#define NvDmaToMemoryMethods                         _nv_rmsym_00434
#define NvPatchcordMethods                           _nv_rmsym_00435
#define NvRing0Callback                              _nv_rmsym_00436
#define NvVideoColorKeyMethods                       _nv_rmsym_00437
#define NvVideoColormapMethods                       _nv_rmsym_00438
#define NvVideoFromMemoryMethods                     _nv_rmsym_00439
#define NvVideoScalerMethods                         _nv_rmsym_00440
#define NvVideoSinkMethods                           _nv_rmsym_00441
#define NvWatchInstanceMemFuncs                      _nv_rmsym_00442
#define NvWatch_DumpBtreeContents                    _nv_rmsym_00443
#define NvWatch_DumpCRTCRegs                         _nv_rmsym_00444
#define NvWatch_Dump_ClientInfo                      _nv_rmsym_00445
#define NvWatch_Dump_HT_Object_From_Channel          _nv_rmsym_00446
#define NvWatch_Dump_HT_Object_From_Class            _nv_rmsym_00447
#define NvWatch_Dump_HT_Object_From_Engine           _nv_rmsym_00448
#define NvWatch_Dump_HT_Object_From_Handle           _nv_rmsym_00449
#define NvWatch_Dump_HT_Object_From_Instance         _nv_rmsym_00450
#define NvWatch_Dump_HT_Objects                      _nv_rmsym_00451
#define NvWatch_Dump_InstanceFifoContext             _nv_rmsym_00452
#define NvWatch_Dump_NvInfo                          _nv_rmsym_00453
#define NvWatch_EditCRTCReg                          _nv_rmsym_00454
#define NvWatch_FrontEnd                             _nv_rmsym_00455
#define NvWatch_GetObjectFromInst                    _nv_rmsym_00456
#define NvWatch_NV04_DumpFifoContents                _nv_rmsym_00457
#define NvWatch_NV04_DumpUserDmaBuffersAtGet         _nv_rmsym_00458
#define NvWatch_NV04_Dump_Fifo                       _nv_rmsym_00459
#define NvWatch_NV04_Dump_Graphics                   _nv_rmsym_00460
#define NvWatch_NV04_Dump_Master                     _nv_rmsym_00461
#define NvWatch_NV04_Dump_SubChannelContext          _nv_rmsym_00462
#define NvWatch_NV04_Dump_Video                      _nv_rmsym_00463
#define NvWatch_NV04_FillDiagStruct                  _nv_rmsym_00464
#define NvWatch_NV04_GetHashSize                     _nv_rmsym_00465
#define NvWatch_NV10_DumpFifoContents                _nv_rmsym_00466
#define NvWatch_NV10_DumpUserDmaBuffersAtGet         _nv_rmsym_00467
#define NvWatch_NV10_Dump_Fifo                       _nv_rmsym_00468
#define NvWatch_NV10_Dump_Graphics                   _nv_rmsym_00469
#define NvWatch_NV10_Dump_Master                     _nv_rmsym_00470
#define NvWatch_NV10_Dump_Video                      _nv_rmsym_00471
#define NvWatch_NV10_FillDiagStruct                  _nv_rmsym_00472
#define NvWatch_NV10_GetHashSize                     _nv_rmsym_00473
#define NvWatch_ObjectStrings                        _nv_rmsym_00474
#define NvWatch_Process_Hash_Entry                   _nv_rmsym_00475
#define NvWatch_QuickDiag                            _nv_rmsym_00476
#define NvWatch_QuickDiag_fifo                       _nv_rmsym_00477
#define NvWatch_QuickDiag_master                     _nv_rmsym_00478
#define NvWatch_ascii2hex                            _nv_rmsym_00479
#define NvWatch_btreeDumpBranch                      _nv_rmsym_00480
#define NvWatch_dumpraw                              _nv_rmsym_00481
#define NvWatch_engine_dump                          _nv_rmsym_00482
#define NvWatch_num_objects                          _nv_rmsym_00483
#define NvWatch_nvedit                               _nv_rmsym_00484
#define NvWatch_nvread                               _nv_rmsym_00485
#define NvWatch_spaceit                              _nv_rmsym_00486
#define PALMstr640                                   _nv_rmsym_00487
#define PALMstr800                                   _nv_rmsym_00488
#define PALstr640                                    _nv_rmsym_00489
#define PALstr800                                    _nv_rmsym_00490
#define ParseEDID11                                  _nv_rmsym_00491
#define ParseEDID12                                  _nv_rmsym_00492
#define ParseEDID13                                  _nv_rmsym_00493
#define ParseEDID2                                   _nv_rmsym_00494

#define ReadCRTCLock                                 _nv_rmsym_00496
#define ReadSCL                                      _nv_rmsym_00497
#define ReadSDA                                      _nv_rmsym_00498
#define ReadVDIF                                     _nv_rmsym_00499
#define ResetSCLLine                                 _nv_rmsym_00500
#define ResetSDALine                                 _nv_rmsym_00501
#define RmAllocChannel                               _nv_rmsym_00502
#define RmAllocChannelDma                            _nv_rmsym_00503
#define RmAllocChannelPio                            _nv_rmsym_00504
#define RmAllocClient                                _nv_rmsym_00505
#define RmAllocContextDma                            _nv_rmsym_00506
#define RmAllocDevice                                _nv_rmsym_00507
#define RmAllocDeviceInstance                        _nv_rmsym_00508
#define RmAllocEvent                                 _nv_rmsym_00509
#define RmAllocFrameBufferMapping                    _nv_rmsym_00510
#define RmAllocInstanceMemory                        _nv_rmsym_00511
#define RmAllocMemory                                _nv_rmsym_00512
#define RmAllocObject                                _nv_rmsym_00513
#define RmAllocSystemMemory                          _nv_rmsym_00514
#define RmArchHeap                                   _nv_rmsym_00515
#define RmArchStatus                                 _nv_rmsym_00516
#define RmConfigGet                                  _nv_rmsym_00517
#define RmConfigGetEx                                _nv_rmsym_00518
#define RmConfigGetExKernel                          _nv_rmsym_00519
#define RmConfigGetKernel                            _nv_rmsym_00520
#define RmConfigSet                                  _nv_rmsym_00521
#define RmConfigSetEx                                _nv_rmsym_00522
#define RmConfigUpdate                               _nv_rmsym_00523
#define RmConfigVersion                              _nv_rmsym_00524
#define RmDisableInterrupts                          _nv_rmsym_00525
#define RmEnableInterrupts                           _nv_rmsym_00526
#define RmFailureTriggered                           _nv_rmsym_00527
#define RmFailuresDisable                            _nv_rmsym_00528
#define RmFailuresEnable                             _nv_rmsym_00529
#define RmFree                                       _nv_rmsym_00530
#define RmFreeChannel                                _nv_rmsym_00531
#define RmFreeClient                                 _nv_rmsym_00532
#define RmFreeContextDma                             _nv_rmsym_00533
#define RmFreeDevice                                 _nv_rmsym_00534
#define RmFreeEvent                                  _nv_rmsym_00535
#define RmFreeFrameBuffer                            _nv_rmsym_00536
#define RmFreeInstanceMemory                         _nv_rmsym_00537
#define RmFreeMemory                                 _nv_rmsym_00538
#define RmFreeObject                                 _nv_rmsym_00539
#define RmFreeSystemMemory                           _nv_rmsym_00540
#define RmI2CAccess                                  _nv_rmsym_00541

#define RmInitCpuInfo                                _nv_rmsym_00543
#define RmInitNvDevice                               _nv_rmsym_00544
#define RmInitNvMapping                              _nv_rmsym_00545
#define RmInterrupt                                  _nv_rmsym_00546
#define RmInterruptPending                           _nv_rmsym_00547
#define RmLoadState                                  _nv_rmsym_00548
#define RmPostNvDevice                               _nv_rmsym_00549
#define RmSetMode                                    _nv_rmsym_00550

#define RmUnloadState                                _nv_rmsym_00552
#define SavedBiosImageArray                          _nv_rmsym_00553
#define ScaleOffset_Passthr_Mode                     _nv_rmsym_00554
#define SetRetraceH                                  _nv_rmsym_00555
#define SetRetraceV                                  _nv_rmsym_00556
#define SetSCLLine                                   _nv_rmsym_00557
#define SetSDALine                                   _nv_rmsym_00558
#define StopDDC1                                     _nv_rmsym_00559
#define VBlank                                       _nv_rmsym_00560
#define VBlankAddCallback                            _nv_rmsym_00561
#define VBlankDeleteCallback                         _nv_rmsym_00562
#define VGATable                                     _nv_rmsym_00563
#define VPFilterCos                                  _nv_rmsym_00564
#define VT_BT_NTSC                                   _nv_rmsym_00565
#define VT_BT_PAL                                    _nv_rmsym_00566
#define VbiNotify                                    _nv_rmsym_00567


#define Vertex_Passthr_Mode                          _nv_rmsym_00570
#define WaitHighSCLLine                              _nv_rmsym_00571
#define WaitHighSDALine                              _nv_rmsym_00572
#define _nvHalClass053SetClipHorizontal              _nv_rmsym_00573
#define _nvHalClass053SetClipVertical                _nv_rmsym_00574
#define _nvHalClass056GetState                       _nv_rmsym_00575
#define _nvHalClass056SetMaterialEmission            _nv_rmsym_00576
#define _nvHalClass060SetColorConversion             _nv_rmsym_00577
#define _nvHalClass096GetState                       _nv_rmsym_00578
#define _nvHalGrClassSoftwareMethod_NV04             _nv_rmsym_00579
#define _nvHalGrClassSoftwareMethod_NV10             _nv_rmsym_00580
#define _nvHalGrInitCelsius_NV10                     _nv_rmsym_00581
#define _nvHalGrInitDx5_NV10                         _nv_rmsym_00582
#define _nvHalGrInitInstance_NV04                    _nv_rmsym_00583
#define _nvHalGrInitObjectContext_NV10               _nv_rmsym_00584
#define _nvHalGrSetContextColorKeyWar_NV04           _nv_rmsym_00585
#define allocHalEnginePvts                           _nv_rmsym_00586

#define blockFree                                    _nv_rmsym_00588
#define btreeBalance                                 _nv_rmsym_00589
#define btreeBalanceBranch                           _nv_rmsym_00590
#define btreeBranchValidate                          _nv_rmsym_00591
#define btreeDelete                                  _nv_rmsym_00592
#define btreeDumpBranch                              _nv_rmsym_00593
#define btreeDumpTree                                _nv_rmsym_00594
#define btreeEnumNext                                _nv_rmsym_00595
#define btreeEnumStart                               _nv_rmsym_00596
#define btreeInsert                                  _nv_rmsym_00597
#define btreeInsertBranch                            _nv_rmsym_00598
#define btreeNodeValidate                            _nv_rmsym_00599
#define btreeSearch                                  _nv_rmsym_00600
#define btreeTreeValidate                            _nv_rmsym_00601
#define class01CSetContextBeta1                      _nv_rmsym_00602
#define class01CSetContextClip                       _nv_rmsym_00603
#define class01CSetContextPattern                    _nv_rmsym_00604
#define class01CSetContextRop                        _nv_rmsym_00605
#define class01CSetContextSurface                    _nv_rmsym_00606
#define class01CSetOperation                         _nv_rmsym_00607
#define class01CValidate                             _nv_rmsym_00608
#define class01DSetContextBeta1                      _nv_rmsym_00609
#define class01DSetContextClip                       _nv_rmsym_00610
#define class01DSetContextPattern                    _nv_rmsym_00611
#define class01DSetContextRop                        _nv_rmsym_00612
#define class01DSetContextSurface                    _nv_rmsym_00613
#define class01DSetOperation                         _nv_rmsym_00614
#define class01DValidate                             _nv_rmsym_00615
#define class01ESetContextBeta1                      _nv_rmsym_00616
#define class01ESetContextClip                       _nv_rmsym_00617
#define class01ESetContextPattern                    _nv_rmsym_00618
#define class01ESetContextRop                        _nv_rmsym_00619
#define class01ESetContextSurface                    _nv_rmsym_00620
#define class01ESetOperation                         _nv_rmsym_00621
#define class01EValidate                             _nv_rmsym_00622
#define class01FSetContextBeta1                      _nv_rmsym_00623
#define class01FSetContextClip                       _nv_rmsym_00624
#define class01FSetContextColorKey                   _nv_rmsym_00625
#define class01FSetContextPattern                    _nv_rmsym_00626
#define class01FSetContextRop                        _nv_rmsym_00627
#define class01FSetContextSurface                    _nv_rmsym_00628
#define class01FSetContextSurfaceSource              _nv_rmsym_00629
#define class01FSetOperation                         _nv_rmsym_00630
#define class01FValidate                             _nv_rmsym_00631
#define class021SetContextBeta1                      _nv_rmsym_00632
#define class021SetContextClip                       _nv_rmsym_00633
#define class021SetContextColorKey                   _nv_rmsym_00634
#define class021SetContextPattern                    _nv_rmsym_00635
#define class021SetContextRop                        _nv_rmsym_00636
#define class021SetContextSurface                    _nv_rmsym_00637
#define class021SetOperation                         _nv_rmsym_00638
#define class021Validate                             _nv_rmsym_00639
#define class036SetContextBeta1                      _nv_rmsym_00640
#define class036SetContextColorKey                   _nv_rmsym_00641
#define class036SetContextPattern                    _nv_rmsym_00642
#define class036SetContextRop                        _nv_rmsym_00643
#define class036SetContextSurface                    _nv_rmsym_00644
#define class036SetOperation                         _nv_rmsym_00645
#define class036Validate                             _nv_rmsym_00646
#define class037SetContextBeta1                      _nv_rmsym_00647
#define class037SetContextPattern                    _nv_rmsym_00648
#define class037SetContextRop                        _nv_rmsym_00649
#define class037SetContextSurface                    _nv_rmsym_00650
#define class037SetOperation                         _nv_rmsym_00651
#define class037Validate                             _nv_rmsym_00652
#define class046CursorImageNotify                    _nv_rmsym_00653
#define class046GetOffset                            _nv_rmsym_00654
#define class046ImageNotify                          _nv_rmsym_00655
#define class046ProgramLUT                           _nv_rmsym_00656
#define class046SetCursorCtxDma                      _nv_rmsym_00657
#define class046SetCursorImageValues                 _nv_rmsym_00658
#define class046SetCursorPoint                       _nv_rmsym_00659
#define class046SetDACValues                         _nv_rmsym_00660
#define class046SetImageCtxDma                       _nv_rmsym_00661
#define class046SetImageValues                       _nv_rmsym_00662
#define class046SetLUTCtxDma                         _nv_rmsym_00663
#define class046SetLUTValues                         _nv_rmsym_00664
#define class046SetNotify                            _nv_rmsym_00665
#define class046SetNotifyCtxDma                      _nv_rmsym_00666
#define class046StopCursorImage                      _nv_rmsym_00667
#define class046StopDAC                              _nv_rmsym_00668
#define class046StopImage                            _nv_rmsym_00669
#define class046StopLUT                              _nv_rmsym_00670
#define class047GetExceptionData_NV04                _nv_rmsym_00671
#define class047GetOffset                            _nv_rmsym_00672
#define class047InitXfer_NV04                        _nv_rmsym_00673
#define class047KickoffBuffer_NV04                   _nv_rmsym_00674
#define class047Method_NV04                          _nv_rmsym_00675
#define class047Method_NV10                          _nv_rmsym_00676
#define class047Service_NV04                         _nv_rmsym_00677
#define class047SetNotify                            _nv_rmsym_00678
#define class047SetNotifyCtxDma                      _nv_rmsym_00679
#define class047SetOverlayCtxDma                     _nv_rmsym_00680
#define class047SetOverlayPointOutNow                _nv_rmsym_00681
#define class047SetOverlayValues                     _nv_rmsym_00682
#define class047StartXfer_NV04                       _nv_rmsym_00683
#define class047StopOverlay                          _nv_rmsym_00684
#define class047StopOverlayNow                       _nv_rmsym_00685
#define class048SetContextClip                       _nv_rmsym_00686
#define class048SetContextSurfaceColor               _nv_rmsym_00687
#define class048SetContextSurfaceZeta                _nv_rmsym_00688
#define class048Validate                             _nv_rmsym_00689
#define class049CursorImageNotify                    _nv_rmsym_00690
#define class049GetOffset                            _nv_rmsym_00691
#define class049ImageNotify                          _nv_rmsym_00692
#define class049ProgramLUT                           _nv_rmsym_00693
#define class049SetCursorCtxDma                      _nv_rmsym_00694
#define class049SetCursorImageValues                 _nv_rmsym_00695
#define class049SetCursorPoint                       _nv_rmsym_00696
#define class049SetDACValues                         _nv_rmsym_00697
#define class049SetImageCtxDma                       _nv_rmsym_00698
#define class049SetImageValues                       _nv_rmsym_00699
#define class049SetLUTCtxDma                         _nv_rmsym_00700
#define class049SetLUTValues                         _nv_rmsym_00701
#define class049SetNotify                            _nv_rmsym_00702
#define class049SetNotifyCtxDma                      _nv_rmsym_00703
#define class049StopCursorImage                      _nv_rmsym_00704
#define class049StopDAC                              _nv_rmsym_00705
#define class049StopImage                            _nv_rmsym_00706
#define class049StopLUT                              _nv_rmsym_00707
#define class04ASetContextBeta1                      _nv_rmsym_00708
#define class04ASetContextBeta4                      _nv_rmsym_00709
#define class04ASetContextPattern                    _nv_rmsym_00710
#define class04ASetContextRop                        _nv_rmsym_00711
#define class04ASetContextSurface                    _nv_rmsym_00712
#define class04ASetOperation                         _nv_rmsym_00713
#define class04AValidate                             _nv_rmsym_00714
#define class04BSetContextBeta1                      _nv_rmsym_00715
#define class04BSetContextPattern                    _nv_rmsym_00716
#define class04BSetContextRop                        _nv_rmsym_00717
#define class04BSetContextSurface                    _nv_rmsym_00718
#define class04BSetOperation                         _nv_rmsym_00719
#define class04BValidate                             _nv_rmsym_00720
#define class04DCalculateScaleIncrement              _nv_rmsym_00721
#define class04DFindNearestScaleFactor               _nv_rmsym_00722
#define class04DProgramWeights                       _nv_rmsym_00723
#define class04DStartImage                           _nv_rmsym_00724

#define class04DStartVbi                             _nv_rmsym_00726

#define class04EStartAudRead                         _nv_rmsym_00728
#define class04EStartRead                            _nv_rmsym_00729
#define class04EStartVidRead                         _nv_rmsym_00730
#define class04EStartWrite                           _nv_rmsym_00731
#define class050Create                               _nv_rmsym_00732
#define class050Destroy                              _nv_rmsym_00733
#define class050Notify                               _nv_rmsym_00734
#define class050Read                                 _nv_rmsym_00735
#define class050SetContextDmaNotifies                _nv_rmsym_00736
#define class050SetInterruptNotify                   _nv_rmsym_00737
#define class050StopTransfer                         _nv_rmsym_00738
#define class050Write                                _nv_rmsym_00739
#define class051Create                               _nv_rmsym_00740
#define class051Destroy                              _nv_rmsym_00741
#define class051Notify                               _nv_rmsym_00742
#define class051Read                                 _nv_rmsym_00743
#define class051SetContextDmaNotifies                _nv_rmsym_00744
#define class051SetInterruptNotify                   _nv_rmsym_00745
#define class051StopTransfer                         _nv_rmsym_00746
#define class051Write                                _nv_rmsym_00747
#define class053SetClipHorizontal                    _nv_rmsym_00748
#define class053SetClipVertical                      _nv_rmsym_00749
#define class05CSetContextBeta1                      _nv_rmsym_00750
#define class05CSetContextBeta4                      _nv_rmsym_00751
#define class05CSetContextClip                       _nv_rmsym_00752
#define class05CSetContextPattern                    _nv_rmsym_00753
#define class05CSetContextRop                        _nv_rmsym_00754
#define class05CSetContextSurface                    _nv_rmsym_00755
#define class05CSetOperation                         _nv_rmsym_00756
#define class05CValidate                             _nv_rmsym_00757
#define class05DSetContextBeta1                      _nv_rmsym_00758
#define class05DSetContextBeta4                      _nv_rmsym_00759
#define class05DSetContextClip                       _nv_rmsym_00760
#define class05DSetContextPattern                    _nv_rmsym_00761
#define class05DSetContextRop                        _nv_rmsym_00762
#define class05DSetContextSurface                    _nv_rmsym_00763
#define class05DSetOperation                         _nv_rmsym_00764
#define class05DValidate                             _nv_rmsym_00765
#define class05ESetContextBeta1                      _nv_rmsym_00766
#define class05ESetContextBeta4                      _nv_rmsym_00767
#define class05ESetContextClip                       _nv_rmsym_00768
#define class05ESetContextPattern                    _nv_rmsym_00769
#define class05ESetContextRop                        _nv_rmsym_00770
#define class05ESetContextSurface                    _nv_rmsym_00771
#define class05ESetOperation                         _nv_rmsym_00772
#define class05EValidate                             _nv_rmsym_00773
#define class05FSetContextBeta1                      _nv_rmsym_00774
#define class05FSetContextBeta4                      _nv_rmsym_00775
#define class05FSetContextClip                       _nv_rmsym_00776
#define class05FSetContextColorKey                   _nv_rmsym_00777
#define class05FSetContextPattern                    _nv_rmsym_00778
#define class05FSetContextRop                        _nv_rmsym_00779
#define class05FSetContextSurfaces2d                 _nv_rmsym_00780
#define class05FSetOperation                         _nv_rmsym_00781
#define class05FValidate                             _nv_rmsym_00782
#define class060SetColorConversion                   _nv_rmsym_00783
#define class060SetContextBeta1                      _nv_rmsym_00784
#define class060SetContextBeta4                      _nv_rmsym_00785
#define class060SetContextClip                       _nv_rmsym_00786
#define class060SetContextColorKey                   _nv_rmsym_00787
#define class060SetContextPattern                    _nv_rmsym_00788
#define class060SetContextRop                        _nv_rmsym_00789
#define class060SetContextSurface                    _nv_rmsym_00790
#define class060SetOperation                         _nv_rmsym_00791
#define class060Validate                             _nv_rmsym_00792
#define class061SetContextBeta1                      _nv_rmsym_00793
#define class061SetContextBeta4                      _nv_rmsym_00794
#define class061SetContextClip                       _nv_rmsym_00795
#define class061SetContextColorKey                   _nv_rmsym_00796
#define class061SetContextPattern                    _nv_rmsym_00797
#define class061SetContextRop                        _nv_rmsym_00798
#define class061SetContextSurface                    _nv_rmsym_00799
#define class061SetOperation                         _nv_rmsym_00800
#define class061Validate                             _nv_rmsym_00801
#define class063SetColorConversion                   _nv_rmsym_00802
#define class063SetContextBeta1                      _nv_rmsym_00803
#define class063SetContextBeta4                      _nv_rmsym_00804
#define class063SetContextColorKey                   _nv_rmsym_00805
#define class063SetContextPattern                    _nv_rmsym_00806
#define class063SetContextRop                        _nv_rmsym_00807
#define class063SetContextSurface                    _nv_rmsym_00808
#define class063SetOperation                         _nv_rmsym_00809
#define class063Validate                             _nv_rmsym_00810
#define class064SetColorConversion                   _nv_rmsym_00811
#define class064SetContextBeta1                      _nv_rmsym_00812
#define class064SetContextBeta4                      _nv_rmsym_00813
#define class064SetContextClip                       _nv_rmsym_00814
#define class064SetContextColorKey                   _nv_rmsym_00815
#define class064SetContextPattern                    _nv_rmsym_00816
#define class064SetContextRop                        _nv_rmsym_00817
#define class064SetContextSurface                    _nv_rmsym_00818
#define class064SetOperation                         _nv_rmsym_00819
#define class064Validate                             _nv_rmsym_00820
#define class065SetColorConversion                   _nv_rmsym_00821
#define class065SetContextBeta1                      _nv_rmsym_00822
#define class065SetContextBeta4                      _nv_rmsym_00823
#define class065SetContextClip                       _nv_rmsym_00824
#define class065SetContextColorKey                   _nv_rmsym_00825
#define class065SetContextPattern                    _nv_rmsym_00826
#define class065SetContextRop                        _nv_rmsym_00827
#define class065SetContextSurface                    _nv_rmsym_00828
#define class065SetOperation                         _nv_rmsym_00829
#define class065Validate                             _nv_rmsym_00830
#define class066SetColorConversion                   _nv_rmsym_00831
#define class066SetContextBeta1                      _nv_rmsym_00832
#define class066SetContextBeta4                      _nv_rmsym_00833
#define class066SetContextColorKey                   _nv_rmsym_00834
#define class066SetContextPattern                    _nv_rmsym_00835
#define class066SetContextRop                        _nv_rmsym_00836
#define class066SetContextSurface                    _nv_rmsym_00837
#define class066SetOperation                         _nv_rmsym_00838
#define class066Validate                             _nv_rmsym_00839
#define class067CursorImageNotify                    _nv_rmsym_00840
#define class067GetOffset                            _nv_rmsym_00841
#define class067ImageNotify                          _nv_rmsym_00842
#define class067ProgramLUT                           _nv_rmsym_00843
#define class067SetCursorCtxDma                      _nv_rmsym_00844
#define class067SetCursorImageValues                 _nv_rmsym_00845
#define class067SetCursorPoint                       _nv_rmsym_00846
#define class067SetDACValues                         _nv_rmsym_00847
#define class067SetImageCtxDma                       _nv_rmsym_00848
#define class067SetImageValues                       _nv_rmsym_00849
#define class067SetLUTCtxDma                         _nv_rmsym_00850
#define class067SetLUTValues                         _nv_rmsym_00851
#define class067SetNotify                            _nv_rmsym_00852
#define class067SetNotifyCtxDma                      _nv_rmsym_00853
#define class067StopCursorImage                      _nv_rmsym_00854
#define class067StopDAC                              _nv_rmsym_00855
#define class067StopImage                            _nv_rmsym_00856
#define class067StopLUT                              _nv_rmsym_00857
#define class076SetContextBeta1                      _nv_rmsym_00858
#define class076SetContextBeta4                      _nv_rmsym_00859
#define class076SetContextColorKey                   _nv_rmsym_00860
#define class076SetContextPattern                    _nv_rmsym_00861
#define class076SetContextRop                        _nv_rmsym_00862
#define class076SetContextSurface                    _nv_rmsym_00863
#define class076SetOperation                         _nv_rmsym_00864
#define class076Validate                             _nv_rmsym_00865
#define class077SetContextBeta1                      _nv_rmsym_00866
#define class077SetContextBeta4                      _nv_rmsym_00867
#define class077SetContextColorKey                   _nv_rmsym_00868
#define class077SetContextPattern                    _nv_rmsym_00869
#define class077SetContextRop                        _nv_rmsym_00870
#define class077SetContextSurface                    _nv_rmsym_00871
#define class077SetOperation                         _nv_rmsym_00872
#define class077Validate                             _nv_rmsym_00873
#define class07AGetOffset                            _nv_rmsym_00874
#define class07ASetNotify                            _nv_rmsym_00875
#define class07ASetNotifyCtxDma                      _nv_rmsym_00876
#define class07ASetOverlayChrominanceNow             _nv_rmsym_00877
#define class07ASetOverlayCtxDma                     _nv_rmsym_00878
#define class07ASetOverlayLuminanceNow               _nv_rmsym_00879
#define class07ASetOverlayPointOutNow                _nv_rmsym_00880
#define class07ASetOverlayValues                     _nv_rmsym_00881
#define class07AStopOverlay                          _nv_rmsym_00882
#define class07CCursorImageNotify                    _nv_rmsym_00883
#define class07CGetOffset                            _nv_rmsym_00884
#define class07CImageNotify                          _nv_rmsym_00885
#define class07CProgramLUT                           _nv_rmsym_00886
#define class07CSetCursorCtxDma                      _nv_rmsym_00887
#define class07CSetCursorImageValues                 _nv_rmsym_00888
#define class07CSetCursorPoint                       _nv_rmsym_00889
#define class07CSetDACValues                         _nv_rmsym_00890
#define class07CSetImageCtxDma                       _nv_rmsym_00891
#define class07CSetImageValues                       _nv_rmsym_00892
#define class07CSetLUTCtxDma                         _nv_rmsym_00893
#define class07CSetLUTValues                         _nv_rmsym_00894
#define class07CSetNotify                            _nv_rmsym_00895
#define class07CSetNotifyCtxDma                      _nv_rmsym_00896
#define class07CSetOffsetRange                       _nv_rmsym_00897
#define class07CStopCursorImage                      _nv_rmsym_00898
#define class07CStopDAC                              _nv_rmsym_00899
#define class07CStopImage                            _nv_rmsym_00900
#define class07CStopLUT                              _nv_rmsym_00901
#define class07aMethod_NV10                          _nv_rmsym_00902
#define class63ColorKey_NV04                         _nv_rmsym_00903
#define class63ColorKey_NV10                         _nv_rmsym_00904
#define class63DualSurfaceDesktop_NV04               _nv_rmsym_00905
#define class63DualSurfaceDesktop_NV10               _nv_rmsym_00906
#define class63DualSurface_NV04                      _nv_rmsym_00907
#define class63DualSurface_NV10                      _nv_rmsym_00908
#define class63GetExceptionData_NV04                 _nv_rmsym_00909
#define class63GetOffsetNotify                       _nv_rmsym_00910
#define class63ImageScan                             _nv_rmsym_00911
#define class63InitXfer_NV04                         _nv_rmsym_00912
#define class63InitXfer_NV10                         _nv_rmsym_00913
#define class63KickoffBuffer_NV04                    _nv_rmsym_00914
#define class63Method_NV04                           _nv_rmsym_00915
#define class63Method_NV10                           _nv_rmsym_00916
#define class63Service_NV04                          _nv_rmsym_00917
#define class63SetImageCtxDma                        _nv_rmsym_00918
#define class63SetNotify                             _nv_rmsym_00919
#define class63SetNotifyCtxDma                       _nv_rmsym_00920
#define class63SetVideoOutput                        _nv_rmsym_00921
#define class63StartXfer_NV04                        _nv_rmsym_00922
#define class63StartXfer_NV10                        _nv_rmsym_00923
#define class63StopTransfer                          _nv_rmsym_00924
#define class63VBlank                                _nv_rmsym_00925
#define class63WaitVBlank                            _nv_rmsym_00926
#define class63XferComplete                          _nv_rmsym_00927
#define class64Method_NV04                           _nv_rmsym_00928
#define class64Method_NV10                           _nv_rmsym_00929
#define class64SetDeltaDuDx                          _nv_rmsym_00930
#define class64SetDeltaDvDy                          _nv_rmsym_00931
#define class64SetNotify                             _nv_rmsym_00932
#define class64SetNotifyCtxDma                       _nv_rmsym_00933
#define class64SetPoint                              _nv_rmsym_00934
#define class64SetVideoInput                         _nv_rmsym_00935
#define class64SetVideoOutput                        _nv_rmsym_00936
#define class65Method_NV04                           _nv_rmsym_00937
#define class65Method_NV10                           _nv_rmsym_00938
#define class65SetColorFormat                        _nv_rmsym_00939
#define class65SetColorKey                           _nv_rmsym_00940
#define class65SetNotify                             _nv_rmsym_00941
#define class65SetNotifyCtxDma                       _nv_rmsym_00942
#define class65SetPoint                              _nv_rmsym_00943
#define class65SetSize                               _nv_rmsym_00944
#define class65SetVideoInput                         _nv_rmsym_00945
#define class65SetVideoOutput                        _nv_rmsym_00946
#define classAddZombie                               _nv_rmsym_00947
#define classBuildDB                                 _nv_rmsym_00948
#define classCreate                                  _nv_rmsym_00949
#define classCreateWellKnownObjects                  _nv_rmsym_00950
#define classDeleteWellKnownObjects                  _nv_rmsym_00951
#define classDestroy                                 _nv_rmsym_00952
#define classDestroyDB                               _nv_rmsym_00953
#define classGetClass                                _nv_rmsym_00954
#define classGetInfo                                 _nv_rmsym_00955
#define classInitCommonObject                        _nv_rmsym_00956
#define classMethodsTable                            _nv_rmsym_00957
#define classSoftwareMethod                          _nv_rmsym_00958
#define clientHandle                                 _nv_rmsym_00959
#define clientInfo                                   _nv_rmsym_00960
#define clientInfoSelector                           _nv_rmsym_00961
#define clientSize                                   _nv_rmsym_00962
#define dac128Name                                   _nv_rmsym_00963
#define dac16Name                                    _nv_rmsym_00964
#define dac32Name                                    _nv_rmsym_00965
#define dac64Name                                    _nv_rmsym_00966
#define dacAdjustCRTCForFlatPanel                    _nv_rmsym_00967
#define dacAdjustCRTCForTV                           _nv_rmsym_00968
#define dacCalcMNP                                   _nv_rmsym_00969
#define dacCalcPLL                                   _nv_rmsym_00970
#define dacCalculateArbitration                      _nv_rmsym_00971
#define dacCreateObj                                 _nv_rmsym_00972
#define dacDestroyObj                                _nv_rmsym_00973
#define dacDetectTrigger                             _nv_rmsym_00974
#define dacDisableCursor                             _nv_rmsym_00975
#define dacEnableCursor                              _nv_rmsym_00976
#define dacFlatPanelConnectStatus                    _nv_rmsym_00977
#define dacGetDefaultTVPosition                      _nv_rmsym_00978
#define dacGetDisplayType                            _nv_rmsym_00979
#define dacGetFlatPanelConfig                        _nv_rmsym_00980
#define dacGetFlatPanelInfo                          _nv_rmsym_00981
#define dacGetI2CModeString                          _nv_rmsym_00982
#define dacGetMonitorDefaultPosition                 _nv_rmsym_00983
#define dacGetMonitorInfo                            _nv_rmsym_00984
#define dacGetTVAdjustTableArray                     _nv_rmsym_00985
#define dacGetTVAdjustTableEntry                     _nv_rmsym_00986
#define dacGetTVmode                                 _nv_rmsym_00987
#define dacLoadColor256DAC                           _nv_rmsym_00988
#define dacLoadColorDACTable                         _nv_rmsym_00989
#define dacLoadIdentityDAC                           _nv_rmsym_00990
#define dacLoadIndexRange                            _nv_rmsym_00991
#define dacLoadPalette                               _nv_rmsym_00992
#define dacLoadWidthDepth                            _nv_rmsym_00993
#define dacMonitorConnectStatus                      _nv_rmsym_00994
#define dacProgramBrooktree                          _nv_rmsym_00995
#define dacProgramCRTC                               _nv_rmsym_00996
#define dacProgramChrontel                           _nv_rmsym_00997
#define dacProgramCursorPosition                     _nv_rmsym_00998
#define dacProgramCustomCRTC                         _nv_rmsym_00999
#define dacProgramDefaultCRTC                        _nv_rmsym_01000
#define dacProgramLUT                                _nv_rmsym_01001
#define dacProgramScanRegion                         _nv_rmsym_01002
#define dacProgramVideoStart                         _nv_rmsym_01003
#define dacReadBIOSI2CSettings                       _nv_rmsym_01004
#define dacReadDesktopPositionFromRegistry           _nv_rmsym_01005
#define dacReadDisplayTypeFromRegistry               _nv_rmsym_01006
#define dacReadTVDesktopPositionFromRegistry         _nv_rmsym_01007
#define dacReadTVOutFromRegistry                     _nv_rmsym_01008
#define dacReadTVTypeFromRegistry                    _nv_rmsym_01009
#define dacSaveMonitorDefaultPosition                _nv_rmsym_01010
#define dacSetCursorBlink                            _nv_rmsym_01011
#define dacSetDpmLevel                               _nv_rmsym_01012
#define dacSetFan                                    _nv_rmsym_01013
#define dacSetFlatPanelMode                          _nv_rmsym_01014
#define dacSetMonitorPosition                        _nv_rmsym_01015
#define dacSetTVPosition                             _nv_rmsym_01016
#define dacSetupTVEncoder                            _nv_rmsym_01017
#define dacTVConnectStatus                           _nv_rmsym_01018
#define dacTransferFromBIOSCopy                      _nv_rmsym_01019
#define dacVBlank                                    _nv_rmsym_01020
#define dacWriteColor                                _nv_rmsym_01021
#define dacWriteColor2                               _nv_rmsym_01022
#define dacWriteDesktopPositionToRegistry            _nv_rmsym_01023
#define dacWriteDisplayTypeToRegistry                _nv_rmsym_01024
#define dacWriteTVOutToRegistry                      _nv_rmsym_01025
#define dacWriteTVTypeToRegistry                     _nv_rmsym_01026
#define dbgDumpHeap                                  _nv_rmsym_01027
#define dbgDumpMTRRs                                 _nv_rmsym_01028
#define destroyHal                                   _nv_rmsym_01029
#define disableCursor                                _nv_rmsym_01030
#define dmaAllocInstance                             _nv_rmsym_01031
#define dmaAllocate                                  _nv_rmsym_01032
#define dmaBindToChannel                             _nv_rmsym_01033
#define dmaContextInstanceToObject                   _nv_rmsym_01034
#define dmaCreate                                    _nv_rmsym_01035
#define dmaDeallocate                                _nv_rmsym_01036
#define dmaDelete                                    _nv_rmsym_01037
#define dmaFindContext                               _nv_rmsym_01038
#define dmaFreeInstance                              _nv_rmsym_01039
#define dmaGetMappedAddress                          _nv_rmsym_01040
#define dmaHalInstanceToHalInfo_NV04                 _nv_rmsym_01041
#define dmaHalInstanceToHalInfo_NV10                 _nv_rmsym_01042
#define dmaListElementPool                           _nv_rmsym_01043
#define dmaRegisterToDevice                          _nv_rmsym_01044
#define dmaSetBufferCtxDma                           _nv_rmsym_01045
#define dmaSetBufferLength                           _nv_rmsym_01046
#define dmaSetBufferPitch                            _nv_rmsym_01047
#define dmaSetBufferStart                            _nv_rmsym_01048
#define dmaUnbindFromChannel                         _nv_rmsym_01049
#define dmaUnregisterFromDevice                      _nv_rmsym_01050
#define dmaValidateObjectName                        _nv_rmsym_01051
#define dmaValidateXlate                             _nv_rmsym_01052
#define edidGetVersion                               _nv_rmsym_01053
#define edidIsAnalogDisplay                          _nv_rmsym_01054
#define edidParseDetailed1                           _nv_rmsym_01055
#define edidParseDetailed2                           _nv_rmsym_01056
#define edidParseDetailedTimingBlock                 _nv_rmsym_01057
#define enableCursor                                 _nv_rmsym_01058
#define engineGetBufferSize                          _nv_rmsym_01059
#define engineGetInfo                                _nv_rmsym_01060
#define engineGetInstMemSize                         _nv_rmsym_01061
#define eventRemoveObjectEventNotify                 _nv_rmsym_01062
#define eventSetEventNotify                          _nv_rmsym_01063
#define eventSetObjectEventNotify                    _nv_rmsym_01064
#define fbAllocInstMem                               _nv_rmsym_01065
#define fbAllocInstMemAlign                          _nv_rmsym_01066
#define fbCalcScreenMemSize                          _nv_rmsym_01067
#define fbFreeInstMem                                _nv_rmsym_01068
#define fbInitializeInstMemBitMap                    _nv_rmsym_01069
#define fbService                                    _nv_rmsym_01070
#define fifoAddHashEntry                             _nv_rmsym_01071
#define fifoAddObject                                _nv_rmsym_01072
#define fifoAlloc                                    _nv_rmsym_01073
#define fifoAllocDma                                 _nv_rmsym_01074
#define fifoDelHashEntry                             _nv_rmsym_01075
#define fifoDelObject                                _nv_rmsym_01076
#define fifoDeleteObjectInstance                     _nv_rmsym_01077
#define fifoEnumObjects                              _nv_rmsym_01078
#define fifoFree                                     _nv_rmsym_01079
#define fifoResend                                   _nv_rmsym_01080
#define fifoResetChannelState                        _nv_rmsym_01081
#define fifoSearchObject                             _nv_rmsym_01082
#define fifoService                                  _nv_rmsym_01083
#define fifoSoftwareMethod                           _nv_rmsym_01084
#define fifoUpdateObjectInstance                     _nv_rmsym_01085
#define fifolog                                      _nv_rmsym_01086
#define findex                                       _nv_rmsym_01087
#define fpParseEDID                                  _nv_rmsym_01088
#define getI2CPort                                   _nv_rmsym_01089
#define get_winice_input                             _nv_rmsym_01090
#define grCancelVBlank                               _nv_rmsym_01091
#define grContextInstanceToObject                    _nv_rmsym_01092
#define grCreateObj                                  _nv_rmsym_01093
#define grCreateOrdinal                              _nv_rmsym_01094
#define grCreateVideoColormap                        _nv_rmsym_01095
#define grCreateVideoPatchcord                       _nv_rmsym_01096
#define grCreateVideoSink                            _nv_rmsym_01097
#define grDefaultMethods                             _nv_rmsym_01098
#define grDeleteObjectInstance                       _nv_rmsym_01099
#define grDeleteOrdinal                              _nv_rmsym_01100
#define grDeleteVideoColormap                        _nv_rmsym_01101
#define grDeleteVideoPatchcord                       _nv_rmsym_01102
#define grDeleteVideoSink                            _nv_rmsym_01103
#define grDestroyObj                                 _nv_rmsym_01104
#define grGetLastIllegalMthdObject                   _nv_rmsym_01105
#define grHWMethod                                   _nv_rmsym_01106
#define grInitCommon                                 _nv_rmsym_01107
#define grInitPipeContextAddr                        _nv_rmsym_01108
#define grInitRenderCommon                           _nv_rmsym_01109
#define grInvalidateVideoPatchcord                   _nv_rmsym_01110
#define grIsRenderObject                             _nv_rmsym_01111
#define grLoadPipeContext                            _nv_rmsym_01112
#define grResubmitVertexContextDma                   _nv_rmsym_01113
#define grService                                    _nv_rmsym_01114
#define grSetLastIllegalMthdObject                   _nv_rmsym_01115
#define grUnloadPipeContext                          _nv_rmsym_01116
#define grVBlank                                     _nv_rmsym_01117
#define grValidateVideoPatchcord                     _nv_rmsym_01118
#define grVideoSwitchComplete                        _nv_rmsym_01119
#define grWaitVBlank                                 _nv_rmsym_01120
#define heapAlloc                                    _nv_rmsym_01121
#define heapCompact                                  _nv_rmsym_01122
#define heapCreate                                   _nv_rmsym_01123
#define heapDestroy                                  _nv_rmsym_01124
#define heapDump                                     _nv_rmsym_01125
#define heapFree                                     _nv_rmsym_01126
#define heapGetBase                                  _nv_rmsym_01127
#define heapGetFree                                  _nv_rmsym_01128
#define heapGetMaxFree                               _nv_rmsym_01129
#define heapGetSize                                  _nv_rmsym_01130
#define heapInfo                                     _nv_rmsym_01131
#define heapPurge                                    _nv_rmsym_01132
#define heapValidate                                 _nv_rmsym_01133
#define i2cAccess                                    _nv_rmsym_01134
#define i2cAck                                       _nv_rmsym_01135
#define i2cHardwareInit                              _nv_rmsym_01136
#define i2cInit                                      _nv_rmsym_01137
#define i2cRead                                      _nv_rmsym_01138
#define i2cReadCRTCStatusIndex                       _nv_rmsym_01139
#define i2cReadCRTCWrIndex                           _nv_rmsym_01140
#define i2cReadCtrl                                  _nv_rmsym_01141
#define i2cRead_ALT                                  _nv_rmsym_01142
#define i2cRead_ALT2                                 _nv_rmsym_01143
#define i2cReceiveByte                               _nv_rmsym_01144
#define i2cSend                                      _nv_rmsym_01145
#define i2cSendByte                                  _nv_rmsym_01146
#define i2cStart                                     _nv_rmsym_01147
#define i2cStop                                      _nv_rmsym_01148
#define i2cWrite                                     _nv_rmsym_01149
#define i2cWriteCRTCWrIndex                          _nv_rmsym_01150
#define i2cWriteCtrl                                 _nv_rmsym_01151
#define i2cWrite_ALT                                 _nv_rmsym_01152
#define initClientInfo                               _nv_rmsym_01153
#define initDac                                      _nv_rmsym_01154
#define initDacEx                                    _nv_rmsym_01155
#define initDisplayInfo                              _nv_rmsym_01156
#define initDmaListElementPool                       _nv_rmsym_01157
#define initFb                                       _nv_rmsym_01158
#define initFbEx                                     _nv_rmsym_01159
#define initFifo                                     _nv_rmsym_01160
#define initFifoEx                                   _nv_rmsym_01161
#define initGrEx                                     _nv_rmsym_01162
#define initHal                                      _nv_rmsym_01163
#define initMapping                                  _nv_rmsym_01164
#define initMc                                       _nv_rmsym_01165
#define initRModeEx                                  _nv_rmsym_01166
#define initTmr                                      _nv_rmsym_01167
#define init_COMPUTE_Memory                          _nv_rmsym_01168
#define init_CONFIGURE_Clocks                        _nv_rmsym_01169
#define init_CONFIGURE_Memory                        _nv_rmsym_01170
#define init_CONFIGURE_PreInit                       _nv_rmsym_01171
#define init_INDEX_IO_Write                          _nv_rmsym_01172
#define init_MEM_RESTRICT_SCRIPT                     _nv_rmsym_01173
#define init_NV                                      _nv_rmsym_01174
#define init_PLL_Values                              _nv_rmsym_01175
#define init_Reset_Chip                              _nv_rmsym_01176
#define init_STRAP_RESTRICT_SCRIPT                   _nv_rmsym_01177
#define init_TIME_Delay                              _nv_rmsym_01178
#define init_ZM                                      _nv_rmsym_01179
#define init_ZMW                                     _nv_rmsym_01180
#define mcService                                    _nv_rmsym_01181
#define mcSetBiosRevision                            _nv_rmsym_01182
#define memTypeFlags                                 _nv_rmsym_01183
#define mpCreateObj                                  _nv_rmsym_01184
#define mpDestroyObj                                 _nv_rmsym_01185
#define mthdColormapDirtyLength                      _nv_rmsym_01186
#define mthdColormapDirtyNotify                      _nv_rmsym_01187
#define mthdColormapDirtyStart                       _nv_rmsym_01188
#define mthdCreate                                   _nv_rmsym_01189
#define mthdDestroy                                  _nv_rmsym_01190
#define mthdNoOperation                              _nv_rmsym_01191
#define mthdSetAlarmNotify                           _nv_rmsym_01192
#define mthdSetAlarmNotifyCtxDma                     _nv_rmsym_01193
#define mthdSetAlarmTime                             _nv_rmsym_01194
#define mthdSetBufferCtxDma                          _nv_rmsym_01195
#define mthdSetBufferLength                          _nv_rmsym_01196
#define mthdSetBufferNotify                          _nv_rmsym_01197
#define mthdSetBufferNotifyCount                     _nv_rmsym_01198
#define mthdSetBufferNotifyCtxDma                    _nv_rmsym_01199
#define mthdSetBufferPitch                           _nv_rmsym_01200
#define mthdSetBufferPosNotify                       _nv_rmsym_01201
#define mthdSetBufferPosNotifyCtxDma                 _nv_rmsym_01202
#define mthdSetBufferStart                           _nv_rmsym_01203
#define mthdSetColormapCtxDma                        _nv_rmsym_01204
#define mthdSetColormapFormat                        _nv_rmsym_01205
#define mthdSetColormapLength                        _nv_rmsym_01206
#define mthdSetColormapStart                         _nv_rmsym_01207
#define mthdSetDmaSpecifier                          _nv_rmsym_01208
#define mthdSetNotify                                _nv_rmsym_01209
#define mthdSetNotifyCtxDma                          _nv_rmsym_01210
#define mthdSetNumberChannels                        _nv_rmsym_01211
#define mthdSetObject                                _nv_rmsym_01212
#define mthdSetSampleRate                            _nv_rmsym_01213
#define mthdSetSampleRateAdjust                      _nv_rmsym_01214
#define mthdSetTime                                  _nv_rmsym_01215
#define mthdSetVideoInput                            _nv_rmsym_01216
#define mthdSetVideoOutput                           _nv_rmsym_01217

#define nopCreate                                    _nv_rmsym_01219
#define nopDelete                                    _nv_rmsym_01220
#define notifyBufferComplete                         _nv_rmsym_01221
#define notifyBufferHWComplete                       _nv_rmsym_01222
#define notifyDefaultError                           _nv_rmsym_01223
#define notifyFillNotifier                           _nv_rmsym_01224
#define notifyFillNotifierArray                      _nv_rmsym_01225
#define notifyMethodComplete                         _nv_rmsym_01226
#define notifySetBufferNotify                        _nv_rmsym_01227
#define notifySetBufferNotifyCtxDma                  _nv_rmsym_01228
#define nvClassEngineDescriptor                      _nv_rmsym_01229

#define nvHalDacAlloc                                _nv_rmsym_01231
#define nvHalDacAlloc_NV04                           _nv_rmsym_01232
#define nvHalDacAlloc_NV10                           _nv_rmsym_01233
#define nvHalDacControl                              _nv_rmsym_01234
#define nvHalDacControl_NV04                         _nv_rmsym_01235
#define nvHalDacControl_NV10                         _nv_rmsym_01236
#define nvHalDacFree                                 _nv_rmsym_01237
#define nvHalDacFree_NV04                            _nv_rmsym_01238
#define nvHalDacFree_NV10                            _nv_rmsym_01239
#define nvHalDacSetStartAddr                         _nv_rmsym_01240
#define nvHalDacSetStartAddr_NV04                    _nv_rmsym_01241
#define nvHalDacSetStartAddr_NV10                    _nv_rmsym_01242
#define nvHalDmaAlloc                                _nv_rmsym_01243
#define nvHalDmaAlloc_NV04                           _nv_rmsym_01244
#define nvHalDmaAlloc_NV10                           _nv_rmsym_01245
#define nvHalDmaControl                              _nv_rmsym_01246
#define nvHalDmaControl_NV04                         _nv_rmsym_01247
#define nvHalDmaControl_NV10                         _nv_rmsym_01248
#define nvHalDmaFree                                 _nv_rmsym_01249
#define nvHalDmaFree_NV04                            _nv_rmsym_01250
#define nvHalDmaFree_NV10                            _nv_rmsym_01251
#define nvHalDmaGetInstSize                          _nv_rmsym_01252
#define nvHalDmaGetInstSize_NV04                     _nv_rmsym_01253
#define nvHalDmaGetInstSize_NV10                     _nv_rmsym_01254
#define nvHalFbAlloc                                 _nv_rmsym_01255
#define nvHalFbAlloc_NV04                            _nv_rmsym_01256
#define nvHalFbAlloc_NV10                            _nv_rmsym_01257
#define nvHalFbControl                               _nv_rmsym_01258
#define nvHalFbControl_NV04                          _nv_rmsym_01259
#define nvHalFbControl_NV10                          _nv_rmsym_01260
#define nvHalFbFree                                  _nv_rmsym_01261
#define nvHalFbFree_NV04                             _nv_rmsym_01262
#define nvHalFbFree_NV10                             _nv_rmsym_01263
#define nvHalFbGetSurfacePitch                       _nv_rmsym_01264
#define nvHalFbGetSurfacePitch_NV04                  _nv_rmsym_01265
#define nvHalFbGetSurfacePitch_NV10                  _nv_rmsym_01266
#define nvHalFbRoundToTiledPitch_NV10                _nv_rmsym_01267
#define nvHalFbSetAllocParameters                    _nv_rmsym_01268
#define nvHalFbSetAllocParameters_NV04               _nv_rmsym_01269
#define nvHalFbSetAllocParameters_NV10               _nv_rmsym_01270
#define nvHalFifoAccess                              _nv_rmsym_01271
#define nvHalFifoAccess_NV04                         _nv_rmsym_01272
#define nvHalFifoAccess_NV10                         _nv_rmsym_01273
#define nvHalFifoAllocDma                            _nv_rmsym_01274
#define nvHalFifoAllocDma_NV04                       _nv_rmsym_01275
#define nvHalFifoAllocDma_NV10                       _nv_rmsym_01276
#define nvHalFifoAllocPio                            _nv_rmsym_01277
#define nvHalFifoAllocPio_NV04                       _nv_rmsym_01278
#define nvHalFifoAllocPio_NV10                       _nv_rmsym_01279
#define nvHalFifoContextSwitch_NV04                  _nv_rmsym_01280
#define nvHalFifoContextSwitch_NV10                  _nv_rmsym_01281
#define nvHalFifoControl                             _nv_rmsym_01282
#define nvHalFifoControl_NV04                        _nv_rmsym_01283
#define nvHalFifoControl_NV10                        _nv_rmsym_01284
#define nvHalFifoFree                                _nv_rmsym_01285
#define nvHalFifoFree_NV04                           _nv_rmsym_01286
#define nvHalFifoFree_NV10                           _nv_rmsym_01287
#define nvHalFifoGetExceptionData                    _nv_rmsym_01288
#define nvHalFifoGetExceptionData_NV04               _nv_rmsym_01289
#define nvHalFifoGetExceptionData_NV10               _nv_rmsym_01290
#define nvHalFifoHashAdd                             _nv_rmsym_01291
#define nvHalFifoHashAdd_NV04                        _nv_rmsym_01292
#define nvHalFifoHashAdd_NV10                        _nv_rmsym_01293
#define nvHalFifoHashDelete                          _nv_rmsym_01294
#define nvHalFifoHashDelete_NV04                     _nv_rmsym_01295
#define nvHalFifoHashDelete_NV10                     _nv_rmsym_01296
#define nvHalFifoHashFunc                            _nv_rmsym_01297
#define nvHalFifoHashFunc_NV04                       _nv_rmsym_01298
#define nvHalFifoHashFunc_NV10                       _nv_rmsym_01299
#define nvHalFifoService                             _nv_rmsym_01300
#define nvHalFifoService_NV04                        _nv_rmsym_01301
#define nvHalFifoService_NV10                        _nv_rmsym_01302
#define nvHalGrAlloc                                 _nv_rmsym_01303
#define nvHalGrAlloc_NV04                            _nv_rmsym_01304
#define nvHalGrAlloc_NV10                            _nv_rmsym_01305
#define nvHalGrControl                               _nv_rmsym_01306
#define nvHalGrControl_NV04                          _nv_rmsym_01307
#define nvHalGrControl_NV10                          _nv_rmsym_01308
#define nvHalGrFree                                  _nv_rmsym_01309
#define nvHalGrFree_NV04                             _nv_rmsym_01310
#define nvHalGrFree_NV10                             _nv_rmsym_01311
#define nvHalGrGetExceptionData                      _nv_rmsym_01312
#define nvHalGrGetExceptionData_NV04                 _nv_rmsym_01313
#define nvHalGrGetExceptionData_NV10                 _nv_rmsym_01314
#define nvHalGrGetNotifyData                         _nv_rmsym_01315
#define nvHalGrGetNotifyData_NV04                    _nv_rmsym_01316
#define nvHalGrGetNotifyData_NV10                    _nv_rmsym_01317
#define nvHalGrGetState_NV10                         _nv_rmsym_01318
#define nvHalGrLoadChannelContext_NV04               _nv_rmsym_01319
#define nvHalGrLoadChannelContext_NV10               _nv_rmsym_01320
#define nvHalGrMethods_NV04                          _nv_rmsym_01321
#define nvHalGrMethods_NV10                          _nv_rmsym_01322
#define nvHalGrPutState_NV10                         _nv_rmsym_01323
#define nvHalGrService                               _nv_rmsym_01324
#define nvHalGrService_NV04                          _nv_rmsym_01325
#define nvHalGrService_NV10                          _nv_rmsym_01326
#define nvHalGrSetMaterialEmission_NV10              _nv_rmsym_01327
#define nvHalGrSetObjectContext                      _nv_rmsym_01328
#define nvHalGrSetObjectContext_NV04                 _nv_rmsym_01329
#define nvHalGrSetObjectContext_NV10                 _nv_rmsym_01330
#define nvHalGrUnloadChannelContext_NV04             _nv_rmsym_01331
#define nvHalGrUnloadChannelContext_NV10             _nv_rmsym_01332
#define nvHalMcChipId                                _nv_rmsym_01333
#define nvHalMcChipId_NV04                           _nv_rmsym_01334
#define nvHalMcChipId_NV10                           _nv_rmsym_01335
#define nvHalMcControl                               _nv_rmsym_01336
#define nvHalMcControl_NV04                          _nv_rmsym_01337
#define nvHalMcControl_NV10                          _nv_rmsym_01338
#define nvHalMcPower                                 _nv_rmsym_01339
#define nvHalMcPower_NV04                            _nv_rmsym_01340
#define nvHalMcPower_NV10                            _nv_rmsym_01341
#define nvHalMpAlloc                                 _nv_rmsym_01342
#define nvHalMpAlloc_NV04                            _nv_rmsym_01343
#define nvHalMpAlloc_NV10                            _nv_rmsym_01344
#define nvHalMpControl                               _nv_rmsym_01345
#define nvHalMpControl_NV04                          _nv_rmsym_01346
#define nvHalMpControl_NV10                          _nv_rmsym_01347
#define nvHalMpFree                                  _nv_rmsym_01348
#define nvHalMpFree_NV04                             _nv_rmsym_01349
#define nvHalMpFree_NV10                             _nv_rmsym_01350
#define nvHalRmServiceIntr                           _nv_rmsym_01351
#define nvHalTetrisTileWrite_NV04                    _nv_rmsym_01352
#define nvHalTetrisTile_NV04                         _nv_rmsym_01353
#define nvHalVideoAlloc                              _nv_rmsym_01354
#define nvHalVideoAlloc_NV04                         _nv_rmsym_01355
#define nvHalVideoAlloc_NV10                         _nv_rmsym_01356
#define nvHalVideoControl                            _nv_rmsym_01357
#define nvHalVideoControl_NV04                       _nv_rmsym_01358
#define nvHalVideoControl_NV10                       _nv_rmsym_01359
#define nvHalVideoFree                               _nv_rmsym_01360
#define nvHalVideoFree_NV04                          _nv_rmsym_01361
#define nvHalVideoFree_NV10                          _nv_rmsym_01362
#define nvHalVideoGetExceptionData                   _nv_rmsym_01363
#define nvHalVideoGetExceptionData_NV04              _nv_rmsym_01364
#define nvHalVideoGetExceptionData_NV10              _nv_rmsym_01365
#define nvHalVideoMethod                             _nv_rmsym_01366
#define nvHalVideoMethod_NV04                        _nv_rmsym_01367
#define nvHalVideoMethod_NV10                        _nv_rmsym_01368
#define nvHalVideoService                            _nv_rmsym_01369
#define nvHalVideoService_NV04                       _nv_rmsym_01370
#define nvHalVideoService_NV10                       _nv_rmsym_01371
#define nvInfoSelector                               _nv_rmsym_01372
#define nvNoEngineDescriptor                         _nv_rmsym_01373


#define osAllocDmaListElement                        _nv_rmsym_01381
#define osAllocPages                                 _nv_rmsym_01382
#define osDeviceNameToDeviceClass                    _nv_rmsym_01383
#define osDisplayInfo                                _nv_rmsym_01384
#define osError                                      _nv_rmsym_01385
#define osFreeDmaListElement                         _nv_rmsym_01386
#define osFreePages                                  _nv_rmsym_01387
#define osInService                                  _nv_rmsym_01388
#define osIsr                                        _nv_rmsym_01389
#define osLockUserMem                                _nv_rmsym_01390
#define osMapFifo                                    _nv_rmsym_01391
#define osMapFrameBuffer                             _nv_rmsym_01392
#define osMapInstanceMemory                          _nv_rmsym_01393
#define osMapPciMemoryUser                           _nv_rmsym_01394
#define osNotifyAction                               _nv_rmsym_01395
#define osNotifyEvent                                _nv_rmsym_01396
#ifndef LINUX
#define osReadRegistryBinary                         _nv_rmsym_01397
#define osReadRegistryDword                          _nv_rmsym_01398
#endif
#define osSetVideoMode                               _nv_rmsym_01399
#define osStateFbEx                                  _nv_rmsym_01400
#define osUnlockUserMem                              _nv_rmsym_01401
#define osUnmapMemory                                _nv_rmsym_01402
#define osUnmapPciMemoryUser                         _nv_rmsym_01403
#define osVirtualToPhysicalAddr                      _nv_rmsym_01404
#ifndef LINUX
#define osWriteRegistryBinary                        _nv_rmsym_01405
#define osWriteRegistryDword                         _nv_rmsym_01406
#endif
#define pClient                                      _nv_rmsym_01407
#define rmInCallback                                 _nv_rmsym_01408
#define rmInSafeService                              _nv_rmsym_01409
#define rmInService                                  _nv_rmsym_01410
#define stateConfigGet                               _nv_rmsym_01411
#define stateConfigGetEx                             _nv_rmsym_01412
#define stateConfigSet                               _nv_rmsym_01413
#define stateConfigSetEx                             _nv_rmsym_01414
#define stateDac                                     _nv_rmsym_01415
#define stateDma                                     _nv_rmsym_01416
#define stateFb                                      _nv_rmsym_01417
#define stateFifo                                    _nv_rmsym_01418
#define stateGr                                      _nv_rmsym_01419
#define stateMc                                      _nv_rmsym_01420
#define stateMp                                      _nv_rmsym_01421
#define stateNv                                      _nv_rmsym_01422
#define stateSetMode                                 _nv_rmsym_01423
#define stateSetMode_DacClassStyle                   _nv_rmsym_01424
#define stateTmr                                     _nv_rmsym_01425
#define stateVideo                                   _nv_rmsym_01426
#define str1024                                      _nv_rmsym_01427
#define str1152                                      _nv_rmsym_01428
#define str1280                                      _nv_rmsym_01429
#define str1280x960                                  _nv_rmsym_01430
#define str1600                                      _nv_rmsym_01431
#define str1600x900                                  _nv_rmsym_01432
#define str1800                                      _nv_rmsym_01433
#define str1920x1080                                 _nv_rmsym_01434
#define str1920x1200                                 _nv_rmsym_01435
#define str1920x1440                                 _nv_rmsym_01436
#define str2048x1536                                 _nv_rmsym_01437
#define str640                                       _nv_rmsym_01438
#define str800                                       _nv_rmsym_01439
#define strDevNodeDisplayNumber                      _nv_rmsym_01440
#define strDevNodeRM                                 _nv_rmsym_01441
#define strDisableMPC                                _nv_rmsym_01442
#define strDisplayType                               _nv_rmsym_01443
#define strEnable256Burst                            _nv_rmsym_01444
#define strExternalSerialOnPrimary                   _nv_rmsym_01445
#define strFpMode                                    _nv_rmsym_01446
#define strMemoryOverride                            _nv_rmsym_01447
#define strPBUSOverride                              _nv_rmsym_01448
#define strRTLOverride                               _nv_rmsym_01449
#define strTVOutOnPrimary                            _nv_rmsym_01450
#define strTVOutType                                 _nv_rmsym_01451
#define strTVtype                                    _nv_rmsym_01452
#define strTilingOverride                            _nv_rmsym_01453
#define strUnderscanXOverride                        _nv_rmsym_01454
#define strUnderscanYOverride                        _nv_rmsym_01455
#define tetris_tile_table_signature                  _nv_rmsym_01456
#define tmrAlarmNotify                               _nv_rmsym_01457
#define tmrCancelCallback                            _nv_rmsym_01458
#define tmrCreateTimer                               _nv_rmsym_01459
#define tmrDefaultMethods                            _nv_rmsym_01460
#define tmrDelay                                     _nv_rmsym_01461
#define tmrDeleteContextTime                         _nv_rmsym_01462
#define tmrDeleteTimer                               _nv_rmsym_01463
#define tmrGetCurrentTime                            _nv_rmsym_01464
#define tmrMonthDays                                 _nv_rmsym_01465
#define tmrScheduleCallbackAbs                       _nv_rmsym_01466
#define tmrScheduleCallbackRel                       _nv_rmsym_01467
#define tmrService                                   _nv_rmsym_01468
#define tmrStopTransfer                              _nv_rmsym_01469
#define vblankProcessCallbacks                       _nv_rmsym_01470
#define videoAdjustScalarForTV_NV10                  _nv_rmsym_01471
#define videoConvertScaleFactor_NV04                 _nv_rmsym_01472
#define videoConvertScaleFactor_NV10                 _nv_rmsym_01473
#define videoCreateColorKeyObj                       _nv_rmsym_01474
#define videoCreateFromMemoryObj                     _nv_rmsym_01475
#define videoCreateObj                               _nv_rmsym_01476
#define videoCreateOverlayObj                        _nv_rmsym_01477
#define videoCreateScalerObj                         _nv_rmsym_01478
#define videoDestroyColorKeyObj                      _nv_rmsym_01479
#define videoDestroyFromMemoryObj                    _nv_rmsym_01480
#define videoDestroyObj                              _nv_rmsym_01481
#define videoDestroyOverlayObj                       _nv_rmsym_01482
#define videoDestroyScalerObj                        _nv_rmsym_01483
#define videoFromMemService                          _nv_rmsym_01484
#define videoGetExceptionData_NV10                   _nv_rmsym_01485
#define videoHwOwnsBuffer_NV10                       _nv_rmsym_01486
#define videoInit_NV04                               _nv_rmsym_01487
#define videoInit_NV10                               _nv_rmsym_01488
#define videoKickOffOverlay_NV10                     _nv_rmsym_01489
#define videoOverlayService                          _nv_rmsym_01490
#define videoService                                 _nv_rmsym_01491
#define videoService_NV10                            _nv_rmsym_01492
#define videoStopOverlay_NV10                        _nv_rmsym_01493
#define wGpo                                         _nv_rmsym_01494
#define wMaxWaitStates                               _nv_rmsym_01495
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\miscr0.c ===
/*----------------------------------------------------------------------------*/
/*
 * miscR0.c
 *
 *      misc ring0 functions
 *	
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#define WANTVXDWRAPS 
#include <basedef.h>
#include <vmm.h>
#include <vxdldr.h>
//#include <debug.h>
#include <vxdwraps.h>
#include <vwin32.h>

#include "nvtypes.h"
#include "nvrmr0api.h"
#include "nvrmwin.h"
#include "nvos.h"

/*----------------------------------------------------------------------------*/
/*
 * pragma's to put the code and data into locked memory (XXX not sure if needed)
 */

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

/*----------------------------------------------------------------------------*/
/*
 * globals
 */

typedef DWORD (* LPDWFN)();
    
/*----------------------------------------------------------------------------*/
/*
 * getApiProcR0 - get the API Proc entry point for a given Vxd from Ring0
 */

LPDWFN getApiProcR0(PCHAR nameVxd)
{

    DWORD	    rc;
    PVMMDDB	    pddb;
    PDEVICEINFO	pdevinfo = NULL;
    
    rc = VXDLDR_LoadDevice( &pddb, &pdevinfo, nameVxd, TRUE); /* XXX what does TRUE do? */
                                                              /* XXX what's the return value */
    if ( (pdevinfo == NULL) || (pddb == NULL) ) {
        return ( NULL );
    }
    else {
        return ( (LPDWFN) pddb->DDB_PM_API_Proc );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\nvagp.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* AGP Chipset Routines **********************************\
*                                                                           *
* Module: NVAGP.C                                                           *
*   One time initialization code to update the AGP chipset and              *
*   our own AGP related values (includes workarounds and registry           *
*   overrides.                                                              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <stddef.h>    // for size_t
#include <nvReg.h>
#include <nvrm.h>
#include <nvhw.h>
#include <os.h>
#include <nvos.h>
#include <nvagp.h>

#ifdef LINUX 
#include <os-interface.h>
#include <asm/system.h>
#define INTERRUPT_SETUP    unsigned long flags;
#define CLI                flags = osCli(flags);
#define STI                flags = osSti(flags);
#else
#define INTERRUPT_SETUP
#ifdef IA64   /* XXX should this include linux?? */
#define CLI
#define STI
#else
#if (_WINN_WIN32 >= 0x0500)
#define CLI     osEnterCriticalCode(pDev)
#define STI      osExitCriticalCode(pDev)
#else
#define CLI      _asm cli
#define STI      _asm sti
#endif
#endif
#endif

VOID
NvUpdateAGPConfig(PHWINFO pDev)
{
}

#if 0


#define BYTES_MAPPED_PER_PAGE   ((RM_PAGE_SIZE >> 2) * RM_PAGE_SIZE)

extern char strDevNodeRM[];

// see how many "devices" are connected to us.
// This is important under Linux, since multiple X Servers can
// be run at once. We don't want the second X Server to reinitialize
// everything when it starts up, or the first X Server to exit
// teardown AGP on the remaining X Server.
static int agp_ref_count = 0;


// XXX get rid of this quick!!
#ifdef LINUX
#define RM_REGISTRY_AGP_BASE_PATH 0
#endif

/* define which chipsets should be compiled in. 
 * This allows controlled adding and testing of new chipsets without 
 * causing problems for people not expecting them.
 */
#define SUPPORT_INTEL_AGP     1
#define SUPPORT_VIA_AGP       1
#define SUPPORT_AMD_AGP       1
#define SUPPORT_RCC_AGP       1
#define SUPPORT_MICRON_AGP    1

enum {
      CS_UNKNOWN = 0
#ifdef SUPPORT_INTEL_AGP
    , CS_INTEL_440LX,
      CS_INTEL_440BX,
      CS_INTEL_440GX,
      CS_INTEL_815,       // solano
      CS_INTEL_820,       // camino
      CS_INTEL_840,       // carmel
      CS_INTEL_850,       // tehama
      CS_INTEL_860,       // colusa
      CS_INTEL_COMPAT     // compatibility
#endif
#ifdef SUPPORT_AMD_AGP
    , CS_AMD_751,         // irongate
      CS_AMD_761          // igd4
#endif
#ifdef SUPPORT_VIA_AGP
    , CS_VIA_8371,        // w/ intel cpu
      CS_VIA_82C694X,     // w/ amd slot A
      CS_VIA_KT133        // w/ amd socket A
#endif
#ifdef SUPPORT_RCC_AGP
    , CS_RCC_6585HE       // cnb20he
#endif
#ifdef SUPPORT_MICRON_AGP
    , CS_MICRON_SAMDDR    // m4369c
#endif
};

/* moved agp mapping info here from pDev.
 * this primarily allows two things:
 *   - a second X Server run on another VT can share AGP with the
 *         initial X Server by using this info.
 *   - if X crashes and leaves AGP setup, the restarting X Server
 *         can use this info, as if it was just a second X Server.
 * In the long run, the variables in pDev should be changed to point
 * to this structure here, but we're too close to a release under
 * multiple platforms to change that much code.
 * For now, we'll just have to deal with keeping info synchronized.
 */

typedef struct {
    unsigned int initialized;
    unsigned int fw_capable;
    unsigned int sba_capable;
    VOID (*enable_mappings)(PHWINFO pDev, U032 handle, U032 physaddr);
    VOID (*flush_mappings)(PHWINFO pDev, U032 handle);
    U032 (*get_aper_size)(PHWINFO pDev, U032 handle);
    U032 (*get_aper_base)(PHWINFO pDev, U032 handle);
    U032 (*get_gart_size)(PHWINFO pDev, U032 handle);
    U032 (*earlyinit)(PHWINFO pDev, U032 handle);
    VOID (*fixup_gart)(PHWINFO pDev, U032 handle, U032 physaddr);
    VOID (*apply_updates)(PHWINFO pDev, U032 handle, U016 deviceID);
    VOID (*disable_chipset)(PHWINFO pDev, U032 handle);
} agp_chipset_funcs;

/* noop error functions to avoid NULL pointer dereferences */
static VOID agp_noop1(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID agp_noop2(PHWINFO pDev, U032 handle);
static U032 agp_noop3(PHWINFO pDev, U032 handle);
static VOID agp_noop4(PHWINFO pDev, U032 handle, U016 deviceID);

/* Chipset Explanation:
 *
 * In theory, it should be easy (sw-wise) to add multiple AGP chipsets per 
 * system. chipset_funcs[] is a static array of all chipsets in a system, 
 * but is only accessed in the code via the chipset ptr. To initialize to 
 * a different chipset, call the AGP_SELECT_DEVICE() macro, to select a 
 * new bus/slot combination. currently, this uses the bus as an offset to 
 * choose which chipset to use. Although this may be a bad assumption, the 
 * only place it is made is right here, and so is a simple, isolated change.
 */

#define AGP_MAX_CHIPSETS 1
static agp_chipset_funcs chipset_funcs[AGP_MAX_CHIPSETS] = 
    { 
        { 
            0, 0, 0, 
            agp_noop1, agp_noop2, agp_noop3, agp_noop3, agp_noop3, agp_noop3, 
            agp_noop1, agp_noop4, agp_noop2
        }
    };

static agp_chipset_funcs *agp_current = NULL;

#define AGP_SELECT_DEVICE(handle, venid, devid)                      \
    agp_current = &chipset_funcs[0];                                 \
    NvSetBusDeviceFunc(pDev);                                        \
    handle = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,               \
                             AgpInfo(pDev).NBAddr.device,            \
                             AgpInfo(pDev).NBAddr.func,              \
                             venid, devid);

/* for a multi-mon environment, we need to save the pDev for AllocAGPPages
 * and FreeAGPPages. Assuming the AGP card is device 0 is wrong. In the
 * long run, this change is wrong for multi-AGP devices, we'll need to
 * change the interfaces to the above functions to take a pDev..
 */ 

static PHWINFO tmp_pDev = NULL;

#define AGP_GET_PDEV()                  tmp_pDev
#define AGP_SAVE_PDEV(pDev)             tmp_pDev = pDev


static VOID 
agp_noop1(PHWINFO pDev, U032 handle, U032 physaddr)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop1\n");
}

static VOID 
agp_noop2(PHWINFO pDev, U032 handle)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop2\n");
}

static U032
agp_noop3(PHWINFO pDev, U032 handle)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop3\n");
    return 0;
}

static VOID 
agp_noop4(PHWINFO pDev, U032 handle, U016 deviceID)
{
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** called agp_noop4\n");
}


#ifdef SUPPORT_AMD_AGP

BOOL 
AMD_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_AMD_751:
        case CS_AMD_761:
            return TRUE;
    }
    return FALSE;
}

U032
AMD_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x7006:
            return CS_AMD_751;
        case 0x700E:
            return CS_AMD_761;
    }
    return 0;
}

static VOID AMD_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID AMD_FlushMappings(PHWINFO pDev, U032 handle);
static U032 AMD_GetAperSize(PHWINFO pDev, U032 handle);
static U032 AMD_GetAperBase(PHWINFO pDev, U032 handle);
static U032 AMD_GetGartSize(PHWINFO pDev, U032 handle);
static U032 AMD_EarlyInit(PHWINFO pDev, U032 handle);
static VOID AMD_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID AMD_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID);
static VOID AMD_DisableChipset(PHWINFO pDev, U032 handle);

VOID
AMD_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings  = AMD_EnableMappings;
    funcs->flush_mappings   = AMD_FlushMappings;
    funcs->get_aper_size    = AMD_GetAperSize;
    funcs->get_aper_base    = AMD_GetAperBase;
    funcs->get_gart_size    = AMD_GetGartSize;
    funcs->earlyinit        = AMD_EarlyInit;
    funcs->fixup_gart       = AMD_FixupGart;
    funcs->apply_updates    = AMD_ApplyChipsetUpdates;
    funcs->disable_chipset  = AMD_DisableChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 1;
    funcs->sba_capable = 0;
}


static VOID
AMD_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_AMD_751:
        case CS_AMD_761:
            // enable GART directory cache      
            osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

            // enable GART table cache and errors
            ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] |= 0x5;

            // base of GART
            ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = physaddr;
            break;
        default:
            break;
    }

}

static VOID
AMD_FlushMappings(PHWINFO pDev, U032 handle)
{
    // We could invalidate the individual entries, but for starters, just
    // invalidate the whole cache of entries. 
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x3] |= 0x1;
}

static U032
AMD_GetAperSize(PHWINFO pDev, U032 handle)
{
    unsigned int apsize = osPciReadWord(handle, AMD_APER_SIZE); // aperture size
    switch ( (apsize & 0xE) >> 1 )   /* mask and shift bits 1-3 */
    {
        case 0x00:
            apsize = (  32 * 1024 * 1024);
            break;
        case 0x01:
            apsize = (  64 * 1024 * 1024);
            break;
        case 0x02:
            apsize = ( 128 * 1024 * 1024);
            break;
        case 0x03:
            apsize = ( 256 * 1024 * 1024);
            break;
        case 0x04:
            apsize = ( 512 * 1024 * 1024);
            break;
        case 0x05:
            apsize = (1024 * 1024 * 1024);
            break;
        case 0x06:
            apsize = (2024 * 1024 * 1024);
            break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciAndWord(handle, AMD_APER_SIZE, ~(0xe) /* apsize */);
    }
#endif

    return apsize;
}

static U032
AMD_GetAperBase(PHWINFO pDev, U032 handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
AMD_GetGartSize(PHWINFO pDev, U032 handle)
{
    unsigned int gart_size;
    gart_size = ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE - 1) / RM_PAGE_SIZE) * 4;
    gart_size += RM_PAGE_SIZE;     // this is for the 1st-level lookup
    return gart_size;
}

static U032 
AMD_EarlyInit(PHWINFO pDev, U032 handle)
{
    if ((AgpInfo(pDev).AGPChipset == CS_AMD_751) || 
        (AgpInfo(pDev).AGPChipset == CS_AMD_761))
    {
        // AMD 751/761 has its AGP related regs memory-mapped via BAR1
        unsigned int physaddr = (osPciReadDword(handle, PCI_BASE_ADDRESS_1) & ~RM_PAGE_MASK);

        AgpInfo(pDev).AGPChipsetMapping = (VOID_PTR) 
            osMapKernelSpace(physaddr, RM_PAGE_SIZE, FALSE);
        if (AgpInfo(pDev).AGPChipsetMapping == (VOID_PTR)NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, 
                    "NVRM: *** Failed to map AMD's AGP chipset registers\n");
            return 0;
        }
    }
    return 1;
}

static VOID
AMD_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr)
{
    U032 i, *baseptr, tableptr;

    //
    // For AMD 751/761, convert the first allocated GART page into the first level GART
    // lookup ... where each GART directory entry is just the subsequent 4k pages. We can
    // derive the following entries, because we know the pages are contiguous.
    //

    baseptr  = (U032 *)((U008 *)AgpInfo(pDev).AGPGartBase + 
        (AgpInfo(pDev).AGPPhysStart >> 20));
    tableptr = physaddr + RM_PAGE_SIZE;    // GART directory entries start on the 2nd page

    for (i = 0; i < ((AgpInfo(pDev).AGPLimit + 1) / BYTES_MAPPED_PER_PAGE); i++)
    {
        *baseptr = (tableptr | 0x1);

        tableptr += RM_PAGE_SIZE;   // next phys GART table address
        baseptr++;                  // next GART directory entry
    }
        
    //
    // Move the AGPGartBase past the first level GART page to where the GART
    // tables really begin (this makes nvagp_LoadGARTEntries() common).
    //
    (U008 *)AgpInfo(pDev).AGPGartBase += RM_PAGE_SIZE;
}

static VOID
AMD_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID)
{
    U032 agp_command;

    if (deviceID != 0x7006)
        return;    // workarounds below are AMD751 (Irongate) specific

    // disable SBA on Irongate with NV5 (some faster NV5's are failing in the lab).
    if (IsNV5(pDev))
    {
        // clear chipset's SBA enable bit
        agp_command  = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON));
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        // clear our SBA enable bit
        FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _OFF);
    }

    // Due to an AMD power glitch bug, drop down to 1x on NV10/NV15
    if (IsNV10orBetter(pDev))
    {
        //
        // Compaq (and possibly others) have a modified NV10 which allows 2x to work.
        // This rework is not SW visable, so we detect it by a registry key.
        //
        if (IsNV10(pDev))
        {
            U032 data32;
            RM_STATUS status;

            // 
            // Compaq has a modified NV10 which allows 2x to work. This rework is not
            // SW visible, so we detect it by a registry key. If set, there's nothing
            // to do.
            //
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                            "EnableIrongate2x", &data32);
            if (status == RM_OK)
                return;

            //
            // This yields little perf difference, but Gateway has requested an option
            // to turn back on SBA when dropping to 1x mode. This requires setting the
            // strap first, since NV10 is normally not strapped for SBA.
            //
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                            "EnableIrongateSBA", &data32);
            if (status == RM_OK)
            {
                // set the overwrite bit and change our SBA strapping
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_SBA,   _ENABLED);

                // set chipset's SBA enable bit
                agp_command  = osPciReadDword(handle, AGP_COMMAND);
                agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
                osPciWriteDword(handle, AGP_COMMAND, agp_command);

                // set our SBA enable bit
                FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON);
            }
        }

        // set AGP 1x mode
        agp_command  = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~0xF;    // clear the old AGP rate
        agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _1X);
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _1X);
    }
}

static VOID
AMD_DisableChipset(PHWINFO pDev, U032 handle)
{
    // paranoia
    if (!AgpInfo(pDev).AGPChipsetMapping)
        return;

    // enable GART directory cache
    // nv_printf("disabling GART directory cache\n");
    // osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

    // enable GART table cache and errors
    ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] &= ~(0x5);

    // base of GART
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = 0x0;

    // unmap AMD AGP registers
    osUnmapKernelSpace((void *) AgpInfo(pDev).AGPChipsetMapping, RM_PAGE_SIZE);
}

#endif

#ifdef SUPPORT_INTEL_AGP
BOOL 
Intel_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_INTEL_440LX:
        case CS_INTEL_440BX:
        case CS_INTEL_440GX:
        case CS_INTEL_815:
        case CS_INTEL_820:
        case CS_INTEL_840:
        case CS_INTEL_850:
        case CS_INTEL_860:
        case CS_INTEL_COMPAT:
            return TRUE;
    }
    return FALSE;
}

U032
Intel_GetChipset(PHWINFO pDev, U032 device)
{
    RM_STATUS status;
    U032 data32;

    switch(device)
    {
        case 0x7180:
            return CS_INTEL_440LX;
        case 0x7190:
            return CS_INTEL_440BX;
        case 0x71A0:
            return CS_INTEL_440GX;
        case 0x1130:
            return CS_INTEL_815;
        case 0x2500:          // dell poblano
            return CS_INTEL_820;
        case 0x2501:
            return CS_INTEL_820;
        case 0x1A20:
            return CS_INTEL_840;
        case 0x1A21:
            return CS_INTEL_840;
        case 0x1A22:
            return CS_INTEL_840;
        case 0x2530:
            return CS_INTEL_850;
        case 0x2531:
            return CS_INTEL_860;
    }

    //
    // For this undetected chipset, check if the registry key is on to run it
    // in "compatibility mode". This allows Intel customers with new chipsets
    // to see if it'll work with our existing Intel support.
    //
    status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, "UseIntelCompat", &data32);
    if ((status == RM_OK) && data32)
        return CS_INTEL_COMPAT;

    return 0;
}

static VOID Intel_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID Intel_FlushMappings(PHWINFO pDev, U032 handle);
static U032 Intel_GetAperSize(PHWINFO pDev, U032 handle);
static U032 Intel_GetAperBase(PHWINFO pDev, U032 handle);
static U032 Intel_GetGartSize(PHWINFO pDev, U032 handle);
static U032 Intel_EarlyInit(PHWINFO pDev, U032 handle);
static VOID Intel_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID Intel_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID);
static VOID Intel_DisableChipset(PHWINFO pDev, U032 handle);

VOID
Intel_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings = Intel_EnableMappings;
    funcs->flush_mappings  = Intel_FlushMappings;
    funcs->get_aper_size   = Intel_GetAperSize;
    funcs->get_aper_base   = Intel_GetAperBase;
    funcs->get_gart_size   = Intel_GetGartSize;
    funcs->earlyinit       = Intel_EarlyInit;
    funcs->fixup_gart      = Intel_FixupGart;
    funcs->apply_updates   = Intel_ApplyChipsetUpdates;
    funcs->disable_chipset = Intel_DisableChipset;
    funcs->initialized = 1;
    funcs->sba_capable = 0;

    /* SOLANO, CAMINO, CARMEL, TEHAMA and COLUSA are fast-write capable */
    if (chipset == CS_INTEL_815
        || chipset == CS_INTEL_820
        || chipset == CS_INTEL_840
        || chipset == CS_INTEL_850
        || chipset == CS_INTEL_860)
       funcs->fw_capable = 1;
    else
       funcs->fw_capable = 0;
}

static VOID
Intel_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_INTEL_440LX:
        case CS_INTEL_440BX:
        case CS_INTEL_440GX:
            osPciWriteWord(handle, INTEL_ERRSTS, 0x07);
        /* FALLTHROUGH */
        case CS_INTEL_815:
        case CS_INTEL_820:
        case CS_INTEL_840:
        case CS_INTEL_850:
        case CS_INTEL_860:
        case CS_INTEL_COMPAT:
            osPciWriteDword(handle, INTEL_GART_BASE, physaddr); // base of GART
            osPciOrDword(handle, INTEL_GART_CONTROL, 0x80);  // enable GTLB
            osPciOrDword(handle, INTEL_CHIPSET_CONFIG, 0x200);  // enable global access
        default:
            break;
    }
}

static VOID
Intel_FlushMappings(PHWINFO pDev, U032 handle)
{
    // Invalidate the GTLB
    if (!handle) return;
    osPciAndDword(handle, INTEL_GART_CONTROL, ~(0x80));
    osPciOrDword(handle, INTEL_GART_CONTROL, 0x80);
}


static U032
Intel_GetAperSize(PHWINFO pDev, U032 handle)
{
    unsigned int apsize;
    apsize = osPciReadWord(handle, INTEL_APER_SIZE); // aperture size
    switch (apsize)
    {
        case 0x3f:
            apsize = (4 * 1024 * 1024);
            break;
        case 0x3e:
            apsize = (8 * 1024 * 1024);
            break;
        case 0x3c:
            apsize = (16 * 1024 * 1024);
            break;
        case 0x38:
            apsize = (32 * 1024 * 1024);
            break;
        case 0x30:
            apsize = (64 * 1024 * 1024);
            break;
        case 0x20:
            apsize = (128 * 1024 * 1024);
            break;
        case 0x00:
            apsize = (256 * 1024 * 1024);
            break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, INTEL_APER_SIZE, 0x38 /* apsize */);
    }

    return apsize;
}

static U032
Intel_GetAperBase(PHWINFO pDev, U032 handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
Intel_GetGartSize(PHWINFO pDev, U032 handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Intel_EarlyInit(PHWINFO pDev, U032 handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Intel_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Intel_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID)
{
    U032 agp_status, agp_command;
    U032 data;
    INTERRUPT_SETUP

    // Some special Intel chipset handling
    switch (deviceID)
    {
        case 0x2500:    // Camino
        case 0x2501:
            // expose the FW capability on Camino
            osPciOrDword(handle, INTEL_GART_CONTROL, 0x2);
            break;
        case 0x7190:    // BX/ZX

            if (IsNV15(pDev) || IsNV11(pDev))
                FLD_WR_DRF_DEF(_PBUS, _DEBUG_2, _AGP_VREF, _ENABLED);

            //
            // Temporary workaround for Toshiba's motherboard that didn't
            // connect external vref.
            //
            if (IsNV11(pDev) &&
                (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "Mobile", &data) == RM_OK)) {
                if (data == 2) {        // equate for Toshiba
                    FLD_WR_DRF_DEF(_PBUS, _DEBUG_2, _AGP_VREF, _DISABLED);
                }
            }

            break;
        default:
            break;
    }

    //
    // Check for chipset overrides to AGP Multi-Transaction Timer or the
    // Low Priority Transaction Timer for the supported Intel chipsets.
    //
    switch (deviceID)
    {
        case 0x2500:    // Camino
        case 0x2501:
        case 0x1A20:    // Carmel
        case 0x1A21:
        case 0x1A22:
        case 0x1130:    // Solano
        case 0x2530:    // Tehama
        case 0x2531:    // Colusa
        {
            U032 amtt, lptt;
            if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                       "IntelAMTT", &amtt) == RM_OK) {
                if (amtt != ~0) {    // value of 0xFFFFFFFF disables the override
                    if (amtt & 0x7) {
                        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Intel AMTT not multiple of 8 clocks\n");
                    } else {
                        osPciWriteByte(handle, INTEL_MULTI_TRANS_TIMER, (U008)amtt);
                    }
                }
            }
            if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                       "IntelLPTT", &lptt) == RM_OK) {
                if (lptt != ~0) {    // value of 0xFFFFFFFF disables the override
                    if (lptt & 0x7) {
                        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: Intel LPTT not multiple of 8 clocks\n");
                    } else {
                        osPciWriteByte(handle, INTEL_LOW_PRI_TRANS_TIMER, (U008)lptt);
                    }
                }
            }
            break;
        }
        default:
            break;
    }

#ifdef LINUX
    {
        unsigned int support_fw;
        if ( (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, 
                                     "EnableAGPFW", &support_fw) != RM_OK) ||
             (support_fw == 0))
        {
            return;
        }
    }
#endif

    // First, check if this chipset is FW capable
    if (!agp_current->fw_capable)
        return;

    // Also, check if we're FW capable
    if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;

    //
    // Finally, check if this chipset is strapped for fastwrites.
    // Solano lies about not supporting FW's, so even though the strap isn't
    // set, we can still enable them (there's no backdoor like Camino).
    //
    agp_status = osPciReadDword(handle, AGP_STATUS);
    if (((agp_status & 0x10) == 0) &&
        (Intel_GetChipset(pDev, deviceID) != CS_INTEL_815))
        return;

    CLI

    // enable AGP fastwrites for both us and the chipset
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);

    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    STI
}

static VOID
Intel_DisableChipset(PHWINFO pDev, U032 handle)
{
    unsigned int agp_command;
    INTERRUPT_SETUP

    agp_command  = osPciReadDword(handle, AGP_COMMAND);

    /* if fast-writes aren't enabled, exit */
    if ( !(agp_command & 0x10) ) return;

    agp_command &= ~(DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON));

    CLI

    // disable AGP fastwrites for both us and the chipset
    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _OFF);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    STI
}
#endif

#ifdef SUPPORT_VIA_AGP

/* XXX hack alert!! */
static unsigned int via_base = 0;

BOOL 
Via_IsChipset(PHWINFO pDev)
{
        switch (AgpInfo(pDev).AGPChipset) {
                case CS_VIA_8371:
                case CS_VIA_82C694X:
                case CS_VIA_KT133:
                        return TRUE;
        }
        return FALSE;
}

U032
Via_GetChipset(PHWINFO pDev, U032 device)
{
    // The spec for the 8371 chipset claims it has a device ID
    // of 0x691, but the version we looked at returned 0x391.
    // This also happens to be the device ID for the 82C694X
    // chipset, so we'll be OK regardless.
    switch(device)
    {
        case 0x0691:
            return CS_VIA_8371;
        case 0x0391:
            return CS_VIA_82C694X;
                case 0x0305:
            return CS_VIA_KT133;
    }
    return 0;
}

static VOID Via_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID Via_FlushMappings(PHWINFO pDev, U032 handle);
static U032 Via_GetAperSize(PHWINFO pDev, U032 handle);
static U032 Via_GetAperBase(PHWINFO pDev, U032 handle);
static U032 Via_GetGartSize(PHWINFO pDev, U032 handle);
static U032 Via_EarlyInit(PHWINFO pDev, U032 handle);
static VOID Via_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID Via_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID);
static VOID Via_DisableChipset(PHWINFO pDev, U032 handle);

VOID
Via_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings  = Via_EnableMappings;
    funcs->flush_mappings   = Via_FlushMappings;
    funcs->get_aper_size    = Via_GetAperSize;
    funcs->get_aper_base    = Via_GetAperBase;
    funcs->get_gart_size    = Via_GetGartSize;
    funcs->earlyinit        = Via_EarlyInit;
    funcs->fixup_gart       = Via_FixupGart;
    funcs->apply_updates    = Via_ApplyChipsetUpdates;
    funcs->disable_chipset  = Via_DisableChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 0;
    funcs->sba_capable = 0;
}

static VOID
Via_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    { 
        case CS_VIA_8371:
        case CS_VIA_82C694X:
        case CS_VIA_KT133:
            // enable global access 
            osPciOrDword(handle, VIA_GART_BASE, physaddr | 0x2);
            // enable GA address translation
            osPciOrDword(handle, VIA_GART_CONTROL, 0xf);
            break;
        default:
            break;
    }
}

static VOID
Via_FlushMappings(PHWINFO pDev, U032 handle)
{
    if (!handle) return;
    osPciOrDword(handle, VIA_GART_CONTROL, 0x80);       // enable TLB flush
    osPciAndDword(handle, VIA_GART_CONTROL, ~(0x80));   // disable TLB flush
}


/* XXX 
 * I'm unsure if there is a BIOS-default size here, the docs seem
 * to indicate it defaults to 0, so we'll see
 */
static U032
Via_GetAperSize(PHWINFO pDev, U032 handle)
{
    unsigned int apsize = 0;
    apsize = osPciReadDword(handle, VIA_APER_SIZE);

    switch (apsize)
    {
        case 0xff:
            apsize =   1 * 1024 * 1024; /*   1 Meg */
            break;
        case 0xfe:
            apsize =   2 * 1024 * 1024; /*   2 Meg */
            break;
        case 0xfc:
            apsize =   4 * 1024 * 1024; /*   4 Meg */
            break;
        case 0xf8:
            apsize =   8 * 1024 * 1024; /*   8 Meg */
            break;
        case 0xf0:
            apsize =  16 * 1024 * 1024; /*  16 Meg */
            break;
        case 0xe0:
            apsize =  32 * 1024 * 1024; /*  32 Meg */
            break;
        case 0xc0:
            apsize =  64 * 1024 * 1024; /*  64 Meg */
            break;
        case 0x80:
            apsize = 128 * 1024 * 1024; /* 128 Meg */
            break;
        case 0x00:
            apsize = 256 * 1024 * 1024; /* 256 Meg */
            break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** VIA bad apsize!\n");
            apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, VIA_APER_SIZE, 0xe0 /* apsize */);
    }
#endif

    return apsize;
}

static U032
Via_GetAperBase(PHWINFO pDev, U032 handle)
{
    if (!via_base)
        via_base = osPciReadDword(handle, PCI_BASE_ADDRESS_0);
    return via_base;
}

static U032
Via_GetGartSize(PHWINFO pDev, U032 handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Via_EarlyInit(PHWINFO pDev, U032 handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Via_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Via_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID)
{
    U032 agp_status, agp_command, gart_control;
    INTERRUPT_SETUP

    //
    // First, determine the real ID of the chipset.
    //
    // Via, in some cases, has been using the Apollo 694x device ID with
    // the KX133 and KT133, and since we're not treating them the same
    // anymore, we need to get the real ID.
    //
    if (deviceID == 0x691)
    {
        U008 backdoor1;

        // disable the Back-Door Device ID Enable bit
        backdoor1  = osPciReadByte(handle, 0xFC);
        osPciWriteByte(handle, 0xFC, (U008)(backdoor1 & ~0x1));

        // reread the deviceID
        deviceID = (U016)(osPciReadDword(handle, 0x0) >> 16);

        // restore the Back-Door control byte
        osPciWriteByte(handle, 0xFC, backdoor1);
    }

    // return, if it's not a 694x, KX133 or KT133
    if ((deviceID != 0x691) && (deviceID != 0x391) && (deviceID != 0x305))
        return;

    //
    // Workaround for a Via chipset driver in WinME that forgot to reenable
    // this bit on the way back from hibernation. This is fixed in the latest
    // Via chipset driver, but just to be safe, leave it in for now.
    //
    gart_control = osPciReadDword(handle, 0x80);
    gart_control |= 0x2;
    osPciWriteDword(handle, 0x80, gart_control);

    // 
    // If AGP FW's are already enabled (as part of normal chipset driver
    // configuration) avoid trying to change the AGP rate, since this can
    // cause a hang.
    //
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE) ==
        NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_ON)
        return;

    //
    // Only the Apollo Pro133 (Via694x) should be dropped down from 4x to 2x
    //
    if (deviceID == 0x691)
    {
        // check if we're currently in AGP 4x mode
        agp_command = osPciReadDword(handle, AGP_COMMAND);
        if (DRF_VAL(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, agp_command) == NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_4X)
        {
            U032 data32;
            RM_STATUS status;

            // check if there's a registry override to stay at AGP 4x
            status = OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, "EnableVia4x", &data32);
            if ( (status != RM_OK) || (data32 == 0) )
            {
                U008 agp_misc;

                // no override, so we'll go to AGP 2x mode
                agp_command &= ~0xF;    // clear the old AGP rate
                agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _2X);
                osPciWriteDword(handle, AGP_COMMAND, agp_command);

                FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, _2X);

                // 
                // In addition to changing AGPCMD, also change AGPSTATUS to disable 4x
                // in case there's another module that tries to put us back in that mode.
                //
                agp_misc  = osPciReadByte(handle, 0xAE);
                agp_misc &= 0xFB;    // clear 4x enable
                osPciWriteByte(handle, 0xAE, agp_misc);

                // clear our 4x enable
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
                FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_4X,    _DISABLED);
            }
        }
    }

    if (IsNV10orBetter(pDev))
    {
        //
        // Set Via's AGP Read Synchronization bit which fixes a coherency
        // problem on their chipset (applies to NV10 and later chips).
        //
        osPciOrByte(handle, VIA_AGP_CONTROL /* 0xAC */, 0x40);
    }

#ifdef LINUX
    {
        unsigned int support_fw;
        if ( (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH, 
                                     "EnableAGPFW", &support_fw) != RM_OK) ||
             (support_fw == 0))
        {
            return;
        }
    }
#endif

    // check if we're FW capable
    if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;

    // check if Via is strapped for FW
    agp_status = osPciReadDword(handle, AGP_STATUS /* 0xA4 */);
    if (DRF_VAL(_PBUS, _PCI_NV_18, _AGP_STATUS_FW, agp_status) == NV_PBUS_PCI_NV_18_AGP_STATUS_FW_NONE)
        return;
    
    CLI

    // enable AGP fastwrites for both us and the chipset
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command |= DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);

    FLD_WR_DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, _ON);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);
    
    STI
}

static VOID
Via_DisableChipset(PHWINFO pDev, U032 handle)
{
    switch (AgpInfo(pDev).AGPChipset)    
    { 
        case CS_VIA_8371:
        case CS_VIA_82C694X:
        case CS_VIA_KT133:
            // enable global access 
            osPciWriteDword(handle, VIA_GART_BASE, 0x0);
            // enable GA address translation
            // osPciAndDword(handle, VIA_GART_CONTROL, ~(0xf));
            // restore aperture size
            // XXX hack, need to translate this mapping from stored value!!
            osPciWriteWord(handle, VIA_APER_SIZE, 0xe0 /* apsize */);
            break;
        default:
            break;
    }
}

#endif

#ifdef SUPPORT_RCC_AGP

BOOL 
RCC_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_RCC_6585HE:
            return TRUE;
    }
    return FALSE;
}

U032
RCC_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x0009:
            return CS_RCC_6585HE;
    }
    return 0;
}

static VOID RCC_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID RCC_FlushMappings(PHWINFO pDev, U032 handle);
static U032 RCC_GetAperSize(PHWINFO pDev, U032 handle);
static U032 RCC_GetAperBase(PHWINFO pDev, U032 handle);
static U032 RCC_GetGartSize(PHWINFO pDev, U032 handle);
static U032 RCC_EarlyInit(PHWINFO pDev, U032 handle);
static VOID RCC_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID RCC_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID);
static VOID RCC_DisableChipset(PHWINFO pDev, U032 handle);
static VOID RCC_FlushPostedWriteBuffer(PHWINFO pDev);

VOID
RCC_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings  = RCC_EnableMappings;
    funcs->flush_mappings   = RCC_FlushMappings;
    funcs->get_aper_size    = RCC_GetAperSize;
    funcs->get_aper_base    = RCC_GetAperBase;
    funcs->get_gart_size    = RCC_GetGartSize;
    funcs->earlyinit        = RCC_EarlyInit;
    funcs->fixup_gart       = RCC_FixupGart;
    funcs->apply_updates    = RCC_ApplyChipsetUpdates;
    funcs->disable_chipset  = RCC_DisableChipset;
    funcs->initialized = 1;
    funcs->fw_capable = 0;
    funcs->sba_capable = 0;
}

static VOID
RCC_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr)
{
    volatile U032 *ccr;    // cache control register

    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_RCC_6585HE:

            // enable GART cache and error reporting 
            ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] |= 0x9;
            
            // invalidate the caches before we start (and poll until it's done)
            ccr = &((U032 *)AgpInfo(pDev).AGPChipsetMapping)[0x3];
            *ccr |= 0x1;
            while ((*ccr & 0x1) != 0)
                ;

            // set the base of GART
            ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = physaddr;

            // set the global AGP enable bit
            osPciOrByte(handle, RCC_APER_SIZE, 0x1);
            break;

        default:
            break;
    }
}

static VOID
RCC_FlushMappings(PHWINFO pDev, U032 handle)
{
    volatile U032 *ccr;    // cache control register

    //
    // We could invalidate individual entries, but for starters, just
    // invalidate the whole cache (and poll until it's done).
    //
    ccr = &((U032 *)AgpInfo(pDev).AGPChipsetMapping)[0x3];
    *ccr |= 0x1;
    while ((*ccr & 0x1) != 0)
        ;
}

static U032
RCC_GetAperSize(PHWINFO pDev, U032 handle)
{
    unsigned int apsize = osPciReadWord(handle, RCC_APER_SIZE); // aperture size
    switch ( (apsize & 0xE) >> 1 )   /* mask and shift bits 1-3 */
    {
        case 0x00:
            apsize = (  32 * 1024 * 1024);
            break;
        case 0x01:
            apsize = (  64 * 1024 * 1024);
            break;
        case 0x02:
            apsize = ( 128 * 1024 * 1024);
            break;
        case 0x03:
            apsize = ( 256 * 1024 * 1024);
            break;
        case 0x04:
            apsize = ( 512 * 1024 * 1024);
            break;
        case 0x05:
            apsize = (1024 * 1024 * 1024);
            break;
        case 0x06:
            apsize = (2024 * 1024 * 1024);
            break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

#if 1
    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciAndWord(handle, RCC_APER_SIZE, ~(0xe) /* apsize */);
    }
#endif

    return apsize;
}

static U032
RCC_GetAperBase(PHWINFO pDev, U032 handle)
{
    U032 handle_func0;
    U016 vendorID, deviceID;

    //
    // Note, for RCC the handle is for func 1, but BAR0/BAR1 are in func 0
    // space, so we have to temporarily generate a func 0 handle.
    //
    handle_func0 = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,
                                   AgpInfo(pDev).NBAddr.device,
                                   0x0,            // func 0
                                   &vendorID, &deviceID);

    return osPciReadDword(handle_func0, PCI_BASE_ADDRESS_0);
}

static U032
RCC_GetGartSize(PHWINFO pDev, U032 handle)
{
    unsigned int gart_size;
    gart_size = ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE - 1) / RM_PAGE_SIZE) * 4;
    gart_size += RM_PAGE_SIZE;     // this is for the 1st-level lookup
    return gart_size;
}

static U032 
RCC_EarlyInit(PHWINFO pDev, U032 handle)
{
    U032 handle_func0, physaddr;
    U016 vendorID, deviceID;

    if (AgpInfo(pDev).AGPChipset != CS_RCC_6585HE)
        return 1;

    //
    // Note, for RCC the handle is for func 1, but BAR0/BAR1 are in func 0
    // space, so we have to temporarily generate a func 0 handle.
    //
    handle_func0 = osPciInitHandle(AgpInfo(pDev).NBAddr.bus,
                                   AgpInfo(pDev).NBAddr.device,
                                   0x0,            // func 0
                                   &vendorID, &deviceID);

    // The RCC chipset registers, like AMD are mapped at BAR1.
    physaddr = (osPciReadDword(handle_func0, PCI_BASE_ADDRESS_1) & ~RM_PAGE_MASK);
    AgpInfo(pDev).AGPChipsetMapping = (VOID_PTR)osMapKernelSpace(physaddr,
                                                                 RM_PAGE_SIZE,
                                                                 FALSE);
    if (AgpInfo(pDev).AGPChipsetMapping == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, 
        "NVRM: *** Failed to map RCC 6585HE's AGP chipset registers\n");
        return 0;
    }
    return 1;
}

static VOID
RCC_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr)
{
    U032 i, *baseptr, tableptr;

    //
    // Convert the first allocated GART page into the first level GART lookup,
    // where each GART directory entry is just the subsequent 4k page.
    // We can derive the following entries, because we know the pages are
    // contiguous.
    //
    baseptr  = (U032 *)AgpInfo(pDev).AGPGartBase;
    tableptr = physaddr + RM_PAGE_SIZE;    // GART directory entries start on the 2nd page

    for (i = 0; i < ((AgpInfo(pDev).AGPLimit + 1) / BYTES_MAPPED_PER_PAGE); i++)
    {
        *baseptr = tableptr;

        tableptr += RM_PAGE_SIZE;   // next phys GART table address
        baseptr++;                  // next GART directory entry
    }
        
    //
    // Move the AGPGartBase past the first level GART page to where the GART
    // tables really begin (this makes nvagp_LoadGARTEntries() common).
    //
    (U008 *)AgpInfo(pDev).AGPGartBase += RM_PAGE_SIZE;
}

static VOID
RCC_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID)
{
    /* nothing to do... */
    return;
}

static VOID
RCC_DisableChipset(PHWINFO pDev, U032 handle)
{
    // paranoia
    if (!AgpInfo(pDev).AGPChipsetMapping)
        return;

    // enable GART directory cache
    // nv_printf("disabling GART directory cache\n");
    // osPciOrWord(handle, PCI_DEVICE_SPECIFIC + 0x72, 0x2);

    // enable GART table cache and errors
    ((unsigned char*)AgpInfo(pDev).AGPChipsetMapping)[0x2] &= ~(0x9);

    // base of GART
    ((unsigned int*)AgpInfo(pDev).AGPChipsetMapping)[0x1] = 0x0;

    // unmap RCC AGP registers
    osUnmapKernelSpace((void *) AgpInfo(pDev).AGPChipsetMapping, RM_PAGE_SIZE);
}

static VOID
RCC_FlushPostedWriteBuffer(PHWINFO pDev)
{
    volatile U008 *pwbcr;    // posted writebuffer control register

    // flush the write buffer and wait until it's completed
    pwbcr = &((U008 *)AgpInfo(pDev).AGPChipsetMapping)[0x14];
    *pwbcr |= 0x1;
    while ((*pwbcr & 0x1) != 0)
        ;
}
#endif

#ifdef SUPPORT_MICRON_AGP
BOOL 
Micron_IsChipset(PHWINFO pDev)
{
    switch (AgpInfo(pDev).AGPChipset) 
    {
        case CS_MICRON_SAMDDR:
            return TRUE;
    }
    return FALSE;
}

U032
Micron_GetChipset(PHWINFO pDev, U032 device)
{
    switch(device)
    {
        case 0x3120:
            return CS_MICRON_SAMDDR;
    }

    return 0;
}

static VOID Micron_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID Micron_FlushMappings(PHWINFO pDev, U032 handle);
static U032 Micron_GetAperSize(PHWINFO pDev, U032 handle);
static U032 Micron_GetAperBase(PHWINFO pDev, U032 handle);
static U032 Micron_GetGartSize(PHWINFO pDev, U032 handle);
static U032 Micron_EarlyInit(PHWINFO pDev, U032 handle);
static VOID Micron_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr);
static VOID Micron_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID);
static VOID Micron_DisableChipset(PHWINFO pDev, U032 handle);

VOID
Micron_SetupFuncs(U032 chipset, agp_chipset_funcs *funcs)
{
    funcs->enable_mappings = Micron_EnableMappings;
    funcs->flush_mappings  = Micron_FlushMappings;
    funcs->get_aper_size   = Micron_GetAperSize;
    funcs->get_aper_base   = Micron_GetAperBase;
    funcs->get_gart_size   = Micron_GetGartSize;
    funcs->earlyinit       = Micron_EarlyInit;
    funcs->fixup_gart      = Micron_FixupGart;
    funcs->apply_updates   = Micron_ApplyChipsetUpdates;
    funcs->disable_chipset = Micron_DisableChipset;
    funcs->initialized = 1;
    funcs->sba_capable = 0;
}

static VOID
Micron_EnableMappings(PHWINFO pDev, U032 handle, U032 physaddr)
{
    switch (AgpInfo(pDev).AGPChipset)    
    {
        case CS_MICRON_SAMDDR:
            osPciWriteDword(handle, INTEL_GART_BASE, physaddr); // base of GART
            osPciOrDword(handle,    INTEL_GART_CONTROL, 0x80);  // enable GTLB
            osPciOrDword(handle,    INTEL_CHIPSET_CONFIG, 0x08);  // enable global access
        default:
            break;
    }
}

static VOID
Micron_FlushMappings(PHWINFO pDev, U032 handle)
{
    // Invalidate the GTLB
    if (!handle)
        return;
    osPciAndDword(handle, INTEL_GART_CONTROL, ~(0x80));
    osPciOrDword(handle,  INTEL_GART_CONTROL, 0x80);
}


static U032
Micron_GetAperSize(PHWINFO pDev, U032 handle)
{
    unsigned int apsize;
    apsize = osPciReadWord(handle, INTEL_APER_SIZE); // aperture size
    switch (apsize)
    {
        case 0x3f:
            apsize = (4 * 1024 * 1024);
            break;
        case 0x3e:
            apsize = (8 * 1024 * 1024);
            break;
        case 0x3c:
            apsize = (16 * 1024 * 1024);
            break;
        case 0x38:
            apsize = (32 * 1024 * 1024);
            break;
        case 0x30:
            apsize = (64 * 1024 * 1024);
            break;
        case 0x20:
            apsize = (128 * 1024 * 1024);
            break;
        case 0x00:
            apsize = (256 * 1024 * 1024);
            break;
        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Intel bad apsize!\n");
            apsize = 0;
    }

    // I'm having problems under Linux if I go greater than 32 Megs...
    if (apsize > AGP_APERTURE_SIZE) 
    {
        apsize = AGP_APERTURE_SIZE;
        // XXX - translate new aperture size back to hw-encoding
        osPciWriteWord(handle, INTEL_APER_SIZE, 0x38 /* apsize */);
    }
    return apsize;
}

static U032
Micron_GetAperBase(PHWINFO pDev, U032 handle)
{
    return osPciReadDword(handle, PCI_BASE_ADDRESS_0);
}

static U032
Micron_GetGartSize(PHWINFO pDev, U032 handle)
{
    /* XXX - change 4 to sizeof(void *)?? */
    return ((AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE) * 4;
}

static U032 
Micron_EarlyInit(PHWINFO pDev, U032 handle)
{
    /* nothing to do... */
    return 1;
}

static VOID
Micron_FixupGart(PHWINFO pDev, U032 handle, U032 physaddr)
{
    /* nothing to do... */
}

static VOID
Micron_ApplyChipsetUpdates(PHWINFO pDev, U032 handle, U016 deviceID)
{
    /* nothing to do... */
}

static VOID
Micron_DisableChipset(PHWINFO pDev, U032 handle)
{
    /* nothing to do... */
}
#endif


// END OF CHIPSET-SPECIFIC CODE
// the rest of this file is generic AGP support

//
// Determine which chipset we're using (from available options)
// and initialize chipset-specific functions
//
RM_STATUS
NvInitChipset(PHWINFO pDev, U032 *handle, U032 *chipset)
{
    U016 vendor_id, device_id;

    AGP_SELECT_DEVICE(*handle, &vendor_id, &device_id);
    if (!*handle) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to get PCI handle\n");
        return RM_ERR_OPERATING_SYSTEM;
    }

#ifdef SUPPORT_INTEL_AGP
    // Check Intel ...
    if (vendor_id == PCI_VENDOR_ID_INTEL)
    {
        *chipset = Intel_GetChipset(pDev, device_id);
        Intel_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_AMD_AGP
    // Check AMD ...
    if (vendor_id == PCI_VENDOR_ID_AMD)
    {
        *chipset = AMD_GetChipset(pDev, device_id);
        AMD_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_VIA_AGP
    // Check Via ...
    if (vendor_id == PCI_VENDOR_ID_VIA)
    {
        *chipset = Via_GetChipset(pDev, device_id);
        Via_SetupFuncs(*chipset, agp_current);
    }
#endif

#ifdef SUPPORT_RCC_AGP
    // Check RCC/ServerWorks ...
    if (vendor_id == PCI_VENDOR_ID_RCC)
    {
        *chipset = RCC_GetChipset(pDev, device_id);
        RCC_SetupFuncs(*chipset, agp_current);
    }
#endif
#ifdef SUPPORT_MICRON_AGP
    // Check Micron ...
    if (vendor_id == PCI_VENDOR_ID_MICRON)
    {
        *chipset = Micron_GetChipset(pDev, device_id);
        Micron_SetupFuncs(*chipset, agp_current);
    }
#endif

    //
    // Set the AGP Cap offset.
    // By offsetting to get to the chipset's AGP_STATUS/AGP_COMMAND, more common
    // code is used, since accessing these registers is now chipset independent.
    // 
    NvSetCapIDOffset(pDev, *handle, &AgpInfo(pDev).AGPCapPtr);
    return RM_OK;
}


//
// If the AGP chipset is 2.0 compliant, we'll set the AGP rate in a
// chipset independent way.
// 
// This is called at boot time from NvUpdateAGPConfig based on a
// registry key, but could also be called in response to a ConfigSet
// called after boot up.
//
RM_STATUS
NvSetAGPRate(PHWINFO pDev, U032 handle, U032 *agprate)
{
    U032 agp_status, agp_command; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    // 
    // If AGP FW's are already enabled, avoid trying to change the
    // AGP rate, since this can cause a hang.
    //
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE) ==
        NV_PBUS_PCI_NV_19_AGP_COMMAND_FW_ENABLE_ON)
        return RM_ERROR;

    //
    // Compare the rate with what the chipset and NV can do
    //
    agp_status = osPciReadDword(handle, AGP_STATUS);
    *agprate &= agp_status;
    *agprate &= REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_RATE);

    /* we now have a mask of acceptable agp rates, but this may 
     * be more than just one rate. Choose the highest rate of
     * the available, and set the chipsets to that rate
     */
    if (*agprate & 0x4) *agprate = 0x4;
    else 
    if (*agprate & 0x2) *agprate = 0x2;
    else 
    if (*agprate & 0x1) *agprate = 0x1;

    if (*agprate)
    {
       // Looks to be a valid rate for the chipset and NV, set it.
        agp_command = osPciReadDword(handle, AGP_COMMAND);
        agp_command &= ~0xF;    // clear the current rate
        agp_command |= *agprate;
        osPciWriteDword(handle, AGP_COMMAND, agp_command);

        FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, *agprate);
    }

    return RM_OK;
}

RM_STATUS
NvSetAGPFastwrites(PHWINFO pDev, U032 handle, U032 agpfw)
{
    U032 agp_status, agp_command; 
    INTERRUPT_SETUP

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    //
    // Compare the fastwrite bit with what the chipset and NV can do
    //
    agp_status = osPciReadDword(handle, AGP_STATUS);
    agpfw &= (agp_status >> 0x4);
    agpfw &= REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_FW);

    agp_command = osPciReadDword(handle, AGP_COMMAND);
    agp_command &= ~0x10;    // clear the current fw bit
    agp_command |= (agpfw << 0x4);

    CLI

    osPciWriteDword(handle, AGP_COMMAND, agp_command);
    FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_FW_ENABLE, agpfw);

    STI

    return RM_OK;
}

RM_STATUS
NvSetAGPSideBand(PHWINFO pDev, U032 handle, U032 agpsba)
{
    U032 agp_status, agp_command; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    // return, if the capability offset for the chipset is NULL
    if (AgpInfo(pDev).AGPCapPtr == 0x0)
        return RM_ERROR;

    agp_status = osPciReadDword(handle, AGP_STATUS);
    agpsba &= (agp_status >> 0x9);

    //
    // If we're turning on SBA (and the chipset supports it), make sure it's
    // also in our AGP_STATUS before we enable ourselves.
    //
    if (agpsba &&
        (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA) == NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE)) {
        U032 strapbits;

        // Write the STRAP_AGP_SBA enable bit
        strapbits  = REG_RD32(NV_PEXTDEV_BOOT_0);
        strapbits &= ~(DRF_MASK(NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA) <<
                       DRF_SHIFT(NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA));
        strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_SBA, _ENABLED);
        REG_WR32(NV_PEXTDEV_BOOT_0, (strapbits |
                                     DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED)));

        // Read it back to make sure the write's completed
        strapbits = (volatile)REG_RD32(NV_PEXTDEV_BOOT_0);

        // If AGP_STATUS still indicates SBA isn't supported, then it's not
        if (REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA) == NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NvSetAGPSideBand: SBA isn't supported\n");
            return RM_ERROR;
        }
    }

    // mask and set the chipsets SBA bit
    agp_command  = osPciReadDword(handle, AGP_COMMAND);
    agp_command &= ~(DRF_MASK(NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE) <<
                     DRF_SHIFT(NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE));
    agp_command |= DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, agpsba);
    osPciWriteDword(handle, AGP_COMMAND, agp_command);

    // set our SBA enable bit
    FLD_WR_DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, agpsba);

    return RM_OK;
}

//
// Determine if any updates are needed to the AGP rate or state of AGP fastwrites.
//
VOID
NvUpdateAGPConfig(PHWINFO pDev)
{
    U032 handle;
    U032 agprate, agpfw, agpfwstrap, agpsba;
    U016 vendorID, deviceID;

    // return if AGP is not enabled
    if (REG_RD_DRF(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE) == NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF)
        return;

    AGP_SELECT_DEVICE(handle, &vendorID, &deviceID);
    if (!handle)
        return;

    /* this may be our first entry point under 9x/w2k, so
     * if we're not initialized, call NvInitChipset(), which
     * will only detect the chipset and set up our data structures.
     */
    if (!agp_current->initialized) 
    {
        U032 dummy;
        NvInitChipset(pDev, &handle, &dummy);
    }

    //
    // Before applying the chipset updates, look for a registry key that changes
    // the strap bits. This impacts what apply_updates will do and any registry
    // overrides (but, doesn't affect normal boot time AGP configuration).
    // 
    if (IsNV10orBetter(pDev) &&
        (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                           "EnableAGPFWStrap", &agpfwstrap) == RM_OK)) {
        U032 strapbits;
        strapbits  = REG_RD32(NV_PEXTDEV_BOOT_0);
        strapbits &= ~(DRF_MASK(NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR) <<
                       DRF_SHIFT(NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR));
        if (agpfwstrap)
            strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_FASTWR, _ENABLED);
        else
            strapbits |= DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_AGP_FASTWR, _DISABLED);

        // OR-in the _STRAP_OVERWRITE_ENABLED bit before writing
        REG_WR32(NV_PEXTDEV_BOOT_0, (strapbits |
                                     DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED)));
    }

    agp_current->apply_updates(pDev, handle, deviceID);

    // 
    // After applying any chipset updates and/or workarounds, see if there's an
    // AGP command overrides in the registry. We've seen where the Via chipset
    // driver later resets the AGP rate, so this key may not work there.
    //

    // set the AGP transfer rate
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                               "ReqAGPRate",  &agprate) == RM_OK) {
        NvSetAGPRate(pDev, handle, &agprate);
    }

    // set/clear the AGP sideband addressing bit
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                "EnableAGPSBA", &agpsba) == RM_OK) {
        NvSetAGPSideBand(pDev, handle, agpsba);
    }

    if (IsNV11orBetter(pDev)) {
        U032 agpfw_adis;

        // allows switching between fullspeed FW's and NV10-style compat mode
        if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                   "DisableAGPFWDisconnect", &agpfw_adis) == RM_OK)
            FLD_WR_DRF_NUM(_PBUS, _DEBUG_1, _AGPFW_ADIS, agpfw_adis);
    }

    // set/clear the AGP fastwrite bit
    if (OS_READ_REGISTRY_DWORD(pDev, RM_REGISTRY_AGP_BASE_PATH,
                                "EnableAGPFW", &agpfw) == RM_OK) {
        NvSetAGPFastwrites(pDev, handle, agpfw);
    }
}


//
// Return the AGP base/limit from the chipset. This function assumes
// the aperture base and size can be determined from PCI BAR0 in config
// space.
//
RM_STATUS
NvGetAGPBaseLimit(PHWINFO pDev, U032 *base, U032 *limit)
{
    U032 aper0, apoffset, mask;
    U032 size;
    U032 handle;

#ifdef _WIN64
    //
    // XXX This code is specific to the 460GX chipset that's used with
    // Itanium with WIN64.
    //
    // It's possible NvSetBusDeviceFunc() may now be able to detect the
    // location of the Northbridge, rather than hardcode the bus/device/func
    // (talking to one of the Intel BIOS guys, the device/func are probably
    // correct, but it can be on a different bus.
    //
    U016 vendorID, deviceID;
    U032 aper1, apsize;
    U008 bus, device, func;

    //
    // Temporary hack to get AGP working on the 460GX
    // (hardcode the NB location at Bus 4, Device 14, Func 1)
    //
    // At some point, we'll want to see if this works (when
    // we're feeling daring with a little time to spare).
    //
    //     NvSetBusDeviceFunc(pDev, &bus, &device, &func);
    //
    bus    = 0x4;
    device = 0x14;
    func   = 0x1;
    handle = osPciInitHandle(bus, device, func, &vendorID, &deviceID);

    if ((vendorID != 0x8086) || ((deviceID != 0x84EA) && (deviceID != 0x84E2))) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: didn't find expected 460GX vendor/device ID's\n");
        return RM_ERROR;
    }

    //
    // read APSIZE holds the size (limit + 1) and bit 3 determine which
    // PCI offset holds the Aperture base.
    //
    apsize = osPciReadByte(handle, 0xA2);
    switch (apsize & 0x7) {
    case 0x1:   // 256 Mb
    case 0x2:   // 1 Gb
        break;
    case 0x4:   // 32GB
    default :
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: too big an Aperture size\n");
        break;
    }
    
    if (apsize & 0x8)
        apoffset = 0x98; // use BAPBASE, which are bits 0x98->0x9F
    else
        apoffset = 0x10; // use APBASE, which are bits 0x10->0x17

    aper0 = osPciReadDword(handle, apoffset);
    if ((aper0 & 0x6) == 0x4)
        aper1 = 0x0;
    else
        aper1 = osPciReadDword(handle, apoffset + 0x4);

    // 
    // If the upper 32bit's of the aperture are set, we're in trouble.
    // Because we're a 32bit device, this better be 0's, since we won't
    // be able to generate the proper address.
    //
    if (aper1) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Aperture base above 4GB\n");
        return RM_ERROR;
    }

#else
    U016 dummy;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return RM_ERROR;

    apoffset = PCI_BASE_ADDRESS_0;

    // read BAR0 to get the base

    aper0 = osPciReadDword(handle, apoffset);
#endif

    *base = aper0 & 0xFFFFF000;

    // write -1 and then read BAR0 to get the size mask
    osPciWriteDword(handle, apoffset, 0xFFFFFFFF);
    mask = osPciReadDword(handle, apoffset);
    *limit = (mask & 0xFFFFF000) ^ 0xFFFFFFFF;

    // restore original aperture value
    osPciWriteDword(handle, apoffset, aper0);

    // limit should be a power of 2 (i.e. size has one bit set)
    size = *limit + 1;    
    if ((size & (size - 1)) != 0)
        return RM_ERROR;

    return RM_OK;
}


VOID
NvEnableAGP(PHWINFO pDev)
{
    U032 handle;
    unsigned short dummy;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle) return;

    /* set AGP_ENABLE bit */
    osPciOrWord(handle, AGP_COMMAND, 0x100);
}

VOID
NvDisableAGP(PHWINFO pDev)
{
    U032 handle;
    unsigned short dummy;
                
    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle) return;

    /* clear AGP_ENABLE bit */
    osPciAndWord(handle, AGP_COMMAND, ~0x100);
}

/*
 * Basic AGP config/turn-on. 
 * Let chipset-specific code deal with workarounds in update.
 * Fast-write "stuff" is there.
 */
VOID
NvSetupAGPConfig(PHWINFO pDev)
{
    unsigned int do_sba, rq_depth, chipset_rq_depth;
    unsigned short dummy;
    U032 agprate;
    U032 handle;
    INTERRUPT_SETUP
                
    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle) return;

    //
    // At init time, an AGP rate has not been established, so max it out.
    // If this needs to be downgraded, it'll be done in the apply_updates
    // routine.
    //
    agprate = 0x7;
    if (RM_OK != NvSetAGPRate(pDev, handle, &agprate))
        return;

    /* setup AGP state */
    // Can we do side-band addressing (we assume the chipset can do SBA)??
    do_sba = REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_SBA);
    do_sba &= agp_current->sba_capable;
    if (do_sba) {
        osPciOrWord(handle,  AGP_COMMAND, 0x0200);
    } else {
        osPciAndWord(handle, AGP_COMMAND, ~0x0200);    // make sure it's off
    }

    //
    // Determine the maximum AGP request depth, our value must be less
    // than or equal to the maximum the chipset can handle.
    //
    rq_depth         = REG_RD_DRF(_PBUS, _PCI_NV_18, _AGP_STATUS_RQ);
    chipset_rq_depth = osPciReadDword(handle, AGP_STATUS) >> 24;
    if (chipset_rq_depth < rq_depth)
        rq_depth = chipset_rq_depth;

    CLI
    REG_WR32(NV_PBUS_PCI_NV_19, DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_RQ_DEPTH, rq_depth) |
                                DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_AGP_ENABLE, 0x1)    |
                                DRF_NUM(_PBUS, _PCI_NV_19, _AGP_COMMAND_DATA_RATE, agprate) |
                                ((do_sba) ? DRF_DEF(_PBUS, _PCI_NV_19, _AGP_COMMAND_SBA_ENABLE, _ON) : 0) |
                                0);
    STI
    flush_cache();
}

static RM_STATUS 
nvagp_AllocAGPBitmap
(
    PHWINFO pDev,
    U032   Size,    // in pages
    U032  *Offset
)
{
    U008 *GARTBitmap = (U008 *)AgpInfo(pDev).AGPGartBitmap;
    U032 agp_pages = (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE;
    U032 i, j;

    for (i = 0; i < agp_pages; i++)
    {
        if (!GARTBitmap[i >> 3])
        {
            i += 7;
        }
        else if (GARTBitmap[i >> 3] & BIT(i & 7))
        {
            //
            // Search for string of 1's the length of the block.
            //
            j = 0;
            do
            {
                if ((++i >= agp_pages) || (++j >= Size))
                    break;
            }
            while (GARTBitmap[i >> 3] & BIT(i & 7));
            if (j == Size)
            {
                //
                // Score, a block was found.
                //
                *Offset = i - j;
                while (j--)
                {
                    //
                    // Mark AGP memory as allocated.
                    //
                    i--;
                    GARTBitmap[i >> 3] &= ~BIT(i & 7);
                }
                return (RM_OK);
            }
        }
    }
    return (RM_ERR_NO_FREE_MEM);
}


static VOID 
nvagp_FreeAGPBitmap
(
    PHWINFO pDev,
    U032 Offset,
    U032 PageCount
)
{
    U008 *GARTBitmap = (U008 *)AgpInfo(pDev).AGPGartBitmap;

    while (PageCount--)
    {
        //
        // Mark AGP memory as free.
        //
        GARTBitmap[Offset >> 3] |= BIT(Offset & 7);
        Offset++;
    }
}

static RM_STATUS 
nvagp_LoadGARTEntries
(
    PHWINFO pDev,
    VOID *pAddress,
    U032 PageCount,
    U032 Index
)
{
    U032 i;
    VOID *ucptr;    // uncached ptr
    U032 pagePhysicalAddr;
    U032 *GARTEntry = ((U032 *)AgpInfo(pDev).AGPGartBase) + Index;
    RM_STATUS status;

    for (i = 0; i < PageCount; i++)
    {
        status = osGetAGPPhysAddr( pDev, (VOID *) ((U008 *)pAddress + (i << RM_PAGE_SHIFT)), &pagePhysicalAddr);
        if (status != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NULL physical address for DMA page\n");
            return RM_ERR_NO_FREE_MEM;
        }

        // As part of loading the GART entry, create a temporary uncached mapping
        // to clean each page (must do this page by page, since the memory won't
        // be contiguous) and then free the mapping.
        //
        // It seems we can't be certain, the cache is clean w.r.t. this page, so
        // by zeroing it uncached, we hopefully force everything out preventing
        // any later writebacks to corrupt our data.

        ucptr = osMapKernelSpace(pagePhysicalAddr, RM_PAGE_SIZE, FALSE);
        if (ucptr == NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Unable to create uncached mapping\n");
            return RM_ERR_NO_FREE_MEM;
        }

        // clean the page
        osMemSet(ucptr, 0, RM_PAGE_SIZE);
        *(U032 *)ucptr = 0x0;

        // free the mapping
        osUnmapKernelSpace(ucptr, RM_PAGE_SIZE);

#ifdef SUPPORT_MICRON_AGP
        if (Micron_IsChipset(pDev))
            // load the GART
            GARTEntry[i] = (pagePhysicalAddr >> RM_PAGE_SHIFT) | 0x80000000;
        else 
#endif
            // load the GART
            GARTEntry[i] = (pagePhysicalAddr & ~RM_PAGE_MASK) | 1;
    }

#ifdef SUPPORT_RCC_AGP
    // Make sure to flush the posted write buffer
    if (RCC_IsChipset(pDev))
        RCC_FlushPostedWriteBuffer(pDev);
#endif
    flush_cache();
    return RM_OK;
}

static RM_STATUS 
nvagp_MapAGPAperture
(
    PHWINFO pDev,
    U032 clientClass,
    U032 index,
    U032 pagecount,
    VOID **pMdl,
    VOID **pAddress
)
{
    VOID *kernAddr;
    RM_STATUS rmStatus = RM_OK;

    // Here's the kernel mapping to the AGP Aperture
    kernAddr = (VOID *)((U008 *)AgpInfo(pDev).AGPLinearStart +
                        (index << RM_PAGE_SHIFT) + ((size_t)*pAddress & RM_PAGE_MASK));

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = kernAddr;
            pMdl = NULL;           // no MDL needed for this mapping
            break;

        case NV01_ROOT_USER:
            // create the user mapping to these pages
            *pMdl = *pAddress;  // linux will use this, but NT will ignore it
            *pAddress = osMapUserSpace(kernAddr, pMdl, (pagecount << RM_PAGE_SHIFT), MAP_WRITECOMBINE);
            if (*pAddress == (VOID *)NULL)
            {
                return RM_ERROR;
            }
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    // let's also scrub from the kernel view, to make sure
    // everything is consistent.
    osMemSet(kernAddr, 0, pagecount << RM_PAGE_SHIFT);
    *(U032 *)kernAddr = 0x0;

    return rmStatus;
}

static VOID 
nvagp_UnmapAGPAperture
(
    PHWINFO pDev,
    VOID *pAddress,
    U032 Index,
    PAGP_MEM_INFO pMemInfo
)
{
    U032 *GARTEntry = (U032 *)AgpInfo(pDev).AGPGartBase;
    U016 dummy;
    U032 handle;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return;

    while (pMemInfo->PageCount--)
    {
        // invalidate the GART entries
        GARTEntry[Index++] = 0x0;
    }

#ifdef SUPPORT_RCC_AGP
    // Make sure to flush the posted write buffer
    if (RCC_IsChipset(pDev))
        RCC_FlushPostedWriteBuffer(pDev);
#endif
    flush_cache();

    //
    // If we're passed a non-NULL MDL, this means a user mapping was
    // created and needs to be cleaned up
    //
    if (pMemInfo->pMdl)
    {
        // free the user mapping
        osUnmapUserSpace(pAddress, pMemInfo->pMdl);
        pMemInfo->pMdl = NULL;
    }

    agp_current->flush_mappings(pDev, handle);

}

RM_STATUS NvAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   PageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    U032          Index;
    PAGP_MEM_INFO pMemInfo;
    U032          rmStatus = RM_ERROR;

    if (!pDev) {
        return RM_ERR_NO_FREE_MEM;  // AGP not initialized, PCI card?
    }

    if (!AgpInfo(pDev).AGPLinearStart) {
        return RM_ERR_NO_FREE_MEM;  // true for PCI cards
    }

    // Since there will be some cleanup needed on the free side
    // create a struct that hooks into VOID * in CLI_MEMORY_INFO

    rmStatus = osAllocMem((VOID **)&pMemInfo, sizeof(AGP_MEM_INFO));
    if (rmStatus != RM_OK)
    {
        return rmStatus;
    }

    // Alloc the pages for the caller.
    //
    // Don't use osAllocMem, since it'll write a DEBUG pattern to the buffer
    // via a cached mapping. Just use the underlying NT routine ... using the
    // non-paged pool guarantees nothing needs to be done in osLockUserMem.
 
    rmStatus = osAllocPool(pAddress, PageCount << RM_PAGE_SHIFT);
    if (rmStatus != RM_OK)
        {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    pMemInfo->SysAddr   = *pAddress;      // keep the original system addr
    pMemInfo->PageCount = PageCount;

    // Alloc from the GART bitmap for the number of pages we'll need.
    rmStatus = nvagp_AllocAGPBitmap(pDev, PageCount, &Index);
    if (rmStatus != RM_OK)
    {
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

    pMemInfo->Offset = Index;

    // Load up the GART entries with the physical addresses
    rmStatus = nvagp_LoadGARTEntries(pDev, *pAddress, PageCount, Index);
    if (rmStatus != RM_OK)
    {
        nvagp_FreeAGPBitmap(pDev, Index, PageCount);
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

    // Finally, setup a user/kernel mapping within the Aperture
    rmStatus = nvagp_MapAGPAperture(pDev,
                                ClientClass,
                                Index,
                                PageCount,
                                &pMemInfo->pMdl,
                                pAddress);
   if (rmStatus != RM_OK)
   {
        nvagp_FreeAGPBitmap(pDev, Index, PageCount);
        osFreePool(pMemInfo->SysAddr);
        osFreeMem(pMemInfo);
        return rmStatus;
    }

#ifdef _WIN64
   DBG_PRINT_STRING_VAL64(DEBUGLEVEL_TRACEINFO, "NVRM: alloc user addr    ", *(U064*)pAddress);
#else
   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: alloc user addr    ", *(U032*)pAddress);
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: mapped to agp addr ", (U032)AgpInfo(pDev).AGPPhysStart + (Index << RM_PAGE_SHIFT));

    *pMemData = (VOID *)pMemInfo;

    return RM_OK;
}

//
// osFreeAGPPages - Free a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  MemoryType - memory pool
//  *pMemData  - pointer to private per-alloc data
//
RM_STATUS NvFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    PAGP_MEM_INFO pMemInfo = (PAGP_MEM_INFO)pMemData;

    if (!pDev)
        return RM_ERROR;        // this would be a misguided free

    if (!AgpInfo(pDev).AGPLinearStart)
        return RM_ERROR;        // this would be a misguided free

    nvagp_FreeAGPBitmap(pDev, pMemInfo->Offset, pMemInfo->PageCount);

    // reset the GART entries, free the mapping and flush the GTLB
    nvagp_UnmapAGPAperture(pDev, *pAddress, pMemInfo->Offset, pMemInfo);

    // free the original system pages
    osFreePool(pMemInfo->SysAddr);

    // free our data struct that kept track of this mapping
    osFreeMem(pMemInfo);

    return RM_OK;
}


//
// Here's our attempt to configure AGP on our own for NT4.
//
// First, we'll attempt to recognize the chipset to determine if we know how to
// program it. Next, we'll create a bitmap that's used to alloc/free slots from
// the GART.
//
BOOL RmInitAGP
(
    PHWINFO pDev
)
{
    VOID *tmpATT;           // temporary holder of the GART
    U032 i, status;
    U032 physaddr, apsize, apbase;
    U032 handle;
    U032 chipset = CS_UNKNOWN;
    U008 *pBitmap;
    U032 gart_size, gart_bitmap_size;

    // verify we're an AGP graphics card
    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) != NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
    {
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    // don't initialize AGP if it's already setup
    // moved after the AGP card check so we know we should be
    // safe for the agp_restore_mappings() if needed.
    if (agp_ref_count) 
    {
        agp_ref_count++;
        return 0;
    }

    NvInitChipset(pDev, &handle, &chipset);

    if (chipset == CS_UNKNOWN)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unrecongnized AGP chipset\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    /* if AGP is already turned on, turn it off while we configure it */
    NvDisableAGP(pDev);

    AgpInfo(pDev).AGPChipset = chipset;

    if (!agp_current->earlyinit(pDev, handle))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** AGP early init failed\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    // get aperture info
    apsize = agp_current->get_aper_size(pDev, handle);
    apbase = agp_current->get_aper_base(pDev, handle);

    if (!apsize || !apbase)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot find Aperture Base or Size\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    AgpInfo(pDev).AGPPhysStart = apbase & ~RM_PAGE_MASK;
        
    // Obtain a mapping (already marked write-combined) to the AGP Aperture
    // This represents the base of our allocations.
    AgpInfo(pDev).AGPLinearStart = 
                (VOID_PTR) osMapKernelSpace(AgpInfo(pDev).AGPPhysStart, apsize, MAP_WRITECOMBINE);
    if (AgpInfo(pDev).AGPLinearStart == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot map the AGP Aperture WriteCombined\n");
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    AgpInfo(pDev).AGPLimit = apsize - 1;

    //
    // Allocate space for the GART.
    //
    // This memory needs to be contiguous, 4K (RM_PAGE_SIZE) aligned and locked
    // down for the page tables. My best guess at what to use is __dma_get_pages()
    // for this. If on AMD, we'll add another page for their first level table.
    //
    gart_size = agp_current->get_gart_size(pDev, handle);

    /* this is num_pages / 8 bits for bitmasks */
    gart_bitmap_size = (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / (8 * RM_PAGE_SIZE); /* don't want the lookup here */

    tmpATT = osAllocContigPages(gart_size);
    if (tmpATT == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to allocate GART\n");
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    // Get the physical addr to be loaded into the chipset
    physaddr = osGetKernPhysAddr(tmpATT); 
    physaddr = ((physaddr + (RM_PAGE_SIZE - 1)) & ~RM_PAGE_MASK); // if it's not page aligned

    // Mark these pages uncached, so we can freely update the GART
    AgpInfo(pDev).AGPGartBase = (VOID_PTR) osMapKernelSpace(physaddr, gart_size, FALSE);

    if (AgpInfo(pDev).AGPGartBase == (VOID_PTR)NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to create uncached mapping for the GART\n");
        osFreeContigPages(tmpATT);
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    osMemSet((void *)AgpInfo(pDev).AGPGartBase, 0, gart_size); /* Clear the ram out, no junk to the user */
    flush_cache();

    // allow chipset-specific modifications to gart structuring (amd...)
    agp_current->fixup_gart(pDev, handle, physaddr);

    //
    // Allocate the GART bitmap, which we'll use to manage AGP allocations.
    // Each bit in the bitmap represents a 4K mapping.
    //
    status = osAllocMem((VOID **)&AgpInfo(pDev).AGPGartBitmap, gart_bitmap_size);

    if (status != RM_OK) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Unable to allocate GART bitmap\n");
        /* osUnmapIoSpace((VOID *)AgpInfo(pDev).AGPGartBase, gart_size); */
        osFreeContigPages(tmpATT);
        AgpInfo(pDev).AGPLinearStart = 0;
        AgpInfo(pDev).AGPLimit = 0;
        return FALSE;
    }

    pBitmap = (char *)AgpInfo(pDev).AGPGartBitmap;
    for (i = 0; i < gart_bitmap_size; i++)
        pBitmap[i] = 0xFF;


    //
    // Program up the rest of the chipset.
    //
    agp_current->enable_mappings(pDev, handle, physaddr);

    /* setup chipset-specific features */
    NvSetupAGPConfig(pDev);

    /* enable chipset-specific overrides */
    NvUpdateAGPConfig(pDev);

    /* now that everything's configured, turn it on */
    NvEnableAGP(pDev);

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP Phys Base:      ", 
        (VOID *)AgpInfo(pDev).AGPPhysStart);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP Linear Base:    ", 
        (VOID *)AgpInfo(pDev).AGPLinearStart);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP GART Base:      ", 
        (VOID *)AgpInfo(pDev).AGPGartBase);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: AGP GART Bitmap:    ", 
        (VOID *)AgpInfo(pDev).AGPGartBitmap);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: # of GART Mappings: ", 
        (AgpInfo(pDev).AGPLimit + RM_PAGE_SIZE) / RM_PAGE_SIZE);

    // looks all good, count this as a "connected device"
    agp_ref_count++;
    AGP_SAVE_PDEV(pDev);

    return 0;

} // end of RmInitAGP()



BOOL RmTeardownAGP
(
    PHWINFO pDev
)
{
    unsigned short dummy;
    U032 handle;

    AGP_SELECT_DEVICE(handle, &dummy, &dummy);
    if (!handle)
        return 0;

    agp_ref_count--;

    // Don't tear down AGP if someone is still using it
    // (like a second X Server)
    if (agp_ref_count != 0) 
        return 0;

    agp_current->disable_chipset(pDev, handle);
    NvDisableAGP(pDev);

    if (AgpInfo(pDev).AGPLinearStart) 
        osUnmapKernelSpace( (void *) AgpInfo(pDev).AGPLinearStart, 
            AgpInfo(pDev).AGPLimit + 1);
    AgpInfo(pDev).AGPLinearStart = 0;

    if (AgpInfo(pDev).AGPGartBase) 
        osFreeContigPages( (void *) AgpInfo(pDev).AGPGartBase);
    AgpInfo(pDev).AGPGartBase = 0;

    return 0;
}


//
// Return the Bus, Device, Func numbers of the Northbridge.
//
// We determine this by looking for the another AGP device that's not us
// and is a bridge device (so, we hopefully avoid an integrated graphics
// device). We should check for a host bridge device where the subclass
// is PCI_SUBCLASS_BR_HOST, but this doesn't work on the RCC chipset.
//
BOOL
NvSetBusDeviceFunc
(
    PHWINFO pDev
)
{
        PRMINFO pRmInfo = (PRMINFO)pDev->pRmInfo;
    U008 bus, device, func;
    U032 handle, cap_offset;
    U016 vendorID, deviceID;
    RM_STATUS status;

    // return it, if we've got it already
    if (pRmInfo->AGP.NBAddr.valid)
        return TRUE;

    // we're checking all the device/funcs for the first 5 buses
    for (bus = 0; bus < 5; bus++)
    {
        for (device = 0; device < PCI_MAX_DEVICES; device++)
        {
            for (func = 0; func < PCI_MAX_FUNCTION; func++)
            {
                // read at bus, device, func
                handle = osPciInitHandle(bus, device, func, &vendorID, &deviceID);
                if (!handle)
                    break;

                if (vendorID == PCI_INVALID_VENDORID)
                    break;           // skip to the next device

                if (REG_RD32(NV_PBUS_PCI_NV_0) == (U032)(deviceID << 16 | vendorID))
                    break;           // skip over ourselves

                if (osPciReadByte(handle, 0xB) != PCI_CLASS_BRIDGE_DEV)
                    break;           // not a bridge device

                // look for the AGP Capability ID
                status = NvSetCapIDOffset(pDev, handle, &cap_offset);
                if (status == RM_OK)
                {
                    // Found it
                    AgpInfo(pDev).NBAddr.bus    = bus;
                    AgpInfo(pDev).NBAddr.device = device;
                    AgpInfo(pDev).NBAddr.func   = func;
                    AgpInfo(pDev).NBAddr.valid  = 0x1;
                    return TRUE;
                }

                if ((osPciReadDword(handle, 0xE) & PCI_MULTIFUNCTION) == 0)
                    break;        // no need to cycle through functions
            }
        }
    }

    // This is bad, we didn't find the NB device (assume bus0/device0/func0)
    AgpInfo(pDev).NBAddr.bus    = 0x0;
    AgpInfo(pDev).NBAddr.device = 0x0;
    AgpInfo(pDev).NBAddr.func   = 0x0;
    AgpInfo(pDev).NBAddr.valid  = 0x1;
    DBG_BREAKPOINT();

    return FALSE;
}

RM_STATUS
NvSetCapIDOffset
(
    PHWINFO pDev, 
    U032 handle,
    U032 *cap_offset
)
{
    U008 cap_next; 
    U032 agp_caps; 

    if (handle == 0)
        return RM_ERROR;    // handle hasn't been initialized

    if ((osPciReadDword(handle, 0x4) & 0x00100000) == 0)
        return RM_ERROR;    // chipset doesn't support capability ptrs

    // find the PCI offset for the AGP Cap ID
    cap_next = osPciReadByte(handle, PCI_CAPABILITY_LIST);
    while (cap_next)
    {
        agp_caps = osPciReadDword(handle, cap_next);
        if ((agp_caps & 0xFF) == 0x2)
            break;      // found the AGP Cap ID
        cap_next = (U008)((agp_caps >> 8) & 0xFF);            
    }

    if (cap_next == 0)
        return RM_ERROR;    // didn't find the AGP capid

    *cap_offset = cap_next;
    return RM_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\client.c ===
/******************************************************************************
*
*   File:  client.c
*
*   Description:
*       This file contains the functions necessary to manage NV Resource
*   Manager client information.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

// TO DO: ClientInstance is a global!!!!  Can we rely on it's being SMP safe??
//        i.e. can two IOCTLs be processing simultaneously?

// This file is chip independent AND OS independent

#include <nvrm.h>
#include <client.h>
#include <nvos.h>
#include <nvarch.h>

//
// Return a "unique" client handle by incrementing our clientHandle variable.
// We cannot let this freely range over all possible values, since it would
// eventually match an already existing handle (looping after 1MB hopefully
// will be enough).
//
static U032 clientHandle = 0xc1d00000;

RM_STATUS CliAddClient(
    U032 *phClient,
    U032 hClass
)
{
    U032 i;

    // verify class is a root object
    switch (hClass)
    {
        case NV01_ROOT:
        case NV01_ROOT_USER:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // register the client
    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if ( ! clientInfo[i].InUse)
        {
            // create a unique client handle
            clientHandle = ((clientHandle + 1) % 0x100000) ? (clientHandle + 1) : 0xc1d00000;
            // mark it busy asap
            clientInfo[i].InUse         = TRUE;

            // initialize the client
            clientInfo[i].Handle           = clientHandle;
            clientInfo[i].Class            = hClass;
            clientInfo[i].ProcID           = i;
            clientInfo[i].ProcContext      = 0;
            clientInfo[i].FifoCount        = 0;
            clientInfo[i].CliDmaList       = NULL;
            clientInfo[i].CliMemoryList    = NULL;
            clientInfo[i].CliEventList     = NULL;
            clientInfo[i].CliHeapOwnerList = NULL;    //added by Chuck Moidel

            // set the client instance and return the client handle
            CliSetClientInstance(i);
            *phClient = clientInfo[i].Handle;

            return RM_OK;
        }
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddClient()

BOOL CliDelClient()
{
    clientInfo[ClientInstance].InUse = FALSE;

    return TRUE;

} // end of CliDelClient()

BOOL CliGetClientHandle(
    U032 *phClient
)
{
    if (clientInfo[ClientInstance].InUse == TRUE)
    {
        *phClient = clientInfo[ClientInstance].Handle;
        return TRUE;
    }

    return FALSE;

} // end of CliGetClientHandle()

BOOL CliGetClientIndex(
    U032 hClient,
    U032 *pIndex
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            *pIndex = i;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetClientIndex()

BOOL CliSetClientContext(
    U032 hClient
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            ClientInstance = i;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetClientContext()

BOOL CliSetClientInstance(
    U032 instance
)
{
    if (instance < NUM_CLIENTS)
    {
        ClientInstance = instance;
        return TRUE;
    }

    return TRUE;

} // end of CliSetClientInstance()

BOOL CliSetClientAppHandle(
    U032  hClient,
    void *appHandle
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            clientInfo[i].AppHandle = appHandle;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetClientAppHandle()

BOOL CliGetClientAppHandle(
    U032   hClient,
    void **appHandle
)
{
    U032 i;

    for (i = 1; i < NUM_CLIENTS; i++)
    {
        if (clientInfo[i].InUse && clientInfo[i].Handle == hClient)
        {
            *appHandle = clientInfo[i].AppHandle;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetClientAppHandle()


RM_STATUS CliAddDevice(
    U032 hClient,
    U032 hDevice,
    U032 hClass
)
{
    U032 client, device;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate device
    if (!CliIsUniqueHandle(hDevice, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    if (!CliGetPhysicalDevice(hClass, &device))
    {
        return RM_ERR_BAD_CLASS;
    }

    // make sure we have a device list
    if ( ! clientInfo[ClientInstance].CliDeviceList)
        if ( ! CliMakeDeviceList(ClientInstance, NUM_DEVICES, &clientInfo[ClientInstance].CliDeviceList))
            goto failed;

    // initialize the device
    if ( ! clientInfo[ClientInstance].CliDeviceList[device].InUse)
    {
        clientInfo[ClientInstance].CliDeviceList[device].InUse          = TRUE;
        clientInfo[ClientInstance].CliDeviceList[device].Handle         = hDevice;
        clientInfo[ClientInstance].CliDeviceList[device].Client         = hClient;
        clientInfo[ClientInstance].CliDeviceList[device].Class          = hClass;
        clientInfo[ClientInstance].CliDeviceList[device].DevMemoryList  = NULL;
        clientInfo[ClientInstance].CliDeviceList[device].AppHandle      = NULL;
        clientInfo[ClientInstance].CliDeviceList[device].DevFifoList    = NULL;
        return RM_OK;
    }

 failed:
    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDevice()


BOOL CliDelDevice(
    U032 hDevice
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        // delete the dynamically allocated device fifo list
        if (pDevice->DevFifoList)
        {
            osFreeMem(pDevice->DevFifoList);
            pDevice->DevFifoList = NULL;
        }

        // mark the device as unused
        pDevice->InUse = FALSE;
        return TRUE;
    }

    return FALSE;

} // end of CliDelDevice()


// allocate a single client's device info
BOOL CliMakeDeviceList(
    U032              client_instance,
    U032              num_devices,
    PCLI_DEVICE_INFO *ppDeviceList
)
{
    PCLI_DEVICE_INFO pdevice;
	
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: make new device list\n");

    if (RM_OK != osAllocMem((VOID **)ppDeviceList, sizeof(CLI_DEVICE_INFO) * num_devices))
        return FALSE;

    for (pdevice = *ppDeviceList; pdevice < *ppDeviceList + num_devices; pdevice++)
    {
        pdevice->InUse       = FALSE;
        pdevice->AppID       = client_instance;
        pdevice->AppHandle   = (void *) 0;
        pdevice->DevID       = (U032)(pdevice - *ppDeviceList);
        pdevice->DevFifoList = NULL;
    }

    return TRUE;
}


BOOL CliGetDeviceInfo(
    U032 hDevice,
    PCLI_DEVICE_INFO *ppDeviceInfo
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i;

    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse && deviceList[i].Handle == hDevice)
            {
                *ppDeviceInfo = &deviceList[i];
                return TRUE;
            }
        }
    }

    return FALSE;

} // end of CliGetDeviceInfo()

PCLI_DEVICE_INFO CliGetDeviceList()
{
    return clientInfo[ClientInstance].CliDeviceList;

} // end of CliGetDeviceList()

BOOL CliGetDeviceHandle(
    U032 hFifo,
    U032 *phDevice
)
{
    PCLI_DEVICE_INFO deviceList;
    U032 i, j;

    // get the device handle based on one of its fifo handles
    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse && deviceList[i].DevFifoList)
            {
                for (j = 0; j < MAX_FIFOS; j++)
                {
                    if (deviceList[i].DevFifoList[j].InUse &&
                        (deviceList[i].DevFifoList[j].Handle == hFifo))
                    {
                        *phDevice = deviceList[i].Handle;
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}

BOOL CliSetDeviceContext(
    U032 hDevice,
    PHWINFO* ppDev
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        // For NT there is no global DeviceInstance variable.
        U032 deviceInstance;

        if (CliGetPhysicalDevice(pDevice->Class, &deviceInstance))
        {
            *ppDev = NvDBPtr_Table[deviceInstance];
            osEnsureDeviceEnabled((PHWINFO)*ppDev);
            return TRUE;
        }
    }

    return FALSE;

} // end of CliSetDeviceContext()

BOOL CliSetDeviceAppHandle(
    U032  hDevice,
    void *appHandle
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        pDevice->AppHandle = appHandle;
        return TRUE;
    }

    return FALSE;

} // end of CliSetDeviceAppHandle()

BOOL CliGetDeviceAppHandle(
    U032   hDevice,
    void **appHandle
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        *appHandle = pDevice->AppHandle;
        return TRUE;
    }

    return FALSE;

} // end of CliSetDeviceAppHandle()


RM_STATUS CliAddDeviceFifo(
    PHWINFO pDev,
    U032 hDevice,
    U032 hFifo,
    U032 hClass,
    U032 hErrorCtx,
    U032 hDataCtx,
    U032 offset,
    U032 flags,
    U032 chID,
    VOID* pChannel
)
{
    PCLI_DEVICE_INFO pDevice;

    // validate device
    if (!CliGetDeviceInfo(hDevice, &pDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate fifo
    if ( ! CliIsUniqueHandle(hFifo, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // make sure we have a fifo list
    // allocate MAX_FIFOS worth because some of the code in here walks the
    //     list without having access to NUM_FIFOS for a particular card.
    //     (NUM_FIFOS is a macro defined in terms of pDev)
    if ( ! pDevice->DevFifoList)
        if ( ! CliMakeDeviceFifoList(ClientInstance,
                                     pDevice->DevID,
                                     MAX_FIFOS,
                                     &pDevice->DevFifoList))
            return RM_ERR_INSUFFICIENT_RESOURCES;

    // add fifo info to the given device's fifo
    if ( ! pDevice->DevFifoList[chID].InUse)
    {
        pDevice->DevFifoList[chID].Handle           = hFifo;
        pDevice->DevFifoList[chID].Device           = hDevice;
        pDevice->DevFifoList[chID].Class            = hClass;
        pDevice->DevFifoList[chID].ErrorDmaContext  = hErrorCtx;
        pDevice->DevFifoList[chID].DataDmaContext   = hDataCtx;
        pDevice->DevFifoList[chID].Selector         = 0;
        pDevice->DevFifoList[chID].Flat             = pChannel;
        pDevice->DevFifoList[chID].FifoPtr          = &pDev->DBfifoTable[chID];
        pDevice->DevFifoList[chID].heventWait       = 0;
        pDevice->DevFifoList[chID].hwndNotify       = 0;
        pDevice->DevFifoList[chID].hwndError        = 0;
        pDevice->DevFifoList[chID].msgNotify        = 0;
        pDevice->DevFifoList[chID].msgError         = 0;
        pDevice->DevFifoList[chID].lpSysCallback    = 0;
        pDevice->DevFifoList[chID].eventNotify      = 0;

        pDevice->DevFifoList[chID].InUse            = TRUE;
        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDeviceFifo()

BOOL CliDelDeviceFifo(
    U032 hDevice,
    U032 hFifo
)
{
    PCLI_FIFO_INFO pFifo;

    if (CliGetDeviceFifoInfo(hDevice, hFifo, &pFifo))
    {
        pFifo->InUse = FALSE;
        return TRUE;
    }

    return FALSE;

} // end of CliDelDeviceFifo()

// allocate a single device's fifo info

BOOL CliMakeDeviceFifoList(
    U032              client_instance,
    U032              device_instance,
    U032              num_fifos,
    PCLI_FIFO_INFO   *ppFifoList
)
{
    PCLI_FIFO_INFO pfifo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: make new fifo list\n");

    if (RM_OK != osAllocMem((VOID **)ppFifoList, sizeof(CLI_FIFO_INFO) * num_fifos))
        return FALSE;

    for (pfifo = *ppFifoList; pfifo < *ppFifoList + num_fifos; pfifo++)
    {
        pfifo->InUse = FALSE;
        pfifo->AppID = client_instance;
        pfifo->AppHandle = (void *) 0;
        pfifo->DevID = device_instance;
        pfifo->ChID = (U032)(pfifo - *ppFifoList);

        pfifo->Selector = 0;
        pfifo->Handle = 0;
        pfifo->Device = 0;
        pfifo->Class = 0;
        pfifo->ErrorDmaContext = 0;
        pfifo->DataDmaContext = 0;
        pfifo->FifoPtr = 0;
        pfifo->Flat = 0;
        pfifo->heventWait = 0;
        pfifo->hwndNotify = 0;
        pfifo->hwndError = 0;
        pfifo->msgNotify = 0;
        pfifo->msgError = 0;
        pfifo->lpSysCallback = 0;
        pfifo->eventNotify = 0;
        pfifo->pDmaObject = 0;
    }

    return TRUE;
}

BOOL CliGetDeviceFifoInfo(
    U032 hDevice,
    U032 hFifo,
    PCLI_FIFO_INFO *ppFifoInfo
)
{
    PCLI_FIFO_INFO fifoList;
    U032 i;

    if (CliGetDeviceFifoList(hDevice, &fifoList) && fifoList)
    {
        for (i = 0; i < MAX_FIFOS; i++)
        {
            if (fifoList[i].InUse && (fifoList[i].Handle == hFifo))
            {
                *ppFifoInfo = &fifoList[i];
                return TRUE;
            }
        }
    }

    return FALSE;

} // end of CliGetDeviceFifoInfo()


// CliGetDeviceFifoList() could return a NULL list on TRUE
BOOL CliGetDeviceFifoList(
    U032 hDevice,
    PCLI_FIFO_INFO *pFifoList
)
{
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        *pFifoList = pDevice->DevFifoList;
        return TRUE;
    }

    return FALSE;

} // end of CliGetDeviceFifoList()

RM_STATUS CliAddDeviceMemory(
    U032 hDevice,
    U032 hMemory,
    U032 hClass,
    VOID *address,
    U032 length,
    U032 instance,
    U032 heapOwner,
    U032 version      //see CLI_MEMORY_INFO definition for more info on version  -C.Moidel
)
{
    PCLI_DEVICE_INFO pDevice;
    PCLI_MEMORY_INFO pMemory;

    // validate client
    if (!CliGetDeviceInfo(hDevice, &pDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate device
    if (!CliIsUniqueHandle(hMemory, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_MEMORY_LOCAL_PRIVILEGED:
        case NV01_MEMORY_LOCAL_USER:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    //TODO: Validate HeapOwner based on version     -C.Moidel

    // allocate a new memory info struct and add to the device
    if (RM_SUCCESS(osAllocMem((void **) &pMemory, sizeof(CLI_MEMORY_INFO))))
    {
        // link in the new device memory mapping
        pMemory->Next = pDevice->DevMemoryList;
        pMemory->Prev = NULL;
        pDevice->DevMemoryList = pMemory;
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory;
        }

        // initialize the device
        pMemory->Handle     = hMemory;
        pMemory->Parent     = hDevice;
        pMemory->Class      = hClass;
        pMemory->Address    = address;
        pMemory->Length     = length;
        pMemory->Instance   = instance;
        pMemory->HeapOwner  = heapOwner;
        pMemory->version    = version;
        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDeviceMemory()

BOOL CliDelDeviceMemory(
    U032 hDevice,
    U032 hMemory
)
{
    PCLI_MEMORY_INFO pMemory;
    PCLI_DEVICE_INFO pDevice;

    if (CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemory))
    {
        // fixup prev link
        if (pMemory->Prev)
        {
            pMemory->Prev->Next = pMemory->Next;
        }
        else
        {
            // head of list, so modify the list head link
            if (!CliGetDeviceInfo(hDevice, &pDevice))
            {
                return FALSE;
            }
            pDevice->DevMemoryList = pMemory->Next;
        }

        // fixup next link
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory->Prev;
        }

        // free the list element
        osFreeMem(pMemory);

        return TRUE;
    }

    return FALSE;

} // end of CliDelDeviceMemory()

//
// This is currently used only by heapPurge to delete DeviceMemory based
// only on the owner.
//
BOOL CliDelDeviceHeapOwner(
    U032 hDevice,
    U032 heapOwner
)
{
    PCLI_MEMORY_INFO pMemory;
    BOOL retval = FALSE;

    for (pMemory = CliGetDeviceMemoryList(hDevice); pMemory; )
    {
        if (pMemory->HeapOwner == heapOwner)
        {
            U032 hMemory = pMemory->Handle;

            pMemory = pMemory->Next;                // get Next, before we delete it
            CliDelDeviceMemory(hDevice, hMemory);

            retval = TRUE;
        } else
            pMemory = pMemory->Next;
    }

    return retval;

} // end of CliDelDeviceHeapOwner

BOOL CliGetDeviceMemoryInfo(
    U032 hDevice,
    U032 hMemory,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetDeviceMemoryList(hDevice); pMemory; pMemory = pMemory->Next)
    {
        if (pMemory->Handle == hMemory)
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetDeviceMemoryInfo()

PCLI_MEMORY_INFO CliGetDeviceMemoryList(
    U032 hDevice
)
{
    PCLI_DEVICE_INFO pDevice;
    PCLI_MEMORY_INFO memoryList = NULL;

    if (CliGetDeviceInfo(hDevice, &pDevice))
    {
        memoryList = pDevice->DevMemoryList;
    }

    return memoryList;

} // end of CliGetDeviceMemoryList()

RM_STATUS CliAddDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    VOID* base,
    U032 limit,
    PCLI_DMA_INFO *ppDma
)
{
    U032 client;
    PCLI_DMA_INFO pDma;
    U032 access, physicality, locked, coherency;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate handle
    if (!CliIsUniqueHandle(hDma, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_CONTEXT_DMA:
            break;

        default:
            return RM_ERR_BAD_CLASS;
    }

    // validate the flags
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_ACCESS) & DRF_MASK(NVOS03_FLAGS_ACCESS))
    {
        case NVOS03_FLAGS_ACCESS_READ_WRITE:
            access = NV01_CONTEXT_DMA_IN_MEMORY;
            break;

        case NVOS03_FLAGS_ACCESS_READ_ONLY:
            access = NV01_CONTEXT_DMA_FROM_MEMORY;
            break;

        case NVOS03_FLAGS_ACCESS_WRITE_ONLY:
            access = NV01_CONTEXT_DMA_TO_MEMORY;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_PHYSICALITY) & DRF_MASK(NVOS03_FLAGS_PHYSICALITY))
    {
        case NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS:
            physicality = NVOS03_FLAGS_PHYSICALITY_CONTIGUOUS;
            break;

        case NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS:
            physicality = NVOS03_FLAGS_PHYSICALITY_NONCONTIGUOUS;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_LOCKED) & DRF_MASK(NVOS03_FLAGS_LOCKED))
    {
        case NVOS03_FLAGS_LOCKED_ALWAYS:
            locked = NVOS03_FLAGS_LOCKED_ALWAYS;
            break;

        case NVOS03_FLAGS_LOCKED_IN_TRANSIT:
            locked = NVOS03_FLAGS_LOCKED_IN_TRANSIT;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }
    switch (flags >> DRF_SHIFT(NVOS03_FLAGS_COHERENCY) & DRF_MASK(NVOS03_FLAGS_COHERENCY))
    {
        case NVOS03_FLAGS_COHERENCY_UNCACHED:
            coherency = NVOS03_FLAGS_COHERENCY_UNCACHED;
            break;

        case NVOS03_FLAGS_COHERENCY_CACHED:
            coherency = NVOS03_FLAGS_COHERENCY_CACHED;
            break;

        default:
            return RM_ERR_BAD_FLAGS;
    }

    // allocate a new dmaInfo and add the device to the client
    if (RM_SUCCESS(osAllocMem((void **) &pDma, sizeof(CLI_DMA_INFO))))
    {
        // link in the new DMA
        pDma->Next = clientInfo[ClientInstance].CliDmaList;
        pDma->Prev = NULL;
        clientInfo[ClientInstance].CliDmaList = pDma;
        if (pDma->Next)
        {
            pDma->Next->Prev = pDma;
        }

        // initialize the device
        pDma->Handle        = hDma;
        pDma->Client        = hClient;
        pDma->Class         = hClass;
        pDma->Flags         = flags;
        pDma->Access        = access;
        pDma->Physicality   = physicality;
        pDma->Locked        = locked;
        pDma->Coherency     = coherency;
        pDma->Valid         = FALSE;
        pDma->DescSelector  = selector;
        pDma->DescOffset    = base;
        pDma->DescLimit     = limit;
        pDma->DescAddr      = 0;
        pDma->BufferBase    = 0;
        pDma->BufferSize    = 0;
        pDma->LockHandle    = 0;
        pDma->PteCount      = 0;
        pDma->PteAdjust     = 0;
        pDma->PteLimit      = 0;
        pDma->PteArray      = 0;
        pDma->AddressSpace  = ADDR_UNKNOWN;
        *ppDma = pDma;

        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddDma()

BOOL CliDelDma(
    U032 hDma
)
{
    PCLI_DMA_INFO pDma;

    if (CliGetDmaInfo(hDma, &pDma))
    {
        // fixup prev link
        if (pDma->Prev)
        {
            pDma->Prev->Next = pDma->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliDmaList = pDma->Next;
        }

        // fixup the next link
        if (pDma->Next)
        {
            pDma->Next->Prev = pDma->Prev;
        }

        // free the list element
        osFreeMem(pDma);

        return TRUE;
    }

    return FALSE;

} // end of CliDelDma()

BOOL CliGetDmaInfo(
    U032 hDma,
    PCLI_DMA_INFO *ppDmaInfo
)
{
    PCLI_DMA_INFO pDma;

    for (pDma = CliGetDmaList(); pDma; pDma = pDma->Next)
    {
        if (pDma->Handle == hDma)
        {
            *ppDmaInfo = pDma;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetDmaInfo()

PCLI_DMA_INFO CliGetDmaList()
{
    return clientInfo[ClientInstance].CliDmaList;

} // end of CliGetDmaList()

RM_STATUS CliAddMemory(
    U032 hClient,
    U032 hMemory,
    U032 hClass,
    U032 flags,
    VOID* address,
    U032 length,
    VOID* memdata       // private per-alloc data
)
{
    U032 client;
    PCLI_MEMORY_INFO pMemory;

    // validate client
    if (!CliGetClientHandle(&client) || client != hClient)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate memory description
    if (!CliIsUniqueHandle(hMemory, FALSE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // allocate a new memory description and add the device to the client
    if (RM_SUCCESS(osAllocMem((void **) &pMemory, sizeof(CLI_MEMORY_INFO))))
    {
        // link in the new system memory mapping
        pMemory->Next = clientInfo[ClientInstance].CliMemoryList;
        pMemory->Prev = NULL;
        clientInfo[ClientInstance].CliMemoryList = pMemory;
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory;
        }

        // initialize the memory description
        pMemory->Handle     = hMemory;
        pMemory->Parent     = hClient;
        pMemory->Class      = hClass;
        pMemory->Address    = address;
        pMemory->Length     = length;
        pMemory->Type       = DRF_VAL(OS02, _FLAGS, _LOCATION, flags);
        pMemory->Physicality = DRF_VAL(OS02, _FLAGS, _PHYSICALITY, flags);
        pMemory->Coherency  = DRF_VAL(OS02, _FLAGS, _COHERENCY, flags);
        pMemory->MemData    = memdata;

        return RM_OK;
    }

    return RM_ERR_INSUFFICIENT_RESOURCES;

} // end of CliAddMemory()

BOOL CliDelMemory(
    U032 hMemory
)
{
    PCLI_MEMORY_INFO pMemory;

    if (CliGetMemoryInfo(hMemory, &pMemory))
    {
        // fixup prev link
        if (pMemory->Prev)
        {
            pMemory->Prev->Next = pMemory->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliMemoryList = pMemory->Next;
        }

        // fixup the next link
        if (pMemory->Next)
        {
            pMemory->Next->Prev = pMemory->Prev;
        }

        pMemory->MemData = NULL;

        // free the list element
        osFreeMem(pMemory);

        return TRUE;
    }

    return FALSE;

} // end of CliDelMemory()

BOOL CliGetMemoryInfo(
    U032 hMemory,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetMemoryList(); pMemory; pMemory = pMemory->Next)
    {
        if (pMemory->Handle == hMemory)
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetMemoryInfo()


// which memory chunk spans a given linear address?
BOOL CliGetMemoryInfoForLinAddr(
    VOID *address,
    PCLI_MEMORY_INFO *ppMemoryInfo
)
{
    PCLI_MEMORY_INFO pMemory;

    for (pMemory = CliGetMemoryList(); pMemory; pMemory = pMemory->Next)
    {
        // NOTE: pMemory->length is really length-1
        if ((address >= pMemory->Address) &&
            (address <= (VOID*)((U008*)pMemory->Address + pMemory->Length)))
        {
            *ppMemoryInfo = pMemory;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetMemoryInfoForLinAddr()


PCLI_MEMORY_INFO CliGetMemoryList()
{
    return clientInfo[ClientInstance].CliMemoryList;

} // end of CliGetMemoryList()

RM_STATUS CliAddEvent(
    U032 hClient,
    U032 hObject,
    U032 hEvent,
    U032 hClass,
    PCLI_EVENT_INFO* ppEventInfo
)
{
    RM_STATUS rmStatus = RM_OK;
    POBJECT pObject;
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER pUser;
    U032 hChannel;

    // validate parent
    if (!CliFindObject(hObject, &pObject, &hChannel))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // validate handle -- disregard existing event handles
    if (!CliIsUniqueHandle(hEvent, TRUE))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // validate class
    switch (hClass)
    {
        case NV01_EVENT_KERNEL_CALLBACK:
        case NV01_EVENT_WIN32_EVENT:
            break;

        default:
            return RM_ERR_BAD_CLASS;

    }

    // return a pointer to the client event list element
    if (!CliGetEventInfo(hEvent, &pEvent))
    {
        // allocate a new event and add to the client
        rmStatus = osAllocMem((void **) &pEvent, sizeof(CLI_EVENT_INFO));
        if (RM_SUCCESS(rmStatus))
        {
            // link in the new event
            pEvent->Next = clientInfo[ClientInstance].CliEventList;
            pEvent->Prev = NULL;
            clientInfo[ClientInstance].CliEventList = pEvent;
            if (pEvent->Next)
            {
                pEvent->Next->Prev = pEvent;
            }

            // initialize the event
            pEvent->Handle      = hEvent;
            pEvent->Class       = hClass;
            pEvent->UserList    = NULL;
        }
    }
    else
    {
        // validate the user object's uniqueness for non-trivial lists
        for (pUser = pEvent->UserList; pUser; pUser = pUser->Next)
        {
            if (pUser->Handle == hObject)
            {
                return RM_ERR_BAD_OBJECT_HANDLE;
            }
        }
    }

    // add the next user
    if (RM_SUCCESS(rmStatus))
    {
        rmStatus = osAllocMem((void **) &pUser, sizeof(CLI_EVENT_USER));
        if (RM_SUCCESS(rmStatus))
        {
            // link in the new event's user
            pUser->Next = pEvent->UserList;
            pUser->Prev = NULL;
            pEvent->UserList = pUser;
            if (pUser->Next)
            {
                pUser->Next->Prev = pUser;
            }

            // initialize the new user
            pUser->Handle   = hObject;
            pUser->Channel  = hChannel;

            // set the return value
            *ppEventInfo = pEvent;
        }
    }

    return rmStatus;

} // end of CliAddEvent()

BOOL CliDelEvent(
    U032 hEvent
)
{
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER nextUser;

    // remove the event from the client database
    if (CliGetEventInfo(hEvent, &pEvent))
    {
        // free up user list
        nextUser = pEvent->UserList;
        while (pEvent->UserList)
        {
            pEvent->UserList = nextUser->Next;
            osFreeMem(nextUser);
        }

        // fixup next link
        if (pEvent->Prev)
        {
            pEvent->Prev->Next = pEvent->Next;
        }
        else
        {
            // head of list, so modify the list head link
            clientInfo[ClientInstance].CliEventList = pEvent->Next;
        }

        // fixup the prev link
        if (pEvent->Next)
        {
            pEvent->Next->Prev = pEvent->Prev;
        }

        // free the list element
        osFreeMem(pEvent);

        return TRUE;
    }

    return FALSE;

} // end of CliDelEvent()

BOOL CliDelEventUser
(
    U032 hUser,
    U032 hClass
)
{
    PCLI_EVENT_INFO nextEvent;
    PCLI_EVENT_USER nextUser, pUser;
    U032 hEvent;

    // remove user from all events
    nextEvent = CliGetEventList();
    while (nextEvent)
    {
        nextUser = nextEvent->UserList;
        while (nextUser)
        {
            if (CliGetEventUserHandle(nextUser, hClass) == hUser)
            {
                // fixup next link
                if (nextUser->Prev)
                {
                    nextUser->Prev->Next = nextUser->Next;
                }
                else
                {
                    // head of list, so modify the list head link
                    nextEvent->UserList = nextUser->Next;
                }

                // fixup the prev link
                if (nextUser->Next)
                {
                    nextUser->Next->Prev = nextUser->Prev;
                }

                // free the list element
                pUser = nextUser;
                nextUser = nextUser->Next;
                osFreeMem(pUser);
            }
            else
            {
                nextUser = nextUser->Next;
            }
        }

        // remove the event if user list is empty
        if (nextEvent->UserList == NULL)
        {
            hEvent = nextEvent->Handle;
            nextEvent = nextEvent->Next;
            CliDelEvent(hEvent);
        }
        else
        {
            nextEvent = nextEvent->Next;
        }
    }

    return TRUE;

}

U032 CliGetEventUserHandle
(
    PCLI_EVENT_USER pUser,
    U032 hClass
)
{
    switch (hClass)
    {
        // object
        case NV01_NULL_OBJECT:
            return pUser->Handle;

        // channel
        default:
            return pUser->Channel;
    }

} // end of CliGetEventUserHandle()

BOOL CliGetEventInfo(
    U032 hEvent,
    PCLI_EVENT_INFO* ppEventInfo
)
{
    PCLI_EVENT_INFO pEvent;

    for (pEvent = CliGetEventList(); pEvent; pEvent = pEvent->Next)
    {
        if (pEvent->Handle == hEvent)
        {
            *ppEventInfo = pEvent;
            return TRUE;
        }
    }

    return FALSE;

} // end of CliGetEventInfo()

PCLI_EVENT_INFO CliGetEventList()
{
    return clientInfo[ClientInstance].CliEventList;

} // end of CliGetEventList()

BOOL CliFindObject(
    U032 hObject,
    POBJECT* ppObject,
    U032* phChannel
)
{
    BOOL found = FALSE;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    U032 device, fifo;
    PHWINFO pDev;

    deviceList = CliGetDeviceList();
    if ( ! deviceList)
        goto done;

    // search thru all channels of all devices for the object
    for (device = 0; device < NUM_DEVICES; device++)
    {
        if (deviceList[device].InUse)
        {
            if (CliSetDeviceContext(deviceList[device].Handle, &pDev))
            {
                if (CliGetDeviceFifoList(deviceList[device].Handle, &fifoList)
                    && fifoList)
                {
                    for (fifo = 0; fifo < NUM_FIFOS; fifo++)
                    {
                        if (fifoList[fifo].InUse)
                        {
                            if (RM_OK == fifoSearchObject(pDev,
                                                          hObject,
                                                          fifoList[fifo].ChID,
                                                          ppObject))
                            {
                                found = TRUE;
                                *phChannel = fifoList[fifo].Handle;
                                goto done;
                            }
                        }
                    }
                }
            }
        }
    }

 done:
    return found;

} // end of CliFindObject()

BOOL CliGetClass(
    U032 hParent,
    U032 hObject,
    U032 *phClass
)
{
    U032 client;
    PCLI_DEVICE_INFO pDevice;
    PCLI_FIFO_INFO pFifo;
    PCLI_MEMORY_INFO pMemory;
    PCLI_DMA_INFO pDma;
    PCLI_EVENT_INFO pEvent;

    // scan all object types

    if (CliGetClientHandle(&client) && client == hObject)
    {
        *phClass = clientInfo[ClientInstance].Class;
    }
    else if (CliGetDeviceInfo(hObject, &pDevice))
    {
        *phClass = pDevice->Class;
    }
    else if (CliGetDeviceFifoInfo(hParent, hObject, &pFifo))
    {
        *phClass = pFifo->Class;
    }
    else if (CliGetDeviceMemoryInfo(hParent, hObject, &pMemory))
    {
        *phClass = pMemory->Class;
    }
    else if (CliGetDmaInfo(hObject, &pDma))
    {
        *phClass = pDma->Class;
    }
    else if (CliGetMemoryInfo(hObject, &pMemory))
    {
        *phClass = pMemory->Class;
    }
    else if (CliGetEventInfo(hObject, &pEvent))
    {
        *phClass = pEvent->Class;
    }
    else
    {
        return FALSE;
    }

    return TRUE;

} // end of CliGetClass()

BOOL CliIsUniqueHandle(U032 hObject, BOOL omitEvents)
{
    U032 i, j;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    PCLI_DMA_INFO nextDma;
    PCLI_MEMORY_INFO nextMemory;
    PCLI_EVENT_INFO nextEvent;
    POBJECT pObject;
    U032 hChannel;

    // handle is unique if it is non-null or does not exist in the client
    if (hObject == NV01_NULL_OBJECT)
        return FALSE;

    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                if (deviceList[i].Handle == hObject)
                    return FALSE;

                if (CliGetDeviceFifoList(deviceList[i].Handle, &fifoList) && fifoList)
                {
                    for (j = 0; j < MAX_FIFOS; j++)
                    {
                        if (fifoList[j].InUse)
                        {
                            if (fifoList[j].Handle == hObject)
                                return FALSE;
                        }
                    }
                }
            }
        }
    }

    for (nextDma = CliGetDmaList(); nextDma; nextDma = nextDma->Next)
    {
        if (nextDma->Handle == hObject)
        {
            return FALSE;
        }
    }
    for (nextMemory = CliGetMemoryList(); nextMemory; nextMemory = nextMemory->Next)
    {
        if (nextMemory->Handle == hObject)
        {
            return FALSE;
        }
    }
    for (nextEvent = CliGetEventList(); nextEvent; nextEvent = nextEvent->Next)
    {
        if (nextEvent->Handle == hObject)
        {
            return FALSE;
        }
    }
    if (CliFindObject(hObject, &pObject, &hChannel))
    {
        return FALSE;
    }

    return TRUE;

} // end of CliIsUniqueHandle()

BOOL CliGetPhysicalDevice(
    U032 logicalDevice,
    U032 *physicalDevice
)
{
    switch (logicalDevice)
    {
        case NV01_DEVICE_0:
            *physicalDevice = 0;
            break;

        case NV01_DEVICE_1:
            *physicalDevice = 1;
            break;

        case NV01_DEVICE_2:
            *physicalDevice = 2;
            break;

        case NV01_DEVICE_3:
            *physicalDevice = 3;
            break;

        case NV01_DEVICE_4:
            *physicalDevice = 4;
            break;

        case NV01_DEVICE_5:
            *physicalDevice = 5;
            break;

        case NV01_DEVICE_6:
            *physicalDevice = 6;
            break;

        case NV01_DEVICE_7:
            *physicalDevice = 7;
            break;

        default:
            return FALSE;
    }

    return TRUE;

} // end of CliGetPhysicalDevice()

// Given a Channel ID return the Client handle
//
// Currently, this is routine is only called at intr time from
// dmaValidateObjectName, so dmaFindContext has the client handle
// to retrieve the correct DmaObject from the global DmaList. The
// DeviceInstance has already been set.
//
RM_STATUS CliGetClientHandleFromChID(
    PHWINFO pDev,
    U032 ChID,
    U032 *phClient
)
{
    U032 i, j, k, physnum;

    PCLI_FIFO_INFO fifoList;

    *phClient = 0;

    for (i = 0; i < NUM_CLIENTS; i++)
    {
        if (!clientInfo[i].InUse)
            continue;

        if (!clientInfo[i].CliDeviceList)
            continue;

        // scan the client's devices
        for (j = 0; j < NUM_DEVICES; j++)
        {
            if (!clientInfo[i].CliDeviceList[j].InUse)
                continue;

            // look for the DeviceInstance in DeviceList
            CliGetPhysicalDevice(clientInfo[i].CliDeviceList[j].Class, &physnum);
            if (physnum != devInstance)
                continue;

            // see if any "inuse" fifos match this channel ID
            fifoList = clientInfo[i].CliDeviceList[j].DevFifoList;
            if ( ! fifoList)
                continue;

            for (k = 0; k < MAX_FIFOS; k++)
            {
                if (fifoList[k].InUse && (fifoList[k].ChID == ChID))
                {
                    // find the one corresponding to largest client id.
                    // this avoids returning a stale client id in case
                    // of a previous client (using this device/channel)
                    // not being properly freed up.
                    if (clientInfo[i].Handle > *phClient)
                        *phClient = clientInfo[i].Handle;
                }
            }
        }
    }

    if (*phClient != 0)
        return RM_OK;

    return RM_ERR_BAD_OBJECT_ERROR;

} // end of CliGetClientHandleFromChID()

//
// Initialize the client database.
//
RM_STATUS initClientInfo(
    VOID
)
{
    RM_STATUS rmStatus;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initClientInfo\n");

    // allocate table
    rmStatus = osAllocMem((VOID **)&clientInfo, sizeof(CLIENTINFO) * NUM_CLIENTS);
    if (!RM_SUCCESS(rmStatus))
        return rmStatus;

    // initialize the client database
    for (i = 0; i < NUM_CLIENTS; i++)
    {
        clientInfo[i].InUse = FALSE;
        clientInfo[i].AppID = i;
        clientInfo[i].AppHandle = (void *) 0;
        clientInfo[i].CliDeviceList = NULL;
        clientInfo[i].CliHeapOwnerList = NULL;         //added by Chuck Moidel
    }

    return RM_OK;
}

//
// Tear down a clientInfo by free'ing all the memory allocated to it.
//
RM_STATUS destroyClientInfo(
    VOID
)
{
    U032 i, d;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: destroyClientInfo\n");

    if ( ! clientInfo)
        return RM_OK;

    for (i = 0; i < NUM_CLIENTS; i++)
    {
        if ( ! clientInfo[i].CliDeviceList)
            continue;

        for (d = 0; d < NUM_DEVICES; d++)
        {
            if ( ! clientInfo[i].CliDeviceList[d].DevFifoList)
                continue;

            osFreeMem(clientInfo[i].CliDeviceList[d].DevFifoList);
            clientInfo[i].CliDeviceList[d].DevFifoList = NULL;
        }
        osFreeMem(clientInfo[i].CliDeviceList);
        clientInfo[i].CliDeviceList = NULL;
    }

    osFreeMem(clientInfo);
    clientInfo = NULL;

    return RM_OK;
}

// end of client.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\cpuid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* CPU Information Gather Routines ***********************\
*                                                                           *
* Module: CPUID.C                                                           *
*   One time initialization code to setup the Processor type                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <nvcm.h>
#include <os.h>

#define CPU_STD_TSC                 BIT(4)
#define CPU_STD_MMX                 BIT(23)
#define CPU_STD_XMM                 BIT(25)
#define CPU_STD_WNI                 BIT(26)
#define CPU_EXT_3DNOW               BIT(31)

/*
 * Identify chip foundry.
 *      IS_INTEL   = "GenuineIntel"
 *      IS_AMD     = "AuthenticAMD"
 *      IS_WINCHIP = "CentaurHauls"
 *      IS_CYRIX   = "CyrixInstead"
 */
#define IS_INTEL(fndry)     (((fndry).StrID[0]==0x756E6547)&&((fndry).StrID[1]==0x49656E69)&&((fndry).StrID[2]==0x6C65746E))
#define IS_AMD(fndry)       (((fndry).StrID[0]==0x68747541)&&((fndry).StrID[1]==0x69746E65)&&((fndry).StrID[2]==0x444D4163))
#define IS_WINCHIP(fndry)   (((fndry).StrID[0]==0x746E6543)&&((fndry).StrID[1]==0x48727561)&&((fndry).StrID[2]==0x736C7561))
#define IS_CYRIX(fndry)     (((fndry).StrID[0]==0x69727943)&&((fndry).StrID[1]==0x736E4978)&&((fndry).StrID[2]==0x64616574))

/*
 * ID the CPU.
 */
VOID RmInitCpuInfo
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    int i;
    struct _CPUID
    {
        union
        {
            U008 String[12];
            U032 StrID[3];
        } Foundry;
        U032 pad;
        U032 Family;
        U032 Model;
        U032 Stepping;
        U032 StandardFeatures;
        U032 MemoryFeatures[4];
        U032 ExtendedFeatures;
        U032 ChipFlags;
        U032 MHz;
    } cpuinfo;

#ifdef __GNUC__
    U032 eax, ebx, ecx, edx;
#endif

    
    /*
     * Init structure to default.
     */
    for (i = 0; i < 12; i++)
        cpuinfo.Foundry.String[i] = '\0';
    cpuinfo.pad              = 0;
    cpuinfo.Family           = 0;
    cpuinfo.Model            = 0;
    cpuinfo.Stepping         = 0;
    cpuinfo.StandardFeatures = 0;
    cpuinfo.ExtendedFeatures = 0;
    cpuinfo.ChipFlags        = 0;
    cpuinfo.MHz              = 0;
    
    pRmInfo->Processor.Type = 0;
    pRmInfo->Processor.Clock = 0;
    
#ifdef __GNUC__
    // if nv_cpuid() returns 0, then this cpu does not support cpuid instruction
    // We just worry about this on the first call...
    if ( ! nv_cpuid(0x00000000/*cpuid op*/, &eax, &ebx, &ecx, &edx))
        goto Exit;

    cpuinfo.Foundry.StrID[0] = ebx;
    cpuinfo.Foundry.StrID[1] = edx;
    cpuinfo.Foundry.StrID[2] = ecx;
        
    nv_cpuid(0x00000001/*cpuid op*/, &eax, &ebx, &ecx, &edx);
    cpuinfo.Family = (eax >> 8) & 0xF;
    cpuinfo.Model = (eax >> 4) & 0xF;
    cpuinfo.Stepping = (eax & 0xF);
    cpuinfo.StandardFeatures = edx;

    nv_cpuid(0x00000002/*cpuid op*/, &eax, &ebx, &ecx, &edx);
    cpuinfo.MemoryFeatures[0] = eax;
    cpuinfo.MemoryFeatures[1] = ebx;
    cpuinfo.MemoryFeatures[2] = ecx;
    cpuinfo.MemoryFeatures[3] = edx;

#else        /* ! __GNUC__ */

        /* XXX this code should be converted to use less asm */

#ifndef IA64
    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                      // cpuid inst not supported
        mov     eax, 0
//      cpuid instr
        _emit   0x0F
        _emit   0xA2
        lea     esi, cpuinfo
        mov     [esi], ebx                // cpuinfo.Foundary.StrID[0]
        mov     [esi + 4], edx            // cpuinfo.Foundary.StrID[1]
        mov     [esi + 8], ecx            // cpuinfo.Foundary.StrID[2] 
        push    eax                       // Save max function count for later


        mov     eax, 1
//      cpuid instr
        _emit   0x0F
        _emit   0xA2

        mov     ebx, eax
        shr     ebx, 8
        and     ebx, 0x0F
        mov     [esi + 16], ebx           // cpuinfo.Family

        mov     ebx, eax
        shr     ebx, 4
        and     ebx, 0x0F
        mov     [esi + 20], ebx           // cpuinfo.Model

        mov     ebx, eax
        and     ebx, 0x0F
        mov     [esi + 24], ebx           // cpuinfo.Stepping

        mov     [esi + 28], edx           // cpuinfo.StandardFeatures


        mov     eax, 2
//      cpuid instr
        _emit   0x0F
        _emit   0xA2
        mov     [esi + 32], eax           // cpuinfo.MemoryFeatures
        mov     [esi + 36], ebx
        mov     [esi + 40], ecx
        mov     [esi + 44], edx
        pop     eax                       // Restore max function, but discard
        
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
#endif // IA64 cannot handle inline asm
#endif
    
    if (IS_INTEL(cpuinfo.Foundry))
    {
        if (cpuinfo.Family == 5)
        {
            if (cpuinfo.Model == 4)
                pRmInfo->Processor.Type = NV_CPU_P55;
            else 
                pRmInfo->Processor.Type = NV_CPU_P5;
        }
        if (cpuinfo.Family == 6)
        {
            if (cpuinfo.Model == 1)
                pRmInfo->Processor.Type = NV_CPU_P6;
            else if (cpuinfo.Model == 3)
                pRmInfo->Processor.Type = NV_CPU_P2;
            else if (cpuinfo.Model == 5)
                pRmInfo->Processor.Type = NV_CPU_P2XC;
            else if (cpuinfo.Model == 6)
                pRmInfo->Processor.Type = NV_CPU_CELA;
            else if (cpuinfo.Model == 7)
                pRmInfo->Processor.Type = NV_CPU_P3;
            else if (cpuinfo.Model == 8)
                pRmInfo->Processor.Type = NV_CPU_P3_INTL2;
        }
            
        if (cpuinfo.StandardFeatures & CPU_STD_MMX)
            pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
        if (cpuinfo.StandardFeatures & CPU_STD_XMM)
        {
            U032 my_cr4;
            
            pRmInfo->Processor.Type |= NV_CPU_FUNC_SFENCE;
#ifdef __GNUC__
            my_cr4 = nv_rdcr4();
#else
#ifndef IA64
            // Before setting the NV_CPU_FUNC_SSE bit, we'll also check
            // that CR4.OSFXSR(bit 9) is set, which means the OS is prepared
            // to switch the additional KATMAI FP state for us.
            
            __asm
            {
                ; save state
                push    eax
                push    ebx
                push    ecx
                push    edx

                // mov     eax,cr4
                _emit   0x0F
                _emit   0x20
                _emit   0xE0

                mov     my_cr4, eax
                
                ; restore state
                pop     edx
                pop     ecx
                pop     ebx
                pop     eax
            }
#else
my_cr4 = 0;
#endif // IA64 cannot handle inline asm
#endif
            if (my_cr4 & 0x200)
            {
                pRmInfo->Processor.Type |= NV_CPU_FUNC_SSE;

                // supports SSE2 (Willamette NI) instructions
                if (cpuinfo.StandardFeatures & CPU_STD_WNI)
                    pRmInfo->Processor.Type |= NV_CPU_FUNC_SSE2;
            }
        }
    }
    else
    {
#ifdef __GNUC__
        nv_cpuid(0x80000001/*cpuid op*/, &eax, &ebx, &ecx, &edx);
        cpuinfo.ExtendedFeatures = edx;
#else
#ifndef IA64
        // All other non-Intel CPU types will want to get the extended features
        __asm
        {
            ; save state
            push    eax
            push    ebx
            push    ecx
            push    edx
                
            mov     eax, 0x80000001
            // cpuid instr
            _emit   0x0F
            _emit   0xA2
            mov     [esi + 48], edx           // cpuinfo.ExtendedFeatures
        
            ; restore state
            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }
#endif // IA64 cannot handle inline asm
#endif

        if (IS_AMD(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 5)                // K5, K6, K6-2 with 3DNow, K6-3
            {
                if (cpuinfo.Model < 6)
                    pRmInfo->Processor.Type = NV_CPU_K5;
                else if (cpuinfo.Model < 8)
                    pRmInfo->Processor.Type = NV_CPU_K6;
                else if (cpuinfo.Model == 8)
                    pRmInfo->Processor.Type = NV_CPU_K62;
                else if (cpuinfo.Model == 9)
                    pRmInfo->Processor.Type = NV_CPU_K63;
             }
            if (cpuinfo.Family == 6)                // K7
            {
                pRmInfo->Processor.Type = NV_CPU_K7;
                pRmInfo->Processor.Type |= NV_CPU_FUNC_SFENCE;
            }
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
        else if (IS_WINCHIP(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 5)                // Winchip C6, Winchip2 w/ 3DNow
            {
                if (cpuinfo.Model == 4)
                    pRmInfo->Processor.Type = NV_CPU_C6;
                if (cpuinfo.Model == 8)        
                    pRmInfo->Processor.Type = NV_CPU_C62;
            }
                    
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
        else if (IS_CYRIX(cpuinfo.Foundry))
        {
            if (cpuinfo.Family == 4)                // MediaGX
                pRmInfo->Processor.Type = NV_CPU_GX;
            if (cpuinfo.Family == 5)                // Cyrix 6x86 or MediaGX w/ MMX
            {
                if (cpuinfo.Model == 2)
                    pRmInfo->Processor.Type = NV_CPU_M1;
                if (cpuinfo.Model == 4)        
                    pRmInfo->Processor.Type = NV_CPU_MGX;
            }
            if (cpuinfo.Family == 6)                // Cyrix MII
                pRmInfo->Processor.Type = NV_CPU_M2;
        
            if (cpuinfo.StandardFeatures & CPU_STD_MMX)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_MMX;
            if (cpuinfo.ExtendedFeatures & CPU_EXT_3DNOW)
                pRmInfo->Processor.Type |= NV_CPU_FUNC_3DNOW;
        }
    }
    
    // Calculate the frequency
    if (cpuinfo.StandardFeatures & CPU_STD_TSC)
        pRmInfo->Processor.Clock = osGetCpuFrequency();
#ifndef IA64        
Exit:    
#endif // IA64 cannot handle inline asm
    return;
}

void RmInitBusInfo
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    U016 vendorID, deviceID;
    U032 handle, data32;
    U032 hclk_freq, mclk_freq;

    //
    // Currently the only chipset we need to really concern ourselves with is
    // Crush, so zero out the others for now
    //
    pRmInfo->Processor.HalInfo.FrontSideBusFreq = 0;
    pRmInfo->Processor.HalInfo.SystemMemoryFreq = 0;

    //
    // Determine if this is a Crush system
    //
    handle = osPciInitHandle(0, 0, 0, &vendorID, &deviceID);
    if (!handle)
        return;

    if ((vendorID != 0x10B9) || (deviceID != 0x1631))
    {
        U016 tempvid, tempdid;
        U032 temphandle;

        //
        // Deal with ALI trickery.  On some systems they changed the chipset
        // devid to 0x1621 (their old chipset).  If this is the case, peer at
        // bus1 dev0 to see if we're there.  If so, assume this is really
        // a 1631
        //
        if ((vendorID == 0x10B9) && (deviceID == 0x1621))
        {
            temphandle = osPciInitHandle(1, 0, 0, &tempvid, &tempdid);
            if (!temphandle)
                return;

            // Is NV out there at Bus1 Dev0?
            if ((tempvid != 0x10DE) || ((tempdid & 0xFFF0) != 0x00A0))
                return;

            // Get the original handle back
            handle = osPciInitHandle(0, 0, 0, &vendorID, &deviceID);
            if (!handle)
                return;
        }
        else
            return;
    }

    data32 = osPciReadDword(handle, 0xF4);    // Clock Freq register

    hclk_freq = (data32 >> 6) & 0x03;   // hclk_freq [7:6]
    mclk_freq = (data32 >> 4) & 0x03;   // mclk_freq [5:4]

    switch (hclk_freq)
    {
        case 2:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 133000000;
            break;

        case 1:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 100000000;
            break;

        case 0:
        default:
            pRmInfo->Processor.HalInfo.FrontSideBusFreq = 66000000;
            break;
    }

    switch (mclk_freq)
    {
        case 2:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 133000000;
            break;

        case 1:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 100000000;
            break;

        case 0:
        default:
            pRmInfo->Processor.HalInfo.SystemMemoryFreq = 66000000;
            break;
    }
}

#ifdef DEBUG
static char *MTRR_Typenames[] = {
    "NVRM:      Type Uncached\n",
    "NVRM:      Type WriteCombined\n",
    "NVRM:      Type Reserved\n",
    "NVRM:      Type Reserved\n",
    "NVRM:      Type WriteThrough\n",
    "NVRM:      Type WriteProtected\n",
    "NVRM:      Type WriteBack\n",
    "NVRM:      Type Reserved\n"
};

//
// This routine is used to make sure the MTRRs are setup the way we think
// they should be. Manually edit the mtrr_done_once variable, if you want
// to see the output post-boot.
//
VOID dbgDumpMTRRs(VOID)
{
    U032 i, numRanges = 0, mtrrAddr;
    U032 BaseHi, BaseLo, MaskHi, MaskLo, Type;
    static U032 mtrr_done_once = 0;
#ifdef __GNUC__
    U032 eax, ebx, ecx, edx;
#endif

     if (mtrr_done_once)
        return;
    mtrr_done_once = 1;

#ifdef __GNUC__
    // if nv_cpuid() returns 0, then this cpu does not support cpuid instruction
    // We just worry about this on the first call...
    if ( ! nv_cpuid(0x00000001/*cpuid op*/, &eax, &ebx, &ecx, &edx))
        return;

    // Is MTRR supported?
    if (0 == (edx & 0x1000))
        return;

    if ( ! nv_rdmsr(254/*address*/, &eax, &edx))
        return;
    if (0 == (eax & 0x400))
        return;
    
    numRanges = eax & 0xFF;

#else

#ifndef IA64
#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32

    __asm
    {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        pushfd
        pop     eax
        mov     ebx, eax
        xor     eax, 0x00200000
        push    eax
        popfd
        pushfd
        pop     eax
        cmp     eax, ebx
        je      Exit                // CPUID inst not supported

        mov     eax, 1
        CPUID
        and     edx, 0x1000         // check for MTRR support
        jz      Exit

        mov     ecx, 254            // read the MTRRcap MSR to determine number of ranges.
        RDMSR
        test    eax, 0x400          // check that WC as a type is supported (should be 1).
        jz      Exit

        and     eax, 0xFF           // save number of ranges
        mov     numRanges, eax
Exit:    
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }
#else
numRanges = 0;    
#endif // IA64 cannot handle inline asm
#endif

    // Use a high DEBUGLEVEL for these strings, since this is normally done once.
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Valid MTRRs:\n");

    // Now determine if we find a Write Combined match in the MTRRs
    for (i = 0, mtrrAddr = 512; i < numRanges; i++, mtrrAddr += 2)
    {
#ifdef __GNUC__
        nv_rdmsr(mtrrAddr, &BaseLo, &BaseHi);
        nv_rdmsr(mtrrAddr+1, &MaskLo, &MaskHi);        
#else
#ifndef IA64
        __asm {
            ; save state
            push    eax
            push    ebx
            push    ecx
            push    edx

            mov     ecx, mtrrAddr
            RDMSR

            mov     BaseHi, edx
            mov     BaseLo, eax

            mov     ecx, mtrrAddr
            add     ecx, 1
            RDMSR

            mov     MaskHi, edx
            mov     MaskLo, eax

            ; restore state
            pop     edx
            pop     ecx
            pop     ebx
            pop     eax
        }
#else
BaseHi = 0;
BaseLo = 0;
MaskHi = 0;
MaskLo = 0;
#endif // IA64 cannot handle inline asm
#endif

        if (!(MaskLo & 0x800))
            continue;               // valid bit not set

        Type = BaseLo & 0xFF;      // set the type
        if (Type >= 0x8)
            Type = 0x7;            // reserved, if it's too large

        MaskLo &= ~0xFFF;          // mask off the valid bit
        BaseLo &= ~0xFFF;          // mask off the type bits

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Range ", i);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:      Base ", BaseLo);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM:    Length ", (~(MaskLo & ~0xFFF)) + 1);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, MTRR_Typenames[Type]);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\nvapi.c ===
/******************************************************************************
*
*	Module: nvapi.c
*
*   Description:
*       This module is the main entry module into the NV Architecture Driver.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <nvrm.h>
#include <nv32.h>
#include <nv_ref.h>
#include <nvhw.h>
#include <rmfail.h>

#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <event.h>
#include <fifo.h>
#include <fb.h>
#include <gr.h>
#include <heap.h>
#include <tmr.h>
#include <mc.h>
#include <client.h>

#include <os.h>
#include <nvos.h>
#include <nvarch.h>
#include <smp.h>

PCLIENTINFO clientInfo;
U032        ClientInstance;
#ifdef DEBUG
PCLIENTINFO pClient;
U032 clientSize = sizeof(CLIENTINFO);
#endif

// NV4+ passes around an element of this table instead of using a global index
PHWINFO     NvDBPtr_Table[MAX_INSTANCE]={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

RMINFO      NvRmInfo;

// globals used by the OS specific calls
U032        nvInfoSelector      = 0;
U032        clientInfoSelector  = 0;
U032        rmInService;
U032        osInService;
U032        rmInSafeService;
U032        rmInCallback;

// NV RM API functions

/*
NV01_ALLOC_ROOT
    NVOS01_PARAMETERS:
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 status
*/
VOID Nv01AllocRoot(
    NVOS01_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating root...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    class:", ARG(hClass));

    ARG(status) = RmAllocClient(
        &ARG(hObjectNew),
        ARG(hClass)
    );
    if (ARG(status) == NVOS01_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   client:", ARG(hObjectNew));
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...root object allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...root object allocation *FAILED*\n");
    }

} // end of Nv01AllocRoot()

/*
NV01_ALLOC_DEVICE
    NVOS06_PARAMETERS:
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvP64 szName
        NvV32 status
*/
VOID Nv01AllocDevice(
    NVOS06_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating device...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   client:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   device:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    class:", ARG(hClass));

    ARG(status) = RmAllocDevice(
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
#if _WIN32_WINNT >= 0x0400
        (char*)ARG_P064(szName)
#else
        (char*)ARG(szName)
#endif
    );
    if (ARG(status) == NVOS06_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...device allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...device allocation *FAILED*\n");
    }

} // end of Nv01AllocDevice()

/*
NV01_ALLOC_CONTEXT_DMA
    NVOS03_PARAMETERS:
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 flags
        NvP64 pBase
        NvU64 limit
        NvV32 status
*/
VOID Nv01AllocContextDma(
    NVOS03_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: Allocating DMA context...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    client:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:   context:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     flags:", ARG(flags));
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:     pBase:", (VOID*)ARG_P064(pBase));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", (U032)ARG_U064(limit));

    ARG(status) = RmAllocContextDma(
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(flags),
        ARG_SELECTOR(pBase),
        (VOID *)ARG_P064(pBase),
        (U032)ARG_U064(limit)
    );
    if (ARG(status) == NVOS03_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...DMA context allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ...DMA context allocation *FAILED*\n");
    }

} // end of Nv01AllocContextDma()

/*
NV01_ALLOC_CHANNEL_PIO
    NVOS04_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 hObjectError
        NvP64 pChannel
        NvV32 flags
        NvV32 status
*/
VOID Nv01AllocChannelPio(
    NVOS04_PARAMETERS *pArgs
)
{
    VOID *channel;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating PIO channel...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    device:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     error:", ARG(hObjectError));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     flage:", ARG(flags));

    // allocate the PIO channel
    ARG(status) = RmAllocChannelPio(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(hObjectError),
        &channel,
        ARG(flags)
    );
    ARG_P064(pChannel) = (NvP64_VALUE_T)channel;
    if (ARG(status) == NVOS04_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...PIO channel allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...PIO channel allocation *FAILED*\n");
    }

} // end of Nv01AllocChannelPio()

/*
NV03_ALLOC_CHANNEL_DMA
    NVOS07_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent
        NvV32 hObjectNew
        NvV32 hClass
        NvV32 hObjectError
        NvV32 hObjectBuffer
        NvU32 offset
        NvP64 pControl
        NvV32 status
*/
VOID Nv03AllocChannelDma(
    NVOS07_PARAMETERS *pArgs
)
{
    VOID *control;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating DMA channel...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      device:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     channel:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:       class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   error ctx:", ARG(hObjectError));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    data ctx:", ARG(hObjectBuffer));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:      offset:", ARG(offset));

    // allocate DMA channel
    ARG(status) = RmAllocChannelDma(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(hObjectError),
        ARG(hObjectBuffer),
        ARG(offset),
        &control
    );
    ARG_P064(pControl) = (NvP64_VALUE_T)control;
    if (ARG(status) == NVOS07_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMA channel allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...DMA channel allocation *FAILED*\n");
    }

} // end of Nv03AllocChannelDma()

/*
NV01_ALLOC_MEMORY
        NVOS02_PARAMETERS:
        NvV32 hRoot;       
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 flags;
        NvP64 pMemory;
        NvU64 pLimit;
        NvV32 status;
*/
VOID Nv01AllocMemory(
    NVOS02_PARAMETERS *pArgs
)
{
    VOID *memory;
    U032 limit;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating memory...\n");
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating memory...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    parent:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    memory:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     flags:", ARG(flags));
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:   pMemory:", (VOID*)ARG_P064(pMemory));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     limit:", (U032)ARG_U064(pLimit));

    // allocate memory

    memory = (VOID *)ARG_P064(pMemory);
    limit = (U032)ARG_U064(pLimit);

    ARG(status) = RmAllocMemory(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(flags),
        &memory,
        &limit
    );

    ARG_P064(pMemory) = (NvP64_VALUE_T)memory;
    ARG_U064(pLimit) = (NvU64_VALUE_T)limit;

    if (ARG(status) == NVOS02_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...memory allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...memory allocation *FAILED*\n");
    }

} // end of Nv01AllocMemory()

/*
NV01_ALLOC_DEVICE
    NVOS05_PARAMETERS
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 status;
*/
VOID Nv01AllocObject(
    NVOS05_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));

    ARG(status) = RmAllocObject(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass)
    );
    if (ARG(status) == NVOS05_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...object allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...object allocation *FAILED*\n");
    }

} // end of Nv01AllocObject()

/*
NV04_ALLOC
    NVOS21_PARAMETERS;
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvP64 pAllocParms;
        NvV32 status;
*/
VOID Nv04Alloc(
    NVOS21_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     class:", ARG(hClass));

    ARG(status) = RmAlloc(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        (VOID *) ARG_P064(pAllocParms)
    );
    if (ARG(status) == NVOS21_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...allocation *FAILED*\n");
    }

} // end of Nv04Alloc()

/*
NV01_ALLOC_EVENT
    NVOS10_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectNew;
        NvV32 hClass;
        NvV32 index;
        NvU64 hEvent;
        NvV32 status;
*/
VOID Nv01AllocEvent(
    NVOS10_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Allocating Event...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Parent:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Object:", ARG(hObjectNew));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Class:",  ARG(hClass));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Index:",  ARG(index));
    DBG_PRINT_STRING_VAL64(DEBUGLEVEL_TRACEINFO,  "NVRM:   Event:",  ARG(hEvent));

    ARG(status) = RmAllocEvent(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectNew),
        ARG(hClass),
        ARG(index),
        ARG(hEvent)
    );
    if (ARG(status) == NVOS10_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...event allocation complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...event allocation *FAILED*\n");
    }

} // end of Nv01AllocEvent()

/*
NV01_FREE
    NVOS00_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectOld;
        NvV32 status;
*/
VOID Nv01Free(
    NVOS00_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Freeing object...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   parent:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   object:", ARG(hObjectOld));

    ARG(status) = RmFree(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectOld)
    );
    if (ARG(status) == NVOS00_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...object free complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...object free *FAILED*\n");
    }

} // end of Nv01Free()

/*
NV03_DMA_FLOW_CONTROL
    NVOS08_PARAMETERS:
        NvV32 hChannel
        NvV32 flags
        NvU32 put
        NvU32 get
        NvV32 status
*/
VOID Nv03DmaFlowControl(
    NVOS08_PARAMETERS *pArgs
)
{
    // This function is not valid on NV4 and later devices.
    ARG(status) = NVOS08_STATUS_ERROR_BAD_OBJECT_PARENT;
    if (ARG(status) == NVOS08_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMA channel flow control complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...DMA channel flow control *FAILED*\n");
    }
} // end of Nv3DmaFlowControl()

/*
NV01_ARCH_HEAP
    NVOS11_PARAMETERS;
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvU32 function;
        NvU32 owner;
        NvU32 type;
        NvU32 depth;
        NvU32 width;
        NvU32 height;
        NvS32 pitch;
        NvU32 offset;
        NvU32 size;
        NvP64 address;
        NvU64 limit;
        NvU32 total;
        NvU32 free;
        NvV32 status;
*/
VOID Nv03ArchHeap(
    NVOS11_PARAMETERS *pArgs
)
{
    VOID *address;
#if DBG
    // allow for the disabling of the enormous amount of spew from heap manipulations
    U032 saveDebuglevel = cur_debuglevel;
    //cur_debuglevel = DEBUGLEVEL_ERRORS;
#endif
    
	DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Arch Heap...\n");
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hRoot));
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hObjectParent));

    ARG(status) = RmArchHeap(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(function),
        ARG(owner),
        ARG(type),
        ARG(depth),
        ARG(width),
        ARG(height),
        &ARG(pitch),
        &ARG(offset),
        &ARG(size),
        &address,
        &ARG(limit),
        &ARG(total),
        &ARG(free)
    );
#if _WIN32_WINNT >= 0x0400
    ARG_P064(address) = (NvP64_VALUE_T)address;
#else
    ARG(address) = (NvU32)address;
#endif
    if (ARG(status) == NVOS11_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Arch Heap complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Arch Heap *FAILED*\n");
    }

#if DBG
     cur_debuglevel = saveDebuglevel;
#endif

} // end of Nv03ArchHeap()

/*
NV01_CONFIG_VERSION:
    NVOS12_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 version;
        NvV32 status;
*/
VOID Nv01ConfigVersion(
    NVOS12_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Version...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(version));

    ARG(status) = RmConfigVersion(
        ARG(hClient),
        ARG(hDevice),
        &ARG(version)
    );
    if (ARG(status) == NVOS12_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Version complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Version *FAILED*\n");
    }

} // end of Nv01ConfigVersion()

/*
NV01_CONFIG_GET:
    NVOS13_PARAMETERS:
      NvV32 hClient;
      NvV32 hDevice;
      NvV32 index;
      NvV32 value;
      NvV32 status;
*/
VOID Nv01ConfigGet(
    NVOS13_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Get...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Index:", ARG(index));

    // get a specific configuration value
    ARG(status) = RmConfigGet(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
        &ARG(value)
    );
    if (ARG(status) == NVOS13_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Get complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Get *FAILED*\n");
    }

} // end of Nv01ConfigGet()

/*
NV01_CONFIG_SET:
    NVOS14_PARAMETERS:
      NvV32 hClient;
      NvV32 hDevice;
      NvV32 index;
      NvV32 oldValue;
      NvV32 newValue;
      NvV32 status;
*/
VOID Nv01ConfigSet(
    NVOS14_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: Setting Configuration...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Value:", ARG(newValue));

    // set a specific configuration value
    ARG(status) = RmConfigSet(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
        &ARG(oldValue),
        ARG(newValue)
    );
    if (ARG(status) == NVOS14_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Set complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Set *FAILED*\n");
    }

} // end of Nv01ConfigSet()

/*
NV01_CONFIG_UPDATE:
    NVOS15_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 flags;
        NvV32 status;
*/
VOID Nv01ConfigUpdate(
    NVOS15_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Config Update...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Flags:", ARG(flags));

    ARG(status) = RmConfigUpdate(
        ARG(hClient),
        ARG(hDevice),
        ARG(flags)
    );
    if (ARG(status) == NVOS15_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Config Update complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Config Update *FAILED*\n");
    }

} // end of Nv01ConfigUpdate()

/*
NV04_CONFIG_GET_EX:
    NVOS_CONFIG_GET_EX_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 index;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04ConfigGetEx(
    NVOS_CONFIG_GET_EX_PARAMS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: config getEx...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: Parm size:", ARG(paramSize));

    ARG(status) = RmConfigGetEx(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr),
#else
        (VOID*)ARG(paramStructPtr),
#endif
        ARG(paramSize)
    );
    if (ARG(status) == NVOS_CGE_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...config getEx complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...config getEx *FAILED*\n");
    }

} // end of Nv04ConfigGetEx()

/*
NV04_CONFIG_SET_EX:
    NVOS_CONFIG_SET_EX_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 index;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04ConfigSetEx(
    NVOS_CONFIG_SET_EX_PARAMS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: config SetEx...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Index:", ARG(index));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  Parm Ptr:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM: Parm size:", ARG(paramSize));

    ARG(status) = RmConfigSetEx(
        ARG(hClient),
        ARG(hDevice),
        ARG(index),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr),
#else
        (VOID*)ARG(paramStructPtr),
#endif
        ARG(paramSize)
    );
    if (ARG(status) == NVOS_CSE_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...config SetEx complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...config SetEx *FAILED*\n");
    }

} // end of Nv04ConfigSetEx()

/*
NV01_INTERRUPT:
    NVOS09_PARAMETERS:
        NvV32 hClient;
        NvV32 hDevice;
        NvV32 status;
*/

VOID Nv01Interrupt(
    NVOS09_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: interrupt...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Device:", ARG(hDevice));


    // service an interrupt
    ARG(status) = RmInterrupt(
        ARG(hClient),
        ARG(hDevice)
    );
    if (ARG(status) == NVOS09_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...interrupt service complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...interrupt service *FAILED*\n");
    }

} // end of Nv01Interrupt()

/*
NV04_RING0_CALLBACK:
    NVRM_RING0CALLBACK_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvP64 functionPtr;
        NvU32 param1;
        NvU32 param2;
        NvV32 status;
    typedef NvU32 (*RING0CALLBACKPROC)(NvU32, NvU32);
*/
VOID NvRing0Callback(
    NVRM_RING0CALLBACK_PARAMS *pArgs
)
{
#if _WIN32_WINNT >= 0x0400
    RING0CALLBACKPROC callbackFct = (RING0CALLBACKPROC)ARG_P064(functionPtr);
#else
    RING0CALLBACKPROC callbackFct = ARG(functionPtr);
#endif

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Ring 0 Callback...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG_P064(functionPtr));
#else
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG(functionPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   param1:", ARG(param1));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   param2:", ARG(param2));

    ARG(status) = callbackFct(
        ARG(param1),
        ARG(param2)
    );
    if (ARG(status) == NVOS16_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...Ring 0 Callback complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...Ring 0 Callback *FAILED*\n");
    }

} // end of NvRing0Callback()

/*
NV04_I2C_ACCESS
    NVOS_I2C_ACCESS_PARAMS:
        NvV32 hClient;
        NvV32 hDevice;
        NvP64 paramStructPtr;
        NvU32 paramSize;
        NvV32 status;
*/
VOID Nv04I2CAccess(
    NVOS_I2C_ACCESS_PARAMS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: I2C Access...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Client:", ARG(hClient));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(hDevice));
#if _WIN32_WINNT >= 0x0400
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", (VOID*)ARG_P064(paramStructPtr));
#else
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     func:", ARG(paramStructPtr));
#endif
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Device:", ARG(paramSize));

    ARG(status) = RmI2CAccess(
        ARG(hClient),
        ARG(hDevice),
#if _WIN32_WINNT >= 0x0400
        (VOID*)ARG_P064(paramStructPtr)
#else
        (VOID*)ARG(paramStructPtr)
#endif
    );
    if (ARG(status) == NVOS_I2C_ACCESS_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...I2C Access complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...I2C Access *FAILED*\n");
    }

} // end of Nv04I2CAccess()

/*
NV04_DIRECT_METHOD_CALL
    NVOS1D_PARAMETERS:
        NvV32 hRoot;
        NvV32 hObjectParent;
        NvV32 hObjectOld;
        NvV32 method;
        NvV32 data;
        NvV32 status;
*/
VOID Nv04DirectMethodCall(
    NVOS1D_PARAMETERS *pArgs
)
{
    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Performing Direct Method Call...\n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   client:", ARG(hRoot));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   channel:", ARG(hObjectParent));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   object:", ARG(hObjectOld));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   method:", ARG(method));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   data:", ARG(data));

    ARG(status) = RmDirectMethodCall(
        ARG(hRoot),
        ARG(hObjectParent),
        ARG(hObjectOld),
        ARG(method),
        ARG(data)
    );
    if (ARG(status) == NVOS1D_STATUS_SUCCESS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM: ...DMC complete\n");
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: ...DMC *FAILED*\n");
    }

} // end of Nv04DirectMethodCall()

NvV32 RmAllocClient(
    U032 *phClient,
    U032 hClass
)
{
    RM_STATUS rmStatus = RM_OK;

    // register a new client and return the client handle
    rmStatus = CliAddClient(phClient, hClass);

    return RmArchStatus(rmStatus, NV01_ALLOC_ROOT);

} // end of RmAllocClient

NvV32 RmAllocDevice(
    NvV32 hClient,
    NvV32 hDevice,
    NvV32 hClass,
    char *szName
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_DEVICE);
    }

    // The caller has to either pass a valid device class (NV01_DEVICE_0 through NV01_DEVICE_7)
    // or pass NV03_DEVICE_XX as the hClass and pass the name of the device in szName.
    rmStatus = osDeviceNameToDeviceClass(szName, &hClass);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_BAD_CLASS, NV01_ALLOC_DEVICE);
    }

    // add new device to client and set the device context
    rmStatus = CliAddDevice(hClient, hDevice, hClass);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_DEVICE);
    }

    // register all DMA contexts with the device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        rmStatus = dmaRegisterToDevice(pDev, pDmaInfo, &pDmaObject);
        if (!RM_SUCCESS(rmStatus))
        {
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);

} // end of RmAllocDevice

NvV32 RmAllocContextDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    VOID* base,
    U032 limit
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PCLI_DEVICE_INFO deviceList = 0;
    PCLI_FIFO_INFO fifoList;
    PDMAOBJECT pDmaObject;
    U032 i, j, hDeviceWithFrameBufferCtx = 0;
    PHWINFO pDev;

    // A limit of 0 is not valid.
    if (limit == 0)
    {
        return NVOS03_STATUS_ERROR_BAD_LIMIT;
    }

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
    }

    // add DMA context to client
    rmStatus = CliAddDma(hClient, hDma, hClass, flags, selector, base, limit, &pDmaInfo);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(rmStatus, NV01_ALLOC_CONTEXT_DMA);
    }

    // TO DO: USE FLAGS FOR CREATION??

    // lock down DMA pages -- zero length is not an error for legacy reasons
    if (pDmaInfo->DescLimit != 0)
    {
        // validate DMA buffer address, searching each device's FB
        if ((deviceList = CliGetDeviceList()) == NULL)
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
        }
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
                {
                    RmFreeContextDma(hClient, hDma);
                    return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_CONTEXT_DMA);
                }
                rmStatus = osGetAddressInfo(
                    pDev,
                    0 /* ChId */,
                    pDmaInfo->DescSelector,
                    &pDmaInfo->DescOffset,
                    pDmaInfo->DescLimit,
                    &pDmaInfo->DescAddr,
                    &pDmaInfo->AddressSpace
                    );

                if (!RM_SUCCESS(rmStatus))
                {
                    RmFreeContextDma(hClient, hDma);
                    return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_CONTEXT_DMA);
                }
                if (pDmaInfo->AddressSpace != ADDR_UNKNOWN)
                {
                    // found the buffer -- remember the device, if the context describes a frame buffer
                    hDeviceWithFrameBufferCtx = (pDmaInfo->AddressSpace == ADDR_FBMEM) ? deviceList[i].Handle : 0;
                    break;
                }
            }
        }

        // calculate page table values
        pDmaInfo->BufferSize = pDmaInfo->DescLimit + 1;
        osCalculatePteAdjust(pDev, pDmaInfo->AddressSpace, pDmaInfo->DescAddr, &pDmaInfo->PteAdjust);
        pDmaInfo->PteLimit   = pDmaInfo->DescLimit; // pDmaInfo->PteAdjust + pDmaInfo->BufferSize;
        pDmaInfo->PteCount   = (pDmaInfo->PteLimit + pDmaInfo->PteAdjust + RM_PAGE_SIZE - 1) >> RM_PAGE_SHIFT;
        rmStatus = osAllocMem((VOID **)&(pDmaInfo->PteArray), pDmaInfo->PteCount * 4);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_CONTEXT_DMA);
        }

        // lock DMA buffer
        rmStatus = osLockUserMem(
            pDev,
            INVALID_CHID,
            pDmaInfo->DescSelector,
            pDmaInfo->DescOffset,
            pDmaInfo->DescAddr,
            &pDmaInfo->AddressSpace,
            pDmaInfo->DescLimit,
            pDmaInfo->PteCount,
            pDmaInfo->PteArray,
            &pDmaInfo->BufferBase,
            &pDmaInfo->LockHandle
        );
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeContextDma(hClient, hDma);
            return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_CONTEXT_DMA);
        }
    }

    // register and bind DMA context
    for (i = 0; i < NUM_DEVICES; i++)
    {
        if (deviceList && deviceList[i].InUse)
        {
            // set the device context
            if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
            {
                rmStatus = RM_ERR_BAD_OBJECT_PARENT;
                break;
            }

            // only allow the device with a DMA context in its FB to be registered as such
            if(deviceList[i].Handle == hDeviceWithFrameBufferCtx)
              pDmaInfo->AddressSpace = ADDR_FBMEM;
            
            // register DMA context with the current device
            if (!RM_SUCCESS(rmStatus = dmaRegisterToDevice(pDev, pDmaInfo, &pDmaObject)))
            {
                break;
            }

            // bind DMA context to all FIFOs of the current device
            if (!CliGetDeviceFifoList(deviceList[i].Handle, &fifoList))
            {
                rmStatus = RM_ERR_BAD_OBJECT_PARENT;
                break;
            }
            for (j = 0; j < NUM_FIFOS; j++)
            {
                if (fifoList && fifoList[j].InUse)
                {
                    if (!RM_SUCCESS(rmStatus = dmaBindToChannel(pDev, pDmaObject, j)))
                    {
                        break;
                    }
                }
            }
            if (!RM_SUCCESS(rmStatus))
            {
                break;
            }
        }
    }
    if (!RM_SUCCESS(rmStatus))
    {
        RmFreeContextDma(hClient, hDma);
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_CONTEXT_DMA);

} // end of RmAllocContextDma()

NvV32 RmAllocChannelPio(
    U032 hClient,
    U032 hDevice,
    U032 hPioChannel,
    U032 hClass,
    U032 hErrorContext,
    VOID** ppChannel,
    U032 flags
)
{
    RM_STATUS rmStatus = RM_OK;

    rmStatus = RmAllocChannel(
        hClient,
        hDevice,
        hPioChannel,
        hClass,
        hErrorContext,
        0,          // no DMA context
        0,          // no DMA push initial offset
        ppChannel,
        flags
    );

    return RmArchStatus(rmStatus, NV01_ALLOC_CHANNEL_PIO);

} // end of RmAllocChannelPio()

NvV32 RmAllocChannelDma(
    U032 hClient,
    U032 hDevice,
    U032 hDmaChannel,
    U032 hClass,
    U032 hErrorContext,
    U032 hDataContext,
    U032 offset,
    VOID** ppControl
)
{
    RM_STATUS rmStatus = RM_OK;

    rmStatus = RmAllocChannel(
        hClient,
        hDevice,
        hDmaChannel,
        hClass,
        hErrorContext,
        hDataContext,
        offset,
        ppControl,
        0           // no flags
    );

    return RmArchStatus(rmStatus, NV03_ALLOC_CHANNEL_DMA);

} // end of RmAllocChannelDma()

RM_STATUS RmAllocChannel(
    U032 hClient,
    U032 hDevice,
    U032 hChannel,
    U032 hClass,
    U032 hErrorContext,
    U032 hDataContext,
    U032 offset,
    VOID** ppChannel,
    U032 flags
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 chID;
    U032 length = CHANNEL_LENGTH;
    PDMAOBJECT pDmaObject;
    PCLI_DMA_INFO pDmaInfo;
    U032 clientClass;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        CliDelDeviceFifo(hDevice, hChannel);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // allocate the channel based on hDataContext
    if (hDataContext == 0)
    {
        // allocate a PIO channel
        rmStatus = fifoAlloc(pDev, hClass, &chID);
    }
    else
    {
        // get context dma object
        if (RM_SUCCESS(rmStatus = dmaFindContext(pDev, hDataContext, hClient, &pDmaObject)))
        {
            // allocate a DMA channel
            rmStatus = fifoAllocDma(pDev, hClass, &chID, pDmaObject);
        }
    }

    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }

    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // map the channel
    switch (hClass)
    {
        // special case the nv3 dma channel
        case NV03_CHANNEL_DMA:
            *ppChannel = NULL;
            break;
        default:
        {
            rmStatus = osMapFifo(pDev, clientClass, chID, ppChannel);
            break;
        }
    }
    if (!RM_SUCCESS(rmStatus))
    {
        fifoFree(pDev, chID);
        //CliDelDeviceFifo(hDevice, hChannel);
        return rmStatus;
    }
    //pFifoInfo->Flat = *ppChannel;

    // add fifo to device fifo list
    rmStatus = CliAddDeviceFifo(
        pDev,
        hDevice,
        hChannel,
        hClass,
        hErrorContext,
        hDataContext,
        offset,
        flags,
        chID,
        *ppChannel
    );
    if (!RM_SUCCESS(rmStatus))
    {
        osUnmapMemory(pDev, clientClass, *ppChannel, length);
        fifoFree(pDev, chID);
        return rmStatus;
    }

    // bind all DMA contexts of the client to the FIFO of the current device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        // When the device was allocated, the dma context was registered to it.
        // Find the dmaObject created at that time.
        rmStatus = dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeChannel(hClient, hDevice, hChannel);
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
        rmStatus = dmaBindToChannel(pDev, pDmaObject, chID);
        if (!RM_SUCCESS(rmStatus))
        {
            RmFreeChannel(hClient, hDevice, hChannel);
            return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
        }
    }

    rmStatus = 0;

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM:   logical address:", *ppChannel);

    return rmStatus;

} // end of RmAllocChannel()

NvV32 RmAllocMemory(
    U032 hClient,
    U032 hParent,
    U032 hMemory,
    U032 hClass,
    U032 flags,
    VOID** pAddress,
    U032* pLimit
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 trueLength;
    U032 instance = 0;
    BOOL addDeviceMemory = TRUE;
    PHWINFO pDev;
    VOID *pMemData = NULL;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_MEMORY);
    }

    // set the device context
    if (!CliSetDeviceContext(hParent, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_MEMORY);
    }

    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:

            rmStatus = RmAllocSystemMemory(pDev, hClient, pAddress, pLimit, &pMemData, flags);
            if (RM_SUCCESS(rmStatus))
            {
                rmStatus = CliAddMemory(hClient, hMemory, hClass, flags, *pAddress, *pLimit + 1, pMemData);
                if (!RM_SUCCESS(rmStatus))
                {
                    RmFreeSystemMemory(pDev, hMemory);
                }
            }
            break;


        // modified by Chuck Moidel
        case NV01_MEMORY_LOCAL_PRIVILEGED:
            #ifndef NV3
            RM_ASSERT(0);  //NV01_MEMORY_LOCAL_PRIVILEGED should only be used by NV3 and before
            #endif
            /*
            // the length returned is the offset into instance memory, but the
            // true length is registered with the client.
            rmStatus = RmAllocInstanceMemory(pDev, hClient, pAddress, pLimit, &trueLength, &instance);
            if (RM_SUCCESS(rmStatus))
            {
               rmStatus = CliAddDeviceMemory(hParent, hMemory, hClass, *pAddress, trueLength, instance, 0);
               // is this right to return the status of the Free rather than the failure of CliAddDeviceMemory??
               if (!RM_SUCCESS(rmStatus))
               {
                   rmStatus = RmFreeInstanceMemory(pDev, hClient, hParent, hMemory);
               }
            }
            */
            break;

        /*
        ATTENTION!
        RmAllocMemory(NV01_MEMORY_LOCAL_USER) and RmAlloc(NV01_MEMORY_LOCAL USER) do VERY different things.
        For more information see nvarch.h  - added by Charles Moidel
        */

        case NV01_MEMORY_LOCAL_USER: /* please note that this function does not allocate ANY framebuffer memory.
                                        This function only allocates and returns a dumb linear mapping to the entire 
                                        framebuffer.  -C.Moidel
                                     */

            // if the address is non-NULL, only return the length -- don't add as device memory
            addDeviceMemory = !*pAddress;
            rmStatus = RmAllocFrameBufferMapping(pDev, hClient, pAddress, pLimit);
            trueLength = *pLimit;

            // add the device memory info to the client database
            if (RM_SUCCESS(rmStatus) && addDeviceMemory)
            {
                rmStatus = CliAddDeviceMemory(hParent, hMemory, hClass, *pAddress, trueLength, instance, 0, 0);
                if (!RM_SUCCESS(rmStatus))
                {
                    rmStatus = RmFreeFrameBuffer(pDev, hClient, hParent, hMemory);
                }
            }
            break;

        default:
            rmStatus = RM_ERR_BAD_CLASS;
            break;
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_MEMORY);

} // end of RmAllocMemory()

RM_STATUS RmAllocSystemMemory(
    PHWINFO pDev,
    U032    hClient,
    VOID**   pAddress,
    U032*   pLimit,
    VOID**  pMemData,
    U032    flags
)
{
    RM_STATUS rmStatus = RM_OK;
    U032      MemoryType, Contiguous, PageCount;
    U032      Cache = 0;
    U032      clientClass;

    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    //
    // Allocate system memory
    //
    // 4k Page sized allocation?  This is the page size default for arch work.
    // Remember that the given length is actually a limit (size-1)
    //
    if ((*pLimit + 1) & 0xFFF)
    {
        //
        // Not a page request.  Don't support for now.
        //
        rmStatus = NVOS03_STATUS_ERROR_BAD_LIMIT;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Invalid limit: not page aligned\n");
        return rmStatus;
    }
    else
    {
        //
        // Page sized request
        //
        // Convert arch constants into RM constants.
        //
        PageCount = (*pLimit + 1) >> 12;

        if (DRF_VAL(OS02, _FLAGS, _LOCATION, flags) == NVOS02_FLAGS_LOCATION_AGP)
            MemoryType = NV_MEMORY_TYPE_AGP;
        else
            MemoryType = NV_MEMORY_TYPE_SYSTEM;

        if (DRF_VAL(OS02, _FLAGS, _PHYSICALITY, flags) == NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS)
            Contiguous = NV_MEMORY_CONTIGUOUS;
        else
            Contiguous = NV_MEMORY_NONCONTIGUOUS;

        if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_UNCACHED)
            Cache = NV_MEMORY_UNCACHED;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_CACHED)
            Cache = NV_MEMORY_DEFAULT;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_COMBINE)
            Cache = NV_MEMORY_WRITECOMBINED;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_THROUGH)
            Cache = NV_MEMORY_WRITETHRU;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_PROTECT)
            Cache = NV_MEMORY_WRITEPROTECT;
        else if (DRF_VAL(OS02, _FLAGS, _COHERENCY, flags) == NVOS02_FLAGS_COHERENCY_WRITE_BACK)
            Cache = NV_MEMORY_WRITEBACK;

        rmStatus = osAllocPages(pDev,
                                pAddress,
                                PageCount,
                                MemoryType,
                                Contiguous,
                                Cache,
                                clientClass,
                                pMemData);

        if (!RM_SUCCESS(rmStatus))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot allocate pages\n");
            rmStatus = NVOS02_STATUS_ERROR_BAD_FLAGS;
            return rmStatus;
        }
    }

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM: after system memory allocation:\n");
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   pMemory:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", *pLimit);

    return rmStatus;

} // end of RmAllocSystemMemory()

RM_STATUS RmAllocInstanceMemory(
    PHWINFO pDev,
    U032 hClient,
    VOID** pAddress,
    U032* pLength,
    U032* pTrueLength,
    U032* pInstance
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 instMemOffset, clientClass;
    // U032 instanceMemoryPciAddress = INSTANCE_MEMORY_BASE;

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // NOTE: never allocate cursor memory for client of type "user"
    // TO DO: this is not generalized -- for NV3 legacy reasons, only a kernel client can alloc inst mem
    // validate the client class
    if (clientClass != NV01_ROOT)
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // allocate instance memory for the cursor aligned on 2K boundary
    rmStatus = fbAllocInstMemAlign(pDev, pInstance, *pLength >> 4, 0x800 >> 4);
    if (!RM_SUCCESS(rmStatus))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot allocate instance for cursor\n");
        return rmStatus;
    }
    instMemOffset = *pInstance << 4;

    // map the memory into the client's context
    rmStatus = osMapInstanceMemory(pDev, clientClass, instMemOffset, *pLength, pAddress);
    if (!RM_SUCCESS(rmStatus))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot map instance memory for cursor\n");
        return rmStatus;
    }

    // return the offset from the top of instance memory in pLength, and the true length in pTrueLength
    // TODO: eliminate this when the miniport does not talk to HW
    *pTrueLength = *pLength;
    *pLength = instMemOffset;

    DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO, "NVRM:  after cursor allocation:\n");
    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   pMemory:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:     limit:", *pLength);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:  instance:", *pInstance);

    return rmStatus;

} // end of RmAllocInstanceMemory()

RM_STATUS RmAllocFrameBufferMapping(
    PHWINFO pDev,
    U032 hClient,
    VOID** pAddress,
    U032* pLength
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // map frame buffer into the client's context -- only map if null is passed in as address
    *pLength = pDev->Framebuffer.HalInfo.Limit[0];
    if (*pAddress == NULL)
    {
        rmStatus = osMapFrameBuffer(pDev, clientClass, 0, *pLength, pAddress);
        if (!RM_SUCCESS(rmStatus))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  "NVRM: *** Cannot map frame buffer\n");
            return rmStatus;
        }
    }

    DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "NVRM:   address:", *pAddress);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM:    length:", *pLength);

    return rmStatus;

} // end of RmAllocFrameBufferMapping()

NvV32 RmAllocObject(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        //return RmArchStatus(RM_ERR_BAD_CLIENT, NV01_ALLOC_OBJECT);
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_ALLOC_OBJECT);
    }

    // find and set the device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }

    // get the class object
    //nv->subchannel[BLIT_SUBCHANNEL].SetObject = NV_VIDEO_COLORMAP;
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_PARENT, NV01_ALLOC_OBJECT);
    }
    if (hClass == NV01_NULL_OBJECT)
    {
        return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV01_ALLOC_OBJECT);
    }

    rmStatus = fifoSearchObject(pDev, hClass, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_BAD_CLASS, NV01_ALLOC_OBJECT);
    }

    // create the device given its class object
    //nv->subchannel[BLIT_SUBCHANNEL].nvClass.Create = DD_COLORMAP;
    rmStatus = mthdCreate(pDev, pObject, 0, 0, hObject, NULL);
    if (!RM_SUCCESS(rmStatus))
    {
        return RmArchStatus(RM_ERR_INSUFFICIENT_RESOURCES, NV01_ALLOC_OBJECT);
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_OBJECT);

} // end of RmAllocObject()

NvV32 RmAllocEvent
(
    U032 hClient,
    U032 hUser,
    U032 hObject,
    U032 hClass,
    U032 index,
    U064 hEvent
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_EVENT_INFO pEventInfo;
    POBJECT pUser;
    U032 hChannel;

    // set client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;
    }

    // add event to client and parent object
    rmStatus = CliAddEvent(hClient, hUser, hObject, hClass, &pEventInfo);
    if (RM_SUCCESS(rmStatus))
    {
        CliFindObject(hUser, &pUser, &hChannel);
        rmStatus = eventSetObjectEventNotify(pUser, hObject, index, hClass, hEvent);
        if (!RM_SUCCESS(rmStatus))
        {
            CliDelEvent(hObject);
        }
    }

    return RmArchStatus(rmStatus, NV01_ALLOC_EVENT);

} // end of RmAllocEvent()




NvV32 RmAlloc(
    U032 hClient,
    U032 hParent,
    U032 hObject,
    U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS rmStatus = RM_OK;

    //special case for Client Allocation - added by Chuck Moidel
    if (hClass == NV01_ROOT)
    {
        NVOS01_PARAMETERS *pArgs = (NVOS01_PARAMETERS*)pAllocParms;
        ARG(status) = RmAllocClient(&ARG(hObjectNew),ARG(hClass));
        return ARG(status);
    }
    
    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_BAD_CLIENT, NV04_ALLOC);
    }

    // allocate the object based on its class
    switch(hClass)
    {
        //case NV01_NULL_OBJECT:
        case NV01_ROOT:  //should be handled above!! -C.Moidel
            RM_ASSERT(hClass);
            return RmArchStatus(RM_ERR_BAD_CLASS, NV04_ALLOC);

        case NV01_MEMORY_SYSTEM:




        //case NV01_MEMORY_LOCAL_PRIVILEGED:  //shouldn't be using this in NV4+   -C.Moidel

        /*
        ATTENTION!
        RmAllocMemory(NV01_MEMORY_LOCAL_USER) and RmAlloc(NV01_MEMORY_LOCAL USER) do VERY different things.
        For more information see nvarch.h  - added by Charles Moidel
        */
        case NV01_MEMORY_LOCAL_USER:      /*This is used to allocate blocks from the Framebuffer Heap!   -C.Moidel */



        case NV04_HEAP_OWNER:             //added by Chuck Moidel


        case NV01_EVENT:
        case NV01_CONTEXT_DMA:
        case NV01_DEVICE_0:
        case NV01_DEVICE_1:
        case NV01_DEVICE_2:
        case NV01_DEVICE_3:
        case NV01_DEVICE_4:
        case NV01_DEVICE_5:
        case NV01_DEVICE_6:
        case NV01_DEVICE_7:
        case NV03_CHANNEL_PIO:
        case NV04_CHANNEL_PIO:
        case NV03_CHANNEL_DMA:
        case NV04_CHANNEL_DMA:
            return RmArchStatus(RM_ERR_BAD_OBJECT_HANDLE, NV04_ALLOC);

        case NVDE_DEBUGGER:
        case NVDE_REGISTER_DEBUGGER:
        case NVDE_UNREGISTER_DEBUGGER:
        case NVDE_READ_MEMORY:
        case NVDE_WRITE_MEMORY:
        case NVDE_TEST:
        case NVDE_GET_EVENT_INFORMATION:
            rmStatus = RmDebugEx(hClient, hObject, hClass, pAllocParms);
            break;

        default:
            rmStatus = RmAllocObjectEx(hParent, hObject, hClass, pAllocParms);
            break;
    }

    return RmArchStatus(rmStatus, NV04_ALLOC);

} // end of RmAlloc()

RM_STATUS RmAllocObjectEx(
    U032 hChannel,
    U032 hObject,
    U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // set the device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // get the class object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    rmStatus = fifoSearchObject(pDev, hClass, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_BAD_CLASS;
    }

    // create the device given its class object
    rmStatus = mthdCreate(pDev, pObject, 0, 0, hObject, pAllocParms);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    return rmStatus;

} // end of RmAllocObjectEx()

// TO DO: clean up as much as possible despite any errors, for all free routines

NvV32 RmFree(
    U032 hClient,
    U032 hParent,
    U032 hObject
)
{
    U032 client;
    PCLI_DEVICE_INFO pDevice;
    PCLI_FIFO_INFO pFifo;
    PCLI_MEMORY_INFO pMemory;
    PCLI_DMA_INFO pDma;
    PCLI_EVENT_INFO pEvent;
    RM_STATUS rmStatus = RM_OK;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RmArchStatus(RM_ERR_OPERATING_SYSTEM, NV01_FREE);
    }

    // scan all object types
    if (CliGetClientHandle(&client) && client == hObject)
    {
        rmStatus = RmFreeClient(hClient);
    }
    else if (CliGetDeviceInfo(hObject, &pDevice))
    {
        rmStatus = RmFreeDevice(hClient, hObject);
    }
    else if (CliGetDeviceFifoInfo(hParent, hObject, &pFifo))
    {
        rmStatus = RmFreeChannel(hClient, hParent, hObject);
    }
    else if (CliGetDeviceMemoryInfo(hParent, hObject, &pMemory))
    {
        rmStatus = RmFreeMemory(hClient, hParent, pMemory->Class, hObject);
    }
    else if (CliGetDmaInfo(hObject, &pDma))
    {
        rmStatus = RmFreeContextDma(hClient, hObject);
    }
    else if (CliGetMemoryInfo(hObject, &pMemory))
    {
        rmStatus = RmFreeMemory(hClient, hParent, pMemory->Class, hObject);
    }
    else if (CliGetEventInfo(hObject, &pEvent))
    {
        rmStatus = RmFreeEvent(hClient, hObject);
    }
    else
    {
        rmStatus = RmFreeObject(hParent, hObject);
    }

    return RmArchStatus(rmStatus, NV01_FREE);

} // end of RmFree()

RM_STATUS RmFreeClient(
    U032 hClient
)
{
    PHWINFO pDev = (PHWINFO) 0;
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo, nextDma;
    PCLI_DEVICE_INFO deviceList;
    PCLI_MEMORY_INFO pMemoryInfo, nextMem;
    U032 i;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: client\n");

    // free all of the devices of the client
    if ((deviceList = CliGetDeviceList()) != NULL)
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                rmStatus |= RmFreeDevice(hClient, deviceList[i].Handle);
                // This patch is necessary in order to distinguish system memory resources
                // on PCI or on AGP. The architecture separates system memory resources from the
                // device, but in reality there is pDev dependence. This problem should be
                // addressed in the future. This patch could cause problems where a client has
                // alloc'd 2 devices(PCI and AGP) along with some system memory resource. The
                // current driver set does not implement this scenario but I would expect problems
                // in the near future.
                pDev = NvDBPtr_Table[i];
            }
        }
    }
    else
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;

    // free all of the DMA contexts of the client
    nextDma = CliGetDmaList();
    while (nextDma)
    {
        pDmaInfo = nextDma;
        nextDma = nextDma->Next;
        rmStatus |= RmFreeContextDma(hClient, pDmaInfo->Handle);
    }

    // free all client system memory
    nextMem = CliGetMemoryList();
    while (nextMem)
    {
        pMemoryInfo = nextMem;
        nextMem = nextMem->Next;
        rmStatus |= RmFreeSystemMemory(pDev, pMemoryInfo->Handle);
    }

    // free the client
    if (!CliDelClient())
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeClient()

RM_STATUS RmFreeDevice(
    U032 hClient,
    U032 hDevice
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_FIFO_INFO fifoList;
    PCLI_MEMORY_INFO pMemoryInfo;
    PCLI_DMA_INFO pDmaInfo;
    U032 i;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: device\n");

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // if the client was created, but never had any devices successfully
    //   attached, we'll get here.  The client's device structure will have
    //   been created, but pDev will be NULL if the device was later found
    //   to be non-existent
    // Since NUM_FIFOS macro ref's pDev, we stay away
    if (pDev)
    {
        // free all of the FIFOs of the device
        if (CliGetDeviceFifoList(hDevice, &fifoList))
        {
            for (i = 0; i < NUM_FIFOS; i++)
            {
                if (fifoList && fifoList[i].InUse)
                {
                    rmStatus |= RmFreeChannel(hClient, hDevice, fifoList[i].Handle);
                }
            }
        }
    }

    // unregister all DMA contexts with the device
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        if (RM_SUCCESS(dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject)))
        {
            rmStatus |= dmaUnregisterFromDevice(pDev, pDmaObject);
        }
    }

    // free all device memory
    while ((pMemoryInfo = CliGetDeviceMemoryList(hDevice)) != NULL)
    {
        rmStatus |= RmFreeMemory(hClient, hDevice, pMemoryInfo->Class, pMemoryInfo->Handle);
    }

    // free the device
    if (!CliDelDevice(hDevice))
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeDevice()

RM_STATUS RmFreeContextDma(
    U032 hClient,
    U032 hDma
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DEVICE_INFO deviceList;
    PCLI_FIFO_INFO fifoList;
    U032 i, j;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: DMA context\n");

    // unregister and unbind the DMA context
    if ((deviceList = CliGetDeviceList()) == NULL)
    {
        rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
    }
    else
    {
        for (i = 0; i < NUM_DEVICES; i++)
        {
            if (deviceList[i].InUse)
            {
                // set the current device context
                if (!CliSetDeviceContext(deviceList[i].Handle, &pDev))
                {
                    rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
                }

                // get a pointer to the dma object
                else if (RM_SUCCESS(rmStatus |= dmaFindContext(pDev, hDma, hClient, &pDmaObject)))
                {
                    // unbind DMA context from all FIFOs of the current device
                    if (!CliGetDeviceFifoList(deviceList[i].Handle, &fifoList))
                    {
                        rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
                    }
                    else
                    {
                        for (j = 0; j < NUM_FIFOS; j++)
                        {
                            if (fifoList && fifoList[j].InUse)
                            {
                                rmStatus |= dmaUnbindFromChannel(pDev, pDmaObject, j);
                            }
                        }

                        // unregister DMA context with the current device
                        rmStatus |= dmaUnregisterFromDevice(pDev, pDmaObject);
                    }
                }
            }
        }
    }

    // TO DO:  ***** THIS SHOULD HAPPEN HERE, BUT UNTIL IT IS PROVED
    //               IT IS DONE IN DMA DELETE
    /*
    // unlock pages
    if (!CliGetDmaInfo(hDma, &pDmaInfo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }
    rmStatus = osUnlockUserMem(
        INVALID_CHID,
        pDmaInfo->BufferBase,
        pDmaInfo->DescAddr,
        pDmaInfo->AddressSpace,
        pDmaInfo->DescLimit,
        pDmaInfo->PteCount,
        pDmaInfo->LockHandle,
        pDmaInfo->Class == NV_CONTEXT_DMA_TO_MEM ? TRUE : FALSE
    );
    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }
    */

    // delete the DMA context from the client
    if (!CliDelDma(hDma))
    {
        rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
    }

    return rmStatus;

} // end of RmFreeContextDma()

RM_STATUS RmFreeChannel(
    U032 hClient,
    U032 hDevice,
    U032 hFifo
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_DMA_INFO pDmaInfo;
    PCLI_FIFO_INFO pFifoInfo;
    PDMAOBJECT pDmaObject;
    PHWINFO pDev;
    U032 hClass;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: channel\n");

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // unbind all DMA contexts from the FIFO
    for (pDmaInfo = CliGetDmaList(); pDmaInfo; pDmaInfo = pDmaInfo->Next)
    {
        if (!RM_SUCCESS(rmStatus = dmaFindContext(pDev, pDmaInfo->Handle, hClient, &pDmaObject)))
        {
            return rmStatus;
        }
        if (!CliGetDeviceFifoInfo(hDevice, hFifo, &pFifoInfo))
        {
            return RM_ERR_BAD_OBJECT_HANDLE;
        }
        if (!RM_SUCCESS(rmStatus = dmaUnbindFromChannel(pDev, pDmaObject, pFifoInfo->ChID)))
        {
            return rmStatus;
        }
    }

    // unmap the channel
    if (!CliGetDeviceFifoInfo(hDevice, hFifo, &pFifoInfo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }
    hClass = pFifoInfo->Class;

    // NV03_CHANNEL_DMA wasn't mapped into clients address space
    if (hClass != NV03_CHANNEL_DMA)
    {
        U032 clientClass;

        if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
        {
            return RM_ERR_OPERATING_SYSTEM;
        }
        osUnmapMemory(pDev, clientClass, (VOID *)pFifoInfo->Flat, CHANNEL_LENGTH);
    }

    // free the FIFO
    rmStatus = fifoFree(pDev, pFifoInfo->ChID);
    if (!RM_SUCCESS(rmStatus))
    {
        return rmStatus;
    }

    // delete the device fifo info
    if (!CliDelDeviceFifo(hDevice, hFifo))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // remove any events associated with this channel from the client
    CliDelEventUser(hFifo, hClass);

    return rmStatus;

} // end of RmFreeChannel()


RM_STATUS RmFreeMemory
(
    U032 hClient,
    U032 hDevice,
    U032 hClass,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    switch(hClass)
    {
        case NV01_MEMORY_SYSTEM:

            rmStatus = RmFreeSystemMemory(pDev, hMemory);

            // remove the system memory reference from the client
            if (!CliDelMemory(hMemory))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }
            break;

        case NV01_MEMORY_LOCAL_PRIVILEGED:
        case NV01_MEMORY_LOCAL_USER:

            // set the device context
            if (!CliSetDeviceContext(hDevice, &pDev))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_PARENT;
            }

            // free the device memory
            switch(hClass)
            {
                case NV01_MEMORY_LOCAL_PRIVILEGED:
                    rmStatus |= RmFreeInstanceMemory(pDev, hClient, hDevice, hMemory);
                    break;

                case NV01_MEMORY_LOCAL_USER:
                    rmStatus |= RmFreeFrameBuffer(pDev, hClient, hDevice, hMemory);
                    break;
            }

            // remove the device memory reference from the client
            if (!CliDelDeviceMemory(hDevice, hMemory))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }

            break;
    }

    return rmStatus;

} // end of RmFreeMemory()

RM_STATUS RmFreeSystemMemory
(
    PHWINFO pDev,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_MEMORY_INFO pMemoryInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: system memory\n");

    if (!CliGetMemoryInfo(hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        rmStatus = osFreePages(pDev,
                               &pMemoryInfo->Address,
                               pMemoryInfo->Type,
                               pMemoryInfo->Length >> RM_PAGE_SHIFT,
                               pMemoryInfo->MemData,
                               (pMemoryInfo->Coherency == NVOS02_FLAGS_COHERENCY_WRITE_COMBINE));
    }

    return rmStatus;

} // end of RmFreeSystemMemory()

RM_STATUS RmFreeInstanceMemory(
    PHWINFO pDev,
    U032 hClient,
    U032 hDevice,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;
    PCLI_MEMORY_INFO pMemoryInfo;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: cursor memory\n");

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // free the instance memory
    else if (!CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        // unmap the memory
        osUnmapMemory(pDev, clientClass, pMemoryInfo->Address, pMemoryInfo->Length);

        // deallocate the instance memory held by the cursor
        rmStatus = fbFreeInstMem(pDev, pMemoryInfo->Instance, pMemoryInfo->Length >> 4);
    }

    return rmStatus;

} // end of RmFreeInstanceMemory()

RM_STATUS RmFreeFrameBuffer(
    PHWINFO pDev,
    U032 hClient,
    U032 hDevice,
    U032 hMemory
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 clientClass;
    PCLI_MEMORY_INFO pMemoryInfo;
    U032 memHandle;


    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:     type: frame buffer\n");

    // get the class of client
    if (!CliGetClass(NV01_NULL_OBJECT, hClient, &clientClass))
    {
        rmStatus = RM_ERR_BAD_OBJECT_PARENT;
    }

    // free the frame buffer
    else if (!CliGetDeviceMemoryInfo(hDevice, hMemory, &pMemoryInfo))
    {
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    }
    else
    {
        // free the video memory based on how it was alloced ... a non-zero
        // HeapOwner indicates it was heapAlloc-ed.

        if (pMemoryInfo->HeapOwner)
        {
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM: Function: FREE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Owner:", pMemoryInfo->HeapOwner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:   Offset:", pMemoryInfo->Handle);

            // memHandle is returned, but not needed ... the caller already has
            // the correct handle to pass to CliDelDeviceMemory, since it's
            // traversing the client DB.

            rmStatus = heapFree(
                pDev,
                (PHEAP)pDev->Framebuffer.HeapHandle,
                pMemoryInfo->HeapOwner,
                (U032)((U008*)pMemoryInfo->Address - (U008*)fbAddr),
                &memHandle);
        }
        else
        {
            // unmap the memory
            osUnmapMemory(pDev, clientClass, pMemoryInfo->Address, pMemoryInfo->Length);
        }
    }
    return rmStatus;

} // end of RmFreeFrameBuffer()

RM_STATUS RmFreeObject(
    U032 hChannel,
    U032 hObject
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    OBJECT classObject;
    PHWINFO pDev;

    // check for debugger object
    if (NvRmInfo.Debugger.object)
        if (NvRmInfo.Debugger.object->Name == hObject)
            return NvdeFree(hChannel, hObject);

    // set the corresponding device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }

    // contrive the class object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return RM_ERR_BAD_OBJECT_PARENT;
    }
    classObject.Name = NV01_NULL_OBJECT;
    classObject.ChID = pFifo->ChID;

    // destroy the object
    rmStatus = mthdDestroy(pDev, &classObject, 0, 0, hObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return RM_ERR_BAD_OBJECT_HANDLE;
    }

    // remove this user object from client events
    CliDelEventUser(hObject, NV01_NULL_OBJECT);

    return rmStatus;

} // end of RmFreeObject()

RM_STATUS RmFreeEvent(
    U032 hClient,
    U032 hEvent
)
{
    RM_STATUS rmStatus = RM_OK;
    PCLI_EVENT_INFO pEvent;
    PCLI_EVENT_USER nextUser;
    POBJECT pUser;
    U032 hChannel;

    // delete the event from all parent objects and client
    if (CliGetEventInfo(hEvent, &pEvent))
    {
        for (nextUser = pEvent->UserList; nextUser; nextUser = nextUser->Next)
        {
            if (CliFindObject(nextUser->Handle, &pUser, &hChannel))
            {
                eventRemoveObjectEventNotify(pUser, hEvent);
            }
        }
        CliDelEvent(hEvent);
    }
    else
    {
        rmStatus = RM_ERR_BAD_OBJECT;
    }

    return rmStatus;

} // end of RmFreeEvent()

NvV32 RmArchHeap
(
    U032 hRoot,
    U032 hObjectParent,
    U032 function,
    U032 owner,
    U032 type,
    U032 depth,
    U032 width,
    U032 height,
    S032* pPitch,
    U032* pOffset,
    U032* pSize,
    VOID** pAddress,
    U032* pLimit,
    U032* pTotal,
    U032* pFree
)
{
    U032 tempPitch;
    RM_STATUS rmStatus = NVOS11_STATUS_SUCCESS;
    PHWINFO pDev;
    U032 memHandle;
#ifdef DEBUG
    U032 oldFree;
#endif

    // set the client context
    if (!CliSetClientContext(hRoot))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hObjectParent, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    //
    // Heap manager for NV memory.
    //
    if ((owner == 0) || (owner == 0xFFFFFFFF))
    {
        return NVOS11_STATUS_ERROR_INVALID_OWNER;
    }

    //
    // Setup size for DEPTH_WIDTH_HEIGHT or TILED_PITCH_HEIGHT allocs
    //
    if (function == NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT)
    {
        U032 byteWidth;

        // For NV3, scanline alignment is 32 bytes.
        byteWidth = ((width * depth) + 7) >> 3;
        *pSize  = height * ((byteWidth + 31) & ~31);
    }
    else if (function == NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT)
    {
        *pSize  = (height * *pPitch);
        tempPitch = *pPitch;
    }

    switch (function)
    {
        //
        // Alloc mem.
        //
        case NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT:
        case NVOS11_HEAP_ALLOC_SIZE:
            tempPitch = 0;          // pitch is valid only for TILED_PITCH_HEIGHT

        case NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT:
            DBG_PRINT_STRING      (DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: ALLOC\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:  ", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner: ", owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Size:  ", *pSize);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Pitch: ", *pPitch);
            rmStatus =
                heapAlloc
                (
                    pDev,
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    owner,
                    pSize,
                    type,
                    height,
                    &tempPitch,
                    pOffset
                );
            if (rmStatus == RM_OK)
            {
                //
                // Set the mapping for the memory.
                //
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Allocated at Offset: ", *pOffset);
                if (tempPitch)
                {
                    // update pitch value
                    *pPitch = tempPitch;
                }
                *pAddress = (U008*)fbAddr + *pOffset;
                *pLimit = *pSize - 1;

                // add the heapAlloc to the Client DB
                rmStatus =
                    CliAddDeviceMemory
                    (
                        hObjectParent,
                        ((PHEAP)pDev->Framebuffer.HeapHandle)->memHandle, // generated handle
                        NV01_MEMORY_LOCAL_USER,
                        *pAddress,
                        *pSize,
                        0x0,
                        owner,
                        0           //version = 0 because the HeapOwner is just an ID without an allocated object behind it - C.Moidel
                    );
                if (rmStatus != RM_OK)
                {
                    // return the failed rmStatus from CliAddMemory not heapFree
                    (VOID)heapFree
                    (
                        pDev,
                        (PHEAP)pDev->Framebuffer.HeapHandle,
                        owner,
                        *pOffset,
                        &memHandle
                    );
                }
            }
            *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
            *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;

            break;

        //
        // Free mem.
        //
        case NVOS11_HEAP_FREE:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: FREE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner:", owner);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Offset:", *pOffset);

            //
            // OpenGL might try to call heapfree (via an ESCAPE call) before NT
            // ever gets the chance to call RmLoadState (in SetPowerState).
            // So to be safe, make sure the HeapHandle is not null.
            //

            if ( ((PHEAP)pDev->Framebuffer.HeapHandle) != NULL)
            {
                rmStatus =
                    heapFree
                    (
                        pDev,
                        (PHEAP)pDev->Framebuffer.HeapHandle,
                        owner,
                        *pOffset,
                        &memHandle  // return the memory handle used
                    );

                *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
                *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;

                if (!CliDelDeviceMemory(hObjectParent, memHandle))
                {
                    rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
                }
            }

            else
            {
                rmStatus = NVOS11_STATUS_ERROR_INVALID_HEAP;
            }

            break;

        //
        // Purge mem.
        //
        case NVOS11_HEAP_PURGE:

            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: PURGE\n");
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Type:", type);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Owner:", owner);
#ifdef DEBUG
            oldFree = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
#endif
            rmStatus = heapPurge(pDev, (PHEAP)pDev->Framebuffer.HeapHandle, owner);
            *pFree   = ((PHEAP)pDev->Framebuffer.HeapHandle)->free;
            *pTotal  = ((PHEAP)pDev->Framebuffer.HeapHandle)->total;
#ifdef DEBUG
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Blocks puged:", *pFree-oldFree);
#endif
/*
#ifdef DEBUG
            if (!(*pFree-oldFree))
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    You did a PURGE for NO REASON!\n");
            };
#endif
*/

            if (!CliDelDeviceHeapOwner(hObjectParent, owner))
            {
                rmStatus |= RM_ERR_BAD_OBJECT_HANDLE;
            }

            break;

        //
        // Info.
        //
        case NVOS11_HEAP_INFO:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: INFO\n");
            rmStatus =
                heapInfo
                (
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    pFree,
                    pTotal,
                    pAddress,  // base of heap
                    pOffset,   // base of largest free block
                    pSize      // size of largest free block
                );
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:", *pFree);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:", *pTotal);
                DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO,  "NVRM:     Base:", *pAddress);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  MaxFree:", *pSize);
            }

            break;

        //
        // Info with freed blocks.
        //
        // The offsets passed in are considered freed for calculation purposes, but
        // aren't actually freed. Passing -1 as an offset arg indicates offset doesn't
        // contain a valid arg (use the NVOS11_INVALID_BLOCK_FREE_OFFSET #define).
        //
        case NVOS11_HEAP_INFO_FREE_BLOCKS:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: INFO FREE BLOCKS\n");
            rmStatus = 
                heapInfoFreeBlocks
                (
                    (PHEAP)pDev->Framebuffer.HeapHandle,
                    pFree,
                    pTotal,
                    *pOffset,   // offset of block to be considered free
                    *pLimit,    // offset of block to be considered free
                    pSize       // size of resulting largest free block
                );    
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:", *pFree);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:", *pTotal);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:  MaxFree:", *pSize);
            }
            
            break;
            
        //
        // Destroy.
        //
        case NVOS11_HEAP_DESTROY:
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,  "NVRM:    Function: DESTROY\n");
            rmStatus = heapDestroy(pDev, (PHEAP)pDev->Framebuffer.HeapHandle);
            if (rmStatus == RM_OK)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:     Free:",
                    ((PHEAP)pDev->Framebuffer.HeapHandle)->free);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,  "NVRM:    Total:",
                    ((PHEAP)pDev->Framebuffer.HeapHandle)->total);
            }

            break;

        //
        // Invalid.
        //
        default:
            rmStatus = NVOS11_STATUS_ERROR_INVALID_FUNCTION;
            break;
    }

    return rmStatus;

} // end of RmArchHeap

NvV32 RmConfigVersion
(
    U032 hClient,
    U032 hDevice,
    U032* pVersion
)
{
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // call the kernel for help
    //*pVersion = stateConfigVersion(pDev);
    *pVersion = 0x01000000;

    return NVOS12_STATUS_SUCCESS;

} // end of RmConfigVersion

NvV32 RmConfigGet
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    U032* pValue
)
{
    RM_STATUS rmStatus = NVOS13_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS13_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS13_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus = stateConfigGet(pDev, index, pValue);
    if (!RM_SUCCESS(rmStatus))
    {
        rmStatus = NVOS13_STATUS_ERROR_BAD_INDEX;
    }

    return rmStatus;

} // end of RmConfigGet()

NvV32 RmConfigSet
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    U032* pOldValue,
    U032 newValue
)
{
    RM_STATUS rmStatus = NVOS14_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS14_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS14_STATUS_ERROR_BAD_DEVICE;
    }

    // access the kernel state
    rmStatus = stateConfigSet(pDev, index, newValue, pOldValue);
    if (!RM_SUCCESS(rmStatus))
    {
        rmStatus = NVOS14_STATUS_ERROR_BAD_INDEX;
    }

    return rmStatus;

} // end of RmConfigSet()

NvV32 RmConfigUpdate
(
    U032 hClient,
    U032 hDevice,
    U032 flags
)
{
    RM_STATUS rmStatus = NVOS15_STATUS_SUCCESS;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return RM_ERR_OPERATING_SYSTEM;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    // call the kernel for help
    //stateConfigUpdate(pDev, flags);

    return rmStatus;

} // end of RmConfigUpdate

NvV32 RmConfigGetEx
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    VOID* pParms,
    U032 parmsSize
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_CGE_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS_CGE_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus =
        stateConfigGetEx
        (
            pDev,
            index,
            pParms,
            parmsSize
        );

    return RmArchStatus(rmStatus, NV04_CONFIG_GET_EX);

} // end of RmConfigGetEx

NvV32 RmConfigSetEx
(
    U032 hClient,
    U032 hDevice,
    U032 index,
    VOID* pParms,
    U032 parmsSize
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_CSE_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS_CSE_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus =
        stateConfigSetEx
        (
            pDev,
            index,
            pParms,
            parmsSize
        );

    return RmArchStatus(rmStatus, NV04_CONFIG_SET_EX);

} // end of RmConfigSetEx

NvV32 RmInterrupt
(
    U032 hClient,
    U032 hDevice
)
{
    PHWINFO pDev;

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS09_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS09_STATUS_ERROR_BAD_DEVICE;
    }

    // call the os ISR service
    osIsr(pDev);

    return NVOS09_STATUS_SUCCESS;

} // end of RmInterrupt()

RM_STATUS RmAllocDeviceInstance
(
    U032 *pInstance
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 instance, i, instanceSize;

    // allocate the next available device instance
    for (instance = 0; instance < MAX_INSTANCE; instance++)
    {
        if (NvDBPtr_Table[instance] == NULL)
        {
            // allocate and init the device information structure
            instanceSize = sizeof(HWINFO);
            rmStatus = osAllocMem((VOID **)&NvDBPtr_Table[instance], instanceSize);
            if (RM_SUCCESS(rmStatus))
            {
                // clear out the new instance
                for (i = 0; i < instanceSize; i++)
                {
                     ((U008 *)(NvDBPtr_Table[instance]))[i] = 0;
                }
                
                // set the instance self-reference in the device instance
                NvDBPtr_Table[instance]->DBdevInstance = instance;

                // return the instance
                *pInstance = instance;

                // setup the pointer to the global NvRmInfo
                NvDBPtr_Table[instance]->pRmInfo = (VOID_PTR) &NvRmInfo;
            }
            break;
        }
    }
    if (instance == MAX_INSTANCE)
    {
        rmStatus = RM_ERROR;
    }

    return rmStatus;

}

NvV32 RmArchStatus(RM_STATUS rmStatus, U032 archFct)
{
    switch (archFct)
    {
        case NV01_FREE:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS00_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS00_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS00_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS00_STATUS_ERROR_BAD_OBJECT_OLD;
                case RM_ERR_OBJECT_IN_USE:
                    return NVOS00_STATUS_ERROR_OBJECT_IN_USE;
                case RM_ERR_OBJECT_HAS_CHILDERN:
                    return NVOS00_STATUS_ERROR_OBJECT_HAS_CHILDERN;
                default:
                    return rmStatus;
            }
        
        case NV01_ROOT_USER:
        case NV01_ALLOC_ROOT:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS01_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS01_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS01_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS01_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS01_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_MEMORY:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS02_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS02_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS02_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS02_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_CONTEXT_DMA:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS03_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS03_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS03_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS03_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS03_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_FLAGS:
                    return NVOS03_STATUS_ERROR_BAD_FLAGS;
                case RM_ERR_BAD_BASE:
                    return NVOS03_STATUS_ERROR_BAD_BASE;
                case RM_ERR_BAD_LIMIT:
                    return NVOS03_STATUS_ERROR_BAD_LIMIT;
                case RM_ERR_PROTECTION_FAULT:
                    return NVOS03_STATUS_ERROR_PROTECTION_FAULT;
                case RM_ERR_MULTIPLE_MEMORY_TYPES:
                    return NVOS03_STATUS_ERROR_MULTIPLE_MEMORY_TYPES;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS03_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_CHANNEL_PIO:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS04_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS04_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_OBJECT_ERROR:
                    return NVOS04_STATUS_ERROR_BAD_OBJECT_ERROR;
                case RM_ERR_BAD_FLAGS:
                    return NVOS04_STATUS_ERROR_BAD_FLAGS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                case RM_ERR_NO_FREE_FIFOS:
                    return NVOS04_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_OBJECT:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS05_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS05_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS05_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS05_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS05_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS05_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV04_ALLOC:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS21_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS21_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_CLIENT:
                    return NVOS21_STATUS_ERROR_BAD_ROOT;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS21_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS21_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS21_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS21_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV01_ALLOC_DEVICE:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS06_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS06_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS06_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV03_ALLOC_CHANNEL_DMA:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS07_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS07_STATUS_ERROR_OPERATING_SYSTEM;
                case RM_ERR_BAD_OBJECT_PARENT:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_PARENT;
                case RM_ERR_BAD_OBJECT_HANDLE:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_NEW;
                case RM_ERR_BAD_CLASS:
                    return NVOS07_STATUS_ERROR_BAD_CLASS;
                case RM_ERR_BAD_OBJECT_ERROR:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_ERROR;
                case RM_ERR_BAD_OBJECT_BUFFER:
                    return NVOS07_STATUS_ERROR_BAD_OBJECT_BUFFER;
                case RM_ERR_BAD_OFFSET:
                    return NVOS07_STATUS_ERROR_BAD_OFFSET;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                case RM_ERR_NO_FREE_FIFOS:
                    return NVOS07_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                default:
                    return rmStatus;
            }

        case NV04_CONFIG_GET_EX:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS_CGE_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM;
                case CONFIG_GETEX_BAD_INDEX:
                    return NVOS_CGE_STATUS_ERROR_BAD_INDEX;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS_CGE_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                case CONFIG_GETEX_BAD_PARAM:
                    return NVOS_CGE_STATUS_ERROR_BAD_PARAM_STRUCT;
            }

        case NV04_CONFIG_SET_EX:
            switch (rmStatus)
            {
                case RM_OK:
                    return NVOS_CSE_STATUS_SUCCESS;
                case RM_ERR_OPERATING_SYSTEM:
                    return NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM;
                case CONFIG_SETEX_BAD_INDEX:
                    return NVOS_CSE_STATUS_ERROR_BAD_INDEX;
                case RM_ERR_INSUFFICIENT_RESOURCES:
                    return NVOS_CSE_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                case CONFIG_SETEX_BAD_PARAM:
                    return NVOS_CSE_STATUS_ERROR_BAD_PARAM_STRUCT;
            }

        default:
            return rmStatus;
    }

} // end of RmArchStatus()

NvV32 RmI2CAccess
(
    U032  hClient,
    U032  hDevice,
    VOID*  pCtrl
)
{
    RM_STATUS   rmStatus;
    PHWINFO pDev;
    U032        Head = 0;   // TO DO: specify which head
    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;
    }

    // set the correct device context
    // also checking for NULL pDev.
    if (!CliSetDeviceContext(hDevice, &pDev) || !pDev)
    {
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_DEVICE;
    }

    // call the kernel for help
    rmStatus = i2cAccess(pDev, Head, pCtrl);

    return rmStatus;

} // end of RmI2CAccess()

NvV32 RmDirectMethodCall
(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 offset,
    U032 data
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 hDevice;
    PCLI_FIFO_INFO pFifo;
    POBJECT pObject;
    PHWINFO pDev;

    // TO DO: it is necessary to be very restrictive as to which methods can be called -- is there a better test?
    // check for valid methods
    switch (offset)
    {
        case NV046_SET_CONTEXT_DMA_NOTIFIES:
        case NV046_SET_CONTEXT_DMA_LUT(0):
        case NV046_SET_LUT_OFFSET(0):
        case NV046_SET_LUT_FORMAT(0):
        case NV046_SET_CURSOR_POINT:
        case NV046_SET_DAC_IMAGE_SIZE(0):
        case NV046_SET_DAC_HORIZONTAL_BLANK(0):
        case NV046_SET_DAC_HORIZONTAL_SYNC(0):
        case NV046_SET_DAC_VERTICAL_BLANK(0):
        case NV046_SET_DAC_VERTICAL_SYNC(0):
        case NV046_SET_DAC_TOTAL_SIZE(0):
        case NV046_SET_DAC_PIXEL_CLOCK(0):
        case NV046_SET_DAC_FORMAT(0):
            break;

        default:
            return NVOS1D_STATUS_ERROR_BAD_METHOD;
    }

    // set the client context
    if (!CliSetClientContext(hClient))
    {
        return NVOS1D_STATUS_ERROR_OPERATING_SYSTEM;
    }

    // set the corresponding device context
    if (!CliGetDeviceHandle(hChannel, &hDevice))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }
    if (!CliSetDeviceContext(hDevice, &pDev))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }

    // get the object
    if (!CliGetDeviceFifoInfo(hDevice, hChannel, &pFifo))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_PARENT;
    }
    rmStatus = fifoSearchObject(pDev, hObject, pFifo->ChID, &pObject);
    if (!RM_SUCCESS(rmStatus))
    {
        return NVOS1D_STATUS_ERROR_BAD_OBJECT_OLD;
    }

    // call the method directly and safely
    rmStatus = classDirectSoftwareMethod(pDev, pObject, offset, data);
    if (!RM_SUCCESS(rmStatus))
    {
        return NVOS1D_STATUS_ERROR_BAD_DATA;
    }

    return NVOS1D_STATUS_SUCCESS;

} // end of RmDirectMethodCall()

/*
 * Control various debugging facilities in the resource manager
 */

VOID Nv01DebugControl(
    NVOS20_PARAMETERS * configParams
)
{
    RM_STATUS rmStatus = NVOS20_STATUS_SUCCESS;

    switch (configParams->command)
    {
        case NVOS20_COMMAND_RM_FAILURE_ENABLE:
            RM_FAILURE_ENABLE();
            break;

        case NVOS20_COMMAND_RM_FAILURE_DISABLE:
            RM_FAILURE_DISABLE();
            break;
    }

    configParams->status = rmStatus;
} // end of RmDebugControl

RM_STATUS RmDebugEx(
	U032 hClient,
    U032 hObject,
	U032 hClass,
    VOID* pAllocParms
)
{
    RM_STATUS status = RM_OK;

    switch (hClass)
    {
        case NVDE_DEBUGGER:
        {
            status = NvdeAlloc(hObject, pAllocParms);
            break;
        }
        case NVDE_REGISTER_DEBUGGER:
        {
            if (hClient == 0)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;
            if (NvRmInfo.Debugger.Handle != 0)
                return NVDE_STATUS_ERROR_STATE_IN_USE;

            NvRmInfo.Debugger.Handle = hClient;
            break;
        }
        case NVDE_UNREGISTER_DEBUGGER:
        {
            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;
            NvRmInfo.Debugger.Handle = 0;
            break;
        }
        case NVDE_READ_MEMORY:
        {
            NVDE_READ_MEMORY_PARAMETERS *pNvDEParams;
            U008 *in, *out;
            U032 i;

            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;

            //
            // Not bothering with osCopyin/osCopyout here because
            // this code will soon be moved to the DMC interface.
            // 
            // bdw: we need 32-bit xfers to be atomic - please retain
            //      this notion when we port this.
            //
            pNvDEParams = (NVDE_READ_MEMORY_PARAMETERS *)pAllocParms;
            
            in  = (U008 *)pNvDEParams->Data;
            out = (U008 *)pNvDEParams->Address;
            i   = pNvDEParams->Size;
            while (i >= 4)
            {
                *(U032*)in = *(U032*)out;
                in  += 4;
                out += 4;
                i   -= 4;
            }
            while (i)
            {
                *in = *out;
                in  += 1;
                out += 1;
                i   -= 1;
            }
            break;
        }
        case NVDE_WRITE_MEMORY:
        {
            NVDE_WRITE_MEMORY_PARAMETERS *pNvDEParams;
            U008 *in, *out;
            U032 i;

            if (NvRmInfo.Debugger.Handle != hClient)
                return NVDE_STATUS_ERROR_BAD_ARGUMENT;

            //
            // Not bothering with osCopyin/osCopyout here because
            // this code will soon be moved to the DMC interface.
            // 
            // bdw: we need 32-bit xfers to be atomic - please retain
            //      this notion when we port this.
            //
            pNvDEParams = (NVDE_WRITE_MEMORY_PARAMETERS *)pAllocParms;
            
            in  = (U008 *)pNvDEParams->Address;
            out = (U008 *)pNvDEParams->Data;
            i   = pNvDEParams->Size;
            while (i >= 4)
            {
                *(U032*)in = *(U032*)out;
                in  += 4;
                out += 4;
                i   -= 4;
            }
            while (i)
            {
                *in = *out;
                in  += 1;
                out += 1;
                i   -= 1;
            }
            break;
        }
        case NVDE_TEST:
        {
            NVDE_TEST_PARAMETERS *pNvDEParams = (NVDE_TEST_PARAMETERS *)pAllocParms;
            NVDE_TEST_FUNC        pfn         = (NVDE_TEST_FUNC)pNvDEParams->CallBackAddress;

            (pfn)();

            break;
        }
        case NVDE_GET_EVENT_INFORMATION:
        {
            NVDE_GET_EVENT_INFORMATION_PARAMETERS *pNvDEParams = (NVDE_GET_EVENT_INFORMATION_PARAMETERS*)pAllocParms;
            U032 *s, *d;
            int  i;

            pNvDEParams->Count = ((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBufferCount;
            s = &((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBuffer[0].code;
            d = &pNvDEParams->Event[0][0];
            for (i = 0; i < NVDE_MAX_EVENTS * sizeof(NVDEEVENT) / 4; i++)
            {
                *d = *s;
                s++;
                d++;
            }

            // reset events
            ((PNVDEOBJECT)NvRmInfo.Debugger.object)->EventBufferCount = 0;

            break;
        }
    }

    return status;

} // end of RmDebugEx()

// end of nvapi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\nvrmapi.c ===
/*
 * nvRmApi.c
 *
 * NVidia resource manager API.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */
#pragma warning(disable : 4101 4035)

/*
 * Function defined in the scope of this file.
 */
static DWORD GetWindowsType(void);

/*
 ********************************************************************************
 * The following functions are the external, exported API to the resource manager.
 ********************************************************************************
/*
 * NvRmOpen - open connection to resource manager
 */
HANDLE __stdcall NvRmOpen
(
    VOID
)
{
}

/*
 * NvRmClose - close connection with resource manager
 */
void __stdcall NvRmClose
(
    VOID
)
{
}

/*
 * NvAlloc - allocate any arbitrary object
 */
ULONG __stdcall NvRmAlloc
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocWin9x(hClient, hParent, hObject, hClass, pAllocParms));
    else
        return(NvRmAllocWinNt(hClient, hParent, hObject, hClass, pAllocParms));
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG __stdcall NvRmAllocRoot
(
    ULONG *phClient
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocRootWin9x(phClient));
    else
        return(NvRmAllocRootWinNt(phClient));
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG __stdcall NvRmAllocDevice
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocDeviceWin9x(hClient, hDevice, hClass, szName));
    else
        return(NvRmAllocDeviceWinNt(hClient, hDevice, hClass, szName));
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG __stdcall NvRmAllocContextDma
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocContextDmaWin9x(hClient, hDma, hClass, flags, base, limit));
    else
        return(NvRmAllocContextDmaWinNt(hClient, hDma, hClass, flags, base, limit));
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG __stdcall NvRmAllocChannelPio
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocChannelPioWin9x(hClient, hDevice, hChannel, hClass, hErrorCtx, ppChannel, flags));
    else
        return(NvRmAllocChannelPioWinNt(hClient, hDevice, hChannel, hClass, hErrorCtx, ppChannel, flags));
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG __stdcall NvRmAllocChannelDma
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocChannelDmaWin9x(hClient, hDevice, hChannel, hClass, hErrorCtx, hDataCtx, offset, ppChannel));
    else
        return(NvRmAllocChannelDmaWinNt(hClient, hDevice, hChannel, hClass, hErrorCtx, hDataCtx, offset, ppChannel));
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG __stdcall NvRmAllocMemory
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocMemoryWin9x(hClient, hParent, hMemory, hClass, flags, ppAddress, pLimit));
    else
        return(NvRmAllocMemoryWinNt(hClient, hParent, hMemory, hClass, flags, ppAddress, pLimit));
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG __stdcall NvRmAllocObject
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocObjectWin9x(hClient, hChannel, hObject, hClass));
    else
        return(NvRmAllocObjectWinNt(hClient, hChannel, hObject, hClass));
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG __stdcall NvRmFree
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmFreeWin9x(hClient, hParent, hObject));
    else
        return(NvRmFreeWinNt(hClient, hParent, hObject));
}

/*
 * NV3GetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG __stdcall Nv3RmGetDmaPushInfo
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hDmaContext,
    ULONG retArray
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(Nv3RmGetDmaPushInfoWin9x(hClient, hDevice, hChannel, hDmaContext, retArray));
    else
        return(Nv3RmGetDmaPushInfoWinNt(hClient, hDevice, hChannel, hDmaContext, retArray));
}

ULONG __stdcall NvRmAllocEvent
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmAllocEventWin9x(hClient, hObjectParent, hObjectNew, hClass, index, data));
    else
        return(NvRmAllocEventWinNt(hClient, hObjectParent, hObjectNew, hClass, index, data));
}


ULONG __stdcall NvRmArchHeap
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmArchHeapWin9x(hClient, hParent, function, owner, type,
                                   height, size, pitch, offset, address, limit, free, total));
    else
        return(NvRmArchHeapWinNt(hClient, hParent, function, owner, type,
                                   height, size, pitch, offset, address, limit, free, total));
}

ULONG  __stdcall NvRmConfigVersion
(
    ULONG hClient,
    ULONG hDevice,
    ULONG *pVersion
)
{
    return NVOS12_STATUS_SUCCESS;
}

ULONG  __stdcall NvRmConfigGet
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigGetWin9x(hClient, hDevice, index, pValue));
    else
        return(NvRmConfigGetWinNt(hClient, hDevice, index, pValue));
}

ULONG  __stdcall NvRmConfigSet
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigSetWin9x(hClient, hDevice, index, newValue, pOldValue));
    else
        return(NvRmConfigSetWinNt(hClient, hDevice, index, newValue, pOldValue));
}

ULONG  __stdcall NvRmConfigUpdate
(
    ULONG hClient,
    ULONG hDevice,
    ULONG flags
)
{
    return NVOS15_STATUS_SUCCESS;
}

ULONG  __stdcall NvRmConfigGetEx
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID  *paramStructPtr,
    ULONG paramSize
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigGetExWin9x(hClient, hDevice, index, paramStructPtr, paramSize));
    else
        return(NvRmConfigGetExWinNt(hClient, hDevice, index, paramStructPtr, paramSize));
}

ULONG  __stdcall NvRmConfigSetEx
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID  *paramStructPtr,
    ULONG paramSize
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmConfigSetExWin9x(hClient, hDevice, index, paramStructPtr, paramSize));
    else
        return(NvRmConfigSetExWinNt(hClient, hDevice, index, paramStructPtr, paramSize));
}

ULONG  __stdcall NvRmInterrupt
(
    ULONG hClient,
    ULONG hDevice
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmInterruptWin9x(hClient, hDevice));
    else
        return(NvRmInterruptWinNt(hClient, hDevice));
}

ULONG  __stdcall NvRmRing0Callback
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmRing0CallbackWin9x(hClient, hDevice, procAddr, param1, param2));
    else
        return(NvRmRing0CallbackWinNt(hClient, hDevice, procAddr, param1, param2));
}

ULONG  __stdcall NvRmI2CAccess
(
    ULONG hClient,
    ULONG hDevice,
    VOID  *paramStructPtr
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return(NvRmI2CAccessWin9x(hClient, hDevice, paramStructPtr ));
    else
        return(NvRmI2CAccessWinNt(hClient, hDevice, paramStructPtr ));
}

ULONG  __stdcall NvRmDebugControl
(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    if (NV_WIN_IS_9X(GetWindowsType()))
        return NvRmDebugControlWin9x(hRoot, command, pArgs);
    else
        return NvRmDebugControlWinNt(hRoot, command, pArgs);
}

/*
 * GetWindowsType - Use Win32 to get windows type (9x or NT)
 */
static DWORD
GetWindowsType
(
    void
)
{
    OSVERSIONINFO osVer; /* for GetVersionEx() */

    /*
     * Get Windows type: 9x or NT
     */
    memset(&osVer, 0, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);
    (void)GetVersionEx(&osVer);
    return(osVer.dwPlatformId);
}

// end of nvRmApi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\winnt4\inc\NVHW.H ===
#ifndef _NVHW_H_
#define _NVHW_H_
/**************************************************************************************************************
*
*	Module:  nvhw.h
*
*	Description:
*		Hardware access macros for the resource manager.
*
*
*	Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.   
*	                                                                 
*	NOTICE TO USER:   The source code  is copyrighted under  U.S. and
*	international laws.   NVIDIA, Corp. of Sunnyvale, California owns
*	the copyright  and as design patents  pending  on the design  and
*	interface  of the NV chips.   Users and possessors of this source
*	code are hereby granted  a nonexclusive,  royalty-free  copyright
*	and  design  patent license  to use this code  in individual  and
*	commercial software.                                             
*	                                                                 
*	Any use of this source code must include,  in the user documenta-
*	tion and  internal comments to the code,  notices to the end user
*	as follows:                                                      
*	                                                                 
*	Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents
*	pending in the U.S. and foreign countries.                       
*	                                                                 
*	NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF
*	THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT
*	EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS
*	ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL
*	IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A
*	PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE
*	FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,
*	OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR
*	PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER
*	TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR
*	PERFORMANCE OF THIS SOURCE CODE.                                 
*                                                                      
*************************************************************************************************************/

/*
	The REG_WR..() and REG_RD..() macros are used to access the NV registers.
	Actual address are passed in then scaled to the correct size of access,
	so no prescaling is necessary.  Just use the register address defined
	in the reference manuals, e.g. nv.._ref.h.
*/
#define REG_WR08(a,d)   (osWriteReg008((U008*)&nvAddr->Reg008[(a)  ], (U008)(d)))
#define REG_WR16(a,d)   (osWriteReg016((U016*)&nvAddr->Reg016[(a)/2], (U016)(d)))
#define REG_WR32(a,d)   (osWriteReg032((U032*)&nvAddr->Reg032[(a)/4], (U032)(d)))
#define REG_RD08(a)     (osReadReg008 ((U008*)&nvAddr->Reg008[(a)  ])			)
#define REG_RD16(a)     (osReadReg016 ((U016*)&nvAddr->Reg016[(a)/2])			)
#define REG_RD32(a)     (osReadReg032 ((U032*)&nvAddr->Reg032[(a)/4])			)

/*
	The REG_WR..DIRECT() and REG_RD..DIRECT() macros are used to access the NV 
    registers given as system addresses.  System addresses of the registers
    are passed in.  A read is made directly from that address, without manipulation. 
*/
#define REG_WR08_DIRECT(a,d)   (osWriteReg008((a), (d)))
#define REG_WR16_DIRECT(a,d)   (osWriteReg016((a), (d)))
#define REG_WR32_DIRECT(a,d)   (osWriteReg032((a), (d)))
#define REG_RD08_DIRECT(a)     (osReadReg008 ((a)     ))
#define REG_RD16_DIRECT(a)     (osReadReg016 ((a)     ))
#define REG_RD32_DIRECT(a)     (osReadReg032 ((a)     ))

/*
	The MEM_WR..() and MEM_RD..() macros are used to access the frame buffer
	memory.  Actual addresses are passed in then scaled to the correct size of
	access, so no prescaling is necessary.  Just use the actual byte address
	of the frame buffer that needs to be accessed.  

	Note:  For NV3, these macros are used to access instance memory directly.
	So, passing in a 0 would access the first location of instance memory, 
	which is at the end of the frame buffer, i.e. at an offset of NV_PRAMIN
	from the beginning of the frame buffer.
*/

// frame buffer access macros
// for NV4 and above, fbAddr actually points to the frame buffer
#define MEM_BASE		(0)
#define MEM_WR08(a,d)   (osWriteReg008((U008*)&fbAddr->Reg008[((a)-MEM_BASE)  ], (U008)(d)))
#define MEM_WR16(a,d)   (osWriteReg016((U016*)&fbAddr->Reg016[((a)-MEM_BASE)/2], (U016)(d)))
#define MEM_WR32(a,d)   (osWriteReg032((U032*)&fbAddr->Reg032[((a)-MEM_BASE)/4], (U032)(d)))
#define MEM_RD08(a)     (osReadReg008 ((U008*)&fbAddr->Reg008[((a)-MEM_BASE)  ])		   )
#define MEM_RD16(a)     (osReadReg016 ((U016*)&fbAddr->Reg016[((a)-MEM_BASE)/2])		   )
#define MEM_RD32(a)     (osReadReg032 ((U032*)&fbAddr->Reg032[((a)-MEM_BASE)/4])		   )

#define FB_WR08(a,d)   (osWriteReg008((U008*)&fbAddr->Reg008[(a)  ], (U008)(d)))
#define FB_WR16(a,d)   (osWriteReg016((U016*)&fbAddr->Reg016[(a)/2], (U016)(d)))
#define FB_WR32(a,d)   (osWriteReg032((U032*)&fbAddr->Reg032[(a)/4], (U032)(d)))
#define FB_RD08(a)     (osReadReg008 ((U008*)&fbAddr->Reg008[(a)  ])		   )
#define FB_RD16(a)     (osReadReg016 ((U016*)&fbAddr->Reg016[(a)/2])		   )
#define FB_RD32(a)     (osReadReg032 ((U032*)&fbAddr->Reg032[(a)/4])		   )

/*
	The ROM_RD..() and BIOS_RD..() macros are used to read data from the BIOS, an image of 
	which resides in the first 64K of instance memory.
*/

// ROM access macros
#define ROM_RD08(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])    ))
#define ROM_RD16(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])	  )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+1])<<8 ))
#define ROM_RD32(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])    )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+1])<<8 )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+2])<<16)\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+3])<<24))

// BIOS access macros
#define BIOS_RD08(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])    ))
#define BIOS_RD16(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])	  )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+1])<<8 ))
#define BIOS_RD32(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])    )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+1])<<8 )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+2])<<16)\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+3])<<24))

#endif // _NVHW_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\nvAuApi.c ===
/******************************************************************************
*
*   Module: nvauapi.c
*
*   Description:
*       This module is the main entry module into the NV Architecture Audio Driver.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/
#include <nvarm.h>
#include <nv32.h>
#include <nvos.h>
// #include <nvarch.h>

#include <aos.h>
#include <AHal.h>

PHWINFO_COMMON_FIELDS	pNvHWInfo[MAX_AUDIO_INSTANCE]={NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL};

// device instance utilities
PHWINFO_COMMON_FIELDS
RmGetAudioDeviceInstance(U032 uRef)
{
    U032 uCount;
    AUDIO_REF aRef;
    
    aRef.uValue = uRef;
    
    for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
    {
        if ((pNvHWInfo[uCount]) && 
            (pNvHWInfo[uCount]->uDevType == aRef.field.type) &&
            (pNvHWInfo[uCount]->uRevisionID == aRef.field.revID))
        {
            // found a device
            return pNvHWInfo[uCount];
        }
    }

    aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: RmGetAudioDeviceInstance - instance not found\n");
    return NULL;
}


PHWINFO_COMMON_FIELDS
RmAllocAudioDeviceInstance(U032 uType, U008 uRevId)
{
    AUDIO_REF aRef;
    PHWINFO_COMMON_FIELDS pDev;
    
    aRef.field.type = uType;
    aRef.field.revID = uRevId;
    // client id-- don't care
    
    pDev = RmGetAudioDeviceInstance(aRef.uValue);
    
    if (!pDev)
    {
        U032 uCount;
        RM_STATUS rmStatus;
        
        for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
        {
            // find a free index
            if (pNvHWInfo[uCount] == NULL)
                break;
        }
        
        if (uCount == MAX_AUDIO_INSTANCE)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmAllocAudioDeviceInstance - MAX_INSTANCE exceeded\n");
            return NULL;
        }
        
        // allocate a new one
        rmStatus = aosAllocateMem(sizeof(HWINFO_COMMON_FIELDS), 
                                    ALIGN_DONT_CARE,
                                    (VOID **)&pNvHWInfo[uCount], 
                                    NULL);
        
        if (rmStatus != RM_OK)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmAllocAudioDeviceInstance - mem alloc fails\n");
            return NULL;
        }
        
        pDev = pNvHWInfo[uCount];
        
        // fill the structure up
        pDev->uDevType = uType;
        pDev->uRevisionID = uRevId;
        pDev->uInstanceCounter = 0;
    }
    
    // increment the instance counter
    pDev->uInstanceCounter++;

    return pDev;
}

VOID
RmFreeAudioDeviceInstance(PHWINFO_COMMON_FIELDS pDev)
{
    // look for the pDev in the array
    U032 uCount;
    
    // check the ref count..
    if (pDev->uInstanceCounter > 1)
    {
        pDev->uInstanceCounter--;
        return;
    }
    
    for (uCount = 0; uCount < MAX_AUDIO_INSTANCE; uCount++)
    {
        if (pNvHWInfo[uCount] == pDev)
            break;
    }
    
    if (uCount == MAX_AUDIO_INSTANCE)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: RmFreeAudioDeviceInstance - instance could not be located\n");
        return;
    }
    
    pNvHWInfo[uCount] = NULL;
    aosFreeMem(pDev);
}

RM_STATUS 
RmAllocAudioMemory(VOID *pParam)
{
    AUDIO_ALLOC_MEMORY	*pAllocParam = (AUDIO_ALLOC_MEMORY *) pParam;
    
    return aosAllocateMem(pAllocParam->uSize,
                        pAllocParam->uAlignMask,
                        (VOID **)&(pAllocParam->pLinearAddress),
                        NULL);
}

RM_STATUS 
RmFreeAudioMemory(VOID *pParam)
{
    AUDIO_FREE_MEMORY *pFreeParam = (AUDIO_FREE_MEMORY *) pParam;
    
    aosFreeMem((VOID *)pFreeParam->pLinearAddress);
    
    return RM_OK;
}

// utility stuff
NvV32 
RmArchStatus(RM_STATUS rmStatus, U032 uArchFunc)
{
    // todo
    return (NvV32) rmStatus;
}

// exported to the calls
NvV32 
NvAuAlloc(U032 hClass, VOID* pAllocParms)
{
    PHWINFO_COMMON_FIELDS   pDev;
    RM_STATUS               rmStatus = RM_ERROR;
    
    switch(hClass)
    {
    case NV01_MEMORY_AUDIO:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_MEMORY_AUDIO ... start\n");
        rmStatus = RmAllocAudioMemory(pAllocParms);
        break;
        
    case NV01_DEVICE_AUDIO:
        {
            AUDIO_INIT_DEVICE *pParam = (AUDIO_INIT_DEVICE *)pAllocParms;
            U008 uClientID = 0;
            AUDIO_REF aRef;
            MCP1_CLIENT_INFO clientInfo;
            
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_DEVICE_AUDIO ... start\n");

            if (!pParam)
            {
                aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuAlloc - bad param list\n");
                rmStatus = RM_ERR_BAD_OBJECT_BUFFER;
                break;
            }
            
            // allocate a device reference
            // note (WDM specific) - NVMM is not initialized at this point
            // but mem allocation is fine, since it does not ask for physically
            // contiguous memory
            pDev = RmAllocAudioDeviceInstance(hClass, (U008) pParam->uRevisionID);
            
            while(pDev)
            {
                // if it's the first instance then init the device etc
                if (pDev->uInstanceCounter == 1)
                {
                    rmStatus = RmInitAudioDevice((VOID *)pParam->pResList,
                                                (VOID *)pParam->pDevObj,
                                                pDev);
                    
                    if (rmStatus == RM_OK)
                    {
                        rmStatus = InitAudioHal(pParam->uRevisionID, pDev);

                        if (rmStatus == RM_OK)
                            rmStatus = AllocDevice(pDev);
                    }
                }

                break;
            };
            
            if (rmStatus != RM_OK)
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: NvAuAlloc - NV01_DEVICE_AUDIO - 1 of the calls failed\n");
                break; 
            }
            
            clientInfo.pFn = pParam->pISRFn;
            clientInfo.Mask.uValue = pParam->IntrMask.uValue;
            clientInfo.pContext = (VOID *)pParam->pServiceContext;
            
            // everything done.. now add the client
            rmStatus = DeviceAddClient(pDev, &clientInfo, &uClientID);
            
            // form a context to be returned
            aRef.field.type = hClass;
            aRef.field.revID = pParam->uRevisionID;
            aRef.field.client = uClientID;
            
            pParam->uDeviceRef = aRef.uValue;
            break;
        }
        
    case NV01_CONTEXT_DMA_AUDIO:
        {
            // get the pDev
            APU_AP_ALLOC_CONTEXT_DMA *pParams = (APU_AP_ALLOC_CONTEXT_DMA *)pAllocParms;

            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV01_CONTEXT_DMA_AUDIO ... start\n");

            pDev = RmGetAudioDeviceInstance(pParams->uDeviceRef);
            if (!pDev)
                rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
            else
                rmStatus = AllocContextDma((PHWINFO_COMMON_FIELDS)pDev, pAllocParms);
            
            break;
        }
        
        // audio object calls
    case NV1B_AUDIO_OBJECT:
        {
            APU_OBJECT *pParams = (APU_OBJECT *)pAllocParms;

            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc - NV1B_AUDIO_OBJECT ... start\n");

            pDev = RmGetAudioDeviceInstance(pParams->uDeviceRef);
            if (!pDev)
                rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
            else
                rmStatus = AllocObject((PHWINFO_COMMON_FIELDS)pDev, pAllocParms);
            
            break;
        }
        
    default:
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuAlloc - bad handle\n");
        rmStatus = RM_ERR_BAD_CLASS;
        break;
    }
    
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuAlloc ... end\n");
    return RmArchStatus(rmStatus, NV01_ALLOC_DEVICE);
}


NvV32
NvAuFree
(
	U032 hClient,
    U032 hClass,
    U032 uDeviceRef,
    VOID *pParam
)
{
    RM_STATUS rmStatus;

    // find the pDev
    PHWINFO_COMMON_FIELDS pDev = RmGetAudioDeviceInstance(uDeviceRef);

    if (!pDev)
        rmStatus = RM_ERR_BAD_OBJECT_HANDLE;
    else
    {
        switch(hClass)
        {
        case NV01_DEVICE_AUDIO:
        case NV01_DEVICE_EXTERNAL_CODEC:
            {

                // remove client
                AUDIO_REF aRef;
                aRef.uValue = uDeviceRef;

                aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE start\n");
                
                DeviceRemoveClient(pDev, (U008) aRef.field.client);
                
                // check if this is the last instance
                if (pDev->uInstanceCounter == 1)
                {
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE freeing device object...\n");
                    rmStatus = FreeDevice(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE freeing HAL...\n");
                    DestroyAudioHal(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE shutting down device...\n");
                    RmShutdownAudioDevice(pDev);
                    
                    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_DEVICE removing instance...\n");
                    RmFreeAudioDeviceInstance(pDev);
                }
            }
            break;
            
        case NV01_CONTEXT_DMA_AUDIO:
        case NV01_CONTEXT_DMA_EXTERNAL_CODEC:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ...  NV01_CONTEXT_DMA start\n");
            rmStatus = FreeContextDma(pDev, pParam);
            break;

        case NV01_EXTERNAL_CODEC_OBJECT:
        case NV1B_AUDIO_OBJECT:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... one of the audio objects..  start\n");
            rmStatus = FreeObject(pDev, pParam);
            break;
            
        case NV01_MEMORY_AUDIO:
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... NV01_MEMORY_AUDIO start\n");
            rmStatus = RmFreeAudioMemory(pParam);
            break;
            
        default:
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: NvAuFree ... Bad class handle\n");
            rmStatus = RM_ERR_BAD_OBJECT_PARENT;
            break;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: NvAuFree ... end\n");

    return RmArchStatus(rmStatus, NV01_FREE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\nvRmApiNt.c ===
/*
 * nvRmtApiNt.c
 *
 * NVidia resource manager API implementation for Windows NT.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */
#pragma warning(disable : 4101 4035)

/*
 * NvRmOpen - open connection to resource manager
 */

HANDLE NvRmOpenWinNt
(
    VOID
)
{
    HDC   hDC;
    int   ret;
    DWORD in, out;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return (HANDLE)-1;
    }

    in  = (DWORD)0;
    ret = ExtEscape(hDC,
                    NV_ESC_RM_OPEN,
                    sizeof(DWORD), (LPCSTR)&in,
                    sizeof(DWORD), (LPSTR)&out);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return (HANDLE)-1;
    }

    ReleaseDC(0, hDC);
    return (out == (DWORD)INVALID_HANDLE_VALUE) ? (HANDLE)-1 : (HANDLE) 0;
}

/*
 * NvRmClose - close connection with resource manager
 */
VOID NvRmCloseWinNt
(
    VOID
)
{
    HDC   hDC;
    int   ret;
    DWORD in, out;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return;
    }

    in  = (DWORD)0;
    ret = ExtEscape(hDC,
                    NV_ESC_RM_CLOSE,
                    sizeof(DWORD), (LPCSTR)&in,
                    sizeof(DWORD), (LPSTR)&out);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return;
    }

    ReleaseDC(0, hDC);
    return;
}

/*
 * NvRmAlloc - allocate arbitrary objects
 */
ULONG NvRmAllocWinNt
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    HDC   hDC;
    int   ret;
    NVOS21_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot                 = (NvV32)hClient;
    inParms.hObjectParent         = (NvV32)hParent;
    inParms.hObjectNew            = (NvV32)hObject;
    inParms.hClass                = (NvV32)hClass;
    inParms.pAllocParms           = (NvP64)pAllocParms;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS21_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC,
                    sizeof(NVOS21_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS21_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS21_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRootWinNt
(
    ULONG *phClient
)
{
    HDC   hDC;
    int   ret;
    NVOS01_PARAMETERS inParms, outParms;

    *phClient = 0;

    inParms.hClass = NV01_ROOT;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS01_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_ROOT,
                    sizeof(NVOS01_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS01_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS01_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *phClient = (ULONG)outParms.hObjectNew;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDeviceWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    HDC   hDC;
    int   ret;
    NVOS06_PARAMETERS inParms, outParms;

    inParms.hObjectParent   = (NvV32)hClient;
    inParms.hObjectNew      = (NvV32)hDevice;
    inParms.hClass          = (NvV32)hClass;
    inParms.szName          = (NvV32)szName;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS06_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_DEVICE,
                    sizeof(NVOS06_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS06_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS06_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDmaWinNt
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    HDC   hDC;
    int   ret;
    NVOS03_PARAMETERS inParms, outParms;

    inParms.hObjectParent   = (NvV32)hClient;
    inParms.hObjectNew      = (NvV32)hDma;
    inParms.hClass          = (NvV32)hClass;
    inParms.flags           = (NvV32)flags;
    inParms.pBase           = (NvP64)base;
    inParms.limit           = (NvU64)limit;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS03_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CONTEXT_DMA,
                    sizeof(NVOS03_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS03_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS03_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPioWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    HDC   hDC;
    int   ret;
    NVOS04_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hDevice;
    inParms.hObjectNew      = (NvV32)hChannel;
    inParms.hClass          = (NvV32)hClass;
    inParms.hObjectError    = (NvV32)hErrorCtx;
    inParms.flags           = (NvV32)flags;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS04_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CHANNEL_PIO,
                    sizeof(NVOS04_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS04_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS04_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *ppChannel = (PVOID)outParms.pChannel;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDmaWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    HDC   hDC;
    int   ret;
    NVOS07_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hDevice;
    inParms.hObjectNew      = (NvV32)hChannel;
    inParms.hClass          = (NvV32)hClass;
    inParms.hObjectError    = (NvV32)hErrorCtx;
    inParms.hObjectBuffer   = (NvV32)hDataCtx;
    inParms.offset          = (NvV32)offset;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS07_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_CHANNEL_DMA,
                    sizeof(NVOS07_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS07_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS07_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *ppChannel = (PVOID)outParms.pControl;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemoryWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    HDC   hDC;
    int   ret;
    NVOS02_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot               = (NvV32)hClient;
    inParms.hObjectParent       = (NvV32)hParent;
    inParms.hObjectNew          = (NvV32)hMemory;
    inParms.hClass              = (NvV32)hClass;
    inParms.flags               = (NvV32)flags;
    inParms.pMemory             = (NvP64)*ppAddress;
    inParms.pLimit              = (NvU64)*pLimit;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS02_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_MEMORY,
                    sizeof(NVOS02_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS02_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS02_STATUS_ERROR_OPERATING_SYSTEM);
    }

    // retrieve output parameters
    *ppAddress = (PVOID)outParms.pMemory;
    *pLimit    = (ULONG)outParms.pLimit;

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG NvRmAllocObjectWinNt
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    HDC   hDC;
    int   ret;
    NVOS05_PARAMETERS inParms, outParms;

    // set input parameters
    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hChannel;
    inParms.hObjectNew      = (NvV32)hObject;
    inParms.hClass          = (NvV32)hClass;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS05_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ALLOC_OBJECT,
                    sizeof(NVOS05_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS05_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS05_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFreeWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    HDC   hDC;
    int   ret;
    NVOS00_PARAMETERS inParms, outParms;

    inParms.hRoot           = (NvV32)hClient;
    inParms.hObjectParent   = (NvV32)hParent;
    inParms.hObjectOld      = (NvV32)hObject;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS00_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_FREE,
                    sizeof(NVOS00_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS00_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS00_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return(outParms.status);
}

/*
 * NVGetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG Nv3RmGetDmaPushInfoWinNt
(
    ULONG hClient,  // this is client NOT channel
    ULONG hDevice,  // this is device NOT flags
    ULONG hChannel, // this is channel NOT put
    ULONG hDmaContext, // this is the DMA context for the push buffer
    ULONG retArray
)
{
    HDC   hDC;
    int   ret;
    ULONG inParms[5], outParms[5];

    inParms[0] = (NvV32)hClient;
    inParms[1] = (NvV32)hDevice;
    inParms[2] = (NvV32)hChannel;
    inParms[3] = (NvV32)retArray;
    inParms[4] = (NvV32)hDmaContext;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS08_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_DMA_PUSH_INFO,
                    sizeof(inParms), (LPCSTR)&inParms,
                    sizeof(outParms), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS08_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return(outParms[4]);
}

ULONG NvRmAllocEventWinNt
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    // This is not supported yet.
    return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;
}

ULONG NvRmArchHeapWinNt
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    HDC   hDC;
    int   ret;
    NVOS11_PARAMETERS inParms, outParms;

    inParms.hRoot         = (NvV32)hClient;
    inParms.hObjectParent = (NvV32)hParent;
    inParms.function      = (NvU32)function;
    inParms.owner         = (NvU32)owner;
    inParms.type          = (NvU32)type;
    inParms.pitch         = (NvS32)((pitch) ? *pitch : 0x0);
    inParms.height        = (NvU32)height;
    inParms.size          = (NvU32)size;
    inParms.offset        = (NvU32)*offset;


    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_ARCH_HEAP,
                    sizeof(NVOS11_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS11_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES);
    }

    if (pitch)
        *pitch   = (ULONG)outParms.pitch;
    *offset  = (ULONG)outParms.offset;
    *address = (ULONG)outParms.address;
    *limit   = (ULONG)outParms.limit;
    *free    = (ULONG)outParms.free;
    *total   = (ULONG)outParms.total;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigGetWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    HDC   hDC;
    int   ret;
    NVOS13_PARAMETERS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS13_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_GET,
                    sizeof(NVOS13_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS13_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS13_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *pValue = (ULONG)outParms.value;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigSetWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    HDC   hDC;
    int   ret;
    NVOS14_PARAMETERS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.newValue        = (NvV32)newValue;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS14_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_SET,
                    sizeof(NVOS14_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS14_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS14_STATUS_ERROR_OPERATING_SYSTEM);
    }

    *pOldValue = (ULONG)outParms.oldValue;

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigGetExWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    HDC   hDC;
    int   ret;
    NVOS_CONFIG_GET_EX_PARAMS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.paramStructPtr  = (NvV32)paramStructPtr;
    inParms.paramSize       = (NvU32)paramSize;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_GET_EX,
                    sizeof(NVOS_CONFIG_GET_EX_PARAMS), (LPCSTR)&inParms,
                    sizeof(NVOS_CONFIG_GET_EX_PARAMS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmConfigSetExWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    HDC   hDC;
    int   ret;
    NVOS_CONFIG_SET_EX_PARAMS inParms, outParms;

    inParms.hClient         = (NvV32)hClient;
    inParms.hDevice         = (NvV32)hDevice;
    inParms.index           = (NvV32)index;
    inParms.paramStructPtr  = (NvV32)paramStructPtr;
    inParms.paramSize       = (NvU32)paramSize;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return(NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_CONFIG_SET_EX,
                    sizeof(NVOS_CONFIG_SET_EX_PARAMS), (LPCSTR)&inParms,
                    sizeof(NVOS_CONFIG_SET_EX_PARAMS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return(NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM);
    }

    ReleaseDC(0, hDC);
    return outParms.status;
}

ULONG NvRmInterruptWinNt
(
    ULONG hClient,
    ULONG hDevice
)
{
    return NVOS09_STATUS_SUCCESS;
}

ULONG NvRmRing0CallbackWinNt
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    return NVOS09_STATUS_SUCCESS;
}

ULONG NvRmI2CAccessWinNt
(
    ULONG hClient,
    ULONG hDevice,
    VOID *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS inParams,outParams;
    HDC   hDC;
    int   ret;

    inParams.hClient         = (NvV32)hClient;
    inParams.hDevice         = (NvV32)hDevice;
    inParams.paramStructPtr  = (NvV32)paramStructPtr;
    inParams.paramSize       = (NvV32)sizeof(NVRM_I2C_ACCESS_CONTROL);
    inParams.status          = (NvV32)0;

    hDC = GetDC(0);
    if (hDC == NULL) {
       return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_I2C_ACCESS,
                    sizeof(NVOS_I2C_ACCESS_PARAMS), (LPSTR)&inParams,
                    sizeof(NVOS_I2C_ACCESS_PARAMS), (LPSTR)&outParams);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    }
    ReleaseDC(0, hDC);

    return (ULONG)outParams.status;
    
}

ULONG NvRmDebugControlWinNt(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    NVOS20_PARAMETERS inParms, outParms;
    HDC   hDC;
    int   ret;

    inParms.hRoot = hRoot;
    inParms.command = command;
    inParms.pArgs = (NvP64) pArgs;

    hDC = GetDC(0);
    if (hDC == NULL) {
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;
    }

    ret = ExtEscape(hDC,
                    NV_ESC_RM_DEBUG_CONTROL,
                    sizeof(NVOS20_PARAMETERS), (LPCSTR)&inParms,
                    sizeof(NVOS20_PARAMETERS), (LPSTR)&outParms);

    if (ret <= 0) {
        ReleaseDC(0, hDC);
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;
    }
    ReleaseDC(0, hDC);

    return outParms.status;
}

// end of nvRmApiNt.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\rmfail.c ===
/*
 * TODO
 *    what about multiboard stuff?
 *     win2k puts RM_FAILURE in per-device registery area
 *    win9x: need printf
 */

 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1999 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * Usage:
 *
 *    Add RM_FAILURE tests and triggers as desired
 *    #include <rmfail.h> in any file w/ RM_FAILURE
 * 
 *    Compile with -DDEBUG_RM_FAILURES
 *        Otherwise all RM_FAILURE macro's will vanish
 *
 *    use rmfail.pl in tools/scripts to set RM_FAILURES registry
 *
 *       rmfail.pl set '127 128:18 129:37% 113:50% 200-300:10%'
 *
 *    Optionally set RM_FAILURES_SEED to seed the random number generator.
 *    Otherwise it will be seeded w/ the current time.
 *
 *    Any RM_FAILURE's encountered before RM_FAILURE_ENABLE() will
 *    harmlessly do nothing.
 *    At startup, RmFailuresEnable() will parse the RM_FAILURES string
 *    and produce debug output indicating tests being probed.
 *
 */

#if !defined(__GNUC__) && !defined(MACOS)
#include <ntddk.h>       /* XXX just for DbgPrint; delete this if/when switch to another printf */
#endif
#include <nvrm.h>
#include <client.h>
#include <nvos.h>
#include <nvarch.h>

#include <rmfail.h>

#ifdef DEBUG_RM_FAILURES

/* our libc routines.  Since we can't get at libc from the driver we have
 * them incorporated in this file.  These are all from CYGNUS' newlib
 */
// we can't use ctype.h from within resman...
#undef isspace
#define isspace(c) (((c) == ' ') || ((c) == '\011') || ((c) == '\012'))
#undef isdigit
#define isdigit(c) (((c) >= '0') && ((c) <= '9'))
#undef isalpha
#define isalpha(c) ((((c) >= 'a') && ((c) <= 'z')) || (((c) >= 'A') && ((c) <= 'Z')))
#undef isupper
#define isupper(c) (((c) >= 'A') && ((c) <= 'Z'))

long nv_strtol(const char *nptr, char **endptr, int base);
#define RAND_MAX 0x7fffffff
void nv_srand(unsigned int seed);
int nv_rand(void);

static void rm_failure_clear(void)
{        
    (void) memset(rm_failure, 0, sizeof(rm_failure));
    (void) memset(rm_failure_counts, 0, sizeof(rm_failure_counts));
}

static void freakout(char *s)
{
    RM_FAILURE_PRINTF(("RM_FAILURE: init failed: %s\n", s));
    rm_failure_clear();
}

#endif // DEBUG_RM_FAILURES

int RmFailureTriggered(
    int n
)
{
    int rc = 0;
#ifdef DEBUG_RM_FAILURES
    int rint;
    int percent;
    int trigger_count;

    trigger_count = ++rm_failure_counts[n];

    if (rm_failure[n] & RM_FAILURES_MASK_PERCENT)
    {
        percent = rm_failure[n] & RM_FAILURES_MASK_COUNT;
        rint = 1 + (nv_rand() % 100);
        if (rint <= percent)
            rc = 1;
    }
    else
        rc = trigger_count >= rm_failure[n];

    if (rc)
    {
        RM_FAILURE_PRINTF(("RM_FAILURE: triggering %d\n", n));

        if (rm_failure[n] & RM_FAILURES_FLAG_BREAK_ON_TRIGGER)
        {
            osDbgBreakPoint();
        }
        
        // disable the trigger after it fires?
        if (rm_failure[n] & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER)
        {
            // we aren't disabling, just set count to 0
            if ( ! (rm_failure[n] & RM_FAILURES_MASK_PERCENT))
                rm_failure_counts[n] = 0;
        }
        else
        {
            RM_FAILURE_TRIGGER_DISABLE(n);
        }
    }
#endif  // DEBUG_RM_FAILURES

    return rc;
}


void RmFailuresEnable(void)
{
/*
    parse input of environment variables or registry or config file
        or all 3! into rm_failure[]

    comma or space separated list of

       t[-T][:n[%]] 

    where 't' is test number, 'n' is integer and '%' indicates
    'n' is a percent likelihood of failure
    T is used to specify a range

    Example:

        set RM_FAILURES=127b 128:18 129:37% 113:50% 200-300:10%
        
        test 127 will fail on first pass and enter debugger (checked build)
        test 128 will fail on 18th pass
        test 129 has a 37% chance of failing on every pass
        test 113 has a 50% chance of failing
        test range 200-300 to 10% failing each
*/

#ifdef DEBUG_RM_FAILURES
#define MY_MAX_STR 1024
    char s[MY_MAX_STR], sr[32];
    char *p;
    unsigned int seed;
    int len;
    RM_STATUS rm_status;
    extern char strDevNodeRM[];
    
    // init all to disabled
    rm_failure_clear();
    
    (void) memset(s, 0, sizeof(s));
    len = sizeof(s) - 1;	// for NULL term
    rm_status = osReadRegistryString(strDevNodeRM, "RM_FAILURES", s, &len);
    if (rm_status != RM_OK)
        goto done;

    RM_FAILURE_PRINTF(("RM_FAILURE: %s\n", s));
    
    // init random #
    len = 0; // XXX GetEnvironmentVariable("RM_FAILURES_SEED", sr, sizeof(sr));
    if (len > 0)
        seed = (unsigned int) nv_strtol(sr, (void *) 0, 0);
    else
    {
        // use current time in seconds as seed
        // not exactly defensible for Numerical Methods, but...
#ifdef UNIX
        U032 sec, usec;
        osGetCurrentTime(&sec, &usec);
#else
        U032 year, month, day, hour, min, sec, msec;
        osGetCurrentTime(&year, &month, &day, &hour, &min, &sec, &msec);
        if (year > 1970) year -= 1970;
        month += year * 12;
        day += month * 30;
        hour += day * 24;
        min += hour * 60;
        sec += min * 60;
#endif
        seed = (unsigned int) sec;
    }
    nv_srand(seed);

    RM_FAILURE_PRINTF(("RM_FAILURE: rand seed is %d\n", seed));

    // parse the string
    p = s;
    while (*p)
    {
        int t1, t2, n, percent;
        char *newp;
        int flags = 0;

        newp = p;
        t1 = nv_strtol(p, &newp, 0);
        if (newp == p)   // did not advance; garbage in str. bail out
            break;
        p = newp;

        n = 1;
        percent = 0;
        if ((t1 < 0) || (t1 >= RM_FAILURES_MAX))
            freakout("invalid test number");

        // test range specified?
        t2 = t1;
        if (*p == '-')
        {
            p++;
            newp = p;
            t2 = nv_strtol(p, &newp, 0);
            if (newp == p) // advance?
                break;
            p = newp;

            if ((t2 < 0) || (t2 >= RM_FAILURES_MAX) || (t1 > t2))
            {
                freakout("invalid test range");
                goto failed;
            }
        }

        // check for break and dont disable flags
        while (*p == 'b' || *p == 'd')
        {
            if (*p == 'b')
                flags |= RM_FAILURES_FLAG_BREAK_ON_TRIGGER;
            else if (*p == 'd')
                flags |= RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER;
            p++;
        }
        
        // how quick does the failure fire?
        if (*p == ':')
        {
            p++;
            n = nv_strtol(p, &p, 0);            
            if (n > RM_FAILURES_MAX_COUNT)
            {
                freakout("invalid count");
                goto failed;
            }
            if (*p == '%')
            {
                p++;
                percent = n;
                if ((percent > 100) || (percent < 1))
                {
                    freakout("invalid percent");
                    goto failed;
                }
            }
        }
        
        // record the failure instructions in rm_failure[]
        if (t2 != t1)
        {
            int t;

            for (t = t1; t <= t2; t++)
                if (percent)
                    rm_failure[t] = RM_FAILURES_MASK_PERCENT | percent | flags;
                else
                    rm_failure[t] = n | flags;

            RM_FAILURE_PRINTF(("RM_FAILURE: set range %d-%d to %d%s%s%s\n",
                               t1, t2,
                               percent ? percent : n,
                               percent ? "%" : "",
                               flags & RM_FAILURES_FLAG_BREAK_ON_TRIGGER ?
                                 " (break)" : "",
                               flags & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER ?
                              "(dont disable)" : ""
                              ));
        }
        else
        {            
            if (percent)
                rm_failure[t1] = RM_FAILURES_MASK_PERCENT | percent | flags;
            else
                rm_failure[t1] = n | flags;

            RM_FAILURE_PRINTF(("RM_FAILURE: set %3d to %d%s%s%s\n",
                               t1,
                               percent ? percent : n,
                               percent ? "%" : "",
                               flags & RM_FAILURES_FLAG_BREAK_ON_TRIGGER ?
                                 " (break)" : "",
                               flags & RM_FAILURES_FLAG_DONT_DISABLE_ON_TRIGGER ?
                              "(dont disable)" : ""
                              ));
        }

        while (*p && (*p == ' '))
            p++;
        if (*p == ',') p++;
    }

 done:
    return;
 failed:
    return;
#endif
}

//
// Disable all RM_FAILURE triggers by zapping them
// To re-enable you must use RmFailuresEnable() which will
// re-read the registry RM_FAILURES value.
//
void RmFailuresDisable(void)
{
#ifdef DEBUG_RM_FAILURES
    RM_FAILURE_PRINTF(("RM_FAILURE: disabled\n"));
    rm_failure_clear();
#endif
}

#ifdef DEBUG_RM_FAILURES
/* Utility routines only below this point */

/*
 * Convert a string to a long integer.
 * From 
 * Ignores `locale' stuff.  Assumes that the upper and lower case
 * alphabets and digits are each contiguous.
 *
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#define LONG_MAX  2147483647L
#define LONG_MIN	(- LONG_MAX - 1L)

long nv_strtol(
    const char *nptr,
    char **endptr,
    int base
)
{
	register const char *s = nptr;
	register unsigned long acc;
	register int c;
	register unsigned long cutoff;
	register int neg = 0, any, cutlim;

	/*
	 * Skip white space and pick up leading +/- sign if any.
	 * If base is 0, allow 0x for hex and 0 for octal, else
	 * assume decimal; if base is already 16, allow 0x.
	 */
	do {
		c = *s++;
	} while (isspace(c));
	if (c == '-') {
		neg = 1;
		c = *s++;
	} else if (c == '+')
		c = *s++;
	if ((base == 0 || base == 16) &&
	    c == '0' && (*s == 'x' || *s == 'X')) {
		c = s[1];
		s += 2;
		base = 16;
	}
	if (base == 0)
		base = c == '0' ? 8 : 10;

	/*
	 * Compute the cutoff value between legal numbers and illegal
	 * numbers.  That is the largest legal value, divided by the
	 * base.  An input number that is greater than this value, if
	 * followed by a legal input character, is too big.  One that
	 * is equal to this value may be valid or not; the limit
	 * between valid and invalid numbers is then based on the last
	 * digit.  For instance, if the range for longs is
	 * [-2147483648..2147483647] and the input base is 10,
	 * cutoff will be set to 214748364 and cutlim to either
	 * 7 (neg==0) or 8 (neg==1), meaning that if we have accumulated
	 * a value > 214748364, or equal but the next digit is > 7 (or 8),
	 * the number is too big, and we will return a range error.
	 *
	 * Set any if any `digits' consumed; make it negative to indicate
	 * overflow.
	 */
	cutoff = neg ? -LONG_MIN : LONG_MAX;
	cutlim = cutoff % (unsigned long)base;
	cutoff /= (unsigned long)base;
	for (acc = 0, any = 0;; c = *s++) {
		if (isdigit(c))
			c -= '0';
		else if (isalpha(c))
			c -= isupper(c) ? 'A' - 10 : 'a' - 10;
		else
			break;
		if (c >= base)
			break;
		if (any < 0 || acc > cutoff || acc == cutoff && c > cutlim)
			any = -1;
		else {
			any = 1;
			acc *= base;
			acc += c;
		}
	}
	if (any < 0) {
		acc = neg ? LONG_MIN : LONG_MAX;
	} else if (neg)
		acc = -(long)acc;
	if (endptr != 0)
		*endptr = (char *) (any ? s - 1 : nptr);
	return (acc);
}
static unsigned int next = 1;

void nv_srand(unsigned int seed)
{
        next = seed;
}

int nv_rand(void)
{
        return ((next = next * 1103515245 + 12345) & RAND_MAX);
}


#endif  // DEBUG_RM_FAILURES
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\nvrmr0api.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvRmR0Api.c
 *
 *  Routines to interact with the resource manager VxD's API services.
 *  
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

// #define WANTVXDWRAPS 
#include <basedef.h>
#include <vmm.h>
#include <vmmreg.h>
#include <vxdldr.h>
//#include <debug.h>
//#include <vxdwraps.h>
#include <vwin32.h>

#include "nvtypes.h"
#include "nvrmr0api.h"
#include "nvrmwin.h"
#include "nvos.h"
#include "files.h"
#include "nvmisc.h"
#include "nvReg.h"

/*----------------------------------------------------------------------------*/
/*
 * pragma's to put the code and data into locked memory (XXX not sure if needed)
 */

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

/*----------------------------------------------------------------------------*/
/*
 * globals
 */

typedef DWORD (* LPDWFN)();
static LPDWFN apiEntry = NULL;
LPDWFN getApiProcR0(char*);

static char strDevNodeRM[128] = NV4_REG_GLOBAL_BASE_PATH "\\" NV4_REG_RESOURCE_MANAGER_SUBKEY;
static char strRmCoreName[] = STR_RM_CORE_NAME;

static CHAR VxdName[32];
#ifdef NV3_HW
static CHAR defaultVxd[] = VXDLDR_NV3_RESMAN_VXD_NAME;
#else
static CHAR defaultVxd[] = VXDLDR_NVX_RESMAN_VXD_NAME;
#endif

#define DEFAULT_DEVICE 0
    
/*----------------------------------------------------------------------------*/
/*
 * nvGetResManAPIEntry - get the API entry point for the resource manager VxD
 */

static PVOID nvGetResManAPIEntry()
{
    ULONG*      pdevinfo = NULL;
    ULONG       size = 32;
    ULONG       hkSW;
    ULONG       cbType;
    ULONG       pos;
    ULONG       status;
    
#ifdef NV3_HW

    //
    // For NV3, don't check registry for RM Core VxD's name. Use the default name.
    //

    // (do string manipulation directly so we don't have to link in the standard str functions)
    pos = 0;
    while ( defaultVxd[pos] ) {
      VxdName[pos] = defaultVxd[pos];
      pos++;
    }
    VxdName[pos] = '\0';

#else

    //
    // For NV4 and up, attempt to get the RM Core VxD's name from the registdry
    //
    status = VMM_RegOpenKey(HKEY_LOCAL_MACHINE, strDevNodeRM, (PVMMHKEY)&hkSW);

    if ( (status == 0) && hkSW ) {
        cbType = REG_BINARY;
        status = VMM_RegQueryValueEx(hkSW, strRmCoreName, NULL, &cbType, &(VxdName[0]), &size);
        VMM_RegCloseKey(hkSW);
    }

    // status = 1; // force use of default VxD name

    if ( status != 0 ) {
        // no registry entry so use default VxD name
        // (do string manipulation directly so we don't have to link in the standard str functions)
        pos = 0;
        while ( defaultVxd[pos] ) {
          VxdName[pos] = defaultVxd[pos];
          pos++;
        }
        VxdName[pos] = '\0';
    }

#endif

    apiEntry = getApiProcR0(VxdName);
    if ( apiEntry == NULL ) {
        // try again with default Vxd name
        apiEntry = getApiProcR0(defaultVxd);
    }

    return(apiEntry);
}

/*----------------------------------------------------------------------------*/
/*
 * callRmAPI - call Resman VxD's API entry point
 */

ULONG callRmAPI(ULONG service, ULONG function, PVOID params)
{

    CLIENT_STRUCT cs;
    CLIENT_STRUCT * pcs = &cs;
    RMUSRAPI_STRUCT rm_struct;
    
    rm_struct.function = service;
    rm_struct.device = DEFAULT_DEVICE;
    cs.CRS.Client_EAX = (ULONG) &rm_struct;
    //cs.CRS.Client_EAX = service;
    

    cs.CRS.Client_EDX = function;
    cs.CRS.Client_EBX = (ULONG)params;
    
    _asm push ebp
    _asm mov  ebp, pcs      ; point ebp to client reg struct 
    
    (*apiEntry)();
    _asm pop  ebp
    
    /* return EAX since resman seems to return most of the "good" stuff there */
    return(cs.CRS.Client_EAX);
}

/*----------------------------------------------------------------------------*/
/*
 * callRmArchAPI - call Resman VxD's API entry point and use the "architecture" 
 *         service
 */

VOID callRmArchAPI(ULONG function, PVOID params)
{

    CLIENT_STRUCT cs;
    CLIENT_STRUCT * pcs = &cs;
    RMUSRAPI_STRUCT rm_struct;
    
    rm_struct.function = NVRM_API_ARCHITECTURE_32;
    rm_struct.device = DEFAULT_DEVICE;
    cs.CRS.Client_EAX = (ULONG) &rm_struct;
    //cs.CRS.Client_EAX = NVRM_API_ARCHITECTURE_32;

    cs.CRS.Client_EDX = function;
    cs.CRS.Client_EBX = (ULONG)params;
    
    _asm push ebp
    _asm mov  ebp, pcs      ; point ebp to client reg struct 
    
    (*apiEntry)();
    _asm pop  ebp
    
    return;
}

/*----------------------------------------------------------------------------*/
/*
 * __GetFlatDataSelector - duplicate of NvGetFlatDataSelector()
 *
 */

static int __GetFlatDataSelector()
{
    DWORD   Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocRoot - allocate root of device tree
 */

ULONG __stdcall NvRmR0AllocRoot (
    ULONG *phClient)
{

    NVOS01_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hClass = NV01_ROOT;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCROOT, (PVOID)(&parms));

    *phClient = (ULONG)parms.hObjectNew;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocDevice - allocate a device
 */

ULONG __stdcall NvRmR0AllocDevice (
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName )
{

    NVOS06_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hObjectParent = hClient;
    parms.hObjectNew    = hDevice;
    parms.hClass        = hClass;
    parms.szName        = (NvV32)szName;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCDEVICE, (PVOID)(&parms));

    return(parms.status);

}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocChannelPio - allocate a PIO channel
 */

ULONG __stdcall NvRmR0AllocChannelPio (
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags )
{

    NVOS04_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.flags         = flags;
  
    callRmArchAPI(NVRM_ARCH_NV01ALLOCCHANNELPIO, (PVOID)(&parms));

    *ppChannel = (PVOID)parms.pChannel.offset;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocChannelDMA - allocate a DMA channel
 */

ULONG __stdcall NvRmR0AllocChannelDma(
    ULONG hClient, 
    ULONG hDevice, 
    ULONG hChannel, 
    ULONG hClass, 
    ULONG hErrorCtx, 
    ULONG hDataCtx, 
    ULONG offset, 
    PVOID *ppChannel)
{

    NVOS07_PARAMETERS   parms; 

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.hObjectBuffer = hDataCtx;
    parms.offset        = offset;

    callRmArchAPI(NVRM_ARCH_NV03ALLOCCHANNELDMA, (PVOID)(&parms));

    *ppChannel = (PVOID)parms.pControl.offset;

    return(parms.status);

}                                               

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocContextDma - get a context DMA
 */

ULONG __stdcall NvRmR0AllocContextDma(
    ULONG hClient, 
    ULONG hDma, 
    ULONG hClass, 
    ULONG flags, 
    PVOID base, 
    ULONG limit)
{

    NVOS03_PARAMETERS   parms;

    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */

    parms.hObjectParent  = hClient;
    parms.hObjectNew     = hDma;
    parms.hClass         = hClass;
    parms.flags          = flags;
    parms.pBase.selector = __GetFlatDataSelector();
    parms.pBase.offset   = (DWORD)base;
    parms.limit.low      = limit;
  
    callRmArchAPI(NVRM_ARCH_NV01ALLOCCONTEXTDMA, (PVOID)(&parms));

    return(parms.status);

}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocMemory - Allocate a chunk of memory using the RM
 */

ULONG __stdcall NvRmR0AllocMemory
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hMemory, 
    ULONG hClass, 
    ULONG flags, 
    PVOID *ppAddress, 
    ULONG *pLimit
)
{
    
    NVOS02_PARAMETERS parms;

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */

    parms.hRoot             = hClient;
    parms.hObjectParent     = hParent;
    parms.hObjectNew        = hMemory;
    parms.hClass            = hClass;
    parms.flags             = flags;
    parms.pMemory.selector  = __GetFlatDataSelector();
    parms.pMemory.offset    = (NvU32)(*ppAddress);
    parms.pLimit.high       = 0x00000000;
    parms.pLimit.low        = *pLimit;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCMEMORY, (PVOID)(&parms));

    *ppAddress = (PVOID)parms.pMemory.offset;
    *pLimit    = (ULONG)parms.pLimit.low;

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocObject - Allocate a "thing" allocated using RM
 */


ULONG __stdcall NvRmR0AllocObject
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    NVOS05_PARAMETERS parms;

    /*
     * fill in parameters for the context dma (see nvdsptch.c)
     */
    parms.hRoot             = hClient;
    parms.hObjectParent     = hChannel;
    parms.hObjectNew        = hObject;
    parms.hClass            = hClass;
    
    callRmArchAPI(NVRM_ARCH_NV01ALLOCOBJECT, (PVOID)(&parms));

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0Alloc - allocate arbitrary objects
 */

ULONG __stdcall NvRmR0Alloc
(
    ULONG hClient, 
    ULONG hChannel,
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    NVOS21_PARAMETERS parms;

    // set input parameters
    parms.hRoot                 = hClient;
    parms.hObjectParent         = hChannel;
    parms.hObjectNew            = hObject;
    parms.hClass                = hClass;
    parms.pAllocParms.selector  = __GetFlatDataSelector();
    parms.pAllocParms.offset    = (NvU32)pAllocParms;

    callRmArchAPI(NVRM_ARCH_NV04ALLOC, (PVOID)(&parms));

    return parms.status;
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0Free - free a "thing" allocated using RM
 */

ULONG __stdcall NvRmR0Free (
    ULONG   hClient,
    ULONG   hParent,
    ULONG   hObject)
{

    NVOS00_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters for the root
     */

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.hObjectOld    = hObject;

    callRmArchAPI(NVRM_ARCH_NV01FREE, (PVOID)(&parms));

    return(parms.status);

}

/*
 * NvRmR0Interrupt - force interrupt handling.
 */

ULONG __stdcall NvRmR0Interrupt (
    ULONG   hClient,
    ULONG   hDevice)
{

    NVOS09_PARAMETERS   parms;
    
    if ( apiEntry == NULL ) {
        nvGetResManAPIEntry();
    }

    /*
     * fill in parameters.
     */

    parms.hClient  = hClient;
    parms.hDevice  = hDevice;

    callRmArchAPI(NVRM_ARCH_NV01INTERRUPT, (PVOID)(&parms));

    return(parms.status);
}

/*----------------------------------------------------------------------------*/
/*
 * NvRmR0AllocEvent - Allocate an NV Event
 */


ULONG __stdcall NvRmR0AllocEvent
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    PVOID data
)
{
    NVOS10_PARAMETERS parms;

    parms.hRoot         = hClient;
    parms.hObjectParent = hObjectParent;
    parms.hObjectNew    = hObjectNew;
    parms.hClass        = hClass;
    parms.index         = index;
    parms.hEvent.low    = (ULONG)data;

    callRmArchAPI(NVRM_ARCH_NV01ALLOCEVENT, (PVOID)(&parms));

    return(parms.status);
}

#ifndef NV3_HW

ULONG  __stdcall NvRmR0I2CAccess
(
    ULONG hClient, 
    ULONG hDevice, 
    VOID  *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS    parms;

    parms.hClient = hClient;
    parms.hDevice = hDevice;
    parms.paramStructPtr = (ULONG)paramStructPtr;

    callRmArchAPI(NVRM_ARCH_I2C_ACCESS, (PVOID)(&parms));

    return(parms.status);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\nvRmApi9x.c ===
/*
 * nvRmApi9x.c
 *
 * NVidia resource manager API for Windows 9x.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

#include <windows.h>
#include <nvEscDef.h>
#include "nvos.h"
#include "nv32.h"
#include "nvRmInt.h"
#include "files.h"
#include "nvmisc.h"
#include "nvcm.h"
#include "nvReg.h"

/*
 * pragmas
 */

#pragma warning(disable : 4101 4035)


/*
 * Global variables local to the scope of this file.
 */
/*
 * Although Win32 applications have a flat address space, on the X86
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
int GetFlatDataSelector(void)
{
    DWORD Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*
 * NvRmOpen - open connection to resource manager
 */
HANDLE NvRmOpenWin9x
(
    VOID
)
{
}

/*
 * NvRmClose - close connection with resource manager
 */
VOID NvRmCloseWin9x
(
	HANDLE IOCTL_hDevice
)
{
}

/*
 * NvRmAlloc - allocate arbitrary objects
 */
ULONG NvRmAllocWin9x
(
    ULONG hClient, 
    ULONG hParent, 
    ULONG hObject, 
    ULONG hClass, 
    PVOID pAllocParms
)
{
    NVOS21_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot                 = (NvV32)hClient;
    parms.hObjectParent         = (NvV32)hParent;
    parms.hObjectNew            = (NvV32)hObject;
    parms.hClass                = (NvV32)hClass;
    parms.pAllocParms.selector  = GetFlatDataSelector();
    parms.pAllocParms.offset    = (NvU32)pAllocParms;

    t_arch.function    = (DWORD)NVRM_ARCH_NV04ALLOC;
    t_arch.pParameters = (DWORD)&parms;
	NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRootWin9x
(
    ULONG *phClient
)
{
    NVOS01_PARAMETERS parms;
    NvIoctlArch       t_arch;
	HANDLE            IOCTL_hDevice;

    parms.hClass = NV01_ROOT;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01ALLOCROOT;
    t_arch.pParameters  = (DWORD)&parms;

    NvIoControl(t_arch.function,(VOID *) &parms);

    *phClient = (ULONG)parms.hObjectNew;

    return (ULONG)parms.status;
}

/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDeviceWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    NVOS06_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hObjectParent = hClient;
    parms.hObjectNew    = hDevice;
    parms.hClass        = hClass;
    parms.szName        = (NvV32)szName;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01ALLOCDEVICE;
    t_arch.pParameters  = (DWORD)&parms;
    
    NvIoControl(t_arch.function,(VOID *) &parms);

    return((DWORD)parms.status);
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDmaWin9x
(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    NVOS03_PARAMETERS parms;
    NvIoctlArch t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hObjectParent  = hClient;
    parms.hObjectNew     = hDma;
    parms.hClass         = hClass;
    parms.flags          = flags;
    parms.pBase.selector = GetFlatDataSelector();
    parms.pBase.offset   = (DWORD)base;
    parms.limit.low      = limit;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCCONTEXTDMA;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPioWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    PVOID *ppChannel,
    ULONG flags
)
{
    NVOS04_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hDevice;
    parms.hObjectNew    = hChannel;
    parms.hClass        = hClass;
    parms.hObjectError  = hErrorCtx;
    parms.flags         = flags;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCCHANNELPIO;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *ppChannel = (PVOID)parms.pChannel.offset;

    return((DWORD) parms.status);
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDmaWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG hChannel,
    ULONG hClass,
    ULONG hErrorCtx,
    ULONG hDataCtx,
    ULONG offset,
    PVOID *ppChannel
)
{
    NVOS07_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = (NvV32)hClient;
    parms.hObjectParent = (NvV32)hDevice;
    parms.hObjectNew    = (NvV32)hChannel;
    parms.hClass        = (NvV32)hClass;
    parms.hObjectError  = (NvV32)hErrorCtx;
    parms.hObjectBuffer = (NvV32)hDataCtx;
    parms.offset        = (NvV32)offset;

    t_arch.function    = (DWORD)NVRM_ARCH_NV03ALLOCCHANNELDMA;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *ppChannel = (PVOID)parms.pControl.offset;

    return((DWORD)parms.status);
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemoryWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG hMemory,
    ULONG hClass,
    ULONG flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    NVOS02_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hParent;
    parms.hObjectNew        = (NvV32)hMemory;
    parms.hClass            = (NvV32)hClass;
    parms.flags             = (NvV32)flags;
    parms.pMemory.selector  = GetFlatDataSelector();
    parms.pMemory.offset    = (NvU32)*ppAddress;
    parms.pLimit.high       = 0x00000000;
    parms.pLimit.low        = (NvU32)*pLimit;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCMEMORY;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    // retrieve output parameters
    *ppAddress = (PVOID)parms.pMemory.offset;
    *pLimit    = (ULONG)parms.pLimit.low;

    return (ULONG)parms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */
ULONG NvRmAllocObjectWin9x
(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    NVOS05_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    // set input parameters
    parms.hRoot             = (NvV32)hClient;
    parms.hObjectParent     = (NvV32)hChannel;
    parms.hObjectNew        = (NvV32)hObject;
    parms.hClass            = (NvV32)hClass;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCOBJECT;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFreeWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    NVOS00_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.hObjectOld    = hObject;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01FREE;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);
}

/*
 * NVGetDmaPutInfo - These functions get the channel ID, TLB PT base and address space
 * from the resource manager.  This is a backdoor to program the DMA push registers.
 */
ULONG Nv3RmGetDmaPushInfoWin9x
(
    ULONG hClient,  // this is client NOT channel
    ULONG hDevice,  // this is device NOT flags
    ULONG hChannel, // this is channel NOT put
    ULONG hDmaContext, // this is the DMA context for the push buffer
    ULONG retArray
)
{
    ULONG       parms[5];
    NvIoctlArch t_arch;
    HANDLE            IOCTL_hDevice;

    parms[0] = (NvV32)hClient;
    parms[1] = (NvV32)hDevice;
    parms[2] = (NvV32)hChannel;
    parms[3] = (NvV32)retArray;
    parms[4] = (NvV32)hDmaContext;

    t_arch.function    = (DWORD)NVRM_ARCH_NV03DMAFLOWCONTROL;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return(parms[4]);
}

ULONG NvRmAllocEventWin9x
(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    NVOS10_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hObjectParent;
    parms.hObjectNew    = hObjectNew;
    parms.hClass        = hClass;
    parms.index         = index;
    parms.hEvent.low    = data;

    t_arch.function    = (DWORD)NVRM_ARCH_NV01ALLOCEVENT;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return((DWORD)parms.status);

}

ULONG NvRmArchHeapWin9x
(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    NVOS11_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hRoot         = hClient;
    parms.hObjectParent = hParent;
    parms.function      = function;
    parms.owner         = owner;
    parms.type          = type;
    parms.pitch         = (pitch) ? *pitch : 0x0;
    parms.height        = height;
    parms.size          = size;
    parms.offset        = *offset;
    t_arch.function    = (DWORD)NVRM_ARCH_NV01HEAP;
    t_arch.pParameters = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    if (pitch)
        *pitch   = parms.pitch;
    *offset  = parms.offset;
    *address = parms.address;
    *limit   = parms.limit;
    *total   = parms.total;
    *free    = parms.free;
    return((DWORD)parms.status);

}

ULONG NvRmConfigGetWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG *pValue
)
{
    NVOS13_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.index         = (NvV32)index;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01CONFIGGET;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *pValue = (ULONG)parms.value;

    return (ULONG)parms.status;
}

ULONG NvRmConfigSetWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    ULONG newValue,
    ULONG *pOldValue
)
{
    NVOS14_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.index         = (NvV32)index;
    parms.newValue      = (NvV32)newValue;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01CONFIGSET;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    *pOldValue = (ULONG)parms.oldValue;

    return (ULONG)parms.status;
}

ULONG NvRmConfigGetExWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_GET_EX_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.index           = (NvV32)index;
    parms.paramStructPtr  = (NvV32)paramStructPtr;
    parms.paramSize       = (NvU32)paramSize;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04CONFIGGETEX;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmConfigSetExWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    NVOS_CONFIG_SET_EX_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.index           = (NvV32)index;
    parms.paramStructPtr  = (NvV32)paramStructPtr;
    parms.paramSize       = (NvU32)paramSize;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04CONFIGSETEX;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmInterruptWin9x
(
    ULONG hClient,
    ULONG hDevice
)
{
    NVOS09_PARAMETERS parms;
    NvIoctlArch       t_arch;
    HANDLE            IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01INTERRUPT;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmRing0CallbackWin9x
(
    ULONG hClient,
    ULONG hDevice,
    ULONG procAddr,
    ULONG param1,
    ULONG param2
)
{
    NVRM_RING0CALLBACK_PARAMS parms;
    NvIoctlArch               t_arch;
    HANDLE                    IOCTL_hDevice;

    parms.hClient       = (NvV32)hClient;
    parms.hDevice       = (NvV32)hDevice;
    parms.functionPtr   = (RING0CALLBACKPROC)procAddr;
    parms.param1        = (NvU32)param1;
    parms.param2        = (NvU32)param2;

    t_arch.function     = (DWORD)NVRM_ARCH_RING0CALLBACK;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmI2CAccessWin9x
(
    ULONG hClient,
    ULONG hDevice,
    VOID *paramStructPtr
)
{
    NVOS_I2C_ACCESS_PARAMS    parms;
    NvIoctlArch               t_arch;
    HANDLE                    IOCTL_hDevice;

    parms.hClient         = (NvV32)hClient;
    parms.hDevice         = (NvV32)hDevice;
    parms.paramStructPtr  = (NvV32)paramStructPtr;

    t_arch.function     = (DWORD)NVRM_ARCH_NV04I2CACCESS;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);
    
    return (ULONG)parms.status;
}

ULONG NvRmDebugControlWin9x
(
    ULONG hRoot,
    ULONG command,
    VOID *pArgs
)
{
    NVOS20_PARAMETERS         parms;
    NvIoctlArch               t_arch;

    parms.hRoot = hRoot;
    parms.command = command;
    parms.pArgs.selector = GetFlatDataSelector();
    parms.pArgs.offset = (DWORD) pArgs;

    t_arch.function     = (DWORD)NVRM_ARCH_NV01DEBUGCONTROL;
    t_arch.pParameters  = (DWORD)&parms;
    NvIoControl(t_arch.function,(VOID *) &parms);

    return (ULONG)parms.status;
}

// end of nvRmApi9x.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\winnt4\inc\OS.H ===
#ifndef _OS_H_
#define _OS_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.H                                                              *
*       Operating system wrapper functions used to abstract the OS.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    06/22/94 - rewrote it.                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Debug macros.
//
//---------------------------------------------------------------------------

#if DBG

/*
#pragma warning(disable:4311)   // allow type cast truncation
#pragma warning(disable:4242)   // allow 
#pragma warning(disable:4244)   // allow 
#pragma warning(disable:4047)   // allow 
*/

// Debug level values
#define DEBUGLEVEL_TRACEINFO    0     // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO    1     // For informational debug setup info
#define DEBUGLEVEL_USERERRORS   2     // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS         3     // For RM debug warning info
#define DEBUGLEVEL_ERRORS           4     // For RM debug error info

VOID    osDbgBreakPoint                 (void);
VOID    osDbgPrintString                (int, char*);
VOID    osDbgPrintCR                    (int);
VOID    osDbgPrintValue                 (int, int);
VOID    osDbgPrintStringValue   (int, char*, int);
VOID    osDbgPrintStringDec             (int, char*, U032);
VOID    osDbgPrintStringPtr             (int, char*, VOID*);
VOID    osDbgPrintStringVal64   (int, char*, U064);

extern int cur_debuglevel;
#define DBG_BREAKPOINT()                        osDbgBreakPoint()
#define DBG_PRINT_STRING(d,s)                   osDbgPrintString((d),(s))
#define DBG_PRINT_VALUE(d,v)                    osDbgPrintValue((d),(v))
#define DBG_PRINT_CR(d,v)                               osDbgPrintCR((d))
#define DBG_PRINT_STRING_VALUE(d,s,v)   osDbgPrintStringValue((d),(s),(v))
#define DBG_PRINT_STRING_DEC(d,s,v)             osDbgPrintStringDec((d),(s),(v))
#define DBG_PRINT_STRING_PTR(d,s,v)             osDbgPrintStringPtr((d),(s),(v))
#define DBG_PRINT_STRING_VAL64(d,s,v)   osDbgPrintStringVal64((d),(s),(v))

static U032 DbgLoop;
#define DBG_MAX_LOOP        1000
#define DBG_INIT_LOOP       DbgLoop = 0;
#define DBG_CHECK_LOOP      if (++DbgLoop > DBG_MAX_LOOP) DBG_BREAKPOINT()
#define DBG_VAL_PTR(p)      {if (*((U032*)(p) - 1) != NV_MARKER1){           \
                                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid pointer!\n\r"); \
                                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, __FILE__); \
                                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, ": line "); \
                                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)__LINE__); \
                                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r"); \
                                DBG_BREAKPOINT();}                              \
                             else if (*(U032*)((U008*)(p) + *((U032*)(p) - 2) - 12) != NV_MARKER2){\
                                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Trashed buffer end!\n\r");\
                                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, __FILE__); \
                                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, ": line "); \
                                DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)__LINE__); \
                                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r"); \
                                DBG_BREAKPOINT();}}
#define DBG_VAL_PATCH(c,p)                                                                                                                                                                            \
    {if (((c) != INVALID_CHID) && (p)                                                                                                                                                                 \
      && (((PROPOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UROP))]      && (grTable[(c)].CurrentRop       != (PROPOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UROP))]))        \
      ||  ((PBETAOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UBETA))]    && (grTable[(c)].CurrentBeta      != (PBETAOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UBETA))]))      \
      ||  ((PSOLIDOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UCHROMA))] && (grTable[(c)].CurrentColorKey  != (PSOLIDOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UCHROMA))]))   \
      ||  ((PSOLIDOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UPLANE))]  && (grTable[(c)].CurrentPlaneMask != (PSOLIDOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UPLANE))]))    \
      ||  ((PCLIPOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UCLIP))]    && (grTable[(c)].CurrentClip      != (PCLIPOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UCLIP))]))      \
      ||  ((PPATTERNOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UPATT))] && (grTable[(c)].CurrentPattern   != (PPATTERNOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UPATT))])))) \
     {                                                                                                                                                                                                \
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid Patch State on Channel: ", (c));                                                                                                                       \
         DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Current ROP: ");                                                                                                                                                           \
         DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)grTable[(c)].CurrentRop);                                                                                                                                                    \
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Patch ROP: ", (int)(PROPOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UROP))]);                                                                                \
         DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Current BETA: ");                                                                                                                                                          \
         DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)grTable[(c)].CurrentBeta);                                                                                                                                                   \
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Patch BETA: ", (int)(PBETAOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UBETA))]);                                                                             \
         DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Current ColorKey: ");                                                                                                                                                      \
         DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)grTable[(c)].CurrentColorKey);                                                                                                                                               \
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Patch ColorKey: ", (int)(PSOLIDOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UCHROMA))]);                                                                      \
         DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Current PlaneMask: ");                                                                                                                                                     \
         DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)grTable[(c)].CurrentPlaneMask);                                                                                                                                              \
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Patch PlaneMask: ", (int)(PSOLIDOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UPLANE))]);                                                                      \
         DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Current Clip: ");                                                                                                                                                          \
         DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)grTable[(c)].CurrentClip);                                                                                                                                                   \
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Patch Clip: ", (int)(PCLIPOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UCLIP))]);                                                                             \
         DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Current Pattern: ");                                                                                                                                                       \
         DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, (int)grTable[(c)].CurrentPattern);                                                                                                                                                \
         DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Patch Pattern: ", (int)(PPATTERNOBJECT)(p)->UserObjects[GR_DEVICE_INDEX(DEVICE_BASE(NV_UPATT))]);                                                                       \
         DBG_BREAKPOINT();                                                                                                                                                                            \
     }}
#else 

// no debugging -- define out debug macros
#define DBG_BREAKPOINT()
#define DBG_PRINT_STRING(d,s)
#define DBG_PRINT_VALUE(d,v)
#define DBG_PRINT_CR(d,v)
#define DBG_PRINT_STRING_VALUE(d,s,v)
#define DBG_PRINT_STRING_DEC(d,s,v)
#define DBG_PRINT_STRING_PTR(d,s,v)
#define DBG_PRINT_STRING_VAL64(d,s,v)
#define DBG_INIT_LOOP
#define DBG_CHECK_LOOP
#define DBG_VAL_PTR(p)
#define DBG_VAL_PATCH(c,p)

static __inline VOID osDbgPrintString(int level, char* str) {}
static __inline VOID osDbgPrintStringValue(int level, char* str, int val) {}

#endif // DBG

// registry path for RM AGP lookups
#define RM_REGISTRY_AGP_BASE_PATH    strDevNodeRM

#ifndef toupper
#define toupper(c)  (((c)>='a'&&(c)<='z')?((c)-'a'+'A'):(c))
#endif

// data types necessary for accessing binary registry data
// this seems to be what we get back on REG_BINARY -- couldn't find it documented tho
typedef struct
{
    U032 Length;
    U032 type;
    U008 buffer[1];
    
} RM_REG_BINARY_RECORD;
typedef union
{
    RM_REG_BINARY_RECORD record;
    U008 buffer[256];
    
} RM_REG_BINARY_BUFFER;

/* polymorphic 64-bit macros */
#ifdef IA64
typedef NvU64 SIZE_PTR; 
#else
typedef NvU32 SIZE_PTR;
#endif // IA64

#define PHYSICAL_ADDRESS_VALUE(p) ((p).LowPart)

typedef struct _def_winnt_hw_info
{
        U016    filler1;
        U008    filler2;

        U008    oldIrql;
        BOOL    rmInitialized;          // per device init flag
        VOID*   pRmSpinLock;
        VOID*   AgpServices;            // win2k's AGP services func ptrs
        VOID*   dmaAdapter;                     // PVP_DMA_ADAPTER for 64 bit systems

} WINNTHWINFO, *PWINNTHWINFO;

#if (_WIN32_WINNT >= 0x0500)

// System memory allocation tracking (for _WIN64)

typedef struct _def_sys_mem_info
{
    NvU64   physAddr;           // aligned adaper address
    VOID*   pMdl;               // MDL for user mapping
    VOID*   sysAddr;            // original, potentially unaligned address
    NvU64   logicalAddr;        // address to be used by adapter
    NvU32   length;             // actual number of bytes allocated
    NvU32   clientClass;        // NV01_ROOT_USER or NV01_ROOT
} SYS_MEM_INFO, *PSYS_MEM_INFO;

#endif

//---------------------------------------------------------------------------
//
//  Function prototypes for OS interface.
//
//---------------------------------------------------------------------------

// macro to allow different syntax between NT and Win9x
#define OS_READ_REGISTRY_DWORD(pDev, a, b, c) osReadRegistryDword(pDev, a, b, c)

RM_STATUS       osCopyIn                                (U008 *src, U008 *target, U032 count);
RM_STATUS       osCopyOut                               (U008 *src, U008 *target, U032 count);
RM_STATUS       osAllocMem                              (VOID **, U032);
RM_STATUS       osFreeMem                               (VOID *);
RM_STATUS       osAllocPages                    (PHWINFO, VOID **, U032, U032, U032, U032, U032, VOID **);
RM_STATUS       osFreePages                             (PHWINFO, VOID **, U032, U032, VOID *, BOOL);
RM_STATUS   osAllocSystemPages      (PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS   osFreeSystemPages       (PHWINFO, VOID **, VOID *);
RM_STATUS   osAllocAGPPages         (PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS   osFreeAGPPages          (PHWINFO, VOID **, VOID *);
RM_STATUS       osAllocDmaListElement   (PDMAUSEROBJECT*);
RM_STATUS       osFreeDmaListElement    (PDMAUSEROBJECT);
RM_STATUS   osVirtualToPhysicalAddr (VOID*, VOID**);
RM_STATUS   osCalculatePteAdjust    (PHWINFO, U032, VOID*, U032*);
RM_STATUS       osGetAddressInfo                (PHWINFO, U032, U032, VOID**, U032, VOID**, U032 *);
RM_STATUS       osLockUserMem                   (PHWINFO, U032, U032, VOID*, VOID*, U032 *, U032, U032, U032 *, VOID**, VOID**);
RM_STATUS       osUnlockUserMem                 (PHWINFO, U032, VOID*, VOID*, U032, U032, U032, VOID*, U032);
RM_STATUS       osSignalSemaphore               (U032 *);
RM_STATUS       osWaitSemaphore                 (U032 *);
RM_STATUS       osGetCurrentTime                (U032 *, U032 *, U032 *, U032 *, U032 *, U032 *, U032 *);
RM_STATUS       osError                                 (POBJECT, U032, V032, RM_STATUS);
RM_STATUS       osDelay                                 (U032);
RM_STATUS       osRedrawScreen                  (VOID);
RM_STATUS       osBeginWatchCanvas              (U032);
RM_STATUS       osEndWatchCanvas                (U032);
RM_STATUS       osValidateVideoSink             (char *);
RM_STATUS       osValidateImageVideo    (char *, U032 *);
RM_STATUS       osValidateDMAObject             (char *, U032, U032 *);
char*           osStringCopy                    (char *, const char *);
U032            osStringLength                  (const char *);
unsigned char * osMemCopy                       (unsigned char *, const unsigned char *, U032);
RM_STATUS       osMapPciMemoryUser              (PHWINFO, U032, U032, VOID**);
RM_STATUS       osUnmapPciMemoryUser    (PHWINFO, VOID*);
RM_STATUS       osMapFrameBuffer                (PHWINFO, U032, U032, U032, VOID **);
RM_STATUS       osMapInstanceMemory             (PHWINFO, U032, U032, U032, VOID **);
RM_STATUS       osMapFifo                               (PHWINFO, U032, U032, VOID **);
RM_STATUS       osUnmapMemory                   (PHWINFO, U032, VOID *, U032);
RM_STATUS   osSetFifoDmaParams      (PHWINFO, U032 *, U032 *, U032 *);
S032            osStringCompare                 (const char *, const char *);
RM_STATUS       osGetCurrentProcess             (U032*);
VOID            osWriteReg008                   (volatile V008*, V008);
VOID            osWriteReg016                   (volatile V016*, V016);
VOID            osWriteReg032                   (volatile V032*, V032);
U008            osReadReg008                    (volatile V008*);
U016            osReadReg016                    (volatile V016*);
U032            osReadReg032                    (volatile V032*);
RM_STATUS       osReadRegistryDword             (PHWINFO, char *, char *, U032 *);
RM_STATUS       osWriteRegistryDword    (PHWINFO, char*, char*, U032);
RM_STATUS       osReadRegistryString    (char*, char*, char*str, U032 *);
RM_STATUS       osWriteRegistryString   (char*, char*, char* str, U032);
RM_STATUS       osReadRegistryBinary    (PHWINFO, char*, char*, U008*, U032 *);
RM_STATUS       osWriteRegistryBinary   (PHWINFO, char*, char*, U008*, U032);
RM_STATUS       osDeviceNameToDeviceClass(char*, U032*);
U032            osGetCpuFrequency               (VOID);
U032        osPciReadDword          (U032, U032);
U016        osPciReadWord           (U032, U032);
U008        osPciReadByte           (U032, U032);
VOID        osPciWriteDword         (U032, U032, U032);
VOID        osPciWriteWord          (U032, U032, U016);
VOID        osPciWriteByte          (U032, U032, U008);
U032        osPciInitHandle         (U008, U008, U008, U016*, U016*);
RM_STATUS       osUpdateAGPLimit                (PHWINFO);

RM_STATUS   osIsr                   (PHWINFO);
RM_STATUS   osMemSet                (VOID *, U032, U032);

// Win2K interrupt handling
#if (_WIN32_WINNT >= 0x0500)
VOID        RmDpcForIsr             (VOID*, VOID*);
#endif

// Win2K processor synchronization
#if (_WIN32_WINNT >= 0x0500)

RM_STATUS   osInitSpinLock          (PHWINFO);
RM_STATUS   osEnterCriticalCode     (PHWINFO);
RM_STATUS   osExitCriticalCode      (PHWINFO);

#else

// define away Win2K only macros
#define osInitSpinLock(p) RM_OK
#define osEnterCriticalCode(p)
#define osExitCriticalCode(p)

#endif

#if defined(_WIN64)

RM_STATUS   osInitDmaAdapter        (PHWINFO);

#else

#define osInitDmaAdapter(p)         RM_OK

#endif

// Define away win9x only functions
#define         osEnsureDeviceEnabled(pDev) 
#define         osExit(s)                               osDbgPrintStr("NVRM: "); osDbgPrintStr((s)); osDbgPrintStr("\n"); return RM_ERROR       
#define         osStateEx(pDev, msg)
#define         osStateDacEx(pDev, msg)
#define     osDisplayModeHook(pDev, msg)
#define     osmpCheckCallbacks(pDev, dwCallbackSelect)
#define     osPreModeSet(pDev, head)
#define     osPostModeSet(pDev, head)

extern BOOL dacMonitorConnectStatus(PHWINFO, U032);
extern BOOL dacFlatPanelConnectStatus(PHWINFO, U032);
VOID        osPostModeSetEx         (PHWINFO, U032);
VOID        osPreModeSetEx          (PHWINFO, U032);

#define     OEMEnableExtensions()
#define     OEMDisableExtensions()

VOID            osLogInstMemAlloc               (U032, U032, U032);
VOID            osUnlogInstMemAlloc             (U032, U032);

// functions needed for nvagp
/* remap IO memory to kernel space */
void *osMapKernelSpace(unsigned long start, unsigned long size, U008 cached);
void osUnmapKernelSpace(void *addr, unsigned long size);

/* remap memory to user space */
void *osMapUserSpace(void *kaddr, void **priv, unsigned int size_bytes, U008 cached);
void osUnmapUserSpace(void *uaddr, void *priv);

// like osAllocMem, but no debugging info written into pages
RM_STATUS osAllocPool(void **addr, unsigned int size_bytes);
RM_STATUS osFreePool(void *addr);

void *osAllocContigPages(unsigned long num_pages);
void osFreeContigPages(void *addr); 
U032 osGetKernPhysAddr(void *kern_virt_addr);
RM_STATUS osGetAGPPhysAddr(PHWINFO pDev, VOID *vaddr, U032 *paddr);


// these are in modehw.h which is in the miniport
VOID WriteIndexed(U032 addr, U016 datum);
U016 ReadIndexed(U032 addr, U008 reg);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WritePriv08(U032 addr, U008 datum);

VOID            osStateFbEx                             (PHWINFO);
RM_STATUS       osSetVideoMode                  (PHWINFO);
RM_STATUS       osNotifyEvent                   (PHWINFO, POBJECT, U032, U032, U032, RM_STATUS, U032);
RM_STATUS       initMapping                             (PHWINFO);
RM_STATUS       initFbEx                                (PHWINFO);
RM_STATUS       initFifoEx                              (PHWINFO);
RM_STATUS       initGrEx                                (PHWINFO);
RM_STATUS       initDacEx                               (PHWINFO);
RM_STATUS       initCodecEx                             (PHWINFO);
BOOL        RmInitAGP               (PHWINFO);
VOID        NvUpdateAGPConfig       (PHWINFO);
RM_STATUS   NvGetAGPBaseLimit       (PHWINFO, U032 *, U032 *);

#define PENDING_INTERRUPTS \
    (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)|DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))

VOID            RmEnableInterrupts              (PHWINFO);
VOID            RmDisableInterrupts             (PHWINFO);
BOOL            RmInterruptPending              (PHWINFO, BOOL*);

#if DBG
VOID osLogMemAlloc(VOID *address, U032 size);
VOID osUnlogMemAlloc(VOID *address);
#endif // DBG

//---------------------------------------------------------------------------
//
//  Required defines for OS interface.
//
//---------------------------------------------------------------------------

#define NV_MEMORY_TYPE_SYSTEM       0
#define NV_MEMORY_TYPE_AGP          1

#define NV_MEMORY_NONCONTIGUOUS     0
#define NV_MEMORY_CONTIGUOUS        1

#define NV_MEMORY_DEFAULT           0
#define NV_MEMORY_UNCACHED          1
#define NV_MEMORY_WRITECOMBINED     2
#define NV_MEMORY_WRITETHRU         3
#define NV_MEMORY_WRITEPROTECT      4
#define NV_MEMORY_WRITEBACK         5

/////////////////////////////////
#define DPC_IMPLEMENTATION 1
/////////////////////////////////


typedef struct
{
    U016  HdrSize;
    U016  InfoFlags;
    U032  DevNodeHandle;
    U008  DriverName[16];
    U016  XRes;
    U016  YRes;
    U016  DPI;
    U008  Planes;
    U008  Bpp;
    U016  RefreshRateMax;
    U016  RefreshRateMin;
    U016  LowHorz;
    U016  HighHorz;
    U016  LowVert;
    U016  HighVert;
    U032  MonitorDevNodeHandle;
    U008  HorzSyncPolarity;
    U008  VertSyncPolarity;
} DISPLAYINFO, *PDISPLAYINFO;

// DMA list element pool
#define DMALISTELEMENT_POOL_SIZE 16
typedef struct
{
        BOOL inUse;
        DMAUSEROBJECT dmaListElement;

} DMALISTELEMENT_POOL_ELEMENT, *PDMALISTELEMENT_POOL_ELEMENT;

// more globals
extern DISPLAYINFO osDisplayInfo;
extern PDMALISTELEMENT_POOL_ELEMENT dmaListElementPool;


// NT callbacks...

// notify callback action
#define NV_OS_WRITE_THEN_AWAKEN    0x00000001

// This is callback function in the miniport.
// The argument is a device extension, and must be cast as such to be useful.
typedef VOID (*MINIPORT_CALLBACK)(VOID*);


// memory allocation
#define NV_MEMORY_TAG '  VN'

// AGP macros
#define BYTES_MAPPED_PER_PAGE   ((RM_PAGE_SIZE >> 2) * RM_PAGE_SIZE)
#define MAP_WRITECOMBINE   0x2


#endif // _OS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\common\src\nv\nvRmApiUnix.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1999 NVIDIA, Corp.  All rights reserved.             *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/*
 * nvRmApiUnix.c
 *
 *   based on NT/Win9x version of nvRmApi.c
 *
 * NVidia resource manager API.
 *
 * Copyright (c) 1997, Nvidia Corporation.  All rights reserved.
 * Portions Copyright (c) 1996, 1997, Silicon Graphics Inc.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
 * This file is linked into programs that talk to the Resource Manager.
 * It does the 'trampoline' as necessary to get to into resman proper.
 */

#if !defined(XFree86LOADER)
#include <sys/mman.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <unistd.h>
#include <stdio.h>
#include <errno.h>

#include <string.h>
#include <stdlib.h>             /* malloc */
#else
# include <xf86_ansic.h>
# ifdef open
#  undef open
#  define open(a,b)   xf86open(a,b,0)
# endif
# ifndef off_t
#  define off_t       xf86size_t
# endif
#endif /* XFree86LOADER */

#include <sys/ioctl.h>
#include <nv.h>

#include <nvos.h>
#include <nvrm.h>
#include <nv32.h>

#include <nvrmint.h>
#include <nvEscDef.h>
#include <nvmisc.h>
#include <nvcm.h>

typedef struct nv_allocated_mmap_s {
    void *address;
    int   length;
    struct nv_allocated_mmap_s *next;
} nv_allocated_mmap_t;

/*
 * track the memory mappings visible by the *current application*
 * so that we can just do pointer arithmetic to get valid mappings
 * instead of having the kernel do it.
 *
 * There is one of these per open device in *this application.
 */

typedef struct
{

    ULONG  client;
    ULONG  device_id;
    int    fd;
    int    agpfd;

    ULONG  reg_phys_base;
    ULONG  reg_length;           // size in bytes

    ULONG  fb_phys_base;
    void  *fb;
    ULONG  fb_length;            // size in bytes

    nv_allocated_mmap_t *mmap_list;    // mmap'd memory to free

    char   path[128];            // pathname for device

	int    agp_enabled;          // indicates AGP is enabled one way or another
    
} nv_mapping_t;

nv_mapping_t  nv_mappings[NV_MAX_DEVICES];

nv_ioctl_card_info_t nv_cards[NV_MAX_DEVICES];


/*
 * file descriptor for the NV control device so we can talk to the
 *   driver before picking a board
 */

int ctl_fd = -1;


/*
 * Initialize the mappings and open the control device
 */
static int init_api_layer(void)
{
    nv_mapping_t *nm;
    char *path = "/dev/nvidiactl";
    int rc;
    
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
    {
        (void) memset(nm, 0, sizeof(nv_mapping_t));
        nm->fd = -1;
    }

    ctl_fd = open(path, O_RDWR);
    if (ctl_fd < 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not open control device %s, errno=%d\n",
                path,
                errno);
#endif
        return 0;
    }

    // pull in the card info from the driver
    rc = ioctl(ctl_fd, NV_IOCTL_CARD_INFO, (void *) nv_cards);
    if (rc < 0)
    {
#ifdef DEBUG
        fprintf(stderr, "NV: could not get NV card info, errno=%d\n", errno);
#endif
        return 0;
    }

    return 1;
}             

/*
 * remember a memory range so that it can be freed when we free the client
 */

static nv_allocated_mmap_t *remember_mmap_memory(
    nv_mapping_t *nm,
    void    *address,
    int      length
)
{
    nv_allocated_mmap_t *mm;

    mm = malloc(sizeof(nv_allocated_mmap_t));
    if (mm == (void *) 0)
        return (void *) 0;

    mm->address = address;
    mm->length = length;
    mm->next = nm->mmap_list;
    nm->mmap_list = mm;        
    
    return mm;
}

static void *mmap_memory(
    nv_mapping_t *nm,
    int           length,
    off_t         offset
)
{
    void *ptr;

    ptr = mmap((void *) 0, length, PROT_WRITE | PROT_READ,
               MAP_SHARED, nm->fd, offset);
    if (ptr != MAP_FAILED)
        return remember_mmap_memory(nm, ptr, length);

    return (void *) 0;
}

static void munmap_memory(
    nv_allocated_mmap_t *mm
)
{
    if (mm->address)
    {
        munmap(mm->address, mm->length);
        mm->address = 0;
        mm->length = ~0;
    }
}

static void free_all_mmap_memory(
    nv_mapping_t *nm
)
{
    nv_allocated_mmap_t *mm;
    nv_allocated_mmap_t *next;

    for (mm = nm->mmap_list; mm; )
    {
        (void) munmap_memory(mm);
        next = mm->next;
        free(mm);
        mm = next;
    }    
}
   
static nv_mapping_t *find_mapping(
    ULONG client,
    ULONG device_id
)
{
    nv_mapping_t *nm;
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
        if (nm->client == client)
            if ((device_id == 0) || (nm->device_id == device_id))
                return nm;
    return (nv_mapping_t *) 0;
}

static nv_mapping_t *find_empty_mapping(void)
{
    nv_mapping_t *nm;
    for (nm = nv_mappings; nm < &nv_mappings[NV_MAX_DEVICES]; nm++)
        if (nm->client == 0)
            return nm;
    return (nv_mapping_t *) 0;
}

static void clear_old_mapping(nv_mapping_t *nm)
{
    if (!nm) return;

    free_all_mmap_memory(nm);
    (void) memset(nm, 0, sizeof(nv_mapping_t));
}

static int fixup_fb_address(
    nv_mapping_t *nm,
    void        **ppAddress,
    ULONG         offset,
    ULONG         length
)
{
    offset -= nm->fb_phys_base;
    if ((offset + length) > nm->fb_length)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: bad offset/length into frame buffer: 0x%lx 0x%lx\n", 
                offset, length);
#endif
        return 1;
    }
    *ppAddress = nm->fb + offset;
    return 0;
}

static int fixup_reg_address(
    nv_mapping_t *nm,
    void        **ppAddress,
    ULONG         offset,
    ULONG         length
)
{
    nv_allocated_mmap_t *mm;

    if ((offset + length) > nm->reg_length)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: bad offset/length into register area: 0x%lx 0x%lx\n", 
                offset, length);
#endif
        return 1;
    }

    mm = mmap_memory(nm, length, NV_MMAP_REG_OFFSET + offset);
    if (mm == (void *) 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not map register space on %s at 0x%lx for 0x%lx bytes, errno=%d\n",
                nm->path,
                offset,
                length,
                errno);
#endif
        return 1;
    }

    *ppAddress = mm->address;

    return 0;
}
    
static int open_actual_device(
    nv_mapping_t *nm,
    char         *pathname,
    int           device_number
)
{
    /* build up the path name */
    if (pathname)
        strcpy(nm->path, pathname);
    else
    {
        strcpy(nm->path, "/dev/nvidia#");
        nm->path[strlen(nm->path) - 1] = '0' + device_number;
    }
    
    nm->fd = open(nm->path, O_RDWR);
    if (nm->fd < 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not open device %s, errno=%d\n",
                nm->path,
                errno);
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    return 0;
}

static int close_actual_device(
    nv_mapping_t *nm
)
{
    (void) close(nm->fd);
    return 0;
}

static int map_actual_device(
    nv_mapping_t *nm
)
{
    nv_allocated_mmap_t *mm;
    nv_ioctl_memory_vtop_t vtop;
    int ret;

    nm->reg_length = 16 * 1024 * 1024;

    // XXX should map size, not hardwired
    nm->fb_length = 64 * 1024 * 1024;
    mm = mmap_memory(nm, nm->fb_length, NV_MMAP_FB_OFFSET);
    if (mm == (void *) 0)
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not map frame buffer on %s, errno=%d\n",
                nm->path,
                errno);
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    nm->fb = mm->address;
    nm->reg_phys_base = 0;

    /* what is physical address of fb? */
    nm->fb_phys_base = 0;
    vtop.buffer = nm->fb;
    vtop.byte_length = 1;	/* will be rounded up to 1 page */
    vtop.physical_addresses = (unsigned int *) &nm->fb_phys_base;
    ret = ioctl(nm->fd, NV_IOCTL_MEMORY_VTOP, (void *) &vtop);
    if ((ret < 0) || (nm->fb_phys_base == 0))
    {
#ifdef DEBUG
        fprintf(stderr,
                "NV: could not get physical address of frame buffer on %s, errno=%d\n",
                nm->path,
                errno);
#endif
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
    }

    return 0;
}
    
static inline int doEscape(
    int fd,
    int cmd,
    void * parms)
{
    return (ioctl(fd, _IOWR(NV_IOCTL_MAGIC, cmd, sizeof(void *)), parms) >= 0) ? 1 : -1;
}


/*
 * NvAllocRoot - allocate root of device tree
 */
ULONG NvRmAllocRoot(
    ULONG *phClient
)
{
    int   ret;
    NVOS01_PARAMETERS Parms;
    static int firstcall = 1;

    if (firstcall)
        if ( ! init_api_layer())
            return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;
    firstcall = 0;

    *phClient = 0;

    Parms.hClass = NV01_ROOT;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_ROOT, (void *) &Parms);
    if (ret <= 0)
        return NVOS01_STATUS_ERROR_OPERATING_SYSTEM;

    *phClient = (ULONG)Parms.hObjectNew;

    return Parms.status;
}


/*
 * NvAllocDevice - allocate a device.
 */
ULONG NvRmAllocDevice(
    ULONG hClient,
    ULONG hDevice,
    ULONG hClass,
    PUCHAR szName
)
{
    int   ret;
    NVOS06_PARAMETERS Parms;
    nv_mapping_t *nm;
    char saved_file_name[128];

    strcpy(saved_file_name, "");

    if (hClass == NV03_DEVICE_XX)
    {
        nv_ioctl_card_info_t *ci;
        int bus, slot;
        char *p;
        int i;

        strcpy(saved_file_name, (char *) szName);

        // check to see if the bus:slot device name requested
        // the X server uses this to request a particular card
        // We convert it here into /dev/nvidia0 form, since the
        // the bus:slot style is not exported to /dev
        if (strchr(saved_file_name, ':'))
        {
            bus = strtol(saved_file_name, &p, 0);
            slot = strtol(p+1, (char **) 0, 0);

            for (i=0, ci = nv_cards; i<NV_MAX_DEVICES; i++, ci++)
            {
                if ((ci->flags & NV_IOCTL_CARD_INFO_FLAG_PRESENT) &&
                    (ci->bus == bus) &&
                    (ci->slot == slot))
                {
                    hClass = NV01_DEVICE_0 + i;
                    break;
                }
            }
        }
    }

    Parms.hObjectParent   = (NvV32) hClient;
    Parms.hObjectNew      = (NvV32) hDevice;
    Parms.hClass          = (NvV32) hClass;
    Parms.szName          = (NvV32) szName;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_DEVICE, (void *) &Parms);
    if (ret <= 0)
        return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;

    if (Parms.status == NVOS06_STATUS_SUCCESS)
    {
        int devnum = -1;
        char *pathname = 0;


        /*
         * save the client handle in the mapping structure
         */

        nm = find_empty_mapping();
        if (nm == 0)
            return NVOS06_STATUS_ERROR_INSUFFICIENT_RESOURCES;

        nm->client    = hClient;
        nm->device_id = hDevice;

        /*
         * figure out the device name.
         * API allows it to be specified numerically or by string based
         *  on hClass
         */

        if (hClass == NV03_DEVICE_XX)
            pathname = saved_file_name;
        else
        {
            devnum = hClass - NV01_DEVICE_0;
            if (devnum < 0 || devnum > 8)    // XXX does resman have #define for num devices?
                return NVOS06_STATUS_ERROR_OPERATING_SYSTEM;
        }

        if ((Parms.status = open_actual_device(nm, pathname, devnum)))
            goto done;

        if ((Parms.status = map_actual_device(nm)))
            goto done;
    }

 done:
    return Parms.status;
}

/*
 * NvAllocContextDma - allocate and lock down memory using the resource manager.
 */
ULONG NvRmAllocContextDma(
    ULONG hClient,
    ULONG hDma,
    ULONG hClass,
    ULONG flags,
    PVOID base,
    ULONG limit
)
{
    int   ret;
    NVOS03_PARAMETERS Parms;

    Parms.hObjectParent   = (NvV32) hClient;
    Parms.hObjectNew      = (NvV32) hDma;
    Parms.hClass          = (NvV32) hClass;
    Parms.flags           = (NvV32) flags;
    Parms.pBase.selector  = 0;
    Parms.pBase.offset    = (NvU32) base;
    Parms.limit.high      = 0;
    Parms.limit.low       = (NvU32) limit;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_CONTEXT_DMA, (void *) &Parms);
    if (ret <= 0)
        return NVOS03_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * AllocChannelPio - allocate a PIO channel by calling RM.
 */
ULONG NvRmAllocChannelPio(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  hChannel,
    ULONG  hClass,
    ULONG  hErrorCtx,
    PVOID *ppChannel,
    ULONG  flags
)
{
    int   ret;
    NVOS04_PARAMETERS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS04_STATUS_ERROR_BAD_CLASS;

    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hDevice;
    Parms.hObjectNew      = (NvV32) hChannel;
    Parms.hClass          = (NvV32) hClass;
    Parms.hObjectError    = (NvV32) hErrorCtx;
    Parms.flags           = (NvV32) flags;

    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_CHANNEL_PIO, (void *) &Parms);
    if (ret <= 0)
        return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;

    // convert the offset returned into a virtual ptr for this app
    if (0 == fixup_reg_address(nm, ppChannel, Parms.pChannel.offset, CHANNEL_LENGTH))
        return Parms.status;

    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
}

/*
 * NvAllocChannelDma - allocate a DMA push channel using RM.
 */
ULONG NvRmAllocChannelDma(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  hChannel,
    ULONG  hClass,
    ULONG  hErrorCtx,
    ULONG  hDataCtx,
    ULONG  offset,
    PVOID *ppChannel
)
{
    int   ret;
    NVOS07_PARAMETERS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS07_STATUS_ERROR_BAD_CLASS;

    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hDevice;
    Parms.hObjectNew      = (NvV32) hChannel;
    Parms.hClass          = (NvV32) hClass;
    Parms.hObjectError    = (NvV32) hErrorCtx;
    Parms.hObjectBuffer   = (NvV32) hDataCtx;
    Parms.offset          = (NvV32) offset;

    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_CHANNEL_DMA, (void *) &Parms);
    if (ret <= 0)
        return NVOS07_STATUS_ERROR_OPERATING_SYSTEM;

    // convert the offset returned into a virtual ptr for this app
    if (0 == fixup_reg_address(nm, ppChannel, Parms.pControl.offset, CHANNEL_LENGTH))
        return Parms.status;

    return NVOS04_STATUS_ERROR_OPERATING_SYSTEM;
}

/*
 * NvAllocMemory - allocate and lock down a mess 'o memory using RM.
 */
ULONG NvRmAllocMemory(
    ULONG  hClient,
    ULONG  hParent,
    ULONG  hMemory,
    ULONG  hClass,
    ULONG  flags,
    PVOID *ppAddress,
    ULONG *pLimit
)
{
    int   ret;
    int   status;
    ULONG byte_count = 0;
    nv_mapping_t *nm;
    nv_allocated_mmap_t *mm = (void *) 0;
    NVOS02_PARAMETERS Parms;

    // set input parameters
    Parms.hRoot               = (NvV32) hClient;
    Parms.hObjectParent       = (NvV32) hParent;
    Parms.hObjectNew          = (NvV32) hMemory;
    Parms.hClass              = (NvV32) hClass;
    Parms.flags               = (NvV32) flags;
    Parms.pMemory.selector    = 0;
    Parms.pMemory.offset      = (NvU32) *ppAddress;
    Parms.pLimit.high         = 0;
    Parms.pLimit.low          = (NvU32) *pLimit;

    nm = find_mapping(hClient, hParent);
    if (nm == 0)
        return NVOS02_STATUS_ERROR_BAD_CLASS;

    /*
     * On Unix, the only approved way to map memory into user
     *   space is via mmap(2).
     * So here in the glue layer, we actually allocate the memory, and
     *   sneak the pointer into resman to validate and hook into its
     *   data structures.
     */

    switch (hClass)
    {
        case NV01_MEMORY_SYSTEM:
        {
			/* if we're AGP, we'll allocate and map from kernel land..
			 * otherwise the kernel complaints about pre-existing PTEs
			 */
			off_t offset = NV_MMAP_ALLOCATION_OFFSET;

		    if (DRF_VAL(OS02, _FLAGS, _LOCATION, flags) == NVOS02_FLAGS_LOCATION_AGP) {
				offset = NV_MMAP_AGP_OFFSET;
			}

            byte_count = *pLimit + 1;

            mm = mmap_memory(nm, byte_count, offset);
            if (mm == (void *) 0)
            {
                status = NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
                goto failed;
            }

            // sneak the pointer into resman
            Parms.pMemory.offset = (ULONG) mm->address;		/* PTRSIZE! */
            break;
        }
    }
    
    ret = doEscape(nm->fd, NV_ESC_RM_ALLOC_MEMORY, (void *) &Parms);
    if (ret <= 0)
    {
        status = NVOS02_STATUS_ERROR_OPERATING_SYSTEM;
        goto failed;
    }
    *pLimit = (ULONG)Parms.pLimit.low;
        
    switch (hClass)
    {
        /*
         * Frame buffer memory
         *
         * A little different from NV01_MEMORY_SYSTEM, since we don't know where
         * in fbmem we're going to get our memory until afterwards.
         *
         * So the resman just returns an offset to us and we patch it up
         * afterwards.
         */

        case NV01_MEMORY_LOCAL_USER:
        {
            if (fixup_fb_address(nm,
                                 (void **) ppAddress,
                                 Parms.pMemory.offset,
                                 *pLimit + 1))
            {
                status = NVOS02_STATUS_ERROR_INSUFFICIENT_RESOURCES;
                goto failed;
            }
            break;
        }

        // return the pointer in our own space
        case NV01_MEMORY_SYSTEM:
			*ppAddress = mm->address;
            break;

        default:
            *ppAddress = (void *) Parms.pMemory.offset;
            break;
    }

    return Parms.status;

 failed:
    if (mm && mm->address)
        munmap_memory(mm);

    return status;
}

/* 
 * NvAlloc - allocate any arbitrary object
 */
ULONG NvRmAlloc(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject,
    ULONG hClass,
    PVOID pAllocParms
)
{
    int   ret;
    NVOS21_PARAMETERS Parms;

    // set input parameters
    Parms.hRoot                 = (NvV32)hClient;
    Parms.hObjectParent         = (NvV32)hParent;
    Parms.hObjectNew            = (NvV32)hObject;
    Parms.hClass                = (NvV32)hClass;
    Parms.pAllocParms.selector  = 0x00000000;
    Parms.pAllocParms.offset    = (NvU32)pAllocParms;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC, (void *)&Parms);

    if (ret <= 0)
        return NVOS21_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvAllocObject - allocate a object using RM.
 */

ULONG NvRmAllocObject(
    ULONG hClient,
    ULONG hChannel,
    ULONG hObject,
    ULONG hClass
)
{
    int   ret;
    NVOS05_PARAMETERS Parms;

    // set input parameters
    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hChannel;
    Parms.hObjectNew      = (NvV32) hObject;
    Parms.hClass          = (NvV32) hClass;

    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_OBJECT, (void *) &Parms);
    if (ret <= 0)
        return NVOS05_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

/*
 * NvFree - free a "thing" allocated using RM.
 */
ULONG NvRmFree(
    ULONG hClient,
    ULONG hParent,
    ULONG hObject
)
{
    int   ret;
    NVOS00_PARAMETERS Parms;

    Parms.hRoot           = (NvV32) hClient;
    Parms.hObjectParent   = (NvV32) hParent;
    Parms.hObjectOld      = (NvV32) hObject;

    ret = doEscape(ctl_fd, NV_ESC_RM_FREE, (void *) &Parms);
    if (ret <= 0)
        return NVOS00_STATUS_ERROR_OPERATING_SYSTEM;

    /*
     * if we're freeing up the entire client, then we also need to
     * free the memory and close the device allocated in the glue layer here.
     */

    if ((Parms.status == NVOS00_STATUS_SUCCESS) && (hParent == NV01_NULL_OBJECT))
    {
        nv_mapping_t *nm;
		int i;

        // for each device on this client
        for (nm = &nv_mappings[0], i = 0; i < NV_MAX_DEVICES; nm++, i++)
        {
            if (nm->client == hClient)
            {
                /* free_all_mmap_memory(nm); */
                close_actual_device(nm);
                clear_old_mapping(nm);
            }
        }
    }

    return Parms.status;
}

ULONG NvRmAllocEvent(
    ULONG hClient,
    ULONG hObjectParent,
    ULONG hObjectNew,
    ULONG hClass,
    ULONG index,
    ULONG data
)
{
    int ret;
    NVOS10_PARAMETERS Parms;

    Parms.hRoot         = hClient;
    Parms.hObjectParent = hObjectParent;
    Parms.hObjectNew    = hObjectNew;
    Parms.hClass        = hClass;
    Parms.index         = index;
    Parms.hEvent.high   = 0;
    Parms.hEvent.low    = data;

    // we don't really know which device is doing this call, so just use control fd
    ret = doEscape(ctl_fd, NV_ESC_RM_ALLOC_EVENT, (void *) &Parms);
    if (ret <= 0)
        return NVOS10_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


ULONG NvRmArchHeap(
    ULONG hClient,
    ULONG hParent,
    ULONG function,
    ULONG owner,
    ULONG type,
    ULONG height,
    ULONG size,
    ULONG *pitch,
    ULONG *offset,
    ULONG *address,
    ULONG *limit,
    ULONG *free,
    ULONG *total
)
{
    int   ret;
    NVOS11_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hRoot         = (NvV32) hClient;
    Parms.hObjectParent = (NvV32) hParent;
    Parms.function      = (NvU32) function;
    Parms.owner         = (NvU32) owner;
    Parms.type          = (NvU32) type;
    Parms.pitch         = (NvS32) (pitch ? *pitch : 0);
    Parms.height        = (NvU32) height;
    Parms.size          = (NvU32) size;
    Parms.offset        = (NvU32) *offset;

    nm = find_mapping(hClient, hParent);
    if (nm == 0)
        return NVOS11_STATUS_ERROR_INVALID_OWNER;

    ret = doEscape(nm->fd, NV_ESC_RM_ARCH_HEAP, (void *) &Parms);
    if (ret <= 0)
        return NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES;

    if (pitch)
        *pitch = (ULONG) Parms.pitch;
    *offset  = (ULONG) Parms.offset;
    *address = (ULONG) Parms.address;
    *limit   = (ULONG) Parms.limit;
    *free    = (ULONG) Parms.free;
    *total   = (ULONG) Parms.total;

    //
    // fixup address and limit on successful allocate calls
    //
    if (Parms.status == NVOS11_STATUS_SUCCESS)
    {
        switch (function)
        {
            case NVOS11_HEAP_ALLOC_DEPTH_WIDTH_HEIGHT:
            case NVOS11_HEAP_ALLOC_SIZE:
            case NVOS11_HEAP_ALLOC_TILED_PITCH_HEIGHT:
            {
                if (fixup_fb_address(nm,
                                     (void **) address,
                                     *offset + nm->fb_phys_base,
                                     size))
                    return NVOS11_STATUS_ERROR_INSUFFICIENT_RESOURCES;

                break;
            }
        }
    }

    return Parms.status;
}

ULONG NvRmConfigGet(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  index,
    ULONG *pValue
)
{
    int   ret;
    NVOS13_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = (NvV32) hClient;
    Parms.hDevice         = (NvV32) hDevice;
    Parms.index           = (NvV32) index;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS13_STATUS_ERROR_BAD_CLIENT;

    // we handle some of these in here
    switch (Parms.index)
    {
        case  NV_CFG_DEVICE_HANDLE:
            *pValue = nm->fd;
            Parms.status = NVOS13_STATUS_SUCCESS;
            break;

        default:
            ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_GET, (void *) &Parms);
            if (ret <= 0)
                return NVOS13_STATUS_ERROR_OPERATING_SYSTEM;
            *pValue = Parms.value;
    }

    return Parms.status;
}


ULONG NvRmConfigSet(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG  index,
    ULONG  newValue,
    ULONG *pOldValue
)
{
    int   ret;
    NVOS14_PARAMETERS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = (NvV32) hClient;
    Parms.hDevice         = (NvV32) hDevice;
    Parms.index           = (NvV32) index;
    Parms.newValue        = (NvV32) newValue;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS14_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_SET, (void *) &Parms);
    if (ret <= 0)
        return NVOS14_STATUS_ERROR_OPERATING_SYSTEM;

    pOldValue = (ULONG *) Parms.oldValue;

    return Parms.status;
}

ULONG NvRmConfigGetEx(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    int   ret;
    NVOS_CONFIG_GET_EX_PARAMS Parms;
    nv_mapping_t *nm;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS06_STATUS_ERROR_BAD_OBJECT_PARENT;

    Parms.hClient         = hClient;
    Parms.hDevice         = hDevice;
    Parms.index           = index;
    Parms.paramStructPtr  = (ULONG) paramStructPtr;     /* XXX paramStructPtr sb ptr */
    Parms.paramSize       = paramSize;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_GET_EX, (void *) &Parms);
    if (ret <= 0)
        return NVOS_CGE_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}


ULONG NvRmConfigSetEx(
    ULONG hClient,
    ULONG hDevice,
    ULONG index,
    VOID *paramStructPtr,
    ULONG paramSize
)
{
    int   ret;
    NVOS_CONFIG_SET_EX_PARAMS Parms;
    nv_mapping_t *nm;

    Parms.hClient         = hClient;
    Parms.hDevice         = hDevice;
    Parms.index           = index;
    Parms.paramStructPtr  = (NvV32) paramStructPtr;  /* XXX ptr/int prob */
    Parms.paramSize       = paramSize;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_CSE_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CONFIG_SET_EX, (void *) &Parms);
    if (ret <= 0)
        return NVOS_CSE_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

#if 0
ULONG NvRmClipSlam(
    ULONG    hClient,
    ULONG    hChannel,
    ULONG    clips[],        /* {x0,y0,x1,y1}, {x0,y0,x1,y1}, ... */
    ULONG    nClips,
    ULONG    inclusive
)
{
    int  ret;
    XXX_NVOS_I2C_ACCESS_PARAMS  Parms;
    nv_mapping_t *nm;

    Parms.hClient   = hClient;
    Parms.hDevice   = hDevice;
    Parms.clipList  = clipList;
    memcpy(Parms.nClips, clips, min(8, nClips) * 4 * 4);
    Parms.inclusive = inclusive;

    nm = find_mapping(hClient);
    if (nm == 0)
        return XXX_NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_CLIPLIST_SLAM, (void *) &Parms);
    if (ret <= 0)
        return XXX_NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    
    return Parms.status;
}

implementation in resman

if not nv10 or better
    return error;

if count too large return error;

wait for IDLE???
set inclusive bit as appropriate in GLOBALSTATE0
for each
   convert to screen space coords of -2048, 2047
   stuff them all

#endif

ULONG  NvRmI2CAccess(
    ULONG hClient,
    ULONG hDevice,
    VOID  *paramStructPtr
)
{
    int  ret;
    NVOS_I2C_ACCESS_PARAMS  Parms;
    nv_mapping_t *nm;

    Parms.hClient        = (NvV32) hClient;
    Parms.hDevice        = (NvV32) hDevice;
    Parms.paramStructPtr = (NvV32) paramStructPtr;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_I2C_ACCESS_STATUS_ERROR_BAD_CLIENT;

    ret = doEscape(nm->fd, NV_ESC_RM_I2C_ACCESS, (void *) &Parms);
    if (ret <= 0)
        return NVOS_I2C_ACCESS_STATUS_ERROR_OPERATING_SYSTEM;
    
    return Parms.status;
}

ULONG NvRmDebugControl(NVOS20_PARAMETERS *parms)
{
    int   ret;
    NVOS20_PARAMETERS Parms;

    ret = doEscape(ctl_fd, NV_ESC_RM_DEBUG_CONTROL, (void *) &Parms);
    if (ret <= 0)
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG  NvRmAGPInit(
    ULONG hClient,
    ULONG hDevice,
    ULONG agp_config
)
{
    int  ret = 0;
    nv_mapping_t *nm;
    NVOS_AGP_PARAMS  Parms;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_AGP_STATUS_ERROR_BAD_CLIENT;

    Parms.hDevice = (NvV32) hDevice;
    Parms.config  = (NvV32) agp_config;

    ret = doEscape(nm->fd, NV_ESC_RM_AGP_INIT, (void *) &Parms);
    if (ret <= 0)
        return NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM;

    nm->agp_enabled = 1;

    return Parms.status;
}

ULONG  NvRmAGPTeardown(
    ULONG hClient,
    ULONG hDevice
)
{
    int  ret = 0;
    nv_mapping_t *nm;
    NVOS_AGP_PARAMS  Parms;

    nm = find_mapping(hClient, hDevice);
    if (nm == 0)
        return NVOS_AGP_STATUS_ERROR_BAD_CLIENT;

    // AGP may not be enabled, which is no error
    if (!nm->agp_enabled) 
        return RM_OK;

    Parms.hDevice = (NvV32) hDevice;

    ret = doEscape(nm->fd, NV_ESC_RM_AGP_TEARDOWN, (void *) &Parms);
    if (ret <= 0)
        return NVOS_AGP_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG NvRmIoFlush(VOID)
{
    int   ret;
    NVOS20_PARAMETERS Parms;

    ret = doEscape(ctl_fd, NV_ESC_RM_IO_FLUSH, (void *) &Parms);
    if (ret <= 0)
        return NVOS20_STATUS_ERROR_OPERATING_SYSTEM;

    return Parms.status;
}

ULONG NvRmConfigVersion(
    ULONG  hClient,
    ULONG  hDevice,
    ULONG *pVersion
)
{
    return NVOS12_STATUS_SUCCESS;
}

ULONG NvRmConfigUpdate(
    ULONG hClient,
    ULONG hDevice,
    ULONG flags
)
{
    return NVOS15_STATUS_SUCCESS;
}

ULONG NvWatchApiFrontEnd(
    ULONG p0,
    ULONG p1,
    ULONG p2,
    ULONG p3,
    ULONG p4,
    ULONG p5,
    ULONG p6
)
{
    NVWATCHAPI_PARAMETERS Parms;

    Parms.p0 = p0;
    Parms.p1 = p1;
    Parms.p2 = p2;
    Parms.p3 = p3;
    Parms.p4 = p4;
    Parms.p5 = p5;
    Parms.p6 = p6;
    return doEscape(ctl_fd, NV_ESC_RM_NVWATCH, (void *) &Parms);
}


// end of nvRmApi.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\os.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1996-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.C                                                              *
*   This is the OS interface module.  All operating system transactions     *
*   pass through these routines.  No other operating system specific code   *
*   or data should exist in the source.                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    09/07/93 - wrote it.                    *
*       Jeff Westerinen (jsw)       04/97 - modified for WinNT.             *
*                                                                           *
\***************************************************************************/

#include <ntddk.h>
#include <nvrm.h>
#include <os.h>
#include <nvos.h>
#include <nvhw.h>
#include <Nvcm.h>

// OS names
char nameVideoSink[]  = "CON:";
char nameImageVideo[] = "WND";
char nameSysMem[]     = "SYSMEM:";
char nameLVidMem[]    = "LOCALVIDMEM:";
char nameSVidMem[]    = "SYSVIDMEM:";

// registry names
char strDevNodeRM[]             = "\\Registry\\Machine\\SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\System";
char strTilingOverride[]        = "TilingOverride";
char strMemoryOverride[]        = "MemoryOverride";
char strRTLOverride[]           = "RTLOverride";
char strPBUSOverride[]          = "PBUSOverride";
char strUnderscanXOverride[]    = "UnderscanX";
char strUnderscanYOverride[]    = "UnderscanY";
//char strDevNodeDisplayNumber[]  = "\\Registry\\Machine\\SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display\\DeviceX";
char strDevNodeDisplayNumber[]  = "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\nv4\\Device0";
char strNTSrvPackVersion[]      = "\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\";

// evil globals
KSEMAPHORE rmSemaphore, osSemaphore;
DISPLAYINFO osDisplayInfo;

// memory pools required so no memory is allocated during ISR
PDMALISTELEMENT_POOL_ELEMENT dmaListElementPool;

#if DBG

// memory allocation tracking data structs and globals
typedef struct _MEM_ALLOC_LOG_ENTRY
{
    U032 handle;
    VOID *address;
    U032 size;
    struct _MEM_ALLOC_LOG_ENTRY *next;
    struct _MEM_ALLOC_LOG_ENTRY *last;

} MEM_ALLOC_LOG_ENTRY;
MEM_ALLOC_LOG_ENTRY *memAllocLog = NULL;
MEM_ALLOC_LOG_ENTRY *memAllocLogTail = NULL;
U032 memAllocEntries = 0;
U032 memAllocTotal = 0;
U032 fourByteAllocs = 0;

// instance memory allocation tracking data structs and globals
typedef struct _INST_MEM_ALLOC_LOG_ENTRY
{
    U032 handle;
    U032 instance;
    U032 size;
    U032 alignment;
    struct _INST_MEM_ALLOC_LOG_ENTRY *next;
    struct _INST_MEM_ALLOC_LOG_ENTRY *last;

} INST_MEM_ALLOC_LOG_ENTRY;
INST_MEM_ALLOC_LOG_ENTRY *instMemAllocLog = NULL;
INST_MEM_ALLOC_LOG_ENTRY *instMemAllocLogTail = NULL;
U032 instMemAllocEntries = 0;
U032 instMemAllocTotal = 0;

U032 nvddHeapAllocationCount = 0;
U032 nvddHeapFreeCount = 0;

#endif // DBG    

//
// Some quick and dirty library functions.
// This is an OS function because some operating systems supply their
// own version of this function that they require you to use instead
// of the C library function.  And some OS code developers may decide to
// use the actual C library function instead of this code.  In this case,
// just replace the code within osStringCopy with a call to the C library
// function strcpy.
//
char *osStringCopy
(
    char *dst,
    const char *src
)
{
    char *dstptr = dst;

    while (*dstptr++ = *src++);
    return (dst);
}

S032 osStringCompare
(
    const char *s1,
    const char *s2
)
{
    return strcmp(s1, s2);
}

U032 osStringLength(const char * str)
{
    U032 i = 0;
    while (str[i++] != '\0');
    return i - 1;
}

unsigned char * osMemCopy(unsigned char * dst, const unsigned char * src, U032 length)
{
    U032 i;
    for (i = 0; i < length; i++)
    {
        dst[i] = src[i];
    }
    return dst;
}

//---------------------------------------------------------------------------
//
//  Operating System Memory functions.
//
//---------------------------------------------------------------------------

#ifndef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS  osCopyIn
(
    U008 *src, 
    U008 *target,
    U032 count
)
{
    osMemCopy(target, src, count);

    return(RM_OK);
}

RM_STATUS  osCopyOut
(
    U008 *src,
    U008 *target,
    U032 count
)
{
    osMemCopy(target, src, count);

    return(RM_OK);
}

RM_STATUS osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    RM_STATUS status;
    U008     *pMem;
    U032      PageCount;

    status = RM_OK;
    
#if !DBG
    *pAddress = ExAllocatePoolWithTag(NonPagedPool, Size, NV_MEMORY_TAG);
    if (*pAddress != NULL)
    {
#else
    // allocate three extra dwords to hold the size and some debug tags
    Size += 3 * sizeof(U032);

    // round to the nearest dword size to prevent alignment fault on IA64
    Size = (Size + sizeof(U032) - 1) & ~(sizeof(U032) - 1);

    *pAddress = ExAllocatePoolWithTag(NonPagedPool, Size, NV_MEMORY_TAG);
    if (*pAddress != NULL)
    {
        // memory allocation tracking
        osLogMemAlloc(*pAddress, Size);

        // load the size into the first dword, the first tag into the second dword, 
        // and the second tag into the last, then adjust the address
        **(U032**)pAddress                                = Size;
        *(*(U032**)pAddress + 1)                          = NV_MARKER1;
        *(U032*)(*(U008**)pAddress + Size - sizeof(U032)) = NV_MARKER2;
        *(U032**)pAddress += 2;
        pMem = *(U008**)pAddress;
        Size -= 3 * sizeof(U032);
        while (Size--)
            *pMem++ = 0x69;
#endif // DBG
    }
    else
    {
        status = RM_ERR_NO_FREE_MEM;
    }
    return (status);
}
RM_STATUS osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status;
    U032      Size;
    U032      PageCount;

#if DBG
    (U032*)pAddress -= 2;
    Size = *(U032*)pAddress;
    if (*((U032*)pAddress + 1) != NV_MARKER1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Invalid address to osFreeMem\n");
        DBG_BREAKPOINT();
    }
    if (*(U032*)((U008*)pAddress + Size - sizeof(U032)) != NV_MARKER2)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Memory overrun in structure to osFreeMem\n");
        DBG_BREAKPOINT();
        return (RM_ERR_MEM_NOT_FREED);
    }
    *((U032*)pAddress + 1) = 'DAED';
    *(U032*)((U008*)pAddress + Size - sizeof(U032)) = 'DEAD';
    Size -= 3 * sizeof(U032);

    // memory allocation tracking
    osUnlogMemAlloc(pAddress);

#endif // DBG    
    ExFreePool(pAddress);

    status = RM_OK;
    return (status);
}

#endif // not Win2K

#if DBG

// add a memory allocation log entry
VOID osLogMemAlloc(VOID *address, U032 size)
{
    static U032 memAllocAttempts = 0;
    static U032 memAllocId = 0;

    MEM_ALLOC_LOG_ENTRY *newElement = ExAllocatePoolWithTag(NonPagedPool, sizeof(MEM_ALLOC_LOG_ENTRY), NV_MEMORY_TAG);
    if (newElement)
    {
        // stats
        memAllocEntries++;
        memAllocTotal += size;

        // find the magic 4-byte alloc
        if (size == 0x10)
        {
            fourByteAllocs++;
        }

        // add the new element to the head of the list
        newElement->handle = memAllocId++;
        newElement->address = address;
        newElement->size = size;
        newElement->next = memAllocLog;
        newElement->last = NULL;
        memAllocLog = newElement;

        // set the tail
        if (memAllocLogTail == NULL)
        {
            memAllocLogTail = newElement;
        }

        // fixup the back link of the next element
        if (newElement->next)
        {
            newElement->next->last = newElement;
        }
    }

    // more stats
    memAllocAttempts++;
}

// remove a memory allocation log entry
VOID osUnlogMemAlloc(VOID *address)
{
    static U032 memFreeAttempts = 0;
    MEM_ALLOC_LOG_ENTRY *element;

    for (element = memAllocLog; element; element = element->next)
    {
        if (element->address == address)
        {
            // stats
            memAllocEntries--;
            memAllocTotal -= element->size;

            // unlink the element from the list
            if (element->last)
            {
                element->last->next = element->next;
            }
            else
            {
                memAllocLog = element->next;
            }
            if (element->next)
            {
                element->next->last = element->last;
            }

            // adjust the tail
            if (element == memAllocLogTail)
            {
                memAllocLogTail = element->last;
            }

            // free the element
            ExFreePool(element);
            break;
        }
    }

    // more stats
    memFreeAttempts++;
}

// add a memory allocation log entry
VOID osLogInstMemAlloc(U032 instance, U032 size, U032 alignment)
{
    static U032 instMemAllocAttempts = 0;
    static U032 instMemAllocId = 0;

    INST_MEM_ALLOC_LOG_ENTRY *newElement = ExAllocatePoolWithTag(NonPagedPool, sizeof(INST_MEM_ALLOC_LOG_ENTRY), NV_MEMORY_TAG);
    if (newElement)
    {
        // stats
        instMemAllocEntries++;
        instMemAllocTotal += size;

        // add the new element to the head of the list
        newElement->handle = instMemAllocId++;
        newElement->instance = instance;
        newElement->size = size;
        newElement->alignment = alignment;
        newElement->next = instMemAllocLog;
        newElement->last = NULL;
        instMemAllocLog = newElement;

        // set the tail
        if (instMemAllocLogTail == NULL)
        {
            instMemAllocLogTail = newElement;
        }

        // fixup the back link of the next element
        if (newElement->next)
        {
            newElement->next->last = newElement;
        }
    }

    // more stats
    instMemAllocAttempts++;
}

// remove a memory allocation log entry
VOID osUnlogInstMemAlloc(U032 instance, U032 size)
{
    static U032 instMemFreeAttempts = 0;
    INST_MEM_ALLOC_LOG_ENTRY *element;

    for (element = instMemAllocLog; element; element = element->next)
    {
        if (element->instance == instance)
        {
            // stats
            instMemAllocEntries--;
            instMemAllocTotal -= size;

            // unlink the element from the list
            if (element->last)
            {
                element->last->next = element->next;
            }
            else
            {
                instMemAllocLog = element->next;
            }
            if (element->next)
            {
                element->next->last = element->last;
            }

            // adjust the tail
            if (element == instMemAllocLogTail)
            {
                instMemAllocLogTail = element->last;
            }

            // free the element
            ExFreePool(element);
            break;
        }
    }

    // more stats
    instMemFreeAttempts++;
}

#endif // DBG    

//
// osAllocPages - Allocate a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  PageCount  - number of pages to allocate
//  MemoryType - memory pool
//  Contiguous - contiguous pages?
//  Cache      - cacheing request
//
RM_STATUS osAllocPages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    PageCount,
    U032    MemoryType,
    U032    Contiguous,
    U032    Cache,
    U032    ClientClass,
    VOID    **pMemData
)
{
    *pMemData = NULL;

    switch (MemoryType)
    {
        case NV_MEMORY_TYPE_AGP:
            return(osAllocAGPPages(pDev, pAddress, PageCount, ClientClass, pMemData));
            break;
#if defined(_WIN64)
        case NV_MEMORY_TYPE_SYSTEM:
            return(osAllocSystemPages(pDev, pAddress, PageCount, ClientClass, pMemData));
            break;
#endif
        default:
            return RM_ERROR;
    }
}

//
// osFreePages - Free a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  MemoryType - memory pool
//
RM_STATUS osFreePages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    MemoryType,
    U032    PageCount,
    VOID    *pMemData,
    BOOL    IsWriteCombined          // all NT4 AGP allocs are write combined
)
{
    switch (MemoryType)
    {
        case NV_MEMORY_TYPE_AGP:
            return(osFreeAGPPages(pDev, pAddress, pMemData));
            break;
#if defined(_WIN64)
        case NV_MEMORY_TYPE_SYSTEM:
            return(osFreeSystemPages(pDev, pAddress, pMemData));
            break;
#endif
        default:
            return RM_ERROR;
    }
}

RM_STATUS osAllocDmaListElement
(
    PDMAUSEROBJECT *ppDmaListElement
)
{
    U032 i;

    // get the next available DMA list elementt
    for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
    {
        if (!dmaListElementPool[i].inUse)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Allocating DMA list element", i);
            dmaListElementPool[i].inUse = TRUE;
            *ppDmaListElement = &dmaListElementPool[i].dmaListElement;
            return RM_OK;
        }
    }

    return RM_ERROR;

} // end of osAllocDmaListElement()

RM_STATUS osFreeDmaListElement
(
    PDMAUSEROBJECT pDmaListElement
)
{
    U032 i;

    // return the DMA list element to the pool
    for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
    {
        if (pDmaListElement == &dmaListElementPool[i].dmaListElement)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing DMA list element", i);
            dmaListElementPool[i].inUse = FALSE;
            return RM_OK;
        }
    }

    return RM_ERROR;

} // end of osFreeDmaListElement()

// video port service implementation
#ifndef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS osLockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    U032             Selector,
    VOID*            Offset,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE *DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    U032            *PageArray,
    VOID**           pLinAddr,
    VOID**           LockHandle
)
{
    NTSTATUS ntStatus;
    PMDL pMdl = 0;
    ULONG i;

    //
    // If we're asking to lock video memory, let's just build up the PTE's and assume
    // that the caller has real control over video memory (such as DirectDraw or the
    // display driver).
    //
    if (*DmaAddressSpace == ADDR_FBMEM)
    {
        //
        // For FB, the offset into the framebuffer has already been calculated by
        // osGetAddressInfo; don't assume 0, but use Offset as the first physaddr.
        //
        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (U032)((NV_UINTPTR_T)Offset + (i * RM_PAGE_SIZE)) | 3;
        }
    }
    else if (*DmaAddressSpace == ADDR_AGPMEM)
    {
        // For AGP, load in the aperture address (we'll only need 1 pte loaded),
        // but since we've allocated PageCount worth, I guess we'll load it all

        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (U032)((NV_UINTPTR_T)DmaAddress + (i * RM_PAGE_SIZE)) | 3;
        }
    }
    else
    {
        PHYSICAL_ADDRESS pagePhysicalAddr;
        U008* pageVirtualAddr;

        // lock the pages using an MDL created from the DMA buffer specs
        pMdl = MmCreateMdl(
            NULL,
            DmaAddress,
            DmaLength
        );
        if (pMdl == NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Cannot allocate MDL\n");
            return RM_ERR_NO_FREE_MEM;
        }
        try
        {
            // the only way to know if locking fails is via an exception
            MmProbeAndLockPages(
                pMdl,
                IoModifyAccess
            );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ntStatus = GetExceptionCode();
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: MmProbeAndLockPages FAILED!\n");
            ExFreePool(pMdl);
            return RM_ERR_PAGE_TABLE_NOT_AVAIL;
        }

        // save the MDL pointer
        *LockHandle = pMdl;

        // map the buffer
#if (_WIN32_WINNT < 0x0500)
        *pLinAddr = MmGetSystemAddressForMdl(pMdl);
#else
        *pLinAddr = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
#endif // (_WIN32_WINNT < 0x0500)
        if (*pLinAddr == NULL)
        {
            MmUnlockPages(pMdl);
            ExFreePool(pMdl);
            return RM_ERROR;
        }



        // load the PTE array with physical addresses of the page-aligned buffer
        pageVirtualAddr = (U008*)((NV_UINTPTR_T)DmaAddress & ~RM_PAGE_MASK);
        for (i = 0; i < PageCount; i++)
        {
            pagePhysicalAddr.QuadPart = MmGetPhysicalAddress(pageVirtualAddr);
            if (pagePhysicalAddr.LowPart == 0)
            {
                MmUnmapLockedPages(*pLinAddr, pMdl);
                MmUnlockPages(pMdl);
                ExFreePool(pMdl);
                return RM_ERR_NO_FREE_MEM;
            }
            PageArray[i] = pagePhysicalAddr.LowPart | 3;
            pageVirtualAddr += RM_PAGE_SIZE;
        }
    }

    return (RM_OK);
}
RM_STATUS osUnlockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    VOID*            LinAddr,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    VOID*            LockHandle,
    U032             DirtyFlag
)
{
    RM_STATUS status = RM_OK;
    PMDL pMdl = (PMDL)LockHandle;

    //
    // If we're asking to unlock video memory, we're assuming the caller (probably
    // direct draw)  has complete control of video memory, and therefore knows what
    // is locked/unlocked.  No need to do anything.
    //
    if ((DmaAddressSpace != ADDR_FBMEM) && (DmaAddressSpace != ADDR_AGPMEM))
    {
        // otherwise, unmap locked pages, unlock pages, and free the MDL
        MmUnmapLockedPages((VOID*)LinAddr, pMdl);
        MmUnlockPages(pMdl);
        ExFreePool(pMdl);
    }
    return (status);
}

//#endif // (_WIN32_WINNT < 0x0500)
#endif // VIDEO_PORT_IMPLEMENTATION

RM_STATUS osMapFifo
(
    PHWINFO pDev,
    U032 clientClass,
    U032 ChannelID,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = (VOID*)((U008*)nvAddr + FIFO_USER_BASE(pDev) + (ChannelID << 16));
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                pDev->Mapping.PhysAddr + FIFO_USER_BASE(pDev) + (ChannelID << 16),
                CHANNEL_LENGTH,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osMapInstanceMemory
(
    PHWINFO pDev,
    U032 clientClass,
    U032 instanceOffset,
    U032 length,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = INSTANCE_MEMORY_LOGICAL_BASE(pDev) + instanceOffset;
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                INSTANCE_MEMORY_PHYSICAL_BASE(pDev) + instanceOffset,
                length,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osMapFrameBuffer
(
    PHWINFO pDev,
    U032 clientClass,
    U032 fbOffset,
    U032 length,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = (U008*)fbAddr + fbOffset;
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                pDev->Mapping.PhysFbAddr + fbOffset,
                length,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

// This procedure undoes the work of osMapFifo, osMapFrameBuffer and osMapInstanceMemory
RM_STATUS osUnmapMemory
(
    PHWINFO pDev,
    U032    clientClass,
    VOID*   address,
    U032    length
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            break;

        case NV01_ROOT_USER:
            rmStatus = osUnmapPciMemoryUser(pDev, address);
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osSetFifoDmaParams
(
    PHWINFO pDev,
    U032   *pFetchTrigger,
    U032   *pFetchSize,
    U032   *pFetchRequests
)
{

    //
    // Default NT DMA channel fetch parameters
    // (optimized for NT display driver).
    //
    *pFetchTrigger = 128;           // 128 bytes
    *pFetchSize = 128;              // 128 bytes
    *pFetchRequests = 8;            // 8 outstanding read requests

    return RM_OK;
}

RM_STATUS osDeviceNameToDeviceClass(char *osName, U032 *pDevClass)
{


    // TO DO: add a validate pointer OS service
    // validate OS name parameter
    try
    {
        U008 testData = *(U008*)osName;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NTSTATUS ntStatus = GetExceptionCode();
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: invalid OS name\n");
        return RM_ERROR;
    }

    switch (*pDevClass)
    {
        // explicit device classes need no processing
        case NV01_DEVICE_0:
        case NV01_DEVICE_1:
        case NV01_DEVICE_2:
        case NV01_DEVICE_3:
        case NV01_DEVICE_4:
        case NV01_DEVICE_5:
        case NV01_DEVICE_6:
        case NV01_DEVICE_7:
            break;

        // derive the device class from the OS name, for NT, the device reference
        case NV03_DEVICE_XX:
            switch (*(U032*)osName)
            {
                case 0:
                    *pDevClass = NV01_DEVICE_0;
                    break;

                case 1:
                    *pDevClass = NV01_DEVICE_1;
                    break;

                case 2:
                    *pDevClass = NV01_DEVICE_2;
                    break;

                case 3:
                    *pDevClass = NV01_DEVICE_3;
                    break;

                case 4:
                    *pDevClass = NV01_DEVICE_4;
                    break;

                case 5:
                    *pDevClass = NV01_DEVICE_5;
                    break;

                case 6:
                    *pDevClass = NV01_DEVICE_6;
                    break;

                case 7:
                    *pDevClass = NV01_DEVICE_7;
                    break;

                // invalid escape value
                default:
                    return RM_ERROR;
            }
            break;

        // invalid class
        default:
            return RM_ERROR;

    }

    return RM_OK;

}

//---------------------------------------------------------------------------
//
//  OS specific time of day.
//
//---------------------------------------------------------------------------

/*****************************************************************************
*
*   Name: osGetCurrentTime
*
*   Description:
*       This functions returns the number of nano seconds that have ellapsed
*   since January 1 at midnight, GMT, of the given base year.  The base year
*   is passed in year, and the elapsed time is returned in nSecElapsed.  The
*   rest of the parameters are filled with the current date and time.
*
*****************************************************************************/

RM_STATUS osGetCurrentTime
(
    U032 *year,
    U032 *month,
    U032 *day,
    U032 *hour,
    U032 *min,
    U032 *sec,
    U032 *msec
)
{
    TIME_FIELDS currentTime;
    LARGE_INTEGER timeIn100ns;

    // get the current elapsed time
    KeQuerySystemTime(&timeIn100ns);

    // set the current time fields
    RtlTimeToTimeFields(&timeIn100ns, &currentTime);
    *year   = currentTime.Year;
    *month  = currentTime.Month;
    *day    = currentTime.Day;
    *hour   = currentTime.Hour;
    *min    = currentTime.Minute;
    *sec    = currentTime.Second;
    *msec   = currentTime.Milliseconds;

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Misc services.
//
//---------------------------------------------------------------------------


// Pre and Post modeset stuff, from the 9x stuff
// Os Specifix pre mode set actions.
VOID osPreModeSetEx(PHWINFO pDev, U032 Head)
{

    // Nothing to do here any more...all TV stuff is in the main
    // modeset path in dac/dacmode.c:dacSetModeMulti().

} // end of osPreModeSetEx()

// Os Specific post mode set actions.
VOID osPostModeSetEx(PHWINFO pDev, U032 Head)
{
    RM_STATUS status;
    U032      data32;

    // See if there are any registry overrides for the desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) {
        U032 cbLen;
        NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS position;

        cbLen = 4 * sizeof(U032);
        status = dacReadDesktopPositionFromRegistry(pDev, Head,
                                                    TRUE,  // isMonitor
                                                    (U008 *) &(position.HRetraceStart),
                                                    &cbLen);
        if (status == RM_OK) {
            // Program the new values.
            dacSetMonitorPosition(pDev, Head,
                                  position.HRetraceStart, position.HRetraceEnd,
                                  position.VRetraceStart, position.VRetraceEnd);
        }
    }

    // See if there are any registry overrides for the monitor timing.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR)
    {
        NV_CFGEX_CRTC_TIMING_PARAMS timings;

        //
        // First check if there are timings available in the registry for this mode
        //
        timings.Head = Head;
        timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTRY;
        status = dacGetCRTCTiming(pDev, Head, &timings);

        if (status == RM_OK)
        {
            //
            // Program the new values
            //
            timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
            status = dacSetCRTCTiming(pDev, Head, &timings);
        }

    }

    // See if there are any registry overrides for the TV desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV) {

       U032 cbLen;
       NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS Params;
 
       // Read the registry to get any updates to the default setting.
       // This should be done after dacAdjustCRTCForTV because it involves changes to CRTC.
       cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
       status = dacReadTVDesktopPositionFromRegistry(pDev, Head, (U008 *) &Params, &cbLen);
   
       // Make sure data is valid for the current encoder.
       if((status == RM_OK) && (Params.Encoder_ID == pDev->Dac.EncoderType)) {
           // Write the saved settings
           dacSetTVPosition(pDev, Head, (U032 *) &Params);
       }
    }
    
    //
    // Determine if it's possible to support a video overlay in this resolution
    //
    nvHalDacValidateArbSettings(pDev,
                                pDev->Dac.HalInfo.Depth,
                                1, 0,
                                (pDev->Dac.HalInfo.PixelClock * 10000),
                                &(pDev->Video.OverlayAllowed));

    // Check/Set any PFB overrides
    if (osReadRegistryDword(pDev, strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }
    if (osReadRegistryDword(pDev, strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_RTL, data32);
    }
    
} // end of osPostModeSetEx()




#if 0
//
// First pass at implementing registry string read.
// Converts the UNICODE string from registry into a POS (plain old string)
// of max length '*cbLen' and returns it in buffer pointed to by '*Data'
//
// Currently just used by RM_FAILURE mechanism in rmfailure.c
//
// Note:
//    has a lot in common w/ osReadRegistryDword
//       could be commoned once it works :-)
//    missing pDev arg of osReadRegistryDword()
//    can not be called from RmInitRm(); it is apparently too early
//        if you do, will just return STATUS_NOT_FOUND
//
RM_STATUS osReadRegistryString
(
    char *regDevNode,
    char *regParmStr,
    char *Data,
    U032 *cbLen
)
{
    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    UNICODE_STRING dest_unicode_string;
    ANSI_STRING dest_ansi_string;

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].DefaultType = REG_SZ;

    dest_unicode_string.Length = 0;
    dest_unicode_string.MaximumLength = (short) *cbLen;
    dest_unicode_string.Buffer = ExAllocatePoolWithTag(
                                        PagedPool,
                                        dest_unicode_string.MaximumLength, 
                                        NV_MEMORY_TAG
                                        );
    
    if (!dest_unicode_string.Buffer) 
    {
        return RM_ERROR;
    }

    query[0].DefaultData = dest_unicode_string.Buffer;
    query[0].DefaultLength = 0;
    query[0].EntryContext = &dest_unicode_string;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL    // environment unused
    );

    if((NT_SUCCESS(ntStatus)) && (dest_unicode_string.Length != 0))
    {
        dest_ansi_string.Length = 0;
        dest_ansi_string.MaximumLength = (unsigned short) *cbLen;
        // convert it into caller's buffer
        dest_ansi_string.Buffer = Data;
        RtlUnicodeStringToAnsiString(&dest_ansi_string,
                                 &dest_unicode_string,
                                 0 /* don't allocate dest */);
        ExFreePool(dest_unicode_string.Buffer);

        *cbLen = dest_ansi_string.Length;

        return RM_OK;
    }
    else
    {
        ExFreePool(dest_unicode_string.Buffer);
        return RM_ERROR;
    }

}
#endif

#if (_WIN32_WINNT < 0x0500)

RM_STATUS osDelay
(
    U032 MilliSeconds
)
{
    // convert mSec to a relative (i.e. negative) interval of 100's of nSecs
    LARGE_INTEGER hundredsOfNanoSeconds = RtlConvertLongToLargeInteger(MilliSeconds * -10000);

    // suspend for given relative time interval
    NTSTATUS ntStatus = KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &hundredsOfNanoSeconds
    );

    return (NT_SUCCESS(ntStatus)) ? RM_OK : RM_ERROR;
}

#ifdef NOT_USING_VIDEOPORT_REGISTRY_CALLS

RM_STATUS osWriteRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 cbLen
)
{

    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";


    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // Write the registry value 
    ntStatus = RtlWriteRegistryValue(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        usRegParmStr.Buffer,
        REG_BINARY,
        Data,
        cbLen
    );
    if (!NT_SUCCESS(ntStatus))
        return RM_ERROR;

    return RM_OK;

}



//
// First pass at implementing registry binary read.
// Returns binary data
// of max length '*cbLen' and returns it in buffer pointed to by '*Data'
//
// 'Data' buffer must be 8 bytes longer than your real data as it is coerced
//     into a data structure used by registry.
//
// The union of a binary registry data record, that contains the size and type
// along with the data, and a pure UCHAR buffer is used here.
//
// Note:
//    has a lot in common w/ osReadRegistryDword
//       could be commoned once it works :-)
//    missing pDev arg of osReadRegistryDword()
//    can not be called from RmInitRm(); it is apparently too early
//        if you do, will just return STATUS_NOT_FOUND
//

RM_STATUS osReadRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 *cbLen
)
{

    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    RM_REG_BINARY_BUFFER localbuf;

    // is the buffer big enough to hold the data and the length/type fields?
    // TO DO: Is there a way so send a more helpful error code?
    if (*cbLen + 8 > sizeof(RM_REG_BINARY_BUFFER))
    {
        return RM_ERROR;
    }

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial, no callback, registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].EntryContext = localbuf.buffer;
    query[0].DefaultType = REG_NONE;
    query[0].DefaultData = localbuf.buffer;
    query[0].DefaultLength = sizeof(localbuf.buffer) - 8;   // Minus the size of the header that is prepended
    
    
    // - Prep the query
    // Zero the local buffer in case the return size is less than the expected size, as someone might get back
    // less than they expected, and at this point, we return them the size that they expected
    RtlZeroMemory(localbuf.buffer, sizeof(localbuf.buffer));
    localbuf.record.Length = sizeof(localbuf.buffer) - 8;   // Minus the size of the header that is prepended
    localbuf.record.type = REG_NONE;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL
    );
    if (!NT_SUCCESS(ntStatus)) {

        return RM_ERROR;
    }

    // Make sure that NT got the value type right...
    if( localbuf.record.type != REG_BINARY) {

       return RM_ERROR;
    }

     // shift data out to Data using a copy that works on overlapping buffers
    // For some reason, the length value handed back from Win2K is incorrect, but correct under WinNT4, so use the users size
    RtlMoveMemory(Data, localbuf.record.buffer, *cbLen);

    return RM_OK;

}

RM_STATUS osWriteRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 Data
)
{

    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";


    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // Write the registry value 
    ntStatus = RtlWriteRegistryValue(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        usRegParmStr.Buffer,
        REG_DWORD,
        &Data,
        sizeof(U032)
    );
    if (!NT_SUCCESS(ntStatus))
        return RM_ERROR;

    return RM_OK;

}

RM_STATUS osReadRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 *Data
)
{

    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    U032 errorData = 0x69696969;

    // init Data to a known-bad value
    *Data = errorData;

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].DefaultType = REG_DWORD;
    query[0].EntryContext = Data;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL
    );
    if (!NT_SUCCESS(ntStatus))
        return RM_ERROR;

    return (*Data != errorData) ? RM_OK : RM_ERROR;

}

#endif // NOT_USING_VIDEOPORT_REGISTRY_CALLS

RM_STATUS osIsr
(
    PHWINFO pDev
)
{
    BOOL serviced = FALSE;
    
    if (RmInterruptPending(pDev, &serviced))
    {
        // service any remaining interrupt and reenable ints
        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Servicing non-VBLANK interrupt...\n");
        mcService(pDev);
        RmEnableInterrupts(pDev);
        serviced = TRUE;
    }
    
    return (serviced) ? RM_OK : RM_ERROR;

} // end of osIsr()

#endif // (_WIN32_WINNT < 0x0500)


RM_STATUS
osMemSet(VOID *addr, U032 fill, U032 bytes)
{
    memset(addr, fill, bytes);
    return RM_OK;
}

// Win2K processor synchronization
#if (_WIN32_WINNT >= 0x0500)

RM_STATUS osInitSpinLock
(
    PHWINFO pDev
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS rmStatus = RM_OK;
    
    rmStatus = osAllocMem(&pOsHwInfo->pRmSpinLock, sizeof(KSPIN_LOCK));
    if (rmStatus == RM_OK)
    {
        KeInitializeSpinLock((PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock));
    }
    
    return rmStatus;
    
} // end of osInitSpinLock()
    
RM_STATUS osEnterCriticalCode
(
    PHWINFO pDev 
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    KeAcquireSpinLock
    (
        (PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock),
        (PKIRQL)&pOsHwInfo->oldIrql
    );
    return RM_OK;
    
} // end of osAcquireSpinLock()

RM_STATUS osExitCriticalCode
(
    PHWINFO pDev
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    KeReleaseSpinLock
    (
        (PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock),
        (KIRQL)pOsHwInfo->oldIrql
    );
    return RM_OK;
    
} // end of osReleaseSpinLock()

#endif // (_WIN32_WINNT >= 0x0500)

#define rdtsc __asm _emit 0x0f __asm _emit 0x31 

// Return frequency value in MHz
U032 osGetCpuFrequency()
{
    U032 t1, t2;
    U032 tsc1, tsc2;

// TO DO: what to do about inline asm for IA-64?       
#ifndef IA64
    // read the tsc
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc1], eax
        pop     edx
        pop     eax
    }

    osDelay(100);

    // read the tsc again
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc2], eax
        pop     edx
        push    eax
    }
#else     
tsc1 = 0;
tsc2 = 0;
#endif // IA-64 cannot tolerate inline asm

    // multiply returned value by 10 since we timed 1/10th second
    // and divide the result to convert from Hz to MHz
    return (U032) ((tsc2-tsc1) * 10) / (1000000);
}

#define NT_HANDLE_PCI_DEVICE_SHIFT     8
#define NT_HANDLE_PCI_FUNC_SHIFT      16

//
//  PCI config space read/write routines.
//
U032
osPciReadDword(U032 handle, U032 offset)
{
    U032 bus;
    U032 retval;
    PCI_SLOT_NUMBER slot;

    bus  = handle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (handle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (handle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

U016
osPciReadWord(U032 handle, U032 offset)
{
    U032 bus;
    U016 retval;
    PCI_SLOT_NUMBER slot;

    bus  = handle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (handle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (handle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

U008
osPciReadByte(U032 handle, U032 offset)
{
    U032 bus;
    U008 retval;
    PCI_SLOT_NUMBER slot;

    bus  = handle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (handle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (handle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

VOID
osPciWriteDword(U032 handle, U032 offset, U032 value)
{
    U032 bus;
    PCI_SLOT_NUMBER slot;

    bus  = handle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (handle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (handle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

VOID
osPciWriteWord(U032 handle, U032 offset, U016 value)
{
    U032 bus;
    PCI_SLOT_NUMBER slot;

    bus  = handle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (handle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (handle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

VOID
osPciWriteByte(U032 handle, U032 offset, U008 value)
{
    U032 bus;
    PCI_SLOT_NUMBER slot;

    bus  = handle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (handle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (handle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

U032
osPciInitHandle(U008 bus, U008 device, U008 func, U016 *pVendorId, U016 *pDeviceId)
{
    U032 vendevID, handle;
    PCI_SLOT_NUMBER slot;
    U032 status;

    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = device;
    slot.u.bits.FunctionNumber = func;

    // get vendor/device id at offset 0
    status = HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                                   bus,                  // bus number
                                   slot.u.AsULONG,       // slot number
                                   &vendevID,            // buffer
                                   0x0,                  // config space offset
                                   sizeof(vendevID));
    if (status == 0 || status == 2)
        return 0;

    // return these to the caller
    if (pVendorId)
        *pVendorId = (U016)(vendevID & 0xFFFF);
    if (pDeviceId)
        *pDeviceId = (U016)(vendevID >> 16);

    // return a non-zero handle out of bus/device/func
    handle = 0xFF000000 |
             (func << NT_HANDLE_PCI_FUNC_SHIFT) |
             (device << NT_HANDLE_PCI_DEVICE_SHIFT) | bus;
    return handle;
}

RM_STATUS
osUpdateAGPLimit(PHWINFO pDev)
{
    // In winnt4/win2k, the AGP limit is always known
    return RM_OK;
}

RM_STATUS osBeginWatchCanvas
(
    U032 hwnd
)
{
    return RM_OK;
}

RM_STATUS osEndWatchCanvas
(
    U032 hwnd
)
{
    return RM_OK;
}

RM_STATUS osSignalSemaphore
(
    U032 *SemaState
)
{
    return RM_OK;
}

RM_STATUS osWaitSemaphore
(
    U032 *SemaState
)
{
    return RM_OK;
}

RM_STATUS osGetCurrentProcess(
    U032 *pPid
)
{
    // TO DO:  what are the semantics of this??
    *pPid = 0;
    return RM_OK;
}

// Validate the DMA address space name from the app
// A DMA object with no name is treated as System Memory space
// The DMA direction does not matter for system memory space
RM_STATUS osValidateDMAObject(
    char *OsName,
    U032 DmaObjectName,
    NV_ADDRESS_SPACE *AddressSpace
)
{
    U032 i;
    RM_STATUS status;

    if (OsName[0] == '\0')
    {
        *AddressSpace = ADDR_SYSMEM;
        return(RM_OK);
    }

    if (strcmp(OsName, nameSysMem) == 0)
    {
       *AddressSpace = ADDR_SYSMEM;
       return(RM_OK);
    }

    if (strcmp(OsName, nameLVidMem) == 0)
    {
       *AddressSpace = ADDR_FBMEM;
       return(RM_OK);
    }

    if (strcmp(OsName, nameSVidMem) == 0)
    {
       *AddressSpace = ADDR_AGPMEM;
       return(RM_OK);
    }

    *AddressSpace = ADDR_SYSMEM;

    return(RM_ERR_INVALID_OS_NAME);

}

RM_STATUS osValidateVideoSink
(
    char *OsName
)
{
    U032 i;

    for (i = 0; i < 4; i++)
        if (OsName[i] != nameVideoSink[i])
            return (RM_ERR_INVALID_OS_NAME);
    return (RM_OK);
}

RM_STATUS osValidateImageVideo
(
    char *OsName,
    U032 *CanvasID
)
{
    U032 i;

    *CanvasID = 0;
    for (i = 0; i < 3; i++)
        if (*OsName++ != nameImageVideo[i])
            return (RM_ERR_INVALID_OS_NAME);
    while (*OsName >= '0' && *OsName <= '9')
        *CanvasID = *CanvasID * 10 + *OsName++ - '0';
    return (*OsName == ':' ? RM_OK : RM_ERROR);
}

// these must be shared by the miniport and RM

RM_STATUS osNotifyAction
(
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyAction() stub\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    return RM_OK;
}

RM_STATUS osError
(
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Error
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osError()\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Error  =", Error);

    return (RM_OK);
}

VOID osStateFbEx
(
    PHWINFO pDev
)
{
    U032    filterLevel;

    // check for an override value -- legal values are 0 (off), 1, or 2
    if (osReadRegistryDword(pDev, strDevNodeRM, "FilterOverride", &filterLevel) == RM_OK)
    {
        //if (pDev->Framebuffer.MonitorType != NV_MONITOR_VGA)
        {
            //pDev->Framebuffer.FilterEnable = 2;
            pDev->Framebuffer.FilterEnable = filterLevel;
        }
    }
    else
    {
        // only enable flicker filter for TV w/bit depth > 8BPP
        if (GETMONITORTYPE(pDev, 0) != NV_MONITOR_VGA)
        {
            if (pDev->Dac.HalInfo.Depth > 8)
            {
                pDev->Framebuffer.FilterEnable = 2;
            }
            else
            {
                pDev->Framebuffer.FilterEnable = 0;
            }
        }
        else
        {
            pDev->Framebuffer.FilterEnable = 0;
        }
    }

} // end of osStateFbEx()

RM_STATUS osSetVideoMode
(
    PHWINFO pDev
)
{
    U032 data32;

    if (osReadRegistryDword(pDev, strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }
    if (osReadRegistryDword(pDev, strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }

    return RM_OK;

} // end of osSetVideoMode()

#ifndef WIN2K_DDK_THAT_CONTAINS_APIS
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS osNotifyEvent
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Notifier,
    U032      Method,
    U032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, j;
    PEVENTNOTIFICATION NotifyEvent;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyEvent()\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    // perform the type of action
    switch (Action)
    {
        case NV_OS_WRITE_THEN_AWAKEN:

            // walk this object's event list and find any matches for this specific notify
            for (NotifyEvent = Object->NotifyEvent; NotifyEvent; NotifyEvent = NotifyEvent->Next)
            {
                if (NotifyEvent->NotifyIndex == Notifier)
                {
                    // found a match -- notify the event
                    switch (NotifyEvent->NotifyType)
                    {
                        case NV01_EVENT_WIN32_EVENT:
                        {
                            // attempt to trigger the event
                            KeSetEvent((PRKEVENT)NotifyEvent->Data, 0, FALSE);
                            break;
                        }

                        case NV01_EVENT_KERNEL_CALLBACK:
                        {
                            MINIPORT_CALLBACK callBackToMiniport = (MINIPORT_CALLBACK)NotifyEvent->Data;

                            // perform a direct callback to the miniport
                            if (callBackToMiniport)
                                callBackToMiniport(pDev->DBmpDeviceExtension);
                            break;
                        }
                    }
                }
            }
            break;

        default:

            // any other actions are legacy channel-based notifies
            rmStatus = NVOS10_STATUS_ERROR_BAD_EVENT;
            break;
    }

    return rmStatus;

} // end of osNotifyEvent()

#endif // (_WIN32_WINNT < 0x0500)


//---------------------------------------------------------------------------
//
//  AGP support
//
//---------------------------------------------------------------------------

#if (_WIN32_WINNT >= 0x0500)

// AGP memory allocation tracking
typedef struct _AGP_MEM_INFO
{
    NvU64   aperAddr;
    VOID*   virtAddr;
    VOID*   physContext;
    VOID*   virtContext;
    U032    sysPageCount;
} AGP_MEM_INFO, *PAGP_MEM_INFO;

#if defined(IA64)

//
// All of the routines below are to make osGetAddressInfo to work
// with the 82460GX chipset.  Unlike other chipsets, the physical
// memory mapped on by the CPU are not the AGP aperture addresses.
// Thus a call to MmGetPhysicalAddress cannot be used to determine
// whether an virtual address is mapped to AGP memory.  The following
// routines maintain a simple mapping table to map the system physical
// address to the AGP aperture address to program the adapter with.

#define AGP_MAPPING_INCR    1    // keep it small at first to exercise code

typedef struct _AGP_MAPPING {
    PHYSICAL_ADDRESS sysAddr;
    PHYSICAL_ADDRESS aperAddr;
} AGP_MAPPING, *PAGP_MAPPING;

static PAGP_MAPPING osAGPMappingTab;
static U032 osAGPMappingSize = 0;
static U032 osAGPMappingUsed = 0;

static RM_STATUS
osAllocAGPMapping(PHYSICAL_ADDRESS sysAddr, PHYSICAL_ADDRESS aperAddr)
{
    RM_STATUS status;
    PAGP_MAPPING pTab;
    U032 newSize;

    if (osAGPMappingSize == osAGPMappingUsed) {
        newSize = sizeof(AGP_MAPPING) * (osAGPMappingSize + AGP_MAPPING_INCR);
        status = osAllocMem((VOID **)&pTab, newSize);
        if (status != RM_OK)
            return status;
        if (osAGPMappingSize) {
            osMemCopy((unsigned char *)pTab, (unsigned char *)osAGPMappingTab, newSize);
            osFreeMem(osAGPMappingTab);
        }
        osAGPMappingTab = pTab;
        osAGPMappingSize += AGP_MAPPING_INCR;
    }
#ifdef DEBUG
    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        RM_ASSERT(pTab->sysAddr.QuadPart != sysAddr.QuadPart);
        RM_ASSERT(pTab->aperAddr.QuadPart != aperAddr.QuadPart);
    }
#endif
    pTab = &osAGPMappingTab[osAGPMappingUsed++];
    pTab->sysAddr = sysAddr;
    pTab->aperAddr = aperAddr;
    return RM_OK;
}

static VOID
osFreeAGPMapping(PHYSICAL_ADDRESS aperAddr)
{
    PAGP_MAPPING pTab;

    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        if (pTab->aperAddr.QuadPart == aperAddr.QuadPart) {
            osAGPMappingUsed--;
            osMemCopy((unsigned char *)pTab, (unsigned char *)(pTab+1),
                      (U032)(&osAGPMappingTab[osAGPMappingUsed] - pTab));
            return;
        }
    }
    
}

static U032
osLookupAGPMapping(PHYSICAL_ADDRESS sysAddr)
{
    PAGP_MAPPING pTab;

    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        if (pTab->sysAddr.QuadPart == sysAddr.QuadPart) {
            return (pTab->aperAddr.LowPart);
        }
    }
    return sysAddr.LowPart;
}

//
// Currently 64 bit Windows returns the same physical addresses
// for multiple virtual addresses, which is clearly a bug.
// This routine was intended as a possible partial workaround,
// but is useful to detect the condition.

static RM_STATUS
osVerifyAGPPages(PAGP_MEM_INFO pMemInfo)
{
    U032 i, j;
    VOID *vaddri, *vaddrj;
    PHYSICAL_ADDRESS paddri, paddrj;
    
    vaddri = pMemInfo->virtAddr;
    for (i = 0; i < pMemInfo->sysPageCount; i++)
    {
        paddri = MmGetPhysicalAddress(vaddri);
        vaddri = (VOID *)((char *)vaddri + PAGE_SIZE);
        vaddrj = vaddri;
        for (j = i + 1; j < pMemInfo->sysPageCount; j++)
        {
            paddrj = MmGetPhysicalAddress(vaddrj);
            vaddrj = (VOID *)((char *)vaddrj + PAGE_SIZE);
            if (paddri.LowPart == paddrj.LowPart) {
                return RM_ERROR;
            }
        }
    }
    return RM_OK;
}

#else

#define WIN2K_VIRT_OFFSET_PAGES    16

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32

//
// win2k currently doesn't set up the correct page attribute table (PAT)
// index for write-combined user space mappings to AGP. The user mapping
// gets a WB index into the PAT and because of there are no non-system MTRR's,
// this defaults to uncached mapping.
//
// To work around this, we'll first READ the PAT and determine which index
// should be used for write-combining. Then, we'll read the PTE's for the
// length of the mapping and set the correct index.
//
// I don't believe (hopefully) MP will be an issue as I expect each CPU
// points to the same page table we're about to modify. At worst, this means
// we may be slow if we ran mostly on the wrong (uncached) processor.
//
static RM_STATUS
RmChangePageAttributeTable(PAGP_MEM_INFO pMemInfo)
{
    U032 modPass, PATvalue, PDTbase, WCindex;
    U032 PDEoffset, PTEoffset, physPage, lastPage;
    U032 *basepdb, *basepte, *pdbptr, *pteptr;
    U032 virtOffset, found_first_page = 0;
    PHYSICAL_ADDRESS pagePhysicalAddr;
    
    PATvalue = PDTbase = 0x0;

    __asm {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        mov     eax, 1
        CPUID

        // check for PAT support
        shr     edx, 16
        and     edx, 1  
        jz      Exit

        // get the (low 0:3 PAT) indices
        mov     ecx, 0x277
        RDMSR
        mov     PATvalue,eax

        // get the page descriptor base
        mov     ecx, cr3
        mov     PDTbase,ecx

        // flush caches making things consistent
        wbinvd
Exit:
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }

    if (!PATvalue || !PDTbase)
        return RM_ERROR;

    // look for the WC type within the PAT indices
    for (WCindex = 0; WCindex < 4; WCindex++)
    {
        if ((PATvalue & 0xF) == 0x1)
            break;
        PATvalue >>= 8;
    }
    if (WCindex == 4)
        return RM_ERROR;    // didn't find a WC index

    // Map in the PDE page (assuming 4K ptes)
    pagePhysicalAddr.HighPart = 0;
    pagePhysicalAddr.LowPart  = (PDTbase & ~0xFFF);
    basepdb = MmMapIoSpace(pagePhysicalAddr.LowPart, RM_PAGE_SIZE, FALSE);
    if (basepdb == NULL)
        return RM_ERROR;

    //
    // First, we need to find if there's a virtOffset that needs to be setup.
    // In win2k, it seems user mappings, in addition to not being write-combined,
    // don't start at the address returned from AgpCommitVirtual after the DX
    // AGP heap has been setup.
    //
    // This might be caused by a non-zero fpGARTLin from the GUID_UpdateNonLocalHeap
    // callback DDraw gets, where the driver is supposed to offset everything by this
    // amount. But, each user alloc seems to not be just fpGARTLin bytes, it's almost
    // fpGARTlin * number of outstanding user allocs.
    // 
    // Rather than guess, for now, just scan WIN2K_VIRT_OFFSET_PAGES pages for the
    // first page and then verify the rest of the mapping from there. This virtOffset
    // will then be added to the user mapping passed back.
    //
    physPage = (U032)pMemInfo->aperAddr;

    virtOffset = 0;
    while (!found_first_page && (virtOffset < WIN2K_VIRT_OFFSET_PAGES))
    {
        // 10bits of PDE offset, 10bits of PTE offset
        PDEoffset = (U032)((NV_UINTPTR_T)pMemInfo->virtAddr >> (RM_PAGE_SHIFT + 10));
        PTEoffset = (U032)(((NV_UINTPTR_T)pMemInfo->virtAddr >> RM_PAGE_SHIFT) & 0x003FF);

        pdbptr = basepdb + PDEoffset;
        if (*pdbptr & 0x80)
        {
            MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
            return RM_ERROR;    // this isn't a 4K PDE
        }

        // Map in a set of PTEs (assuming 4K ptes)
        pagePhysicalAddr.HighPart = 0;
        pagePhysicalAddr.LowPart  = (*pdbptr & ~0xFFF);
        basepte = MmMapIoSpace(pagePhysicalAddr.LowPart, RM_PAGE_SIZE, FALSE);
        if (basepte == NULL)
        {
            MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
            return RM_ERROR;
        }

        pteptr = basepte + PTEoffset;

        // Look for the beginning of the mapping on this PTE page
        while ((PTEoffset <= 0x3FF) && (virtOffset < WIN2K_VIRT_OFFSET_PAGES))
        {
            if ((*pteptr & ~0xFFF) == physPage)
            {
                found_first_page = 1;
                break;
            }
            PTEoffset++; pteptr++; virtOffset++;
            (U008 *)pMemInfo->virtAddr += RM_PAGE_SIZE;
        }

        MmUnmapIoSpace(basepte, RM_PAGE_SIZE);
    }

    if (!found_first_page)
    {
        MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
        return RM_ERROR;    // can't find first page of our mapping
    }

    lastPage = (U032)pMemInfo->aperAddr + (pMemInfo->sysPageCount << RM_PAGE_SHIFT);

    //
    // Before updating any PTEs, make sure they have the expected physPage.
    // The second pass is the modifying pass where we update the PAT index.
    //
    for (modPass = 0; modPass < 2; modPass++)
    {
        // sets the beginning and ending phys page
        physPage = (U032)pMemInfo->aperAddr;

        // 10bits of PDE offset, 10bits of PTE offset
        PDEoffset = (U032)((NV_UINTPTR_T)pMemInfo->virtAddr >> (RM_PAGE_SHIFT + 10));
        PTEoffset = (U032)(((NV_UINTPTR_T)pMemInfo->virtAddr >> RM_PAGE_SHIFT) & 0x003FF);

        pdbptr = basepdb + PDEoffset;

        while (physPage < lastPage)
        {
            if (*pdbptr & 0x80)
            {
                MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                return RM_ERROR;    // this isn't a 4K PDE
            }

            // Map in a set of PTEs (assuming 4K ptes)
            pagePhysicalAddr.HighPart = 0;
            pagePhysicalAddr.LowPart  = (*pdbptr & ~0xFFF);
            basepte = MmMapIoSpace(pagePhysicalAddr.LowPart, RM_PAGE_SIZE, FALSE);
            if (basepte == NULL)
            {
                MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                return RM_ERROR;
            }

            pteptr = basepte + PTEoffset;

            // Check (or modify) the PTEs on this page
            while ((PTEoffset <= 0x3FF) && (physPage < lastPage))
            {
                if ((*pteptr & ~0xFFF) != physPage)
                {
                    // mismatch on physical page in PTE
                    DBG_PRINT_STRING_PTR(DEBUGLEVEL_ERRORS, "NVRM: mismatch in AGP mapping ",
                                         pMemInfo->virtAddr);
                    MmUnmapIoSpace(basepte, RM_PAGE_SIZE);
                    MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                    return RM_ERROR;
                }
                if (modPass)
                {
                    // mask off bits 4:3 and set the index
                    *pteptr = (*pteptr & ~0x18) | (WCindex << 3);
                }
                PTEoffset++; pteptr++;
                physPage += RM_PAGE_SIZE;
            }

            // Free the old page of PTEs
            MmUnmapIoSpace(basepte, RM_PAGE_SIZE);

            PTEoffset = 0x0;
            pdbptr++;
        }
    }

    MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);

    return RM_OK;
}
#endif // !IA64

#include <videoagp.h>

RM_STATUS osAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PAGP_MEM_INFO pMemInfo;
    HANDLE procHandle;
    RM_STATUS status;
    PHYSICAL_ADDRESS aperAddr;
#if defined(IA64)
    PHYSICAL_ADDRESS sysAddr;
#endif

    PVOID hwDeviceExtension = pDev->DBmpDeviceExtension;

    if (!hwDeviceExtension || !pOsHwInfo->AgpServices)
        return RM_ERR_NO_FREE_MEM;

    // we'll need to manage this allocation, a little
    status = osAllocMem((VOID **)&pMemInfo, sizeof(AGP_MEM_INFO));
    if (status != RM_OK)
        return RM_ERR_NO_FREE_MEM;

    // not all systems have PAGE_SIZE == RM_PAGE_SIZE;
    // round up to get an adequate number of system pages

    pMemInfo->sysPageCount = (pageCount + (PAGE_SIZE/RM_PAGE_SIZE) - 1) >> (PAGE_SHIFT - RM_PAGE_SHIFT);

    // reserve physical
    aperAddr = ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReservePhysical(hwDeviceExtension, pMemInfo->sysPageCount, TRUE, &pMemInfo->physContext);

    if ((aperAddr.LowPart == 0) && (aperAddr.HighPart == 0)) {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    pMemInfo->aperAddr = aperAddr.QuadPart;

    // commit physical
    if ( ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpCommitPhysical(hwDeviceExtension,
                                                                               pMemInfo->physContext,
                                                                               pMemInfo->sysPageCount,
                                                                               0)
                                                                               == FALSE )
    {

        ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    // set processs handle (hopefully triggers the correct mapping)
    procHandle = (ClientClass == NV01_ROOT_USER) ? NtCurrentProcess() : 0x0;

    // reserve virtual
    pMemInfo->virtAddr = ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReserveVirtual(hwDeviceExtension,
                                                                                               procHandle,
                                                                                               pMemInfo->physContext,
                                                                                               &pMemInfo->virtContext);
    if (pMemInfo->virtAddr == NULL)
    {
        ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
        ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    // commit virtual
    if ( ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpCommitVirtual(hwDeviceExtension,
                                                                              pMemInfo->virtContext,
                                                                              pMemInfo->sysPageCount,
                                                                              0)
                                                                              == NULL)
    {
        ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleaseVirtual(hwDeviceExtension, pMemInfo->virtContext);
        ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
        ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

#if defined(IA64)
    sysAddr = MmGetPhysicalAddress(pMemInfo->virtAddr);
    if (osAllocAGPMapping(sysAddr, aperAddr) != RM_OK) {
        osFreeAGPPages(pDev, pAddress, pMemInfo); 
        return RM_ERR_NO_FREE_MEM;
    }
    if (osVerifyAGPPages(pMemInfo) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: redundant physical pages for AGP allocation\n");
        osFreeAGPPages(pDev, pAddress, pMemInfo); 
        return RM_ERR_NO_FREE_MEM;
    }
#else
    // apply a win2k kernel workaround for write-combined user mappings 
    if (ClientClass == NV01_ROOT_USER)
    {
        // Dios Mio, forgive me for what I'm about to do ...
        if (RmChangePageAttributeTable(pMemInfo) != RM_OK)
        {
            osFreeAGPPages(pDev, pAddress, pMemInfo); 
            return RM_ERR_NO_FREE_MEM;
        }
    }
#endif

    // verify the buffer is writable (may not be due to a chipset driver bug).
    // This has been seen on a Via 694x when returning from hibernation.
    *(volatile U032 *)pMemInfo->virtAddr = 0xBEEFCAFE;
    if (*(volatile U032 *)pMemInfo->virtAddr != 0xBEEFCAFE)
    {
        DBG_PRINT_STRING_PTR(DEBUGLEVEL_ERRORS,
                            "NVRM: allocated unwritable AGP buffer ", pMemInfo->virtAddr);
        osFreeAGPPages(pDev, pAddress, pMemInfo); 
        return RM_ERR_NO_FREE_MEM;
    }

    // Set our AGP parameters, if they need to be.
    // We don't expect this to ever be needed, since RmSetAgpServices should've
    // handled it already.
    if (!pRmInfo->AGP.AGPLinearStart) {
        pRmInfo->AGP.AGPLinearStart = (VOID_PTR)pMemInfo->virtAddr;

        if (!pRmInfo->AGP.AGPPhysStart && !pRmInfo->AGP.AGPLimit) {
            // should've already been filled in by NvGetAGPBaseLimit()
            pRmInfo->AGP.AGPPhysStart   = aperAddr.LowPart;
            pRmInfo->AGP.AGPLimit       = 0x4000000;        // 64MB
        }

#ifdef DEBUG
        // first allocation should be at the aperture base
        if (aperAddr.LowPart != pRmInfo->AGP.AGPPhysStart) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: first AGP alloc != AGP base\n");
            DBG_BREAKPOINT();        
        }
#endif
    }

    *pAddress = pMemInfo->virtAddr;
    *pMemData = (VOID *)pMemInfo;

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: setup AGP addr    ", *pAddress);

    return RM_OK;
}

RM_STATUS osFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PVOID hwDeviceExtension = pDev->DBmpDeviceExtension;
    PAGP_MEM_INFO pMemInfo = pMemData;
#if defined(IA64)
    PHYSICAL_ADDRESS aperAddr;
#endif

    ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreeVirtual(hwDeviceExtension, pMemInfo->virtContext, pMemInfo->sysPageCount, 0);
    ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleaseVirtual(hwDeviceExtension, pMemInfo->virtContext);
    ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
    ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

#if defined(IA64)
    aperAddr.QuadPart = pMemInfo->aperAddr;
    osFreeAGPMapping(aperAddr);
#endif

    osFreeMem(pMemInfo);

    return RM_OK;
}

#else // WIN32_WINNT >= 0x0500

// NT4 versions just call into nvagp functions

#include <nvagp.h>

RM_STATUS osAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    return NvAllocAGPPages(pDev, pAddress, pageCount, ClientClass, pMemData);
}

RM_STATUS osFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    return NvFreeAGPPages(pDev, pAddress, pMemData);
}

#endif // WIN32_WINNT >= 0x0500

// Translate a Virtual to Physical addr (used to provide the AGP aperture offset)
RM_STATUS osVirtualToPhysicalAddr
(
    VOID* virtaddr,
    VOID** physaddr
)
{
    PHYSICAL_ADDRESS physAddress;
    
    physAddress.QuadPart = MmGetPhysicalAddress(virtaddr);

    *physaddr = (VOID*)(physAddress.LowPart);

    return RM_OK;
}

RM_STATUS osCalculatePteAdjust
(
    PHWINFO pDev,
    U032    AddressSpace,
    VOID*   Address,
    U032*   pPteAdjust
)
{
    *pPteAdjust = (U032)((SIZE_PTR)Address & RM_PAGE_MASK);

    return RM_OK;
}

// get address information from the linear address
RM_STATUS osGetAddressInfo
(
    PHWINFO pDev,
    U032    unusedParamChID,
    U032    unusedParamSelector,
    VOID**  pLinearAddress,
    U032    Limit,
    VOID**  pAddress,
    NV_ADDRESS_SPACE *pAddressSpace
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    PHYSICAL_ADDRESS pa;
    U032 physFbAddr;
    U032 physicalAddress;
    U032 ramSize;

    // Check to see if we have an address space conflict
    if ((*pAddressSpace != ADDR_UNKNOWN) && (*pAddressSpace != ADDR_SYSMEM))
    {
       return (RM_ERR_BAD_ADDRESS);
    }

#if 1 // NUGOOP
    if (((ULONG)(*pLinearAddress)) >= 0xF8000000
        && (((ULONG)(*pLinearAddress)) + Limit) < (0xF8000000 + 64 * 1024 * 1024))
    {
        // For AGP, just return the Aperture address as the DescAddr, which'll get
        // loaded into the instance memory PTEs

        *pAddressSpace = ADDR_AGPMEM;
        *pAddress = (VOID*)((ULONG)(*pLinearAddress));
   
        return (RM_OK);
    }
#endif

    // Convert virtual address into physical address

    pa.QuadPart = MmGetPhysicalAddress(*pLinearAddress);

#ifdef IA64
    //
    // The virtual address of AGP memory returned to the user is mapped
    // to PCI pages on the 82460GX chipset.  Substitute the AGP aperture
    // address for this physical address in this case.

    physicalAddress = osLookupAGPMapping(pa);
#else
    physicalAddress = pa.LowPart;
#endif

    physFbAddr = pDev->Mapping.PhysFbAddr;
    ramSize = pDev->Framebuffer.HalInfo.RamSize;

    // address space type is frame buffer if the physical address lies within the FB range
    if (physicalAddress >= physFbAddr && physicalAddress < physFbAddr + ramSize)
    {
        if (physicalAddress + Limit >= physFbAddr + ramSize)
        {
            //
            // We're straddling fb mem...bomb.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses fbmem boundary ", physicalAddress);
            DBG_BREAKPOINT();
            return (RM_ERR_MULTIPLE_MEMORY_TYPES);
        }

        //
        // Subtract off the start of the framebuffer
        //
        *pLinearAddress = (VOID*)(physicalAddress - physFbAddr);
        //
        // Turn this into a PNVM dma structure
        //
        *pAddressSpace = ADDR_FBMEM;
    }

#if 0 // NUGOOP

    else if (pRmInfo->AGP.AGPLinearStart &&
             physicalAddress >= pRmInfo->AGP.AGPPhysStart &&
             physicalAddress < pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit)
    {
        if (physicalAddress + Limit > pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit)
        {
            //
            // We're straddling agp mem...bomb.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses agp aperture boundary ", physicalAddress);
            DBG_BREAKPOINT();
            return (RM_ERR_MULTIPLE_MEMORY_TYPES);
        }

        // For AGP, just return the Aperture address as the DescAddr, which'll get
        // loaded into the instance memory PTEs
        *pAddressSpace = ADDR_AGPMEM;
        *pLinearAddress = (VOID *)physicalAddress;
    }
#endif
    // otherwise address space type is system    
    else
    {
        // The address space is always system memory
        *pAddressSpace = ADDR_SYSMEM;
    }

    // the resulting address IS the linear address
    *pAddress = *pLinearAddress;

    return (RM_OK);
}
/* remap IO memory to kernel space */
VOID *osMapKernelSpace(unsigned long start, unsigned long size, U008 cached)
{
    PHYSICAL_ADDRESS physaddr;
    physaddr.HighPart = 0;
    physaddr.LowPart  = start;
    return MmMapIoSpace(physaddr.LowPart, size, cached);
}

VOID osUnmapKernelSpace(void *addr, unsigned long size)
{
    MmUnmapIoSpace(addr, size);
}

#if 0

/* remap memory to user space */
VOID *osMapUserSpace(VOID *kaddr, VOID **priv, unsigned int size_bytes, U008 cached)
{
    PMDL pMdl;
    VOID *addr;

    // create a mdl that describes the kernel mapping
    pMdl = MmCreateMdl(NULL,
                       kaddr,
                       size_bytes);
    if (pMdl == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Cannot allocate MDL\n");
        return NULL;
    }
  
  
    // fill in the physical page array of the MDL
    MmBuildMdlForNonPagedPool(pMdl);

    // create the user mapping to these pages
    addr = MmMapLockedPages(pMdl, UserMode);
    if (addr == NULL)
    {
       ExFreePool(pMdl);
       pMdl = NULL;
       return NULL;
    }

    *priv = (VOID *) pMdl;
    return addr;
}

VOID osUnmapUserSpace(VOID *uaddr, VOID *priv)
{
    PMDL pMdl = (PMDL) priv;

    MmUnmapLockedPages(uaddr, pMdl);
    ExFreePool(pMdl);
    priv = (VOID *) NULL;
}

VOID *osAllocContigPages(U032 size)
{
    PHYSICAL_ADDRESS physaddr;
    physaddr.HighPart = 0;
    physaddr.LowPart  = -1;
    return (VOID *) MmAllocateContiguousMemory(size, physaddr);
}

VOID osFreeContigPages(VOID *addr)
{
    MmFreeContiguousMemory(addr);
}


U032 osGetKernPhysAddr(VOID *kern_virt_addr)
{
    PHYSICAL_ADDRESS physaddr;
    physaddr = MmGetPhysicalAddress(kern_virt_addr);
    return (physaddr.LowPart);
}

RM_STATUS osGetAGPPhysAddr(PHWINFO pDev, VOID *vaddr, U032 *paddr)
{
    *paddr = osGetKernPhysAddr(vaddr);
    if (*paddr == (U032) 0x0) return RM_ERROR;
    return RM_OK;
}
#endif

RM_STATUS osAllocPool(VOID **addr, unsigned int size_bytes)
{
    *addr = ExAllocatePoolWithTag(NonPagedPool, size_bytes, NV_MEMORY_TAG);
    if (*addr == NULL) return RM_ERROR;
    return RM_OK;
}

RM_STATUS osFreePool(VOID *addr)
{
    ExFreePool(addr);
    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Debugging support.
//
//---------------------------------------------------------------------------

#if DBG

// The current debug display level (default to maximum debug level)
int cur_debuglevel = DEBUGLEVEL_WARNINGS;

VOID osDbgBreakPoint
(
    void
)
{
    DbgBreakPoint();
}

VOID osDbgPrintString
(
    int debuglevel,
    char* string
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print formatted string, for checked build
        DbgPrint(string);
    }
}

VOID osDbgPrintValue
(
    int debuglevel,
    int value
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print hex value only, for checked build
        DbgPrint("0x%x", value);
    }
}

VOID osDbgPrintCR
(
    int debuglevel
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print newline only, for checked build
        DbgPrint("\n");
    }
}

VOID osDbgPrintStringValue
(
    int debuglevel,
    char *string,
    int value
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print string and hex value, for checked build
        DbgPrint("%s 0x%x\n", string, value);

    }
}

VOID osDbgPrintStringDec
(
    int debuglevel,
    char *s,
    U032 decVal
)
{
    // print string and decimal value, for checked build
    if (debuglevel >= cur_debuglevel) 
    {
        DbgPrint("%s %d\n", s, decVal);
    }
}

VOID osDbgPrintStringPtr
(
    int debuglevel,
    char *s,
    VOID *ptr
)
{
    // print string and pointer, for checked build
    if (debuglevel >= cur_debuglevel) 
    {
        DbgPrint("%s 0x%p\n", s, ptr);
    }
}

VOID osDbgPrintStringVal64
(
    int debuglevel,
    char *string,
    U064 value
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print string and hex value, for checked build
        DbgPrint("%s 0x%I64x\n", string, value);
    }
}

#endif // DBG


// end of os.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osapi.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************************************************************
*
*   File: osapi.c
*
*   Description:
*       This file contains the resource manager API for the NT miniport.  It
*   provides services to the miniport that directly access the device.
*
******************************************************************************/

#include <ntddk.h>
#include <nvrm.h>
#include <nvhw.h>
#include <os.h>

BOOL RmLoadState
(
    U032 deviceReference,
    U032 horizWidth,
    U032 vertWidth,
    U032 bitDepth,
    U032 refreshRate,
    BOOL vgaEnabled
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // allow hi res modes to happen
    // This value should be FALSE after a SetMode has occurred
    // This value should be TRUE when restoring from Hibernation (in VGA mode)
    pDev->Vga.Enabled = vgaEnabled;

    // transfer the arguments from the client into RM global state
    pDev->Dac.HalInfo.Depth             = bitDepth;
    pDev->Framebuffer.HalInfo.RefreshRate        = refreshRate;
    pDev->Framebuffer.HalInfo.HorizDisplayWidth  = horizWidth;
    pDev->Framebuffer.HalInfo.VertDisplayWidth   = vertWidth;

    // reload the state based on the new display mode
    rmStatus = stateNv(pDev, STATE_LOAD);
    
    return (rmStatus == RM_OK) ? TRUE : FALSE;
                        
} // end of RmLoadState()

BOOL RmUnloadState
(
    U032 deviceReference
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // unload the state
    rmStatus = stateNv(pDev, STATE_UNLOAD);
    
    return (rmStatus == RM_OK) ? TRUE : FALSE;
            
} // end of RmUnloadState()


#if 0
BOOL RmUpdateAGPConfig
(
    U032 deviceReference
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    NvUpdateAGPConfig(pDev);
        
    return (rmStatus == RM_OK) ? TRUE : FALSE;
            
} // end of RmUnloadState()
#endif

BOOL RmSetMode
(
    U032 deviceReference,
    U032 HorizontalVisible,
    U032 HorizontalBlankStart,
    U032 HorizontalRetraceStart,
    U032 HorizontalRetraceEnd,
    U032 HorizontalBlankEnd,
    U032 HorizontalTotal,
    U032 VerticalVisible,
    U032 VerticalBlankStart,
    U032 VerticalRetraceStart,
    U032 VerticalRetraceEnd,
    U032 VerticalBlankEnd,
    U032 VerticalTotal,
    U032 PixelDepth,
    U032 RefreshRate,
    U032 Width,
    U032 Height,
    U032 PixelClock,
    U032 HorizontalSyncPolarity,
    U032 VerticalSyncPolarity,
    U032 DoubleScannedMode     
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // unload the state
    rmStatus = stateDac(pDev, STATE_UNLOAD);
    if (rmStatus == RM_OK)
    {
        // set the VESA parameters in the device context
        pDev->Dac.HorizontalVisible         = HorizontalVisible;     
        pDev->Dac.HorizontalBlankStart      = HorizontalBlankStart;
        pDev->Dac.HorizontalRetraceStart    = HorizontalRetraceStart;
        pDev->Dac.HorizontalRetraceEnd      = HorizontalRetraceEnd;
        pDev->Dac.HorizontalBlankEnd        = HorizontalBlankEnd;
        pDev->Dac.HorizontalTotal           = HorizontalTotal;
        pDev->Dac.VerticalVisible           = VerticalVisible;
        pDev->Dac.VerticalBlankStart        = VerticalBlankStart;
        pDev->Dac.VerticalRetraceStart      = VerticalRetraceStart;
        pDev->Dac.VerticalRetraceEnd        = VerticalRetraceEnd;
        pDev->Dac.VerticalBlankEnd          = VerticalBlankEnd;
        pDev->Dac.VerticalTotal             = VerticalTotal;
        pDev->Dac.PixelDepth                = PixelDepth;
        pDev->Dac.HalInfo.PixelClock        = PixelClock;
        pDev->Dac.HorizontalSyncPolarity    = HorizontalSyncPolarity;
        pDev->Dac.VerticalSyncPolarity      = VerticalSyncPolarity;
        pDev->Dac.DoubleScannedMode         = DoubleScannedMode;
        pDev->Dac.DisplayPitch              = HorizontalVisible * (PixelDepth >> 3);

        // reload the state -- this will reset the mode
        pDev->Vga.Enabled = FALSE;

        // transfer the arguments from the client into RM global state
        pDev->Dac.HalInfo.Depth             = PixelDepth;
        pDev->Framebuffer.HalInfo.RefreshRate        = RefreshRate;
        pDev->Framebuffer.HalInfo.HorizDisplayWidth  = Width;
        pDev->Framebuffer.HalInfo.VertDisplayWidth   = Height;

        rmStatus = stateDac(pDev, STATE_LOAD);
        if (rmStatus == RM_OK)
            rmStatus = dacSetMode(pDev, 0);
    } 

    return (rmStatus == RM_OK) ? TRUE : FALSE;  
                        
} // end of RmSetMode()

BOOL RmIsr
(
    U032 deviceReference
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // check for any valid NV interrupts that need to be serviced
    if (pDev)
    {
        rmStatus = osIsr(pDev);
    }

    return (rmStatus == RM_OK);

} // end of RmIsr()

BOOL RmInterruptPending
(
    PHWINFO pDev,
    BOOL *serviced
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    V032 pmc;

    // check interrupts only if the RM is initialized
    if (pOsHwInfo->rmInitialized)
    {
        // service interrupts only if they are enabled
        if (REG_RD32(NV_PMC_INTR_EN_0))
        {
            // service interrupts only if they are present
            pmc = REG_RD32(NV_PMC_INTR_0);
            if (pmc)
            {
                // disable interrupts
                RmDisableInterrupts(pDev);

                // only service interrupts locally for NT4
                #if (_WIN32_WINNT < 0x0500)
                // locally service high-priority interrupts immediately
                if (pmc & PENDING_INTERRUPTS)
                {
                    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Servicing VBLANK interrupt...\n");
                    VBlank(pDev);
                    *serviced = TRUE;
                }
                #endif // _WIN32_WINNT >= 0x0500

                // recheck to see if any interrupts occured during local servicing
                pmc = REG_RD32(NV_PMC_INTR_0);
                if (pmc)
                {
                    // a non-VBLANK interrupt is pending, so don't enable ints yet
                    return TRUE;
                }
                else
                {
                    // enable interrupts if all were serviced locally
                    RmEnableInterrupts(pDev);
                }
            }
        }
    }

    return FALSE;

} // end of RmInterruptPending()

VOID RmEnableInterrupts
(
    PHWINFO pDev
)
{
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Enabling NV interrupts...\n");
    REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);

} // end of RmEnableInterrupts();

VOID RmDisableInterrupts
(
    PHWINFO pDev
)
{
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Disabling NV interrupts...\n");
    REG_WR32(NV_PMC_INTR_EN_0, 0x00000000);

} // end of RmDisableInterrupts();

BOOL RmConfigGetKernel
(
    U032 deviceReference,
    U032 index,
    U032* pValue
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];
    
    rmStatus = stateConfigGet(pDev, index, pValue);

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigGetKernel()

BOOL RmConfigGetExKernel
(
    U032 deviceReference,
    U032 index,
    VOID* pParms,
    U032 parmSize
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];
    
    rmStatus = stateConfigGetEx(pDev, index, pParms, parmSize);

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigGetExKernel()


BOOL RmConfigSetKernel
(
    U032  deviceReference,
   U032  index,
   U032  newvalue,
   U032* pOldvalue
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];
    
   rmStatus = stateConfigSet(pDev, index, newvalue, pOldvalue);

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigSetKernel()

BOOL RmConfigSetExKernel
(
    U032 deviceReference,
    U032 index,
    VOID* pParms,
    U032 parmSize
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];
    
    rmStatus = stateConfigSetEx(pDev, index, pParms, parmSize);

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigSetExKernel()

#if 0 // (_WIN32_WINNT >= 0x0500)
VOID RmSetAgpServices
(
    U032 deviceReference,
    VOID *AgpServices
)
{
    PHWINFO pDev = NvDBPtr_Table[deviceReference];
    PRMINFO pRmInfo = (PRMINFO) NvDBPtr_Table[deviceReference]->pRmInfo;
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS status;

    pOsHwInfo->AgpServices = AgpServices;

    // setup our AGP base/limit
    if (pOsHwInfo->AgpServices) {
        PHYSICAL_ADDRESS AgpPhysBase;
        VOID *AgpLinearBase;

        // Get the AGP physical base and limit
        status = NvGetAGPBaseLimit(pDev, &pRmInfo->AGP.AGPPhysStart, &pRmInfo->AGP.AGPLimit);
        if (status != RM_OK) {
            // chipset isn't configured correctly
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NvGetAGPBaseLimit call failed\n");
            pOsHwInfo->AgpServices = NULL;        // avoid AGP allocations
            return;
        }

        DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,   "NVRM: AGP PhysBase:  ", (VOID *)pRmInfo->AGP.AGPPhysStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AGP PhysLimit: ", pRmInfo->AGP.AGPLimit);

        //
        // So we're not dependent on anyone else's mapping to exist, establish our
        // own virtual addr to the AGP physbase. We only need a single page mapped
        // and type of mapping doesn't really matter. This is used only by drivers
        // wanting to setup a context DMA for the whole AGP aperture.
        //
        AgpPhysBase.HighPart = 0x00000000;
        AgpPhysBase.LowPart = (ULONG)pRmInfo->AGP.AGPPhysStart;

        AgpLinearBase = MmMapIoSpace(AgpPhysBase, 0x1000, 0x2);
        if (AgpLinearBase == NULL) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Failed to establish AGP base mapping\n");
            return;
        }
        pRmInfo->AGP.AGPLinearStart = (VOID_PTR)AgpLinearBase;
    }
}
#endif

BOOL RmPreModeSet
(
    U032 deviceReference,
    U032 head
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];
    int i;

    pDev->Vga.Enabled = FALSE;

    // call the pre-mode set OS service
    osPreModeSetEx(pDev, head);
    
    // 
    // For a tiled primary surface, we delay setting the tiled bit in the hardware
    // until after we've modeswitched out of VGA to prevent a garbled splash screen.
    // Just in case we haven't set it yet, do it now.
    //
    for (i=0; i<MAX_CRTCS; i++) {
        if (pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i].hwResId != 0) {
            nvHalFbSetAllocParameters(pDev, &pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i]);
        }
    }
    return (rmStatus == RM_OK) ? TRUE : FALSE;

}

BOOL RmPostModeSet
(
    U032 deviceReference,
    U032 head
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // call the pre-mode set OS service
    osPostModeSetEx(pDev, head);
    
    return (rmStatus == RM_OK) ? TRUE : FALSE;

}

// set a display's state: TRUE = on, FALSE = off
BOOL RmSetDisplayPowerState
(
    U032 deviceReference,
    U032 head,
    BOOL state
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        if (state)
        {
            // turn DAC on
            dacEnableDac(pDev, head);
            
            // signify that the sync state has not been set
            pDev->Dac.CrtcInfo[head].SyncStateIsSaved = FALSE;
            
        }
        else
        {
            // store away the sync states only on the first call
            if (!pDev->Dac.CrtcInfo[head].SyncStateIsSaved)
            {
                pDev->Dac.CrtcInfo[head].CurrentVsyncState = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, head);
                pDev->Dac.CrtcInfo[head].CurrentHsyncState = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, head);
                pDev->Dac.CrtcInfo[head].SyncStateIsSaved = TRUE;
            }
            
            // turn DAC off
            dacDisableDac(pDev, head);
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

    return (rmStatus == RM_OK);

} // end of RmSetDisplayPowerState()

// set I2C ownership to the given head
BOOL RmEnableHead
(
    U032 deviceReference,
    U032 head
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        EnableHead(pDev, head);
    }
    else
    {
        rmStatus = RM_ERROR;
    }    
    
    return (rmStatus == RM_OK);

} // end of RmEnableHead()

// TO DO:  these defines need to go to a file that is shared between the miniport.c and osapi.c
// power state definitions used by RmSet/GetPowerState() and RmGetCurrentPowerState()
#define NV_POWER_ADAPTER_STATE_0            0x00000001 // full on
#define NV_POWER_ADAPTER_STATE_1            0x00000002 // slowed clocks
#define NV_POWER_ADAPTER_STATE_2            0x00000004 // slowed clocks, mobile style *** not all devices supported ***
#define NV_POWER_ADAPTER_STATE_3            0x00000008 // very slow clocks, state saved (regs & instance memory)
#define NV_POWER_ADAPTER_STATE_4            0x00000010 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_5            0x00000020 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_6            0x00000040 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_7            0x00000080 // future lower adapter power state
#define NV_POWER_ADAPTER_FEATURE_CTXSAVED   0x00000100 // lowest power consumption state saves device context
#define NV_POWER_ADAPTER_FEATURE_UNDEF_1    0x00000200 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_2    0x00000400 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_3    0x00000800 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_4    0x00001000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_5    0x00002000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_6    0x00004000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_7    0x00008000 // future feature
#define NV_POWER_MONITOR_STATE_0            0x00010000 // full on
#define NV_POWER_MONITOR_STATE_1            0x00020000 // no VSYNC nor HSYNC
#define NV_POWER_MONITOR_STATE_2            0x00040000 // future lower monitor power state 
#define NV_POWER_MONITOR_STATE_3            0x00080000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_4            0x00100000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_5            0x00200000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_6            0x00400000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_7            0x00800000 // future lower monitor power state
#define NV_POWER_UNDEF_0                    0x01000000 // future attribute
#define NV_POWER_UNDEF_1                    0x02000000 // future attribute
#define NV_POWER_UNDEF_2                    0x04000000 // future attribute
#define NV_POWER_UNDEF_3                    0x08000000 // future attribute
#define NV_POWER_UNDEF_4                    0x10000000 // future attribute
#define NV_POWER_UNDEF_5                    0x20000000 // future attribute
#define NV_POWER_UNDEF_6                    0x40000000 // future attribute
#define NV_POWER_UNDEF_7                    0x80000000 // future attribute


BOOL RmSetPowerState
(
    U032 deviceReference,
    U032 head,
    U032 state
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        switch (state)
        {
            // ADAPTER POWER STATES
            
            //  Level 0 - full on
            case NV_POWER_ADAPTER_STATE_0:
                mcPowerState(pDev, MC_POWER_LEVEL_0);
                break;
                
            //  Level 1 - slowed clocks
            case NV_POWER_ADAPTER_STATE_1:
                mcPowerState(pDev, MC_POWER_LEVEL_1);
                break;
                
            //  Level 2 - slowed clocks, mobile style (not all devices support)
            case NV_POWER_ADAPTER_STATE_2:
                mcPowerState(pDev, MC_POWER_LEVEL_2);
                break;
                
            //  Level 3 - very slow clocks, state saved (regs & instance memory)
            case NV_POWER_ADAPTER_STATE_3:
                mcPowerState(pDev, MC_POWER_LEVEL_3);
                break;
                
                
            // DISPLAY POWER STATES
            
            // display on
            case NV_POWER_MONITOR_STATE_0:
            
                // turn DAC on
                dacEnableDac(pDev, head);
            
                // flag that the sync state has not been set
                pDev->Dac.CrtcInfo[head].SyncStateIsSaved = FALSE;
                
                // set the current monitor power state for this head
                pDev->Dac.CrtcInfo[head].CurrentPowerState = NV_POWER_MONITOR_STATE_0;
                
                break;
            
            // display off
            case NV_POWER_MONITOR_STATE_1:
            
                // store away the sync states only on the first call
                if (!pDev->Dac.CrtcInfo[head].SyncStateIsSaved)
                {
                    pDev->Dac.CrtcInfo[head].CurrentVsyncState = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, head);
                    pDev->Dac.CrtcInfo[head].CurrentHsyncState = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, head);
                    pDev->Dac.CrtcInfo[head].SyncStateIsSaved = TRUE;
                }
            
                // turn DAC off
                dacDisableDac(pDev, head);
                
                // set the current monitor power state for this head
                pDev->Dac.CrtcInfo[head].CurrentPowerState = NV_POWER_MONITOR_STATE_1;
                
                break;
                
            default:
                rmStatus = RM_ERROR;
                break;
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

    return (rmStatus == RM_OK);
    
} // end of RmSetPowerState()

BOOL RmGetCurrentPowerState
(
    U032 deviceReference,
    U032 head, 
    U032* pState
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        // load the return state with the current adapter state
        switch (pDev->Power.State)
        {
            case MC_POWER_LEVEL_0:
                *pState = NV_POWER_ADAPTER_STATE_0;
                break;
                
            case MC_POWER_LEVEL_1:
                *pState = NV_POWER_ADAPTER_STATE_1;
                break;
                
            case MC_POWER_LEVEL_2:
                *pState = NV_POWER_ADAPTER_STATE_2;
                break;
                
            case MC_POWER_LEVEL_3:
                *pState = NV_POWER_ADAPTER_STATE_3;
                break;
        }
        
        // OR in the current monitor state
        // TO DO: use HAL to get max head count for this sanity check
        if (head < 2)
        {
            *pState |= pDev->Dac.CrtcInfo[head].CurrentPowerState;
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

    return (rmStatus == RM_OK);
    
} // end of RmGetCurrentPowerState()

BOOL RmGetPowerCaps
(
    U032 deviceReference,
    U032 head, 
    U032* pCaps
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        // TO DO: do we need some kind of HAL call for this?
        if (pDev->Power.MobileOperation)
        {
            *pCaps = 
                NV_POWER_ADAPTER_STATE_0            |
                NV_POWER_ADAPTER_STATE_2            |
                NV_POWER_ADAPTER_STATE_3            |
                NV_POWER_ADAPTER_FEATURE_CTXSAVED   |
                NV_POWER_MONITOR_STATE_0            |
                NV_POWER_MONITOR_STATE_1;
        }
        else
        {
            *pCaps = 
                NV_POWER_ADAPTER_STATE_0            |
                NV_POWER_ADAPTER_STATE_1            |
                NV_POWER_ADAPTER_STATE_3            |
                NV_POWER_ADAPTER_FEATURE_CTXSAVED   |
                NV_POWER_MONITOR_STATE_0            |
                NV_POWER_MONITOR_STATE_1;
        }    
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

    return (rmStatus == RM_OK);
    
} // end of RmGetPowerCaps()

BOOL RmSetDriverHotkeyHandling
(
    U032 deviceReference,
    BOOL enabled
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        if (enabled)
        {
            EnableMobileHotkeyHandling(pDev);
        }
        else
        {
            DisableMobileHotkeyHandling(pDev);
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

    return (rmStatus == RM_OK);

} // end of RmSetDriverHotkeyHandling()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osinit.c ===
/**************************************************************************************************************
*
*   Module:  osinit.c
*
*   Description:
*       This is the NT-specific, device-independent initialization code for the resource manager.
*
*
**************************************************************************************************************/

#include <nvhw.h>
#include <nvrm.h>
#include <nvos.h>
#include <nvarch.h>
#include <devinit.h>
#include <rmfail.h>

//
// Globals
//
WINNTHWINFO winNTHwInfo[MAX_INSTANCE];

// local prototypes
RM_STATUS   initDmaListElementPool();
VOID        initDisplayInfo(PDISPLAYINFO);


BOOL RmInitRm()
{
    // init client database
    if (initClientInfo() != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize client database\n");
        return FALSE;
    }

    // init dma context-list element pool
    if (initDmaListElementPool() != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize graphics patch pool\n");
        return FALSE;
    }

    // init state of display
    osDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    initDisplayInfo(&osDisplayInfo);

    return TRUE;
       
} // end of RmInitRm()


BOOL RmInitNvMapping
(
    VOID* deviceExtension,
    U032 PhysNvAddr,
    PHWREG nvRegisterBase,
    U032* pDeviceReference
)
{
    PHWINFO pDev;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: RmInitNvMapping:\n");

    // get the next available device instance
    if (!RM_SUCCESS(RmAllocDeviceInstance(pDeviceReference)))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device database\n");
        return FALSE;
    }
    pDev = NvDBPtr_Table[*pDeviceReference];

    // setup the ptr to the OS Hw info
    pDev->pOsHwInfo = (VOID_PTR) &winNTHwInfo[*pDeviceReference];

    // set the device extension
    pDev->DBmpDeviceExtension = deviceExtension;

    // init configuration
    osStringCopy(pDev->Mapping.ID, "Device Mapping");
    pDev->Mapping.Size = sizeof(pDev->Mapping);

    // set physical and logical register base
    pDev->Mapping.PhysAddr = PhysNvAddr;
    nvAddr = nvRegisterBase;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: device instance          :", devInstance);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: NV using physical address:", (VOID *)pDev->Mapping.PhysAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: NV using linear address  :", nvAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: ROM using linear address :", romAddr);
    
    // default the crystal frequency to 0
    pDev->Chip.HalInfo.CrystalFreq = 0;

    return TRUE;

} // end of RmInitNvMapping()

BOOL RmInitNvHal
(
    U032 deviceReference
)
{
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // hook up the HAL
    if (initHal(pDev) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device-dependent (HAL) state\n");
        return FALSE;
    }

    // set the chip revision
    nvHalMcControl(pDev, MC_CONTROL_SETREVISION);

    // set the bios addr now, PraminOffset is set in MC_CONTROL_SETREVISION
    biosAddr = (PHWREG)((U008 *)nvAddr + pDev->Pram.HalInfo.PraminOffset);

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: BIOS using linear address:", biosAddr);

    return (TRUE);
} // end of RmInitNvHal()

// the FB address is only provided on the first POST
BOOL RmPostNvDevice
(
    U032 deviceReference,
    PHWREG externalBiosImage,
    PHWREG frameBufferBase
)
{
    RM_STATUS rmStatus = RM_OK;
    BOOL biosUsedToInit;
    
    // set the device context
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: POSTing device instance  :", devInstance);

    // set the FB logical address, if given
    if (frameBufferBase)
    {
        fbAddr = frameBufferBase;
    }
    
    // POST the device
    rmStatus = DevinitInitializeDevice(pDev, externalBiosImage, &biosUsedToInit);

    if (RM_SUCCESS(rmStatus))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...POST completed sucessfully\n");
        
        // shadow the VGA BIOS image in upper inst mem
        if (externalBiosImage)
        {
            DevinitShadowBios(pDev, externalBiosImage);
        }
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot POST the device\n");
    }
    
    return (rmStatus == RM_OK);

} // end of RmPostNvDevice()

BOOL RmInitNvDevice
(
    U032 deviceReference,
    U032 PhysFbAddr,
    PHWREG frameBufferBase
)
{
    // set the device context
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: RmInitNvDevice:\n");

    // init the RM FAILURE facility if enabled
    RM_FAILURE_ENABLE();
    
    // init processor synchronization
    if (!RM_SUCCESS(osInitSpinLock(pDev)))
    {
        return FALSE;
    }

    // init "DMA adapter" for use in memory management routines
    if (!RM_SUCCESS(osInitDmaAdapter(pDev)))
    {
        return FALSE;
    }
        
#ifdef RM_STATS
    // init all data structures
    pDev->Statistics.MemAlloced = 0;
    pDev->Statistics.MemLocked = 0;
#endif

    // set physical and logical frame buffer
    pDev->Mapping.PhysFbAddr = PhysFbAddr;
    fbAddr = frameBufferBase;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: device instance          :", devInstance);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: FB using physical address:", (VOID *)pDev->Mapping.PhysFbAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: FB using linear address  :", fbAddr);

    // initialize all engines -- calls back initMapping()
    if (!RM_SUCCESS(stateNv(pDev, STATE_INIT)))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize the device\n");
        return FALSE;
    }

    // come up as VGA until display driver disables it, thus enabling high-res
    pDev->Vga.Enabled = TRUE;
    if (!RM_SUCCESS(stateNv(pDev, STATE_LOAD)))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot load state into the device\n");
        return FALSE;
    }

    return TRUE;

} // end of RmInitNvDevice()

// init the global pool of DMA context list elements
RM_STATUS initDmaListElementPool()
{
    RM_STATUS status = RM_OK;
    U032 i;

    // allocate the pool
    status = osAllocMem((VOID **)&dmaListElementPool, sizeof(DMALISTELEMENT_POOL_ELEMENT) * DMALISTELEMENT_POOL_SIZE);
    if (RM_SUCCESS(status))
    {
        // initialize the pool
        for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
        {
            dmaListElementPool[i].inUse = FALSE;
        }
    }

    return status;

} // end of initDmaCtxtListElemPool()

VOID initDisplayInfo(PDISPLAYINFO pDi)
{
    // these are hard coded not unreasonable values for the time being
    pDi->XRes                   = 1024;
    pDi->YRes                   = 768;
    pDi->Bpp                    = 16;
    pDi->HdrSize                = 0x32;
    pDi->InfoFlags              = 0;
    pDi->DevNodeHandle          = 0;
    pDi->DriverName[0]          = 0;
    pDi->DPI                    = 0x60;
    pDi->Planes                 = 0x1;
    pDi->RefreshRateMax         = 0x4F;
    pDi->RefreshRateMin         = 0x32;
    pDi->LowHorz                = 0x1E;
    pDi->HighHorz               = 0x40;
    pDi->LowVert                = 0x32;
    pDi->HighVert               = 0x64;
    pDi->MonitorDevNodeHandle   = 0;
    pDi->HorzSyncPolarity       = 0x2B;
    pDi->VertSyncPolarity       = 0x2B;

} // end of RmInitDisplayInfo()

// map the NV device into the RM memory space
RM_STATUS initMapping
(
    PHWINFO pDev
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS status;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initMapping:\n");

    // attempt to determine the current CPU type
    RmInitCpuInfo(pDev);

    // attempt to determine the FSB and Memory speeds
    RmInitBusInfo(pDev);

    // reload mapped device addresses for HAL use
    if (initHalMappings(pDev) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device mappings for HAL\n\r");
        return FALSE;
    }

    // satisfy MC init
    pDev->Mapping.IntPin = 0x0A;

    // Some PCI BIOSs leave the ROM mapped.  This causes problems if it overlays system RAM.  Just disable it.
    REG_WR32(NV_PBUS_PCI_NV_12, 0);
    
    // make sure our PCI latency timer is sufficient (max it out)
    REG_WR32(NV_PBUS_PCI_NV_3, DRF_NUM(_PBUS,_PCI_NV_3,_LATENCY_TIMER, NV_PBUS_PCI_NV_3_LATENCY_TIMER_248_CLOCKS));

#if (_WIN32_WINNT < 0x500)
    //
    // For NT4, we'll attempt to recognize the chipset and init AGP support
    // if this is an AGP card and there's no registry entry override set
    //
    {
        U032 data32;
        U032 stringlength=80;
        char string[80];
        extern char strDevNodeRM[];
        extern char strNTSrvPackVersion[];

        // For DELL's unattended install, they're running NT without *ANY* service packs!
        // In this case, do NOT implement AGP functionality, because NT without
        // service pack can't handle it.  We'll check and see if a service pack 
        // (greather than or equal to service pack 3) was installed.  Not sure
        // what C libraries we can include here, so to be safe, just compare the strings by hand.
    
        if (osReadRegistryString(strNTSrvPackVersion, "CSDVersion", &string[0], &stringlength) == RM_OK)
        {
            if ( ((string[0] == 'S') || (string[0] == 's'))  && 
                 ((string[1] == 'E') || (string[1] == 'e'))  &&                 
                 ((string[2] == 'R') || (string[2] == 'r'))  &&
                 ((string[3] == 'V') || (string[3] == 'v'))  && 
                 ((string[4] == 'I') || (string[4] == 'i'))  && 
                 ((string[5] == 'C') || (string[5] == 'c'))  && 
                 ((string[6] == 'E') || (string[6] == 'e'))  &&             
                 (string[13] >= '3') )             
            {

                if (osReadRegistryDword(pDev, strDevNodeRM, "NoNT4AGP", &data32) != RM_OK)
                {
                    // Allow an override to set the AGP rate
                    if (osReadRegistryDword(pDev, strDevNodeRM, "ReqAGPRate", &data32) == RM_OK)
                        pDev->Chip.ReqAGPRate = data32;

                    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
                        RmInitAGP(pDev);
                }

            }
        }
    }
#endif

#if 0
    // Apply any AGP chipset workarounds or overrides
    NvUpdateAGPConfig(pDev);
#endif

    // flag RM to be initialized
    pOsHwInfo->rmInitialized = TRUE;

    // TO DO: add AGP support in NT 5.0

    return RM_OK;

} // end of initMapping()

// OS-specific initializations

RM_STATUS initFbEx
(
    PHWINFO pDev
)
{
    S032  fbCalcMemSize(VOID);
    U032 calc_max_bw (VOID);
    U032 size;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initFramebufferEx\n");
    //
    // Get screen resolution and framebuffer configuration from registry.
    //
    pDev->Dac.HalInfo.Depth = (osDisplayInfo.InfoFlags & REGISTRY_BPP_NOT_VALID) ? 8 : osDisplayInfo.Bpp;
    if ((osDisplayInfo.InfoFlags & (MONITOR_INFO_NOT_VALID | MONITOR_INFO_DISABLED_BY_USER))
     || (osDisplayInfo.RefreshRateMax == 0xFFFFFFFF)
     || (osDisplayInfo.RefreshRateMax == 0))
    {
        pDev->Framebuffer.HalInfo.RefreshRate   = 60;
        pDev->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
        pDev->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    }
    else
    {
        pDev->Framebuffer.HalInfo.RefreshRate   = osDisplayInfo.RefreshRateMax;
        pDev->Framebuffer.HSyncPolarity = osDisplayInfo.HorzSyncPolarity;
        pDev->Framebuffer.VSyncPolarity = osDisplayInfo.VertSyncPolarity;
    }

    pDev->Framebuffer.HalInfo.HorizDisplayWidth = osDisplayInfo.XRes;
    pDev->Framebuffer.HalInfo.VertDisplayWidth  = osDisplayInfo.YRes;
    pDev->Framebuffer.HorizFrontPorch = 0;
    pDev->Framebuffer.HorizSyncWidth  = 0;
    pDev->Framebuffer.HorizBackPorch  = 0;
    pDev->Framebuffer.VertFrontPorch  = 0;
    pDev->Framebuffer.VertSyncWidth   = 0;
    pDev->Framebuffer.VertBackPorch   = 0;
    pDev->Framebuffer.CSync           = BUFFER_CSYNC_DISABLED;
    pDev->Dac.HalInfo.VClk            = 0;
    //
    // Calculate the framebuffer count based on the configuration with double buffering.
    //
    size = pDev->Dac.HalInfo.Depth / 8
         * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth
         * 2;
    if (size > pDev->Framebuffer.HalInfo.RamSize)
        size = 0;
    else
        size = pDev->Framebuffer.HalInfo.RamSize - size;
    pDev->Framebuffer.Count = 1;

    return (RM_OK);
}
RM_STATUS initGrEx
(
    PHWINFO pDev
)
{
    return (RM_OK);
}
RM_STATUS initDacEx
(
    PHWINFO pDev
)
{
    return (RM_OK);
}
RM_STATUS initFifoEx
(
    PHWINFO pDev
)
{
    pDev->Fifo.HalInfo.RetryCount = 1;

    return (RM_OK);
}
RM_STATUS initRModeEx
(
    PHWINFO pDev
)
{
    return(RM_OK);
}

// end of osinit.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\AHal.cpp ===
extern "C" 
{
#include <nvarm.h>
#include <aos.h>
#include <nv32.h>
#include <AHal.h>
#include <AudioHw.h>
}
#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalMCP1.h"

RM_STATUS InitAudioHal(U008 uRevID, HWINFO_COMMON_FIELDS *pDev)
{
	switch(uRevID)
	{
	case REV_MCP1:
		pDev->pHalContext = (VOID *) new CHalMCP1(uRevID, pDev);
		break;

	default:
		pDev->pHalContext = NULL;
		break;
	}

	return (pDev->pHalContext)?RM_OK:RM_ERROR;
}

VOID DestroyAudioHal(HWINFO_COMMON_FIELDS *pDev)
{
	delete ((CHalBase *)pDev->pHalContext);
}

RM_STATUS AllocDevice(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->Allocate();
}

RM_STATUS FreeDevice(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->Free();
}

RM_STATUS DeviceAddClient(HWINFO_COMMON_FIELDS *pDev, VOID *pParam, U008 *pClientRef)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->AddClient(pParam, pClientRef);
}

RM_STATUS DeviceRemoveClient(HWINFO_COMMON_FIELDS *pDev, U008 uClientRef)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->DeleteClient(uClientRef);
}

RM_STATUS AllocObject(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	APU_OBJECT	*pObjAllocParams = (APU_OBJECT *)pParam;
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->AllocateObject(pObjAllocParams->uObjectCode, (VOID *)pObjAllocParams->pParam);
}

RM_STATUS FreeObject(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	APU_OBJECT	*pObjFreeParams = (APU_OBJECT *)pParam;
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->FreeObject(pObjFreeParams->uObjectCode, (VOID *)pObjFreeParams->pParam);
}

RM_STATUS AllocContextDma(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->AllocateContextDma(pParam);
}

RM_STATUS FreeContextDma(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->FreeContextDma(pParam);
}

RM_STATUS InterruptService(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->InterruptService();
}

// the following code is to make the driver compile in C++ 
void* _cdecl operator new(unsigned int n)
{
	void *p;
    aosAllocateMem((U032) n, ALIGN_DONT_CARE, &p, NULL);
    return p;
}

void _cdecl operator delete(void* p)
{
	if (p) 
		aosFreeMem(p);
}

extern "C" int _cdecl _purecall();

int _cdecl _purecall()
{
    // this better get printed!!
    aosDbgPrintString(DEBUGLEVEL_ERRORS + 5, "NVARM: _purecall - RUNTIME ERROR!  calling pure virtual function!!!\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CContextDma.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: CContextDma.cpp                                                   *
*   The MCPX HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nv32.h>
#include <nvarm.h>
#include <aos.h>
};

#include <ClinkList.h>
#include "CContextDma.h"


RM_STATUS
CContextDma::Initialize(VOID *pAddress, U032 uSize, U032 uType)
{
    RM_STATUS rmStatus = RM_ERROR;

    m_uType = uType;
    m_uSize = uSize;

    switch(m_uType)
    {
    case AUDIO_CONTEXT_DMA_SESGE:
    case AUDIO_CONTEXT_DMA_SESSL:
    case AUDIO_CONTEXT_DMA_GPSGE:
    case AUDIO_CONTEXT_DMA_EPSGE:
        {
            // make sure the stuff is properly aligned
            if (!PAGEOFF(pAddress))
            {
                if (!PAGEOFF(uSize))
                {
                    m_pAddress = pAddress;
                    rmStatus = RM_OK;
                }
            }
        }
        break;

    case AUDIO_CONTEXT_DMA_FENOTIFIER:
        {
            // convert the address to physical
            rmStatus = aosGetPhysicalAddress(pAddress, m_uSize, &m_pAddress);
            if (rmStatus == RM_OK)
            {
                // has to be 256 byte aligned..
                if (((U032)m_pAddress) & 0xFF)
                    rmStatus = RM_ERROR;        // alignment fails
            }
        }
        break;

    default:
        break;
    }

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CContextDma.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: CContextDma.h                                                   *
*   The MCPX HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CCONTEXTDMAH_
#define _CCONTEXTDMAH_

class CLinkList;

class CContextDma : public CLinkList
{
public:
    RM_STATUS Initialize(VOID *pAddress, U032 uSize, U032 uType);

    VOID *GetAddress() { return m_pAddress; }
    U032 GetSize()  { return m_uSize; }
    U032 GetType()  { return m_uType; }

private:
    VOID *m_pAddress;
    U032 m_uSize;
    U032 m_uType;       // type of the dma - this is prob redundant
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CEPMethod.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CEPMethod.cpp                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uep.h>
#include <nv_papu.h>
#include <nv32.h>
#include <AudioHw.h>
};
#include <aos.h>
#include <ahal.h>

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalMCP1.h"
#include "CHalExtendedProc.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CEPMethod.h"

RM_STATUS
CEPMethod::Execute(U032 uOffset, U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;

    do
    {
        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE))
        {
            rmStatus = SetCurrentSge(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA))
        {
            rmStatus = SetContextDMA(uData);
            break;
        }
        
        if (CheckRange(uOffset, NV1BAE_PIO_SET_STATE))
        {
            rmStatus = SetState(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET))
        {
            rmStatus = SetSgeOffset(uData);
            break;
        }
        
        U032 uCnt = 0;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if ( CheckRange(uOffset, (NV1BAE_PIO_SET_OUTBUF_BA(uCnt))) )
            {
                rmStatus = SetSgeBaseAddr(uData, uCnt);
                break;
            }
        }
        
        if (uCnt != 4)
            break;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if ( CheckRange(uOffset, (NV1BAE_PIO_SET_OUTBUF_LEN(uCnt))) )
            {
                rmStatus = SetSgeLength(uData, uCnt);
                break;
            }
        }

        if (uCnt != 4)
            break;

        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CEPMethod::Execute - SW method not yet implemented!\n");

#if defined WDM
        KdPrint(("Method offset = 0x%x Method Data = 0x%x\n", uOffset, uData));
#endif

    } while (FALSE);
    
    return rmStatus;
}

RM_STATUS
CEPMethod::SetCurrentSge(U032 uData)
{
    // HW indexes are not 0 based
    if (!uData)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetCurrentSge - SGE index cannot be 0\n");
        // bad argument
        return RM_ERROR;
    }
    
    m_uCurrSge = uData;

    return RM_OK;
}


RM_STATUS
CEPMethod::SetContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }
    
    m_uBaseAddr = (U032)pDma->GetAddress();
    m_uMaxOffset = (U032)pDma->GetSize();

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeOffset(U032 uData)
{
    if (!m_uMaxOffset)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetSgeOffset - context DMA is not valid\n");
        // context DMA not valid
        return RM_ERROR;
    }

    if (uData > m_uMaxOffset)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetSgeOffset - exceeds max offset\n");
        // bad argument
        return RM_ERROR;
    }

    
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pHal->GetExtendedProc()->GetSgeOutLinAddr());

    pPrd[m_uCurrSge-1].uAddr = m_uBaseAddr + uData;
    pPrd[m_uCurrSge-1].Control.uValue = 0;
    pPrd[m_uCurrSge-1].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeBaseAddr(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;
    
    GetBaseAndEnd(uIndex, &uOffBase, &uOffEnd);

    m_pHal->RegWrite(uOffBase, uData);
    m_pHal->RegWrite(uOffEnd, uData);

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeLength(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    GetBaseAndEnd(uIndex, &uOffBase, &uOffEnd);
    
    U032 uBaseAddr;
    m_pHal->RegRead(uOffBase, &uBaseAddr);

    m_pHal->RegWrite(uOffEnd, uBaseAddr + uData);
    
    return RM_OK;
}

RM_STATUS 
CEPMethod::SetState(U032 uData)
{
    // vik - todo
    return RM_ERROR;
}

// utility functions
VOID
CEPMethod::GetBaseAndEnd(U032 uIndex, U032 *pBase, U032 *pEnd)
{
    switch(uIndex)
    {
    case 0:
        *pBase = NV_PAPU_EPOFBASE0;
        *pEnd = NV_PAPU_EPOFEND0;
        break;
    case 1:
        *pBase = NV_PAPU_EPOFBASE1;
        *pEnd = NV_PAPU_EPOFEND1;
        break;
    case 2:
        *pBase = NV_PAPU_EPOFBASE2;
        *pEnd = NV_PAPU_EPOFEND2;
        break;
    case 3:
        *pBase = NV_PAPU_EPOFBASE3;
        *pEnd = NV_PAPU_EPOFEND3;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osvp.c ===
/******************************************************************************
*
*   Module: osvp.c
*
*   Description:
*       This module contains OS services provided to the RM kernel.  These
*	versions are implemented using the Video Port services.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <miniport.h>
#include <ntddvdeo.h>
#include <video.h>
#include <dderror.h>
#include <nvrm.h>
#include <os.h>
#include <nvos.h>

#define USE_CURRENT_CONTEXT -1

#ifdef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT >= 0x0500)

// video port service implementation

#if (_WIN32_WINNT >= 0x0500)

RM_STATUS osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
	VP_STATUS vpStatus = NO_ERROR;
    U008* pMem;
    VOID* hwDeviceExtension = (VOID*)1;

#ifndef DBG

    vpStatus = VideoPortAllocateBuffer
    (
        hwDeviceExtension,
        Size + 4,
        pAddress
    );
    if (vpStatus == NO_ERROR)
    {
        //pDev.Statistics.MemAlloced += Size;
        **(U032 **)pAddress           = Size;
        *(U032 *)pAddress            += 4;
    }
        
#else

    Size += 12;
    vpStatus = VideoPortAllocateBuffer
    (
        hwDeviceExtension,
        Size,
        pAddress
    );
    if (vpStatus == NO_ERROR)
    {
		// memory allocation tracking
		osLogMemAlloc(*pAddress, Size);

        //pDev.Statistics.MemAlloced           += Size - 12;
        **(U032 **)pAddress                     = Size;
        *(U032 *)(*(U032 *)pAddress + 4)        = NV_MARKER1;
        *(U032 *)(*(U032 *)pAddress + Size - 4) = NV_MARKER2;
        *(U032 *)pAddress += 8;
        pMem = (U008 *)*pAddress;
        Size -= 12;
        while (Size--)
            *pMem++ = 0x69;
    }
            
#endif // DBG

	return (vpStatus == NO_ERROR) ? RM_OK : RM_ERR_NO_FREE_MEM;
    
}

RM_STATUS osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status = RM_OK;
    U032      Size;
    VOID* hwDeviceExtension = (VOID*)1;
    
#ifndef DBG

    pAddress = (VOID *)((U032)pAddress - 4);
    Size     = *(U032 *)pAddress;
    
#else

    pAddress = (VOID *)((U032)pAddress - 8);
    Size     = *(U032 *)pAddress;
    if (*(U032 *)((U032)pAddress + 4) != NV_MARKER1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Invalid address to osFreeMem\n");
        DBG_BREAKPOINT();
    }
    if (*(U032 *)((U032)pAddress + Size - 4) != NV_MARKER2)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Memory overrun in structure to osFreeMem\n");
        DBG_BREAKPOINT();
        return (RM_ERR_MEM_NOT_FREED);
    }
    *(U032 *)((U032)pAddress + 4)        = 'DAED';
    *(U032 *)((U032)pAddress + Size - 4) = 'DEAD';
    Size -= 12;

	// memory allocation tracking
	osUnlogMemAlloc(pAddress);

#endif // DBG  
  
    VideoPortReleaseBuffer(
        hwDeviceExtension,
        pAddress
    );

    //pDev.Statistics.MemAlloced -= Size;

    return status;
    
}

#endif // Win2K

typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_LOCK_HELD               0x0200
#define MDL_SCATTER_GATHER_VA       0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000
#define MDL_64_BIT_VA               0x8000

RM_STATUS osLockUserMem
(
    PHWINFO             pDev,
    U032             	ChID,
    U032             	Selector,
    U032             	Offset,
    U032             	DmaAddress,
    NV_ADDRESS_SPACE*	DmaAddressSpace,
    U032             	DmaLength,
    U032             	PageCount,
    U032*				PageArray,
    U032*				pLinAddr,
    U032*				pLockHandle
)
{
	RM_STATUS rmStatus;
	PMDL pMdl = 0;
	ULONG i;
	STATUS_BLOCK vrpStatus;
	VIDEO_REQUEST_PACKET vrp;
	PULONG mdlPageArray;

    // map the buffer
    *pLinAddr = DmaAddress;

    //
    // If we're asking to lock video memory, let's just build up the PTE's and assume
    // that the caller has real control over video memory (such as DirectDraw or the
    // display driver).
    //
    if (*DmaAddressSpace == ADDR_FBMEM)
    {
        //
        // This is hardcoded assuming zero = start of fb
        //
        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (*pLinAddr + (i * RM_PAGE_SIZE)) | 3;
        }
    }
	else
	{
		// fill a VRP with the buffer information
		vrpStatus.Status = 0;    
		vrpStatus.Information = 0;    
		vrp.IoControlCode = 0;
		vrp.StatusBlock = &vrpStatus;    
		vrp.InputBuffer = (PVOID)DmaAddress;    
		vrp.InputBufferLength = DmaLength;
		vrp.OutputBuffer = NULL;    
		vrp.OutputBufferLength = 0;

    	// lock the buffer's pages
		if (
			VideoPortLockPages(
				pDev->DBmpDeviceExtension,
				&vrp,
				NULL,
				NULL,
				VideoPortDmaInitOnly
			)
		)
		{
	        // save the MDL pointer
		    *pLockHandle = (U032)vrp.OutputBuffer;

		    // load the PTE array with physical addresses of the page-aligned buffer
			pMdl = (PMDL)VideoPortGetMdl(
				pDev->DBmpDeviceExtension, 
				(PDMA)pLockHandle
			);
			if (pMdl != NULL)
			{
				// extract the physical address from the MDL into the PTE array
				mdlPageArray = (PULONG)(pMdl + 1);
		   	    for (i = 0; i < PageCount; i++)
			    {
				    PageArray[i] = mdlPageArray[i] | 3;
		        }
			}
			else 
			{
				VideoPortUnlockPages(pDev->DBmpDeviceExtension, (PDMA)pLockHandle);
				rmStatus = RM_ERROR;
			}
		}
		else 
		{
			rmStatus = RM_ERROR;
		}
    }

    return rmStatus;    
}

RM_STATUS osUnlockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    VOID*            LinAddr,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    U032             LockHandle,
    U032             DirtyFlag
)
{
	BOOLEAN status = TRUE;

    //
    // If we're asking to unlock video memory, we're assuming the caller (probably
    // direct draw)  has complete control of video memory, and therefore knows what
    // is locked/unlocked.  No need to do anything.
    //
    if (DmaAddressSpace != ADDR_FBMEM)
	{
		// otherwise, unmap locked pages, unlock pages, and free the MDL
		status = VideoPortUnlockPages(
			pDev->DBmpDeviceExtension,
			(PDMA)&LockHandle
		);
	}

    return (status) ? RM_OK : RM_ERROR;
}

//#endif // (_WIN32_WINNT >= 0x0500)
#endif // VIDEO_PORT_IMPLEMENTATION

RM_STATUS osMapPciMemoryUser( 
	PHWINFO pDev,
	U032 busAddress, 
	U032 length,
	VOID** pVirtualAddress
) 
{
	VP_STATUS vpStatus = NO_ERROR;
	U032 mapFlags;
	PHYSICAL_ADDRESS busPhysicalAddress; 

#if (_WIN32_WINNT >= 0x0500)
	mapFlags = VIDEO_MEMORY_SPACE_P6CACHE;
#else
	mapFlags = VIDEO_MEMORY_SPACE_USER_MODE;
#endif

	// construct an NT physical address from the requested bus-relative address
	busPhysicalAddress.HighPart = 0x00000000;
	busPhysicalAddress.LowPart = busAddress;

	// flag the video port to map into the current context
	*pVirtualAddress = (VOID*)USE_CURRENT_CONTEXT;

	// map the PCI memory into user mode
	vpStatus = VideoPortMapMemory(
		pDev->DBmpDeviceExtension,
		busPhysicalAddress,
		&length,
		&mapFlags,
		pVirtualAddress
	);
	
	return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;

}

RM_STATUS osUnmapPciMemoryUser(
	PHWINFO pDev,
	VOID* virtualAddress
)
{
	VP_STATUS vpStatus = NO_ERROR;

	VideoPortUnmapMemory(
		pDev->DBmpDeviceExtension,
		virtualAddress,
		(VOID*)USE_CURRENT_CONTEXT
	);

	return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;

}

#if defined(_WIN64)

#define	MAX_DMA_LENGTH   (2*1024*1024)

RM_STATUS osInitDmaAdapter
(
    PHWINFO pDev
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS rmStatus = RM_OK;
    VP_DEVICE_DESCRIPTION deviceDescription = {
        TRUE,          // ScatterGather;
        TRUE,          // Dma32BitAddresses
        FALSE,         // Dma64BitAddresses
        MAX_DMA_LENGTH // MaximumLength
    };

    pOsHwInfo->dmaAdapter = VideoPortGetDmaAdapter(pDev->DBmpDeviceExtension,
                                                   &deviceDescription);
    if(pOsHwInfo->dmaAdapter == NULL)
        return RM_ERROR;
    else
        return RM_OK;
}

RM_STATUS osAllocSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    PWINNTHWINFO     pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PSYS_MEM_INFO    pMemInfo;
    PHYSICAL_ADDRESS logicalAddr;
    RM_STATUS        rmStatus;
    VOID             *pageAddr, *userAddr;

    // Since there will be some cleanup needed on the free side
    // create a struct that hooks into VOID * in CLI_MEMORY_INFO

    rmStatus = osAllocMem((VOID **)&pMemInfo, sizeof(SYS_MEM_INFO));
    if (rmStatus != RM_OK)
        return rmStatus;

    pMemInfo->sysAddr = VideoPortAllocateCommonBuffer(pDev->DBmpDeviceExtension,
                                                      pOsHwInfo->dmaAdapter,
                                                      (pageCount + 1) << RM_PAGE_SHIFT,
                                                      &logicalAddr,
                                                      TRUE,
                                                      &pMemInfo->length);
    if (pMemInfo->sysAddr == NULL) {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }
    pMemInfo->logicalAddr = logicalAddr.QuadPart;
    pageAddr = (VOID *)(((NV_UINTPTR_T)pMemInfo->sysAddr + RM_PAGE_MASK) & ~RM_PAGE_MASK);
    pMemInfo->physAddr = (pMemInfo->logicalAddr + RM_PAGE_MASK) & ~RM_PAGE_MASK;

    if ((pMemInfo->clientClass = ClientClass) == NV01_ROOT_USER) {
        userAddr = osMapUserSpace(pageAddr, &pMemInfo->pMdl,
                                  pageCount << RM_PAGE_SHIFT, MAP_WRITECOMBINE);
        if (userAddr == NULL) {
            VideoPortReleaseCommonBuffer(pDev->DBmpDeviceExtension,
                                         pOsHwInfo->dmaAdapter,
                                         pMemInfo->length,
                                         logicalAddr,
                                         pMemInfo->sysAddr,
                                         TRUE);
            osFreeMem(pMemInfo);
            return RM_ERR_NO_FREE_MEM;
        } else {
           *pAddress = userAddr;
        }
    } else {
       *pAddress = pageAddr;
    }
    *pMemData = (VOID *)pMemInfo;
    return RM_OK;
}

RM_STATUS osFreeSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID *pMemData
)
{
    PWINNTHWINFO     pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PSYS_MEM_INFO    pMemInfo = (PSYS_MEM_INFO)pMemData;
    PHYSICAL_ADDRESS logicalAddr;

    // unmap the memory from user space, if necessary
    if (pMemInfo->clientClass == NV01_ROOT_USER) {
        osUnmapUserSpace(*pAddress, pMemInfo->pMdl);
    }

    // free the memory using the original pointer and actual allocated length
    logicalAddr.QuadPart = pMemInfo->logicalAddr;
    VideoPortReleaseCommonBuffer(pDev->DBmpDeviceExtension,
                                 pOsHwInfo->dmaAdapter, pMemInfo->length,
                                 logicalAddr, pMemInfo->sysAddr,
                                 TRUE);

    // free our data struct that kept track of this mapping
    osFreeMem(pMemInfo);

    return RM_OK;
}

#endif // _WIN64

VOID osWriteReg008(volatile U008* address, U008 data)
{
	VideoPortWriteRegisterUchar((PUCHAR)address, (UCHAR)data);
}

VOID osWriteReg016(volatile U016* address, U016 data)
{
	VideoPortWriteRegisterUshort((PUSHORT)address, (USHORT)data);
}

VOID osWriteReg032(volatile U032* address, U032 data)
{
	VideoPortWriteRegisterUlong((PULONG)address, (ULONG)data);
}

U008 osReadReg008(volatile U008* address)
{
	return VideoPortReadRegisterUchar((PUCHAR)address);
}

U016 osReadReg016(volatile U016* address)
{
	return VideoPortReadRegisterUshort((PUSHORT)address);
}

U032 osReadReg032(volatile U032* address)
{
	return VideoPortReadRegisterUlong((PULONG)address);
}

VP_STATUS osReadRegistryCallback
(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
)
{
    // return the extracted reg value
    *(U032*)Context = *(U032*)ValueData;
    
    return NO_ERROR;

} // end of osReadRegistryCallback()

VP_STATUS osReadRegistryBinaryCallback
(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
)
{
    ULONG i;

    // Grab the avil length from the contexts first element and make
    // sure that the value provided will fit in the buffer
    if (ValueLength > ((U032 *)Context)[0])
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Let the VP do the value copy
    VideoPortMoveMemory(Context,ValueData,ValueLength);

    return NO_ERROR;

} // end of osReadRegistryBinaryCallback()

RM_STATUS osReadRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 *cbLen
)
{
    RM_STATUS rmStatus = RM_OK;
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;
    // long word allign the following so we can stuff
    // a buffer length in the first element.  We need
    // to do this as the callback does not provide for
    // a buffer size to be passed in
    U032 localvaluebuffer[64];
 
    // Make sure that we have enough space for the callback data copy
    if (*cbLen > sizeof(localvaluebuffer))
    {
        return RM_ERROR;
    }

	 // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // Stuff the size in the first element
    localvaluebuffer[0] = *cbLen;

    // call the video port to get the parameter value -- calls back to osReadRegistryCallback()
    vpStatus = VideoPortGetRegistryParameters
    (
        pDev->DBmpDeviceExtension,
        parameterName,
        FALSE,
        osReadRegistryBinaryCallback,
        &localvaluebuffer
    );

    // If all is well, fetch the value data and copy it 
    if(vpStatus == NO_ERROR) {

      // Let the VP do the copy and set the size to
      // what the caller suggested
      VideoPortMoveMemory(Data,localvaluebuffer,*cbLen);
    }

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osWriteRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 cbLen
)
{
    VP_STATUS vpStatus;
	WCHAR parameterName[80];
    U032 i;

	 // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to set the parameter value
    vpStatus = VideoPortSetRegistryParameters(
                  pDev->DBmpDeviceExtension,
                  parameterName,
                  Data,
                  cbLen
                  );

	return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osWriteRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 Data
)
{
    VP_STATUS vpStatus;
	WCHAR parameterName[80];
    U032 i;

	 // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to set the parameter value
    vpStatus = VideoPortSetRegistryParameters(
                  pDev->DBmpDeviceExtension,
                  parameterName,
                  &Data,
                  sizeof(ULONG)
                  );

	return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osReadRegistryDword
(
    PHWINFO pDev,
    char* regDevNode,
    char* regParmStr,
    U032* pData
)
{
    RM_STATUS rmStatus = RM_OK;
    VP_STATUS vpStatus;
	WCHAR parameterName[80];
    U032 i;
    
	// convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to get the parameter value -- calls back to osReadRegistryCallback()
    vpStatus = VideoPortGetRegistryParameters
    (
        pDev->DBmpDeviceExtension,
        parameterName,
        FALSE,
        osReadRegistryCallback,
        pData
    );

	return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
} // end of osReadRegistryDword()

#if (_WIN32_WINNT >= 0x0500)

RM_STATUS osDelay
(
    U032 MilliSeconds
)
{
	VP_STATUS vpStatus = NO_ERROR;

	VideoPortStallExecution(MilliSeconds * 1000);
    
	return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
}

RM_STATUS osIsr
(
    PHWINFO pDev
)
{
	BOOL serviced = FALSE;
    
    if (RmInterruptPending(pDev, &serviced))
    {
        // queue up a DPC for a normal priority interrupt
	    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Queueing interrupt on DPC queue...\n");
        serviced |= VideoPortQueueDpc(pDev->DBmpDeviceExtension, RmDpcForIsr, pDev);
    }
    
    return (serviced) ? RM_OK : RM_ERROR;

} // end of osIsr()

VOID RmDpcForIsr
(
    PVOID HwDeviceExtension,
    PVOID Context
)
{
	PHWINFO pDev = (PHWINFO)Context;
    
	// service queued up interrupts and reenable interrupts
	//DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Servicing interrupt at DPC level...\n");
    mcService(pDev);
	RmEnableInterrupts(pDev);

} // end of RmDpcForIsr()

#endif // (_WIN32_WINNT >= 0x0500)

#ifdef WIN2K_DDK_THAT_CONTAINS_APIS

RM_STATUS osNotifyEvent
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Notifier,
    U032      Method,
    U032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, j;
    PEVENTNOTIFICATION NotifyEvent;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyEvent()\n");
	DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
	DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    // perform the type of action
    switch (Action)
    {
        case NV_OS_WRITE_THEN_AWAKEN:

            // walk this object's event list and find any matches for this specific notify
            for (NotifyEvent = Object->NotifyEvent; NotifyEvent; NotifyEvent = NotifyEvent->Next)
            {
                if (NotifyEvent->NotifyIndex == Notifier)
                {
                    // found a match -- notify the event
                    switch (NotifyEvent->NotifyType)
                    {
                        case NV01_EVENT_WIN32_EVENT:
                        {
                            // attempt to trigger the event
                		    if (!VideoPortSetEvent(pDev->DBmpDeviceExtension, (PEVENT)NotifyEvent->Data.low))
                		    {
                                // failed, so invalidate this event so we don't try again
                			    NotifyEvent->NotifyType = 0;
                		    }
                            break;
                        }

                        case NV01_EVENT_KERNEL_CALLBACK:
                        {
                            MINIPORT_CALLBACK callBackToMiniport = (MINIPORT_CALLBACK)(NotifyEvent->Data.low);

                            // perform a direct callback to the miniport
                            if (callBackToMiniport)
                                callBackToMiniport(pDev->DBmpDeviceExtension);
                            break;
                        }
                    
                        default:
                            break;    
                    }
                }
            }
            break;

        default:

            // any other actions are legacy channel-based notifies
            rmStatus = NVOS10_STATUS_ERROR_BAD_EVENT;
            break;
    }

    return rmStatus;

} // end of osNotifyEvent()

#endif // WIN2K_DDK_THAT_CONTAINS_APIS


// end of smp.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\smp.c ===
/******************************************************************************
*
*   Module: smp.c
*
*   Description:
*       This module contains SMP-safe versions of calls to functions that
*   contain critical code.
*
*       Each SMP-safe wrapper has the same name as the function it replaces
*   prepended with "smp".  Each requires a macro, to be included in those files
*   that call the "wrapped" functions, that replaces the call to the original
*   function with a call to the wrapper.  Currently, the header file that
*   contains these macros is called "smp.h".  The wrapper function packages
*   up the args into a single, custom arg struct, then calls
*   VideoPortSynchronizeExecution(), specifying a pointer to the arg struct
*   and a callback function.  The callback has the same name as the original
*   function prepended with "smpCallback".  The callback calls the original
*   function with the correct members of the arg struct.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <miniport.h>
#include <ntddvdeo.h>
#include <video.h>
#include <nvrm.h>
#include <os.h>

// external prototypes
RM_STATUS fifoUpdateObjectInstance(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
);
RM_STATUS fifoDeleteObjectInstance(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID
);
RM_STATUS fifoResetChannelState(
    PHWINFO pDev,
    U032 ChID
);
RM_STATUS fifoDeleteSubchannelContextEntry(
    PHWINFO pDev,
    POBJECT Object
);
RM_STATUS nvHalFbSetAllocParameters(
    PHWINFO pDev,
    PFBALLOCINFO pFbAllocInfo
);
RM_STATUS nvHalFbFree(
    PHWINFO pDev,
    U032 hwResId
);
VOID VBlankDeleteCallback(
    PHWINFO pDev,
    U032 Head,
    PVBLANKCALLBACK Callback
);
RM_STATUS classDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
);
// local prototypes
BOOLEAN smpCallbackFifoUpdateObjectInstance(PVOID object);
BOOLEAN smpCallbackFifoDeleteObjectInstance(PVOID object);
BOOLEAN smpCallbackFifoResetChannelState(PVOID object);
BOOLEAN smpCallbackFifoDeleteSubchannelContextEntry(PVOID object);
BOOLEAN smpCallbackMcService(PVOID object);
BOOLEAN smpCallbackNvHalFbSetAllocParameters(PVOID object);
BOOLEAN smpCallbackNvHalFbFree(PVOID object);
BOOLEAN smpCallbackVBlankDeleteCallback(PVOID object);
BOOLEAN smpCallbackClassDirectSoftwareMethod(PVOID object);

// arg strucs
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    ChID;
    U032    Instance;
} ARGS_FifoUpdateObjectInstance, *PARGS_FifoUpdateObjectInstance;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    ChID;
} ARGS_FifoDeleteObjectInstance, *PARGS_FifoDeleteObjectInstance;
typedef struct
{
    PHWINFO pDev;
    U032    ChID;
} ARGS_FifoResetChannelState, *PARGS_FifoResetChannelState;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
} ARGS_FifoDeleteSubchannelContextEntry, *PARGS_FifoDeleteSubchannelContextEntry;
typedef struct
{
    PHWINFO pDev;
} ARGS_McService, *PARGS_McService;
typedef struct
{
    PHWINFO pDev;
    PFBALLOCINFO pFbAllocInfo;
} ARGS_NvHalFbSetAllocParameters, *PARGS_NvHalFbSetAllocParameters;
typedef struct
{
    PHWINFO pDev;
    U032    hwResId;
} ARGS_NvHalFbFree, *PARGS_NvHalFbFree;
typedef struct
{
    PHWINFO pDev;
    U032 Head;
    PVBLANKCALLBACK Callback;
} ARGS_VBlankDeleteCallback, *PARGS_VBlankDeleteCallback;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    Offset;
    V032    Data;
} ARGS_ClassDirectSoftwareMethod, *PARGS_ClassDirectSoftwareMethod;

// critical code wrappers

// critical code wrapper for fifoUpdateObjectInstance()
RM_STATUS smpFifoUpdateObjectInstance
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
)
{
    BOOLEAN bStatus;
    ARGS_FifoUpdateObjectInstance args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.ChID = ChID;
    args.Instance = Instance;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoUpdateObjectInstance...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoUpdateObjectInstance,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoUpdateObjectInstance unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoUpdateObjectInstance()

RM_STATUS smpFifoDeleteObjectInstance
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID
)
{
    BOOLEAN bStatus;
    ARGS_FifoDeleteObjectInstance args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.ChID = ChID;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoDeleteObjectInstance...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoDeleteObjectInstance,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoDeleteObjectInstance unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoDeleteObjectInstance()

// critical code wrapper for fifoResetChannelState()
RM_STATUS smpFifoResetChannelState
(
    PHWINFO pDev,
    U032    ChID
)
{
    BOOLEAN bStatus;
    ARGS_FifoResetChannelState args;

    // load the arg struct
    args.pDev = pDev;
    args.ChID = ChID;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoResetChannelState...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoResetChannelState,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoResetChannelState unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoResetChannelState()

// critical code wrapper for fifoDeleteSubchannelContextEntry()
RM_STATUS smpFifoDeleteSubchannelContextEntry
(
    PHWINFO pDev,
    POBJECT Object
)
{
    BOOLEAN bStatus;
    ARGS_FifoDeleteSubchannelContextEntry args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoDeleteSubchannelContextEntry...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoDeleteSubchannelContextEntry,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoDeleteSubchannelContextEntry unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoDeleteSubchannelContextEntry()

// critical code wrapper for nvHalFbSetAllocParameters()
RM_STATUS smpNvHalFbSetAllocParameters
(
    PHWINFO pDev,
    PFBALLOCINFO pFbAllocInfo
)
{
    RM_STATUS rmStatus;
    BOOLEAN bStatus;    
    ARGS_NvHalFbSetAllocParameters args;

    //
    // This wrapper only deploys if we have hardware resources
    // associated with the specified block of local memory.
    //
    if (pFbAllocInfo->hwResId)
    {
        // load the arg struct
        args.pDev = pDev;
        args.pFbAllocInfo = pFbAllocInfo;

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvHalFbSetAllocParameters...\n");

        bStatus = VideoPortSynchronizeExecution(
            pDev->DBmpDeviceExtension,
            VpMediumPriority,
            smpCallbackNvHalFbSetAllocParameters,
            (PVOID)&args
            );

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvHalFbSetAllocParameters unsynchronized\n");

        rmStatus = (bStatus) ? RM_OK : RM_ERROR;
    }
    else
    {
        //
        // No MP issues in this case...
        //
        rmStatus = nvHalFbSetAllocParameters(pDev, pFbAllocInfo);
    }

    return (rmStatus);

} // end of smpNvHalFbSetAllocParameters()

// critical code wrapper for nvHalFbFree()
RM_STATUS smpNvHalFbFree
(
    PHWINFO pDev,
    U032 hwResId
)
{
    RM_STATUS rmStatus;
    BOOLEAN bStatus;    
    ARGS_NvHalFbFree args;

    //
    // This wrapper only deploys if we have hardware resources
    // associated with the specified block of local memory.
    //
    if (hwResId)
    {
        // load the arg struct
        args.pDev = pDev;
        args.hwResId = hwResId;

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvHalFbFree...\n");

        bStatus = VideoPortSynchronizeExecution(
            pDev->DBmpDeviceExtension,
            VpMediumPriority,
            smpCallbackNvHalFbFree,
            (PVOID)&args
            );

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvHalFbFree unsynchronized\n");
        rmStatus = (bStatus) ? RM_OK : RM_ERROR;
    }
    else
    {
        //
        // No MP issues in this case...
        //
        rmStatus = nvHalFbFree(pDev, hwResId);
    }

    return (rmStatus);

} // end of smpNvHalFbFree()

// critical code wrapper for VBlankDeleteCallback()
RM_STATUS smpVBlankDeleteCallback
(
    PHWINFO pDev,
    U032 Head,
    PVBLANKCALLBACK Callback
)
{
    BOOLEAN bStatus;    
    ARGS_VBlankDeleteCallback args;

    // load the arg struct
    args.pDev = pDev;
    args.Head = Head;
    args.Callback = Callback;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpVBlankDeleteCallback...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackVBlankDeleteCallback,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpVBlankDeleteCallback unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpVBlankDeleteCallback()

// critical code wrapper for ClassDirectSoftwareMethod()
RM_STATUS smpClassDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032 Offset,
    U032 Data
)
{
    BOOLEAN bStatus;    
    ARGS_ClassDirectSoftwareMethod args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.Offset = Offset;
    args.Data = Data;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpClassDirectSoftwareMethod...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackClassDirectSoftwareMethod,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpClassDirectSoftwareMethod unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpClassDirectSoftwareMethod()

// critical code callbacks

// critical code callback for fifoUpdateObjectInstance()
BOOLEAN smpCallbackFifoUpdateObjectInstance(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoUpdateObjectInstance pArgs = (PARGS_FifoUpdateObjectInstance)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoUpdateObjectInstance...\n");

    rmStatus = fifoUpdateObjectInstance(
        pArgs->pDev,
        pArgs->Object,
        pArgs->ChID,
        pArgs->Instance
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoUpdateObjectInstance\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;
    
} // end of smpCallbackFifoUpdateObjectInstance()

BOOLEAN smpCallbackFifoDeleteObjectInstance(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoDeleteObjectInstance pArgs = (PARGS_FifoDeleteObjectInstance)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoDeleteObjectInstance...\n");

    rmStatus = fifoDeleteObjectInstance(
        pArgs->pDev,
        pArgs->Object,
        pArgs->ChID
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoDeleteObjectInstance\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;
    
} // end of smpCallbackFifoDeleteObjectInstance()

BOOLEAN smpCallbackFifoResetChannelState(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoResetChannelState pArgs = (PARGS_FifoResetChannelState)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoResetChannelState...\n");

    rmStatus = fifoResetChannelState(
        pArgs->pDev,
        pArgs->ChID
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoResetChannelState\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFifoResetChannelState()

BOOLEAN smpCallbackFifoDeleteSubchannelContextEntry(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoDeleteSubchannelContextEntry pArgs = (PARGS_FifoDeleteSubchannelContextEntry)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoDeleteSubchannelContextEntry...\n");

    rmStatus = fifoDeleteSubchannelContextEntry(
        pArgs->pDev,
        pArgs->Object
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoDeleteSubchannelContextEntry\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFifoDeleteSubchannelContextEntry()

BOOLEAN smpCallbackNvHalFbSetAllocParameters(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_NvHalFbSetAllocParameters pArgs = (PARGS_NvHalFbSetAllocParameters)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvHalFbSetAllocParameters...\n");

    rmStatus = nvHalFbSetAllocParameters(pArgs->pDev, pArgs->pFbAllocInfo);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvHalFbSetAllocParameters\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackNvHalFbSetAllocParameters

BOOLEAN smpCallbackNvHalFbFree(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_NvHalFbFree pArgs = (PARGS_NvHalFbFree)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvHalFbFree...\n");

    rmStatus = nvHalFbFree(pArgs->pDev, pArgs->hwResId);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvHalFbFree\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackNvHalFbFree

BOOLEAN smpCallbackVBlankDeleteCallback(PVOID pvArgs)
{
    PARGS_VBlankDeleteCallback pArgs = (PARGS_VBlankDeleteCallback)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized VBlankDeleteCallback...\n");

    VBlankDeleteCallback(pArgs->pDev, pArgs->Head, pArgs->Callback);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized VBlankDeleteCallback\n");

    return RM_OK;

} // end of smpCallbackVBlankDeleteCallback

BOOLEAN smpCallbackClassDirectSoftwareMethod(PVOID pvArgs)
{
    PARGS_ClassDirectSoftwareMethod pArgs = (PARGS_ClassDirectSoftwareMethod)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized classDirectSoftwareMethod...\n");

    rmStatus = classDirectSoftwareMethod(pArgs->pDev, pArgs->Object, pArgs->Offset, pArgs->Data);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized classDirectSoftwareMethod\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackClassDirectSoftwareMethod

// end of smp.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CEPMethod.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CEPMethod.h                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CEPMETHODH_
#define _CEPMETHODH_

#define METHOD_MIN_OFFSET(x)       (x)
#define METHOD_MAX_OFFSET(x)       ((x) + 0x4)

class CHalMCP1;

class CEPMethod
{
public:
    CEPMethod(CHalMCP1 *pHal) 
    { 
        m_pHal = pHal;
        m_uCurrSge = 0;
        m_uBaseAddr = 0;
        m_uMaxOffset = 0;
    }

    ~CEPMethod() { };

public:
    RM_STATUS Execute(U032 uOffset, U032 uData);

private:
    CHalMCP1    *m_pHal;

    // SW methods
    RM_STATUS SetCurrentSge(U032 uData);
    RM_STATUS SetSgeBaseAddr(U032, U032);
    RM_STATUS SetSgeLength(U032, U032);
    RM_STATUS SetContextDMA(U032);
    RM_STATUS SetSgeOffset(U032);
    RM_STATUS SetState(U032);

    // utility
    VOID GetBaseAndEnd(U032 uIndex, U032 *pBase, U032 *pEnd);
    BOOL CheckRange(U032 uOffset, U032 uMethodOffset)   
    { 
        return ((uOffset >= METHOD_MIN_OFFSET(uMethodOffset)) && 
                (uOffset < METHOD_MAX_OFFSET(uMethodOffset))?TRUE:FALSE);
    }

    // variables equiv of some GP regs
    U032    m_uCurrSge;
    U032    m_uBaseAddr;
    U032    m_uMaxOffset;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalBase.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALBASEH_
#define _CHALBASEH_

class CHalBase
{
public:
    CHalBase::CHalBase(U008 uRevID, HWINFO_COMMON_FIELDS *pDev);
    virtual CHalBase::~CHalBase();

	virtual RM_STATUS Allocate() = 0;
	virtual RM_STATUS Free() = 0;

    virtual RM_STATUS AddClient(VOID *pParam, U008 *pClientRef) = 0;
    virtual RM_STATUS DeleteClient(U008 uClientRef) = 0;

    // context dma
    virtual RM_STATUS AllocateContextDma(VOID *pParam) { return ErrorFn(); }
    virtual RM_STATUS FreeContextDma(VOID *pParam) { return ErrorFn(); }
    
    virtual RM_STATUS AllocateObject(U032 uObjectType, VOID *pParam) { return ErrorFn(); }
    virtual RM_STATUS FreeObject(U032 uObjectType, VOID *pParam) { return ErrorFn(); }

	// the ISR function called at interrupt time
	virtual RM_STATUS InterruptService() = 0;


	virtual VOID RegWrite(U032 uOffset, U032 uValue) { *(U032*)(m_uBase + uOffset) = uValue; }
	virtual VOID RegWrite(U032 uOffset, U016 uValue) { *(U016*)(m_uBase + uOffset) = uValue; }
	virtual VOID RegWrite(U032 uOffset, U008 uValue) { *(U008*)(m_uBase + uOffset) = uValue; }
	
	virtual VOID RegRead(U032 uOffset, U032 *pValue) { *pValue = *(U032*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, U016 *pValue) { *pValue = *(U016*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, U008 *pValue) { *pValue = *(U008*)(m_uBase + uOffset); }

	virtual VOID RegRead(U032 uOffset, volatile U032 *pValue) { *pValue = *(U032*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, volatile U016 *pValue) { *pValue = *(U016*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, volatile U008 *pValue) { *pValue = *(U008*)(m_uBase + uOffset); }
    

    virtual VOID MemWrite(U032 uAddr, U008 uData)    { 	*((U008 *)uAddr) = uData;   }
    virtual VOID MemWrite(U032 uAddr, U016 uData)    { 	*((U016 *)uAddr) = uData;   }
    virtual VOID MemWrite(U032 uAddr, U032 uData)    { 	*((U032 *)uAddr) = uData;   }

	U008                    GetRevID()	{ return m_uRevID; }
	HWINFO_COMMON_FIELDS *  GetpDev()   { return m_pDev; }
    U032                    GetDevBase() { return m_uBase; }

protected:
    VOID DumpChipToFile();

private:

    RM_STATUS   ErrorFn()
    {
        // the called function HAS to be
        // either defined in the dervied class,
        // or the call is on the wrong object
#if defined DEBUG
        aosDbgBreakPoint();
#endif
        return RM_ERROR;
    }


	U008 m_uRevID;
	U032 m_uBase;
	HWINFO_COMMON_FIELDS *m_pDev;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalBase.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include <aos.h>
#include "CHalBase.h"

CHalBase::CHalBase(U008 uRevID, HWINFO_COMMON_FIELDS *pDev) 
{ 
	m_uRevID = uRevID; 
	m_pDev = pDev;
	m_uBase = m_pDev->pDeviceBase;

#if defined VIKDBG
    // allocate some memory that will be the device PCI space
    if (RM_OK != aosAllocateMem(1?NV_PAPU, ALIGN_DONT_CARE, (VOID **)&m_uBase, NULL) )
    {
        // well.. too bad .. i tried
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalBase::CHalBase - no memory for the chip");
        return;
    }

    // zero the memory
    for (U032 uCnt = 0; uCnt < (1?NV_PAPU)/4; uCnt++)
        RegWrite(uCnt*4, (U032)0);
#endif
}

CHalBase::~CHalBase() 
{
    m_uRevID = 0; 

#if defined VIKDBG
    DumpChipToFile();
    aosFreeMem((VOID *)m_uBase);
#endif
}

VOID
CHalBase::DumpChipToFile()
{
    VOID *pHandle = aosCreateDiskFile();
    if (pHandle)
    {
        aosWriteDiskFile(pHandle, (VOID *)m_uBase, 1?NV_PAPU);
        aosCloseDiskFile(pHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalGlobalProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************GP class for the HAL******************************\
*                                                                           *
* Module: CHalGlobalProc.cpp                                                *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <aos.h>
#include <nv32.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalGlobalProc.h"

CHalGlobalProc::CHalGlobalProc(CHalBase *pHal) : CObjBase(pHal)
{
    m_CommandQ.Size = 4096;
}

RM_STATUS
CHalGlobalProc::Allocate(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_OK;
    
    do
    {
        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

        InitializeHardware();

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalGlobalProc::Free(VOID *pParam)
{
    FreeMemory();
    return RM_OK;
}

RM_STATUS
CHalGlobalProc::GetCaps(APU_AP_CREATE *pArg)
{
    VOLU32 vTemp;

    // output from GP
    if (pArg->uSGEOutCount)
    {
	    vTemp = pArg->uSGEOutCount - 1;
	    RegWrite(NV_PAPU_FEMAXGPSGE, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXGPSGE, &vTemp);
	    pArg->uSGEOutCount = vTemp + 1;
    }
    
    if (pArg->uGPScratch)
    {
	    vTemp = pArg->uGPScratch - 1;
	    RegWrite(NV_PAPU_GPSMAXSGE, LOW16(vTemp));
	    RegRead(NV_PAPU_GPSMAXSGE, &vTemp);
	    pArg->uGPScratch = vTemp + 1;
    }

    return RM_OK;
}

RM_STATUS
CHalGlobalProc::AllocateMemory(APU_AP_CREATE *pArg)
{
    m_SgeOut.Size = pArg->uSGEOutCount * NV_PSGE_SIZE;
    m_Scratch.Size = pArg->uGPScratch * NV_PSGE_SIZE;

	RM_STATUS rmStatus =  aosAllocateMem(m_SgeOut.Size,
						                ALIGN_16K,
						                &m_SgeOut.pLinAddr,
						                &m_SgeOut.pPhysAddr);

    if (rmStatus == RM_OK)
    {
        // allocate memory for the command Q
        rmStatus =  aosAllocateMem(m_CommandQ.Size,
						        ALIGN_16K,
						        &m_CommandQ.pLinAddr,
						        &m_CommandQ.pPhysAddr);
    }
    
    // allocate memory for 1PRD to point to the 4K command Q

    if (rmStatus == RM_OK)
    {
        // allocate memory scratch area
        rmStatus =  aosAllocateMem(m_Scratch.Size,
						        ALIGN_16K,
						        &m_Scratch.pLinAddr,
						        &m_Scratch.pPhysAddr);
    }

    return rmStatus;
}

VOID
CHalGlobalProc::FreeMemory()
{
	aosFreeMem(m_SgeOut.pLinAddr);
	aosFreeMem(m_CommandQ.pLinAddr);
	aosFreeMem(m_Scratch.pLinAddr);
}

VOID
CHalGlobalProc::InitializeHardware()
{
    // clear any pending interrupts! - todo cleanup
    RegWrite(NV_PAPU_GPISTS, (U032)0xFFFFFFFF);
    
    /*
    // set up the Q ptrs .. JLT
    RegWrite(NV_PAPU_GPOFBASE0, (U032)0);
    RegWrite(NV_PAPU_GPOFEND0, m_SgeOut.Size);
    RegWrite(NV_PAPU_GPOFCUR0, (U032)0);

    RegWrite(NV_PAPU_GPOFBASE1, (U032)0);
    RegWrite(NV_PAPU_GPOFEND1, m_SgeOut.Size);
    RegWrite(NV_PAPU_GPOFCUR1, (U032)0);

    RegWrite(NV_PAPU_GPOFBASE2, (U032)0);
    RegWrite(NV_PAPU_GPOFEND2, m_SgeOut.Size);
    RegWrite(NV_PAPU_GPOFCUR2, (U032)0);

    RegWrite(NV_PAPU_GPOFBASE3, (U032)0);
    RegWrite(NV_PAPU_GPOFEND3, m_SgeOut.Size);
    RegWrite(NV_PAPU_GPOFCUR3, (U032)0);
    */

    // output buffer PRDs
    RegWrite(NV_PAPU_GPFADDR, (U032)m_SgeOut.pPhysAddr);

    // scratch area for the GP
    RegWrite(NV_PAPU_GPSADDR, (U032)m_Scratch.pPhysAddr);

    // PRDs for the FIFO
    RegWrite(NV_PAPU_GPCADDR, (U032)m_CommandQ.pPhysAddr);
}

VOID
CHalGlobalProc::WriteCommand(DSP_CONTROL *pDspWord, WORD4 *pW4, WORD5 *pW5, WORD6 *pW6)
{
    RegWrite(NV_PAPU_GPXMEM(0), pDspWord->w0.uValue);
    RegWrite(NV_PAPU_GPXMEM(1), pDspWord->w1.uValue);
    RegWrite(NV_PAPU_GPXMEM(2), pDspWord->w2.uValue);
    RegWrite(NV_PAPU_GPXMEM(3), pDspWord->w3.uValue);
    
    if (pW4)
        RegWrite(NV_PAPU_GPXMEM(4), pW4->uValue);

    if (pW5)
        RegWrite(NV_PAPU_GPXMEM(5), pW5->uValue);

    if (pW6)
        RegWrite(NV_PAPU_GPXMEM(6), pW6->uValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalGlobalProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalGlobalProc.h                                                   *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALGLOBALPROCH_
#define _CHALGLOBALPROCH_

class CHalBase;
class CObjBase;

class CHalGlobalProc : public CObjBase
{
public:
    CHalGlobalProc(CHalBase *pHal);
	~CHalGlobalProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);

    void    *GetSgeOutLinAddr() { return m_SgeOut.pLinAddr; }
    VOID    WriteCommand(DSP_CONTROL *, WORD4 * = NULL, WORD5 * = NULL, WORD6 * = NULL);

private:
    RM_STATUS AllocateMemory(APU_AP_CREATE *);
    VOID FreeMemory();

    RM_STATUS GetCaps(APU_AP_CREATE *);
    VOID InitializeHardware();

    MEM_DESC    m_SgeOut;
    MEM_DESC    m_CommandQ;
    MEM_DESC    m_Scratch;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalExtendedProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************GP class for the HAL******************************\
*                                                                           *
* Module: CHalExtendedProc.cpp                                                *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <nv32.h>
#include <aos.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalExtendedProc.h"

CHalExtendedProc::CHalExtendedProc(CHalBase *pHal) : CObjBase(pHal)
{
    // keep the internal count ahead of the external count by this much
    m_CommandQ.Size = 4096;
}

RM_STATUS
CHalExtendedProc::Allocate(VOID *pParam)
{
	APU_EP_CREATE *pArg = (APU_EP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_OK;
    
    do
    {
        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

        InitializeHardware();

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalExtendedProc::Free(VOID *pParam)
{
    FreeMemory();
    return RM_OK;
}

RM_STATUS
CHalExtendedProc::GetCaps(APU_EP_CREATE *pArg)
{
    // have no idea what regs to check against

    return RM_OK;
}

RM_STATUS
CHalExtendedProc::AllocateMemory(APU_EP_CREATE *pArg)
{
    // what about notifier memory for both EP & GP ???
    // vik - todo
    m_SgeOut.Size = pArg->uSGEOutCount * NV_PSGE_SIZE;
    m_Scratch.Size = pArg->uScratch * NV_PSGE_SIZE;

	RM_STATUS rmStatus =  aosAllocateMem(m_SgeOut.Size,
						                ALIGN_16K,
						                &m_SgeOut.pLinAddr,
						                &m_SgeOut.pPhysAddr);

    if (rmStatus == RM_OK)
    {
        // allocate memory for the command Q
        rmStatus =  aosAllocateMem(m_CommandQ.Size,
						        ALIGN_16K,
						        &m_CommandQ.pLinAddr,
						        &m_CommandQ.pPhysAddr);
    }
    
    // allocate memory for 1PRD to point to the 4K command Q

    if (rmStatus == RM_OK)
    {
        // allocate memory scratch area
        rmStatus =  aosAllocateMem(m_Scratch.Size,
						        ALIGN_16K,
						        &m_Scratch.pLinAddr,
						        &m_Scratch.pPhysAddr);
    }

    return rmStatus;
}

VOID
CHalExtendedProc::FreeMemory()
{
	aosFreeMem(m_SgeOut.pLinAddr);
	aosFreeMem(m_CommandQ.pLinAddr);
	aosFreeMem(m_Scratch.pLinAddr);
}

VOID
CHalExtendedProc::InitializeHardware()
{
    // clear any pending interrupts! - todo cleanup
    RegWrite(NV_PAPU_EPISTS, (U032)0xFFFFFFFF);
    
    // output buffer PRDs
    RegWrite(NV_PAPU_EPFADDR, (U032)m_SgeOut.pPhysAddr);

    // scratch area for the eP
    RegWrite(NV_PAPU_EPSADDR, (U032)m_Scratch.pPhysAddr);

    // PRDs for the FIFO
    RegWrite(NV_PAPU_EPCADDR, (U032)m_CommandQ.pPhysAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalExtendedProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalExtendedProc.h                                                   *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALEXTENDEDPROCH_
#define _CHALEXTENDEDPROCH_

class CHalBase;
class CObjBase;

class CHalExtendedProc : public CObjBase
{
public:
    CHalExtendedProc(CHalBase *pHal);
	~CHalExtendedProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);

    void    *GetSgeOutLinAddr() { return m_SgeOut.pLinAddr; }

private:
    RM_STATUS AllocateMemory(APU_EP_CREATE *);
    void FreeMemory();

    RM_STATUS GetCaps(APU_EP_CREATE *);
    void InitializeHardware();

    MEM_DESC    m_SgeOut;
    MEM_DESC    m_CommandQ;
    MEM_DESC    m_Scratch;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalMCP1.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALMCP1H_
#define _CHALMCP1H_

class CHalVoiceProc;
class CHalGlobalProc;
class CHalExtendedProc;
class CContextDma;
class CMCP1Method;
class CEPMethod;

#define MAX_CLIENTS		        8

class CHalMCP1 : public CHalBase
{
public:
	CHalMCP1(U008, HWINFO_COMMON_FIELDS *);
	~CHalMCP1();

public:
	RM_STATUS Allocate();
	RM_STATUS Free();

    RM_STATUS AddClient(VOID *pParam, U008 *pClientRef);
    RM_STATUS DeleteClient(U008 uClientRef);

    RM_STATUS AllocateContextDma(VOID *pParam);
    RM_STATUS FreeContextDma(VOID *pParam);

    RM_STATUS AllocateObject(U032 uObjectType, VOID *pParam);
    RM_STATUS FreeObject(U032 uObjectType, VOID *pParam);

	RM_STATUS InterruptService();
    
    enum E_STATE
    {
        ISO = 0,
        NON_ISO,
        // mode states
        FREE_RUN,
        // SE modes
        OFF,
        AC_SYNC,
        SW,
        // interrupts enables for SE
        INT_PANIC,
        INT_RETRIGGER,
        INT_WARN,
        // FE modes
        HALT,
        // FE controls
        LOCK,
        UNLOCK
    };

    enum INTERRUPT_STATE
    {
        ENABLE,
        DISABLE
    };

    VOID SetFrontEnd(E_STATE);
    VOID SetSetupEngine(E_STATE);
   	VOID SetInterrupts(INTERRUPT_STATE);


    CHalVoiceProc   *GetVoiceProc()     { return m_pVoiceProc; }
    CHalGlobalProc  *GetGlobalProc()    { return m_pGlobalProc; }
    CHalExtendedProc *GetExtendedProc() { return m_pExtendedProc; }

protected:
	// public objects
	CHalVoiceProc	    *m_pVoiceProc;
    CHalGlobalProc      *m_pGlobalProc;
    CHalExtendedProc    *m_pExtendedProc;

private:
	VOID OnIntrFETrap();
	BOOL GetUserMethodInfo(U032 *pMethod, U032 *pData);
	VOID WriteError(U032 uIsCurrentVoice, U008	uErrorCode);

    VOID SetSetupEngineGlobalCounts(U032 uExt, U032 uInt, U032 uDelta);
    VOID SetSetupEngineExtendedCounts(U032 uInt, U032 uDelta, U032 uStep);

    VOID CallbackClients(U032 uIntrMask);
    RM_STATUS StoreClientInfo(VOID *pFn, U032 uMask, U032 uContext);

	R_INTR	m_rInterruptMask;

    CContextDma *m_pCDma;
    CMCP1Method *m_pApMethod;
    CEPMethod   *m_pEpMethod;
    
    PNV1BA0NOTIFICATION *m_pNotify;

    MCP1_CLIENT_INFO m_ClientInfo[MAX_CLIENTS];

    MEM_DESC m_MagicWrite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalMCP1.cpp ===
// cHalMCPI.cpp

extern "C"
{
#include <nv32.h>
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include <aos.h>
// ahal should not need to be included...
// todo - have to work on the client info stuff
#include "AHal.h"

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalExtendedProc.h"
#include "CHalGlobalProc.h"
#include "CHalMCP1.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CMCP1Method.h"
#include "CEPMethod.h"

// constructor
CHalMCP1::CHalMCP1(U008 uRevID, HWINFO_COMMON_FIELDS *pDev) : CHalBase(uRevID, pDev) 
{ 
    m_pVoiceProc = NULL;
    m_pCDma = NULL;
    m_pApMethod = NULL;
    m_pGlobalProc = NULL;
    m_pExtendedProc = NULL;
    m_pNotify = NULL;
    m_pEpMethod = NULL;
    m_MagicWrite.pLinAddr = NULL;

    // init the client callback info
    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
        m_ClientInfo[uCnt].pFn = NULL;
}

CHalMCP1::~CHalMCP1()
{
    if (m_pApMethod)
        delete m_pApMethod;
    
    if (m_pEpMethod)
        delete m_pEpMethod;

    if (m_pVoiceProc)   
        delete m_pVoiceProc;
    
    if (m_pGlobalProc)
        delete m_pGlobalProc;

    if (m_pExtendedProc)
        delete m_pExtendedProc;

    if (m_pCDma)
    {
        // clean the list - todo
    }

    m_pVoiceProc = NULL;
    m_pCDma = NULL;
    m_pApMethod = NULL;
    m_pGlobalProc = NULL;
    m_pExtendedProc = NULL;
    m_pEpMethod = NULL;
}

RM_STATUS 
CHalMCP1::InterruptService()
{
    RM_STATUS rmStatus = RM_OK;
    
    R_INTR rInterruptStatus;
    U032 uServiced = 1;
    
    INTR_MASK ClientMask;
    ClientMask.uValue = 0;
    
    // read from hardware what interrupt is pending
    RegRead(NV_PAPU_ISTS, &rInterruptStatus.uValue);
    
    // take action depending on what is triggered
    if (NV_PAPU_ISTS_GINTSTS_INTR == rInterruptStatus.General)
    {
        // prepare the magic write stuff
        aosZeroMemory(m_MagicWrite.pLinAddr, m_MagicWrite.Size);

        SetFrontEnd(E_STATE::LOCK);
        RegWrite(NV_PAPU_FEMEMADDR, (U032)m_MagicWrite.pPhysAddr);
        RegWrite(NV_PAPU_FEMEMDATA, (U032) 0x1);

        // find out if it's a valid interrupt
        // check for individial interrupt bits
        // can multiple bits be set?? vik
        
        if (NV_PAPU_ISTS_DWINTSTS_INTR == rInterruptStatus.DeltaWarning)
        {
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::InterruptService - Delta Warning interrupt triggered!\n");
            rInterruptStatus.DeltaWarning = NV_PAPU_ISTS_DWINTSTS_CLR;
            ClientMask.apu.DeltaWarning = 1;
        }

        if (NV_PAPU_ISTS_RTWSTS_INTR == rInterruptStatus.RetriggerEvent)
        {
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::InterruptService - Retriggerd Delta Warning interrupt (??)\n");
            // read only value.. need not be cleared
            // rInterruptStatus.RetriggerEvent = NV_PAPU_ISTS_RTWSTS_CLR; 
        }

        if (NV_PAPU_ISTS_DPINTSTS_INTR == rInterruptStatus.DeltaPanic)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::InterruptService - Delta Panic (internal and external GSCNT is same!\n");
            rInterruptStatus.DeltaPanic = NV_PAPU_ISTS_DPINTSTS_CLR;
            ClientMask.apu.DeltaPanic = 1;
        }

        if (NV_PAPU_ISTS_FETINTSTS_INTR == rInterruptStatus.FETrap)
        {
            rInterruptStatus.FETrap = NV_PAPU_ISTS_FETINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_FENINTSTS_INTR == rInterruptStatus.FENotify)
        {
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::InterruptService - Notifier was written\n");
            rInterruptStatus.FENotify = NV_PAPU_ISTS_FENINTSTS_CLR;
            ClientMask.apu.FENotify = 1;
        }

        if (NV_PAPU_ISTS_FEVINTSTS_INTR == rInterruptStatus.FEVoice)
        {
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::InterruptService - End of voice received\n");
            rInterruptStatus.FEVoice = NV_PAPU_ISTS_FEVINTSTS_CLR;
            ClientMask.apu.FEVoice = 1;
        }

        if (NV_PAPU_ISTS_FEOINTSTS_INTR == rInterruptStatus.FEMethodOverFlow)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::InterruptService - User method fifo overflow.. some methods/data will be discarded\n");
            rInterruptStatus.FEMethodOverFlow = NV_PAPU_ISTS_FEOINTSTS_CLR;
            ClientMask.apu.FEMethodOverFlow = 1;
        }

        if (NV_PAPU_ISTS_GPMINTSTS_INTR == rInterruptStatus.GPMailbox)
        {
            rInterruptStatus.GPMailbox = NV_PAPU_ISTS_GPMINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_GPNINTSTS_INTR == rInterruptStatus.GPNotify)
        {
            rInterruptStatus.GPNotify = NV_PAPU_ISTS_GPNINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_EPMINTSTS_INTR == rInterruptStatus.EPMailbox)
        {
            rInterruptStatus.EPMailbox = NV_PAPU_ISTS_EPMINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_EPNINTSTS_INTR == rInterruptStatus.EPNotify)
        {
            rInterruptStatus.EPNotify = NV_PAPU_ISTS_EPNINTSTS_CLR;
        }

        RegWrite(NV_PAPU_ISTS, rInterruptStatus.uValue);

        // complete the magic write...

        // unlock the FE
        SetFrontEnd(E_STATE::UNLOCK);

        // complete the magic writes (??)
        U032 uCnt = 0;
        while (! (*((U032 *)m_MagicWrite.pLinAddr)) )
        {
            if (uCnt++ > 100)
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "CHalMCP1::InterruptService - magic write not completing!!!\n");
                aosDbgBreakPoint();
                break;
            }
        }
    
        // it was our interrupt then complete the processing
        if (NV_PAPU_ISTS_GINTSTS_INTR == rInterruptStatus.General)
        {
            if (rInterruptStatus.FETrap == NV_PAPU_ISTS_FETINTSTS_CLR)
                OnIntrFETrap();

            // callback the clients
            CallbackClients(ClientMask.uValue);
        }

    }
    else
    {
        // not our interrupt
        rmStatus = RM_ERROR;
    }
    
    return rmStatus;
}

// returns non-zero if it's an EP SW method.. FALSE for AP
BOOL
CHalMCP1::GetUserMethodInfo(U032 *pMethod, U032 *pParam)
{
    // to do - change this when the .ref is updated
    RegRead(NV_PAPU_FEDECPARAM, pParam);
    RegRead(NV_PAPU_FEDECMETH, pMethod);

    BOOL bEPMethod = (*pMethod) & PIO_EP_OFFSET;

    // return 16 LSB after turning off bit 16
    *pMethod = ((*pMethod) & (~PIO_EP_OFFSET));
    *pMethod = LOW16(*pMethod);

    return bEPMethod;
}

VOID
CHalMCP1::OnIntrFETrap()
{
    R_FE_CONTROL rFeControl;
    RM_STATUS rmStatus = RM_ERROR;
    
    // first find out the reason for the trap
    U032 uParam;
    U032 uMethod;
    BOOL bEpMethod = GetUserMethodInfo(&uMethod, &uParam);
    
    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);
    rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
    
    switch(rFeControl.TrapReason)
    {
    case NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN\n");
    case NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED\n");

        if (bEpMethod)
            rmStatus = m_pEpMethod->Execute(uMethod, uParam);
        else
            rmStatus = m_pApMethod->Execute(uMethod, uParam);

        break;
        
    case NV_PAPU_FECTL_FETRAPREASON_REQUESTED:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_REQUESTED\n");
        break;
        
    case NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT\n");
        break;

    case NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET\n");
        break;

    case NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET\n");
        break;

    case NV_PAPU_FECTL_FETRAPREASON_VOICE_ACTIVE:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_VOICE_ACTIVE\n");
        break;

    case NV_PAPU_FECTL_FETRAPREASON_NOT_DATA_TYPE_BUFFER:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_NOT_DATA_TYPE_BUFFER\n");
        break;
    }
    
    if (rmStatus != RM_OK)
        WriteError(FALSE, (U008)rFeControl.TrapReason);
        
    // turn the FE to free running
    SetFrontEnd(E_STATE::FREE_RUN);
}


VOID
CHalMCP1::WriteError(U032 uIsCurrentVoice, U008	uErrorCode)		
{
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::WriteError - Writing to notification memory\n");

    if (m_pNotify)
    {
        U032 uIndex = 0;

        // TRUE - pick up from FECV, else write to [0]
        if (uIsCurrentVoice)
        {
            // get index
            RegRead(NV_PAPU_FECV, &uIndex);
            uIndex = (2*uIndex) + 2;
        }
        
        m_pNotify[uIndex]->GSCNT = 0xA1;             // just my signature
        m_pNotify[uIndex]->CurrentOffset = 0; 
        m_pNotify[uIndex]->Zero = 0;
        m_pNotify[uIndex]->Res0 = 0;
        m_pNotify[uIndex]->SamplesAvailable = 0;
        m_pNotify[uIndex]->EnvelopeActive = 0;
        m_pNotify[uIndex]->Status = uErrorCode;
    }
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::WriteError - Notification memory not available\n");
    }

    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::WriteError - Done\n");
}

VOID 
CHalMCP1::CallbackClients(U032 uIntrMask)
{
    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
    {
        if ( (m_ClientInfo[uCnt].pFn) &&
            (m_ClientInfo[uCnt].Mask.uValue & uIntrMask) )
        {
            (*(m_ClientInfo[uCnt].pFn))((U032)m_ClientInfo[uCnt].pContext, uIntrMask, 0);
        }
    }
}

RM_STATUS
CHalMCP1::AddClient(VOID *pParam, U008 *pRef)
{
    PMCP1_CLIENT_INFO pClientInfo = (PMCP1_CLIENT_INFO)pParam;

    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
    {
        if (!m_ClientInfo[uCnt].pFn)
        {
            // store it here
            m_ClientInfo[uCnt].pFn = pClientInfo->pFn;
            m_ClientInfo[uCnt].Mask.uValue = pClientInfo->Mask.uValue;
            m_ClientInfo[uCnt].pContext = pClientInfo->pContext;
            *pRef = (U008)uCnt;

            return RM_OK;
        }
    }
    
    return RM_ERROR;
}

RM_STATUS
CHalMCP1::DeleteClient(U008 uRef)
{
    m_ClientInfo[uRef].pFn = NULL;
    return RM_OK;
}


RM_STATUS
CHalMCP1::Allocate()
{
    RM_STATUS rmStatus = RM_OK;
    
    // right now allocate just a page for magic write.. but later change it 
    // to allocate only 32 bits
    m_MagicWrite.Size = PAGE_SIZE;
    rmStatus = aosAllocateMem(m_MagicWrite.Size, 
                            ALIGN_4K, 
                            &(m_MagicWrite.pLinAddr),
                            &(m_MagicWrite.pPhysAddr));

    if (rmStatus == RM_OK)
    {
        // clear all the interrupts
        RegWrite(NV_PAPU_ISTS, (U032)0x00000FFF);

        m_rInterruptMask.uValue = 0;
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
        // m_rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_ENABLED;
        // m_rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_ENABLED;
        m_rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_DISABLED;
        m_rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_DISABLED;
        m_rInterruptMask.FETrap = NV_PAPU_IEN_FETINTEN_ENABLED;
        m_rInterruptMask.FENotify = NV_PAPU_IEN_FENINTEN_DISABLED;
        m_rInterruptMask.FEVoice = NV_PAPU_IEN_FEVINTEN_DISABLED;
        m_rInterruptMask.FEMethodOverFlow = NV_PAPU_IEN_FEOINTEN_ENABLED;
        m_rInterruptMask.GPMailbox = NV_PAPU_IEN_GPMINTEN_DISABLED;
        m_rInterruptMask.GPNotify = NV_PAPU_IEN_GPNINTEN_DISABLED;
        m_rInterruptMask.EPMailbox = NV_PAPU_IEN_EPMINTEN_DISABLED;
        m_rInterruptMask.EPNotify = NV_PAPU_IEN_EPNINTEN_DISABLED;

        R_FE_CONTROL rFeControl;
        rFeControl.uValue = 0;
	    rFeControl.TrapOnNotifier = NV_PAPU_FECTL_FENINT_ENABLED;
        rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
        rFeControl.EnableLock = NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED;

        R_SE_CONTROL rSeControl;
        rSeControl.uValue = 0;
	    rSeControl.DeltaPanic = NV_PAPU_SECTL_DPINT_DISABLED;
	    rSeControl.Retriggered = NV_PAPU_SECTL_RTWARN_DISABLED;
	    rSeControl.DeltaWarn = NV_PAPU_SECTL_DWINT_DISABLED;
	    rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

        RegWrite(NV_PAPU_IEN, m_rInterruptMask.uValue);
        RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
        RegWrite(NV_PAPU_SECTL, rSeControl.uValue);
    
        // i want all legal traps to come to me...
        RegWrite(NV_PAPU_FETFORCE0, (U032)0);
        RegWrite(NV_PAPU_FETFORCE1, (U032)0);
        RegWrite(NV_PAPU_FETIGNORE0, (U032)0);
        RegWrite(NV_PAPU_FETIGNORE1, (U032)0);
    
        // stop the GP - todo

        // stop the EP - todo
    }

    return rmStatus;
}

RM_STATUS
CHalMCP1::Free()
{
    RM_STATUS rmStatus = RM_OK;
    
    // disable the interrupts
    SetInterrupts(INTERRUPT_STATE::DISABLE);

    // stop the FE
    SetFrontEnd(E_STATE::HALT);

    // free the memory
    if (m_MagicWrite.pLinAddr)
        aosFreeMem(m_MagicWrite.pLinAddr);

    return rmStatus;
}

RM_STATUS 
CHalMCP1::AllocateObject(U032 uObjectType, VOID *pParam)
{
	RM_STATUS	rmStatus = RM_ERROR;

    switch (uObjectType)
    {
    case AUDIO_OBJECT_AP:

        do
        {
	        APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;

            if (m_pApMethod)
            {
                // not support for multiple object allocations...
                break;
            }

            // allocate the sw method class
            m_pApMethod = new CMCP1Method(this);
            m_pVoiceProc = new CHalVoiceProc(this);
            m_pGlobalProc = new CHalGlobalProc(this);

            if (m_pVoiceProc && m_pGlobalProc && m_pApMethod)
            {
                SetInterrupts(INTERRUPT_STATE::DISABLE);
                SetFrontEnd(E_STATE::LOCK);

                // now allocate the objects
                rmStatus = m_pVoiceProc->Allocate(pParam);
                if (rmStatus == RM_OK)
                    rmStatus = m_pGlobalProc->Allocate(pParam);
                
                if (pArg->flags.fields.ISO)
                {
                    SetFrontEnd(E_STATE::ISO);
                    SetSetupEngine(E_STATE::ISO);
                }
                else
                {
                    SetFrontEnd(E_STATE::NON_ISO);
                    SetSetupEngine(E_STATE::NON_ISO);
                }
                
                if (rmStatus == RM_OK)
                {
                    // find out mode for setup engine...
                    E_STATE eState;

                    switch(pArg->flags.fields.GSCNT)
                    {
                    case GSCNT_ACSYNC:
                        eState = AC_SYNC;
                        break;
                    case GSCNT_SW:
                        eState = SW;
                        break;
                    case GSCNT_FREE_RUNNING:
                    default:
                        eState = FREE_RUN;
                        break;
                    }

                    SetSetupEngine(eState);

                    if (eState != E_STATE::FREE_RUN)
                    {
                        SetSetupEngineGlobalCounts( pArg->uExternalGSCNT,
                                                    pArg->uInternalGSCNT,
                                                    pArg->uDeltaGSCNT);
                    }

                    SetFrontEnd(E_STATE::FREE_RUN);
                }
                
                SetFrontEnd(E_STATE::UNLOCK);
                SetInterrupts(INTERRUPT_STATE::ENABLE);

                pArg->pioBase = GetDevBase() + DEVICE_BASE(NV_PAPU_NV1BA0);
            }

        } while (FALSE);

        break;

    case AUDIO_OBJECT_EP:
        do
        {
            APU_EP_CREATE *pArg = (APU_EP_CREATE *) pParam;
            
            if (m_pEpMethod)
                break;

            m_pExtendedProc = new CHalExtendedProc(this);
            m_pEpMethod = new CEPMethod(this);

            if (m_pExtendedProc && m_pEpMethod)
                rmStatus = m_pExtendedProc->Allocate(pParam);

            if (rmStatus == RM_OK)
            {
                // set up the sample counts
                SetSetupEngineExtendedCounts(pArg->uInternalGSCNT,
                                            pArg->uDeltaGSCNT,
                                            pArg->uStepSize);

                pArg->pioBase = GetDevBase() + DEVICE_BASE(NV_PAPU_NV1BA0) + PIO_EP_OFFSET;
            }

        } while (FALSE);

        break;

    default:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::AllocateObject - Illegal object\n");
        rmStatus = RM_ERR_ILLEGAL_OBJECT;
        break;
    }
    
    if (rmStatus != RM_OK)
        FreeObject(uObjectType, NULL);

    return rmStatus;

}

RM_STATUS 
CHalMCP1::FreeObject(U032 uObjectType, VOID *pParam)
{
    RM_STATUS rmStatus = RM_OK;

    switch(uObjectType)
    {
    case AUDIO_OBJECT_AP:
        if (m_pApMethod)
        {
            delete m_pApMethod;
            m_pApMethod = NULL;
        }

        if (m_pGlobalProc)
        {
            m_pGlobalProc->Free();
            delete m_pGlobalProc;
            m_pGlobalProc = NULL;
        }

        if (m_pVoiceProc)
        {
            m_pVoiceProc->Free(pParam);
            delete m_pVoiceProc;
            m_pVoiceProc = NULL;
        }
        break;

    case AUDIO_OBJECT_EP:
        if (m_pEpMethod)
        {
            delete m_pEpMethod;
            m_pEpMethod = NULL;
        }

        if (m_pExtendedProc)
        {
            m_pExtendedProc->Free();
            delete m_pExtendedProc;
            m_pExtendedProc = NULL;
        }
        break;

    default:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::FreeObject - Illegal object\n");
        rmStatus = RM_ERR_ILLEGAL_OBJECT;
        break;
    }

    return rmStatus;
}


VOID 
CHalMCP1::SetInterrupts(INTERRUPT_STATE eIntrState)
{
    if (eIntrState == ENABLE)		// set the interrupts on
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_ENABLED;
    else							// turn them off
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
    
    RegWrite(NV_PAPU_IEN, m_rInterruptMask.uValue);
}


VOID 
CHalMCP1::SetFrontEnd(E_STATE eFeState)
{
    R_FE_CONTROL rFeControl;
    
#if defined DEBUG
    U032 uCnt = 0;
#endif

    if (eFeState == LOCK)
    {
        do
        {
            RegRead(NV_PAPU_FECTL, &rFeControl.uValue);

#if defined DEBUG
            if (uCnt++ > 1000)      aosDbgBreakPoint();
#endif

        } while (rFeControl.Lock == NV_PAPU_FECTL_FEPRIVLOCK_LOCKED);

        rFeControl.Lock = NV_PAPU_FECTL_FEPRIVLOCK_LOCKED;
    }
    else
    {
        RegRead(NV_PAPU_FECTL, &rFeControl.uValue);

        // error check
        if (rFeControl.Lock == NV_PAPU_FECTL_FEPRIVLOCK_LOCKED)
        {
            aosDbgBreakPoint();
        }
        
        switch(eFeState)
        {
        case UNLOCK:
            rFeControl.Lock = NV_PAPU_FECTL_FEPRIVLOCK_UNLOCKED;
            break;
        case HALT:
            rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
            break;
        case FREE_RUN:
            rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING;
            break;
        case ISO:
	        rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_ISO;
	        rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_ISO;
	        rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_ISO;
            rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_ISO;
            break;
        case NON_ISO:
	        rFeControl.WriteISO = NV_PAPU_FECTL_FEMWTYP_NON_ISO;
	        rFeControl.ReadISO = NV_PAPU_FECTL_FEMRTYP_NON_ISO;
	        rFeControl.NotifyISO = NV_PAPU_FECTL_FENTYP_NON_ISO;
            rFeControl.PIOClass = NV_PAPU_FECTL_FEPIOCLASS_NON_ISO;
            break;
        }
    }

    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
}


VOID
CHalMCP1::SetSetupEngine(E_STATE eState)
{
    R_SE_CONTROL rSeControl;

    RegRead(NV_PAPU_SECTL, &rSeControl.uValue);

    switch(eState)
    {
    case ISO:
	    rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_ISO;
	    rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_ISO;
	    rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_ISO;
        break;
    case NON_ISO:
	    rSeControl.SampleReadISO = NV_PAPU_SECTL_SESRTYP_NON_ISO;
	    rSeControl.WriteISO = NV_PAPU_SECTL_SEPWTYP_NON_ISO;
	    rSeControl.ReadISO = NV_PAPU_SECTL_SEPRTYP_NON_ISO;
        break;
    case OFF:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;
        break;
    case AC_SYNC:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;
        break;
    case SW:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_SW;
        break;
    case FREE_RUN:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;
        break;
    case INT_PANIC:
        rSeControl.DeltaPanic = NV_PAPU_SECTL_DPINT_ENABLED;
        break;
    case INT_RETRIGGER:
        rSeControl.Retriggered = NV_PAPU_SECTL_RTWARN_ENABLED;
        break;
    case INT_WARN:
        rSeControl.DeltaWarn = NV_PAPU_SECTL_DWINT_ENABLED;
        break;
    default:
        return;
    }

    RegWrite(NV_PAPU_SECTL, rSeControl.uValue);

}

VOID
CHalMCP1::SetSetupEngineGlobalCounts(U032 uExt, U032 uInt, U032 uDelta)
{
    U032 uWarn = ((uInt - uExt) - uDelta)/3;
    U032 uRetrigger = 0;        // not using it right now
    U032 uPanic = 0;            // for now.. panic if uExt catches up with uInt

    RegWrite(NV_PAPU_XGSCNT, uExt);
    RegWrite(NV_PAPU_IGSCNT, uInt);
    RegWrite(NV_PAPU_DGSCNT, uDelta);
    RegWrite(NV_PAPU_WGSCNT, uWarn);
    RegWrite(NV_PAPU_RGSCNT, uRetrigger);
    RegWrite(NV_PAPU_PGSCNT, uPanic);
    
    // make sure the SECTL is triggering panic and warn interrupts
    // and retrigger is off
    SetSetupEngine(E_STATE::INT_PANIC);
    SetSetupEngine(E_STATE::INT_WARN);
}

VOID
CHalMCP1::SetSetupEngineExtendedCounts(U032 uInt, U032 uDelta, U032 uStep)
{
    RegWrite(NV_PAPU_EGSCNT, uInt);
    RegWrite(NV_PAPU_DEGSCNT, uDelta);
    RegWrite(NV_PAPU_ECNTSTP, uStep);
}

RM_STATUS 
CHalMCP1::AllocateContextDma(VOID *pParam)
{
    APU_AP_ALLOC_CONTEXT_DMA *pIn = (APU_AP_ALLOC_CONTEXT_DMA *)pParam;
    RM_STATUS rmStatus = RM_ERROR;

    CContextDma *pDma = new CContextDma;

    if (pDma)
    {
        rmStatus = pDma->Initialize((VOID *)pIn->uBaseAddress,
                                    pIn->uMaxOffset,
                                    pIn->uType);

        if (AUDIO_CONTEXT_DMA_FENOTIFIER == pIn->uType)
        {
            // store the notifier memory address...
            m_pNotify = (PNV1BA0NOTIFICATION *)pIn->uBaseAddress;
        }

        if (rmStatus == RM_OK)
            pDma->Add((CLinkList **)&m_pCDma);
        else
        {
            delete pDma;
            pDma = NULL;
        }
    }
    
    pIn->uHandle = (U032)pDma;

    return rmStatus;
}

RM_STATUS 
CHalMCP1::FreeContextDma(VOID *pParam)
{
    APU_AP_FREE_CONTEXT_DMA *pIn = (APU_AP_FREE_CONTEXT_DMA *) pParam;

#if defined DEBUG

    // search the list for the context DMA
    if (!m_pCDma || FALSE == m_pCDma->Exists((CLinkList *)pIn->uHandle))
    {
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::FreeContextDma - handle not found\n");
        return RM_ERROR;
        
    }

#endif 

    // assume it's the correct handle and free it
    CContextDma *pElement = (CContextDma *)pIn->uHandle;
    
    if (!pElement)
        return RM_ERROR;

    if (pElement->GetType() == AUDIO_CONTEXT_DMA_FENOTIFIER)
        m_pNotify = NULL;
    
    pElement->Remove((CLinkList **)&m_pCDma);
    
    delete pElement;

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\class\nv\classdel.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASSDEL.C                                                        *
*     Deleted user objects are destroyed here if not in use or placed       *
* into a 'zombie' state waiting to go idle before all state is removed.     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>

//
// No zombie management yet
//
RM_STATUS classAddZombie
(
    POBJECT DeadObject
)
{
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\class\nv\classobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASSOBJ.C                                                        *
*     NV_CLASS objects are defined and managed in this module.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <fifo.h>
#include <os.h>
#include <modular.h>


//
// Class object table.
//
extern CLASS classTable[];


//---------------------------------------------------------------------------
//
//  Class object method functions.
//
//---------------------------------------------------------------------------

RM_STATUS mthdCreateLegacy
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    NewName
)
{
    RM_STATUS status;
    POBJECT   NewObject;

    if (NewName < RESERVED_NAMES)
        return (RM_ERR_CREATE_BAD_CLASS);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Creating Object ", NewName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               ChID   ", ClassObject->ChID);
    
    //
    // Class specific creation routine.
    //
    status = classCreate((VOID*)pDev, (PCLASSOBJECT)ClassObject, NewName, &NewObject, NULL);
    if (status == RM_OK)
    {
        //
        // Init global state.
        //
        DBG_VAL_PTR(NewObject);

        //
        // Stick new object into FIFO database.
        //
        if ((status = fifoAddObject(pDev, NewObject)) != RM_OK)
            classDestroy((VOID*)pDev, NewObject);
    }
    return (status);
}
RM_STATUS mthdCreate
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    NewName,
    VOID*   pCreateParms
)
{
    RM_STATUS status;
    POBJECT   NewObject;

    if (NewName < RESERVED_NAMES)
        return (RM_ERR_CREATE_BAD_CLASS);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Creating Object ", NewName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               ChID   ", ClassObject->ChID);
    
    //
    // Class specific creation routine.
    //
    status = classCreate((VOID*)pDev, (PCLASSOBJECT)ClassObject, NewName, &NewObject, pCreateParms);
    if (status == RM_OK)
    {
        //
        // Init global state.
        //
        DBG_VAL_PTR(NewObject);

        //
        // Stick new object into FIFO database.
        //
        if ((status = fifoAddObject(pDev, NewObject)) != RM_OK)
            classDestroy((VOID*)pDev, NewObject);
    }
    return (status);
}
RM_STATUS mthdDestroy
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    DelName
)
{
    RM_STATUS status;
    POBJECT   DelObject;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Destroying Object ", DelName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 ChID   ", ClassObject->ChID);
    //
    // Retrieve and delete object from FIFO database.
    //    
    status = fifoSearchObject(pDev, DelName, ClassObject->ChID, &DelObject);
    if (status == RM_OK)
    {
        //
        // Make sure to free up any events in this object
        //
        if (DelObject->NotifyEvent)
        {
            PEVENTNOTIFICATION thisEvent = DelObject->NotifyEvent;
            PEVENTNOTIFICATION nextEvent = DelObject->NotifyEvent->Next;
            
            //
            // Walk the event chain and delete
            //
            osFreeMem((VOID *)thisEvent);
            while (nextEvent)
            {
                thisEvent = nextEvent;
                nextEvent = thisEvent->Next;
                osFreeMem((VOID *)thisEvent);
            }
        }
        
        //
        // Class specific delete procedure.
        //
        status  = fifoDelObject(pDev, DelObject);
        status |= classDestroy((VOID*)pDev, DelObject);
    }
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalVoiceProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalVoiceProc.h                                                   *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALVOICEPROCH_
#define _CHALVOICEPROCH_

class CHalBase;
class CObjBase;

class CHalVoiceProc : public CObjBase
{
public:
    CHalVoiceProc(CHalBase *pHal) : CObjBase(pHal) { };
	~CHalVoiceProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);
	RM_STATUS GetCaps(VOID *pParam);
    
    void *  GetSgeInLinAddr()   { return m_SgeIn.pLinAddr; }
    U032    GetSgeInSize()      { return m_SgeIn.Size; }

    void *  GetSegInLinAddr()   { return m_SegIn.pLinAddr; }
    U032    GetSegInSize()      { return m_SegIn.Size; }

private:
	VOID InitializeHardware(APU_AP_CREATE *);

    RM_STATUS AllocateMemory(APU_AP_CREATE *);
    VOID FreeMemory();

    MEM_DESC    m_Voice;
    MEM_DESC    m_SgeIn;
    MEM_DESC    m_SegIn;
    MEM_DESC    m_HRTFTarg;
    MEM_DESC    m_HRTFCurr;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CHalVoiceProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalVoiceProc.cpp                                                 *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <AudioHw.h>
#include <nvarm.h>
#include <nv32.h>
#include <nv_papu.h>
#include <aos.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"


RM_STATUS
CHalVoiceProc::Allocate(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_OK;
	
    do
    {
        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

	    // this is for debug only!
        pArg->pVoiceList = (VOID_PTR)m_Voice.pLinAddr;

        InitializeHardware(pArg);

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalVoiceProc::Free(VOID *pParam)
{
	RM_STATUS rmStatus = RM_OK;
	
	FreeMemory();

	return rmStatus;
}

VOID
CHalVoiceProc::FreeMemory()
{
	aosFreeMem(m_Voice.pLinAddr);
	aosFreeMem(m_SgeIn.pLinAddr);
	aosFreeMem(m_SegIn.pLinAddr);
	aosFreeMem(m_HRTFTarg.pLinAddr);
	aosFreeMem(m_HRTFCurr.pLinAddr);
}

RM_STATUS
CHalVoiceProc::AllocateMemory(APU_AP_CREATE *pArg)
{
	RM_STATUS rmStatus;

    U032 uCnt;

	m_Voice.Size = pArg->uVoiceCount * NV_PAVS_SIZE;
    m_SgeIn.Size = pArg->uSGEInCount * NV_PSGE_SIZE;
    m_SegIn.Size = pArg->uSegInCount * 64 * NV_PSGE_SIZE;
    m_HRTFTarg.Size = pArg->uHRTFCount * NV_PAHRTFT_SIZE;
    m_HRTFCurr.Size = pArg->uVoice3dCount * NV_PAHRTFC_SIZE;
	
	rmStatus = aosAllocateMem(m_Voice.Size,
							ALIGN_16K,
							&m_Voice.pLinAddr,
							&m_Voice.pPhysAddr);
	if (rmStatus == RM_OK)
	{
        rmStatus = aosAllocateMem(m_SgeIn.Size,
								ALIGN_16K,
								&m_SgeIn.pLinAddr,
								&m_SgeIn.pPhysAddr);

	}
	

	if (rmStatus == RM_OK)
	{

		rmStatus = aosAllocateMem(m_SegIn.Size,
								ALIGN_16K,
								&m_SegIn.pLinAddr,
								&m_SegIn.pPhysAddr);

	}


	if (rmStatus == RM_OK)
	{

		rmStatus = aosAllocateMem(m_HRTFTarg.Size,
								ALIGN_16K,
								&m_HRTFTarg.pLinAddr,
								&m_HRTFTarg.pPhysAddr);

	}

	if (rmStatus == RM_OK)
	{
		rmStatus = aosAllocateMem(m_HRTFCurr.Size,
								ALIGN_16K,
								&m_HRTFCurr.pLinAddr,
								&m_HRTFCurr.pPhysAddr);

	}

    // initialize the voice structures
    if (rmStatus == RM_OK)
    {
        U032 uAddr;
        U016 uNxtVoice;

        for (uCnt = 0; uCnt < pArg->uVoiceCount; uCnt++) 
        {
            uAddr = U032(m_Voice.pLinAddr) + (uCnt * NV_PAVS_SIZE);

            aosZeroMemory((VOID *)uAddr, NV_PAVS_SIZE);

            uNxtVoice = (U016)REF_NUM(NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE, uCnt);

            MemWrite(uAddr + NV_PAVS_VOICE_TAR_PITCH_LINK, uNxtVoice);
        }
        
        aosZeroMemory(m_SgeIn.pLinAddr, m_SgeIn.Size);
        aosZeroMemory(m_SegIn.pLinAddr, m_SegIn.Size);
        
    }

	return rmStatus;
}


RM_STATUS
CHalVoiceProc::GetCaps(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	VOLU32 vTemp;

    if (pArg->uVoiceCount)
    {
	    vTemp = pArg->uVoiceCount - 1;
	    RegWrite(NV_PAPU_FEMAXV, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXV, &vTemp);
	    pArg->uVoiceCount = vTemp + 1;
    }

    if (pArg->uVoice3dCount)
    {
	    vTemp = pArg->uVoice3dCount - 1;
	    RegWrite(NV_PAPU_FEMAXTV, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXTV, &vTemp);
	    pArg->uVoice3dCount = vTemp + 1;
    }

	if (pArg->uHRTFCount)
    {
        vTemp = pArg->uHRTFCount - 1;
	    RegWrite(NV_PAPU_FEMAXHT, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXHT, &vTemp);
	    pArg->uHRTFCount = vTemp + 1;
    }


	if (pArg->uSegInCount)
    {
        vTemp = pArg->uSegInCount - 1;
	    RegWrite(NV_PAPU_FEMAXSESSL, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXSESSL, &vTemp);
	    pArg->uSegInCount = vTemp + 1;
    }

	if (pArg->uSGEInCount)
    {
        vTemp = pArg->uSGEInCount - 1;
	    RegWrite(NV_PAPU_FEMAXSESGE, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXSESGE, &vTemp);
	    pArg->uSGEInCount = vTemp + 1;
    }
    
    if (pArg->uSubmixCount)
    {
	    // submixes
        vTemp = pArg->uSubmixCount - 1;
	    RegWrite(NV_PAPU_FEMAXMB, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXMB, &vTemp);
	    pArg->uSubmixCount = vTemp + 1;
    }

	return RM_OK;
}


VOID
CHalVoiceProc::InitializeHardware(APU_AP_CREATE *pArg)
{
    // program the instance memory
    RegWrite(NV_PAPU_VPVADDR, (U032)m_Voice.pPhysAddr);
	RegWrite(NV_PAPU_VPHTADDR, (U032)m_HRTFTarg.pPhysAddr);
	RegWrite(NV_PAPU_VPHCADDR, (U032)m_HRTFCurr.pPhysAddr);
	RegWrite(NV_PAPU_VPSGEADDR, (U032)m_SgeIn.pPhysAddr);
	RegWrite(NV_PAPU_VPSSLADDR, (U032)m_SegIn.pPhysAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\class\nv\nvde.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** NVDE ****************************************\
*                                                                           *
* Module: NVDE.C                                                            *
*     NVDE methods                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <modular.h>
#include <event.h>

RM_STATUS NvdeAlloc
(
    U032            Name,
    VOID*           pCreateParms
)
{
    PRMINFO pRmInfo = &NvRmInfo;
    RM_STATUS status;
    POBJECT pObject;
    PNVDEOBJECT pNvdeObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvdeAlloc\r\n");

    //
    // Make sure an NVDE object isn't already in use
    //
    if (pRmInfo->Debugger.object)
        return (NVDE_STATUS_ERROR_STATE_IN_USE);

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)&pObject, sizeof(NVDEOBJECT));
    if (status)
        return (status);

    //
    // Set some default state.
    //
    pObject->Name = Name;
    pObject->ChID = 0;
    pObject->Class = NULL;
    pObject->ThisClass = NULL;
    pObject->Subchannel = NULL;
    pObject->Next = NULL;
    pObject->NotifyXlate = NULL;
    pObject->NotifyAction = 0;
    pObject->NotifyTrigger = 0;
    pObject->NotifyEvent = 0;

    //
    // Save off the event parameters.
    //
    pNvdeObject = (PNVDEOBJECT)pObject;
    pNvdeObject->EventHandle = ((NVDE_ALLOCATION_PARAMETERS*)pCreateParms)->EventHandle;
    pNvdeObject->EventClass = ((NVDE_ALLOCATION_PARAMETERS*)pCreateParms)->EventClass;
    pNvdeObject->EventBufferCount = 0;

    //
    // Queue up event...
    //
    status = eventSetObjectEventNotify(pObject, 0, 0, pNvdeObject->EventClass,  pNvdeObject->EventHandle);

    //
    // Set the pointer so we know a NVDE object is in use
    //
    if (status == RM_OK)
        pRmInfo->Debugger.object = (POBJECT) pObject;

    return status;
}


RM_STATUS NvdeFree
(
    U032 Client,
    U032 Object
)
{
    PRMINFO pRmInfo = &NvRmInfo;
    PNVDEOBJECT pNvdeObject = (PNVDEOBJECT)pRmInfo->Debugger.object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvdeFree\r\n");

    if (pNvdeObject == NULL)
        return RM_OK;

    //
    // Assert that the handles match.
    //
    if (pNvdeObject->Common.Base.Name != Object)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad debugger object handle ", Object);
        return RM_ERROR;
    }

    //
    // Unplug event.  Handle is 0 for now since we only support
    // a single debugger event.
    //
    eventRemoveObjectEventNotify((POBJECT)pNvdeObject, 0);

    //
    // Clear out the NVDE object pointer so we know it's not in use
    //
    pRmInfo->Debugger.object = (POBJECT)NULL;

    return (osFreeMem(pNvdeObject));
}

V032 NvdeAppendEventForDebugger
(
    PNVDEOBJECT pDebugger,
    U032        code,
    U032        flags,
    U032        param1,
    U032        param2,
    U032        param3,
    U032        param4,
    U032        param5,
    U032        param6
)
{
    PNVDEEVENT event;

    if (pDebugger->EventBufferCount >= NVDE_MAX_EVENTS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Too many NVDE events to buffer.\n\r");
        return 0;
    }
    
    event           = pDebugger->EventBuffer + pDebugger->EventBufferCount;
    event->code     = code;
    event->flags    = flags;
    event->param[0] = param1;
    event->param[1] = param2;
    event->param[2] = param3;
    event->param[3] = param4;
    event->param[4] = param5;
    event->param[5] = param6;

    pDebugger->EventBufferCount++;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\btree\nv\btree.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Balanced Tree *******************************\
*                                                                           *
* Module: BTREE.C                                                           *
*   A generic library to balanced tree management is provided.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <class.h>
#include <btree.h>
#include <os.h>
//
// Debugging support.
//
#ifdef DEBUG
//
// Validate node.
//
#define VALIDATE_NODE(pn)                   \
{                                           \
    if (btreeNodeValidate(pn) != RM_OK)     \
        return (RM_ERROR);                  \
}
#define VALIDATE_TREE(pt)                   \
{                                           \
    if (btreeTreeValidate(pt) != RM_OK)     \
        return (RM_ERROR);                  \
}
//
// Prototype validation routines.
//
RM_STATUS btreeNodeValidate(PNODE);
RM_STATUS btreeTreeValidate(PNODE);
RM_STATUS btreeDumpBranch(PNODE, U032);
RM_STATUS btreeDumpTree(PNODE);
//
// Validate a nodes branch and count values.
//
RM_STATUS btreeNodeValidate
(
    PNODE Node
)
{
    RM_STATUS status;
    
    status = RM_OK;
    if (Node == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR validating NULL NODE.\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }
    if (((Node->LeftCount != 0) && (Node->LeftBranch == NULL))
    ||  ((Node->LeftCount == 0) && (Node->LeftBranch != NULL)))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left branch, Value = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                       Left count = ", Node->LeftCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                      Left branch = ", Node->LeftBranch);
        DBG_BREAKPOINT();
        status = RM_ERROR;
    }
    if (((Node->RightCount != 0) && (Node->RightBranch == NULL))
    ||  ((Node->RightCount == 0) && (Node->RightBranch != NULL)))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right branch, Value = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                       Right count = ", Node->RightCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                      Right branch = ", Node->RightBranch);
        DBG_BREAKPOINT();
        status = RM_ERROR;
    }
    return (status);
}
//
// Validate entire BTREE.
//
RM_STATUS btreeBranchValidate
(
    PNODE Node,
    U032 *NodeCount
)
{
    RM_STATUS status;
    U032 LeftCount;
    U032 RightCount;
    
    status = RM_OK;
    if (Node)
    {
        btreeNodeValidate(Node);
        if (Node->LeftBranch)
            status = btreeBranchValidate(Node->LeftBranch, &LeftCount);
        else
            LeftCount = 0;
        if (Node->RightBranch)
            status = btreeBranchValidate(Node->RightBranch, &RightCount);
        else
            RightCount = 0;
        if (Node->LeftCount != LeftCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left count, Value = ", Node->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Left count = ", Node->LeftCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Left branch = ", Node->LeftBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        if (Node->RightCount != RightCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right count, Value = ", Node->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Right count = ", Node->RightCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Right branch = ", Node->RightBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        *NodeCount = LeftCount + RightCount + 1;
    }
    return (status);
}
RM_STATUS btreeTreeValidate
(
    PNODE Trunk
)
{
    RM_STATUS status;
    U032      LeftCount;
    U032      RightCount;
    
    status = RM_OK;
    if (Trunk)
    {
        status = btreeNodeValidate(Trunk);
        if (Trunk->LeftBranch)
            status |= btreeBranchValidate(Trunk->LeftBranch, &LeftCount);
        else
            LeftCount = 0;
        if (Trunk->RightBranch)
            status |= btreeBranchValidate(Trunk->RightBranch, &RightCount);
        else
            RightCount = 0;
        if (Trunk->LeftCount != LeftCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left count, Value = ", Trunk->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Left count = ", Trunk->LeftCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Left branch = ", Trunk->LeftBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        if (Trunk->RightCount != RightCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right count, Value = ", Trunk->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Right count = ", Trunk->RightCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Right branch = ", Trunk->RightBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
    }
    if (status)
        btreeDumpTree(Trunk);
    return (status);
}
//
// Dump current tree to debug port.
//
RM_STATUS btreeDumpBranch
(
    PNODE Node,
    U032  Level
)
{
    U032 i;

    if (Node)
    {
        VALIDATE_NODE(Node);
        btreeDumpBranch(Node->RightBranch, Level + 1);
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: ");
        for (i = 0; i < Level; i++)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, ".");
        }
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Node         = ", Node);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Value        = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Left count   = ", Node->LeftCount);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Right count  = ", Node->RightCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Left branch  = ", Node->LeftBranch);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Right branch = ", Node->RightBranch);
        btreeDumpBranch(Node->LeftBranch, Level + 1);
    }
    return (RM_OK);
}
RM_STATUS btreeDumpTree
(
    PNODE Trunk
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: ======================== Tree Dump ==========================\n\r");
    if (Trunk == NULL)
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: NULL\n\r");
    else
        btreeDumpBranch(Trunk, 0);
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: =============================================================\n\r");
    return (RM_OK);
}
#else
//
// Validate nothing.
//
#define VALIDATE_NODE(pn)
#define VALIDATE_TREE(pt)
#endif // DEBUG
//
// Insert new node into tree.
//
RM_STATUS btreeInsertBranch
(
    PNODE Node, 
    PNODE BranchNode
)
{
    RM_STATUS status;
    
    //
    // Check for duplicate names.
    //
    VALIDATE_NODE(BranchNode);
    if (Node->Value == BranchNode->Value)
        return (RM_ERR_INSERT_DUPLICATE_NAME);
    status = RM_OK;    
    if (Node->Value < BranchNode->Value)
    {
        //
        // Insert into right branch.
        //
        if (BranchNode->RightBranch)
        {
            status = btreeInsertBranch(Node, BranchNode->RightBranch);
        }
        else
        {
            BranchNode->RightBranch = Node;
            Node->RightCount        = 0;
            Node->LeftCount         = 0;
            Node->RightBranch       = NULL;
            Node->LeftBranch        = NULL;
        }
        if (status == RM_OK)    
            BranchNode->RightCount++;
    }
    else
    {
        //
        // Insert into left branch.
        //
        if (BranchNode->LeftBranch)
        {
            status = btreeInsertBranch(Node, BranchNode->LeftBranch);
        }
        else
        {
            BranchNode->LeftBranch = Node;
            Node->RightCount       = 0;
            Node->LeftCount        = 0;
            Node->RightBranch      = NULL;
            Node->LeftBranch       = NULL;
        }
        if (status == RM_OK)    
            BranchNode->LeftCount++;
    }
    return (status);
}
RM_STATUS btreeInsert
(
    PNODE  Node,
    PNODE *Trunk
)
{
    RM_STATUS status;

#ifdef DEBUG
    if (Node == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: Inserting NULL into BTREE!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG    
    status = RM_OK;
    if (*Trunk == NULL)
    {
        *Trunk            = Node;
        Node->RightCount  = 0;
        Node->LeftCount   = 0;
        Node->RightBranch = NULL;
        Node->LeftBranch  = NULL;
    }
    else
    {
        status = btreeInsertBranch(Node, *Trunk);
    }
    VALIDATE_TREE(*Trunk);
    return (status);
}
//
// Remove node from tree.
//
RM_STATUS btreeDelete
(
    U032   Value,
    PNODE *Trunk
)
{
    PNODE Node;
    PNODE ParentNode;
    PNODE PrevNode;
    PNODE SearchNode;

    if (*Trunk == NULL)
        return (RM_ERROR);
    Node       = *Trunk;
    SearchNode = NULL;
    ParentNode = NULL;
    VALIDATE_TREE(*Trunk);
    //
    // Search tree for node being deleted.
    //
    while (Value != Node->Value)
    {
        ParentNode = Node;
        if (Value > Node->Value)
            Node = Node->LeftBranch;
        else
            Node = Node->RightBranch;
        if (Node == NULL)
            //
            // Not found.
            //
            return (RM_ERROR);
    }
    //
    // Check for branches of node to be deleted.
    //
    if (Node->RightCount + Node->LeftCount > 0)
    {
        PrevNode = NULL;
        //
        // Find best candidate to fill in place of deleted node.
        //
        if (Node->RightCount > Node->LeftCount)
        {
            //
            // Get next higher node.
            //
            SearchNode = Node->RightBranch;
            Node->RightCount--;
            while (SearchNode->LeftBranch)
            {
                SearchNode->LeftCount--;
                PrevNode   = SearchNode;
                SearchNode = SearchNode->LeftBranch;
            }
            if (PrevNode)
                PrevNode->LeftBranch = SearchNode->RightBranch;
            else
                Node->RightBranch = SearchNode->RightBranch;
        }
        else
        {
            //
            // Get next lower node.
            //
            SearchNode = Node->LeftBranch;
            Node->LeftCount--;
            while (SearchNode->RightBranch)
            {
                SearchNode->RightCount--;
                PrevNode   = SearchNode;
                SearchNode = SearchNode->RightBranch;
            }
            if (PrevNode)
                PrevNode->RightBranch  = SearchNode->LeftBranch;
            else
                Node->LeftBranch = SearchNode->LeftBranch;
        }
        //
        // Replace deleted node with best candidate.
        //
        SearchNode->LeftBranch  = Node->LeftBranch;
        SearchNode->LeftCount   = Node->LeftCount;
        SearchNode->RightBranch = Node->RightBranch;
        SearchNode->RightCount  = Node->RightCount;
    }
    //
    // Update parent branch pointers.
    //
    if (ParentNode)
    {
        if (ParentNode->LeftBranch == Node)
            ParentNode->LeftBranch  = SearchNode;
        else
            ParentNode->RightBranch = SearchNode;
    }
    else
    {
       *Trunk = SearchNode;
    }
    //
    // Update branch counts up to the deleted node.
    //    
    PrevNode = *Trunk;
    while (PrevNode && (PrevNode != SearchNode))
    {
        if (Value > PrevNode->Value)
        {
            PrevNode->LeftCount--;
            PrevNode = PrevNode->LeftBranch;
        }
        else
        {
            PrevNode->RightCount--;
            PrevNode = PrevNode->RightBranch;
        }
    }
    Node->RightCount  = 0;
    Node->LeftCount   = 0;
    Node->RightBranch = NULL;
    Node->LeftBranch  = NULL;
    VALIDATE_TREE(*Trunk);
    return (RM_OK);
}
//
// Search for node in tree.
//
RM_STATUS btreeSearch
(
    U032   Value,
    PNODE *Node,
    PNODE  Trunk
)
{
    VALIDATE_TREE(Trunk);
    *Node = Trunk;
    //
    // Search for Node Value.
    //
    while (*Node)
    {
        if (Value == (*Node)->Value)
            return (RM_OK);
        if (Value > (*Node)->Value)
            *Node = (*Node)->LeftBranch;
        else
            *Node = (*Node)->RightBranch;
    }
    return (RM_ERR_OBJECT_NOT_FOUND);
}
//
// Enumerate tree.
//
RM_STATUS btreeEnumStart
(
    U032   Value,
    PNODE *Node,
    PNODE  Trunk
)
{
    PNODE EnumNode;
    
    *Node    = Trunk;
    EnumNode = NULL;
    //
    // Search for Node Value.
    //
    while (*Node)
    {
        VALIDATE_NODE(*Node);
        if (Value == (*Node)->Value)
            return (RM_OK);
        if (Value > (*Node)->Value)
            *Node = (*Node)->LeftBranch;
        else
        {
            //
            // Save next nearest node.
            //
            EnumNode = *Node;
            *Node    = (*Node)->RightBranch;
        }
    }
    *Node = EnumNode;
    return (RM_OK);
}
RM_STATUS btreeEnumNext
(
    PNODE *Node,
    PNODE  Trunk
)
{
    PNODE EnumNode;
    U032  Value;
    
    VALIDATE_NODE(*Node);
    if ((*Node)->LeftBranch)
    {
        //
        // Start where we left off.
        //
        Value     = (*Node)->Value + 1;
        *Node    = (*Node)->LeftBranch;
        EnumNode = *Node;
        while (*Node)
        {
            VALIDATE_NODE(*Node);
            if (Value == (*Node)->Value)
                return (RM_OK);
            if (Value > (*Node)->Value)
                *Node = (*Node)->LeftBranch;
            else
            {
                //
                // Save next nearest node.
                //
                EnumNode = *Node;
                *Node    = (*Node)->RightBranch;
            }
        }
        *Node = EnumNode;
        return (RM_OK);
    }
    else
        return (btreeEnumStart((*Node)->Value + 1, Node, Trunk));
}
//
// Balance branch.
//
RM_STATUS btreeBalanceBranch
(
    PNODE *Node
)
{
    PNODE SearchNode;
    PNODE ParentNode;

    VALIDATE_NODE(*Node);
    while ((((*Node)->RightCount > (*Node)->LeftCount)
          ? ((*Node)->RightCount - (*Node)->LeftCount)
          : ((*Node)->LeftCount  - (*Node)->RightCount)) > 1)
    {
        ParentNode = NULL;
        if ((*Node)->RightCount > (*Node)->LeftCount)
        {
            SearchNode = (*Node)->RightBranch;
            while (SearchNode->LeftBranch)
            {
                ParentNode = SearchNode;
                SearchNode->LeftCount--;
                SearchNode = SearchNode->LeftBranch;
            }
            if (ParentNode)
            {
                ParentNode->LeftBranch  = SearchNode->RightBranch;
                SearchNode->RightBranch = (*Node)->RightBranch;
                SearchNode->RightCount  = (*Node)->RightCount - 1;
            }
            else
            {
                (*Node)->RightBranch = NULL;
                (*Node)->RightCount  = 0;
            }
            SearchNode->LeftBranch     = *Node;
            SearchNode->LeftCount      = (*Node)->LeftCount + 1;
            (*Node)->RightBranch = NULL;
            (*Node)->RightCount  = 0;
        }
        else
        {
            SearchNode = (*Node)->LeftBranch;
            while (SearchNode->RightBranch)
            {
                ParentNode = SearchNode;
                SearchNode->RightCount--;
                SearchNode = SearchNode->RightBranch;
            }
            if (ParentNode)
            {
                ParentNode->RightBranch = SearchNode->LeftBranch;
                SearchNode->LeftBranch  = (*Node)->LeftBranch;
                SearchNode->LeftCount   = (*Node)->LeftCount - 1;
            }
            else
            {
                (*Node)->LeftBranch = NULL;
                (*Node)->LeftCount  = 0;
            }
            SearchNode->RightBranch   = *Node;
            SearchNode->RightCount    = (*Node)->RightCount + 1;
            (*Node)->LeftBranch = NULL;
            (*Node)->LeftCount  = 0;
        }
        *Node = SearchNode;
    }
    if ((*Node)->RightBranch)
        btreeBalanceBranch(&((*Node)->RightBranch));
    if ((*Node)->LeftBranch)
        btreeBalanceBranch(&((*Node)->LeftBranch));
    return (RM_OK);
}
//
// Balance tree.
//
RM_STATUS btreeBalance
(
    PNODE *Trunk
)
{
    RM_STATUS status;
    
    status = RM_OK;
    if (*Trunk)
    {
        VALIDATE_TREE(*Trunk);
        status = btreeBalanceBranch(Trunk);
        VALIDATE_TREE(*Trunk);
    }
    return (status);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\class\nv\class.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASS.C                                                           *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <mc.h>
#include <gr.h>
#include <dac.h>
#include <tmr.h>
#include <os.h>
#include <modular.h>
#include <nv32.h>


//---------------------------------------------------------------------------
//
//  Class methods.
//
//---------------------------------------------------------------------------

METHOD NvPatchcordMethods[] =
{
    {mthdSetNotifyCtxDma,           0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107}
    //{mthdValidate,                  0x0300, 0x0303}
};
METHOD NvClassMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdCreateLegacy,              0x0300, 0x0303},
    {mthdDestroy,                   0x0304, 0x0307},
};
METHOD NvDmaFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvDmaToMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvDmaInMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvVideoSinkMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetVideoInput,             0x0200, 0x02ff}
};
METHOD NvVideoColormapMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetColormapCtxDma,         0x0184, 0x0187},
    {mthdSetVideoOutput,            0x0200, 0x0203},
    {mthdSetVideoInput,             0x0204, 0x0207},
    {mthdSetColormapStart,          0x0308, 0x030b},
    {mthdSetColormapLength,         0x030c, 0x030f},
    {mthdColormapDirtyStart,        0x0310, 0x0313},
    {mthdColormapDirtyLength,       0x0314, 0x0317}
};
METHOD Nv04VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class046SetNotify,             0x0104, 0x0107},
    {class046StopImage,             0x0108, 0x010f},
    {class046StopLUT,               0x0110, 0x0117},
    {class046StopCursorImage,       0x0118, 0x011f},
    {class046StopDAC,               0x0120, 0x0128},
    {class046SetNotifyCtxDma,       0x0180, 0x0183},
    {class046SetImageCtxDma,        0x0184, 0x018b},
    {class046SetLUTCtxDma,          0x018c, 0x0193},
    {class046SetCursorCtxDma,       0x0194, 0x019b},
    {class046SetPanOffset,          0x0220, 0x0223},
    {class046GetOffset,             0x02fc, 0x02ff},
    {class046SetImageValues,        0x0300, 0x030f},
    {class046SetLUTValues,          0x0310, 0x031f},
    {class046SetCursorImageValues,  0x0320, 0x032f},
    {class046SetCursorPoint,        0x0330, 0x0333},
    {class046SetDACValues,          0x0340, 0x037c}
};

METHOD Nv04VideoOverlayMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class047SetNotify,             0x0104, 0x0107},
    {class047StopOverlay,           0x0120, 0x0127},
    {class047SetNotifyCtxDma,       0x0180, 0x0183},
    {class047SetOverlayCtxDma,      0x019c, 0x01a3},
    {class047GetOffset,             0x02fc, 0x02ff},
    {class047SetOverlayValues,      0x0400, 0x04ff},
    {class047SetOverlayPointOutNow, 0x0500, 0x0503}
};

METHOD Nv05VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class049SetNotify,             0x0104, 0x0107},
    {class049StopImage,             0x0108, 0x010f},
    {class049StopLUT,               0x0110, 0x0117},
    {class049StopCursorImage,       0x0118, 0x011f},
    {class049StopDAC,               0x0120, 0x0128},
    {class049SetNotifyCtxDma,       0x0180, 0x0183},
    {class049SetImageCtxDma,        0x0184, 0x018b},
    {class049SetLUTCtxDma,          0x018c, 0x0193},
    {class049SetCursorCtxDma,       0x0194, 0x019b},
    {class049SetPanOffset,          0x0220, 0x0223},
    {class049GetOffset,             0x02fc, 0x02ff},
    {class049SetImageValues,        0x0300, 0x030f},
    {class049SetLUTValues,          0x0310, 0x031f},
    {class049SetCursorImageValues,  0x0320, 0x032f},
    {class049SetCursorPoint,        0x0330, 0x0333},
    {class049SetDACValues,          0x0340, 0x037c}
};

METHOD NvVideoFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class63SetNotify,              0x0104, 0x0107},
    {class63StopTransfer,           0x0108, 0x010b},
    {class63SetNotifyCtxDma,        0x0180, 0x0183},
    {class63SetImageCtxDma,         0x0184, 0x018b},
    {class63SetVideoOutput,         0x0200, 0x0203},
    {class63ImageScan,              0x0300, 0x0327},
    {class63GetOffsetNotify,        0x0328, 0x032f}
};
METHOD NvVideoScalerMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class64SetNotify,              0x0104, 0x0107},
    {class64SetNotifyCtxDma,        0x0180, 0x0183},
    {class64SetVideoOutput,         0x0200, 0x0203},
    {class64SetVideoInput,          0x0204, 0x0207},
    {class64SetDeltaDuDx,           0x0300, 0x0303},
    {class64SetDeltaDvDy,           0x0304, 0x0307},
    {class64SetPoint,               0x0308, 0x030b}
};
METHOD NvVideoColorKeyMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class65SetNotify,              0x0104, 0x0107},
    {class65SetNotifyCtxDma,        0x0180, 0x0183},
    {class65SetVideoOutput,         0x0200, 0x0203},
    {class65SetVideoInput,          0x0204, 0x020f},
    {class65SetColorFormat,         0x0300, 0x0303},
    {class65SetColorKey,            0x0304, 0x0307},
    {class65SetPoint,               0x0308, 0x030b},
    {class65SetSize,                0x030c, 0x030f}
};

/*
METHOD NvVideoCaptureToMemoryMethods[] =
{
    {class66SetNotifyCtxDma,        0x0100, 0x0103},
    {class66SetNotify,              0x0104, 0x0107},
    {class66StopTransfer,           0x0108, 0x010b},
    {class66SetVideoInput,          0x0200, 0x0203},
    {class66SetImageCtxDma,         0x0300, 0x0307},
    {class66SetImageNotifyCtxDma,   0x0308, 0x030f},
    {class66ImageCapture,           0x0310, 0x0337},
    {class66SetVbiCtxDma,           0x0400, 0x0407},
    {class66SetVbiNotifyCtxDma,     0x0408, 0x040f},
    {class66VbiCapture,             0x0410, 0x0437}
};
*/

METHOD Nv10VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class067SetNotify,             0x0104, 0x0107},
    {class067StopImage,             0x0108, 0x010f},
    {class067StopLUT,               0x0110, 0x0117},
    {class067StopCursorImage,       0x0118, 0x011f},
    {class067StopDAC,               0x0120, 0x0128},
    {class067SetNotifyCtxDma,       0x0180, 0x0183},
    {class067SetImageCtxDma,        0x0184, 0x018b},
    {class067SetLUTCtxDma,          0x018c, 0x0193},
    {class067SetCursorCtxDma,       0x0194, 0x019b},
    {class067SetPanOffset,          0x0220, 0x0223},
    {class067GetOffset,             0x02fc, 0x02ff},
    {class067SetImageValues,        0x0300, 0x030f},
    {class067SetLUTValues,          0x0310, 0x031f},
    {class067SetCursorImageValues,  0x0320, 0x032f},
    {class067SetCursorPoint,        0x0330, 0x0333},
    {class067SetDACValues,          0x0340, 0x037c}
};

METHOD Nv10VideoOverlayMethods[] =
{
    {mthdNoOperation,                  0x0100, 0x0103},
    {class07ASetNotify,                0x0104, 0x0107},
    {class07AStopOverlay,              0x0120, 0x0127},
    {class07ASetNotifyCtxDma,          0x0180, 0x0183},
    {class07ASetOverlayCtxDma,         0x019c, 0x01a3},
    {class07AGetOffset,                0x02fc, 0x02ff},
    {class07ASetOverlayValues,         0x0400, 0x04ff},
    {class07ASetOverlayPointOutNow,    0x0500, 0x0503},
    {class07ASetOverlayLuminanceNow,   0x0504, 0x0507},
    {class07ASetOverlayChrominanceNow, 0x0508, 0x050b}
};

METHOD Nv15VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07CSetNotify,             0x0104, 0x0107},
    {class07CStopImage,             0x0108, 0x010f},
    {class07CStopLUT,               0x0110, 0x0117},
    {class07CStopCursorImage,       0x0118, 0x011f},
    {class07CStopDAC,               0x0120, 0x0128},
    {class07CSetNotifyCtxDma,       0x0180, 0x0183},
    {class07CSetImageCtxDma,        0x0184, 0x018b},
    {class07CSetLUTCtxDma,          0x018c, 0x0193},
    {class07CSetCursorCtxDma,       0x0194, 0x019b},
    {class07CSetSemaphoreCtxDma,    0x019c, 0x019f},
    {class07CSetPanOffset,          0x0220, 0x0223},
    {class07CSetSemaphoreOffset,    0x02f0, 0x02f3},
    {class07CSetSemaphoreRelease,   0x02f4, 0x02f7},
    {class07CSetOffsetRange,        0x02f8, 0x02fb},
    {class07CGetOffset,             0x02fc, 0x02ff},
    {class07CSetImageValues,        0x0300, 0x030f},
    {class07CSetLUTValues,          0x0310, 0x031f},
    {class07CSetCursorImageValues,  0x0320, 0x032f},
    {class07CSetCursorPoint,        0x0330, 0x0333},
    {class07CSetDACValues,          0x0340, 0x037c},
};

/*
METHOD NvVideoSourceMethods[] =
{
    {class74SetNotifyCtxDma,        0x0100, 0x0103},
    {class74SetNotify,              0x0104, 0x0107},
    {class74SetVideoOutput,         0x0200, 0x0203},
};
*/

METHOD Nv1TimerMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {tmrStopTransfer,               0x0108, 0x010b},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetAlarmTime,              0x0300, 0x0307},
    {mthdSetAlarmTimeRelative,      0x0308, 0x030f},
    {mthdSetAlarmNotify,            0x0320, 0x0323}
};
METHOD Nv1BetaSolidMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class012Notify,                0x0104, 0x0107},
    {class012SetContextDmaNotifies, 0x0180, 0x0183},
    {class012SetBeta,               0x0300, 0x0303}
};
METHOD Nv1ImageSolidMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class017Notify,                0x0104, 0x0107},
    {class017SetContextDmaNotifies, 0x0180, 0x0183},
    {class017SetColorFormat,        0x0300, 0x0303},
    {class017SetColor,              0x0304, 0x0307}
};
METHOD Nv1ImagePatternMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class018Notify,                0x0104, 0x0107},
    {class018SetContextDmaNotifies, 0x0180, 0x0183},
    {class018SetColorFormat,        0x0300, 0x0303},
    {class018SetMonochromeFormat,   0x0304, 0x0307},
    {class018SetPatternShape,       0x0308, 0x030b},
    {class018SetColor0,             0x0310, 0x0313},
    {class018SetColor1,             0x0314, 0x0317},
    {class018SetPattern,            0x0318, 0x031f}
};
METHOD Nv1ImageRectangleBlackMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class019Notify,                0x0104, 0x0107},
    {class019SetContextDmaNotifies, 0x0180, 0x0183},
    {class019SetRectangle,          0x0300, 0x0307}
};
METHOD Nv1RenderSolidLinMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01CNotify,                0x0104, 0x0107},
    {class01CSetContextDmaNotifies, 0x0180, 0x0183},
    {class01CSetContextClip,        0x0184, 0x0187},
    {class01CSetContextPattern,     0x0188, 0x018b},
    {class01CSetContextRop,         0x018c, 0x018f},
    {class01CSetContextBeta1,       0x0190, 0x0193},
    {class01CSetContextSurface,     0x0194, 0x0197},
    {class01CSetOperation,          0x02fc, 0x02ff},
    {class01CSetColorFormat,        0x0300, 0x0303},
    {class01CColor,                 0x0304, 0x0307},
    {class01CLin,                   0x0400, 0x047f},
    {class01CLin32,                 0x0480, 0x04ff},
    {class01CPolyLin,               0x0500, 0x057f},
    {class01CPolyLin32,             0x0580, 0x05ff},
    {class01CColorPolyLin,          0x0600, 0x067f}
};
METHOD Nv1RenderSolidTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01DNotify,                0x0104, 0x0107},
    {class01DSetContextDmaNotifies, 0x0180, 0x0183},
    {class01DSetContextClip,        0x0184, 0x0187},
    {class01DSetContextPattern,     0x0188, 0x018b},
    {class01DSetContextRop,         0x018c, 0x018f},
    {class01DSetContextBeta1,       0x0190, 0x0193},
    {class01DSetContextSurface,     0x0194, 0x0197},
    {class01DSetOperation,          0x02fc, 0x02ff},
    {class01DSetColorFormat,        0x0300, 0x0303},
    {class01DColor,                 0x0304, 0x0307},
    {class01DTriangle,              0x0310, 0x031b},
    {class01DTriangle32,            0x0320, 0x0337},
    {class01DTrimesh,               0x0400, 0x047f},
    {class01DTrimesh32,             0x0480, 0x04ff},
    {class01DColorTriangle,         0x0500, 0x057f},
    {class01DColorTrimesh,          0x0580, 0x05ff}
};
METHOD Nv1RenderSolidRectangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01ENotify,                0x0104, 0x0107},
    {class01ESetContextDmaNotifies, 0x0180, 0x0183},
    {class01ESetContextClip,        0x0184, 0x0187},
    {class01ESetContextPattern,     0x0188, 0x018b},
    {class01ESetContextRop,         0x018c, 0x018f},
    {class01ESetContextBeta1,       0x0190, 0x0193},
    {class01ESetContextSurface,     0x0194, 0x0197},
    {class01ESetOperation,          0x02fc, 0x02ff},
    {class01ESetColorFormat,        0x0300, 0x0303},
    {class01EColor,                 0x0304, 0x0307},
    {class01ERectangle,             0x0400, 0x047f}
};
METHOD Nv1ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01FNotify,                0x0104, 0x0107},
    {class01FSetContextDmaNotifies, 0x0180, 0x0183},
    {class01FSetContextColorKey,    0x0184, 0x0187},
    {class01FSetContextClip,        0x0188, 0x018b},
    {class01FSetContextPattern,     0x018c, 0x018f},
    {class01FSetContextRop,         0x0190, 0x0193},
    {class01FSetContextBeta1,       0x0194, 0x0197},
    {class01FSetContextSurfaceSource, 0x0198, 0x019b},
    {class01FSetContextSurface,     0x019c, 0x019f},
    {class01FSetOperation,          0x02fc, 0x02ff},
    {class01FPointIn,               0x0300, 0x0303},
    {class01FPointOut,              0x0304, 0x0307},
    {class01FSize,                  0x0308, 0x030b}
};
METHOD Nv1ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class021Notify,                0x0104, 0x0107},
    {class021SetContextDmaNotifies, 0x0180, 0x0183},
    {class021SetContextColorKey,    0x0184, 0x0187},
    {class021SetContextClip,        0x0188, 0x018b},
    {class021SetContextPattern,     0x018c, 0x018f},
    {class021SetContextRop,         0x0190, 0x0193},
    {class021SetContextBeta1,       0x0194, 0x0197},
    {class021SetContextSurface,     0x0198, 0x019b},
    {class021SetOperation,          0x02fc, 0x02ff},
    {class021SetColorFormat,        0x0300, 0x0303},
    {class021Point,                 0x0304, 0x0307},
    {class021Size,                  0x0308, 0x030b},
    {class021SizeIn,                0x030c, 0x030f},
    {class021Color,                 0x0400, 0x047f}
};
METHOD Nv3StretchedImageFromCPUMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class036Notify,                0x0104, 0x0107},
    {class036SetContextDmaNotifies, 0x0180, 0x0183},
    {class036SetContextColorKey,    0x0184, 0x0187},
    {class036SetContextPattern,     0x0188, 0x018b},
    {class036SetContextRop,         0x018c, 0x018f},
    {class036SetContextBeta1,       0x0190, 0x0193},
    {class036SetContextSurface,     0x0194, 0x0197},
    {class036SetOperation,          0x02fc, 0x02ff},
    {class036SetColorFormat,        0x0300, 0x0303},
    {class036SizeIn,                0x0304, 0x0307},
    {class036DeltaDxDu,             0x0308, 0x030b},
    {class036DeltaDyDv,             0x030c, 0x030f},
    {class036Clip,                  0x0310, 0x0317},
    {class036Point12d4,             0x0318, 0x031b},
    {class036Color,                 0x0400, 0x1fff}
};
METHOD Nv3ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class037Notify,                0x0104, 0x0107},
    {class037SetContextDmaNotifies, 0x0180, 0x0183},
    {class037SetContextDmaImage,    0x0184, 0x0187},
    {class037SetContextPattern,     0x0188, 0x018b},
    {class037SetContextRop,         0x018c, 0x018f},
    {class037SetContextBeta1,       0x0190, 0x0193},
    {class037SetContextSurface,     0x0194, 0x0197},
    {class037SetColorFormat,        0x0300, 0x0303},
    {class037SetOperation,          0x0304, 0x0307},
    {class037Clip,                  0x0308, 0x030f},
    {class037RectangleOut,          0x0310, 0x0317},
    {class037DeltaDuDx,             0x0318, 0x031b},
    {class037DeltaDvDy,             0x031c, 0x031f},
    {class037ImageIn,               0x0400, 0x040f}
};
METHOD Nv3MemoryToMemoryFormatMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class039Notify,                0x0104, 0x0107},
    {class039SetContextDmaNotifies, 0x0180, 0x0183},
    {class039SetContextDmaBufferIn, 0x0184, 0x0187},
    {class039SetContextDmaBufferOut, 0x0188, 0x018b},
    {class039BufferTransfer,        0x030c, 0x032b}
};
METHOD Nv3DX3TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class048Notify,                0x0104, 0x0107},
    {class048SetContextDmaNotifies, 0x0180, 0x0183},
    {class048SetTextureCtxDma,      0x0184, 0x0187},
    {class048SetContextClip,        0x0188, 0x018b},
    {class048SetContextSurfaceColor, 0x018c, 0x018f},
    {class048SetContextSurfaceZeta, 0x0190, 0x0193},
    {class048TextureOffset,         0x0304, 0x0307},
    {class048TextureFormat,         0x0308, 0x030b},
    {class048Filter,                0x030c, 0x030f},
    {class048FogColor,              0x0310, 0x0313},
    {class048ControlOut0,           0x0314, 0x0317},
    {class048ControlOut1,           0x0318, 0x031b},
    {class048ControlPoint,          0x1000, 0x1fff}
};
METHOD Nv3GDIRectangleTextMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04BNotify,                0x0104, 0x0107},
    {class04BSetContextDmaNotifies, 0x0180, 0x0183},
    {class04BSetContextPattern,     0x0184, 0x0187},
    {class04BSetContextRop,         0x0188, 0x018b},
    {class04BSetContextBeta1,       0x018c, 0x018f},
    {class04BSetContextSurface,     0x0190, 0x0193},
    {class04BSetOperation,          0x02fc, 0x02ff},
    {class04BSetColorFormat,        0x0300, 0x0303},
    {class04BSetMonochromeFormat,   0x0304, 0x0307},
    {class04BColor1A,               0x03fc, 0x03ff},
    {class04BUnclippedRectangle,    0x0400, 0x05ff},
    {class04BClipB,                 0x07f4, 0x07fb},
    {class04BColor1B,               0x07fc, 0x07ff},
    {class04BClippedRectangle,      0x0800, 0x09ff},
    {class04BClipC,                 0x0bec, 0x0bf3},
    {class04BColor1C,               0x0bf4, 0x0bf7},
    {class04BSizeC,                 0x0bf8, 0x0bfb},
    {class04BPointC,                0x0bfc, 0x0bff},
    {class04BMonochromeColor1C,     0x0c00, 0x0dff},
    {class04BClipD,                 0x0fe8, 0x0fef},
    {class04BColor1D,               0x0ff0, 0x0ff3},
    {class04BSizeInD,               0x0ff4, 0x0ff7},
    {class04BSizeOutD,              0x0ff8, 0x0ffb},
    {class04BPointD,                0x0ffc, 0x0fff},
    {class04BMonochromeColor1D,     0x1000, 0x11ff},
    {class04BClipE,                 0x13e4, 0x13eb},
    {class04BColor0E,               0x13ec, 0x13ef},
    {class04BColor1E,               0x13f0, 0x13f3},
    {class04BSizeInE,               0x13f4, 0x13f7},
    {class04BSizeOutE,              0x13f8, 0x13fb},
    {class04BPointE,                0x13fc, 0x13ff},
    {class04BMonochromeColor01E,    0x1400, 0x15ff}
};
METHOD Nv3ExternalVideoDecoderMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04DNotify,                0x0104, 0x0107},
    {class04DStopTransferVbi,       0x0108, 0x010b},
    {class04DStopTransferImage,     0x010c, 0x010f},
    {class04DSetContextDmaNotifies, 0x0180, 0x0183},
    {class04DSetContextDmaVbi,      0x0184, 0x018b},
    {class04DSetContextDmaImage,    0x018c, 0x0193},
    {class04DSetImageConfig,        0x02f8, 0x02fb},
    {class04DSetImageStartLine,     0x02fc, 0x02ff},
    {class04DSetVbi,                0x0300, 0x0317},
    {class04DGetVbiOffsetNotify,    0x0318, 0x031f},
    {class04DSetImage,              0x0320, 0x033f},
    {class04DGetImageOffsetNotify,  0x0340, 0x0347}
};
METHOD Nv3ExternalVideoDecompressorMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04ENotify,                0x0104, 0x0107},
    {class04EStopTransfer,          0x0108, 0x010b},
    {class04ESetContextDmaNotifies, 0x0180, 0x0183},
    {class04ESetContextDmaData,     0x0184, 0x018b},
    {class04ESetContextDmaImage,    0x018c, 0x0193},
    {class04EReadData,              0x0300, 0x0317},
    {class04EWriteImage,            0x0318, 0x033f}
};
METHOD Nv1ExternalParallelBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04FNotify,                0x0104, 0x0107},
    {class04FStopTransfer,          0x0108, 0x010b},
    {class04FSetContextDmaNotifies, 0x0180, 0x0183},
    {class04FWrite,                 0x0300, 0x030b},
    {class04FRead,                  0x030c, 0x0317},
    {class04FSetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv3ExternalMonitorBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class050Notify,                0x0104, 0x0107},
    {class050StopTransfer,          0x0108, 0x010b},
    {class050SetContextDmaNotifies, 0x0180, 0x0183},
    {class050Write,                 0x0300, 0x030b},
    {class050Read,                  0x030c, 0x0317},
    {class050SetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv4ExternalSerialBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class051Notify,                0x0104, 0x0107},
    {class051StopTransfer,          0x0108, 0x010b},
    {class051SetContextDmaNotifies, 0x0180, 0x0183},
    {class051Write,                 0x0300, 0x030b},
    {class051Read,                  0x030c, 0x0317},
    {class051SetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv3ContextSurface0Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class058Notify,                0x0104, 0x0107},
    {class058SetContextDmaNotifies, 0x0180, 0x0183},
    {class058SetContextDmaImage,    0x0184, 0x0187},
    {class058SetColorFormat,        0x0300, 0x0303},
    {class058SetImagePitch,         0x0308, 0x030b},
    {class058SetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface1Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class059Notify,                0x0104, 0x0107},
    {class059SetContextDmaNotifies, 0x0180, 0x0183},
    {class059SetContextDmaImage,    0x0184, 0x0187},
    {class059SetColorFormat,        0x0300, 0x0303},
    {class059SetImagePitch,         0x0308, 0x030b},
    {class059SetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface2Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05ANotify,                0x0104, 0x0107},
    {class05ASetContextDmaNotifies, 0x0180, 0x0183},
    {class05ASetContextDmaImage,    0x0184, 0x0187},
    {class05ASetColorFormat,        0x0300, 0x0303},
    {class05ASetImagePitch,         0x0308, 0x030b},
    {class05ASetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface3Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05BNotify,                0x0104, 0x0107},
    {class05BSetContextDmaNotifies, 0x0180, 0x0183},
    {class05BSetContextDmaImage,    0x0184, 0x0187},
    {class05BSetColorFormat,        0x0300, 0x0303},
    {class05BSetImagePitch,         0x0308, 0x030b},
    {class05BSetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextRopMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class043Notify,                0x0104, 0x0107},
    {class043SetContextDmaNotifies, 0x0180, 0x0183},
    {class043SetRop5,               0x0300, 0x0303}
};
METHOD Nv4DvdSubpictureMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class038Notify,                0x0104, 0x0107},
    {class038SetContextDmaNotifies, 0x0180, 0x0183},
    {class038SetContextDmaOverlay,  0x0184, 0x0187},
    {class038SetContextDmaImageIn,  0x0188, 0x018b},
    {class038SetContextDmaImageOut, 0x018c, 0x018f},
    {class038ImageOutPoint,         0x0300, 0x0303},
    {class038ImageOutSize,          0x0304, 0x0307},
    {class038ImageOutFormat,        0x0308, 0x030b},
    {class038ImageOutOffset,        0x030c, 0x030f},
    {class038ImageInDeltaDuDx,      0x0310, 0x0313},
    {class038ImageInDeltaDvDy,      0x0314, 0x0317},
    {class038ImageInSize,           0x0318, 0x031b},
    {class038ImageInFormat,         0x031c, 0x031f},
    {class038ImageInOffset,         0x0320, 0x0323},
    {class038ImageInPoint,          0x0324, 0x0317},
    {class038OverlayDeltaDuDx,      0x0328, 0x032b},
    {class038OverlayDeltaDvDy,      0x032c, 0x032f},
    {class038OverlaySize,           0x0330, 0x0333},
    {class038OverlayFormat,         0x0334, 0x0337},
    {class038OverlayOffset,         0x0338, 0x033b},
    {class038OverlayPoint,          0x033c, 0x033f}
};
METHOD Nv4ContextSurfaces2DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class042Notify,                0x0104, 0x0107},
    {class042SetContextDmaNotifies, 0x0180, 0x0183},
    {class042SetContextDmaSource,   0x0184, 0x0187},
    {class042SetContextDmaDestin,   0x0188, 0x018b},
    {class042SetColorFormat,        0x0300, 0x0303},
    {class042SetPitch,              0x0304, 0x0307},
    {class042SetOffsetSource,       0x0308, 0x030b},
    {class042SetOffsetDestin,       0x030c, 0x030f}
};
METHOD Nv4ContextPatternMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class044Notify,                0x0104, 0x0107},
    {class044SetContextDmaNotifies, 0x0180, 0x0183},
    {class044SetColorFormat,        0x0300, 0x0303},
    {class044SetMonochromeFormat,   0x0304, 0x0307},
    {class044SetMonochromeShape,    0x0308, 0x030b},
    {class044SetPatternSelect,      0x030c, 0x030f},
    {class044SetMonochromeColor,    0x0310, 0x0317},
    {class044SetMonochromePattern,  0x0318, 0x031f},
    {class044SetPatternY8,          0x0400, 0x043f},
    {class044SetPatternR5G6B5,      0x0500, 0x057f},
    {class044SetPatternX8R8G8B8,    0x0700, 0x07ff}
};
METHOD Nv4GDIRectangleTextMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04ANotify,                0x0104, 0x0107},
    {class04ASetContextDmaNotifies, 0x0180, 0x0183},
    {class04ASetContextFonts,       0x0184, 0x0187},
    {class04ASetContextPattern,     0x0188, 0x018b},
    {class04ASetContextRop,         0x018c, 0x018f},
    {class04ASetContextBeta1,       0x0190, 0x0193},
    {class04ASetContextBeta4,       0x0194, 0x0197},
    {class04ASetContextSurface,     0x0198, 0x019b},
    {class04ASetOperation,          0x02fc, 0x02ff},
    {class04ASetColorFormat,        0x0300, 0x0303},
    {class04ASetMonochromeFormat,   0x0304, 0x0307},
    {class04AColor1A,               0x03fc, 0x03ff},
    {class04AUnclippedRectangle,    0x0400, 0x04ff},
    {class04AClipB,                 0x05f4, 0x05fb},
    {class04AColor1B,               0x05fc, 0x05ff},
    {class04AClippedRectangle,      0x0600, 0x06ff},
    {class04AClipC,                 0x07ec, 0x07f3},
    {class04AColor1C,               0x07f4, 0x07f7},
    {class04ASizeC,                 0x07f8, 0x07fb},
    {class04APointC,                0x07fc, 0x07ff},
    {class04AMonochromeColor1C,     0x0800, 0x09ff},
    {class04AClipE,                 0x0be4, 0x0beb},
    {class04AColor0E,               0x0bec, 0x0bef},
    {class04AColor1E,               0x0bf0, 0x0bf3},
    {class04ASizeInE,               0x0bf4, 0x0bf7},
    {class04ASizeOutE,              0x0bf8, 0x0bfb},
    {class04APointE,                0x0bfc, 0x0bff},
    {class04AMonochromeColor01E,    0x0c00, 0x0dff},
    {class04AFontF,                 0x0ff0, 0x0ff3},
    {class04AClipF,                 0x0ff4, 0x0ffb},
    {class04AColor1F,               0x0ffc, 0x0fff},
    {class04ACharacterColor1F,      0x1000, 0x13ff},
    {class04AFontG,                 0x17f0, 0x17f3},
    {class04AClipG,                 0x17f4, 0x17fb},
    {class04AColor1G,               0x17fc, 0x17ff},
    {class04ACharacterColor1G,      0x1800, 0x1fff}
};
METHOD Nv4ContextSurfaceSwizzledMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class052Notify,                0x0104, 0x0107},
    {class052SetContextDmaNotifies, 0x0180, 0x0183},
    {class052SetContextDmaImage,    0x0184, 0x0187},
    {class052SetFormat,             0x0300, 0x0303},
    {class052SetOffset,             0x0304, 0x0307}
};
METHOD Nv4ContextSurfacesArgbZsMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class053Notify,                0x0104, 0x0107},
    {class053SetContextDmaNotifies, 0x0180, 0x0183},
    {class053SetContextDmaColor,    0x0184, 0x0187},
    {class053SetContextDmaZeta,     0x0188, 0x018b},
    {class053SetClipHorizontal,     0x02f8, 0x02fb},
    {class053SetClipVertical,       0x02fc, 0x02ff},
    {class053SetFormat,             0x0300, 0x0303},
    {class053SetClipSize,           0x0304, 0x0307},
    {class053SetPitch,              0x0308, 0x030b},
    {class053SetOffsetColor,        0x030c, 0x030f},
    {class053SetOffsetZeta,         0x0310, 0x0313}
};
METHOD Nv4DX5TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class054Notify,                0x0104, 0x0107},
    {class054SetContextDmaNotifies, 0x0180, 0x0183},
    {class054SetContextDmaA,        0x0184, 0x0187},
    {class054SetContextDmaB,        0x0188, 0x018b},
    {class054SetContextSurface,     0x018c, 0x018f},
    {class054ColorKey,              0x0300, 0x0303},
    {class054Offset,                0x0304, 0x0307},
    {class054Format,                0x0308, 0x030b},
    {class054Filter,                0x030c, 0x030f},
    {class054Blend,                 0x0310, 0x0313},
    {class054Control,               0x0314, 0x0317},
    {class054FogColor,              0x0318, 0x031b},
    {class054Tlvertex,              0x0400, 0x05ff},
    {class054DrawPrimitive,         0x0600, 0x06ff}
};
METHOD Nv4DX6MultiTextureTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class055Notify,                0x0104, 0x0107},
    {class055SetContextDmaNotifies, 0x0180, 0x0183},
    {class055SetContextDmaA,        0x0184, 0x0187},
    {class055SetContextDmaB,        0x0188, 0x018b},
    {class055SetContextSurface,     0x018c, 0x018f},
    {class055Offset,                0x0308, 0x030f},
    {class055Format,                0x0310, 0x0317},
    {class055Filter,                0x0318, 0x031f},
    {class055Combine0Alpha,         0x0320, 0x0323},
    {class055Combine0Color,         0x0324, 0x0327},
    {class055Combine1Alpha,         0x032c, 0x032f},
    {class055Combine1Color,         0x0330, 0x0333},
    {class055CombineFactor,         0x0334, 0x0337},
    {class055Blend,                 0x0338, 0x033b},
    {class055Control,               0x033c, 0x0347},
    {class055FogColor,              0x0348, 0x034b},
    {class055Tlmtvertex,            0x0400, 0x053f},
    {class055DrawPrimitive,         0x0540, 0x05ff}
};
METHOD Nv10CelsiusPrimitiveMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class056Notify,                0x0104, 0x0107},
    {class056SetWarningEnable,      0x0108, 0x010b},
    //{class056GetState,              0x010c, 0x010f},
    {class056WaitForIdle,           0x0110, 0x0113},
    {class056PMTrigger,             0x0140, 0x0143},
    {class056SetContextDmaNotifies, 0x0180, 0x0183},
    {class056SetContextDmaA,        0x0184, 0x0187},
    {class056SetContextDmaB,        0x0188, 0x018b},
    {class056SetContextDmaVertex,   0x018c, 0x018f},
    {class056SetContextDmaState,    0x0190, 0x0193},
    {class056SetContextDmaColor,    0x0194, 0x0197},
    {class056SetContextDmaZeta,     0x0198, 0x019b},
    {class056MethodCatcher,         0x019c, 0x17ff},    // catch any in between methods
    //{class056SetMaterialEmission,   0x1628, 0x1633},    // HW workaround for NV10
    //{class056MethodCatcher,         0x1634, 0x17ff},    // catch any in between methods
    {class056InlineArray,           0x1800, 0x1fff},
};
METHOD Nv4ContextColorKeyMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class057Notify,                0x0104, 0x0107},
    {class057SetContextDmaNotifies, 0x0180, 0x0183},
    {class057SetColorFormat,        0x0300, 0x0303},
    {class057SetColor,              0x0304, 0x0307}
};
METHOD Nv4RenderSolidLinMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05CNotify,                0x0104, 0x0107},
    {class05CSetContextDmaNotifies, 0x0180, 0x0183},
    {class05CSetContextClip,        0x0184, 0x0187},
    {class05CSetContextPattern,     0x0188, 0x018b},
    {class05CSetContextRop,         0x018c, 0x018f},
    {class05CSetContextBeta1,       0x0190, 0x0193},
    {class05CSetContextBeta4,       0x0194, 0x0197},
    {class05CSetContextSurface,     0x0198, 0x019b},
    {class05CSetOperation,          0x02fc, 0x02ff},
    {class05CSetColorFormat,        0x0300, 0x0303},
    {class05CColor,                 0x0304, 0x0307},
    {class05CLin,                   0x0400, 0x047f},
    {class05CLin32,                 0x0480, 0x04ff},
    {class05CPolyLin,               0x0500, 0x057f},
    {class05CPolyLin32,             0x0580, 0x05ff},
    {class05CColorPolyLin,          0x0600, 0x067f}
};
METHOD Nv4RenderSolidTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05DNotify,                0x0104, 0x0107},
    {class05DSetContextDmaNotifies, 0x0180, 0x0183},
    {class05DSetContextClip,        0x0184, 0x0187},
    {class05DSetContextPattern,     0x0188, 0x018b},
    {class05DSetContextRop,         0x018c, 0x018f},
    {class05DSetContextBeta1,       0x0190, 0x0193},
    {class05DSetContextBeta4,       0x0194, 0x0197},
    {class05DSetContextSurface,     0x0198, 0x019b},
    {class05DSetOperation,          0x02fc, 0x02ff},
    {class05DSetColorFormat,        0x0300, 0x0303},
    {class05DColor,                 0x0304, 0x0307},
    {class05DTriangle,              0x0310, 0x031b},
    {class05DTriangle32,            0x0320, 0x0337},
    {class05DTrimesh,               0x0400, 0x047f},
    {class05DTrimesh32,             0x0480, 0x04ff},
    {class05DColorTriangle,         0x0500, 0x057f},
    {class05DColorTrimesh,          0x0580, 0x05ff}
};
METHOD Nv4RenderSolidRectangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05ENotify,                0x0104, 0x0107},
    {class05ESetContextDmaNotifies, 0x0180, 0x0183},
    {class05ESetContextClip,        0x0184, 0x0187},
    {class05ESetContextPattern,     0x0188, 0x018b},
    {class05ESetContextRop,         0x018c, 0x018f},
    {class05ESetContextBeta1,       0x0190, 0x0193},
    {class05ESetContextBeta4,       0x0194, 0x0197},
    {class05ESetContextSurface,     0x0198, 0x019b},
    {class05ESetOperation,          0x02fc, 0x02ff},
    {class05ESetColorFormat,        0x0300, 0x0303},
    {class05EColor,                 0x0304, 0x0307},
    {class05ERectangle,             0x0400, 0x047f}
};
METHOD Nv4ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05FNotify,                0x0104, 0x0107},
    {class05FSetContextDmaNotifies, 0x0180, 0x0183},
    {class05FSetContextColorKey,    0x0184, 0x0187},
    {class05FSetContextClip,        0x0188, 0x018b},
    {class05FSetContextPattern,     0x018c, 0x018f},
    {class05FSetContextRop,         0x0190, 0x0193},
    {class05FSetContextBeta1,       0x0194, 0x0197},
    {class05FSetContextBeta4,       0x0198, 0x019b},
    {class05FSetContextSurfaces2d,  0x019c, 0x019f},
    {class05FSetOperation,          0x02fc, 0x02ff},
    {class05FControlPointIn,        0x0300, 0x0303},
    {class05FControlPointOut,       0x0304, 0x0307},
    {class05FSize,                  0x0308, 0x030b}
};
METHOD Nv4IndexedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class060Notify,                0x0104, 0x0107},
    {class060SetContextDmaNotifies, 0x0180, 0x0183},
    {class060SetContextDmaLut,      0x0184, 0x0187},
    {class060SetContextColorKey,    0x0188, 0x018b},
    {class060SetContextClip,        0x018c, 0x018f},
    {class060SetContextPattern,     0x0190, 0x0193},
    {class060SetContextRop,         0x0194, 0x0197},
    {class060SetContextBeta1,       0x0198, 0x019b},
    {class060SetContextBeta4,       0x019c, 0x019f},
    {class060SetContextSurface,     0x01a0, 0x01a3},
    {class060SetColorConversion,    0x03e0, 0x03e3},
    {class060SetOperation,          0x03e4, 0x03e7},
    {class060SetColorFormat,        0x03e8, 0x03eb},
    {class060IndexFormat,           0x03ec, 0x03ef},
    {class060LutOffset,             0x03f0, 0x03f3},
    {class060Point,                 0x03f4, 0x03f7},
    {class060SizeOut,               0x03f8, 0x03fb},
    {class060SizeIn,                0x03fc, 0x03ff},
    {class060Indices,               0x0400, 0x1fff}
};
METHOD Nv4ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class061Notify,                0x0104, 0x0107},
    {class061SetContextDmaNotifies, 0x0180, 0x0183},
    {class061SetContextColorKey,    0x0184, 0x0187},
    {class061SetContextClip,        0x0188, 0x018b},
    {class061SetContextPattern,     0x018c, 0x018f},
    {class061SetContextRop,         0x0190, 0x0193},
    {class061SetContextBeta1,       0x0194, 0x0197},
    {class061SetContextBeta4,       0x0198, 0x019b},
    {class061SetContextSurface,     0x019c, 0x019f},
    {class061SetOperation,          0x02fc, 0x02ff},
    {class061SetColorFormat,        0x0300, 0x0303},
    {class061Point,                 0x0304, 0x0307},
    {class061SizeOut,               0x0308, 0x030b},
    {class061SizeIn,                0x030c, 0x030f},
    {class061Color,                 0x0400, 0x1fff}
};

METHOD Nv5ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class063Notify,                0x0104, 0x0107},
    {class063SetContextDmaNotifies, 0x0180, 0x0183},
    {class063SetContextDmaImage,    0x0184, 0x0187},
    {class063SetContextPattern,     0x0188, 0x018b},
    {class063SetContextRop,         0x018c, 0x018f},
    {class063SetContextBeta1,       0x0190, 0x0193},
    {class063SetContextBeta4,       0x0194, 0x0197},
    {class063SetContextSurface,     0x0198, 0x019b},
    {class063SetColorConversion,    0x02fc, 0x02ff},
    {class063SetColorFormat,        0x0300, 0x0303},
    {class063SetOperation,          0x0304, 0x0307},
    {class063Clip,                  0x0308, 0x030f},
    {class063RectangleOut,          0x0310, 0x0317},
    {class063DeltaDuDx,             0x0318, 0x031b},
    {class063DeltaDvDy,             0x031c, 0x031f},
    {class063ImageIn,               0x0400, 0x040f}
};

METHOD Nv5IndexedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class064Notify,                0x0104, 0x0107},
    {class064SetContextDmaNotifies, 0x0180, 0x0183},
    {class064SetContextDmaLut,      0x0184, 0x0187},
    {class064SetContextColorKey,    0x0188, 0x018b},
    {class064SetContextClip,        0x018c, 0x018f},
    {class064SetContextPattern,     0x0190, 0x0193},
    {class064SetContextRop,         0x0194, 0x0197},
    {class064SetContextBeta1,       0x0198, 0x019b},
    {class064SetContextBeta4,       0x019c, 0x019f},
    {class064SetContextSurface,     0x01a0, 0x01a3},
    {class064SetColorConversion,    0x03e0, 0x03e3},
    {class064SetOperation,          0x03e4, 0x03e7},
    {class064SetColorFormat,        0x03e8, 0x03eb},
    {class064IndexFormat,           0x03ec, 0x03ef},
    {class064LutOffset,             0x03f0, 0x03f3},
    {class064Point,                 0x03f4, 0x03f7},
    {class064SizeOut,               0x03f8, 0x03fb},
    {class064SizeIn,                0x03fc, 0x03ff},
    {class064Indices,               0x0400, 0x1fff}
};

METHOD Nv5ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class065Notify,                0x0104, 0x0107},
    {class065SetContextDmaNotifies, 0x0180, 0x0183},
    {class065SetContextColorKey,    0x0184, 0x0187},
    {class065SetContextClip,        0x0188, 0x018b},
    {class065SetContextPattern,     0x018c, 0x018f},
    {class065SetContextRop,         0x0190, 0x0193},
    {class065SetContextBeta1,       0x0194, 0x0197},
    {class065SetContextBeta4,       0x0198, 0x019b},
    {class065SetContextSurface,     0x019c, 0x019f},
    {class065SetColorConversion,    0x02f8, 0x02fb},
    {class065SetOperation,          0x02fc, 0x02ff},
    {class065SetColorFormat,        0x0300, 0x0303},
    {class065Point,                 0x0304, 0x0307},
    {class065SizeOut,               0x0308, 0x030b},
    {class065SizeIn,                0x030c, 0x030f},
    {class065Color,                 0x0400, 0x1fff}
};
METHOD Nv5StretchedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class066Notify,                0x0104, 0x0107},
    {class066SetContextDmaNotifies, 0x0180, 0x0183},
    {class066SetContextColorKey,    0x0184, 0x0187},
    {class066SetContextPattern,     0x0188, 0x018b},
    {class066SetContextRop,         0x018c, 0x018f},
    {class066SetContextBeta1,       0x0190, 0x0193},
    {class066SetContextBeta4,       0x0194, 0x0197},
    {class066SetContextSurface,     0x0198, 0x019b},
    {class066SetColorConversion,    0x02f8, 0x02fb},
    {class066SetOperation,          0x02fc, 0x02ff},
    {class066SetColorFormat,        0x0300, 0x0303},
    {class066SizeIn,                0x0304, 0x0307},
    {class066DeltaDxDu,             0x0308, 0x030b},
    {class066DeltaDyDv,             0x030c, 0x030f},
    {class066Clip,                  0x0310, 0x0317},
    {class066Point12d4,             0x0318, 0x031b},
    {class066Color,                 0x0400, 0x1fff}
};
METHOD Nv4ContextBetaMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class072Notify,                0x0104, 0x0107},
    {class072SetContextDmaNotifies, 0x0180, 0x0183},
    {class072SetBetaFactor,         0x0300, 0x0303}
};
METHOD Nv4StretchedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class076Notify,                0x0104, 0x0107},
    {class076SetContextDmaNotifies, 0x0180, 0x0183},
    {class076SetContextColorKey,    0x0184, 0x0187},
    {class076SetContextPattern,     0x0188, 0x018b},
    {class076SetContextRop,         0x018c, 0x018f},
    {class076SetContextBeta1,       0x0190, 0x0193},
    {class076SetContextBeta4,       0x0194, 0x0197},
    {class076SetContextSurface,     0x0198, 0x019b},
    {class076SetOperation,          0x02fc, 0x02ff},
    {class076SetColorFormat,        0x0300, 0x0303},
    {class076SizeIn,                0x0304, 0x0307},
    {class076DeltaDxDu,             0x0308, 0x030b},
    {class076DeltaDyDv,             0x030c, 0x030f},
    {class076Clip,                  0x0310, 0x0317},
    {class076Point12d4,             0x0318, 0x031b},
    {class076Color,                 0x0400, 0x1fff}
};
METHOD Nv4ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class077Notify,                0x0104, 0x0107},
    {class077SetContextDmaNotifies, 0x0180, 0x0183},
    {class077SetContextDmaImage,    0x0184, 0x0187},
    {class077SetContextPattern,     0x0188, 0x018b},
    {class077SetContextRop,         0x018c, 0x018f},
    {class077SetContextBeta1,       0x0190, 0x0193},
    {class077SetContextBeta4,       0x0194, 0x0197},
    {class077SetContextSurface,     0x0198, 0x019b},
    {class077SetColorFormat,        0x0300, 0x0303},
    {class077SetOperation,          0x0304, 0x0307},
    {class077Clip,                  0x0308, 0x030f},
    {class077RectangleOut,          0x0310, 0x0317},
    {class077DeltaDuDx,             0x0318, 0x031b},
    {class077DeltaDvDy,             0x031c, 0x031f},
    {class077ImageIn,               0x0400, 0x040f}
};
METHOD Nv10ContextSurfaces2DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class062Notify,                0x0104, 0x0107},
    {class062SetContextDmaNotifies, 0x0180, 0x0183},
    {class062SetContextDmaSource,   0x0184, 0x0187},
    {class062SetContextDmaDestin,   0x0188, 0x018b},
    {class062SetColorFormat,        0x0300, 0x0303},
    {class062SetPitch,              0x0304, 0x0307},
    {class062SetOffsetSource,       0x0308, 0x030b},
    {class062SetOffsetDestin,       0x030c, 0x030f}
};
METHOD Nv10TextureFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07BNotify,                0x0104, 0x0107},
    {class07BSetContextDmaNotifies, 0x0180, 0x0183},
    {class07BSetContextSurface,     0x0184, 0x0187},
    {class07BSetColorFormat,        0x0300, 0x0303},
    {class07BPoint,                 0x0304, 0x0307},
    {class07BSize,                  0x0308, 0x030b},
    {class07BClipHorizontal,        0x030c, 0x030f},
    {class07BClipVertical,          0x0310, 0x0313},
    {class07BColor,                 0x0400, 0x1fff}
};
METHOD Nv10DvdSubpictureMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class088Notify,                0x0104, 0x0107},
    {class088SetContextDmaNotifies, 0x0180, 0x0183},
    {class088SetContextDmaOverlay,  0x0184, 0x0187},
    {class088SetContextDmaImageIn,  0x0188, 0x018b},
    {class088SetContextDmaImageOut, 0x018c, 0x018f},
    {class088ImageOutPoint,         0x0300, 0x0303},
    {class088ImageOutSize,          0x0304, 0x0307},
    {class088ImageOutFormat,        0x0308, 0x030b},
    {class088ImageOutOffset,        0x030c, 0x030f},
    {class088ImageInDeltaDuDx,      0x0310, 0x0313},
    {class088ImageInDeltaDvDy,      0x0314, 0x0317},
    {class088ImageInSize,           0x0318, 0x031b},
    {class088ImageInFormat,         0x031c, 0x031f},
    {class088ImageInOffset,         0x0320, 0x0323},
    {class088ImageInPoint,          0x0324, 0x0317},
    {class088OverlayDeltaDuDx,      0x0328, 0x032b},
    {class088OverlayDeltaDvDy,      0x032c, 0x032f},
    {class088OverlaySize,           0x0330, 0x0333},
    {class088OverlayFormat,         0x0334, 0x0337},
    {class088OverlayOffset,         0x0338, 0x033b},
    {class088OverlayPoint,          0x033c, 0x033f}
};
METHOD Nv10ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class089Notify,                0x0104, 0x0107},
    {class089SetContextDmaNotifies, 0x0180, 0x0183},
    {class089SetContextDmaImage,    0x0184, 0x0187},
    {class089SetContextPattern,     0x0188, 0x018b},
    {class089SetContextRop,         0x018c, 0x018f},
    {class089SetContextBeta1,       0x0190, 0x0193},
    {class089SetContextBeta4,       0x0194, 0x0197},
    {class089SetContextSurface,     0x0198, 0x019b},
    {class089SetColorConversion,    0x02fc, 0x02ff},
    {class089SetColorFormat,        0x0300, 0x0303},
    {class089SetOperation,          0x0304, 0x0307},
    {class089Clip,                  0x0308, 0x030f},
    {class089RectangleOut,          0x0310, 0x0317},
    {class089DeltaDuDx,             0x0318, 0x031b},
    {class089DeltaDvDy,             0x031c, 0x031f},
    {class089ImageIn,               0x0400, 0x040f}
};
METHOD Nv10ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class08ANotify,                0x0104, 0x0107},
    {class08ASetContextDmaNotifies, 0x0180, 0x0183},
    {class08ASetContextColorKey,    0x0184, 0x0187},
    {class08ASetContextClip,        0x0188, 0x018b},
    {class08ASetContextPattern,     0x018c, 0x018f},
    {class08ASetContextRop,         0x0190, 0x0193},
    {class08ASetContextBeta1,       0x0194, 0x0197},
    {class08ASetContextBeta4,       0x0198, 0x019b},
    {class08ASetContextSurface,     0x019c, 0x019f},
    {class08ASetColorConversion,    0x02f8, 0x02fb},
    {class08ASetOperation,          0x02fc, 0x02ff},
    {class08ASetColorFormat,        0x0300, 0x0303},
    {class08APoint,                 0x0304, 0x0307},
    {class08ASizeOut,               0x0308, 0x030b},
    {class08ASizeIn,                0x030c, 0x030f},
    {class08AColor,                 0x0400, 0x1fff}
};
METHOD Nv10ContextSurfaces3DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class093Notify,                0x0104, 0x0107},
    {class093SetContextDmaNotifies, 0x0180, 0x0183},
    {class093SetContextDmaColor,    0x0184, 0x0187},
    {class093SetContextDmaZeta,     0x0188, 0x018b},
    {class093SetClipHorizontal,     0x02f8, 0x02fb},
    {class093SetClipVertical,       0x02fc, 0x02ff},
    {class093SetFormat,             0x0300, 0x0303},
    {class093SetClipSize,           0x0304, 0x0307},
    {class093SetPitch,              0x0308, 0x030b},
    {class093SetOffsetColor,        0x030c, 0x030f},
    {class093SetOffsetZeta,         0x0310, 0x0313}
};
METHOD Nv10DX5TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class094Notify,                0x0104, 0x0107},
    {class094SetContextDmaNotifies, 0x0180, 0x0183},
    {class094SetContextDmaA,        0x0184, 0x0187},
    {class094SetContextDmaB,        0x0188, 0x018b},
    {class094SetContextSurface,     0x018c, 0x018f},
    {class094ColorKey,              0x0300, 0x0303},
    {class094Offset,                0x0304, 0x0307},
    {class094Format,                0x0308, 0x030b},
    {class094Filter,                0x030c, 0x030f},
    {class094Blend,                 0x0310, 0x0313},
    {class094Control,               0x0314, 0x0317},
    {class094FogColor,              0x0318, 0x031b},
    {class094Tlvertex,              0x0400, 0x05ff},
    {class094DrawPrimitive,         0x0600, 0x06ff}
};
METHOD Nv10DX6MultiTextureTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class095Notify,                0x0104, 0x0107},
    {class095SetContextDmaNotifies, 0x0180, 0x0183},
    {class095SetContextDmaA,        0x0184, 0x0187},
    {class095SetContextDmaB,        0x0188, 0x018b},
    {class095SetContextSurface,     0x018c, 0x018f},
    {class095Offset,                0x0308, 0x030f},
    {class095Format,                0x0310, 0x0317},
    {class095Filter,                0x0318, 0x031f},
    {class095Combine0Alpha,         0x0320, 0x0323},
    {class095Combine0Color,         0x0324, 0x0327},
    {class095Combine1Alpha,         0x032c, 0x032f},
    {class095Combine1Color,         0x0330, 0x0333},
    {class095CombineFactor,         0x0334, 0x0337},
    {class095Blend,                 0x0338, 0x033b},
    {class095Control,               0x033c, 0x0347},
    {class095FogColor,              0x0348, 0x034b},
    {class095Tlmtvertex,            0x0400, 0x053f},
    {class095DrawPrimitive,         0x0540, 0x05ff}
};
METHOD Nv15CelsiusPrimitiveMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class096Notify,                0x0104, 0x0107},
    {class096SetWarningEnable,      0x0108, 0x010b},
    //{class096GetState,              0x010c, 0x010f},
    {class096WaitForIdle,           0x0110, 0x0113},
    {class096SyncSetRead,           0x0120, 0x0123},
    {class096SyncSetWrite,          0x0124, 0x0127},
    {class096SyncSetModulo,         0x0128, 0x012b},
    {class096SyncIncrementWrite,    0x012c, 0x012f},
    {class096SyncStall,             0x0130, 0x0133},
    {class096PMTrigger,             0x0140, 0x0143},
    {class096SetContextDmaNotifies, 0x0180, 0x0183},
    {class096SetContextDmaA,        0x0184, 0x0187},
    {class096SetContextDmaB,        0x0188, 0x018b},
    {class096SetContextDmaVertex,   0x018c, 0x018f},
    {class096SetContextDmaState,    0x0190, 0x0193},
    {class096SetContextDmaColor,    0x0194, 0x0197},
    {class096SetContextDmaZeta,     0x0198, 0x019b},
    //...
    // for now, catch anything in between
    {class096MethodCatcher,         0x0200, 0x17ff},
    //...
    {class096InlineArray,           0x1800, 0x1fff},
    {class096DebugInit,             0x2000, 0x2027}
};
METHOD Nv15ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class09FNotify,                0x0104, 0x0107},
    {class09FSyncSetRead,           0x0120, 0x0123},
    {class09FSyncSetWrite,          0x0124, 0x0127},
    {class09FSyncSetModulo,         0x0128, 0x012b},
    {class09FSyncIncrementWrite,    0x012c, 0x012f},
    {class09FSyncStall,             0x0130, 0x0133},
    {class09FSyncIncrementReadRange,0x0134, 0x0137},
    {class09FSetContextDmaNotifies, 0x0180, 0x0183},
    {class09FSetContextColorKey,    0x0184, 0x0187},
    {class09FSetContextClip,        0x0188, 0x018b},
    {class09FSetContextPattern,     0x018c, 0x018f},
    {class09FSetContextRop,         0x0190, 0x0193},
    {class09FSetContextBeta1,       0x0194, 0x0197},
    {class09FSetContextBeta4,       0x0198, 0x019b},
    {class09FSetContextSurfaces2d,  0x019c, 0x019f},
    {class09FSetOperation,          0x02fc, 0x02ff},
    {class09FControlPointIn,        0x0300, 0x0303},
    {class09FControlPointOut,       0x0304, 0x0307},
    {class09FSize,                  0x0308, 0x030b}
};

//
// These classes are supported across all chips.
//
CLASSDESCRIPTOR Common_ClassDescriptors[] =
{
    MKCLASSDECL(TMR_ENGINE_TAG, 0, NV01_TIMER),

    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_COLOR_KEY),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_SCALER),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_FROM_MEMORY),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_COLORMAP),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_SINK),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_PATCHCORD_VIDEO),

    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_FROM_MEMORY),
    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_TO_MEMORY),
    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_IN_MEMORY),

    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_SYSTEM),
    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_LOCAL_PRIVILEGED),
    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_LOCAL_USER),

    // MAKE THIS LAST !!!!
    MKCLASSDECL(CLASS_PSEUDO_ENGINE_TAG, 0, NV_CLASS),
};

#define NUM_COMMONCLASSDESCRIPTORS          (sizeof (Common_ClassDescriptors) / sizeof (CLASSDESCRIPTOR))

CLASSMETHODS classMethodsTable[] =
{
    {NV1_CLASS,                             NULL, 0},

    {NV1_CONTEXT_DMA_FROM_MEMORY,           NULL, 0},

    {NV1_CONTEXT_DMA_TO_MEMORY,             NULL, 0},

    {NV1_TIMER,                             Nv1TimerMethods,
                                            sizeof(Nv1TimerMethods)/sizeof(METHOD)},

    {NV1_BETA_SOLID,                        Nv1BetaSolidMethods,
                                            sizeof(Nv1BetaSolidMethods)/sizeof(METHOD)},

    {NV1_IMAGE_SOLID,                       Nv1ImageSolidMethods,
                                            sizeof(Nv1ImageSolidMethods)/sizeof(METHOD)},

    {NV1_IMAGE_PATTERN,                     Nv1ImagePatternMethods,
                                            sizeof(Nv1ImagePatternMethods)/sizeof(METHOD)},

    {NV1_IMAGE_BLACK_RECTANGLE,             Nv1ImageRectangleBlackMethods,
                                            sizeof(Nv1ImageRectangleBlackMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_LIN,                  Nv1RenderSolidLinMethods,
                                            sizeof(Nv1RenderSolidLinMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_TRIANGLE,             Nv1RenderSolidTriangleMethods,
                                            sizeof(Nv1RenderSolidTriangleMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_RECTANGLE,            Nv1RenderSolidRectangleMethods,
                                            sizeof(Nv1RenderSolidRectangleMethods)/sizeof(METHOD)},

    {NV1_IMAGE_BLIT,                        Nv1ImageBlitMethods,
                                            sizeof(Nv1ImageBlitMethods)/sizeof(METHOD)},

    {NV1_IMAGE_FROM_CPU,                    Nv1ImageFromCpuMethods,
                                            sizeof(Nv1ImageFromCpuMethods)/sizeof(METHOD)},

    {NV1_NULL,                              NULL, 0},

    {NV3_STRETCHED_IMAGE_FROM_CPU,          Nv3StretchedImageFromCPUMethods,
                                            sizeof(Nv3StretchedImageFromCPUMethods)/sizeof(METHOD)},


    {NV3_SCALED_IMAGE_FROM_MEMORY,          Nv3ScaledImageFromMemoryMethods,
                                            sizeof(Nv3ScaledImageFromMemoryMethods)/sizeof(METHOD)},

                                            
    {NV3_MEMORY_TO_MEMORY_FORMAT,           Nv3MemoryToMemoryFormatMethods,
                                            sizeof(Nv3MemoryToMemoryFormatMethods)/sizeof(METHOD)},
                                            
    {NV1_CONTEXT_DMA_IN_MEMORY,             NULL, 0},

    {NV_CONTEXT_ERROR_TO_MEMORY,            NULL, 0},

    {NV1_CONTEXT_ERROR_TO_MEMORY,           NULL, 0},

    {NV1_MEMORY_PRIVILEGED,                 NULL, 0},

    {NV1_MEMORY_USER,                       NULL, 0},

    {NV3_CONTEXT_ROP,                       Nv3ContextRopMethods,
                                            sizeof(Nv3ContextRopMethods)/sizeof(METHOD)},

    {NV04_VIDEO_LUT_CURSOR_DAC,             Nv04VideoLUTCursorDACMethods,
                                            sizeof(Nv04VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV04_VIDEO_OVERLAY,                    Nv04VideoOverlayMethods,
                                            sizeof(Nv04VideoOverlayMethods)/sizeof(METHOD)},

    {NV3_DX3_TEXTURED_TRIANGLE,             Nv3DX3TexturedTriangleMethods,
                                            sizeof(Nv3DX3TexturedTriangleMethods)/sizeof(METHOD)},

    {NV05_VIDEO_LUT_CURSOR_DAC,             Nv05VideoLUTCursorDACMethods,        
                                            sizeof(Nv05VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV3_GDI_RECTANGLE_TEXT,                Nv3GDIRectangleTextMethods,   
                                            sizeof(Nv3GDIRectangleTextMethods)/sizeof(METHOD)},

    {NV03_EXTERNAL_VIDEO_DECODER,           Nv3ExternalVideoDecoderMethods,
                                            sizeof(Nv3ExternalVideoDecoderMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_VIDEO_DECOMPRESSOR,       Nv3ExternalVideoDecompressorMethods,   
                                            sizeof(Nv3ExternalVideoDecompressorMethods)/sizeof(METHOD)},

    {NV1_EXTERNAL_PARALLEL_BUS,             Nv1ExternalParallelBusMethods,
                                            sizeof(Nv1ExternalParallelBusMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_MONITOR_BUS,              Nv3ExternalMonitorBusMethods,
                                            sizeof(Nv3ExternalMonitorBusMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_SERIAL_BUS,               Nv4ExternalSerialBusMethods,
                                            sizeof(Nv4ExternalSerialBusMethods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_0,                 Nv3ContextSurface0Methods,
                                            sizeof(Nv3ContextSurface0Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_1,                 Nv3ContextSurface1Methods,   
                                            sizeof(Nv3ContextSurface1Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_2,                 Nv3ContextSurface2Methods,   
                                            sizeof(Nv3ContextSurface2Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_3,                 Nv3ContextSurface3Methods,   
                                            sizeof(Nv3ContextSurface3Methods)/sizeof(METHOD)},

    {NV4_DVD_SUBPICTURE,                    Nv4DvdSubpictureMethods,
                                            sizeof(Nv4DvdSubpictureMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACES_2D,               Nv4ContextSurfaces2DMethods,
                                            sizeof(Nv4ContextSurfaces2DMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_PATTERN,                   Nv4ContextPatternMethods,
                                            sizeof(Nv4ContextPatternMethods)/sizeof(METHOD)},

    {NV4_GDI_RECTANGLE_TEXT,                Nv4GDIRectangleTextMethods,
                                            sizeof(Nv4GDIRectangleTextMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACE_SWIZZLED,          Nv4ContextSurfaceSwizzledMethods,
                                            sizeof(Nv4ContextSurfaceSwizzledMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACES_ARGB_ZS,          Nv4ContextSurfacesArgbZsMethods,
                                            sizeof(Nv4ContextSurfacesArgbZsMethods)/sizeof(METHOD)},

    {NV4_DX5_TEXTURED_TRIANGLE,             Nv4DX5TexturedTriangleMethods,
                                            sizeof(Nv4DX5TexturedTriangleMethods)/sizeof(METHOD)},

    {NV4_DX6_MULTI_TEXTURE_TRIANGLE,        Nv4DX6MultiTextureTriangleMethods,
                                            sizeof(Nv4DX6MultiTextureTriangleMethods)/sizeof(METHOD)},

    {NV10_CELSIUS_PRIMITIVE,                Nv10CelsiusPrimitiveMethods,
                                            sizeof(Nv10CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_COLOR_KEY,                 Nv4ContextColorKeyMethods,
                                            sizeof(Nv4ContextColorKeyMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_LIN,                  Nv4RenderSolidLinMethods,
                                            sizeof(Nv4RenderSolidLinMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_TRIANGLE,             Nv4RenderSolidTriangleMethods,
                                            sizeof(Nv4RenderSolidTriangleMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_RECTANGLE,            Nv4RenderSolidRectangleMethods,
                                            sizeof(Nv4RenderSolidRectangleMethods)/sizeof(METHOD)},

    {NV4_IMAGE_BLIT,                        Nv4ImageBlitMethods,
                                            sizeof(Nv4ImageBlitMethods)/sizeof(METHOD)},

    {NV4_INDEXED_IMAGE_FROM_CPU,            Nv4IndexedImageFromCpuMethods,   
                                            sizeof(Nv4IndexedImageFromCpuMethods)/sizeof(METHOD)},

    {NV4_IMAGE_FROM_CPU,                    Nv4ImageFromCpuMethods,   
                                            sizeof(Nv4ImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_SCALED_IMAGE_FROM_MEMORY,         Nv5ScaledImageFromMemoryMethods,   
                                            sizeof(Nv5ScaledImageFromMemoryMethods)/sizeof(METHOD)},

    {NV05_INDEXED_IMAGE_FROM_CPU,           Nv5IndexedImageFromCpuMethods,
                                            sizeof(Nv5IndexedImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_IMAGE_FROM_CPU,                   Nv5ImageFromCpuMethods,
                                            sizeof(Nv5ImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_STRETCHED_IMAGE_FROM_CPU,         Nv5StretchedImageFromCpuMethods,
                                            sizeof(Nv5StretchedImageFromCpuMethods)/sizeof(METHOD)},

    {NV10_VIDEO_LUT_CURSOR_DAC,             Nv10VideoLUTCursorDACMethods,
                                            sizeof(Nv10VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_BETA,                      Nv4ContextBetaMethods,
                                            sizeof(Nv4ContextBetaMethods)/sizeof(METHOD)},

    {NV4_STRETCHED_IMAGE_FROM_CPU,          Nv4StretchedImageFromCpuMethods,
                                            sizeof(Nv4StretchedImageFromCpuMethods)/sizeof(METHOD)},

    {NV4_SCALED_IMAGE_FROM_MEMORY,          Nv4ScaledImageFromMemoryMethods,
                                            sizeof(Nv4ScaledImageFromMemoryMethods)/sizeof(METHOD)},

    {NV_VIDEO_COLOR_KEY,                    NvVideoColorKeyMethods,
                                            sizeof(NvVideoColorKeyMethods)/sizeof(METHOD)},

    {NV_VIDEO_SCALER,                       NvVideoScalerMethods,
                                            sizeof(NvVideoScalerMethods)/sizeof(METHOD)},

    {NV_VIDEO_FROM_MEMORY,                  NvVideoFromMemoryMethods,
                                            sizeof(NvVideoFromMemoryMethods)/sizeof(METHOD)},

    {NV_VIDEO_COLORMAP,                     NvVideoColormapMethods,   
                                            sizeof(NvVideoColormapMethods)/sizeof(METHOD)},

    {NV_VIDEO_SINK,                         NvVideoSinkMethods,   
                                            sizeof(NvVideoSinkMethods)/sizeof(METHOD)},

    {NV_PATCHCORD_VIDEO,                    NvPatchcordMethods,
                                            sizeof(NvPatchcordMethods)/sizeof(METHOD)},

    {NV_CONTEXT_DMA_IN_MEMORY,              NvDmaInMemoryMethods,
                                            sizeof(NvDmaInMemoryMethods)/sizeof(METHOD)},
                                            
    {NV_CONTEXT_DMA_TO_MEMORY,              NvDmaToMemoryMethods,
                                            sizeof(NvDmaToMemoryMethods)/sizeof(METHOD)},
                                            
    {NV_CONTEXT_DMA_FROM_MEMORY,            NvDmaFromMemoryMethods,
                                            sizeof(NvDmaFromMemoryMethods)/sizeof(METHOD)},
                                            
    {NV10_CONTEXT_SURFACES_2D,              Nv10ContextSurfaces2DMethods,
                                            sizeof(Nv10ContextSurfaces2DMethods)/sizeof(METHOD)},

    {NV10_VIDEO_OVERLAY,                    Nv10VideoOverlayMethods,
                                            sizeof(Nv10VideoOverlayMethods)/sizeof(METHOD)},

    {NV10_TEXTURE_FROM_CPU,                 Nv10TextureFromCpuMethods,
                                            sizeof(Nv10TextureFromCpuMethods)/sizeof(METHOD)},

    {NV15_VIDEO_LUT_CURSOR_DAC,             Nv15VideoLUTCursorDACMethods,
                                            sizeof(Nv15VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV10_DVD_SUBPICTURE,                   Nv10DvdSubpictureMethods,
                                            sizeof(Nv10DvdSubpictureMethods)/sizeof(METHOD)},
                                            
    {NV10_SCALED_IMAGE_FROM_MEMORY,         Nv10ScaledImageFromMemoryMethods,
                                            sizeof(Nv10ScaledImageFromMemoryMethods)/sizeof(METHOD)},
                                            
    {NV10_IMAGE_FROM_CPU,                   Nv10ImageFromCpuMethods,
                                            sizeof(Nv10ImageFromCpuMethods)/sizeof(METHOD)},

    {NV10_CONTEXT_SURFACES_3D,              Nv10ContextSurfaces3DMethods,   
                                            sizeof(Nv10ContextSurfaces3DMethods)/sizeof(METHOD)},

    {NV10_DX5_TEXTURED_TRIANGLE,            Nv10DX5TexturedTriangleMethods,
                                            sizeof(Nv10DX5TexturedTriangleMethods)/sizeof(METHOD)},

    {NV10_DX6_MULTI_TEXTURE_TRIANGLE,       Nv10DX6MultiTextureTriangleMethods,
                                            sizeof(Nv10DX6MultiTextureTriangleMethods)/sizeof(METHOD)},

    {NV15_CELSIUS_PRIMITIVE,                Nv15CelsiusPrimitiveMethods,
                                            sizeof(Nv15CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV15_IMAGE_BLIT,                       Nv15ImageBlitMethods,
                                            sizeof(Nv15ImageBlitMethods)/sizeof(METHOD)},

    // NV11 and NV15 Celsius share the same method struct.
    {NV11_CELSIUS_PRIMITIVE,                Nv15CelsiusPrimitiveMethods,
                                            sizeof(Nv15CelsiusPrimitiveMethods)/sizeof(METHOD)},

    //
    // MAKE THIS LAST!!!
    //                                     
    {NV_CLASS,                              NvClassMethods,
                                            sizeof(NvClassMethods)/sizeof(METHOD)},
};

#define CLASSMETHODSTABLE_SIZE              (sizeof(classMethodsTable) / sizeof(CLASSMETHODS))

//---------------------------------------------------------------------------
//
//  Class table access.
//
//---------------------------------------------------------------------------

RM_STATUS classGetClass
(
    PCLASSDB pClassDB,
	U032 classNum, 
	PCLASS *ppClass
)
{
    U032 i;

	for (i = 0; i < pClassDB->numClasses; i++)
    {
		if (pClassDB->pClasses[i].Type == classNum)
        {
			*ppClass = &pClassDB->pClasses[i];
			return RM_OK;
        }
    }

	return RM_ERROR;
}

//
// classGetInfo
//
// This routine sets up method handling for the specified class
// It also binds the class to a a particular engine.
//
RM_STATUS classGetInfo
(
    PENGINEDB pEngineDB, 
    PCLASSDB pClassDB,
    PCLASS pClass
)
{
    U032 classNum;
    PENGINEINFO pEngineInfo;
    PENGINEDESCRIPTOR pEngineDecl;
    U032 engine;
	U032 i;

    //
    // Get class number and engine tag.
    //
    classNum = CLASSDECL_FIELD(*pClass->ClassDecl, _CLASS);
    engine = CLASSDECL_FIELD(*pClass->ClassDecl, _TAG);

    //
    // Wire up engine data first.
    //
    if (engineGetInfo(pEngineDB, engine, &pEngineInfo, &pEngineDecl) != RM_OK)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: classGetInfo: bad engine tag ", engine);
        return RM_ERROR;
    }

    pClass->EngineDecl = pEngineDecl;
    pClass->EngineInfo = pEngineInfo;

    //
    // Now wire up method routines.
    //
    for (i = 0; i < CLASSMETHODSTABLE_SIZE; i++)
    {
        if (classMethodsTable[i].Type == classNum)
        {
            pClass->Method = classMethodsTable[i].Method;
            pClass->MethodMax = classMethodsTable[i].MethodMax;
            break;
        }
    }

    //
    // If we don't have an entry in the resman method table for the
    // given class, then use the engine-specific default table
    // (usually just filled with a hardware method stub).
    //
    if (i == CLASSMETHODSTABLE_SIZE)
    {
        pClass->Method = pEngineInfo->Methods;
        pClass->MethodMax = pEngineInfo->MethodMax;
    }
    
	return RM_OK;
}

//
// classBuildDB
//
// This routine generates the class database for the
// specified device.
//
RM_STATUS classBuildDB
(
    PENGINEDB pEngineDB,
    PCLASSDB pClassDB
)
{
    PCLASS pClass;
    PCLASSDESCRIPTOR pClassDesc;
    U032 numClasses;
    U032 i, j;
    RM_STATUS status;

    //
    // Calculate number of classes supported by this device.
    //
    // For now, just add the size of the common class descriptor
    // table to the number of class descriptors in the pClassDB table (we
    // should probably allow for overlaps between the two).
    //
    j = 0;
    for (i = 0; i < pClassDB->numClassDescriptors; i++)
    {
        if (CLASSDECL_FIELD(pClassDB->pClassDescriptors[i], _OPCODE) == CLASSDECL_INSTR)
            j++;
            
    }

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvInfo class descriptors ",  j);

    numClasses = NUM_COMMONCLASSDESCRIPTORS + j;

    //
    // Allocate space for correct number of entries.
    //
    status = osAllocMem((VOID **)&pClass, sizeof (CLASS) * numClasses);
    if (status)
        return status;

    //
    // Load up the fixed (common) classes.
    //
    pClassDesc = &Common_ClassDescriptors[0];
    for (i = 0; i < NUM_COMMONCLASSDESCRIPTORS; i++)
    {
        pClass[i].Type = CLASSDECL_FIELD(pClassDesc[i], _CLASS);
        pClass[i].ClassDecl = &pClassDesc[i];
        status = classGetInfo(pEngineDB, pClassDB, &pClass[i]);
        if (status != RM_OK)
        {
            //
            // This shouldn't happen; treat as a fatal error.
            //
            osFreeMem((VOID *)pClass);
            return (RM_ERROR);
        }
    }

    //
    // Load up chip-dependent classes.
    //
    pClassDesc = &pClassDB->pClassDescriptors[0];
    for (i = NUM_COMMONCLASSDESCRIPTORS, j = 0; i < numClasses; i++)
    {
        //
        // Advance to next class descriptor header
        // (i.e. skip over any class extension descriptors).
        //
        while (CLASSDECL_FIELD(pClassDesc[j], _OPCODE) != CLASSDECL_INSTR)
            j++;
        pClass[i].Type = CLASSDECL_FIELD(pClassDesc[j], _CLASS);
        pClass[i].ClassDecl = &pClassDesc[j];
        if (CLASSDECL_FIELD(pClassDesc[++j], _OPCODE) == CLASSINSTMALLOC_INSTR)
            pClass[i].ClassInstMalloc = &pClassDesc[j];
        else
            pClass[i].ClassInstMalloc = NULL;
        
        status = classGetInfo(pEngineDB, pClassDB, &pClass[i]);
        if (status != RM_OK)
        {
            //
            // This shouldn't happen; treat as a fatal error.
            //
            osFreeMem((VOID *)pClass);
            return (RM_ERROR);
        }
    }

    pClassDB->pClasses = pClass;
    pClassDB->numClasses = numClasses;

    return (RM_OK);
}

RM_STATUS classDestroyDB
(
    PCLASSDB  pClassDB
)
{
    osFreeMem((VOID *)pClassDB->pClasses);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class object initial creation.
//
//---------------------------------------------------------------------------

RM_STATUS classCreateWellKnownObjects
(
    PHWINFO pDev,
    U032    ChID
)
{
    RM_STATUS    status;
    U032         i;
    U032         j;
    PCLASSDB pClassDB;
    PCLASSOBJECT ClassObject;
    PCLASSOBJECT *ClassObjects;
    PRENDERCOMMONOBJECT nullObject;
    PCLASS classTable;
#ifdef LEGACY_ARCH
    PDMAOBJECT   ErrNotifier;
#endif

    pClassDB = &pDev->classDB;

    //
    // Create and initialize all CLASS objects.  These are the master
    // class instances for this particular channel.  All user objects
    // created in this channel will be children of these master class
    // objects.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: numClasses ", pClassDB->numClasses);

    //
    // Allocate ClassObjects[] table.
    //
    status = osAllocMem((VOID **)&ClassObjects, sizeof (PCLASSOBJECT) * pClassDB->numClasses);
    if (status)
        return (status);

    classTable = pClassDB->pClasses;
    for (i = 0; i < pClassDB->numClasses; i++)
    {
        status = osAllocMem((VOID **)&ClassObject, sizeof (CLASSOBJECT));
        if (status)
        {
            while (i)
                osFreeMem(ClassObjects[--i]);
            osFreeMem(ClassObjects);
            return status;
        }

        //
        // Init global state.
        //
        ClassObjects[i]                 = ClassObject;
        ClassObject->Base.Name          = classTable[i].Type;
        //ClassObject->Base.Class         = &(classTable[i]);
        ClassObject->Base.Class         = &(classTable[NUM_COMMONCLASSDESCRIPTORS-1]);
        ClassObject->Base.ThisClass     = &(classTable[i]);
        ClassObject->Base.ChID          = ChID;
        ClassObject->Base.NotifyXlate   = NULL;
        ClassObject->Base.NotifyAction  = 0;
        ClassObject->Base.NotifyTrigger = 0;
        ClassObject->Base.NotifyEvent   = NULL;

        //
        // Add object into FIFO object tree.
        //
        status = fifoAddObject(pDev, (POBJECT)ClassObject);
        if (status != RM_OK)
        {
            while (i)
                osFreeMem(ClassObjects[--i]);
            osFreeMem(ClassObjects);
            return (status);
        }
    }

    //
    // Create and initialize NV_ERROR_NOTIFIER.
    //
    // jsw: this is no longer necessary with the new architecture
    //      error notifiers are explicitly created.
#ifdef LEGACY_ARCH
    // Find the DMA_TO_MEM master class object first.
    //
    j = 0;
    while ((j < pClassDB->numClasses) && (ClassObjects[j]->Base.Name != NV_CONTEXT_DMA_TO_MEMORY))
        j++;
    if (j == pClassDB->numClasses)
    {
        // Kinda silly error, but just in case we can't find the class
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        return (status);
    }
    //
    // Now create our instance
    //
    status = dmaCreate(pDev, ClassObjects[j], NV_CONTEXT_ERROR_TO_MEMORY, (POBJECT *)&ErrNotifier, NULL);
    if (status)
    {
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        dmaDelete((VOID*)pDev, (POBJECT)ErrNotifier);
        return (status);
    }
    ErrNotifier->Base.Name          = NV_CONTEXT_ERROR_TO_MEMORY;
    ErrNotifier->Base.Class         = &(classTable[j]);
    ErrNotifier->Base.ThisClass     = &(classTable[j]);
    ErrNotifier->Base.ChID          = ChID;
    ErrNotifier->Base.NotifyXlate   = NULL;
    ErrNotifier->Base.NotifyAction  = 0;
    ErrNotifier->Base.NotifyTrigger = 0;
    ErrNotifier->Base.NotifyEvent   = NULL;
    if ((status = fifoAddObject(pDev, (POBJECT)ErrNotifier)) != RM_OK)
    {
        dmaDelete((VOID*)pDev, (POBJECT)ErrNotifier);
        //return (status);
    }
#endif

    //
    // Create and initialize NV1_NULL_OBJECT.
    //
    // Find the NV1_NULL master class object first.
    //
    j = 0;
    while ((j < pClassDB->numClasses) && (ClassObjects[j]->Base.Name != NV1_NULL))
        j++;

    if (j == pClassDB->numClasses)
    {
        // Kinda silly error, but just in case we can't find the class
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        return (status);
    }       

    //
    // Now create our instance
    // 
    status = grCreateObj(pDev, ClassObjects[j], 0, (POBJECT *)&nullObject, NULL);
    if (status)
    {
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        grDestroyObj(pDev, (POBJECT)nullObject);
        return (status);
    }

    if ((status = fifoAddObject(pDev, (POBJECT)nullObject)) != RM_OK)
    {
        grDestroyObj(pDev, (POBJECT)nullObject);
        //return (status);
    }

    osFreeMem(ClassObjects);

    return (RM_OK);
}

RM_STATUS classDeleteWellKnownObjects
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    return (osFreeMem(Object));
}

RM_STATUS classInitCommonObject
(
    POBJECT pObject,
    PCLASSOBJECT pClassObject,
    U032 Name
)
{
    PCOMMONOBJECT pCommonObject;

    //
    // Initialize base object data.
    //
    pCommonObject = (PCOMMONOBJECT)pObject;

    pCommonObject->Base.Name = Name;
    pCommonObject->Base.ChID = pClassObject->Base.ChID;
    pCommonObject->Base.Class = pClassObject->Base.ThisClass;
    pCommonObject->Base.ThisClass = pClassObject->Base.ThisClass;
    pCommonObject->Base.NotifyXlate   = NULL;
    pCommonObject->Base.NotifyAction  = 0;
    pCommonObject->Base.NotifyTrigger = 0;
    pCommonObject->Base.NotifyEvent   = NULL;

    //
    // Initialize common object data.
    //
    pCommonObject->Valid            = FALSE;
    pCommonObject->NotifyPending    = FALSE;
    pCommonObject->Instance         = 0;
    pCommonObject->NotifyObject     = NULL;
    pCommonObject->Dma0Object       = NULL;
    pCommonObject->Dma1Object       = NULL;

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  NOP methods.
//
//---------------------------------------------------------------------------

RM_STATUS nopCreate
(
    VOID*        pDevHandle,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *UserObject,
    VOID*        pCreateParms
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Class not implemented yet: ", ClassObject->Base.Class->Type);
    return (RM_ERR_CREATE_BAD_CLASS);
}
RM_STATUS nopDelete
(
    PHWINFO pDev,
    POBJECT Object
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Class not implemented yet: ", Object->Class->Type);
    return (RM_ERR_DELETE_BAD_CLASS);
}
RM_STATUS mthdNoOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Method NoOperation", Object->Class->Type);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Create object.
//
//---------------------------------------------------------------------------

RM_STATUS classCreate
(
    VOID*        pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *UserObject,
    VOID*        pCreateParms
)
{
    //
    // Class specific create procedure.
    //

    DBG_VAL_PTR(ClassObject);
    return ((*(ClassObject->Base.ThisClass->EngineInfo->CreateObject))(pDev, ClassObject, UserName, UserObject, pCreateParms)); //KJK YUCK!!
}

//---------------------------------------------------------------------------
//
//  Destroy object.
//
//---------------------------------------------------------------------------

RM_STATUS classDestroy
(
    VOID*   pDev,
    POBJECT Object
)
{
    //
    // Class specific delete procedure.
    //
    DBG_VAL_PTR(Object);
    return ((*(Object->Class->EngineInfo->DestroyObject))(pDev, Object));    //KJK YUCK!!
}

//---------------------------------------------------------------------------
//
//  Software methods.
//  Emulate the device access in software.
//
//---------------------------------------------------------------------------

RM_STATUS classSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS  status;
    U032       i;

#if DEBUG
    //
    // Reject unaligned accesses.
    //
    if (Offset & 0x0003)
        return (RM_ERR_FIFO_BAD_ACCESS);
#endif // DEBUG
    if (Object != NULL)
    {
        //
        // Search for object method.
        //
        DBG_VAL_PTR(Object);
        for (i = 0; i < Object->Class->MethodMax; i++)
        {
            if ((Offset >= Object->Class->Method[i].Low)
            &&  (Offset <  Object->Class->Method[i].High))
            {

                status = Object->Class->Method[i].Proc(pDev,
                                                       Object,
                                                       &(Object->Class->Method[i]),
                                                       Offset,
                                                       Data);
                //
                // Send completion notification.
                //
                notifyMethodComplete(pDev, Object, Offset, Data, status);
                return (status);
            }
        }
        //
        // Method not found, so report the error if notify pending.
        //
        notifyMethodComplete(pDev, Object, Offset, Data, RM_ERR_FIFO_BAD_ACCESS);
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: invalid access ", RM_ERROR);
    if (Object)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              object ", Object->Class->Type);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "              object NULL");
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              offset ", Offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "                data ", Data);
    return (RM_ERR_FIFO_BAD_ACCESS);
}

//
// SMP wrapper for classSoftwareMethod
//
RM_STATUS classDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS status;

    osEnterCriticalCode(pDev);
    status = classSoftwareMethod(pDev, Object, Offset, Data);
    osExitCriticalCode(pDev);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CMCP1Method.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CMCP1Method.h                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CMCP1METHODH_
#define _CMCP1METHODH_

#define METHOD_MIN_OFFSET(x)       (x)
#define METHOD_MAX_OFFSET(x)       ((x) + 0x4)

class CHalMCP1;

class CMCP1Method
{
public:
    CMCP1Method(CHalMCP1 *pHal) { m_pHal = pHal; };
    ~CMCP1Method() { };

public:
    RM_STATUS Execute(U032 uOffset, U032 uData);

private:
    CHalMCP1    *m_pHal;

    // utility
    BOOL CheckRange(U032 uOffset, U032 uMethodOffset)   
    { 
        return ((uOffset >= METHOD_MIN_OFFSET(uMethodOffset)) && 
                (uOffset < METHOD_MAX_OFFSET(uMethodOffset))?TRUE:FALSE);
    }

    // software methods
    RM_STATUS SetContextDMANotify(U032);
    RM_STATUS SetCurrentSSLContextDMA(U032);
    RM_STATUS SetCurrentInBufSGEContextDMA(U032);
    RM_STATUS SetCurrentOutBufSGEContextDMA(U032);

    // damn hacks!
    RM_STATUS SetGPState(U032);
    RM_STATUS SetCurrentOutBufSGEOffset(U032);
    RM_STATUS SetCurrentInBufSGEOffset(U032);
    RM_STATUS SetSSLSegmentOffset(U032);
    RM_STATUS SetSSLSegmentOffsetLength(U032, U032);
    RM_STATUS SetOutBufBA(U032, U032);
    RM_STATUS SetOutBufLen(U032, U032);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CMCP1Method.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CMCP1Method.cpp                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uap.h>
#include <nv_papu.h>
#include <AudioHw.h>
#include <nv32.h>
};
#include <aos.h>
#include <ahal.h>

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalMCP1.h"
#include "CHalGlobalProc.h"
#include "CHalVoiceProc.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CMCP1Method.h"

RM_STATUS
CMCP1Method::Execute(U032 uOffset, U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;  // not implemented

    do
    {
        if (CheckRange(uOffset, NV1BA0_PIO_SET_CONTEXT_DMA_NOTIFY))
        {
            rmStatus = SetContextDMANotify(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_SSL_CONTEXT_DMA))
        {
            rmStatus = SetCurrentSSLContextDMA(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_INBUF_SGE_CONTEXT_DMA))
        {
            rmStatus = SetCurrentInBufSGEContextDMA(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA))
        {
            rmStatus = SetCurrentOutBufSGEContextDMA(uData);
            break;
        }
        
        if (CheckRange(uOffset, 0x4000))        // to be moved to the .ref file.. todo vik
        {
            rmStatus = SetGPState(uData);
            break;
        }

        if (CheckRange(uOffset, 0x4004))        // debug...
        {
            rmStatus = SetCurrentOutBufSGEOffset(uData);
            break;
        }
        
        if (CheckRange(uOffset, 0x4008))        // debug...
        {
            rmStatus = SetCurrentInBufSGEOffset(uData);
            break;
        }
        
        U032 uCnt = 0;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if (CheckRange(uOffset, (0x420C + (uCnt*8))) )
            {
                rmStatus = SetOutBufBA(uData, uCnt);
                break;
            }
        }
        
        if (uCnt != 4)
            break;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if (CheckRange(uOffset, (0x4210 + (uCnt*8))) )
            {
                rmStatus = SetOutBufLen(uData, uCnt);
                break;
            }
        }

        if (uCnt != 4)
            break;

        // find out if NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET got triggered
        for (uCnt = 0; uCnt < 64; uCnt++)
        {
            if (CheckRange(uOffset, (0x400C + (uCnt*8))) )
            {
                rmStatus = SetSSLSegmentOffset(uData);
                break;
            }
        }
        
        if (uCnt != 64)
            break;

        for (uCnt = 0; uCnt < 64; uCnt++)
        {
            if (CheckRange(uOffset, (0x4010 + (uCnt*8))) )
            {
                rmStatus = SetSSLSegmentOffsetLength(uData, uCnt);
                break;
            }
        }

        if (uCnt != 64)
            break;
        
        
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CMCP1Method::Execute - SW method not yet implemented!\n");

#if defined WDM
        KdPrint(("Method offset = 0x%x Method Data = 0x%x\n", uOffset, uData));
#endif

    } while (FALSE);
    
    return rmStatus;
}

// software methods
RM_STATUS
CMCP1Method::SetContextDMANotify(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if ((U032)(pDma->GetAddress()) & 0xFF)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetContextDMANotify - Address not aligned on 256bytes boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FENADDR, (U032)pDma->GetAddress());
    return RM_OK;
}

RM_STATUS
CMCP1Method::SetCurrentSSLContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentSSLContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FESESSLCTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FESESSLMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CMCP1Method::SetCurrentInBufSGEContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentInBufSGEContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FESESGECTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FESESGEMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CMCP1Method::SetCurrentOutBufSGEContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentOutBufSGEContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FEGPSGECTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FEGPSGEMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CMCP1Method::SetGPState(U032 uData)
{
    R_GP_CONTROL rControl;
    rControl.uValue = 0;

    if (uData)
    {
        // take it out of reset...
        R_GP_RESET rReset;
        rReset.uValue = 0;
        rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
        rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
        rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
        rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;

        m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);
        
        // write the command to make the GP work in pass thru
        DSP_CONTROL dspCtl;

        dspCtl.w0.uValue = 0;
        dspCtl.w0.field.EOL = 1;    // this is the last command

        dspCtl.w1.uValue = 0;
        dspCtl.w1.field.interleave = 1;
        dspCtl.w1.field.dspToSys = 1;
        dspCtl.w1.field.smDataFormat = 1;
        dspCtl.w1.field.increment = 32;

        dspCtl.w2.uValue = 0;
        dspCtl.w2.field.count0 = 1;   // 2 samples per block
        dspCtl.w2.field.count1 = 32;

        dspCtl.w3.uValue = 0;
        dspCtl.w3.field.dspStart = 0x1400;

        m_pHal->GetGlobalProc()->WriteCommand(&dspCtl);

        // auto start and auto idle
        R_GPDMA_CONFIG rConfig;
        rConfig.uValue = 0;
        rConfig.Start = NV_PAPU_GPDCFG_GPDASTRT_ENABLED;
        rConfig.Ready = NV_PAPU_GPDCFG_GPDARDY_ENABLED;
        m_pHal->RegWrite(NV_PAPU_GPDCFG, rConfig.uValue);
    
        // DMA start block pointer
        m_pHal->RegWrite(NV_PAPU_GPDSPT, (U032) 0);

        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CMCP1Method::SetGPState - the GP might just start...");
        // enable the GP
        rControl.Idle = NV_PAPU_GPIDRDY_GPSETIDLE_SET;
        rControl.IntrNotify = NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET;
    }
    else
    {
        // stop the GP
        /*
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CMCP1Method::SetGPState - the GP might just stop...");
        rControl.EnableStop = NV_PAPU_GPIDRDY_GPSTOP_ENABLED;
        rControl.Stopped = NV_PAPU_GPIDRDY_GPSTOPPED_SET;
        */
    }

    m_pHal->RegWrite(NV_PAPU_GPIDRDY, rControl.uValue);

    aosDbgPrintString(DEBUGLEVEL_ERRORS, "done.  Congratulations!\n");
    return RM_OK;
}

// NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET
RM_STATUS
CMCP1Method::SetCurrentOutBufSGEOffset(U032 uData)
{
    MCP1_PRD *pLin = (MCP1_PRD *)(m_pHal->GetGlobalProc()->GetSgeOutLinAddr());

    pLin->uAddr = uData;
    pLin->Control.uValue = 0;
    pLin->Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;      // owned by HW

    return RM_OK;
}

// NV1BA0_PIO_SET_CURRENT_INBUF_SGE_OFFSET
RM_STATUS
CMCP1Method::SetCurrentInBufSGEOffset(U032 uData)
{
    VOLU32 uTemp;

    // find out the max offset
    m_pHal->RegRead(NV_PAPU_FESESGEMAXOFF, &uTemp);
    if (uTemp < uData)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - max offset exceeded!\n");
        return RM_ERROR;
    }

    R_FE_CONTROL rFeCtl;

    m_pHal->RegRead(NV_PAPU_FECTL, &rFeCtl.uValue);
    if (rFeCtl.ValidSESGE == NV_PAPU_FECTL_FESESGECTXPA_VALID_NO)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - SGE context dma valid bit not set\n");
        return RM_ERROR;
    }

    // find the right PRD to write to
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pHal->GetVoiceProc()->GetSgeInLinAddr());
    U032 uNumOfPrds = (m_pHal->GetVoiceProc()->GetSgeInSize())/NV_PSGE_SIZE;

    // read the current index to write to...
    m_pHal->RegRead(NV_PAPU_FECSESGE, &uTemp);

    // a little error checking of my own..
    if (uNumOfPrds < uTemp)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - current index greater than total PRDs allocated\n");
        return RM_ERROR;
    }

    VOLU32 uBase;
    m_pHal->RegRead(NV_PAPU_FESESGECTXPA, &uBase);

    // make the PRD (not 0 based.. i think)
    pPrd[uTemp-1].uAddr = uBase + uData;
    pPrd[uTemp-1].Control.uValue = 0;
    pPrd[uTemp-1].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

    return RM_OK;
}

// NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET
RM_STATUS
CMCP1Method::SetSSLSegmentOffset(U032 uData)
{
    // error checking .. to hell with it! (for now)

    if (uData & 0xFFF)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetSSLSegmentOffset - alignment check fails!\n");
        return RM_ERROR;
    }
    
    // save it as pending
    uData = uData | NV_PAPU_FESESSLPENDOFF_VALID_YES;

    m_pHal->RegWrite(NV_PAPU_FESESSLPENDOFF, uData);

    return RM_OK;
}

// NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH
RM_STATUS
CMCP1Method::SetSSLSegmentOffsetLength(U032 uData, U032 uIndex)
{
    /*
    Check that the offset has already been saved by the previous method.
    Check that container_size != 2. 
    Check that (offset & container_size) == 0.
    Check that samples_per_block > stereo.
    
    Then, check the offset and length as follows:
    
           offset+(length*container_size*samples_per_block) <= maxoff
    */

    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pHal->GetVoiceProc()->GetSegInLinAddr());
    
    // calculate the index of the SSL
    VOLU16 uCurrSSL = 0;
    m_pHal->RegRead(NV_PAPU_FECSESSL, &uCurrSSL);
    
    uIndex += (uCurrSSL * 64);
    
    // read the offset previosuly set
    VOLU32 uPendOffset = 0;
    m_pHal->RegRead(NV_PAPU_FESESSLPENDOFF, &uPendOffset);
    
    // just for fun confirm that it's valid
    if ((uPendOffset & 0x1) != NV_PAPU_FESESSLPENDOFF_VALID_YES)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetSSLSegmentOffsetLength - u can only set length after setting the offset!\n");
        return RM_ERROR;
    }
    
    VOLU32 uBase;
    m_pHal->RegRead(NV_PAPU_FESESSLCTXPA, &uBase);
    
    // these don't look like being '0' based
    pPrd[uIndex-1].uAddr = uBase + (uPendOffset & 0xFFFFF000);
    pPrd[uIndex-1].Control.uValue = uData;

    return RM_OK;
}

// NV1BA0_PIO_SET_OUTBUF_BA(i)
RM_STATUS
CMCP1Method::SetOutBufBA(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    switch(uIndex)
    {
    case 0:
        uOffBase = NV_PAPU_GPOFBASE0;
        uOffEnd = NV_PAPU_GPOFEND0;
        break;
    case 1:
        uOffBase = NV_PAPU_GPOFBASE1;
        uOffEnd = NV_PAPU_GPOFEND1;
        break;
    case 2:
        uOffBase = NV_PAPU_GPOFBASE2;
        uOffEnd = NV_PAPU_GPOFEND2;
        break;
    case 3:
        uOffBase = NV_PAPU_GPOFBASE3;
        uOffEnd = NV_PAPU_GPOFEND3;
        break;
    }

    m_pHal->RegWrite(uOffBase, uData);
    m_pHal->RegWrite(uOffEnd, uData);

    return RM_OK;
}

// NV1BA0_PIO_SET_OUTBUF_LEN(i)
RM_STATUS
CMCP1Method::SetOutBufLen(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    switch(uIndex)
    {
    case 0:
        uOffBase = NV_PAPU_GPOFBASE0;
        uOffEnd = NV_PAPU_GPOFEND0;
        break;
    case 1:
        uOffBase = NV_PAPU_GPOFBASE1;
        uOffEnd = NV_PAPU_GPOFEND1;
        break;
    case 2:
        uOffBase = NV_PAPU_GPOFBASE2;
        uOffEnd = NV_PAPU_GPOFEND2;
        break;
    case 3:
        uOffBase = NV_PAPU_GPOFBASE3;
        uOffEnd = NV_PAPU_GPOFEND3;
        break;
    }
    
    U032 uBaseAddr;
    m_pHal->RegRead(uOffBase, &uBaseAddr);

    m_pHal->RegWrite(uOffEnd, uBaseAddr + uData);
    
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\audio\CObjBase.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CObjBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _COBJBASEH_
#define _COBJBASEH_

class CHalBase;

class CObjBase
{
public:
	CObjBase(CHalBase *pHal)	{ m_pHal = pHal; }

public:
	// each derived object has to implement these functions
	virtual RM_STATUS Allocate(VOID *pParam) = 0;
	virtual RM_STATUS Free(VOID *pParam = NULL) = 0;

protected:
	
	virtual VOID RegWrite(U032 uOffset, U032 uValue) { m_pHal->RegWrite(uOffset, uValue); }
	virtual VOID RegWrite(U032 uOffset, U016 uValue) { m_pHal->RegWrite(uOffset, uValue); }
	virtual VOID RegWrite(U032 uOffset, U008 uValue) { m_pHal->RegWrite(uOffset, uValue); }

	virtual VOID RegRead(U032 uOffset, U032 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, U016 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, U008 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U032 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U016 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U008 *pValue) { m_pHal->RegRead(uOffset, pValue); }

    virtual void MemWrite(U032 uAddr, U008 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }
    virtual void MemWrite(U032 uAddr, U016 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }
    virtual void MemWrite(U032 uAddr, U032 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }

    CHalBase *GetDevice()           { return m_pHal; }

private:
	CHalBase *m_pHal;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\class\nv\control.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CONTROL.C                                                         *
*     Control methods are implemented in this module.                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include <nv32.h>
#include "control.h"
#include "nvhw.h"

//
// FIFO database.
//

//---------------------------------------------------------------------------
//
//  Control methods.
//
//---------------------------------------------------------------------------


CTRLMETHOD NvControlMethods[] =
{
    {mthdSetObject,                 0x0000, 0x0003}
#ifdef OBSOLETE_FUNCTIONS
    {mthdSetStallNotifier,          0x0050, 0x0053},
    {mthdStallChannel,              0x0054, 0x0057}
#endif // OBSOLETE_FUNCTIONS
};

// Class representing information for channel control operations
CTRLCLASS NvControlClass =
{
    NvControlMethods,
    sizeof(NvControlMethods) / sizeof(CTRLMETHOD)
};


// Implementation of the control "Set Object" method
RM_STATUS mthdSetObject
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    U032    Context;
    POBJECT Object;
#ifdef KJK
    U032    CacheChID;
#endif

    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object.
        //
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = NULL;
    }
    else if (fifoSearchObject(pDev, Data, ChID, &Object) == RM_OK)
    {
    
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: SetObject on subchannel: ", SubChannel);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      Object#: ", Object->Name);
    
        //
        // Set this as the current object for this ChID/SubChannel.
        //
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = Object;

        //
        // Set the current subchannel for this object, per this SetObject
        //
        Object->Subchannel = SubChannel;
        
        //
        // Update the fifo context for this subchannel back to a software object
        //
        Context = REG_RD32(NV_PFIFO_CACHE1_ENGINE);
        Context &= ~(0x03 << (SubChannel*4));
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, Context);
    }
    else
    {
        //
        // Object not found.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetObject on invalid object: ", Data);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = NULL;
    }
    
#ifdef KJK    
    //
    // Do the hash function.  Update the appropriate channel context.
    //
    fifoHashEntry(pDev->DBfifoTable[ChID].ObjectStack[SubChannel][0], ChID, &Context);
    CacheChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    if (CacheChID == ChID)
    {
        REG_WR32(NV_PFIFO_CACHE1_CTX(SubChannel), Context);
        REG_WR32(NV_PFIFO_CACHE1_PULL1, DRF_DEF(_PFIFO, _CACHE1_PULL1, _CTX,       _DIRTY));
    }
    else
    {
        U032  *CtxtPtr = (U032 *)pDev->Pram.FifoContextAddr;
        MEM_WR32((U032)(CtxtPtr + (ChID * 8) + SubChannel), Context);
    }
#endif // KJK
    
    return(RM_OK);
}

#ifdef OBSOLETE_FUNCTIONS
// Implementation of the control "Set Stall Notifier" method
RM_STATUS mthdSetStallNotifier
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    RM_STATUS status;

    if (!(REG_RD32(NV_PFIFO_MODE) & (1 << ChID))) 
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetStallNotifier not valid for PIO channel: ", ChID);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_ILLEGAL_ACTION;
    }

    status = dmaValidateObjectName(pDev, Data,
                                   ChID,
                                   &(pDev->DBfifoTable[ChID].StallNotifier));
    if (status) {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid notifier for SetStallNotifier: ", Data);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_BAD_OBJECT;
    }

    return RM_OK;
}


// Implementation of the control "Stall Channel" method
RM_STATUS mthdStallChannel
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    RM_STATUS status;
    U032      GetPtr;

    if (!(REG_RD32(NV_PFIFO_MODE) & (1 << ChID))) 
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: StallChannel not valid for PIO channel: ", ChID);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_ILLEGAL_ACTION;
    }

    // Remember the current position of the PutPtr.
    pDev->DBfifoTable[ChID].Put = REG_RD32(NV_PFIFO_CACHE1_PUT);

    // Make the Put the same as Get. The getptr will be incremented to skip 
    // over the stall channel method. Account for that when setting the putptr.
    GetPtr     = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    GetPtr++;
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, GetPtr);

    // Mark this channel as stalled.
    pDev->DBfifoTable[ChID].IsStalledPendingVblank = TRUE;

    // Write the stall notifier.
    if (pDev->DBfifoTable[ChID].StallNotifier) 
    {
        status = notifyFillNotifierArray(pDev, pDev->DBfifoTable[ChID].StallNotifier, 
                                         0 /* info16 */, 0 /* info32 */, 
                                         Data,
                                         0 /* index */);
    }

    return RM_OK;
}

RM_STATUS mthdEnableStalledChannels
(
    PHWINFO   pDev,
    RM_STATUS status
)
{
    U032 i, currentCh, pushPending;
    BOOL isDma;
    // Check all DMA channels other than the current channel that are in use 
    // (The stalled channel cannot be the current one.)
    currentCh = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 
    for (i = 0; i < NUM_FIFOS; i++)
    {
        isDma = REG_RD32(NV_PFIFO_MODE) & (1 << i);
        if (pDev->DBfifoTable[i].InUse && isDma && i != currentCh && 
            pDev->DBfifoTable[i].IsStalledPendingVblank)
        {
            // This channel was stalled pending a vblank.
            // Update the put in instance memory and mark this channel as push pending.
            REG_WR32((0x714000 + i * 32), pDev->DBfifoTable[i].Put);
            pushPending = REG_RD32(NV_PFIFO_DMA);
            pushPending |= (1 << i);
            REG_WR32(NV_PFIFO_DMA, pushPending);
            // Write the stall notifier.
            if (pDev->DBfifoTable[i].StallNotifier) 
            {
                notifyFillNotifierArray(pDev, pDev->DBfifoTable[i].StallNotifier, 
                                        0 /* info16 */, 0 /* info32 */, 
                                        status,
                                        0 /* index */);
            }

            pDev->DBfifoTable[i].IsStalledPendingVblank = FALSE;
        }
    }

    return RM_OK;
}
#endif // OBSOLETE_FUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dacfp.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC Flat panel Control ********************\
*                                                                           *
* Module: DACFP.C                                                           *
*   Mode set for flat panel is done here.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <dac.h>
#include <os.h>
#include <nvcm.h>
#include <edid.h>
#include <devinit.h>
#include "nvhw.h"


#if defined(NTRM) && !defined(WriteIndexed)
// For NT these are in modehw.h which is in the miniport.
VOID WriteIndexed(U032 addr, U016 datum);
U016 ReadIndexed(U032 addr, U008 reg);
#endif //NTRM

// Const strings for accessing the registry
extern char strFpMode[];

//*************************** Exported functions *****************************************

RM_STATUS dacAdjustCRTCForFlatPanel
(
    PHWINFO pDev, 
    U032 Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    U032    Ht, Hre, Vt, Vrs, Vre, Vbs, data32;
    U016    Seq, Vendor;
    U008    Cr03, Cr04, Cr05, Cr07, Cr09, Cr11, Cr25, Cr28, Cr2d, Cr33;
#if 0
    U032 cntl32;
#endif

    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);   // power on flat panel

#if 0 // If TMDS not powered up, it will hang
    //
    // First, check if the internal TMDS exists, by trying to read/write
    // the TMDS_CONTROL register. If it exists, only power up the internal
    // TMDS, if we're not using an external one.
    //
    cntl32 = DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_PLL1;
    REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, cntl32);
    if (REG_RD32(NV_PRAMDAC_FP_TMDS_CONTROL) == cntl32)
    {
        // The internal TMDS exists, see if we're using the external TMDS
        if (REG_RD_DRF(_PRAMDAC, _FP_TEST_CONTROL, _TMDS) == NV_PRAMDAC_FP_TEST_CONTROL_TMDS_EXTERNAL)
            FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _TMDS);
    }
#endif
    // check for pixel doubled modes
    if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_MONITOR) &&
        (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth < 640))
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }        
    // Make sure attr is set correctly
    Cr07 = REG_RD08(NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    REG_WR08(NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    REG_WR08(NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    // HBE = HT + 4  This is required for the overlay to sync (videos will be offset).
    CRTC_RD(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);
    CRTC_RD(NV_CIO_CR_HDT_INDEX, Ht, Head);
    if (Cr2d & BIT(0))
        Ht |= BIT(8);
    Cr04 = (U008)Ht - 3; // everyone else except SGI
    // SGI is "special". We have to check for their panel and adjust HRS.
    if (pDev->Dac.CrtcInfo[Head].EDID != 0)
    {
    // EDID Version 1 version field should never be 1 on a version 2 (it's an ascii field in V2).
        if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
        {
            Vendor = (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX+1])<<8 | pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX];
            if (Vendor == 0xf84c)
            {
                Cr04 = (U008)Ht; // All modes
//                if ( (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) &&
//                     (pDev->Framebuffer.HalInfo.VertDisplayWidth == 480))
//                {   
//                    Cr04 = (U008)Ht+2;
//                }
            }                              
        }
    }
    CRTC_WR(NV_CIO_CR_HRS_INDEX, Cr04, Head);        // HRS
    if (Ht & BIT(8))
        Cr2d |= 8;
    CRTC_WR(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);   // HRS msb
    
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Hre, Head);    // read CR05 and mask 4:0
    Hre &= 0xe0;
    CRTC_WR(NV_CIO_CR_HRE_INDEX, (Ht-2) | Hre, Head);   // HRE = Ht - 2, CR04[4:0]
    
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);
    // HBE = HT + 4. HBE[6] = CR25[4], HBE[5] = CR5[7], HBE[4:0] = CR3[4:0]
    Cr03 &= 0xE0;   // lose 4:0, the HBE bits
    Cr03 |= (Ht + 4) & 0x1f;
    CRTC_WR(NV_CIO_CR_HBE_INDEX, Cr03, Head);     // HBE[4:0]
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    Cr05 &= 0x7f;
    if ((Ht + 4) & BIT(5))
        Cr05 |= BIT(7);
    CRTC_WR(NV_CIO_CR_HRE_INDEX, Cr05, Head);     // HBE[5]
    Cr25 &= 0xEF;
    if ((Ht + 4) & BIT(6))
        Cr25 |= BIT(4);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);    // HBE[6]

    // gather VT bits
    CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
    if (Cr07 & BIT(0))  // bit 8 of VT
        Vt |= BIT(8);
    if (Cr07 & BIT(5))  // bit 9 of VT
        Vt |= BIT(9);
    if (Cr25 & BIT(0))  // bit 10 of VT
        Vt |= BIT(10);

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    CRTC_WR(NV_CIO_CR_VRS_INDEX, Vrs, Head);
    Cr07 &= ~(BIT(7) | BIT(2)); // clear bits 7 and 2
    if (Vrs & BIT(8)) Cr07 |= BIT(2);
    if (Vrs & BIT(9)) Cr07 |= BIT(7);
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    if (Vrs & BIT(10)) Cr25 |= BIT(2);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    
    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    Vre |= (Cr11 & 0xf0);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Vre, Head);
    
    // VBS = VRS
    CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    Vbs = Vrs;
                
    // write VBS            
    Cr07 &= ~BIT(3); // clear bit 3
    if (Vbs & BIT(8)) Cr07 |= BIT(3);
    Cr09 &= ~BIT(5); // clear bit 5
    if (Vbs & BIT(9)) Cr09 |= BIT(5);
    Cr25 &= ~BIT(3); // clear bit 3
    if (Vbs & BIT(10)) Cr25 |= BIT(3);
    CRTC_WR(NV_CIO_CR_VBS_INDEX, Vbs, Head);
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
            
    data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);    // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

    // Slave the CRTC to timing generator
    // Setup the crtc to work in slave mode (cr28).
    //
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
    Cr28 |= BIT(7);
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head); 
    CRTC_RD(0x33, Cr33, Head);   // NV_CIO_CRE_LCD__INDEX
    Cr33 |= BIT(0);     // bit 0 is HW
    Cr33 |= BIT(1);     // bit 1 is BIOS flag
    CRTC_WR(0x33, Cr33, Head);   //NV_CIO_CRE_LCD__INDEX
                          
    return RM_OK;
}

VOID dacTMDSWrite
(
    PHWINFO pDev,
    U032    Head,
    U008    Addr,
    U008    Data
)
{
    // Due to a bug in NV15, the procedure is more complicated than intended:
    // Write the index of the register with WRITE DISABLE set.
    // Write the data.
    // Write the index with WRITE DISABLED cleared.
    // Write the index with WRITE DISABLED set.
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_DATA, Data, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _ENABLE) | Addr, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
}


U008 dacTMDSRead
(
    PHWINFO pDev,
    U032    Head,
    U008    Addr
)
{
    U008 Data;

    // Write the index of the register with WRITE DISABLE set.
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
    // Read the data.
    Data = (U008) ( DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_DATA, Head) & 0xFF );
    return Data;
}


RM_STATUS dacSetFlatPanelMode
(
    PHWINFO pDev,
    U032    Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032    FpMode,
    BOOL    commitChange
)
{
U032    data32, cntl32;
U008    est_tim1, est_tim2;
U032    fpHActive=0, fpHDispEnd=0, fpHValidStart=0, fpHValidEnd=0, fpHSyncStart=0, fpHSyncEnd=0, fpHTotal=0;
U032    fpVActive=0, fpVDispEnd=0, fpVValidStart=0, fpVValidEnd=0, fpVSyncStart=0, fpVSyncEnd=0, fpVTotal=0;
U032    fpPixClk, fpPolarity=0, M, N, P, pixels, refresh;
BOOL    ModeValid;

    RM_STATUS rmStatus = RM_OK;

    // *********************************************************
    // Power On Flat Panel TMDS and FPCLK
    // Later in dacAdjustCRTCForFlatPanel() we will power
    // down the internal TMDS if we are using an external
    // one.  -paul
    // *********************************************************
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);
    
    // *********************************************************
    // We need to stall after powering on the flat panel TMDS
    // and FPCLK and before we start programming the setup 
    // registers since there is a bit of instability immediately
    // after powerup. On win9x, we will get noise on the FP 
    // without this stall. By trial and error, we found that a 
    // 0x400000 nanosecond delay is sufficient. -paul
    // *********************************************************
    tmrDelay(pDev, 0x400000);
    // Set the scale factor in FP_DEBUG back to 0 in case the BIOS used this to get a special
    // mode, i.e. Japanese DOS. This is only done on NV10. 
    // In Windows modes, the scaling is always set by HW comparing the values in the FP timing
    // registers and the CRTC registers, so the DEBUG registers are always set to 0. 
    // For DOS 475 lines, this method doesn't work, because the scaling value is not in the HW 
    // tables on NV10, so the BIOS has to work around this by setting these DEBUG registers.
    
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_1, 0, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_2, 0, Head);
#ifndef IKOS
    if (FpMode > NV_CFGEX_GET_FLATPANEL_INFO_NATIVE)
    {
        return RM_ERROR;
    }
#else
    FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
#endif
    // read strapping bit to set proper control width
    if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _WIDTH, _24, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _WIDTH, _12, Head);
    }
    // set scaling mode
    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, Head);

    // If we are going native, we must reprogram the dac with new timing
    // We saved the EDID in pDev->Dac.CrtcInfo[Head].EDID[].
    if ((FpMode == NV_CFGEX_GET_FLATPANEL_INFO_NATIVE) &&
        (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL))
    {
        // Check detailed timings first
        DACFPTIMING fpTim;
        U008 block;
        
        fpPixClk = 0;
        for (block=0; block<NUM_DET_TIM; block++)           
        {
            if (edidParseDetailedTimingBlock(pDev, block, &fpTim, Head))
            {
                // Check whether this timing block is for the mode requested
                //  or the doubled mode
                ModeValid = FALSE;
                switch  (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth)
                {
                    case 1600:
                        if (fpTim.HActive == 1600)
                        {
                            if ((fpTim.VActive == 1200) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1200)) 
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024))
                                ModeValid = TRUE;
                        }
                        break;
                    case 1280:
                        if (fpTim.HActive == 1280) 
                        {
                            if ((fpTim.VActive == 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 960) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960))
                                ModeValid = TRUE;
                        }
                        break;
                    case 1024:
                    case 512:
                        if (fpTim.HActive == 1024)
                            if (fpTim.VActive == 768)
                                ModeValid = TRUE;
                        break;
                    case 800:
                    case 400:
                        if (fpTim.HActive == 800)
                            if (fpTim.VActive == 600)
                                ModeValid = TRUE;
                        break;
                    case 640:
                        if (fpTim.HActive == 640) // can be 640x480 or 640x400
                        {
                            if ((fpTim.VActive == 480) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 480))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 400) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 400))
                                ModeValid = TRUE;
                        }
                        break;
                    case 320:
                        if (fpTim.HActive == 640) // can be 640x480 or 640x400
                        {
                            if ((fpTim.VActive == 480) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 240))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 400) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 200))
                                ModeValid = TRUE;
                        }
                        break;
                }
                if (ModeValid) // Use detailed timing
                {
                    fpPixClk = fpTim.PixClk;
                    fpHActive = fpTim.HActive;
                    fpHDispEnd = fpTim.HDispEnd;
                    fpHValidEnd = fpTim.HValidEnd;
                    fpHSyncStart = fpTim.HSyncStart;
                    fpHSyncEnd = fpTim.HSyncEnd;
                    fpHValidStart = fpTim.HValidStart;
                    fpHTotal = fpTim.HTotal - 1;
                    
                    fpVActive = fpTim.VActive;
                    fpVDispEnd = fpTim.VDispEnd;
                    fpVValidEnd = fpTim.VValidEnd;
                    fpVSyncStart = fpTim.VSyncStart;
                    fpVSyncEnd = fpTim.VSyncEnd;
                    fpVValidStart = fpTim.VValidStart;
                    fpVTotal = fpTim.VTotal - 1;
                    fpPolarity = (fpTim.Flags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
                }                       
            } // if parseDetailedTimings
        }
#if IKOS // no EDID
        fpPixClk = 0;
#endif
        if (!fpPixClk)  // not found in detailed, check established
        {
            est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
            est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
            fpPolarity = 0x3;   // estab timings use positive polarities on syncs

#if IKOS // give them whatever they ask for
            est_tim1 = 0xff;
            est_tim2 = 0xff;
#endif

            // Find requested refresh rate
            pixels = pVidLutCurDac->HalObject.Dac[0].TotalWidth * pVidLutCurDac->HalObject.Dac[0].TotalHeight;
            refresh = (pVidLutCurDac->HalObject.Dac[0].PixelClock*10000) / pixels;

            // if it didn't come out exactly, set to nearest choice
            // established timings are limited to 60, 70, 72, and 75
            if (refresh < 62)
                refresh = 60;
            else 
                if (refresh < 72)
                    refresh = 70;
                else 
                    if (refresh < 74)
                        refresh = 72;
                    else
                        refresh = 75;

            switch (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth)
            {
                case 320:
                case 640:   // 640x400 is not an established timing, but we can do 640x480 panel timing and send 640x400 data within this.
                    if ((pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==480) 
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==240)
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==400)
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==200))
                    {
                        if ((refresh == 72) && (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_72))
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 663;
                            fpHSyncEnd =  663+40;
                            fpHTotal = 831;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 487;
                            fpVSyncEnd = 487+3;
                            fpVTotal = 519;
                            fpPixClk = 3150;    // 31.5 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        }
                        else if ((refresh == 75) && (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_75))
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 655;
                            fpHSyncEnd =  655+64;
                            fpHTotal = 839;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 480;
                            fpVSyncEnd = 480+20;
                            fpVTotal = 480+20;
                            fpPixClk = 3150;    // 31.5 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        }
                        // if none of the above, use 60 Hz
                        else if (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_ANY)
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 655;
                            fpHSyncEnd =  655+96;
                            fpHTotal = 799;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 489;
                            fpVSyncEnd = 489+2;
                            fpVTotal = 524;
                            fpPixClk = 2517;    // 25.17 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        }
                    }
                    break;
                case 400:
                case 800:
                    if ((refresh == 72) && (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_72))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 855;
                        fpHSyncEnd =  855+120;
                        fpHTotal = 1040;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 636;
                        fpVSyncEnd = 636+6;
                        fpVTotal = 666;
                        fpPixClk = 5000;    // 50 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    else if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_75))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 815;
                        fpHSyncEnd =  815+80;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+3;
                        fpVTotal = 624;
                        fpPixClk = 4950;    // 49.5 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    // if none of the above, use 60 Hz
                    else if ((est_tim1 & EDID_ESTABLISHED_TIMING_800x600_60) 
                        || (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_ANY))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 839;
                        fpHSyncEnd =  839+128;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+4;
                        fpVTotal = 627;
                        fpPixClk = 4000;    // 40 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    break;
                case 512:
                case 1024:
                    if ((refresh == 70) && (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_70))
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1327;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 7500;    // 75 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                    }
                    else if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_75))
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1039;
                        fpHSyncEnd = 1039+96;
                        fpHTotal = 1311;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 769;
                        fpVSyncEnd = 769+3;
                        fpVTotal = 799;
                        fpPixClk = 7875;    // 78.75 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    else if (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_ANY)
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1343;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 6500;    // 65 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                    }
                    break;
                case 1280:
                    if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_1280x1024_75))
                    {
                        fpHActive = 1280;
                        fpHDispEnd = 1279;
                        fpHValidStart = 0;
                        fpHValidEnd = 1279;
                        fpHSyncStart = 1295;
                        fpHSyncEnd = 1295+144;
                        fpHTotal = 1687;
                        fpVActive = 1024;
                        fpVDispEnd = 1023;
                        fpVValidStart = 0;
                        fpVValidEnd = 1024;
                        fpVSyncStart = 1024;
                        fpVSyncEnd = 1024+3;
                        fpVTotal = 1065;
                        fpPixClk = 13500;   // 135 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                    }
                    break;
                default:
                    break;
            } //switch
        } // if not PixClk

        if (!fpPixClk) // If not found in detailed or established, try standard timings
        {
            U008 stdTiming1, stdTiming2, i;
            U016 hRes, vRes;

            for (i=0; i<EDID_V1_NUM_STANDARD_TIMINGS; i++) 
            {
                // Translate coded value into H + V resolution
                stdTiming1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_STANDARD_TIMING_1_INDEX + i*2];
                stdTiming2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_STANDARD_TIMING_1_INDEX + i*2 +1];
                hRes = (stdTiming1 + 31) * 8;
                switch (stdTiming2>>6)
                {
                    case 0:
                        vRes = (hRes / 16) * 10;
                        break;
                    case 1:
                        vRes = (hRes / 4) * 3;
                        break;
                    case 2:
                        vRes = (hRes / 5) * 4;
                        break;
                    case 3:
                        vRes = (hRes / 16) * 9;
                        break;
                }
                // Standard timing could also specify any refresh rate from 60-123 Hz. This only handles 60 Hz.
                if (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == hRes) 
                {
                    switch (hRes) 
                    {
                    case 640:
                        fpHActive =  640;
                        fpHDispEnd = 639;
                        fpHValidStart = 0;
                        fpHValidEnd = 639;
                        fpHSyncStart = 655;
                        fpHSyncEnd =  655+96;
                        fpHTotal = 799;
                        fpVActive = 480;
                        fpVDispEnd = 479;
                        fpVValidStart = 0;
                        fpVValidEnd =  479;
                        fpVSyncStart = 489;
                        fpVSyncEnd = 489+2;
                        fpVTotal = 524;
                        fpPixClk = 2517;    // 25.17 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    case 800:
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 839;
                        fpHSyncEnd =  839+128;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+4;
                        fpVTotal = 627;
                        fpPixClk = 4000;    // 40 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        break;
                    case 1024:
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1343;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 6500;    // 65 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    case 1280:
                        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960) 
                        {   // GTF
                            fpHActive = 1280;
                            fpHDispEnd = 1279;
                            fpHValidStart = 0;
                            fpHValidEnd = 1279;
                            fpHSyncStart = 1279+80;
                            fpHSyncEnd = 1279+80+136;
                            fpHTotal = 1711;
                            fpVActive = 960;
                            fpVDispEnd = 959;
                            fpVValidStart = 0;
                            fpVValidEnd = 959;
                            fpVSyncStart = 960;
                            fpVSyncEnd = 963;
                            fpVTotal = 993;
                            fpPixClk = 10200;    // 102 MHz
                            fpPolarity = VSYNC_POS | HSYNC_POS;
                        }
                        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024) 
                        {   // DMT
                            fpHActive = 1280;
                            fpHDispEnd = 1279;
                            fpHValidStart = 0;
                            fpHValidEnd = 1279;
                            fpHSyncStart = 1327;
                            fpHSyncEnd = 1327+112;
                            fpHTotal = 1687;
                            fpVActive = 1024;
                            fpVDispEnd = 1023;
                            fpVValidStart = 0;
                            fpVValidEnd = 1023;
                            fpVSyncStart = 1024;
                            fpVSyncEnd = 1024+3;
                            fpVTotal = 1065;
                            fpPixClk = 10800;    // 108 MHz
                            fpPolarity = VSYNC_POS | HSYNC_POS;
                        }
                        break;
                    case 1600:
                        fpHActive = 1600;
                        fpHDispEnd = 1599;
                        fpHValidStart = 0;
                        fpHValidEnd = 1599;
                        fpHSyncStart = 1599+104;
                        fpHSyncEnd = 1599+104+176;
                        fpHTotal = 2159;
                        fpVActive = 1024;
                        fpVDispEnd = 1023;
                        fpVValidStart = 0;
                        fpVValidEnd = 1023;
                        fpVSyncStart = 1024;
                        fpVSyncEnd = 1024+3;
                        fpVTotal = 1060;
                        fpPixClk = 16000;    // 160 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    }
                }
                if (fpPixClk) // found? break for loop
                    break;
            } // for loop

        }
        if (!fpPixClk) // Did we find a detailed, established, or standard timings for the requested mode?
        {
            // No, did we find any valid timings in the EDID? Then fall back to adapter scaling.
            if (pDev->Dac.fpPixClk) 
            {
                // These values were gotten when we read the Edid. It should be the preferred mode.
                fpHActive = pDev->Dac.fpHActive;
                fpHDispEnd = pDev->Dac.fpHDispEnd;
                fpHValidStart = pDev->Dac.fpHValidStart;
                fpHValidEnd = pDev->Dac.fpHValidEnd;
                fpHSyncStart = pDev->Dac.fpHSyncStart;
                fpHSyncEnd = pDev->Dac.fpHSyncEnd;
                fpHTotal = pDev->Dac.fpHTotal - 1;
                fpVActive = pDev->Dac.fpVActive;
                fpVDispEnd = pDev->Dac.fpVDispEnd;
                fpVValidStart = pDev->Dac.fpVValidStart;
                fpVValidEnd = pDev->Dac.fpVValidEnd;
                fpVSyncStart = pDev->Dac.fpVSyncStart;
                fpVSyncEnd = pDev->Dac.fpVSyncEnd;
                fpVTotal = pDev->Dac.fpVTotal - 1;
                fpPixClk = pDev->Dac.fpPixClk;
                fpPolarity = (pDev->Dac.fpFlags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, 0, Head);   // scaled mode
            }
            else
            {
                // No EDID info: set 640x480. We need valid timing, especially the clock, so we will generate interrupts
                // and notifiers which depend on vblank interrupt will get written.
                fpHActive =  640;
                fpHDispEnd = 639;
                fpHValidStart = 0;
                fpHValidEnd = 639;
                fpHSyncStart = 655;
                fpHSyncEnd =  655+96;
                fpHTotal = 799;
                fpVActive = 480;
                fpVDispEnd = 479;
                fpVValidStart = 0;
                fpVValidEnd =  479;
                fpVSyncStart = 489;
                fpVSyncEnd = 489+2;
                fpVTotal = 524;
                fpPixClk = 2517;    // 25.17 MHz
                fpPolarity = VSYNC_NEG | HSYNC_NEG;
                return RM_ERROR;
            }
        }
    }
    else if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR))
    {
        // These values are gotten from the LUT_CURSOR_DAC class
        fpHActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        fpHDispEnd = fpHActive - 1;
        fpHValidStart = 0;
        fpHValidEnd = fpHDispEnd;
        fpHSyncStart = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart - 1;
        fpHSyncEnd = fpHSyncStart + pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth;
        fpHTotal = pVidLutCurDac->HalObject.Dac[0].TotalWidth - 1;

        fpVActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        // check for scanline doubled modes
        if (pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode)
            fpVActive *= 2;

        fpVDispEnd = fpVActive - 1;
        fpVValidStart = 0;
        fpVValidEnd = fpVDispEnd;
        fpVSyncStart = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart - 1;
        fpVSyncEnd = fpVSyncStart + pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight;
        fpVTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight - 1;

        fpPixClk = pVidLutCurDac->HalObject.Dac[0].PixelClock;
        // make sure we're not exceeding our max pixclk for this head
        RM_ASSERT((fpPixClk * 10000) <= GETCRTCHALINFO(pDev, Head, PCLKLimit32bpp));

        fpPolarity = ((!pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity) << 2) | 
                     ((!pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity) << 1);
    }
    else    // FP not native mode, restore full resolution
    {
        // These values were gotten when we read the Edid.
        fpHActive = pDev->Dac.fpHActive;
        fpHDispEnd = pDev->Dac.fpHDispEnd;
        fpHValidStart = pDev->Dac.fpHValidStart;
        fpHValidEnd = pDev->Dac.fpHValidEnd;
        fpHSyncStart = pDev->Dac.fpHSyncStart;
        fpHSyncEnd = pDev->Dac.fpHSyncEnd;
        fpHTotal = pDev->Dac.fpHTotal - 1;
        fpVActive = pDev->Dac.fpVActive;
        fpVDispEnd = pDev->Dac.fpVDispEnd;
        fpVValidStart = pDev->Dac.fpVValidStart;
        fpVValidEnd = pDev->Dac.fpVValidEnd;
        fpVSyncStart = pDev->Dac.fpVSyncStart;
        fpVSyncEnd = pDev->Dac.fpVSyncEnd;
        fpVTotal = pDev->Dac.fpVTotal - 1;
        fpPixClk = pDev->Dac.fpPixClk;
        fpPolarity = (pDev->Dac.fpFlags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
    }
    // Work-around for HW bug: can't set HT lsb's to 00 in 1280 mode.
    if (fpHActive == 1280)
        if (!(fpHTotal & 0x03))
            fpHTotal += 1;  // if x...x00, make it 01
    // We are switching modes, so program the DAC with new timings.
    // If switching between scaled and centered, this isn't necessary, but it won't hurt.
    if (fpPolarity & VSYNC_POS)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _POS, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _NEG, Head);
    }
    if (fpPolarity & HSYNC_POS)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _POS, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _NEG, Head);
    }
    // Pixel Clock
#ifdef NV11_PCLK_HACK
    if (fpHActive == 1024)
    {
        fpPixClk = 5000;    // lower pixclk on NV11 for demo. 
    }
#endif
    dacCalcMNP(pDev, Head, fpPixClk, &M, &N, &P);
    // VPLL doesn't follow the pattern of addressing by adding a fixed offset. VPLL2 has an address in the same range (680xxx) as the
    // primary head. This makes the DAC_REG_WR32 macros useless.
    if (Head == 0) 
    {
        REG_WR32(NV_PRAMDAC_VPLL_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
    }
    else
    {
        // Tell DAC to use programmed M,N,P values, then give it M,N,P.
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _MSOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _NVSOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG); 
        REG_WR32(NV_PRAMDAC_VPLL2_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
    }

    //
    // Set Link depending on which head we want to drive fp.
    //
    if (IsNV11(pDev))
    {
        // Some boards have only one link, and that should be connected to the second head
        if (Head == 0)
            FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK1);
        else
            FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK2);

        // Mobile is dual link LVDS, so both links are used
        if (pDev->Power.MobileOperation)
            if (Head == 0)
            {
                // If using Head==0, both links use primary clock
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK1);
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK1);
            }
            else
            {
                // If using Head==1, both links use secondary clock
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK2);
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK2);
            }
    }

    //
    // If an integrated TMDS exists (we can read/write TMDS_CONTROL),
    // set the PLL values there, as well.
    //
    // TMDS access is in the address range of the primary head. (680xxx)
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FP on to access TMDS

    cntl32 = DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_PLL1;
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, cntl32, Head);

    if (DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_CONTROL, Head) == cntl32) // IF TMDS present
    {
        U008 tmds_pll0, tmds_pll1, tmds_pll2;

        // make sure PLL is enabled, or we'll hang
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head); 

        if (IsNV15(pDev))
        {
            // TMDS settings

            // Run BIOS TMDS single, link A or link B table
            if ( Head == 0 )
            {
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_A );
            }
            else
            {
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_B );
            }

            if ( rmStatus != RM_OK )
            {
                BOOL isMode4 = FALSE;

                // clear error
                rmStatus = RM_OK;

                // Determine PLL values based on pixclk
                if (fpPixClk <= 6400)
                {         // pixclk <= 64MHz
                    tmds_pll0 = 0x31;
                    tmds_pll1 = 0x5F;
                }
                else if (fpPixClk == 6500)
                {  // pixclk == 65MHz
                    tmds_pll0 = 0x31;
                    tmds_pll1 = 0x49;
                }
                else if (fpPixClk <= 8000)
                {  // pixclk <= 80Mhz
                    tmds_pll0 = 0x29;
                    tmds_pll1 = 0x4E;
                }
                else if (fpPixClk <= 10000)
                {  // pixclk <= 100Mhz
                    tmds_pll0 = 0x29;
                    tmds_pll1 = 0x49;
                }
                else
                {                        // pixclk > 100MHz
                    tmds_pll0 = 0x30;
                    tmds_pll1 = 0x4F;
                    isMode4 = TRUE;
                }

                if (isMode4)
                {
                    static U032 mode4_delay = 1000000;  // delay 1 ms between programming

                    //
                    // To set TMDS_PLL0 to 0x30, we need to transition through 0x31 first
                    // (setting TMDS_PLL1 both times), with a little delay in between.
                    //
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x31);         // set PLL0
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
                    tmrDelay(pDev, mode4_delay);
                }

                dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, tmds_pll0);    // set PLL0
                dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
            }
        }
        else
        {
            // First, check if we're in TMDS or LVDS mode
            // Currently looking at one of the registers
            // TODO: should look at the BIOS tables instead?
            DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, 
                         DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_MODE,
                         Head);
            if ((DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_DATA, Head) & 0x1) || pDev->Power.MobileOperation)
            {
                // LVDS mode

                // Run BIOS LVDS dual table
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_LVDS_DUAL );

                if ( rmStatus == RM_OK )
                {
                    // Head selection does not occur in BIOS, so we do this manually
                    // after the other stuff is done.
                    if (Head == 0)
                    {
                        U008 Data;
                        // read register NV_PRAMDAC_INDIR_TMDS_MODE in LINK B
                        Data = dacTMDSRead(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE );
                        // Or with 0x0C to say get from alternate source
                        // write register back to Link B
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, (U008)( Data | 0x0C ));
                    }
                    else
                    {
                        U008 Data;
                        // read register NV_PRAMDAC_INDIR_TMDS_MODE in LINK A
                        Data = dacTMDSRead(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE );
                        // Or with 0x0C to say get from alternate source
                        // write register back to Link A
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, (U008)( Data | 0x0C ));
                    }
                }
                else
                {
                    // We failed to process the table, so do it the hardcoded way

                    if (!IsNV11(pDev))
                    {
                        // We only know how to do NV11
                        return RM_ERROR;
                    }

                    // Clear the error
                    rmStatus = RM_OK;

                    // Setup Link0
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x32);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xF7);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_IDLY, 0x00);
                    if (Head == 0)
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, 0x81);
                    else
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, 0x8D);
                    dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_LVDS, 0x6E);

                    // Setup Link1
                    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, 0x1101111, 0x1);

                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x32);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xF7);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_IDLY, 0x00);
                    if (Head == 0)
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, 0x8D);
                    else
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, 0x81);
                    dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_LVDS, 0x2E);

                    // Setup both Links to run at 1/2 the fpclk frequency
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _FPCLK_RATIO, _DB2, 0);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _FPCLK_RATIO, _DB2, 1);
                    tmrDelay(pDev, 2000000);    // delay to let PLL's stabilize
                }
            }
            else
            {
                // TMDS settings

                // Run BIOS TMDS single, link A or link B table
                if ( Head == 0 )
                {
                    rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_A );
                }
                else
                {
                    rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_B );
                }

                if ( rmStatus != RM_OK )
                {
                    // We failed to process the table, so do it the hardcoded way

                    if (!IsNV11(pDev))
                    {
                        // We only know how to do NV11
                        return RM_ERROR;
                    }

                    // Clear the error
                    rmStatus = RM_OK;

                    // Determine PLL values based on pixclk
                    if (fpPixClk <= 6500) {         // pixclk <= 65MHz
                        tmds_pll0 = 0xB2;
                        tmds_pll1 = 0xF7;
                        tmds_pll2 = 0x00;
                    } else {                        // pixclk > 65MHz
                        tmds_pll0 = 0x32;
                        tmds_pll1 = 0x6F;
                        tmds_pll2 = 0x20;
                    }

                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, tmds_pll0);    // set PLL0
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL2, tmds_pll2);    // set PLL2

                    // Link0 gets data from CRTC0; Link1 gets data from CRTC1, so set "normal" for DINSEL
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_MODE, 0x80);    // get data from CRTCx

                }
            }
        }
    }


    if (IsNV11(pDev))
    {
        U032    HSyncOffset;
        
        // For NV11, there is a clock synchronization problem when scaling:
        // At H display end, the CRTC clock must be held off until sync start, but if the period between end of active display
        // and sync start is too small, there is not enough time to synchronize, so we will reduce HCRTC, which is the synchronization
        // point.
        HSyncOffset = fpHSyncStart - fpHActive;    // find period between display end and sync start
        if (HSyncOffset < 28) 
        {
            fpHActive = fpHActive - (28 - HSyncOffset); // reduce HCRTC by an appropriate amount
        }
    }

    data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, (data32 & 0xfff0ffff) | 0x00020000, Head);
    
    DAC_REG_WR32(NV_PRAMDAC_FP_HCRTC, fpHActive, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HDISPLAY_END, fpHDispEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, fpHValidStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, fpHValidEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, fpHSyncStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, fpHSyncEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HTOTAL, fpHTotal, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VCRTC, fpVActive, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VDISPLAY_END, fpVDispEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, fpVValidStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, fpVValidEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, fpVSyncStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, fpVSyncEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VTOTAL, fpVTotal, Head);
    
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

    if (commitChange)
    {
        // write this mode to the registry
        // fill in the path to the registry key--last character is the display number
       return osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, FpMode);
    }

    return RM_OK;
}

// TODOMK: What is this for?  Can it be replaced with BIOS table usage?
RM_STATUS dacPowerOnMobilePanel
(
    PHWINFO pDev,
    U032    Head
)
{

    U008 lock;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacPowerOnMobilePanel on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
    // make sure PLL is enabled, or we'll hang
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FP on to access TMDS

    // make sure PLL is enabled, or we'll hang
    FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE); 

	// Enable Head2 GPIO
    lock = UnlockCRTC(pDev, 1);
    CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
    RestoreLock(pDev, 1, lock);

#ifdef MACOS
	//MACOS specific panel init
	
	// Disable panel I/O
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x62);    // set PLL0
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x62);    // set PLL0

	// Enable GPIO3 to a zero, set breaker
    REG_WR32(NV_PCRTC_GPIO_EXT, 0x2200);

	// Enable panel I/O
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);    // set PLL0
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);    // set PLL0
#endif
   
#ifndef MACOS
	// Disable panel I/O
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
    
    // Wait a bit
    tmrDelay(pDev, 1000000);

    dacTMDSWrite(pDev, 0, 0xF7, 1);

    tmrDelay(pDev, 1000000);

    dacTMDSWrite(pDev, 0, 0x94, 1);

    // Wait a bit
    tmrDelay(pDev, 100000);

    // Let DivBy7 go again -- this leaves us in LVDS
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1

    // Wait a moderate bit
    tmrDelay(pDev, 2000000);
#endif

    //
    // Power on the BL so we can see
    //
    REG_WR32(NV_PCRTC_GPIO_EXT, 0x2211);

	return (RM_OK);
}

RM_STATUS dacPowerOffMobilePanel
(
    PHWINFO pDev,
    U032    Head
)
{
    
    U008 lock;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacPowerOffMobilePanel on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
	// Enable Head2 GPIO
    lock = UnlockCRTC(pDev, 1);
    CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
    RestoreLock(pDev, 1, lock);

#ifndef MACOS
	// make sure PLL is enabled, or we'll hang
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, 0);     // FP on to access TMDS
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, 1);     // FP on to access TMDS

    // BL disable
	REG_WR32(NV_PCRTC_GPIO_EXT, 0x2210);

	// Disable panel I/O
    dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
    dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0

    tmrDelay(pDev, 1000000);
#endif

	REG_WR32(NV_PCRTC_GPIO_EXT, 0x2200);

	return (RM_OK);
}

void dacZeroPWMController(PHWINFO pDev)
{
	REG_WR32(NV_PBUS_PWM,0);
}

void dacSetPWMController(PHWINFO pDev)
{
	REG_WR32(NV_PBUS_PWM,pDev->Dac.fpPWMRegisterContents);
}

void dacGetPWMController(PHWINFO pDev)
{
	U032 NvPbusPwmHighValue,ControllerRegisterValue,FpDynamicRange;
    U032 NvPbusPwmPeriodValue;
    U032 MinPeriodValue,RelativePeriod;
	
	//we need to init the variable for the flat panel brightness
    if(!pDev->Dac.fpRelativeBrightness)
    {
    	ControllerRegisterValue=REG_RD32(NV_PBUS_PWM);
    	NvPbusPwmHighValue=(ControllerRegisterValue>>16)&0x7fff;
    	NvPbusPwmPeriodValue=ControllerRegisterValue&0x7fff;
    	
    	//a kludge - 40% to 100%
    	MinPeriodValue=((NvPbusPwmPeriodValue*40)+50)/100;
    	
    	FpDynamicRange=NvPbusPwmPeriodValue-MinPeriodValue;
    	
    	RelativePeriod=NvPbusPwmHighValue-MinPeriodValue;
    	
    	pDev->Dac.fpRelativeBrightness=(((RelativePeriod*10000)/(FpDynamicRange*10000/255))*10+5)/10;
    	
    	//store this raw PWM value also into the DAC.fpPWMRegisterContents save/restore var.
    	pDev->Dac.fpPWMRegisterContents=ControllerRegisterValue;
    }
}

RM_STATUS  dacSetFlatPanelBrightness(PHWINFO pDev, U032 Head, U032 Brightness, U032 Frequency, U032 MaxPercent, U032 MinPercent,BOOL ControllerIsOn)
{

	
	U032 TicksNeededForClock;
	U032 TicksNeededForHigh;
	
	U032 ControlValue=0;
	
	//clip if necessary
	if(Brightness>255)
	{
		Brightness=255;
	}
	
	//enable PWM output
	if(ControllerIsOn)
	{
		FLD_WR_DRF_DEF(_PBUS,_PWM,_EN,_ENABLED);
	}
	else
	{
		FLD_WR_DRF_DEF(_PBUS,_PWM,_EN,_DISABLED);
	}
	
	TicksNeededForClock=GetTicksForFrequency(Frequency);
	TicksNeededForHigh=GetRequiredTickCount(Frequency,MaxPercent,MinPercent,Brightness);
	
	//program the chip
	FLD_WR_DRF_NUM(_PBUS,_PWM,_HI,TicksNeededForHigh);
	FLD_WR_DRF_NUM(_PBUS,_PWM,_PERIOD,TicksNeededForClock);
	
	//store multiplier for get
	pDev->Dac.fpRelativeBrightness=Brightness;
	
	//store the raw PWM value in case someone triggers an on without an off
	pDev->Dac.fpPWMRegisterContents = REG_RD32(NV_PBUS_PWM);
			
	return RM_OK;
}

RM_STATUS  dacGetFlatPanelBrightness(PHWINFO pDev, U032 Head, U032 * Brightness,BOOL * ControllerIsOn)
{
	U032 NvPbusPwmEnable;
	
	//read register
	NvPbusPwmEnable=REG_RD_DRF(_PBUS,_PWM,_EN);
	
	//retrieve last brightness setting
	*Brightness=pDev->Dac.fpRelativeBrightness;
	
	//check the status of the control bit
	if(NvPbusPwmEnable)
	{
		*ControllerIsOn=TRUE;
	}
	else
	{
		*ControllerIsOn=FALSE;
	}
	
	return RM_OK;
}

U032 GetAbsoluteDifference(U032 value_a, U032 value_b)
{
	if(value_a>value_b)
	{
		return value_a-value_b;
	}
	else
	{
		return value_b-value_a;
	}
}

U032 GetTicksForFrequency(U032 Frequency)
{
	//this replaced alot of code - overcomplication on my part
	return 33333333/Frequency;
}

U032 GetPortionOfTotalSizeBasedOnPercentage(U032 TotalSize,U032 Percentage)
{

	//do calculation, round up
	return (((TotalSize*Percentage)+50)/100);
}

U032 DetermineFrequencyFromTickCount(U032 NumTicks)
{
	return ((333333330/NumTicks)+5)/10;
}

U032 GetRequiredTickCount(U032 Frequency,U032 MaxPercent,U032 MinPercent,U032 BaseMultiplier)
{
	U032 TicksInClockPeriod;
	U032 MaxTicks;
	U032 MinTicks;
	U032 DynamicRange;
	U032 PreliminaryTickCount;

	TicksInClockPeriod=GetTicksForFrequency(Frequency);
	MaxTicks=GetPortionOfTotalSizeBasedOnPercentage(TicksInClockPeriod,MaxPercent);
	MinTicks=GetPortionOfTotalSizeBasedOnPercentage(TicksInClockPeriod,MinPercent);

	DynamicRange=MaxTicks-MinTicks;

	PreliminaryTickCount=MinTicks+(((((DynamicRange*10)/255)+5)/10)*BaseMultiplier);
	
	if (PreliminaryTickCount>MaxTicks)
	{
		//if rounding produces a number too large, clip it
		PreliminaryTickCount=MaxTicks;
	}
	
	return PreliminaryTickCount;
}

BOOL dacIsFlatPanelOn(PHWINFO pDev,U032 Head)
{
    U008 lock;
    
	// Enable Head2 GPIO
    lock = UnlockCRTC(pDev, 1);
    CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
    RestoreLock(pDev, 1, lock);

    if((BIT(4)|BIT(6))&REG_RD32(NV_PCRTC_GPIO_EXT))
    {
        return TRUE;
    }
    
    return FALSE;
}

/*
//we are going to memorize the setting that we spec'd before, because we cannot reliably reproduce the same setting as
//was spec'd for. The specing is more like a hash than an exact formula. And hashes cannot be reversed easily....
U032 DetermineMultiplierForCurrentPeriod(PHWINFO pDev, U032 ClockTicksTotal,U032 DutyCycle)
{
	U032 DynamicRange,MaxTicks,MinTicks,PreliminaryMultiplier;

	MaxTicks=GetPortionOfTotalSizeBasedOnPercentage(ClockTicksTotal,pDev->Dac.fpMaxPercentDutyCycle);
	MinTicks=GetPortionOfTotalSizeBasedOnPercentage(ClockTicksTotal,pDev->Dac.fpMinPercentDutyCycle);
	DynamicRange=MaxTicks-MinTicks;
	
	PreliminaryMultiplier=((((DutyCycle-MinTicks)*10000)/(DynamicRange*10000/255))*10+5)/10;
	
	if(PreliminaryMultiplier>255)
	{
		PreliminaryMultiplier=255;
	}
	
		if(DutyCycle==MaxTicks)
		{
			PreliminaryMultiplier=255;
		}
		
		if(DutyCycle==MinTicks)
		{
			PreliminaryMultiplier=0;
		}
	
	
	return PreliminaryMultiplier;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dac.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DAC.C                                                             *
*   The DAC control management is updated here.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include <i2c.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include <edid.h>
#include <tv.h>
#include <devinit.h>
#include <smp.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>


// Const strings for accessing the registry

extern U008    CH_Init[];
// The "leaf" subkeys are OS-independent

#ifdef NTRM    
char strDisplayType[] = "Display Type";
char strDisplay2Type[] = "Display2 Type";
char strTVtype[] = "TV Type";
char strTVOutType[] = "TV Out";
char    strFpMode[] = "FlatPanelMode";
#else
extern char strDisplayType[];
extern char strDisplay2Type[];
extern char strTVtype[];
extern char strTVOutType[];
extern char strFpMode[];
#endif // NTRM

#define RED_OUT_300MV   0x800001A0
#define MAXCRTRETRIES   5

// remove this after all drivers switch to the new devices based API.
static BOOL using_new_api = FALSE;

//
// Set Display Power Managememnt Level.
//
RM_STATUS dacSetDpmLevel
(
    PHWINFO      pDev
)
{
    switch (pDev->Dac.DpmLevel)
    {
        default:
            break;
    }
    return (RM_OK);
}

RM_STATUS dacLoadWidthDepth
(
   PHWINFO pDev,
   U032    Head
)
{
    U032 data;

    switch (pDev->Dac.HalInfo.Depth)
    {
        case 8:
            data = NV_CIO_CRE_PIXEL_FORMAT_8BPP;
            break;
        case 15:
        case 16:
            data = NV_CIO_CRE_PIXEL_FORMAT_16BPP;
            break;
        case 24:
        case 30:
        case 32:
        default:
            data = NV_CIO_CRE_PIXEL_FORMAT_32BPP;
            break;
    }
    //
    // Write the CRTC register
    //
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

    return (RM_OK);
}

//
// Find closest DAC PLL parameters for a given frequency.
//
RM_STATUS dacCalcPLL
(
    PHWINFO pDev 
)
{
    U032 DeltaNew;
    U032 DeltaOld;
    U032 VClk;
    U032 Freq;
    U032 M;
    U032 N;
    U032 P;

    //
    // Calc VPLL.
    //
    DeltaOld = 0xFFFFFFFF;
    VClk     = pDev->Dac.HalInfo.VClk / 1000;
    //
    // Calculate frequencies using KHz to keep the math precision inside 32 bits.
    //
    for (P = 1; P <= 8; P <<= 1)
    {
        Freq = VClk * P;
        //
        // Bound the parameters to the internal frequencies of the DAC.
        //
        if ((Freq >= 64000) && (Freq <= 170000))
        {
            for (M = 7; M <= 12; M++)
            {
                N    = VClk * P * M / 12096;
                Freq = N * 12096 / P / M;
                if (Freq > VClk)
                    DeltaNew = Freq - VClk;
                else
                    DeltaNew = VClk - Freq;
                if (DeltaNew < DeltaOld)
                {
                    //
                    // Closer match.
                    //
                    pDev->Dac.HalInfo.VPllM = M;
                    pDev->Dac.HalInfo.VPllN = N;
                    pDev->Dac.HalInfo.VPllO = 1;
                    if (P==8)
                        pDev->Dac.HalInfo.VPllP = 3;
                    else if (P==4)
                        pDev->Dac.HalInfo.VPllP = 2;
                    else if (P==2)
                        pDev->Dac.HalInfo.VPllP = 1;
                    else 
                        pDev->Dac.HalInfo.VPllP = 0;
                    DeltaOld = DeltaNew;
                }
            }
        }
    }
    return (RM_OK);
}


//
//       dacCalcMNP - Return the PLL values for a specified frequency
//
//          Clock frequency in MHz * 100
//
// The algorithm is constrained to keep within 0.5% error
// to remain inside the VBE spec.
// However, if you have a choice of what frequencies you
// request, try to avoid the following requested frequencies
// when you get above 300MHz, as they require M values > 3.
//
//  14.31818 MHz
// 29739 - 29918
// 30219 - 30393
// 31178 - 31343
// 31658 - 31818
// 32617 - 32767
// 33097 - 33243
// 34056 - 34193
// 34536 - 34668
//
//  13.5000 MHz
// 29397 - 29552
// 29849 - 30000
// 30754 - 30896
// 31206 - 31344
// 32110 - 32239
// 32563 - 32767
// 33467 - 33582
// 33919 - 34030
// 34824 - 34926
//
U032 dacCalcMNP(
    PHWINFO  pDev,
    U032     Head,
    U032     Clock,
    U032    *M,    
    U032    *N,    
    U032    *P    
)
{
    U016  crystalFreq;
    U032  vclk;
    U016  vclkClosest = 0;
    U016  deltaOld;
    U016  bestM = 0;
    U016  bestP = 0;
    U016  bestN = 0;
    U016  lowM;
    U016  highM;
    U016  lowP, highP;
    U032  hiVclk1, hiVclk2;
    U032  FminVco, FmaxVco;
    
    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032  lwv, lwv2;
    
    U016  lwvs, vclks;
    U016  t;
    
    vclk = (U032)(Clock * 10);     // Make KHz
    
    deltaOld = 0xFFFF;
    hiVclk1 = 250000;
    hiVclk2 = 340000;
    lowP  = 0;
    highP = 4;

    // if initDac() has run then FminVco and FmaxVco will be set.
    // But we might be called during devinit processing prior to
    //    initDac(), so we need a fallback...
    // NOTE: these defaults duplicated in initDac()
    if ((pDev->Dac.FminVco == 0) || (pDev->Dac.FmaxVco == 0))
    {
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;
            
            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }
    
    FminVco = pDev->Dac.FminVco;
    FmaxVco = pDev->Dac.FmaxVco;

    // Apply any adjusts needed to FminVco/FmaxVco.
    //
    // 1). Make sure vclk is not so low that we'll miss the whole VCO range.
    //     Adjust FminVco to hit with the highest P (post divide).
    //
    if ((vclk << highP) < FminVco)
        FminVco = vclk << highP;

    //
    // 2). Also, check if two consecutive P values would cause us to miss
    //     the whole VCO range, where the first P is beneath FminVco and
    //     the next P is above FmaxVco.
    //
    for (powerP = lowP; powerP < highP; powerP++)
    {
        lwv = vclk << powerP;
        if ((lwv < FminVco) && ((lwv << 1) > FmaxVco))
        {
            // adjust FminVco or FmaxVco, whichever is closer
            if ((FminVco - lwv) < ((lwv << 1) - FmaxVco))
                FminVco = lwv;
            else
                FmaxVco = (lwv << 1);
        }
    }

    //
    // 3). Let a high vclk set the upper bound.
    //
    if (vclk > FmaxVco)
        FmaxVco = vclk;

    //
    // For NV15, we've got a bit in CR33 that indicates we're setting the
    // PLL in the "upper" VCO range.
    //
    if (IsNV15(pDev))
    {
        U008 lock, cr33;

        // unlock the extended regs
        CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

        // put NV15 into NV15 VPLL VCO programming mode
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, cr33, Head);
        cr33 |= (1 << DRF_SHIFT(NV_CIO_CRE_LCD_VPLL_VCO));
        CRTC_WR(NV_CIO_CRE_LCD__INDEX, cr33, Head);

        // restore lock, if previously locked
        if (lock == 0)
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    }

    //
    // Determine the current crystal frequency
    //   
    if (pDev->Chip.HalInfo.CrystalFreq == 14318180)
    {
        // 14.3Khz
        crystalFreq = 14318;

        lowM = 1;
             
        if (vclk > hiVclk2)
            highM = 2;
        else if (vclk > hiVclk1)
            highM = 6;
        else
            highM = 14;
    }
    else
    {
        // 13.5Khz
        crystalFreq = 13500;

        lowM = 1;

        if (vclk > hiVclk2)
            highM = 2;
        else if (vclk > hiVclk1)
            highM = 6;
        else
            highM = 13;
    }                      
    
    //
    // P Loop
    //
    for (powerP = lowP; powerP <= highP; powerP++) // Init Power of P
    {                             
        // M Loop
        for (m = lowM; m <= highM; m++)
        {                          
            lwv = vclk << powerP;   // vclk * P
            
            // Compare with internal range of DAC
            if ((lwv >= FminVco) && (lwv <= FmaxVco))
            {
                lwv *= (U032)m;    // vclk * P * M
                
                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);
                
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                
                if (n > 0xFF)
                    break;
                    
                lwv *= crystalFreq; // N * crystal
                   
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                
                i = m;
                j = m;
                
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                                       
                lwv2 = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                
                if (lwvs < vclks)
                {               
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }            
                    
                lwvs -= vclks;      // ABS(Freq-Vclk);
                
                //
                // If this is an NV5 or better, allow the higher PCLK settings to use a lower M
                // if the error is small enough.  Just looking for the lowest overall error
                // may result in an M that is too high, possibly introducing PLL jitter.
                //
                if (IsNV5orBetter(pDev))
                {                
                    //
                    // If VCLK > 250MHz and error is less than 0.2%, drop out
                    //
                    if (vclk > hiVclk1)
                    {
                        if (((vclk/lwvs) > 200) || (lwvs == 0)) // zero error; rare, but would cause exception
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                    }
                    
                    if (lwvs < deltaOld) // go to closest match with M < highM
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                                            
                }
                else // !NV5
                {
                    if (lwvs < deltaOld)
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                }
            }
        }
    }                             
    
    // Verify we've established M, N, P values to use
    if (!bestM && !bestN && !bestP)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: dacCalcMNP didn't set any M, N, P values!!!\n");
        DBG_BREAKPOINT();
    }

    //
    // Return the results
    //
    *M = bestM;
    *N = bestN;
    *P = bestP;
    
    return (vclkClosest);
} 

//
// Clock programming methods
//

//
// dacProgramMClk - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramMClk
(
    PHWINFO pDev
)
{
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 Head = 0;  // MPLL is on head 0

    // Compute M, N, O, and P values
    dacCalcMNP( pDev, Head, pDev->Dac.HalInfo.MClk / 10000, &mNew, &nNew, &pNew );

    // Update Dac structure
    pDev->Dac.HalInfo.MPllM = mNew;
    pDev->Dac.HalInfo.MPllN = nNew;
    pDev->Dac.HalInfo.MPllO = 1;
    pDev->Dac.HalInfo.MPllP = pNew;

    return(nvHalDacProgramMClk(pDev));
}

//
// dacProgramNVClk - Program NVCLK based on the value in
// pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramNVClk
(
    PHWINFO pDev 
)
{
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 Head = 0; // NVPLL is on head 0

    // Compute M, N, O, and P values
    dacCalcMNP(pDev, Head, pDev->Dac.HalInfo.NVClk / 10000, &mNew, &nNew, &pNew);

    // Update Dac structure
    pDev->Dac.HalInfo.NVPllM = mNew;
    pDev->Dac.HalInfo.NVPllN = nNew;
    pDev->Dac.HalInfo.NVPllO = 1;
    pDev->Dac.HalInfo.NVPllP = pNew;

    return(nvHalDacProgramNVClk(pDev));
}

RM_STATUS dacGetDisplayInfo
(
    PHWINFO pDev,
    U032 DisplayMap,
    U032 *Head,
    U032 *DisplayType,
    U032 *I2CWritePort,
    U032 *I2CReadPort
)
{
    U032 flag = 0;
    PDACDCBDEVDESC pDevDesc;
    pDACDCBI2CRECORD pDCBI2c;

    pDevDesc = pDev->Dac.DCBDesc;
    pDCBI2c  = pDev->Dac.DCBI2c;

    while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL)
    {
        if (pDevDesc->DevTypeUnit == DisplayMap)
        {
            flag = 1;
            break;
        }
        pDevDesc++;
        pDCBI2c++;
    }

    if (!flag) return RM_ERROR;

    if (Head)         *Head = pDevDesc->DCBRecHead;
    if (DisplayType)  *DisplayType = pDevDesc->DCBRecType;
    if (I2CWritePort) *I2CWritePort = pDCBI2c->WritePort;
    if (I2CReadPort)  *I2CReadPort = pDCBI2c->ReadPort;

    return RM_OK;
}

//
// dacProgramPClk - Program PCLK based on the value in pDev->Dac.PClk
//
// This routine uses the value in pDev->Dac.PClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramPClk
(
    PHWINFO pDev, 
    U032    Head,
    U032    PixelClock
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
    U032 mNew;
    U032 nNew;
    U032 pNew;

    // Compute M, N, O, and P values
    dacCalcMNP( pDev, Head, PixelClock, &mNew, &nNew, &pNew );

    // Update Dac structure
    pDev->halHwInfo.pDacHalInfo->VPllM = mNew;
    pDev->halHwInfo.pDacHalInfo->VPllN = nNew;
    pDev->halHwInfo.pDacHalInfo->VPllO = 1;
    pDev->halHwInfo.pDacHalInfo->VPllP = pNew;

    vidLutCurDacHalObj.Head = Head;

    return(nvHalDacProgramPClk(pDev, PixelClock, (VOID*) &vidLutCurDacHalObj));
}

// This function just enables the cursor by setting bit 0 of config register 0x31 to 1.
// The cursor image is not changed in any way.
VOID dacEnableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    cr31;
    U008    lock;
    
    // Unlock CRTC extended regs
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    
    CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, Head);           
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (cr31 | (1 << DRF_SHIFT(NV_CIO_CRE_HCUR_ADDR1_ENABLE))), Head);

    // Relock CRTC extended regs
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

}

// This function just disables the cursor by setting bit 0 of config register 0x31 to 0.
// The cursor image is not changed in any way.
VOID dacDisableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    cr31;
    U008    lock;
    
    // Unlock CRTC extended regs
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    
    CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, Head);           
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (cr31 & ~(1 << DRF_SHIFT(NV_CIO_CRE_HCUR_ADDR1_ENABLE))), Head);

    // Relock CRTC extended regs
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}

/*  This function is mis-named. It also loads the cursor image offset in addition to enabling the
    cursor. This is used by the old style of cursor manipulation. 
*/
VOID enableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    lock;
    
    // Unlock CRTC extended regs
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    
#ifdef NTRM    
	// Tell the DAC where to load the image from
	// The address is in pages, so shift 4 bits.
	if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x00000001)    // color or mono?
	{
        CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f, Head);
        CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 4) & 0xf8), Head);
	}
	else
	{
        // call crtc_wrm: need to add this routine
        CRTC_WRM(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f);
        CRTC_WRM(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 4) & 0xf8) | 1);
	}
#else
    // Tell the DAC where to load the image from. The address is in pages, so shift 4 bits.
#ifdef WIN31
    // On NV4 and later HCUR_ADDR0 is 23:17, HCUR_ADDR1 is 16:11 (on NV3 its 22:16)
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 13) & 0x7f);
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 5) & 0xfc) | 1);
//JohnH The Win9x code below is incorrect for NV4 and up, but the correct address
//JohnH gets set in dacProgramCursorImage.
//JohnH CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f);
//JohnH CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (pDev->Dac.CursorImageInstance >> 4) & 0xf8);
#endif // WIN31
#endif // NTRM
    
    // JJV - I am removing this call. Vblank will call this later if needed.
    //       This will fix a multimonitor cursor problem.  
    // Enable the cursor.
    //dacEnableCursor(pDev);

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
        
    return;
}

/*  Turn off the enable bit in CRTC reg
    This function unlocks the CRTC extended registers and calls dacDisableCursor.
    This is used by the old style cursor manipulation functions. */
VOID disableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 lock;

#ifndef NTRM
    pDev->Dac.CrtcInfo[Head].CursorType = DAC_CURSOR_DISABLED;    // disable updates in vblank
#endif

    // Unlock CRTC extended regs
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    dacDisableCursor(pDev, Head);

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}

RM_STATUS dacProgramCursorPosition
(
    PHWINFO pDev, 
    U032    Head,
    U032    cursorX, 
    U032    cursorY 
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // on modes below 400 lines, scanline doubling is used. we need to adjust cursor y postion
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac && pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode)
        cursorY *= 2;

//    if (CRTCHALINFO(pDev, Head, DisplayType) == TV)
        cursorX += pDev->Framebuffer.CursorAdjust;  // HW bug in NV4, position is off a little on TV

    DAC_REG_WR32(NV_PRAMDAC_CU_START_POS, cursorX | (cursorY << 16), Head);

    return RM_OK;
}

VOID dacDisableImage
(
    PHWINFO pDev,
    U032 Head
)
{
    U016 data;
    U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);

    EnableHead(pDev, Head);        // sequencer updates require setting CR44 

    // turn on blank
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    data |= 0x2000;
    WriteIndexed(NV_PRMVIO_SRX, data);

    EnableHead(pDev, prevHead);    // restore previous CR44 value
}

VOID dacEnableImage
(
    PHWINFO pDev,
    U032 Head
)
{
    U016 data;
    U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);

    EnableHead(pDev, Head);        // sequencer updates require setting CR44 

    // turn off blank
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    data &= ~0x2000;
    WriteIndexed(NV_PRMVIO_SRX, data);

    EnableHead(pDev, prevHead);    // restore previous CR44 value
}


VOID dacEnableDac
(
    PHWINFO pDev,
    U032 Head
)
{
    U008 lock, data08;    
    
    if (!IsNV11(pDev) && (Head == 1)) // if not dual-head
    {
        return;
    }
    
    // unlock CRTC extended regs
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    // enable vblank interrupt
    DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 1, Head);
    pDev->Dac.CrtcInfo[Head].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
    
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
        
            // TO DO: this decision must be made by the HAL
            // if normal VGA (internal DAC)
            if (Head == 0) 
            {
                dacEnableImage(pDev, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);  // CRT on
                //
                // We need to be careful about powering down the TMDS
                // transmitter on NV11 because we can lose a flat
                // panel connected to the second crtc (head 1).
                //
                if (IsNV11(pDev))
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _FPCLK, Head);     // FPCLK off only;leave TMDS going for secondary crtc
                else
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);      // FPCLK/TMDS both off
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, (data08 & ~0x02), Head);  // clear CR33[1] (BIOS flag)
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & 0x3F, Head);
                dacSetCursorBlink(pDev, Head, 0); // set cursor blink rate for DOS
            }
        
            // PRAMDAC_FP is driving analog
            else
            {
                // restore sync states
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, pDev->Dac.CrtcInfo[Head].CurrentVsyncState, Head);
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, pDev->Dac.CrtcInfo[Head].CurrentHsyncState, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);
            }
            
            break;   
                                       
        case DISPLAY_TYPE_FLAT_PANEL:
        
            // restore sync states
            DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, pDev->Dac.CrtcInfo[Head].CurrentVsyncState, Head);
            DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, pDev->Dac.CrtcInfo[Head].CurrentHsyncState, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);

            if (pDev->Power.MobileOperation)
    	   		dacPowerOnMobilePanel(pDev,Head);
            break;                              
            
        case DISPLAY_TYPE_TV:
            dacEnableTV(pDev, Head);
            break;
            
        default:
            break;
    }

    // relock extended regs
    if (lock == 0)
    {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    }

} // end of dacEnableDac()

VOID dacDisableDac
(
    PHWINFO pDev,
    U032 Head
)
{
    if (!IsNV11(pDev) && (Head == 1)) // if not dual-head
    {
        return;
    }

    // disable vblank interrupt
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, Head);
    DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, Head);
    pDev->Dac.CrtcInfo[Head].StateFlags &= ~DAC_CRTCINFO_VBLANK_ENABLED;

    // device-specific disabling...
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
        
            // TO DO: this decision must be made by the HAL
            // head 0 -- treat as CRT
            if (Head == 0)
            {
                // disable sync
                dacSetSyncState(pDev, Head, 0, 0);
                //
                // BIOS WORKAROUND
                //
                // For now the Mobile BIOS does not reenable the dac power when performing
                // a modeset, therefore after we disable the power upon windows exit,
                // the CRT remains blank (even after warm restart).  Until the BIOS is
                // updated to account for this, I need to make sure we don't power
                // off the dac.
                //
                // The only issue with not doing the powerdown is with monitors that
                // don't abide by the blank-on-disabled-syncs rule, but that exposure
                // is small.
                //
                // Only do this for mobile
                //
                if (!pDev->Power.MobileOperation) {
                    dacDisableImage(pDev, Head);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);
                }
            }
            
            // head 1 -- treat as DFP
            else
            {    
                // disable sync
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _DISABLE, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _DISABLE, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);
            }
            break;
            
        case DISPLAY_TYPE_FLAT_PANEL:
        
            // disable sync
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _DISABLE, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _DISABLE, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);

            // if we're mobile, turn the power off as well
            if (pDev->Power.MobileOperation)
                dacPowerOffMobilePanel(pDev, Head);
            
            break;
            
        case DISPLAY_TYPE_TV:
        
            // this has to be encoder dependent
            dacDisableTV(pDev, Head);
            break;
            
        default:
            break;
    }

} // end of dacDisableDac()

RM_STATUS dacProgramVideoStart
(
    PHWINFO pDev, 
    U032    Head,
    U032    StartAddr, 
    U032    Pitch 
)
{
    if (!pDev->Vga.Enabled)
    {
        VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;

        vidLutCurDacHalObj.Head = Head;

        //
        // If the pitch of the RGB surface does not match the current display width, we
        // need to tweak the CRTC to a different pitch adjust.
        //
        // Compare Pitch against pDev->Framebuffer.DisplayPitch rather than trying to
        // calculate it, since DisplayPitch has been aligned for the HW already (e.g. NV10).
        //
        // Checking against DisplayPitch actually doesn't save us in the case where the 2
        // surfaces have different pitch values. This really needs to be checking against
        // the last loaded pitch ... but then we'd be programming more than just the start
        // addr 1/2 the time.
        //
        // For now, print out a message, so the driver can be changed to flip between
        // surfaces of the same pitch making our job easier and giving us the best perf.
        //        
//#if 0 // This was used for video class63, but later classes take care of this case
//        if (Pitch != pDev->Framebuffer.DisplayPitch)
        {

            U008      i, lock, crtc_index;
            U032      val32;

//            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Flipping between different pitched surfaces!!!\n\r");

            //
            // Save the current CRTC index
            //
            if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
                crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
            else
                crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

            // Unlock CRTC extended regs
            lock = ReadCRTCLock(pDev, Head);
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

            // Write the alternative pitch to the CRTC Offset Register
            // The value written to CR13/CR19 is the number of 8-byte chunks
            CRTC_WR(NV_CIO_CR_OFFSET_INDEX, (Pitch >> 3) & 0xFF, Head);

            // Modify the bits in the extended register as well
            CRTC_RD(NV_CIO_CRE_RPC0_INDEX, i, Head);
            i &= 0x1F;
            val32 = ((Pitch >> 3) & 0x700) >> 3;
            i |= (U008)val32; 
            CRTC_WR(NV_CIO_CRE_RPC0_INDEX, i, Head);

            // Relock extended regs
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

            // Restore index
            if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
                REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
            else
                REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);  // restore crtc index

        }
//#endif

        // Program the new start address; this will latch at the end of blank
#ifdef  STEREO_SUPPORT
        if (pDev->pStereoParams)
        {
            pDev->pStereoParams->FlipOffsets[3][0] = StartAddr;
            if (pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED)
            {
                return RM_OK;
            }
        }
#endif  //STEREO_SUPPORT
        nvHalDacSetStartAddr(pDev, StartAddr, &vidLutCurDacHalObj);
    }
    return RM_OK;
}

RM_STATUS dacProgramLUT
(
    PHWINFO pDev, 
    U032    Head,
    U032*   Palette, 
    U032    numEntries 
)
{
    U032    i, rgb;

    // start at palette 0 and autoincrement
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0, Head);
    for (i = 0; i < numEntries; i++)
    {
        rgb = Palette[i];
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)(rgb >> 16), Head);    // b
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)(rgb >> 8), Head);     // g
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)rgb, Head);            // r
    }
    return RM_OK;
}

RM_STATUS dacProgramScanRegion
(
    PHWINFO pDev,
    U032    Head,
    U032    startLine,
    U032    stopLine,
    U032    polarity
)
{
    //
    // Note that this routine should only be called for NV15, the only
    // chip with this support.  Since no other chips will have this
    // feature (past or future), no need to overload a chip func.
    //
    if (IsNV15(pDev) || IsNV11(pDev) || IsNV20(pDev))
    {
        DAC_REG_WR32(NV_PCRTC_RASTER_START, startLine | DRF_NUM(_PCRTC, _RASTER_START, _POL, polarity), Head);
        DAC_REG_WR32(NV_PCRTC_RASTER_STOP,  stopLine, Head);
        return (RM_OK);    
    }
    else
        return (RM_ERROR);
}

/************************************************************
* Here is how the H & V blank and retrace values map to the config registers:
    Hbs<0:7> = CR02<0:7>
    Hbe<0:4> = CR03<0:4>
    Hbe<5>   = CR05<7>
    Hbe<6>   = CR25<4>
    Vbs<0:7> = CR15<0:7>
    Vbs<8>   = CR07<3>
    Vbs<9>   = CR09<5>
    Vbs<10>  = CR25<3>
    Vbe<0:7> = CR16<0:7>
    
    Hrs<0:7> = CR04<0:7>
    Hre<0:4> = CR05<0:4>
    Vrs<0:7> = CR10<0:7>
    Vrs<8>   = CR07<2>
    Vrs<9>   = CR07<7>
    Vrs<10>  = CR25<2>
    Vre<0:3> = CR11<0:3>
***********************************************************/

//  After every mode set, we save the H & V retrace in nvinfo, so we can restore the default screen position
VOID dacSaveMonitorDefaultPosition
(
    PHWINFO pDev,
    U032    Head
)
{
    PDACMONITORPOSITION pDacMonPos;
    U016    Hrs, Hre, Vrs, Vre;
    U016    Hbs, Hbe, Vbs, Vbe;
    U008    Cr03, Cr05, Cr07, Cr09, Cr25;
    short   temp;

// debug 
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);

    // read all the necessary config registers.
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);

    // Construct Hbs
    CRTC_RD(NV_CIO_CR_HBS_INDEX, Hbs, Head);
    // Construct Hbe
    Hbe = Cr03 & BITS0_4;
    if (Cr05 & BIT7)
        Hbe |= BIT5;
    if (Cr25 & BIT4)
        Hbe |= BIT6;
    // Construct Vbs
    CRTC_RD(NV_CIO_CR_VBS_INDEX, Vbs, Head);
    if (Cr07 & BIT3)
        Vbs |= BIT8;
    if (Cr09 & BIT5)
        Vbs |= BIT9;
    if (Cr25 & BIT3)
        Vbs |= BIT10;
    // Construct Vbe
    CRTC_RD(NV_CIO_CR_VBE_INDEX, Vbe, Head);

    // Construct Hrs
    CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);
    // Construct Hre
    Hre = Cr05 & BITS0_4;
    // Construct Vrs
    CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
    if (Cr25 & BIT2)
        Vrs |= BIT10;
    if (Cr07 & BIT7)
        Vrs |= BIT9;
    if (Cr07 & BIT2)
        Vrs |= BIT8;
    // Construct Vre
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Vre, Head);
    Vre &= BITS0_3;

    // The horizontal/vertical, blank/retrace end values are really the width of the respective signal.
    // Calculate the absolute end values. It is a bit cumbursome because the number of bits of information
    // is not uniform.
    // The formula is: <Absolute end value> = <start-value> + ((<width> - <start-value>) & (# of bits))
    temp = (short)Hbe - (short)Hbs; 
    temp &= 0x7f; // just take the low 7 bits
    Hbe = Hbs + temp;
    
    temp = (short)Hre - (short)Hrs; 
    temp &= 0x1f; // just take the lower 5 bits
    Hre = Hrs + temp;

    temp = (short)Vbe - (short)Vbs; 
    temp &= 0x7f; // just take the low 7 bits
    Vbe = Vbs + temp;
    
    temp = (short)Vre - (short)Vrs; 
    temp &= 0xf; // just take the lower 4 bits
    Vre = Vrs + temp;

    // save it off in nvinfo
    pDacMonPos = &pDev->Dac.CrtcInfo[Head].MonitorPosition;
    pDacMonPos->Hbs = Hbs;
    pDacMonPos->Hbe = Hbe;
    pDacMonPos->Vbs = Vbs;
    pDacMonPos->Vbe = Vbe;
    pDacMonPos->Hrs = Hrs;
    pDacMonPos->Hre = Hre;
    pDacMonPos->Vrs = Vrs;
    pDacMonPos->Vre = Vre;
}

//****************************************************************************************
/*  Adjust monitor horizontal position
    This is accomplished by increasing/decreasing the retrace start/end values
    The adjustment is character granularity
*/
static VOID SetRetraceH
(   PHWINFO pDev, 
    U032    Head,
    U032    Hrs, 
    U032    Hre
)
{
    U008    Cr05;

    // Get HRE
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    Cr05 &= ~BITS0_4;        // Clear bits 0:4
    Cr05 |= (Hre & BITS0_4); // Combine new HRE bits 0:4 with other bits

    // Write out adjustment
    CRTC_WR(NV_CIO_CR_HRS_INDEX, Hrs, Head);
    CRTC_WR(NV_CIO_CR_HRE_INDEX, Cr05, Head);
}

//****************************************************************************************
/*  Adjust monitor vertical position
    This is accomplished by increasing/decreasing the retrace start/end values
    The adjustment is scanline granularity
*/
static VOID SetRetraceV
(   PHWINFO pDev, 
    U032    Head,
    U032    Vrs, 
    U032    Vre
)
{
    U008    Cr10, Cr11, Cr07, Cr25;

    // Get CR25, CR7, CR11, mask VR bits
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    Cr07 &= ~(BIT7 | BIT2);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    Cr25 &= ~BIT2;
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    Cr11 &= ~BITS0_3;
        
    Cr10 = (U008)(Vrs & BITS0_7);
    // Combine new VRS value with other bits in CR07, CR25.
    if (Vrs & BIT10)
        Cr25 |= BIT2;
    if (Vrs & BIT9)
        Cr07 |= BIT7;
    if (Vrs & BIT8)
        Cr07 |= BIT2;

    // Combine VRE with other bits in CR11
    Cr11 |= (Vre & BITS0_3);
    
    // Write out adjustment
    CRTC_WR(NV_CIO_CR_VRS_INDEX, Cr10, Head);  
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Cr11, Head);
}

//****************************************************************************************
/*  Adjust monitor postion
*/
RM_STATUS dacSetMonitorPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    Hrs,
    U032    Hre,
    U032    Vrs,
    U032    Vre
)
{
U032    Vde, Vt;
U008    Cr01, Cr07, Cr11, Cr21, Cr25, val;
U008    lock;
U008    UpdatedCr11;

    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    val = Cr11 & 0x7f;                          // clear write protection bit
    CRTC_WR(NV_CIO_CR_VRE_INDEX, val, Head);

    CRTC_RD(0x21, Cr21, Head);
    CRTC_WR(0x21, 0xf8, Head);       // disable shadowing for TV
    
    CRTC_RD(NV_CIO_CR_HDE_INDEX, Cr01, Head);     // read H display end

    // Check that the sync width doesn't go to 0 and that the sync pulse is beyond display end
    if ((Hre <= (Hrs & 0x1f)) || (Hrs <= Cr01))
    {
        return RM_ERROR;
    }

    // Get overflow bits
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);    

    // Check that the sync width doesn't go to 0 and that the sync pulse is beyond display end
    CRTC_RD(NV_CIO_CR_VDE_INDEX, Vde, Head);    // read V display end (CR12)
    if (Cr07 & BIT(1)) Vde |= 0x100;
    if (Cr07 & BIT(6)) Vde |= 0x200;
    if (Cr25 & BIT(1)) Vde |= 0x400;
    
    // Check also that the sync pulse doesn't enter the display start (vertical total)
    CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
    if (Cr07 & BIT(0)) Vt |= 0x100;
    if (Cr07 & BIT(5)) Vt |= 0x200;    
    if (Cr25 & BIT(0)) Vt |= 0x400; 

    // Check for error conditions
    if ((Vre <= Vrs) || (Vrs <= Vde) || (Vre >= Vt))
    {
        return RM_ERROR;
    }

    /*
    // Make sure we don't change these values during the vblank interval.
    while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_ACTIVE)
        ;
    while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_INACTIVE)
        ;
    */

    SetRetraceH(pDev, Head, Hrs, Hre);
    SetRetraceV(pDev, Head, Vrs, Vre);

    CRTC_WR(0x21, Cr21, Head);

    // the lower 4 bits in CR11 were updated by SetRetraceV(), don't mess it up
    CRTC_RD(NV_CIO_CR_VRE_INDEX, UpdatedCr11, Head);
    Cr11 = (Cr11 & ~BITS0_3) | (UpdatedCr11 & BITS0_3);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Cr11, Head);

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

    return RM_OK;
}
 
//  Get the H & V Blank and retrace values from nvinfo.
VOID dacGetMonitorDefaultPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    *pHbs,
    U032    *pHbe,
    U032    *pVbs,
    U032    *pVbe,
    U032    *pHrs,
    U032    *pHre,
    U032    *pVrs,
    U032    *pVre
)
{
    PDACMONITORPOSITION pDacMonPos;

    pDacMonPos = &pDev->Dac.CrtcInfo[Head].MonitorPosition;

    *pHbs = pDacMonPos->Hbs;
    *pHbe = pDacMonPos->Hbe;
    *pVbs = pDacMonPos->Vbs;
    *pVbe = pDacMonPos->Vbe;
    *pHrs = pDacMonPos->Hrs;
    *pHre = pDacMonPos->Hre;
    *pVrs = pDacMonPos->Vrs;
    *pVre = pDacMonPos->Vre;
}

//  Get a string pointing to a key in the Display section
//  The string is of the type hresxyres, e.g. "1024x768"
//  Return 0 if its not a desktop mode
void dacFindRegistryKeyDisplayPosition
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    char    *strDisplayMode
)
{
    U032    hres, vres;
    U032    strIndex;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hres = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vres = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    //
    // For non-TV modes, convert the resolution into a string
    //
    // Oh, to have a sscanf() handy...
    //
    strIndex = 0;   // start at the beginning

    //
    // Prepend the TV format if necessary
    //
    if (!isMonitor)
    {
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                strDisplayMode = osStringCopy(strDisplayMode, "NTSC");
                strIndex = 4;
                break;
            case PAL_M: // unique case; does not use normal PAL timing
                strDisplayMode = osStringCopy(strDisplayMode, "PALM");
                strIndex = 4;
                break;
            default:    // rest are PAL modes
                strDisplayMode = osStringCopy(strDisplayMode, "PAL");
                strIndex = 3;
                break;     
        }
    }

    //
    // Assume the resolution is always below 9999x9999 and above 99x99
    // (this makes it a bit easier, especially with floating 0's)
    //
    // Start with the horizontal resolution first
    //
    if (hres / 1000)
    {
        strDisplayMode[strIndex++] = (U008)(hres/1000)+'0';
        hres -= (hres/1000)*1000;
    }

    if (hres / 100)
    {
        strDisplayMode[strIndex++] = (U008)(hres/100)+'0';
        hres -= (hres/100)*100;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    if (hres / 10)
    {
        strDisplayMode[strIndex++] = (U008)(hres/10)+'0';
        hres -= (hres/10)*10;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    strDisplayMode[strIndex++] = (U008)hres + '0';

    //
    // Append a lower case 'x'
    //
    strDisplayMode[strIndex++] = 'x';

    // 
    // Now generate the vertical value
    //
    if (vres / 1000)
    {
        strDisplayMode[strIndex++] = (U008)(vres/1000)+'0';
        vres -= (vres/1000)*1000;
    }
    
    if (vres / 100)
    {
        strDisplayMode[strIndex++] = (U008)(vres/100)+'0';
        vres -= (vres/100)*100;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    if (vres / 10)
    {
        strDisplayMode[strIndex++] = (U008)(vres/10)+'0';
        vres -= (vres/10)*10;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    strDisplayMode[strIndex++] = (U008)vres + '0';

    //
    // Zero append to the end
    //
    strDisplayMode[strIndex] = NULL;

    return;

}

//  Save the screen position for the current mode in the registry
//  Find the registry key for this device and this mode
RM_STATUS dacWriteDesktopPositionToRegistry
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    U008 *  position, 
    U032    numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";
    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, isMonitor, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = NULL;

    return osWriteRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, position, numBytes);
}

//  Read the screen position for the current mode from the registry
RM_STATUS dacReadDesktopPositionFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    U008 *  position, 
    U032 *  numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";

    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, isMonitor, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = NULL;

    return osReadRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, position, numBytes);
}

//  Return the registry values for TV position, brightness, contrast and flicker filter.
RM_STATUS dacReadTVDesktopPositionFromRegistry
(
    PHWINFO pDev,
    U032 Head,
    U008 *Params,
    U032 *numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";

    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, 0, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = NULL;

    return osReadRegistryBinary(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, Params, numBytes);
}

//  Read the TV Out format (Composite on S-video, S-Video, Auto select)
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacReadTVOutFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032   *type
)
{
    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVOutType, type);
}

//  Check Registry for Philips 7108B special setting
RM_STATUS dacReadTVPhilipsBFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032   *type
)
{
char strTVPhilipsB[] = "Philips7108B";

    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVPhilipsB, type);
}

//  Write the TV Out format (Composite on S-video, S-Video, Auto select)
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacWriteTVOutToRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032    type
)
{
    pDev->Dac.TVoutput = type;  // save in pDev, because NT cannot read registry at modeset time.
    return osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strTVOutType, type);
}

RM_STATUS dacGetMonitorInfo
(
    PHWINFO pDev,
    U032    Head,
    U032    *MonitorConnected
)
{
    *MonitorConnected = 0;

    if (dacMonitorConnectStatus(pDev, Head))
        *MonitorConnected = 1;
    return RM_OK;
}
// Write a CRTC timing parameter into the CRTC registers
VOID dacSetCRTC
(
    PHWINFO pDev, 
    U032 Head, 
    U032 Param, 
    U032 Val
)
{
    U008 Crtc;
    U032 Val2;

    switch (Param) 
    {
    case H_TOTAL:
        Val2 = (Val >> 3) - 5;
        Crtc = (U008)(Val2 & 0xff);
        CRTC_WR(0, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x100)               
            Crtc |= BIT(0);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_DISPLAY_END:
        Crtc = (U008) ((Val >> 3) - 1);
        CRTC_WR(1, Crtc, Head);
        break;
    case H_BLANK_START:
        Val2 = (Val >> 3) - 1;
        Crtc = (U008)(Val2 & 0xff);
        CRTC_WR(2, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(2);
        if (Val2 & 0x100)               
            Crtc |= BIT(2);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_BLANK_END:
        Val2 = (Val >> 3) - 1;
        CRTC_RD(3, Crtc, Head);     // HBE bits 4:0
        Crtc &= 0xe0;
        Crtc |= (U008)(Val2 & 0x1f);
        CRTC_WR(3, Crtc, Head);
        CRTC_RD(5, Crtc, Head);
        Crtc &= ~BIT(7);
        if (Val2 & 0x20)               // HBE bit 5
            Crtc |= BIT(7);
        CRTC_WR(5, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(4);
        if (Val2 & 0x40)
            Crtc |= BIT(4);             // HBE bit 6
        CRTC_WR(0x25, Crtc, Head);
        break;
    case H_RETRACE_START:
        Val2 = (Val >> 3) + 1;
        Crtc = (U008) (Val2 & 0xFF);
        CRTC_WR(4, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x100)
            Crtc |= BIT(3);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_RETRACE_END:
        Val2 = (Val >> 3) + 1;
        CRTC_RD(5, Crtc, Head);     // HRE bits 4:0
        Crtc &= 0xe0;
        Crtc |= (U008)(Val2 & 0x1f);
        CRTC_WR(5, Crtc, Head);
        break;
    case V_TOTAL:
        Val2 = Val - 2;
        Crtc = (U008) Val2;
        CRTC_WR(6, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(0x21);
        if (Val2 & 0x100) Crtc |= BIT(0);
        if (Val2 & 0x200) Crtc |= BIT(5);
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x400) Crtc |= BIT(0);
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x800) Crtc |= BIT(0);
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_DISPLAY_END:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x12, Crtc, Head);    // VDE 7:0
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(0x42);
        if (Val2 & 0x100) Crtc |= BIT(1);  // VDE 8
        if (Val2 & 0x200) Crtc |= BIT(6);  // VDE 9
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(1);
        if (Val2 & 0x400) Crtc |= BIT(1);  // VDE 10
        CRTC_WR(0x25, Crtc, Head);
        break;
    case V_RETRACE_START:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x10, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(BIT(2) | BIT(7));
        if (Val2 & 0x100) Crtc |= BIT(2);  // VRS 8
        if (Val2 & 0x200) Crtc |= BIT(7);  // VRS 9
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(2);
        if (Val2 & 0x400) Crtc |= BIT(2);  // VRS 10
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(4);
        if (Val2 & 0x800) Crtc |= BIT(4);  // VRS 11
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_RETRACE_END:
        Val2 = Val - 1;
        CRTC_RD(0x11, Crtc, Head);
        Crtc &= 0xF0;
        Crtc |= (U008) (Val2 & 0x0F);
        CRTC_WR(0x11, Crtc, Head);
        break;
    case V_BLANK_START:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x15, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x100) Crtc |= BIT(3);  // VBS 8
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(9, Crtc, Head);
        Crtc &= ~BIT(5);
        if (Val2 & 0x200) Crtc |= BIT(5);  // VBS 9
        CRTC_WR(9, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x400) Crtc |= BIT(3);  // VBS 10
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(6);
        if (Val2 & 0x800) Crtc |= BIT(6);  // VBS 11
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_BLANK_END:
        Crtc = (U008) Val - 1;
        CRTC_WR(0x16, Crtc, Head);
        break;
    }
}

// Write a CRTC timing parameter into the CRTC registers
U032 dacGetCRTC
(
    PHWINFO pDev, 
    U032 Head, 
    U032 Param
)
{
    U008 Crtc;
    U032 Val=0, Val2;

    switch (Param) 
    {
    case H_TOTAL:
        CRTC_RD(0, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x100;
        Val = (Val + 5) * 8;
        break;
    case H_DISPLAY_END:
        CRTC_RD(1, Crtc, Head);
        Val = (U032)(Crtc + 1) * 8;
        break;
    case H_BLANK_START:
        CRTC_RD(2, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x100;
        Val = (Val + 1) * 8;
        break;
    case H_BLANK_END:
        CRTC_RD(3, Crtc, Head);     // HBE bits 4:0
        Val = (U032)(Crtc & 0x1f);
        CRTC_RD(5, Crtc, Head);
        if (Crtc & 0x80) Val |= 0x20;
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(4)) Val |= 0x40;
        Val++;
        Val2 = dacGetCRTC(pDev, Head, H_BLANK_START);
        Val2 >>= 3;                     // convert HRS back to real chars
        Val2++;
        if (Val >= (Val2 & 0x7f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0x180);
        }
        else
        {
            Val |= ((Val2 + 0x80) & 0x180);    // add Start + carry
        }
        Val *= 8;
        break;
    case H_RETRACE_START:
        CRTC_RD(4, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x100;
        Val--;
        Val *= 8;
        break;
    case H_RETRACE_END:
        CRTC_RD(5, Crtc, Head);     // HRE bits 4:0
        Val = (U032)(Crtc & 0x1f);
        Val--;
        Val2 = dacGetCRTC(pDev, Head, H_RETRACE_START);
        Val2 >>= 3;                     // convert HRS back to real chars
        Val2--;
        if (Val >= (Val2 & 0x1f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0x1E0);
        }
        else
        {
            Val |= ((Val2 + 0x20) & 0x1E0);    // add Start + carry
        }
        Val *= 8;
        break;
    case V_TOTAL:
        CRTC_RD(6, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x100;
        if (Crtc & BIT(5)) Val |= 0x200;
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x400;
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x800;
        Val += 2;
        break;
    case V_DISPLAY_END:
        CRTC_RD(0x12, Crtc, Head);    // VDE 7:0
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(1)) Val |= 0x100;  // VDE 8
        if (Crtc & BIT(6)) Val |= 0x200;  // VDE 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(1)) Val |= 0x400;  // VDE 10
        Val++;
        break;
    case V_RETRACE_START:
        CRTC_RD(0x10, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x100;  // VRS 8
        if (Crtc & BIT(7)) Val |= 0x200;  // VRS 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x400;  // VRS 10
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(4)) Val |= 0x800;  // VRS 11
        Val++;
        break;
    case V_RETRACE_END:
        CRTC_RD(0x11, Crtc, Head);
        Val = (U032)(Crtc & 0x0f);
        Val2 = dacGetCRTC(pDev, Head, V_RETRACE_START);
        if (Val >= (Val2 & 0x0f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0xFF0);
        }
        else
        {
            Val |= ((Val2 + 0x10) & 0xFF0);    // add Start + carry
        }
        Val++;
        break;
    case V_BLANK_START:
        CRTC_RD(0x15, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x100;  // VBS 8
        CRTC_RD(9, Crtc, Head);
        if (Crtc & BIT(5)) Val |= 0x200;  // VBS 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x400;  // VBS 10
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(6)) Val |= 0x800;  // VBS 11
        Val++;
        break;
    case V_BLANK_END:
        CRTC_RD(0x16, Crtc, Head);
        Val = (U032)Crtc + 1;
        Val2 = dacGetCRTC(pDev, Head, V_RETRACE_START); // End = Start + width of sync
        if (Val >= (Val2 & 0xff))    // if low byte of end > low byte of start 
        {
            Val |= (Val2 & 0xf00);  // combine with upper bits of V_BLANK_START
        }
        else
        {
            Val |= ((Val2 + 0x100) & 0xf00);    // combine with upper bits of V_BLANK_START plus carry
        }
        break;
    }
    return Val;
}
//  Get CRTC timing values from either CRTC registers or Windows registry
RM_STATUS dacGetCRTCTiming
(
    PHWINFO pDev,
    U032    Head,
    NV_CFGEX_CRTC_TIMING_PARAMS    *Params
)
{
    U008    lock;

    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTER) // Get currect CRTC values
    {
        // Unlock extended registers
        lock = ReadCRTCLock(pDev, Head);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
        
        Params->HTotal = dacGetCRTC(pDev, Head, H_TOTAL);    
        Params->HDisplayEnd = dacGetCRTC(pDev, Head, H_DISPLAY_END);    
        Params->HBlankStart = dacGetCRTC(pDev, Head, H_BLANK_START);    
        Params->HBlankEnd = dacGetCRTC(pDev, Head, H_BLANK_END);    
        Params->HRetraceStart = dacGetCRTC(pDev, Head, H_RETRACE_START);    
        Params->HRetraceEnd = dacGetCRTC(pDev, Head, H_RETRACE_END);    
        Params->VTotal = dacGetCRTC(pDev, Head, V_TOTAL);    
        Params->VDisplayEnd = dacGetCRTC(pDev, Head, V_DISPLAY_END);    
        Params->VRetraceStart = dacGetCRTC(pDev, Head, V_RETRACE_START);    
        Params->VRetraceEnd = dacGetCRTC(pDev, Head, V_RETRACE_END);    
        Params->VBlankStart = dacGetCRTC(pDev, Head, V_BLANK_START);    
        Params->VBlankEnd = dacGetCRTC(pDev, Head, V_BLANK_END);    
        
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
        return RM_OK;
    }
    else if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTRY)   // Get values from registry
    {

        char    *strptr;
        U032    numBytes;
        char    strDisplayMode[] = "12345678901234567890";

        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(strDevNodeDisplayNumber);
        //JJV-New registry Process strDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        // now get the specific entry we need
        dacFindRegistryKeyDisplayPosition(pDev, Head, TRUE, strDisplayMode);
        // Copy the string and append the head number
        
        for (strptr = strDisplayMode; *strptr != NULL; strptr++) 
            ;
        *strptr++ = '_';
        *strptr++ = (char)(Head | 0x30);
        *strptr++ = 'T';                    // make sure to use different key than desktop position
        *strptr   = NULL;
        return osReadRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, (U008 *)&Params->HTotal, &numBytes);
    }
    else // return default values for current mode
    {

        PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

        //
        // Grab the current dac settings (last modeset to come through on this head)
        //
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;


        Params->HTotal = pVidLutCurDac->HalObject.Dac[0].TotalWidth;    
        Params->HDisplayEnd = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        Params->HBlankStart = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
        Params->HBlankEnd = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                            pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
        Params->HRetraceStart = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
        Params->HRetraceEnd = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                            pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
        Params->VTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
        Params->VDisplayEnd = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        Params->VRetraceStart = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
        Params->VRetraceEnd = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
        Params->VBlankStart = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
        Params->VBlankEnd = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                            pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);

        //
        // There is a bug in NV hardware where the hardware cursor will not clip correctly
        // if a border is defined in the display timings (blank start != visible end).
        //
        // Borders are only defined in two specific DMT modes, so generally this is
        // not a problem.
        //
        // To fix this, set the blank starts to match the visible totals and remove the 
        // implicit borders.
        //
        // Remove this code when the hardware gets fixed.  Since this bug has been in the 
        // hardware since 1994, don't expect a fix soon.
        //
        //HorizontalBlankStart = HorizontalVisible;
        //HorizontalBlankEnd   = HorizontalTotal;
        //VerticalBlankStart   = VerticalVisible;
        //VerticalBlankEnd     = VerticalTotal;
        //
        // We want to return "default" values that match what the hardware really wants
        // us to program, not the true borders that exist in the DMT.  Otherwise a
        // client that uses this call to get hardware defaults, and then turns around
        // and programs the hardware with them, will get incorrect timings.
        //
        Params->HBlankStart = Params->HDisplayEnd;
        Params->HBlankEnd = Params->HTotal;
        Params->VBlankStart = Params->VDisplayEnd;
        Params->VBlankEnd = Params->VTotal;

        return RM_OK;
    }
}

//  Write caller's CRTC timing values into CRTC register and/or Windows Registry
RM_STATUS dacSetCRTCTiming
(
    PHWINFO pDev,
    U032    Head,
    NV_CFGEX_CRTC_TIMING_PARAMS    *Params
)
{

    U008    lock, data08;

    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTER) // Set CRTC values
    {
        
        // Unlock extended registers
        lock = ReadCRTCLock(pDev, Head);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

        CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7


        // Write the CRTC's        
        dacSetCRTC(pDev, Head, H_TOTAL, Params->HTotal);
        dacSetCRTC(pDev, Head, H_DISPLAY_END, Params->HDisplayEnd);
        dacSetCRTC(pDev, Head, H_BLANK_START, Params->HBlankStart);
        dacSetCRTC(pDev, Head, H_BLANK_END, Params->HBlankEnd);       
        dacSetCRTC(pDev, Head, H_RETRACE_START, Params->HRetraceStart);
        dacSetCRTC(pDev, Head, H_RETRACE_END, Params->HRetraceEnd);     
        dacSetCRTC(pDev, Head, V_TOTAL, Params->VTotal);
        dacSetCRTC(pDev, Head, V_DISPLAY_END, Params->VDisplayEnd);
        dacSetCRTC(pDev, Head, V_BLANK_START, Params->VBlankStart);
        dacSetCRTC(pDev, Head, V_BLANK_END, Params->VBlankEnd);
        dacSetCRTC(pDev, Head, V_RETRACE_START, Params->VRetraceStart);
        dacSetCRTC(pDev, Head, V_RETRACE_END, Params->VRetraceEnd);

        //
        // Lock everything back up again
        //
        CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 | 0x80, Head);    // lock CR0-7
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

    }
    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTRY) // Set Register values
    {
        char    *strptr;
        U032    numBytes = (NV_CFGEX_CRTC_PARAMS * 4) - 8;  // HTotal is 8 bytes in
        char    strDisplayMode[] = "12345678901234567890";

        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(strDevNodeDisplayNumber);
        //JJV-New registry Process strDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        // now get the specific entry we need
        dacFindRegistryKeyDisplayPosition(pDev, Head, TRUE, strDisplayMode);
        // append the head number
        for (strptr = strDisplayMode; *strptr != NULL; strptr++) 
            ;
        *strptr++ = '_';
        *strptr++ = (char)(Head | 0x30);
        *strptr++ = 'T';                    // make sure to use different key than desktop position
        *strptr   = NULL;
        return osWriteRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, (U008 *)&Params->HTotal, numBytes);
    }
    return RM_OK;
}

//	See what is currently being used as a display
U032 dacGetBiosDisplayType
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    rc;
    U032    displayType;
    U008    lock;               

    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, rc, Head);
    if (rc & 0x80)    // is VGA slaved to something?
    {
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, rc, Head);
        if (rc & 0x01)
            displayType = DISPLAY_TYPE_FLAT_PANEL;   
        else
            displayType = DISPLAY_TYPE_TV;      
    }
    else
    {
        displayType = DISPLAY_TYPE_MONITOR;
    }

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
    return displayType;
}

//  Read analog out comparator 
//  If the output is loaded, it will be below threshold
//  If no CRT is attached, it will trip
BOOL dacDetectTrigger(
    PHWINFO pDev
)
{
    U008 blank, data8;
    U032 retry;

#define MAXRETRIES 500000
    
    // wait for active
    retry = 0;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
    } while ((retry < MAXRETRIES) && blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // wait for blank
    retry = 0;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
    } while ((retry < MAXRETRIES) && !blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // wait for active
    retry = 0;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
    } while ((retry < MAXRETRIES) && blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // get 2 samples which are the same to debounce
    retry = 0;
    do {
        data8 = (REG_RD08(NV_PRMCIO_INP0) & 0x10);
        retry++;
    } while ((retry < MAXRETRIES) && ((REG_RD08(NV_PRMCIO_INP0) & 0x10) != data8));
    if (retry >= MAXRETRIES)
    {
 timedout:
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: trigger detect timed out\n");
        return FALSE;
    }

    // sense bit in NV_PRMCIO_INP0 is inverted (0x1 = no trigger).
    if (data8)
        return FALSE;    // no trigger
    else
        return TRUE;     // trigger
}



// Check whether monitor is currently connected
BOOL dacMonitorConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    RM_STATUS status;
    U008    lock;
    U032    Current;

    if (using_new_api == FALSE) {
        //
        // Make sure monitor is supported on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR)) == 0)
            return FALSE;

        //
        // For NV11 TwinView, make sure head isn't in use by another display device
        //
        if (!pDev->Power.MobileOperation)
            if (IsNV11(pDev))
            {
                if (GETDISPLAYTYPE(pDev, Head ^ 1) != 0xFFFFFFFF) // if both heads in use
                {
                    Current = GETDISPLAYTYPE(pDev, Head);
                    if (Current == DISPLAY_TYPE_FLAT_PANEL) // then only the current type is allowed (except TV)
                        return FALSE;
                }
            }

        // Mobile devices should never have CRT on Head 1
        if (pDev->Power.MobileOperation && (Head == 1)) 
            return FALSE;
    }

//#ifdef USE_EDID_TO_TEST_CRT_CONNECT
    if ((IsNV11(pDev)) && (Head == 1))
    {
    // Attempt to read EDID and check for analog display. On head 1 there is no way to do the analog out test below.
        lock = ReadCRTCLock(pDev, Head);    // Unlock the registers

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

        // read EDID 
        status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);        // Try to read EDID

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

        if (status == RM_OK)        
        {
            if (edidIsAnalogDisplay(pDev, Head))
                return TRUE;
            else    
                return FALSE;
        }
        else
            return FALSE;   // the analog test (below) will not work on head 1--it always returns TRUE.
    }
//#endif

    status = EDIDDetect(pDev, Head, DISPLAY_TYPE_MONITOR);      // Try to read EDID
    if (status) 
    {
        if (Head != 1) // Head 1 does not have an internal DAC, so we cannot do the analog check.
        {
            // EDID did not confirm that a CRT is connected, but it may be an older non-DDC CRT,
            // so procede with analog out test.
            return (dacVGAConnectStatus(pDev, Head));
        }
        return FALSE;       // EDID read failed on Head1, so no CRT
    }

    return TRUE;
}

#ifdef MACOS
// XXX Enable old style on the Mac
//     This one can timeout 5 times in dacDetectTrigger(), the new one 
//     can time out about 255 times!

#define USE_TESTPOINT_DATA
#endif

BOOL dacVGAConnectStatus
(
    PHWINFO pDev, 
    U032    Head
)
{
    U032	dacPowerDown;
    U016	Sr1;
    U008	retries;
    BOOL    result = 0;
#ifndef USE_TESTPOINT_DATA
    U032 bgr, cur_palette[256], red_palette[256];
    U032 i, red_trigger, dacControl;
#endif

    // This test drives a selected amount of current out the DAC Red
    // output. This currect causes a voltage drop over the terminating
    // resistor (no CRT connected) or the terminating resistor in parallel
    // with the CRT load.  There is a voltage comparator which is sampled at
    // port 3C2. (Actually 3, on for each color.)  This indicates whether the
    // voltage at the output resistor has crossed a reference level.  If a CRT
    // is connected, the amount of current required to reach this level will
    // be twice (this can vary depending on the board) that required if there
    // is not a CRT.  (e.g. 75 ohms on the board, in parallel with 75 ohms at
    // the monitor = 37.5 ohms).  At the selected current level, we check to
    // see whether the comparator has flipped.  If so, there must be no CRT
    // connected (75 ohm load). If not, there is additional loading, i.e.  a
    // CRT is connected.

#ifdef USE_TESTPOINT_DATA
    // This shortened test replaces the traditional method of ramping up the
    // palette. We set the DAC into a test mode which bypasses the palette,
    // and set one level of analog out which we know will differentiate
    // between CRT and no CRT.
#endif
    
    Sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);      
    if (Sr1 & 0x2000)
        WriteIndexed(NV_PRMVIO_SRX, (U016)(Sr1 & ~0x2000)); // turn off blank

    // make sure the DAC is driving RGB out
    dacPowerDown = REG_RD32(NV_PRAMDAC_TEST_CONTROL);
    FLD_WR_DRF_DEF( _PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON);

#ifdef USE_TESTPOINT_DATA
    // set to test mode--bypass palette
    FLD_WR_DRF_DEF( _PRAMDAC, _TEST_CONTROL, _TP_INS_EN, _ASSERTED);
    // set to level corresponding to roughly 300 mv
    REG_WR32(NV_PRAMDAC_TESTPOINT_DATA, RED_OUT_300MV);
#endif

    tmrDelay(pDev, 10000000);	// delay 10 ms to allow DAC to power up
    
#ifdef USE_TESTPOINT_DATA
    // The function dacDetectTrigger debounces the samples.
    // We will call dacDetectTrigger multiple times to insure
    // stability on a longer time interval as well.
    retries = 0;
    result = dacDetectTrigger(pDev);
    while (retries < MAXCRTRETRIES) 
    {
        BOOL result2;	

        result2 = dacDetectTrigger(pDev);
        if (result == result2) 
            break;
        result = result2;
        retries++;
    }
    FLD_WR_DRF_DEF( _PRAMDAC, _TEST_CONTROL, _TP_INS_EN, _DEASSERTED); // test mode off

    if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_MONITOR)
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);   // CRT off

    if (retries == MAXCRTRETRIES)
        result = TRUE;  // if the test is not working, assume CRT is present        
    
    return result;
#else
    //
    // Here's the "ramping up the palette" method for detecting if a CRT is
    // present, reimplemented from what the BIOS had. The USE_TESTPOINT_DATA
    // version seemed not very reliable and frequently gave false CRT
    // detections. 
    // 
    // The palette version in testing gave no false detections for many test
    // loops and did correctly detect the monitor when it was present. The
    // red_trigger value used was tested on NV5/NV10/NV15 and NV11.
    //

    // save the current palette 
    DAC_REG_WR08(NV_USER_DAC_READ_MODE_ADDRESS, 0, Head);
    for (i = 0; i < 256; i++)
    {
        bgr = DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);     // b
        bgr <<= 8;
        bgr |= DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);    // g
        bgr <<= 8;
        bgr |= DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);    // r
        cur_palette[i] = bgr;
    }

    // these red values rely on being interpreted as 6 bits per color
    dacControl = DAC_REG_RD32(NV_PRAMDAC_GENERAL_CONTROL, Head);
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _6BITS, Head);

    for (red_trigger = 0x8; red_trigger < 0x3F; red_trigger++)
    {
        // Load the red palette with the new values
        for (i = 0; i < 256; i++)
            red_palette[i] = (0x8 << 16) | (0x8 << 8) | red_trigger;

        dacProgramLUT(pDev, Head, red_palette, 256);

        for (retries = 0; retries < MAXCRTRETRIES; retries++) {
            result = dacDetectTrigger(pDev);
            if (result == dacDetectTrigger(pDev))
                break;
        }

        if (retries == MAXCRTRETRIES)
            return TRUE;    // no consistent read (assume something's connected)

        if (result == TRUE)
            break;          // triggered, so check the value
    }

    // restore the previous dac control
    DAC_REG_WR32(NV_PRAMDAC_GENERAL_CONTROL, dacControl, Head);

    // restore the previous palette
    dacProgramLUT(pDev, Head, cur_palette, 256);

    if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_MONITOR)
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);	// CRT off

    if (red_trigger < 0x18)
        return FALSE;
    else
        return TRUE;
#endif
}


// Check whether flat panel is currently connected
BOOL dacFlatPanelConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    RM_STATUS status;
    U008 lock;

    if (using_new_api == FALSE) {
        //
        // Make sure flatpanel allowed on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL)) == 0)
            return FALSE;

        //
        // If the other head is TV, we can't do it (P38 with external TMDS, P41 with internal is OK)
        // TODO: Need to change this to a dynamic check based on feedback from the BIOS topology table
        // If we're using the 12bit wide FP interface, then FP/TV can share and are allowed.
        //
        if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_TV) && !pDev->Power.MobileOperation &&
            (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT))
            return FALSE;
    
        // if the other head is already a DFP, we can't do it (P38).
        //
        // TODO: Need to change this to a dynamic check based on feedback from the BIOS topology table
        //
        // Check dac object for the other head to see if the driver is using the flat panel. Previous check in HAL for 
        // display type is not correct because the boot device may be flat panel, but this should not limit us from changing
        // to a new configuration when the driver loads.
        if (pDev->Dac.DFP2PortID == NV_I2C_PORT_SECONDARY)   // is P38? 
        {
#if 0
            PVIDEO_LUT_CURSOR_DAC_OBJECT AltDacObj = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac;
            if (AltDacObj != NULL) 
            {
                if (AltDacObj->DisplayType == DISPLAY_TYPE_FLAT_PANEL)
        //        if (GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_FLAT_PANEL)
                    return FALSE;
            }
#endif    
            if ((pDev->Dac.DesktopState == NV_DAC_DESKTOP_STATE_MULTI) && (Head == 0))  
                            // In multi head mode, limit DFP to head 1 only, since we can't know what the driver is going to do
                            // i.e., this gets called for both heads before the driver does a modeset on either head,
                            // so the driver could attempt to use DFP on both.
            {
                return FALSE;
            }
        }
    }

    lock = UnlockCRTC(pDev, Head);

	// read EDID 
    status = EDIDRead(pDev, Head, DISPLAY_TYPE_FLAT_PANEL);     // Try to read EDID

    RestoreLock(pDev, Head, lock);

    if (status != RM_OK)
        return FALSE;

	if (edidIsDigitalDisplay(pDev, Head)) 				// Check the display technology byte
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;
        return TRUE;
    }
    return FALSE;
}

U032 dacGetFlatPanelConfig
(
    PHWINFO pDev,
    U032    Head
)
{
    U032 mode;
    
    mode = DAC_REG_RD32(NV_PRAMDAC_FP_TG_CONTROL, Head); 
    return(DRF_VAL(_PRAMDAC, _FP_TG_CONTROL, _MODE, mode)); 
}
    


RM_STATUS dacGetFlatPanelInfo
(
    PHWINFO pDev,
    U032    Head,
    U032    *FpMode,
    U032    *FpMaxX,
    U032    *FpMaxY,
    BOOL    *FpConnected,
    BOOL    *FlatPanelNativeSupported,
    BOOL    fromRegistry
)
{
    U032      mode;
    RM_STATUS status;

    // Get info from EDID
	if (!dacFlatPanelConnectStatus(pDev, Head))	// FP connected?
	{
		*FpConnected = NV_CFGEX_GET_FLATPANEL_INFO_NOT_CONNECTED;
		return RM_OK;						// then no more to do
	}
	if ((status = fpParseEDID(pDev, Head)) != RM_OK) // parse EDID to get timing info
        return status;
    
    *FpConnected = NV_CFGEX_GET_FLATPANEL_INFO_CONNECTED;
    *FpMaxX = pDev->Dac.fpHMax;
    *FpMaxY = pDev->Dac.fpVMax;
    *FlatPanelNativeSupported = FALSE;
    if (pDev->Dac.fpNative)
        *FlatPanelNativeSupported = TRUE;

    if (fromRegistry)
    {
        //JJV-New registry Process   char * strDisplayMode;
        //JJV-New registry Process   U032   size;
        // read it from the registry
        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
        //JJV-New registry Process pDev->Registry.DBstrDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        status = OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, &mode);
    if (status == RM_OK)
            *FpMode = mode;
    else
        *FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
    }
    else
    {
        mode = dacGetFlatPanelConfig(pDev, Head);
        *FpMode = mode;
        status = RM_OK;
    }

    return status;
}

// Check whether TV is currently connected
// This only works for the Brooktree encoder
BOOL dacTVConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    read, ack, lock, encoderPower, reg0e, reg10, reg3d, i;
    BOOL    connect;
    U032    retry;

    if (using_new_api == FALSE) {
        //
        // Make sure TV allowed on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_TV)) == 0)
            return FALSE;
    }

    //
    // For NV11, make sure TV isn't in use by other head.
    // For P38 boards (external TMDS), we cannot run both TV and flat panel. This will change if we use internal TMDS,
    // but we'll have to get that info from the BIOS. Until then, TV + DFP is not allowed.
    //
    if (IsNV11(pDev))
    {
        if (using_new_api == FALSE) {
            // If the other head already has the TV, we can't use it.
            if (GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_TV)  
                return FALSE;

            //
            // If the other head is flat panel, we can't do it (only if this board is using external TMDS)
            // or if we're using the 12bit wide FP interface, then FP/TV can share and are allowed.
            //
            if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_FLAT_PANEL) && !pDev->Power.MobileOperation &&
                (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT))
                return FALSE;

            // If the other head is CRT on head 1, we can't do it (only if this board is using external TMDS)
            if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_MONITOR) && (Head == 0))
                return FALSE;
        }
        
        //
        // Make sure that i2c/tv ownership is setup properly.
        //
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // Set power to "normal"
            // Chrontel 7007 wants bit 7 set on register address
            
            // Read Power Management Register to preserve contents
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E); // 0x0e = PM register
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg0e,1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // Powered up? No, then do so
            if ((reg0e & 3) != 3) {
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E); // 0e = power register
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x0b); // ON + RESET HIGH
                }
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);


            // Some initialization is necessary on the 7007 to make the detection work.
            // Exactly what needs to be set, I don't know, but the following 2 register initializations do it.

            // Set data format
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // 04 = input data format reg
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x05);      // set to NTSC for now
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // Set clocking
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // 06 = clock mode
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x40);      // 
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // In the 7008, reg 3D bits 2:0 must be cleared for detection to work
            // Don't know what effect it has on others, so we'll special case it.
            if (pDev->Dac.EncoderType == NV_ENCODER_CHRONTEL_7008) {

                // Read Reg 3D to preserve contents
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_3D); // 3D = ?
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg3d,1);
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

                if (ack == 0) {
                    // clear mystery bits 2:0 so TV connect detection will work
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    }
                    if (ack == 0) {
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_3D); // 
                        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(reg3d & 0xf8)); 
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
            } // 7008

            // Read Connection Detect Register to preserve contents
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg10,1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            if (ack == 0) {
                // Set Sense bit to tell encoder to check for TV connected
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    reg10 &= 0x0f;  // clear bits 7:4
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(reg10 | 1)); // sense bit <= 1
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }

            if (ack == 0) {
                // Reset Sense bit 
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); // sense bit <= 0
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }

            if (ack == 0) {
                // Read Connect reg - restart read
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            if  ((ack == 0 ) &&     // If we failed some how, we fail this
                 ((read & 0x0e) ^ 0x0e))     // 0 indicates connection
                                    // bit 3: Y (luma), bit 2: C (chroma), bit 1: composite
                connect = TRUE;
            else
                connect =  FALSE;
            break;
   

        case TV_ENCODER_BROOKTREE:

            // Turn DAC on before checking status
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);   // subaddress
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            // Give it some time for the outputs to stabilize
            tmrDelay(pDev, 20000000);         // 20 ms delay    

            // Set Check Status bit to tell encoder to check for TV connected.
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                if (ack)
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after first address byte while detecting TV connection\n\r");
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL); // subaddress
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT); // set check stat
            } else {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after first address byte while detecting TV connection\n\r");
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            if (ack != 0) {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during first transaction while detecting TV connection\n\r");
            }

            //870/871 supports direct register reads.  The older chips require a more involved procedure.
            if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) {
                if (ack == 0) {
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x06);
                }

                if (ack == 0) {
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID | 1));   // Add read bit
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after third address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
            } else {
                if (ack == 0) {
                    // Set Estat to select status register 1
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after second address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);   // subaddress
                        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x41);   // set estat (estat 01 + en_out)
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after second address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                    if (ack != 0) {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during second transaction while detecting TV connection\n\r");
                    }
                }

                if (ack == 0) {
                    // Read Monitor Status bits
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID | 1));   // Add read bit
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after third address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                } 
            }

            if (ack == 0) {
                // Reset Check Status -- not documented, but very important (can't program encoder if not done).
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    if (ack)
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after last address byte while detecting TV connection\n\r");
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL); // subaddress
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF); // set check stat
                } else {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after last address byte while detecting TV connection\n\r");
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                if (ack != 0) {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during last transaction while detecting TV connection\n\r");
                }
            }

            if (ack) // if any error occurred, go to monitor
                return (FALSE);

            if (read & BT_MONSTAT)  // any connection deteced?
                connect = TRUE;
            else
                connect =  FALSE;

            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            break;
        
       case TV_ENCODER_PHILIPS:
           // Turn Power On -- Read/Modify/Write
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
           }
           if (ack == 0) {
              ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x61); // 
              i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
              ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
              i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           encoderPower = read;
           read &= 0x3f;   // power on
           // Write Power bits
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x61);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) read);   // 
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           
           // Set Monitor Sense Threshold
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Set Monitor Sense Threshold
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Set Monitor Sense Mode
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x80);   // MSM
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Read sense bits
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
           }
           if (ack == 0) {
              ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x1b); // 
              i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
              ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
              i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           if ((read & 0x07) == 0x07)    // check C and Y inputs
               connect = FALSE;
           else
               connect = TRUE;                                    
           // Reset Monitor Sense Mode
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x00);   // MSM
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           // Restore power state
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x61);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) encoderPower);   // power
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           break;
        default:
                connect =  FALSE;
    }
    RestoreLock(pDev, Head, lock);

    // restore TV connection if TV is connected on the other head
    if (GETDISPLAYTYPE(pDev, Head ^ 0x1) == DISPLAY_TYPE_TV) {
        AssocDDC(pDev, Head ^ 0x1);
        AssocTV(pDev, Head ^ 0x1);
    }
    return connect;
}

//  Set the text cursor blink rate depending on the display type
//  The BIOS won't do this, so we have to.
VOID dacSetCursorBlink
(
    PHWINFO pDev,
    U032    Head,
    U008    Rate
)
{
U008    data;

    if (IsNV5(pDev)) // This is a problem in NV5 only
    {
        // another undocumented register
        CRTC_RD(NV_CIO_CRE_TREG__INDEX, data, Head);
        data &= ~0x80;
        if (Rate)   // CRT set bit 7 to 0, FP & TV set to 1
            data |= 0x80;
        CRTC_WR(NV_CIO_CRE_TREG__INDEX, data, Head);
    }
}

// Unlock extended CRTC and return former state of lock
U008 UnlockCRTC
(
    PHWINFO pDev,
    U032    Head
)
{
U008 lock;
    
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    return lock;
}
VOID RestoreLock
(
    PHWINFO pDev, 
    U032    Head, 
    U008    lock
)
{
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}
//  Read extended CRTC lock register and return corresponding write value
U008 ReadCRTCLock
(
    PHWINFO pDev,
    U032    Head
)
{
U008 data;

    CRTC_RD(NV_CIO_SR_LOCK_INDEX, data, Head);
    switch (data)
    {
        case 0x03:
            data = 0x57;
            break;
        case 0x01:
            data = 0x75;
            break;
        case 0x00:
        default:
            data = 0x99;
            break;
    }
    return data;
}

VOID dacSetFan
(
    PHWINFO pDev,
    U008    state
)
{
U008 data, lock;
U032 Head = 0;

    if(IsNV10orBetter(pDev))
    {
        lock = ReadCRTCLock(pDev, Head);
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
        CRTC_RD(0x35, data, Head);
        data &= ~0x02;      // bit 1 = output enable (active low) 
        if (state == 0)
        {
            // OFF
            CRTC_WR(0x35, data & ~0x01, Head);  // bit 0 = fan control (active high)
        }
        else
        {
            // ON
            CRTC_WR(0x35, data | 0x01, Head);       // bit 0 = fan control (active high)
        }
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
    }
}

RM_STATUS dacGetColorSaturationBoost
(
    PHWINFO pDev,
    U032    Head,
    U008    *boostValue
)
{
    U008 lock;

    if (IsNV11(pDev) == FALSE)
        return CONFIG_GETEX_BAD_READ;    // not supported pre-NV11

    // unlock extended regs
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    // get the color boost value
    CRTC_RD(NV_CIO_CRE_CSB, *boostValue, Head);

    // restore extended regs lock state
    if (lock == 0) {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    } else if (lock == 1) {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RO_VALUE, Head);
    }
    return RM_OK;
}

RM_STATUS dacSetColorSaturationBoost
(
    PHWINFO pDev,
    U032    Head,
    U008    boostValue
)
{
    U008 lock;

    if (IsNV11(pDev) == FALSE)
        return CONFIG_GETEX_BAD_READ;    // not support pre-NV11

    if (boostValue > NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_750)
        return CONFIG_SETEX_BAD_PARAM;    // 75% is the largest value

    // unlock extended regs
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, lock, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

    // set the color saturation boost value
    CRTC_WR(NV_CIO_CRE_CSB, boostValue, Head);

    // restore extended regs lock state
    if (lock == 0) {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_LOCK_VALUE, Head);
    } else if (lock == 1) {
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RO_VALUE, Head);
    }
    return RM_OK;
}

#ifdef MACOS
/*
 * The fcode on the mac implements Apple's monitor selection policy
 *  (what device to boot on, etc).  The fcode then publishes this information
 *  in the registry.
 *
 * Here we read that information.
 *
 * "displayA"      --  HHIILLTT
 * "displayB"      --  HHIILLTT
 * "display-type"  -- "CRT" or "LCD"  preferred boot device
 *
 * Decoder ring:
 *             HH -- head
 *             II -- i2c status port base
 *             LL -- TMDS link info
 *             TT -- display type (0 = crt, 3 = digital flat panel)
 *
 * If a display is not present, then the value will be 0x??FFFFFF.
 *
 * On the iMac / P11, displayA would be 00FFFF00 (Head A, no I2C port, no TMDS
 * link, CRT) and displayB would be 013E0103 (Head B, I2C 3E/3F, Link 2, DFP).
 *
 */

RM_STATUS dacMacReadBIOSDisplaySettings(
    PHWINFO pDev
)
{
    U032 displayA, displayB;
    U032 head, i2cport, tmdslink, displaytype;
    char primary_displaytype_string[16];
    U032 reglen;

    displayA = ~0;
    displayB = ~0;

    osReadRegistryDword(pDev, (char *) 0, "displayA", &displayA);
    osReadRegistryDword(pDev, (char *) 0, "displayB", &displayB);
    if ((displayA == ~0) && (displayB == ~0))
        return RM_ERROR;

    // what is 

    reglen = sizeof(primary_displaytype_string);
    osMemSet(primary_displaytype_string, 0, reglen);
    osReadRegistryBinary(pDev,
                         (char *) 0,
                         "display-type",
                         (U008 *) primary_displaytype_string,
                         &reglen);


    // parse out displayA settings

    if ((displayA & 0x00FFFFFF) != 0x00FFFFFF)
    {
        head =        (displayA >> 24) & 0xFF;
        i2cport =     (displayA >> 16) & 0xFF;
        tmdslink =    (displayA >> 8)  & 0xFF;
        displaytype = (displayA >> 0)  & 0xFF;

        if (i2cport == 0xff)
            i2cport = 0x36;
        pDev->Dac.I2CPrimaryStatusIndex = i2cport;
        pDev->Dac.I2CPrimaryWriteIndex = i2cport + 1;
    }
    
    if ((displayB & 0x00FFFFFF) != 0x00FFFFFF)
    {
        head =        (displayB >> 24) & 0xFF;
        i2cport =     (displayB >> 16) & 0xFF;
        tmdslink =    (displayB >> 8)  & 0xFF;
        displaytype = (displayB >> 0)  & 0xFF;

        pDev->Dac.I2CSecondaryStatusIndex = i2cport;
        pDev->Dac.I2CSecondaryWriteIndex = i2cport + 1;
    }

    // is CRT on primary or secondary
    pDev->Dac.CRTPortID  = NV_I2C_PORT_PRIMARY;
    pDev->Dac.DFPPortID  = NV_I2C_PORT_PRIMARY;
    pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;
    pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;
 
    return  RM_OK;
}

#endif // MACOS



//
// Extract the relevant I2C values from any arbitrary version of BMP structure
// Update the nvInfo structure with the location of the TV and FP ports.
RM_STATUS dacReadBIOSI2CSettings(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

#ifdef IKOS
    pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
    pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
    pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
    pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
    pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
    pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
    pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
#else

    if ( !IsNV5orBetter(pDev) || IsNV0A(pDev) )
    {
        // This is a one DDC port device
        pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.TVOutPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.DFPPortID = NV_I2C_PORT_PRIMARY;
    }
    else
    {
        U032 offset;
        BMP_Control_Block bmpCtrlBlk;

        // This device has two DDC ports, set defaults

        pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
        pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
        pDev->Dac.I2CTertiaryWriteIndex = NV_CIO_CRE_DDC2_WR__INDEX;
        pDev->Dac.I2CTertiaryStatusIndex = NV_CIO_CRE_DDC2_STATUS__INDEX;
        pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
        pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
        
        // NV11, NV20 have three DDC ports
        if (IsNV11(pDev))
        {
#if 0 // We can no longer assume that VGA is the boot device. We assume that we can talk to VGA over I2C 0 and DFP over I2C 1
      // unless we find a registry override.
            // determine if this is VGA + ? or DVI/DVI board
            if (dacVGAConnectStatus(pDev, 0))  // Is there VGA on I2C 0? (Uses analog comparator)
            {
                // VGA is mapped to I2C 0, so the secondary could be VGA or DFP on I2C 1
                pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
                pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;     // No primary DFP--set to unused port
                pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;   // second DFP uses I2C 1
            }
            else // no CRT, assume dual DFP
            {
                if (dacFlatPanelConnectStatus(pDev, 0)) // this will try to find EDID on I2C 1
                {
                    // DVI on I2C 1 and 2                
                    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // secondary DFP uses I2c 2
                }
                else // No DFP after all, assume CRT with no EDID
                {
                    pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
                    pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;    // set to unused port
                    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // set to unused port
                }
            }
#else
            U032 val = 0;
            char strDualDVI[] = "Dual DVI";

            // VGA is mapped to I2C 0, so the secondary could be VGA or DFP on I2C 1
            pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
            pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;     // No primary DFP--set to unused port
            pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;   // second DFP uses I2C 1
            
            // registry override for dual DVI board -- Flat Panels connected to I2C 1 and 2
            OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strDualDVI, &val);
            if (val) 
            {
                pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
                pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // secondary DFP uses I2c 2
            }
#endif        
        }

#ifdef MACOS
        // the Mac is *special*
        // The fcode sets registry properties to indicate i2c mappings
        //    If we find these registry settings, we'll use them,
        //    otherwise we'll look for the BMP bios table.
        if (RM_OK == dacMacReadBIOSDisplaySettings(pDev))
            return RM_OK;
#endif

        // Attempt to find the I2C info in the BIOS' BMP tables
        rmStatus = DevinitGetBMPControlBlock(pDev,
                                             &bmpCtrlBlk,
                                             &offset);
        if (rmStatus == RM_OK)
        {
            switch ( bmpCtrlBlk.CTL_Version )
            {
                // version 0 is for Nv3, no others exist
                case BMP_INIT_TABLE_VER_0:
                case BMP_INIT_TABLE_VER_1:
                {
                    // There is no I2C info in these BIOS's.
                    break;
                }
                    
                // BMP init table version 2 & 3
                case BMP_INIT_TABLE_VER_2:
                case BMP_INIT_TABLE_VER_3:
                {
                    //PBMP_Struc_Rev3 BMP_InitTableInfo = (PBMP_Struc_Rev3)pBmpCtrlBlk;
                    BIOSI2CTable biosI2CTable;
                    
                    rmStatus = BiosReadStructure(pDev,
                                                 (U008 *) &biosI2CTable,
                                                 0x40,
                                                 (U032 *) 0,
                                                 BMP_I2C_FMT);
                    if (rmStatus == RM_OK)
                    {
                        pDev->Dac.I2CPrimaryWriteIndex = biosI2CTable.I2CPort0IO & 0xFF;
                        pDev->Dac.I2CPrimaryStatusIndex = ( biosI2CTable.I2CPort0IO >> 8 ) & 0xFF;
                        pDev->Dac.I2CSecondaryWriteIndex = biosI2CTable.I2CPort1IO & 0xFF;;
                        pDev->Dac.I2CSecondaryStatusIndex = ( biosI2CTable.I2CPort1IO >> 8 ) & 0xFF;
                        pDev->Dac.CRTPortID = biosI2CTable.CRTI2CPort;
                        pDev->Dac.TVOutPortID = biosI2CTable.TVI2CPort;
                        pDev->Dac.DFPPortID = biosI2CTable.DFPI2CPort;
                    }
                    break;
                }
        
                // BMP init table version >= BMP_INIT_TABLE_VER_4 ( 4 )
                default:
                {
                    BMP_Struc_Rev4 bmp_InitTableInfo ;
                    
                    rmStatus = BiosReadStructure(pDev,
                                                 (U008 *) &bmp_InitTableInfo,
                                                 offset,
                                                 (U032 *) 0,
                                                 BMP_INIT4_FMT);

                    if (rmStatus == RM_OK)
                    {
                        pDev->Dac.I2CPrimaryWriteIndex = bmp_InitTableInfo.BMP_I2CPort0IO & 0xFF;
                        pDev->Dac.I2CPrimaryStatusIndex = ( bmp_InitTableInfo.BMP_I2CPort0IO >> 8 ) & 0xFF;
                        pDev->Dac.I2CSecondaryWriteIndex = bmp_InitTableInfo.BMP_I2CPort1IO & 0xFF;;
                        pDev->Dac.I2CSecondaryStatusIndex = ( bmp_InitTableInfo.BMP_I2CPort1IO >> 8 ) & 0xFF;
                        pDev->Dac.CRTPortID = bmp_InitTableInfo.BMP_CRTI2CPort;
                        pDev->Dac.TVOutPortID = bmp_InitTableInfo.BMP_TVI2CPort;
                        pDev->Dac.DFPPortID = bmp_InitTableInfo.BMP_DFPI2CPort;
                    }
                    break;
                }
            }
        }

        // Verify that there are no non-zero values in these reg indexes as these should never be 0       
        // This fixes a bug in which Diamond stuffs 0s into the bitmap
        if( (pDev->Dac.I2CPrimaryWriteIndex == 0x00)   ||
            (pDev->Dac.I2CPrimaryStatusIndex == 0x00)  ||
            (pDev->Dac.I2CSecondaryWriteIndex == 0x00) ||
            (pDev->Dac.I2CSecondaryStatusIndex == 0x00) ) {

            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid I2C info in bios image\n");

            // Someone gave us bogus values, so set all of these to the defaults
            pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
            pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
            pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
            pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
            pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
            pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
            pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
        }

    }
#endif

    return rmStatus;
}

//
// Return head number specified in alloc request.
//
U032 dacGetHead
(
    PCLASS pClass,
    VOID *pCreateParms
)
{
    RM_STATUS   status = RM_OK;
    U032 Head = 0;

    if (pCreateParms == NULL)
        return Head;

    switch (pClass->Type)
    {
        case NV15_VIDEO_LUT_CURSOR_DAC:
        {
            NV07C_ALLOCATION_PARAMETERS Class07cParams;
            status = osCopyIn(pCreateParms, (U008*) &Class07cParams, sizeof (NV07C_ALLOCATION_PARAMETERS));
            if (status != RM_OK)
                return 0;
            Head = Class07cParams.logicalHeadId;
        }
        default:
            // for everything else, it's head 0
            break;
    }

    return Head;
}

RM_STATUS
dacCreateObj(VOID* pDevHandle, PCLASSOBJECT ClassObject, U032 Name, POBJECT *Object, VOID *pCreateParms)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS                    status = RM_OK;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    PCLASS                       pClass = ClassObject->Base.ThisClass;
    U008                         *bytePtr;
    U032                          i, head;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacCreateObj\r\n");
    
    //
    // Check allocation restrictions.
    //

    //
    // Check head assignment.
    //
    head = dacGetHead(pClass, pCreateParms);
    if (head >= pDev->Dac.HalInfo.NumCrtcs)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: dacCreateObj: invalid logical head number ", head);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    //
    // For synchronized multi-head flips, init the sync counter
    //
    pDev->Dac.MultiSyncCounter = pDev->Dac.HalInfo.NumCrtcs;

    //
    // Alloc memory for class dependent object state.
    // All DAC engine objects currently use the same structure.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEO_LUT_CURSOR_DAC_OBJECT));
    if (status)
        return (status);

    //
    // Nice casts to make the code more readable.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pVidLutCurDac;
    for (i = 0; i < sizeof (VIDEO_LUT_CURSOR_DAC_OBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidLutCurDac->CBase, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    pVidLutCurDac->HalObject.Head = head;
    status = nvHalDacAlloc(pDev, pVidLutCurDac->CBase.ChID, pVidLutCurDac->CInstance, pClass->Type, (VOID *)&pVidLutCurDac->HalObject);

    if (status == RM_OK)
    {
        //
        // Build a FIFO/Hash context for this object
        //
        status = fifoUpdateObjectInstance(pDev,
                                          &pVidLutCurDac->CBase, 
                                          pVidLutCurDac->CBase.ChID, 
                                          pVidLutCurDac->CInstance);
    }

    if (status)
    {
        osFreeMem(*Object);
        return (status); 
    }

    //
    // If we're in a multimon mode, and this is the first dac object
    // to be instantiated for a given head, be sure to swing the
    // VGA space over the *other* head.  By doing this, we can
    // be sure that any VGA accesses done between the time the
    // first and second heads are accessible will safely go out
    // to the second head.  This won't always necessarily be what
    // we want (e.g. blue screens), but it's better than having
    // Windows start routing VGA accesses to the primary head (while
    // it's got a desktop going) in response to detection of
    // the second head.
    //
    if (pDev->Dac.DesktopState == NV_DAC_DESKTOP_STATE_MULTI)
    {
        if (pDev->Dac.CrtcInfo[head].RefCount == 0)
            EnableHead(pDev, head^1);
    }

    //
    // Bump up reference count on this.
    //
    pDev->Dac.CrtcInfo[head].RefCount++;

    return (RM_OK);
}

RM_STATUS
dacDestroyObj(VOID* pDevHandle, POBJECT Object)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS               status = RM_OK;
    PCLASS                  pClass;
    U032                    buffNum;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

#if !defined(NTRM)
    U008    data08, lock;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // Nice cast to make the code more readable.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    pClass = Object->ThisClass;
    nvHalDacFree(pDev, pVidLutCurDac->CBase.ChID, pVidLutCurDac->CInstance, pClass->Type, (VOID *)&pVidLutCurDac->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidLutCurDac->CBase, pVidLutCurDac->CBase.ChID); 
    if (status)
        return (status);

    //
    // Cleanup any pending VBlank callbacks
    //
    for (buffNum = 0; buffNum < 2; buffNum++) {
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->Image[buffNum].ImageCallback));
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->LUT[buffNum].LUTCallback));
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
    }

    //
    // Decrement reference count.
    //
    // Turn off DAC if this is last object instance associated
    // with this (non-primary) head
    //
    if (--pDev->Dac.CrtcInfo[pVidLutCurDac->HalObject.Head].RefCount == 0)
    {
        if (pVidLutCurDac->HalObject.Head != 0)
            dacDisableDac(pDev, pVidLutCurDac->HalObject.Head);
    }

    //Remove the pointer to this object -- whether this ptr is NULL is used
    // to determine whether this head is disabled.
    if (pVidLutCurDac == (PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac)) 
    {
#if !defined(NTRM)
        //Runtime clone mode switch support -- turn off display when associated object it is destroyed.
        if (!pDev->Vga.Enabled) {
            dacDisableDac(pDev, pVidLutCurDac->HalObject.Head); 

            //Also, if mobile BIOS, let the BIOS know we've done this.
            lock = ReadCRTCLock(pDev, pVidLutCurDac->HalObject.Head);           //Back up lock state
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, pVidLutCurDac->HalObject.Head);    //Unlock CRTC extended regs
            if (pDev->Power.MobileOperation &&  pDev->HotKeys.enabled) {
                CRTC_RD(0x3B, data08, pVidLutCurDac->HalObject.Head);
                CRTC_WR(0x3B, (data08 & 0x0F), pVidLutCurDac->HalObject.Head);
            }

            CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, pVidLutCurDac->HalObject.Head); // Restore lock state
        }
#endif                                                          
        SETDISPLAYTYPE(pDev, DACGETHEAD(pVidLutCurDac), DISPLAY_TYPE_NONE);
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = NULL;
        pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = NULL;
    }

    //
    // And finally delete the object itself    
    //    
    return (osFreeMem(Object));
}

//
// EnableHead
//
// Set DAC address space mode in CR44 (H2OWNS)
// register so that CIO/VIO/PRMVIO addressing 
// goes to the specified head.
//
VOID EnableHead
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 data08, temp;

    if (!IsNV11(pDev))
        return;

    if (pDev->Dac.HalInfo.Head2RegOwner == HEAD2_OWNER_UNKNOWN) {
        // Set the initial values, if this is the first call.
        if (Head == 1)
            data08 = 3;
        else
            data08 = 0;
    } else {
        // CR44 has a bug; memory mapped reads don't work, so we use a shadow copy.
        data08 = (U008)pDev->Dac.HalInfo.Head2RegOwner;
        if (Head == 1) 
        {
            // Did CR44 already point to head 1
            if ((data08 & 0x3) == 3)
                return;
            data08 |= 3;
        }
        else
        {
            // Did CR44 already point to head 0
            if ((data08 & 0x3) == 0)
                return;
            data08 &= ~3;
        }
    }

    //We've determined experimentally that leaving 3d4 pointing at CR44
    // gives rise to many complications.  So we do a dummy access here
    // to avoid that problem.
    CRTC_WR(NV_CIO_CRE_H2OWNS, data08, 0);
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, temp, 0);
    pDev->Dac.HalInfo.Head2RegOwner = (U032)data08;
}

// Multi-head DDC switching (ENGINE_CTRL update routine).
VOID AssocDDC(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _DEFAULT, 0);
    }
}

// Multi-head TV switching (ENGINE_CTRL update routine).
VOID AssocTV(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _DEFAULT, 0);
    }
}

// Multi-head VideoScalar switching (ENGINE_CTRL update routine).
VOID AssocVideoScalar(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _DEFAULT, 0);
    }
}


//Set a flag to let the BIOS know not to handle hotkey events itself.
//Set while in Windows, cleared in full-screen DOS.  Mobile only.
VOID EnableMobileHotkeyHandling(PHWINFO pDev)
{
    U008 lock, data;

    if (pDev->Power.MobileOperation) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling enabled\n\r");

        lock = ReadCRTCLock(pDev, 0);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs

        //Clear any pending events
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);
        data &= ~(NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);

        //Notify BIOS we're enabling driver hotkey handling.
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 0);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 0); // Restore lock state

        //Workaround: head 1's bit, too.
        lock = ReadCRTCLock(pDev, 1);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 1);    //Unlock CRTC extended regs

        //Clear any pending events
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);
        data &= ~(NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);

        //Notify BIOS we're enabling driver hotkey handling.
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 1);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 1); // Restore lock state

        pDev->HotKeys.enabled = TRUE;
    }
}


//Clear flag so BIOS knows to handle hotkey events itself.
//Set while in Windows, cleared in full-screen DOS.  Mobile only.
VOID DisableMobileHotkeyHandling(PHWINFO pDev)
{
    U008 lock, data;

    if (pDev->Power.MobileOperation) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling disabled\n\r");

        lock = ReadCRTCLock(pDev, 0);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs

        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 0);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 0); // Restore lock state

        //Workaround: head 1's bit, too.
        lock = ReadCRTCLock(pDev, 1);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 1);    //Unlock CRTC extended regs

        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling disabled\n\r");
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 1);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 1); // Restore lock state

        pDev->HotKeys.enabled = FALSE;
    }
}

//---------------------------------------------------------------------------
//
//  VBlank service handler.
//
//---------------------------------------------------------------------------
V032 dacService
(
    PHWINFO pDev
)
{
    U032 head, pmc, pending;
    RM_STATUS status;

    pending = 0;

    pmc = REG_RD32(NV_PMC_INTR_0);
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        pending |= 0x1;
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))
        pending |= 0x2;

    //
    // Check for any VBlank actions. Service count was already updated in VBlank
    //
    status = RM_OK;
    if (pDev->Framebuffer.FinishFlags)
        status |= grVBlank(pDev);
#if DEBUG
    if (status)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Problems in dacService.\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG

    VBlank(pDev);

    // Clear 'em all...
    for (head = 0; head < MAX_CRTCS; head++)
    {
        if (pending & BIT(head))
            DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, head);
    }
    return (0x00000000);
}

// read/parse the Display Config Block (DCB) from the BIOS.  only revisions 1.2 and up support
// this feature
RM_STATUS dacParseDCBFromBIOS
(
    PHWINFO pDev
)
{
    extern char strDevNodeRM[];
    U016        offset;             // offset from NV BIOS base
    U016        DCBBase;            // offset of DCB from BIOS base
    U032        CRTs = 0;           // # of CRT connectors
    U032        DDs = 0;            // # of DD connectors
    U032        TVs = 0;            // # of TV connectors
    U032        DevDescs = 0;       // # of valid DCB device descriptors
    U032        CRTCs = 0;          // # of CRTCs
    U032        I2cPorts;           // # of I2C ports
    U032        i;
    U032        j;
    U032        *pI2cPort;

    DCBBase = BIOS_RD16(DCB_PTR_OFFSET);
    //if (BIOS_RD08(DCBBase + DCB_REVISION_OFFSET) < DCB_FIRST_REVISION) {
    if (1) {
        // fake DCB records for older board
#define SETUP_DCB_DESC(i,a,b,c,d,e,f,g)                                     \
        pDev->Dac.DCBDesc[i].DCBRecType = DCB_DEV_REC_TYPE_##a;             \
        pDev->Dac.DCBDesc[i].DCBRecSubtype = DCB_DEV_REC_SUBTYPE_##b;       \
        pDev->Dac.DCBDesc[i].DCBRecFmt = DCB_DEV_REC_FMT_##c;               \
        pDev->Dac.DCBDesc[i].DCBRecIdxToICB = DCB_DEV_REC_LOGICAL_PORT_##d; \
        pDev->Dac.DCBDesc[i].DCBRecHead = DCB_DEV_REC_HEAD_##e;             \
        pDev->Dac.DCBDesc[i].DCBRecLocation = DCB_DEV_REC_LOCATION_##f;     \
        pDev->Dac.DCBDesc[i].DCBRecBus = DCB_DEV_REC_BUS_##g;

        if (IsNV11(pDev)) {
            pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
            pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;

            pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
            pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;

            pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[2].WritePort = I2C_PHYSICAL_PORT_C_DATA;
            pDev->Dac.DCBI2c[2].ReadPort = I2C_PHYSICAL_PORT_C_STATUS;

            pDev->Dac.DCBI2c[3].I2cAccess = I2C_PORT_ACCESS_UNUSED;
            I2cPorts = 3;

            if (pDev->Power.MobileOperation) {
                //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                SETUP_DCB_DESC(0, DD_SLINK, UNUSED, UNUSED, UNUSED, B,      UNUSED, 0); 
                SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, UNUSED, A,      UNUSED, 0); 
                SETUP_DCB_DESC(2, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 1); 
                SETUP_DCB_DESC(3, CRT,      UNUSED, UNUSED, 0,      B,      UNUSED, 1); 
                SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 2); 
                SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 2); 
                SETUP_DCB_DESC(6, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
                DevDescs = 6;
                CRTCs = 2;
            }
            else {
                //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0); 
                SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                SETUP_DCB_DESC(2, DD_SLINK, UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                SETUP_DCB_DESC(3, CRT,      UNUSED, UNUSED, 1,      B,      UNUSED, 2); 
                SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                SETUP_DCB_DESC(6, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
                DevDescs = 6;
                CRTCs = 2;
            }
        }
        else {  // non NV11 boards
            pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
            pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;
            pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
            pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;
            pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_UNUSED;
            I2cPorts = 2;

            //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
            SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(2, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(3, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
            DevDescs = 3;
            CRTCs = 1;
        }
    }
    else {
        // read DCB device descriptors. endianess ?
        offset = DCBBase + DCB_DEV_DESC_OFFSET;
        for (i = 0; i < DCB_MAX_NUM_DEVDESCS; i++) {
            pDev->Dac.DCBDesc[i].DCBDevRec.DevRec_U032 = BIOS_RD32(offset);
            if (pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_EOL)
                break;
            offset += sizeof(U032);

            pDev->Dac.DCBDesc[i].DataPtr = BIOS_RD16(offset);
            offset += sizeof(U016);

            pDev->Dac.DCBDesc[i].DCBDevData.DataDword = BIOS_RD32(offset);
            offset += sizeof(U032);

            // keep track of the highest head number
            if (pDev->Dac.DCBDesc[i].DCBRecHead > CRTCs)
                CRTCs = pDev->Dac.DCBDesc[i].DCBRecHead;
        }
        DevDescs = i;   // # of device descriptors, excluding EOL
        CRTCs++;        // head number is zero based

        // read the I2C Configuration Block (ICB). endianess ?
        offset = BIOS_RD16(DCBBase + DCB_ICB_OFFSET);
        pI2cPort = (U032 *)pDev->Dac.DCBI2c;
        for (i = 0; i < DCB_MAX_NUM_I2C_RECORDS; i++) {
            *pI2cPort++ = BIOS_RD32(offset);
    
            if (pDev->Dac.DCBI2c[i].I2cAccess == I2C_PORT_ACCESS_UNUSED)
                break;

            offset += sizeof(U032);
        }
        I2cPorts = i;
    }
    
    // override nvHalmcControl_nv10 setting
    DACHALINFO(pDev, NumCrtcs) = CRTCs;

    // find all devices with no I2C port.  these are the built in devices.
    // currently, only the flat panel on laptop doesn't have an I2C port
    // associate with it.  assume at most one device of each type.
    for (i = 0; i < DevDescs; i++) {
        if (pDev->Dac.DCBDesc[i].DCBRecIdxToICB == DCB_DEV_REC_LOGICAL_PORT_UNUSED) {
            switch (pDev->Dac.DCBDesc[i].DCBRecType) {
            case DCB_DEV_REC_TYPE_CRT:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_CRT_OFFSET_IN_MAP;
                CRTs = 1;
                break;

            case DCB_DEV_REC_TYPE_TV:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_TV_OFFSET_IN_MAP;
                TVs = 1;
                break;

            case DCB_DEV_REC_TYPE_DD_SLINK:
            case DCB_DEV_REC_TYPE_DD_DLINK:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_DD_OFFSET_IN_MAP;
                DDs = 1;
                break;
            }
        }
    }

    // assign device unit number according to the I2C port number.  devices
    // of the same type connected to the same I2C port have the same unit
    // number since they use the same connnector.
    for (i = 0; i < I2cPorts; i++) {
        int     CRTFound;
        int     TVFound;
        int     DDFound;

        CRTFound = TVFound = DDFound = 0;
        for (j = 0; j < DevDescs; j++) {
            if (pDev->Dac.DCBDesc[j].DCBRecIdxToICB != i)
                continue;

            switch (pDev->Dac.DCBDesc[j].DCBRecType) {
            case DCB_DEV_REC_TYPE_CRT:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_CRT_OFFSET_IN_MAP + CRTs);
                CRTFound = 1;
                break;

            case DCB_DEV_REC_TYPE_TV:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_TV_OFFSET_IN_MAP + TVs);
                TVFound = 1;
                break;

            case DCB_DEV_REC_TYPE_DD_SLINK:
            case DCB_DEV_REC_TYPE_DD_DLINK:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_DD_OFFSET_IN_MAP + DDs);
                DDFound = 1;
                break;

            }
        }

        CRTs += CRTFound;
        TVs += TVFound;
        DDs += DDFound;
    }

    // create devices bitmap
    pDev->Dac.DevicesBitMap = (((0x1 << CRTs) - 1) << DAC_CRT_OFFSET_IN_MAP) |
        (((0x1 << TVs) - 1) << DAC_TV_OFFSET_IN_MAP) |
        (((0x1 << DDs) - 1) << DAC_DD_OFFSET_IN_MAP);

    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "DevicesConnected", &pDev->Dac.DevicesNoCheck) != RM_OK)
        pDev->Dac.DevicesNoCheck = 0x0;

    return RM_OK;
}

// find the connect status of the specified devices.  a set bit
// in the bit map mean the calling routine want to know the connect
// status of the corresponding device.  this routine will keep a set
// bit set if the corresponding device is connected, clear a set bit
// if the corresponding device is not connected.
VOID dacDevicesConnectStatus
(
    PHWINFO pDev,
    U032    *pDevBitMap
)
{
    U032            dev = *pDevBitMap;
    PDACDCBDEVDESC  pDevDesc;
    U032            CurrDevTypeUnit = 0x1;
    BOOL            status;

    using_new_api = TRUE;
    while (dev) {
        if (dev & 0x1) {
            if (CurrDevTypeUnit & pDev->Dac.DevicesNoCheck)
                goto NextDev;

            // go through all entries in the DCB to find matching devices.
            pDevDesc = pDev->Dac.DCBDesc;
            while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
                if  (pDevDesc->DevTypeUnit == CurrDevTypeUnit) {
                    if (pDevDesc->DCBRecIdxToICB == DCB_DEV_REC_LOGICAL_PORT_UNUSED)
                        goto NextDev;

                    switch (pDevDesc->DCBRecType)  {
                    case DCB_DEV_REC_TYPE_CRT:
                        status = dacMonitorConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;

                    case DCB_DEV_REC_TYPE_TV:
                        status = dacTVConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;

                    case DCB_DEV_REC_TYPE_DD_SLINK:
                    case DCB_DEV_REC_TYPE_DD_DLINK:
                        status = dacFlatPanelConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;
                    }

                    if (status == FALSE)
                        // clear the corresponding bit if no devices found.
                        *pDevBitMap &= ~CurrDevTypeUnit;

                    goto NextDev;
                }
                pDevDesc++;
            }
        }

NextDev:
        dev >>= 1;
        CurrDevTypeUnit <<= 1;
    }
    using_new_api = FALSE;
}

// this routine will try to find a configuration for the specified
// devices. return FALSE if a suitable configuration cannot be found.
// the configuration is returned in pAllocationMap with the first nibble
// corresponds to the first/rightmost device, second nibble corresponds
// to the second device, ... up to 8 devices can be specified. the nibble
// value is the head that should be connected to the device.
static BOOL dacMapDeviceToHead
(
    PHWINFO     pDev,
    U032        DevBitMap,          // devices in configuration
    U032        HeadsUsed,          // assigned heads
    U032        BusesUsed,          // assigned buses
    U032        CurrDev,            // current device
    U032        NibbleToUse,        // nibble to use for the next allocation
    U032        *pAllocationMap     // allocation map, result that will be passed
                                    // back to the calling routine
)
{
    PDACDCBDEVDESC  pDevDesc;

    // done, no more device
    if (!DevBitMap)
        return TRUE;

    // look for the rightmost set bit
    while (!(DevBitMap & 0x1)) {
        DevBitMap >>= 1;
        CurrDev++;
    }

    // use recursion to map device to head, one at a time.
    pDevDesc = pDev->Dac.DCBDesc;
    while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
        if (pDevDesc->DevTypeUnit != ((U032)0x1 << CurrDev))
            goto NextDevDesc;

        // make sure we are not using resources assigned already.
        if (((0x1 << pDevDesc->DCBRecHead) & HeadsUsed) ||
            ((0x1 << pDevDesc->DCBRecBus) & BusesUsed))
            goto NextDevDesc;

        if (dacMapDeviceToHead(pDev,
                               DevBitMap >> 1,
                               HeadsUsed | (0x1 << pDevDesc->DCBRecHead),
                               BusesUsed | (0x1 << pDevDesc->DCBRecBus),
                               CurrDev + 1,
                               NibbleToUse + 1,
                               pAllocationMap) == TRUE) {
            *pAllocationMap |= pDevDesc->DCBRecHead << (NibbleToUse * 4);
            return TRUE;
        }

NextDevDesc:
        pDevDesc++;
    }

    return FALSE;
}

// find a suitable configuration for the specified devices.
RM_STATUS dacFindDevicesConfiguration
(
    PHWINFO pDev,
    U032    NewDevBitMap,
    U032    *pNewAllocationMap,
    U032    OldDevBitMap,
    U032    OldAllocationMap
)
{
    U032        DevBitMap;
    U032        CurrDev;
    U032        NibbleToUse;
    U032        HeadsUsed = 0x0;     // heads used
    U032        BusesUsed = 0x0;     // buses used
    U032        head;
    PDACDCBDEVDESC pDevDesc;
    U032        AdjustedOldAllocationMap = 0x0;
    U032        AdjustedNibbleToUse;
    U032        NewConfig;

    // find common devices between the old and new configurations. keep them
    // attaching to the same CRTCs if possible.
    DevBitMap = OldDevBitMap;
    CurrDev = NibbleToUse = AdjustedNibbleToUse = 0;
    while (DevBitMap) {
        if (!(DevBitMap & 0x1))
            goto NextDev_0;

        // device in the old but not in the new configuration ?
        if (!(OldDevBitMap & NewDevBitMap & (0x1 << CurrDev))) {
            NibbleToUse++;
            goto NextDev_0;
        }

        // device is in both the old and new configurations.
        // find CRTCs attached to the device and mark it as used.
        // adjust old allocation map such that we can merge it with the new
        // allocation map later.
        head = (OldAllocationMap >> (NibbleToUse++ * 4)) & 0xf;
        HeadsUsed |= 0x1 << head;
        AdjustedOldAllocationMap |= head << (AdjustedNibbleToUse++ * 4);

        // determine other non-shared resources used by this device.
        pDevDesc = pDev->Dac.DCBDesc;
        while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
            if ((pDevDesc->DevTypeUnit != ((U032)0x1 << CurrDev)) ||
                (pDevDesc->DCBRecHead != head))
                pDevDesc++;
            else {
                BusesUsed |= 0x1 << pDevDesc->DCBRecBus;
                break;
            }
        }

NextDev_0:
        DevBitMap >>= 1;
        CurrDev++;
    }

    // find new allocation with common devices at fixed CRTCs.
    NewConfig = 0x0;
    if (dacMapDeviceToHead(pDev,
                           (NewDevBitMap ^ OldDevBitMap) & NewDevBitMap,
                           HeadsUsed,
                           BusesUsed,
                           0,
                           0,
                           &NewConfig) == TRUE) {

        // no merging necessary if there are no common devices.
        if (!(OldDevBitMap & NewDevBitMap)) {
            *pNewAllocationMap = NewConfig;
            return RM_OK;
        }

        // merge configuration.
        DevBitMap = NewDevBitMap;
        *pNewAllocationMap = 0x0;
        CurrDev = NibbleToUse = 0;
        while (DevBitMap) {
            if (!(DevBitMap & 0x1))
                goto NextDev_1;

            if ((0x1 << CurrDev) & OldDevBitMap) {
                *pNewAllocationMap |= (AdjustedOldAllocationMap & 0xf) << (NibbleToUse++ * 4);
                AdjustedOldAllocationMap >>= 4;
            }
            else {
                *pNewAllocationMap |= (NewConfig & 0xf) << (NibbleToUse++ * 4);
                NewConfig >>= 4;
            }

NextDev_1:
            DevBitMap >>= 1;
            CurrDev++;
        }

        return RM_OK;
    }

    // couldn't find allocation with common devices at fixed CRTCs.
    // try to get allocation with no CRTCs fixed.
    if (OldDevBitMap & NewDevBitMap) {
        *pNewAllocationMap = 0x0;
        if (dacMapDeviceToHead(pDev,
                               NewDevBitMap,
                               0x0,
                               0x0,
                               0,
                               0,
                               pNewAllocationMap) == TRUE)
            return RM_OK;
    }

    return RM_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dacinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DACINIT.C                                                         *
*   The DAC is initialized in this module.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <dac.h>
#include <os.h>
#include <i2c.h>
#include <edid.h>
#include "nvhw.h"
#include "nvcm.h"
#include <devinit.h>

//
// DAC names.
//
char dac16Name[] = "SGS 16-bit DAC                ";
char dac32Name[] = "SGS 32-bit DAC (Van Gogh)     ";
char dac64Name[] = "SGS 64-bit DAC (Van Dyke)     ";
char dac128Name[] = "NV 128-bit DAC (Picasso)    ";

//
// Externals.
//

extern char strDevNodeRM[];
char strEnable256Burst[] = "Enable256Burst";
char strTVOutOnPrimary[] = "TVOutOnPrimary";
BOOL dacTVConnected(PHWINFO);

BOOL dacMonitorConnectStatus(PHWINFO,U032);
BOOL dacFlatPanelConnectStatus(PHWINFO pDev, U032);

static U032 dacGetDisplayType(PHWINFO, U032);

//
// Initialize the DAC.
//
RM_STATUS initDac
(
    PHWINFO pDev
)
{
    U032 i;
    U032 j;
    U032 k;
    U032 data, data32;
#ifndef IKOS
    U008 lockA, lockB, cr3BhA, cr3BhB;
    U008 data08;
#endif
    U032 freq = 0;

    nvHalDacControl(pDev, DAC_CONTROL_INIT);

    if ( BiosGetMaxExternalPCLKFreq( pDev, 1, &freq ) == RM_OK )
    {
        if ( freq != 0 )
        {
            // Convert freq from freq(Mhz)*100 to plain Hz
            freq = freq * 10000;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit8bpp  = freq;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp = freq;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit32bpp = freq;
        }
    }

    // Determine I2C setup from BIOS
    dacReadBIOSI2CSettings(pDev);

    // Read/Parse BIOS Display Config Block
    dacParseDCBFromBIOS(pDev);

    //
    // Find out where to send TV Out commands (overrides dacReadBIOSI2CSettings)
    //
    // NV_I2C_PORT_SECONDARY is the default (unless the BIOS overrode it), but
    // we can override everything here with the registry
    if ( OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strTVOutOnPrimary, &data32) == RM_OK)
    {
        pDev->Dac.TVOutPortID = NV_I2C_PORT_PRIMARY;
    }

    //
    // Initialize flags.
    //
    pDev->Dac.UpdateFlags = 0;

    //
    // Initialize cursor.
    //
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        pDev->Dac.CrtcInfo[i].CursorType      = DAC_CURSOR_TWO_COLOR_XOR;
        pDev->Dac.CrtcInfo[i].UpdateFlags = 0;
    }

    //
    // Start the cursor cache at 0
    //
    pDev->Dac.CursorCacheCount = 0;
    pDev->Dac.CursorCacheEntry = 0;
    pDev->Dac.CursorCacheEnable = 1;
    
    //
    // Clear the initial cursor cache data
    //
    for (k = 0; k < MAX_CACHED_CURSORS; k++)
    {
        pDev->Dac.CursorMaskCRC[k] = 0;    
        for (i = 0; i < 32; i++)    
            for (j = 0; j < 32; j++)
                pDev->Dac.CursorImageCache[i][j][k] = 0;
    }                
            
    //
    // Initialize palette to grey scale ramp.
    //
    for (i = 0; i < 256; i++)
        pDev->Dac.Palette[i] = (i << 16) | (i << 8) | i;
    //
    // Initialize gamma to unity translation.
    //
    for (i = 0; i < 256; i++)
        pDev->Dac.Gamma[i] = (i << 16) | (i << 8) | i;
    //
    // Initialize power management state.
    //
    pDev->Dac.DpmLevel = 0;

    //
    // Check for a registry override to temporarily enable the 256Burst setting
    // within the DAC.
    //    
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strEnable256Burst, &data) == RM_OK)
        pDev->Dac.HalInfo.Enable256Burst = data;

    //
    // Set the min/max VCO values from the BIOS. This call may fail if we're
    // running an older BIOS, so in this case we'll use the RM defaults.
    //
    if (DevinitGetMinMaxVCOValues(pDev,
                                  &pDev->Dac.FminVco,
                                  &pDev->Dac.FmaxVco) != RM_OK)
    {
        // Use the RM default values for these chips
        // NOTE: These defaults are duplicated in dacCalcMNP() which may
        //       be called before initDac()
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;

            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }

    //
    // Look for a registry override for min/max VCO (in MHz).
    //
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FminVCO", &data32) == RM_OK)
        pDev->Dac.FminVco = data32 * 1000;

    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FmaxVCO", &data32) == RM_OK)
        pDev->Dac.FmaxVco = data32 * 1000;

    //
    // Set current desktop state to default.
    //
    pDev->Dac.DesktopState = NV_DAC_DESKTOP_STATE_DEFAULT;

    //
    // Attempt to detect the presense of an external TV chip.  Attempt to also
    // identify the part so we know how to program it up when a modeset comes
    // through a bit later.
    //    

    //Skip TV encoder detection for IKOS.
#ifndef IKOS
    //
    // If Canopus, skip the detection
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
        pDev->Dac.EncoderType = NV_ENCODER_NONE;
    else
    {        
        // Use head 0 for decoder detection.
        dacDetectEncoder(pDev, 0);
    } // !Canopus

    // Get TV output format.
    if (dacReadTVOutFromRegistry(pDev, 0, &data32) == RM_OK)
        pDev->Dac.TVoutput = data32;
    else
        pDev->Dac.TVoutput = 0xffffffff;

    // Set TV format to be what the BIOS chose
    CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data08, 0);
    pDev->Dac.TVStandard = data08 & 0x7;

    //
    // We're about to setup head 0's default display type.
    // Before we do that, invalidate any other heads.
    //
    for (i = 1; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        SETDISPLAYTYPE(pDev, i, 0xffffffff);
        SETMONITORTYPE(pDev, i, 0xffffffff);
    }


    
    //Mobile hotkey support initialization.

    pDev->HotKeys.queueHead = 0;
    pDev->HotKeys.queueTail = 0;
    pDev->HotKeys.enabled = FALSE;

    if (pDev->Power.MobileOperation) {

        EnableMobileHotkeyHandling(pDev);

        lockA = ReadCRTCLock(pDev, 0);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs
        lockB = ReadCRTCLock(pDev, 1);           //Back up lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 1);    //Unlock CRTC extended regs

        //Read CR3B regs -- used below to set default display types.
        // Write back the registers with the 'enable' bits cleared.
        // They will be set as needed via display driver calls to dacSetModeMulti.
        CRTC_RD(0x3B, cr3BhA, 0);
        CRTC_WR(0x3B, cr3BhA & 0x0F, 0);

        CRTC_RD(0x3B, cr3BhB, 1);
        CRTC_WR(0x3B, cr3BhB & 0x0F, 1);

        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lockA, 0); // Restore lock state
        CRTC_WR(NV_CIO_SR_LOCK_INDEX, lockB, 0); // Restore lock state
    }

    if ((pDev->Power.MobileOperation) && ((pDev->Chip.BiosRevision & 0xFF0000FF) >= 0x03000019)) {
    //Set startup display options based on BIOS CR3B settings.
    /*        if (cr3BhA & 0x10) {
            data = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
        } else */
        if (cr3BhA & 0x20) {
            data = DISPLAY_TYPE_MONITOR;
        } else if (cr3BhA & 0x40) {
            data = DISPLAY_TYPE_TV;
        } else if (cr3BhA & 0x80) {
            data = DISPLAY_TYPE_FLAT_PANEL; //external DFP
        } else {
            data = DISPLAY_TYPE_NONE;
        }

        SETDISPLAYTYPE(pDev, 0, data);

        if (cr3BhB & 0x10) {
            data = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
/*        } else if (cr3BhB & 0x20) {
            data = DISPLAY_TYPE_MONITOR;
        } else if (cr3BhB & 0x40) {
            data = DISPLAY_TYPE_TV;
        } else if (cr3BhB & 0x80) {
            data = DISPLAY_TYPE_FLAT_PANEL; //external DFP
            */
        } else {
            data = DISPLAY_TYPE_NONE;
        }

        SETDISPLAYTYPE(pDev, 1, data);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/0 register init:", cr3BhA);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/1 register init:", cr3BhB);

    } else {

    //
    // Set default boot display type...first, use what the
    // CR28/CR33 registers tell us via the BIOS settings.
    //
        SETDISPLAYTYPE(pDev, 0, dacGetBiosDisplayType(pDev, 0));
        SETDISPLAYTYPE(pDev, 0, dacGetDisplayType(pDev, 0));
    }


    //Determine which displays the VGA BIOS enabled at boot time, so that on mobile systems
    //we can have the same ones enabled in Windows.  The result is reported to the display
    //driver as a device bit mask rather than the old head-based system.
    data = 0;   //clear boot device bitmask
    //Loop over all heads
    for (j = 0; j < MAX_CRTCS; j++) {   //Head
//        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "*** Head:", j);
        k = GETDISPLAYTYPE(pDev, j);    //Device on this head
        //Loop over all list entries
        for (i = 0; (i < DCB_MAX_NUM_DEVDESCS) && (pDev->Dac.DCBDesc[i].DCBRecType != DCB_DEV_REC_TYPE_EOL); i++)
        {
//            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  *** Checking for: ", pDev->Dac.DCBDesc[i].DevTypeUnit);
            //If list entry is for this head...
            if (pDev->Dac.DCBDesc[i].DCBRecHead == (U032)(j?DCB_DEV_REC_HEAD_B:DCB_DEV_REC_HEAD_A))
            {
                //...and display type matches the BIOS's...
                if (((pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_CRT) && (k == DISPLAY_TYPE_MONITOR))
                    || ((pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_DD_SLINK) && (k == DISPLAY_TYPE_FLAT_PANEL))
                    || ((pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_TV) && (k == DISPLAY_TYPE_TV)))
                {
                    //...OR this entry's mask into the boot device mask
                    data |= pDev->Dac.DCBDesc[i].DevTypeUnit;   //Device bitmask for device on this head.
                }
            }
        }
    }
    pDev->Dac.BootDevicesBitMap = data;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Boot device(s):", pDev->Dac.BootDevicesBitMap);

    //LPL: This forcing of the display type in the mobile case is a workaround
    // while the display driver still determines which display we booted on (or
    // which display is the primary, in extended mode) using the old method.
    // Once the switch to the new, improved method implemented above (using
    // NV_CFG_GET_BOOT_DEVICES) is complete, the code below should be deleted.
    if (pDev->Power.MobileOperation && (GETDISPLAYTYPE(pDev, 1) == DISPLAY_TYPE_FLAT_PANEL))
        SETDISPLAYTYPE(pDev, 0, DISPLAY_TYPE_FLAT_PANEL);
    //


    //
    // Set the MonitorType for head 0 *only*
    //
    switch (GETDISPLAYTYPE(pDev, 0))
    {
        case DISPLAY_TYPE_MONITOR:
            SETMONITORTYPE(pDev, 0, MONITOR_TYPE_VGA);
            break;
        case DISPLAY_TYPE_TV:
            switch (pDev->Dac.TVStandard)
            {
                case NTSC_M:
                case NTSC_J:
                    SETMONITORTYPE(pDev, 0, MONITOR_TYPE_NTSC);
                    break;
                case PAL_A:
                case PAL_M:
                case PAL_N:
                case PAL_NC:
                    SETMONITORTYPE(pDev, 0, MONITOR_TYPE_PAL);
                    break;
            }
            break;
        case DISPLAY_TYPE_FLAT_PANEL:        
            SETMONITORTYPE(pDev, 0, MONITOR_TYPE_FLAT_PANEL);
            break;
        default:
            SETDISPLAYTYPE(pDev, 0, DISPLAY_TYPE_MONITOR);
    }
#endif // not IKOS

    //
    // initialize per-crtc state
    //
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        pDev->Dac.CrtcInfo[i].RefCount = 0;
        pDev->Dac.CrtcInfo[i].StateFlags = 0;
        pDev->Dac.CrtcInfo[i].VBlankCounter = 0;
        pDev->Dac.CrtcInfo[i].VBlankToggle = 0;
        pDev->Dac.CrtcInfo[i].VBlankCallbackList = NULL;
        pDev->Dac.CrtcInfo[i].CurrentPanOffset = 0;
        pDev->Dac.CrtcInfo[i].CurrentImageOffset = 0;
    }

    //
    // Perform any os initialization
    //
    initDacEx(pDev);
    
    //
    // initialize I2C lock flags
    //
    pDev->I2CAcquired = 0;

    //
    // Initialize CR44 contents to UNKNOWN 
    //
    pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN;

    //
    // Determine which head was used to boot the system
    //
    // NEED TO DO: Get this from the BIOS, but for now if we're
    // a mobile system booting the DFP let's get the drivers to swing
    // over to the secondary head.
    // LPL : preliminary version that reads from BIOS in place above.
    //
    pDev->Dac.HalInfo.InitialBootHead = 0;
#ifdef MACOS
    if (pDev->Dac.HalInfo.NumCrtcs > 1)    // ie: NV11
        if (GETDISPLAYTYPE(pDev, 1) == DISPLAY_TYPE_FLAT_PANEL)
            pDev->Dac.HalInfo.InitialBootHead = 1;
#else
    if (pDev->Power.MobileOperation && (GETDISPLAYTYPE(pDev, 0) == DISPLAY_TYPE_FLAT_PANEL))
        pDev->Dac.HalInfo.InitialBootHead = 1;
#endif

    //
    // WORKAROUND - REMOVE QUICKLY BEFORE SCOTT LONG CATCHES ME
    //
    // The current PCLK limits programmed by the HAL are head driven.
    // They really need to be device driven, as the head can drive any
    // one of many devices.  The current HeadB limits were dictated by
    // an external CRT (150MHz max) and were fine while the possible
    // DFP's and TV's stayed below that ceiling.  Now mobile is appearing
    // with huge DFP's, and therefore the 150 limit is insufficient.
    //
    // Since mobile will never use an external DAC, override in this one
    // case to 170MHz in order to handle 16x12 panels.
    //
    // The real limits will actually come from the BIOS via the BIP/3
    // parser.
    //
    if (pDev->Power.MobileOperation)
    {
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit8bpp = 170000000;
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit16bpp = 170000000;
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit32bpp = 170000000;
    }

    return (RM_OK);
}

// WinNT / Win2k Notes:
//
//        Before RmInitDevice() is called in the NT miniport, we need
//        to make sure that any non-primary monitor is 'alive',  so that
//        dacMonitorConnectStatus() works correctly.  We do this by using
//        the 'WakeUpCard' function in the miniport.
//  
//        dacMonitorConnectStatus() sometimes returns FALSE POSITIVE 
//        when on a FLAT PANEL panel or TV.  So to make NT initialization
//        as safe as possible, we need to use combinations of these functions.
//
//        1) Check for CRT first
//        2) Check for Flat Panel
//        3) Check for TV
//        4) Fall back to CRT
//

#ifdef MACOS        /* macos9 or macosX */

// Mac algorithm for monitor selection is different from windows:
//
//   if flat panel avail
//      use it
//   else if CRT attached
//      use it
//   else
//      no device, error.
//

static U032 dacGetDisplayType(
    PHWINFO pDev,
    U032 Head
)
{
    U032   BootDisplayDevice;
    U008   lock;
    RM_STATUS status;

    //
    // Use our current setting as the desired display type.
    //
    BootDisplayDevice = GETDISPLAYTYPE(pDev, Head);

    if (dacFlatPanelConnectStatus(pDev, Head))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel\n");

        BootDisplayDevice = DISPLAY_TYPE_FLAT_PANEL;
        
        dacGetPWMController(pDev);        	
    }
    else if (dacVGAConnectStatus(pDev, Head))
    {
        lock = UnlockCRTC(pDev, Head);
        status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);
        RestoreLock(pDev, Head, lock);
        
        if ((status == RM_OK) && (edidIsAnalogDisplay(pDev, Head)))
            BootDisplayDevice = DISPLAY_TYPE_MONITOR;
    }

    return BootDisplayDevice;
}

#else

static U032 dacGetDisplayType(
    PHWINFO pDev,
    U032 Head
)
{
    U032 BootDisplayDevice;
    BOOL MonitorAvail, FlatPanelAvail, TVAvail, RequestedDisplayDeviceAvail;
    U032 RequestedDisplayDevice;

    //
    // Use our current setting as the desired display type.
    //
    RequestedDisplayDevice = GETDISPLAYTYPE(pDev, Head);

    // @ Detect avail display devices
    // - Check the MONITOR status
    if(dacMonitorConnectStatus(pDev, Head)) {
        MonitorAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Monitor connected\n\r");
    }
    else {
        MonitorAvail = FALSE;
    }

    // - Check the FLATPANEL status
    if(IsNV5orBetter(pDev) && dacFlatPanelConnectStatus(pDev, Head)) {
        FlatPanelAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel connected\n\r");
    }
    else {
        FlatPanelAvail = FALSE;
    }

    // - Check the TV status
    if(dacTVConnectStatus(pDev, Head)) {
        TVAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - TV connected\n\r");
    }
    else {
        TVAvail = FALSE;
    }

    // - Assume the requested display device is not available
    RequestedDisplayDeviceAvail = FALSE;

    switch(RequestedDisplayDevice) {
        case DISPLAY_TYPE_MONITOR:
            if(MonitorAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            if(FlatPanelAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        case DISPLAY_TYPE_TV:
            if(TVAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        default:
            break;
    }

    // - If the requested device is unavail, determine the next best thing
    if(!RequestedDisplayDeviceAvail)
    {
        if(MonitorAvail)
        {
            BootDisplayDevice = DISPLAY_TYPE_MONITOR;
        }
        else
        {
            if(FlatPanelAvail)
            {
                BootDisplayDevice = DISPLAY_TYPE_FLAT_PANEL;
            }
            else
            {
                if(TVAvail)
                    BootDisplayDevice = DISPLAY_TYPE_TV;
                else
                    BootDisplayDevice = dacGetBiosDisplayType(pDev, 0);
            }
        }
    }

    // - If the requested device is present, use it
    if(RequestedDisplayDeviceAvail)
        BootDisplayDevice = RequestedDisplayDevice;

    // Display the resulting display device
    switch(BootDisplayDevice) {

        case DISPLAY_TYPE_MONITOR:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Monitor selected as display device\n\r");
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel selected as display device\n\r");
            break;

        case DISPLAY_TYPE_TV:
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - TV selected as display device\n\r");
               break;

        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Display device is unknown\n\r");
            break;
    }

    return BootDisplayDevice;
}
#endif   /* ! MACOS */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dactv.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC TV Control ****************************\
*                                                                           *
* Module: DACTV.C                                                           *
*   Mode set for TV is done here.                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include "vga.h"
#include "i2c.h"
#include "tv.h"
#include <nvcm.h>
#include <edid.h>

U008 dacGetTVmode(PHWINFO, U032);

//
//  I2C  Strings
//
//---------------------------------------------------------------------------------------
// Philips


//-----------------------------------------------------------------------------
U008 Ph_Gen_Init0[] = {  
              0x01,            //subaddress 01
              0x00,            //reg 1 - load macrovision registers with 0's ???  
              0x00,            //reg 2  
              0x00,            //reg 3  
              0x00,            //reg 4  
              0x00,            //reg 5  
              0x00,            //reg 6  
              0x00,            //reg 7  
              0x00,            //reg 8  
              0x00,            //reg 9  
              0x00,            //reg a  
              0x00,            //reg b  
              0x00,            //reg c  
              0x00,            //reg d  
              0x00,            //reg e  
              0x00,            //reg f  
              0x00,            //reg 10 
              0x00,            //reg 11 
              0x00,            //reg 12 
              0x00,            //reg 13  
              0x00,            //reg 14
              0x00,            //reg 15  
              0x00,            //reg 16
              0x1b,            //reg 17
              0x1b,            //reg 18  
              0x1f,            //reg 19
              0x46,            //reg 1a
              0x00,            //reg 1b  
              0x00,            //reg 1c
              0x00,            //reg 1d  
              0x00,            //reg 1e
              0x00,            //reg 1f  
              0x00,            //reg 20
              0x1b,            //reg 21
              0x00,            //reg 22
              0x00,            //reg 23  
              0x00,            //reg 24
              0x00,            //reg 25  
              0xff,            //reg26                  
              0x3f,            //reg27                  
              0x19,            //reg28 Burst start: PAL=21h,NTSC=19h                 
              0x1d,            //reg29 Burst End: PAL=1dh,NTSC=1dh                 
              0xff,            //reg2a copy guard          
              0xff,            //reg2b copy guard          
              0x0f,            //reg2c cg data             
              0xb4,            //reg2d (clock polarity) 
              0x00,            //reg2e null             
              0x00,            //reg2f null             
              0x00,            //reg30 macro-vision     
              0x00,            //reg31 macro data 0        
              0x00,            //reg32                  
              0x00,            //reg33 data                
              0x00,            //reg34                  
              0x00,            //reg35                  
              0x00,            //reg36 data             
              0x00,            //reg37                  
              0x1a,            //reg38 RGB luma gain       
              0x1a,            //reg39 color gain diff.    
              0x00             //reg3a Color burst Enable    3Ah = 58
};
#define Ph_Gen_Init0_Len sizeof(Ph_Gen_Init0)
        
//----------------------------------------------------------------------------
U008 Ph_Gen_Init1[] = {
              0xa2,            //subaddress a2                2
              0x10,            //rega2 border color black     3   
              0x80,            //rega3 border color           4   
              0x80             //rega4 border color           5
};
#define Ph_Gen_Init1_Len sizeof(Ph_Gen_Init1)

//-----------------------------------------------------------------------------
U008 Ph_Gen_Init2[] = {
              0xfc,            
              0x03,            //regfc cursor position, move cursor off screen     
              0x98             //regfd lut off for now...         
};
#define Ph_Gen_Init2_Len sizeof(Ph_Gen_Init2)

// Format dependent init tables
// Init string 0
U008 Ph_NTSC_Init0[] = {
              0x54,            //start at address 54,
              0x01,            //reg 54 Internal PPD1 & PPD2 clock edge
              0x0f,            //reg 55
              0xc3,            //reg 56
              0x00,            //reg 57
              0x02,            //reg 58
              0x30,            //reg 59
              0x00,            //reg 5a Chrominance Phase (was 88)
              0x76,            //reg 5b
              0xa5,            //reg 5c 
              0x3a,            //reg 5d 
              0x2e,            //reg 5e 
              0x2e,            //reg 5f Cross Color Reduction (was 6e)
              0x00,            //reg 60                 
              0x15,            //reg 61 
              0x3f,            //reg 62 
              0x1f,            //reg 63 
              0x7c,            //reg 64 
              0xf0,            //reg 65  
              0x21,            //reg 66  
              0x00,            //reg 67  
              0x00,            //reg 68  
              0x00,            //reg 69  
              0x00,            //reg 6a
              0x00,            //reg 6b reserved
              0x01,            //reg 6c  
              0x20,            //reg 6d  
              0x00,            //reg 6e Blanking Control
              0x42,            //reg 6f CCN b[7:6], SCCLN b[4:0] (was 00)
              0x48,            //reg 70
              0x44,            //reg 71
              0x61,            //reg 72
              0x90,            //reg 73
              0x94,            //reg 74
              0xB0,            //reg 75
              0x78,            //reg 76
              0xf9,            //reg 77
              0x2a,            //reg 78
              0x2a,            //reg 79
              0x29,            //reg 7a >>> was 29, maybe 1d
              0x01,            //reg 7b >>> was 01, maybe f9 or de
              0x00,            //reg 7c
              0x00,            //reg 7d
              0x0c,            //reg 7e
              0x0d,            //reg 7f
              0x00,            //reg 80
              0x48,            //reg 81 >>> was 48, maybe ad
              0x2a,            //reg 82
              0x21             //reg 83
};
#define Ph_NTSC_Init0_Len sizeof(Ph_NTSC_Init0)

//-----------------------------------------------------------------------------
U008 Ph_NTSC_Init1[] = {
              0x90,            //start at address 90,
              0x5c,            //reg 90
              0x40,            //reg 91
              0x58,            //reg 92
              0x58,            //reg 93
              0x04,            //reg 94
              0xa0,            //reg 95
              0x02,            //reg 96
              0x2e,            //reg 97
              0x1f,            //reg 98
              0x13,            //reg 99
              0xf4,            //reg 9a
              0x33,            //reg 9b
              0x7f,            //reg 9c
              0x99,            //reg 9d
              0x99             //reg 9e
};
#define Ph_NTSC_Init1_Len sizeof(Ph_NTSC_Init1)

// Init string 0
U008 Ph_PAL_Init0[] = {
              0x54,            //start at address 54,
              0x01,            //reg 54 Internal PPD1 & PPD2 clock edge
              0x0f,            //reg 55
              0xc3,            //reg 56
              0x00,            //reg 57
              0x02,            //reg 58
              0x30,            //reg 59
              0x00,            //reg 5a Chrominance Phase (was 88)
              0x7d,            //reg 5b
              0xaf,            //reg 5c 
              0x33,            //reg 5d 
              0x35,            //reg 5e 
              0x75,            //reg 5f Cross Color Reduction (was 6e)
              0x00,            //reg 60                 
              0x02,            //reg 61 
              0x2f,            //reg 62 
              0xcb,            //reg 63 
              0x8a,            //reg 64 
              0x09,            //reg 65  
              0x2a,            //reg 66  
              0x00,            //reg 67  
              0x00,            //reg 68  
              0x00,            //reg 69  
              0x00,            //reg 6a
              0x00,            //reg 6b reserved
              0x01,            //reg 6c  
              0x20,            //reg 6d  
              0x00,            //reg 6e Blanking Control
              0x42,            //reg 6f CCN b[7:6], SCCLN b[4:0] (was 00)
              0x56,            //reg 70
              0x52,            //reg 71
              0x61,            //reg 72
              0x90,            //reg 73
              0x94,            //reg 74
              0xB0,            //reg 75
              0x78,            //reg 76
              0xf9,            //reg 77
              0x2a,            //reg 78
              0xfa,            //reg 79
              0x26,            //reg 7a >>> was 29, maybe 1d
              0x27,            //reg 7b >>> was 01, maybe f9 or de
              0x40,            //reg 7c
              0x00,            //reg 7d
              0x0c,            //reg 7e
              0x0d,            //reg 7f
              0x00,            //reg 80
              0x00,            //reg 81 >>> was 48, maybe ad
              0x00,            //reg 82
              0x1c             //reg 83
};
#define Ph_PAL_Init0_Len sizeof(Ph_PAL_Init0)

//-----------------------------------------------------------------------------
U008 Ph_PAL_Init1[] = {
              0x90,            //start at address 90,
              0x68,            //reg 90
              0x40,            //reg 91
              0x45,            //reg 92
              0x45,            //reg 93
              0x04,            //reg 94
              0xb8,            //reg 95
              0x02,            //reg 96
              0x2e,            //reg 97
              0x25,            //reg 98
              0x53,            //reg 99
              0xf4,            //reg 9a
              0x89,            //reg 9b
              0x8f,            //reg 9c
              0x43,            //reg 9d
              0x43,            //reg 9e
              0x4c
};
#define Ph_PAL_Init1_Len sizeof(Ph_PAL_Init1)

// Mode Tables
U008 Ph_NTSC_640[] = {
                0x70,       //start at address 70  
                0x3e,       //reg 70 Active display H Start (horizontal centering)
                0x3e,       //reg 71 Active display H End
                0x61,       //reg 72=0x61
                0x90,       //reg 73=0x90
                0x94,       //reg 74=0x94
                0xb0,       //reg 75=0xb0
                0x78,       //reg 76=0x78
                0xf9,       //reg 77=0xf9
                0x2a,       //reg 78=0x2a
                0xfa,       //reg 79=0xfa
                0x20,       //reg 7a
                0xf6,       //reg 7b
                0x00,       //reg 7c=0x00
                0x00,       //reg 7d=0x00
                0x0c,       //reg 7e=0x0c
                0x0d,       //reg 7f=0x0d
                0x00,       //reg 80=0x00
                0x00,       //reg 81  Pix clk 0
                0x00,       //reg 82  Pix clk 1
                0x20,       //reg 83  Pix Clk 2
                0x00,       //reg 84=0x00
                0x00,       //reg 85=0x00
                0x00,       //reg 86=0x00
                0x00,       //reg 87=0x00
                0x00,       //reg 88=0x00
                0x00,       //reg 89=0x00
                0x00,       //reg 8a=0x00
                0x00,       //reg 8b=0x00
                0x00,       //reg 8c=0x00
                0x00,       //reg 8d=0x00
                0x00,       //reg 8e=0x00
                0x00,       //reg 8f=0x00
                0x64,       //reg 90=0x60
                0x40,       //reg 91=0x40
                0x45,       //reg 92
                0x45,       //reg 93
                0x04,       //reg 94=0x04
                0xa0,       //reg 95=0xa0
                0x02,       //reg 96=0x02
                0x2e,       //reg 97=0x2e
                0xf9,       //reg 98=0x1f
                0x12,       //reg 99=0x13
                0x00,       //reg 9a=0x00
                0x1b,       //reg 9b
                0x70,       //reg 9c
                0x8d,       //reg 9d
                0x8d,       //reg 9e
                0x3b,       //reg 9f=0x3b
                0x00,       //reg a0=0x00
                0x00,       //reg a1=0x00
                0x10,       //reg a2 
                0x80,       //reg a3  
                0x80        //reg a4  
};
#define Ph_NTSC_Res_Len sizeof(Ph_NTSC_640)

U008 Ph_NTSC_800[] = {
                0x70,        //begin at register 70
                0x4b,        //reg 70
                0x23,        //reg 71
                0x61,        //reg 72
                0x90,        //reg 73
                0x94,        //reg 74
                0xb0,        //reg 75
                0x78,        //reg 76
                0xf9,        //reg 77
                0x2a,        //reg 78
                0xfa,        //reg 79
                0x1e,        //reg 7a
                0xf4,        //reg 7b
                0x00,        //reg 7c
                0x00,        //reg 7d
                0x0c,        //reg 7e
                0x0d,        //reg 7f
                0x00,        //reg 80
                0x00,        //reg 81 Pix clk 0
                0x00,        //reg 82 Pix clk 1
                0x40,        //reg 83 Pix clk 2
                0x00,        //reg 84
                0x00,        //reg 85
                0x00,        //reg 86
                0x00,        //reg 87
                0x00,        //reg 88
                0x00,        //reg 89
                0x00,        //reg 8a
                0x00,        //reg 8b
                0x00,        //reg 8c
                0x00,        //reg 8d
                0x00,        //reg 8e
                0x00,        //reg 8f
                0x62,        //reg 90 [Wiped out by fine adjust]
                0x90,        //reg 91
                0x51,        //reg 92
                0x51,        //reg 93
                0x04,        //reg 94
                0xb8,        //reg 95
                0x02,        //reg 96
                0x2e,        //reg 97
                0xc5,        //reg 98 HLen 
                0x64,        //reg 99 IDEL + HLen
                0x67,        //reg 9a
                0xb1,        //reg 9b
                0x5c,        //reg 9c
                0xd8,        //reg 9d
                0xd8,        //reg 9e
                0x2a,        //reg 9f
                0x00,        //reg a0
                0x00,        //reg a1
                0x10,        //reg a2
                0x80,        //reg a3
                0x80         //reg a4
};

U008 Ph_PAL_640[] = {
                0x70,       //start at address 70  
                0x81,       //reg 70=0x44
                0x59,       //reg 71=0x44
                0x61,       //reg 72=0x61
                0x90,       //reg 73=0x90
                0x94,       //reg 74=0x94
                0xb0,       //reg 75=0xb0
                0x78,       //reg 76=0x78
                0xf9,       //reg 77=0xf9
                0x2a,       //reg 78=0x2a
                0xfa,       //reg 79=0xfa
                0x26,       //reg 7a=0x29  >>> was 29, maybe 1d
                0x27,       //reg 7b=0x01  >>> was 01, maybe f9 or de
                0x40,       //reg 7c=0x00
                0x00,       //reg 7d=0x00
                0x0c,       //reg 7e=0x0c
                0x0d,       //reg 7f=0x0d
                0x00,       //reg 80=0x00
                0x00,       //reg 81=0x48  Pix clk 0
                0x00,       //reg 82=0x21  Pix clk 1
                0x1c,       //reg 83=0x21  Pix Clk 2
                0x00,       //reg 84=0x00
                0x00,       //reg 85=0x00
                0x00,       //reg 86=0x00
                0x00,       //reg 87=0x00
                0x00,       //reg 88=0x00
                0x00,       //reg 89=0x00
                0x00,       //reg 8a=0x00
                0x00,       //reg 8b=0x00
                0x00,       //reg 8c=0x00
                0x00,       //reg 8d=0x00
                0x00,       //reg 8e=0x00
                0x00,       //reg 8f=0x00
                0x68,       //reg 90=0x60
                0x40,       //reg 91=0x40
                0x45,       //reg 92=0x58  >>> was 58, maybe 3d
                0x45,       //reg 93=0x58  >>> was 58, maybe 3d
                0x04,       //reg 94=0x04
                0xb8,       //reg 95=0xa0
                0x02,       //reg 96=0x02
                0x2e,       //reg 97=0x2e
                0x25,       //reg 98=0x1f
                0x53,       //reg 99=0x13
                0x81,       //reg 9a=0x00
                0x89,       //reg 9b=0x33  >>> was 33, maybe 4e
                0x8f,       //reg 9c=0x70  >>> was 70, maybe 70
                0x43,       //reg 9d=0x99  >>> was 99, maybe a6
                0x43,       //reg 9e=0x99  >>> was 99, maybe a6
                0x4c,       //reg 9f=0x3b
                0x00,       //reg a0=0x00
                0x00,       //reg a1=0x00
                0x10,       //reg a2 
                0x80,       //reg a3  
                0x80        //reg a4  
};
#define Ph_PAL_Res_Len sizeof(Ph_PAL_640)

U008 Ph_PAL_800[] = {
                0x70,        //begin at register 70
                0x5d,        //reg 70
                0x51,        //reg 71
                0x61,        //reg 72
                0x90,        //reg 73
                0x94,        //reg 74
                0xb0,        //reg 75
                0x78,        //reg 76
                0xf9,        //reg 77
                0x2a,        //reg 78
                0xfa,        //reg 79
                0x24,        //reg 7a
                0x29,        //reg 7b
                0x40,        //reg 7c
                0x00,        //reg 7d
                0x0c,        //reg 7e
                0x0d,        //reg 7f
                0x00,        //reg 80
                0x00,        //reg 81 Pix clk 0
                0x00,        //reg 82 Pix clk 1
                0x2c,        //reg 83 Pix clk 2
                0x00,        //reg 84
                0x00,        //reg 85
                0x00,        //reg 86
                0x00,        //reg 87
                0x00,        //reg 88
                0x00,        //reg 89
                0x00,        //reg 8a
                0x00,        //reg 8b
                0x00,        //reg 8c
                0x00,        //reg 8d
                0x00,        //reg 8e
                0x00,        //reg 8f
                0x66,        //reg 90 [Wiped out by fine adjust]
                0x90,        //reg 91
                0x50,        //reg 92
                0x50,        //reg 93
                0x04,        //reg 94
                0xb8,        //reg 95
                0x02,        //reg 96
                0x2e,        //reg 97
                0x07,        //reg 98 ,LEN was 0xxff, c,anged to non-sentinel value
                0x54,        //reg 99
                0xaf,        //reg 9a
                0xf2,        //reg 9b
                0x6c,        //reg 9c
                0x77,        //reg 9d
                0x77,        //reg 9e
                0x3b,        //reg 9f
                0x00,        //reg a0
                0x00,        //reg a1
                0x10,        //reg a2
                0x80,        //reg a3
                0x80         //reg a4
};


// Autoconfigure hack
U008    Bt_NM800[] = { 0xB8, 0x02, 0xff };
U008    Bt_NM640[] = { 0xB8, 0x00, 0xff };
//
// Brooktree strings
//

//  Init string               C4    C6    C8            CA           CC             CE
U008    BT_Init[] = { 0xC4, 0x01, 0x98, BT_FLICKER_MED, BT_LUMA_DEF, BT_CHROMA_DEF, (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL), 0xff };
U008    BT871_Init[] = { 0xC4, 0x01, 0x98, BT_FLICKER_MED, BT871_LUMA_DEF, BT871_CHROMA_DEF, (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL), 0xff };

/************************************************************************************************
    We now support 6 distinct TV standards: NTSC M, NTSC J, PAL NC, PAL M, PAL N, and
    PAL B, D, G, I (which are the same as far as we are concerned).
*/
//---------------------------------------------------------------------------------------
// Brooktree 800x600

// NTSC M 800x600
U008 Bt_NM600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
// 76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90
 0x76, 
 0xA0, 0x20, 0xB6, 0xD8, 0xB9, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
// 92    94    96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA,
// B0    B2    B4    B6
 0xE8, 0xA2, 0x17, 0x00, 
 0xff};

// NTSC J 800x600
U008 Bt_NJ600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
 0x76, 
 0xA0, 0x20, 0xB6, 0xD8, 0xB9, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x08, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA,
 0xE8, 0xA2, 0x17, 0x00,
 0xff};

// PAL NC 800x600
U008 Bt_NC600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
 0x76, 
 0x00, 0x20, 0xAA, 0xCA, 0xA4, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 
 0x5F, 0x58, 0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x56, 0x7F, 0x47, 0x8C, 0x35,
 0xEF, 0x78, 0x19, 0x00,
 0xff};

// PAL B,D,G,I 800x600
U008 Bt_PA600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE,
 0x5F, 0x58, 0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18,
 0x28, 0x87, 0x1F, 0x00,
 0xff};

// PAL M 800x600
U008 Bt_PM600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
 0x76, 
 0xA0, 0x20, 0xB6, 0xE0, 0xC2, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x2A, 0xF0, 0x56, 0x7E, 0x47, 0x8C, 0x7E,
 0x42, 0x9C, 0x17, 0x00,
 0xff};

// PAL N 800x600
U008 Bt_PN600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
0x76, 
0x00, 0x20, 0xAA, 0xCA, 0x9A, 0xF3, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE,
0x5F, 0x58, 0x3A, 0x66, 0x56, 0x00, 0x00, 0x10, 0x2E, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18,
0x28, 0x87, 0x1F, 0x00,
0xff};

//---------------------------------------------------------------------------------------
// Native TV modes with no overscan.  For use when playing DVD's

// Brooktree 720x480 NTSC
U008 Bt_NMDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94
    0x76, 
    0xE0, 0xD0, 0x82, 0x92, 0x5C, 0x1B, 0x13, 0xF2, 0x26, 0x00, 0x70, 0x8C, 0x03, 0x0D, 0x24, 0xE0, 
    0x36, 0x00, 0x50, 0xC5, 0x4E, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0xD1, 0x45, 0x17, 0x21, 
    0x00, 0xff};

U008 Bt_NJDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94
    0x76, 
    0x66, 0xD0, 0x82, 0x92, 0x5C, 0x1B, 0x13, 0xF2, 0x27, 0x00, 0x70, 0x8C, 0x03, 0x0D, 0x24, 0xE0, 
    0x36, 0x00, 0x50, 0xC5, 0x4E, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0xD1, 0x45, 0x17, 0x21, 
    0x00, 0xff};

U008 Bt_NCDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PADVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PMDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PNDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

//---------------------------------------------------------------------------------------

// Two no-overscan modes, which will be the default on X-box:

// Brooktree 640x480 NTSC
U008 Bt_NM480x[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	   8E	 90
    0x76,
    0x08, 0x80, 0x72, 0x80, 0x42, 0xf1, 0x13, 0xf2, 0x26, 0x00, 0x04, 0x73, 0x03, 0x0d, 
    0x24, 0xe0, 0x00, 0x00, 0x10, 0x15, 0xcc, 0x0a, 0x0a, 0xe5, 0x77, 0x7a, 0x45, 0x85, // 92-AC
    0x81, 0x5f, 0xb8, 0x25, 0x00,             // AE-B6 (stop here: B8 is the autoconfig mode register)
    0xff};

// Brooktree 640x480 PAL. This one starts at reg 38.
U008 Bt_PA480x[] = {
// 38,   3A,   3C,   3E,   40,   42,   44,   46,   48,   4A,   4C,   4E,   50,   52,   54,   56,   58,   5A,   5C,   5E 
 0x38,
 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x2e, 0x1a, 0x01, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x46, 0x00, 0x01,                                  // 60-74
 0x3c, 0x80, 0x76, 0x8c, 0x44, 0x1b, 0x16, 0x20, 0xA6, 0x00, 0xB6, 0xFB, 0x03, 0x0D,    // 76-90
 0x23, 0xe0, 0x06, 0xe1, 0x4a, 0x55, 0x15, 0x0b, 0x24, 0xf0, 0x59, 0x83, 0x4a, 0x8c,    // 92-AC
 0x33, 0x98, 0x83, 0x2d, 0x00,                                                          // AE-B6
 0xff};

// Normal modes used with 868/869:

 //---------------------------------------------------------------------------------------
// Brooktree 640x480

// NTSC 640x480
U008 Bt_NM480[] = {
// 0x6e, 0x26, 0x02, 0x00, 0x01,
// 76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90
 0x76, 
 0x00, 0x80, 0x84, 0x9E, 0x65, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58,
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// NTSC J 640x480
U008 Bt_NJ480[] = {
// 0x6e, 0x26, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x9E, 0x65, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58, 
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// PAL NC 640x480
U008 Bt_NC480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x60, 0x80, 0x8A, 0xA6, 0x70, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x1E,
 0xC0, 0x15, 0x1F, 0x00,
 0xff};

// PAL B,D,G,I 640x480
U008 Bt_PA480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
// 0x76, 78    7a    7c    7e    80    82    84    86    88    8a    8c    8e    90
 0x76,
 0x60, 0x80, 0x8A, 0xA6, 0x68, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71,
// 92    94    96    98    9a    9c    a0    a2    a4    a6    a8    aa    ac    ae    b0
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x24, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C,
 0x8C, 0x79, 0x26, 0x00,
 0xff};

// PAL M 640x480
U008 Bt_PM480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0xA4, 0x6A, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58, 
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x2A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6E, 
 0xDB, 0x76, 0x20, 0x00,
 0xff};

// PAL N 640x480
U008 Bt_PN480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x60, 0x80, 0x8A, 0xA6, 0x68, 0xAB, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x2E, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C,
 0x8C, 0x79, 0x26, 0x00,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree 640x400

// NTSC M 640x400
U008 Bt_NM400[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x96, 0x60, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// NTSC J 640x400
U008 Bt_NJ400[] = {
// 0x6e, 0xc0, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x96, 0x60, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00, 
 0x00, 0x80, 0x20, 0x00,
 0xff};

// PAL NC 640x400
U008 Bt_NC400[] = {
// 0x6e, 0xc0, 0x02, 0x00, 0x01,
0x76, 
0x90, 0x80, 0x8E, 0xAA, 0x76, 0xDD, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6B, 
0x73, 0x50, 0x1E, 0x00, 
0xff};

// PAL B,D,G,I 640x400
U008 Bt_PA400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
//0x76,  78    7a    7c    7e    80    82    84    86    88    8a    8c    8e    90
  0x90, 0x80, 0x8E, 0xAA, 0x6E, 0xDD, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
//  92    94    96    98    9a    9c    a0    a2    a4    a6    a8    aa    ac    ae    b0
  0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x24, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0xEA, 
  0x57, 0x85, 0x25, 0x00,
 0xff};

// PAL M 640x400
U008 Bt_PM400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
// 0x76, 
 0x00, 0x80, 0x84, 0xA4, 0x6A, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x2A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6E, 
 0xDB, 0x76, 0x20, 0x00,
 0xff};

// PAL N 640x400
U008 Bt_PN400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
//0x76 
0x90, 0x80, 0x8E, 0xAA, 0x6E, 0xC5, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x2E, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0xEA, 
0x57, 0x85, 0x25, 0x00, 
0xff};

//---------------------------------------------------------------------------------------
//  Centering
//  H, V Offset. 6E = H Offset Low, 70[7,6] = H Offset High, 70[5:0] = H Sync Width
//               72 = V Offset Low, 74[5:3] = V Offset High, 74[2:0] = V Sync Width
//  NV4 Horizontal Offset should be 8 pixels less than NV5 & up (see programBrooktree()).
//---------------------------------------------------------------------------------------

// NTSC M 800x600
U008 Btc_NM600[] = {
 0x6e, 0xe0, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 800x600
U008 Btc_PA600[] = {
 0x6e, 0x2a, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC 720x480
U008 Btc_NMDVD[] = {
 0x6e, 0x28, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 720x576
U008 Btc_PADVD[] = {
 0x6e, 0x28, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC 640x480
U008 Btc_NM480[] = {
 0x6e, 0x1e, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 640x480
U008 Btc_PA480[] = {
 0x6e, 0xac, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 640x400
U008 Btc_NM400[] = {
 0x6e, 0xb6, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 640x400
U008 Btc_PA400[] = {
 0x6e, 0x2e, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 320x400
// CURRENTLY UNUSED
U008 Btc_NM3x4[] = {
 0x6e, 0x00, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320X400
U008 Btc_PA3x4[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 512x384
U008 Btc_NM384[] = {
 0x6e, 0x08, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 512x384
U008 Btc_PA384[] = {
 0x6e, 0x80, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 480x360
U008 Btc_NM360[] = {
 0x6e, 0x08, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 480x360
U008 Btc_PA360[] = {
 0x6e, 0x80, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 400x300
U008 Btc_NM300[] = {
 0x6e, 0xac, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 400x300
U008 Btc_PA300[] = {
 0x6e, 0x05, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 320x240
U008 Btc_NM240[] = {
 0x6e, 0xd2, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320x240
U008 Btc_PA240[] = {
 0x6e, 0x60, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree 320x200

// NTSC M 320x200
U008 Btc_NM200[] = {
 0x6e, 0x6b, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320x200
U008 Btc_PA200[] = {
 0x6e, 0xd8, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree I2C tables for TV modes 0..9
// Some modes are scanline and/or character doubled (e.g. 320x200 is really 640x400)
// Some modes do not have specific encoder tables; they use the next larger format
// (e.g. 512x384 uses 640x400).
// DVD native mode is the native TV resolution with overscan compensation disabled
// There are 3 sets of tables (400, 480, 600) times 6 TV formats.
//    320x200   320x240   320x400   400x300   480x360   512x384   640x400   640x480   800x600  DVD native
U008 *Bt_NM[] =    // NTSC M
    {Bt_NM400, Bt_NM480, Bt_NM400, Bt_NM600, Bt_NM400, Bt_NM400, Bt_NM400, Bt_NM480, Bt_NM600, Bt_NMDVD};

U008 *Bt_NJ[] =    // NTSC J
    {Bt_NJ400, Bt_NJ480, Bt_NJ400, Bt_NJ600, Bt_NJ400, Bt_NJ400, Bt_NJ400, Bt_NJ480, Bt_NJ600, Bt_NJDVD};

U008 *Bt_PM[] =    // PAL M
    {Bt_PM400, Bt_PM480, Bt_PM400, Bt_PM600, Bt_PM400, Bt_PM400, Bt_PM400, Bt_PM480, Bt_PM600, Bt_PMDVD};

U008 *Bt_PA[] =    // PAL BDHGI
    {Bt_PA400, Bt_PA480, Bt_PA400, Bt_PA600, Bt_PA400, Bt_PA400, Bt_PA400, Bt_PA480, Bt_PA600, Bt_PADVD};

U008 *Bt_PN[] =    // PAL N
    {Bt_PM400, Bt_PN480, Bt_PN400, Bt_PN600, Bt_PN400, Bt_PN400, Bt_PN400, Bt_PN480, Bt_PN600, Bt_PNDVD};

U008 *Bt_NC[] =   // PAL NC
    {Bt_NC400, Bt_NC480, Bt_NC400, Bt_NC600, Bt_NC400, Bt_NC400, Bt_NC400, Bt_NC480, Bt_NC600, Bt_NCDVD};

//---------------------------------------------------------------------------------------
// Brooktree Centering tables
// Centering is NTSC-like (NTSC-M, NTSC-J, PAL-M) or PAL-like (PAL-BDGHI, PAL-N, PAL-NC).
// There are 2 sets of tables for 6 TV formats.
//    320x200   320x240    320x400    400x300    480x360    512x384    640x400    640x480    800x600
U008 *Btc_NM[] =    // NTSC M
    {Btc_NM200, Btc_NM240, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_NJ[] =    // NTSC J
    {Btc_NM400, Btc_NM480, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_PM[] =   // PAL M
    {Btc_NM200, Btc_NM480, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_PA[] =   // PAL BDHGI
    {Btc_PA200, Btc_PA240, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};

U008 *Btc_PN[] =   // PAL N
    {Btc_PA200, Btc_PA480, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};

U008 *Btc_NC[] =   // PAL NC
    {Btc_PA200, Btc_PA480, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};


//---------------------------------------------------------------------------------------
// Brooktree Autoconfig tables
//
// Bit 0 indicates NTSC/PAL
// Bits 5:4 indicate overscan ratio, but not in a consisent way (640x480 standard is 0 for PAL and 1 for NTSC, and lower is the reverse).
#define BTAN_640x400    0x08    //001000b
#define BTAN_640x480    0x10    //010000b
#define BTAN_800x600    0x12    //010010b
#define BTAN_1024x768   0x1a    //001010b
#define BTAP_640x400    0x09    //001001b
#define BTAP_640x480    0x01    //000001b
#define BTAP_800x600    0x13    //010011b
#define BTAP_1024x768   0x1b    //001011b

//              640x400  640x480  800x600  1024x768
U008 BTA[] = {  BTAN_640x400, BTAN_640x480, BTAN_800x600, BTAN_1024x768,
                BTAP_640x400, BTAP_640x480, BTAP_800x600, BTAP_1024x768
};
#define BTA_LEN sizeof(BTA)/2

// H Sync
U008 BTHS0[] = { 0x19, 0x19, 0xEB, 0x23,
                  0xAC, 0xAC, 0x2C, 0xEB };
U008 BTHS1[] = { 0x02, 0x02, 0x02, 0x02,
                  0x02, 0x02, 0x02, 0x02};
// Coring & Attenuation
U008 BTCA0[] = { 0xC3, 0xC3, 0xC3, 0xC3,
                  0xC3, 0xC3, 0xC3, 0xC3 };
U008 BTCA1[] = { 0xC2, 0xC2, 0xC2, 0xC2,
                  0xC2, 0xC2, 0xC2, 0xC2 };
// V Active & Lines
U008 BTVAL[] = { 0x06, 0x06, 0x0A, 0x0F,
                  0x06, 0x06, 0x0B, 0x0F };
// Flicker Filter
U008 BTFF0[] = { 0x1B, 0x1B, 0x1B, 0x00,
                  0x12, 0x12, 0x1B, 0x00 };
U008 BTFF1[] = { 0x9B, 0x9B, 0x80, 0x80,
                  0x9B, 0x9B, 0x80, 0x80 };
U008 BTFF2[] = { 0xC0, 0xC0, 0x92, 0xF6,
                  0xC0, 0xC0, 0x92, 0xF6 };

//
//  Chrontel strings
//

//  The I2C init string
U008    CH_Init[] = { 0xea, CH_REG_04, 0x05, CH_REG_06, 0x40, CH_REG_0D, 0x07, CH_REG_0E, 0x0B, CH_REG_1B, 0x20, CH_REG_1C, 0xC0, 0xff };

CH_string  CH_NULL_STRING = {   0xff    };

//  The I2C disable string
U008    CH_Disable[] = { 0xea, CH_REG_0D, 0x03, CH_REG_0E, 0x09, 0xff };

//  Flicker filter, Brightness, and Contrast.
U008    CH_FBC[] = { 0xea, CH_REG_01, CH_FF, CH_REG_09, CH_BL, CH_REG_11, CH_CE, 0xff };

//
// Chrontel I2C timing tables. All resolutions are multiples of these modes.
// Reg A is horizontal position; Reg B is vertical position
// DEVICE REG 0       REG 7       REG A       REG B       REG13, AUTOINC TO REG 15
CH_string  CH_NTSC320X200 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 320x200 (640x400)
CH_string  CH_NTSC320X240 =
{   0xea, CH_REG_00, 0x6a, CH_REG_07, 0x5C, CH_REG_0A, 0x2a, CH_REG_0B, 0x04, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3f, 0x7e, 0xff };  // NTSC 320x240 (640x480)
CH_string CH_NTSC400X300 =
{   0xea, CH_REG_00, 0x8d, CH_REG_07, 0x84, CH_REG_0A, 0x38, CH_REG_0B, 0xe8, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // NTSC 400x300 (800x600)
CH_string  CH_NTSC480X360 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x16, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 480x360 (640x400) 
CH_string  CH_NTSC512X384 = 
//{   0xea, CH_REG_00, 0x09, CH_REG_07, 0xd4, CH_REG_0A, 0x0a, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x63, 0x16, 0xff };  // NTSC 512x384
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x48, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // use NTSC 640x400 
CH_string  CH_NTSC640X400 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 640x400 mode 11
CH_string  CH_NTSC640X480 = 
{   0xea, CH_REG_00, 0x6A, CH_REG_07, 0x5c, CH_REG_0A, 0x2b, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3F, 0x7E, 0xff };  // NTSC 640x480 mode 17
CH_string  CH_NTSC720X576 = 
{   0xea, CH_REG_00, 0x8C, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x13, 0x3E, 0xff };  // NTSC 800x600 mode 24
CH_string  CH_NTSC800X600 = 
{   0xea, CH_REG_00, 0x8D, CH_REG_07, 0x84, CH_REG_0A, 0x3c, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // NTSC 800x600 mode 24

// PAL values 
CH_string  CH_PAL320X200 =
{   0xea, CH_REG_00, 0x40, CH_REG_07, 0xf0, CH_REG_0A, 0x30, CH_REG_0B, 0x08, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL 320x200 (640x400)
CH_string  CH_PAL320X240 =
{   0xea, CH_REG_00, 0x61, CH_REG_07, 0xc0, CH_REG_0A, 0x38, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x04, 0x09, 0xff };  // PAL 320x240 (640x480)
CH_string  CH_PAL400X300 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x8c, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 (800x600)
CH_string  CH_PAL480X360 = 
{   0xea, CH_REG_00, 0x40, CH_REG_07, 0x5c, CH_REG_0A, 0x40, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  480x360 (640x400)
CH_string  CH_PAL512X384 = 
{   0xea, CH_REG_00, 0x40, CH_REG_07, 0xc0, CH_REG_0A, 0x20, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  512x384 (640x400)
CH_string  CH_PAL640X400 = 
{   0xea, CH_REG_00, 0x40, CH_REG_07, 0xee, CH_REG_0A, 0x30, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  640x400 100
CH_string  CH_PAL640X480 = 
{   0xea, CH_REG_00, 0x61, CH_REG_07, 0x6e, CH_REG_0A, 0x34, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x04, 0x09, 0xff };  // PAL  640x480 101
CH_string  CH_PAL720X576 = 
{   0xea, CH_REG_00, 0x81, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x05, 0x39, 0x87, 0xff };  // PAL  720x576
CH_string  CH_PAL800X600 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x7e, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 103

// FSCI data (subcarrier frequency adjustment). If reg 21 bit 0 is set, the subcarrier frequency is automatically selected.
U008 CH_FSCI_640x480[] = {0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 }; // mode 17
U008 CH_FSCI_720x576[] = {0x01, 0x0D, 0x09, 0x0C, 0x00, 0x04, 0x06, 0x0F }; // mode 23
U008 CH_FSCI_800x600[] = {0x01, 0x09, 0x08, 0x0B, 0x03, 0x0A, 0x06, 0x03 }; // mode 24
U008 CH_FSCI_640x480NC[] = {0x01, 0x0f, 0x00, 0x0d, 0x05, 0x04, 0x05, 0x0e }; // PAL NC 640x480
U008 CH_FSCI_720x576NC[] = {0x02, 0x06, 0x07, 0x09, 0x08, 0x0C, 0x00, 0x0C }; // mode 19
U008 CH_FSCI_800x600NC[] = {0x01, 0x09, 0x07, 0x08, 0x0e, 0x0f, 0x03, 0x05 }; // PAL NC 800x600
#define numFSCIbytes    sizeof CH_FSCI_640x480

//
//  NV4 TV adjustments for Chrontel
//
TV_ADJUST CHRONTEL_NTSC[] =
{
//   hRes  vRes  SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR28  encoderStringPtr
    {320,  200,  0x09, 0x2b, 0x2b, 0x0c, 0x3e, 0x00, 0xc0, 0x8f, 0x98, (U008 *)(&CH_NTSC320X200) },
    {320,  240,  0x09, 0x2b, 0x2b, 0x3c, 0x3e, 0x40, 0xe4, 0xdf, 0x88, (U008 *)(&CH_NTSC320X240) },
    {400,  300,  0x09, 0x3d, 0x3d, 0x72, 0xf0, 0x20, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC400X300) },
    // 480x360 and 512x384 use 640x400 encoder mode 
    {480,  360,  0x01, 0x49, 0x40, 0x20, 0xB3, 0x00, 0x90, 0x67, 0x80, (U008 *)(&CH_NTSC480X360) }, 
    {512,  384,  0x01, 0x5b, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x7f, 0x80, (U008 *)(&CH_NTSC512X384) },
    {640,  400,  0x01, 0x5b, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x8f, 0x80, (U008 *)(&CH_NTSC640X400) },
    {640,  480,  0x01, 0x5f, 0x5e, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x80, (U008 *)(&CH_NTSC640X480) },
    {720,  576,  0x01, 0x70, 0x6f, 0x92, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC720X576) }, //LPL: unfinished
    {800,  600,  0x01, 0x76, 0x6f, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC800X600) },
};
//
TV_ADJUST  CHRONTEL_PAL[] =
{
//   hRes  vRes  SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR28  encoderStringPtr
    {320,  200,  0x09, 0x2e, 0x29, 0x0c, 0x3e, 0x00, 0xc0, 0x8f, 0x98, (U008 *)(&CH_PAL320X200) },     
    {320,  240,  0x09, 0x2c, 0x2a, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x88, (U008 *)(&CH_PAL320X240) },     
    {400,  300,  0x09, 0x3c, 0x3c, 0xb0, 0xf0, 0x00, 0x57, 0x57, 0x80, (U008 *)(&CH_PAL400X300) },    
    // 480x360 and 512x384 use 640x400 encoder mode
    {480,  360,  0x01, 0x49, 0x48, 0xf0, 0xB2, 0x00, 0x90, 0x67, 0x80, (U008 *)(&CH_PAL480X360) },   
    {512,  384,  0x01, 0x75, 0x57, 0x0e, 0x3e, 0x00, 0xc0, 0x7f, 0x80, (U008 *)(&CH_PAL512X384) },     
    {640,  400,  0x01, 0x6a, 0x57, 0x0C, 0x3e, 0x00, 0xc0, 0x8f, 0x80, (U008 *)(&CH_PAL640X400) },    
    {640,  480,  0x01, 0x59, 0x56, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x80, (U008 *)(&CH_PAL640X480) },   
    {720,  576,  0x01, 0x6f, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL720X576) },
    {800,  600,  0x01, 0x6f, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL800X600) },  
};
    
//
//  adjustments for Brooktree 
//
// New method eliminates most of the table entries. Only VT needs to be table driven.
// Now we can use normal CRTC values, except HRS = HDE + 1, HT = HRS + 1.
// There are some exceptions to this (see programTV()).
U008    VT_BT_NTSC[] =
   // 320x200,320x240,320x400,400x300,480x360,512x384,640x400,640x480,800x600, DVD
    { 0xd3,   0x32,   0xc8,   0xac,   0xe4,   0x39,   0xca,   0x34,   0xac,    0x0D}; 
U008    VT_BT_PAL[] =
    { 0xf5,   0x42,   0xcf,   0xb6,   0xe8,   0x5a,   0xf4,   0x43,   0xb6,    0x54};


/*************************** Helper functions *******************************/

U008 dacTVReadModifyWrite
(
    PHWINFO pDev, 
    U032    Head,
    U008    Reg,
    U008    WriteData,
    U008    WriteMask
)
{
U008 ReadData, ack;

     // Read register
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg); 
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID); // Start w/o Stop = Restart
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
     i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &ReadData, 1);
     i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
     
     // Combine data and write
     WriteData &= WriteMask;   // just to be safe
     WriteData |= (ReadData & ~WriteMask);
     
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg); 
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) WriteData); 
     i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
     
     return ReadData;
}

static U032 dacGetTVAdjustTableArray
(
    PHWINFO pDev,
    U032 Head,
    TV_ADJUST **adjustTablePtr
)
{
    U032  numEntries;

    numEntries = 0;
    if (TV_ENCODER_FAMILY(pDev->Dac.EncoderType) == TV_ENCODER_CHRONTEL)
    {
        // Chrontel encoder.
        switch (pDev->Dac.TVStandard)
        {
            // modes with NTSC CRTC timing
            case NTSC_M:
            case NTSC_J:
            case PAL_M:
                *adjustTablePtr = (TV_ADJUST *)&CHRONTEL_NTSC;
                numEntries = sizeof(CHRONTEL_NTSC) / sizeof(TV_ADJUST);
                break;
            // modes with PAL CRTC timing
            case PAL_A:
            case PAL_N:
            case PAL_NC:
                *adjustTablePtr = (TV_ADJUST *)&CHRONTEL_PAL;
                numEntries = sizeof(CHRONTEL_PAL) / sizeof(TV_ADJUST);
                break;
        }
    }
#if 0   // this style table lookup not used
    else
    {
        // Brooktree encoder.
        if (pDev->Dac.TVStandard == NTSC)
        {
            // NTSC 
            *adjustTablePtr = (TV_ADJUST *)&BROOKTREE_NTSC;
            numEntries = sizeof(BROOKTREE_NTSC) / sizeof(TV_ADJUST);
        }
        else
        {
            // PAL
            *adjustTablePtr = (TV_ADJUST *)&BROOKTREE_PAL;
            numEntries = sizeof(BROOKTREE_PAL) / sizeof(TV_ADJUST);
        }
    }
#endif

    return numEntries;
} // end of dacGetTVAdjustTableArray

static RM_STATUS dacGetI2CModeString
(
    PHWINFO pDev, 
    U032 Head,
    U032 hRes, 
    U032 vRes,
    U008 **encoderStringPtr
)
{
    U032 i, numEntries;
    TV_ADJUST * adjustTable;

    numEntries = dacGetTVAdjustTableArray(pDev, Head, &adjustTable);
    for (i = 0; i < numEntries; i++)
    {
        if (adjustTable[i].hRes == hRes &&
            adjustTable[i].vRes == vRes)
        {
            // found a match.
            *encoderStringPtr = adjustTable[i].encoderString;
            return RM_OK;
        }
    }

    // did not find a match.
    return RM_ERROR;
} // end of dacGetI2CModeString

static RM_STATUS dacGetTVAdjustTableEntry
(
    PHWINFO pDev,
    U032 Head,
    U032 hRes,
    U032 vRes,
    TV_ADJUST **adjustTableEntry
)
{
    U032 i, numEntries;
    TV_ADJUST * adjustTable;

    numEntries = dacGetTVAdjustTableArray(pDev, Head, &adjustTable);
    for (i = 0; i < numEntries; i++)
    {
        if (adjustTable[i].hRes == hRes &&
            adjustTable[i].vRes == vRes)
        {
            // found a match.
            *adjustTableEntry = &adjustTable[i];
            return RM_OK;
        }
    }

    // did not find a match.
    return RM_ERROR;
} // end of dacGetTVAdjustTableEntry

// Autoconfiguration requires writing a single register.
// The resolution, TV standard, and overscan ration is encapsulated in this mode number.
// Currently, only "standard" overscan is used. 
// Note: in order to get non-overscan modes for 640x480, we can't use autoconfig, so I've added discrete tables.
RM_STATUS dacProgramBrooktreeAuto(PHWINFO pDev, U032 Head)
{
    U032    hRes, vRes;
    U016    status = 0;
    U008    mode, config1, config2, autoConfigMode, *strptr, i;
    
    hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
    vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;

    // generate an index into our mode table
    mode = 0; // not really needed but some compilers complain about uninitialized use

    switch (hRes) 
    {
        case 320:
            switch (vRes) 
            {
                case 200:
                    mode = 0;   // 640x400
                    break;
                case 240:
                    mode = 1;   // 640x480
                    break;
                default:
                    return RM_ERROR;
            }
            break;
        case 400:
            if (vRes == 300) 
                mode = 2; // 800x600
            else
                return RM_ERROR;
            break;
        case 480:
            if (vRes == 360) 
                mode = 1;   // 640x480
            else
                return RM_ERROR;
            break;
        case 512:
            if (vRes == 384) 
                mode = 3;   // 1024x768
            break;
        case 640:
            switch (vRes)
            {
                case 400:
                    mode = 0;   // 640x400
                    break;
                case 480:
                    mode = 1;
                    break;
                default:
                    return RM_ERROR;
            }
            break;
        case 800:
            if (vRes == 600) 
                mode = 2;
            else
                return RM_ERROR;
            break;
        case 1024:
            if (vRes == 768) 
                mode = 3;
            else
                return RM_ERROR;
            break;
        default:
            return RM_ERROR;
    }
    // 640x480 defaults to non-overscan, for which there is no autoconfig. Use tables.
    if (mode == 1) 
    {
        // Set the auto-config mode 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CONFIG);	// subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0);	// 
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        
        // send an init string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        strptr = (U008 *)&BT871_Init;          // send init sequence
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
            if (status)
                break;
        }     
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                strptr = (U008 *)&Bt_NM480x;
                break;
            case PAL_NC:
            case PAL_A:
            case PAL_M:
            case PAL_N:
                strptr = (U008 *)&Bt_PA480x;                
                break;
            default:
                break;
        }
        
        // send a timing string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
            if (status)
                break;
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        
        // Toggle TIMING_RST
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    }
    else // do autoconfig
    {
        // Now adjust index for TV standard
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                break;
            case PAL_NC:
            case PAL_A:
            case PAL_M:
            case PAL_N:
                mode += BTA_LEN;  // second row of table
                break;
            default:
                break;
        }
        autoConfigMode = BTA[mode];
        // The HW designer shoved a reserved bit into the middle of the config info.
        // I could account for this in the table, but I want my table to correspond to the values in the manual, and
        // if the reserved bit is ever used, we'll have to preserve it, so it's better to leave the table as is, and insert
        // into the config byte here.
        config1 = autoConfigMode & 0x07;
        config2 = autoConfigMode & 0x38;
        config2 <<= 1;   // put a 0 in bit 3
        autoConfigMode = config2 | config1;

        // Set the auto-config mode
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CONFIG);	// subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) autoConfigMode);	// 
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }
    
    // Some adjustments
    // Hsync offset + width
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_HS0);	    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTHS0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_HS1);	    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTHS1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Coring + attenuation
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CA0);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTCA0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CA1);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTCA1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // VActive + VLines
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_VAL);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTVAL[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Flicker Filter
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF0);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF1);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF2);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF2[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    return(RM_OK);
}

//****************************************************************************************
//  Program the Brooktree device for a display mode
static RM_STATUS dacProgramBrooktree(PHWINFO pDev, U032 Head)
{
U016    i, status;
U008    *strptr, *strptr2;
U008    Data, TVmode;
#if 0
U032    hRes, vRes;
#endif

    status = RM_OK;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    TVmode = dacGetTVmode(pDev, Head);
    // Turn DAC on
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);   // subaddress
    status |= i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
    i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);
    tmrDelay(pDev, 20000000);   // delay 20 ms to allow DAC to power up. If we don't wait, check status could give wrong input.
    
    // Use Autoconfiguration for 871
    if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
        return dacProgramBrooktreeAuto(pDev, Head);

    // send an init string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
    strptr = (U008 *)&BT_Init;          // send init sequence
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    // Get pointers to the strings to write to the I2C controller.
    // One string sets the timing for a particular resolution.
    // The other string sets the position (centering).
    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
            strptr = (U008 *)Bt_NM[TVmode];
            strptr2 = (U008 *)Btc_NM[TVmode];
            break;
        case NTSC_J:
            strptr = (U008 *)Bt_NJ[TVmode];
            strptr2 = (U008 *)Btc_NJ[TVmode];
            break;
        case PAL_NC:
            strptr = (U008 *)Bt_NC[TVmode];
            strptr2 = (U008 *)Btc_NC[TVmode];
            break;
        case PAL_A:
            strptr = (U008 *)Bt_PA[TVmode];
            strptr2 = (U008 *)Btc_PA[TVmode];
            break;
        case PAL_M:
            strptr = (U008 *)Bt_PM[TVmode];
            strptr2 = (U008 *)Btc_PM[TVmode];
            break;
        case PAL_N:
            strptr = (U008 *)Bt_PN[TVmode];
            strptr2 = (U008 *)Btc_PN[TVmode];
            break;
        default:
            strptr = (U008 *)Bt_NM[TVmode];
            strptr2 = (U008 *)Btc_NM[TVmode];
            break;
    }
    // send a timing string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
//  Try autoconfigure modes
#if 0
        hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
        vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;
        if (hRes == 800)
        {
            strptr = (U008 *)&Bt_NM800;
        }
        if (hRes == 640)
        {
            strptr = (U008 *)&Bt_NM640;
        }
#endif
// end hack
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    // send a centering string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    for (i=0; *strptr2 != 0xff; i++)
    {
        Data = *strptr2++;
        if (i == 1) // second byte is H Offset, which differs between NV4 and NV5
        {
            if(IsNV4(pDev))
            {
                // NV4 timing 8-16 pixels different, generally
                if (TVmode <= TV_MODE_400x300)
                    Data -= 16;
                else
                    Data -= 8; 
                switch (TVmode)
                {
                    case TV_MODE_400x300:
                        if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                            Data = 0x31;
                        break;
                    case TV_MODE_640x480:                                           
                        if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                            Data = 0xa2;
                        break;
                    case TV_MODE_800x600:
                        if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                            Data = 0x22;
                        else
                            Data = 0xd8;
                        break;
                    case TV_MODE_320x200:
                        if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                            Data = 0xca;
                        break;
                }
            }
        }
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, Data);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    // Set Check Status bit to tell encoder to check for TV connected.
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT);   // set check stat
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // Set Estat to select status register 1
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);  // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x41);  // set estat (estat 01 + en_out)
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // Read Monitor Status bits
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));
    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &Data, 1);
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // Reset Check Status -- not documented, but very important (can't program encoder if not done).
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF);    // set check stat
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // Read registry to decide how to output on the S-video connector--do we use straight
    // S-video, or do we output composite?
    // DAC A is always composite out. DAC B and C are S-video (chroma and luma).
    // If the user has an S-video cable attached to a TV with composite input, we want
    // to output composite on the S-video (DAC C). We try to sense whether both 
    // B and C are loaded (S-video) or only C is loaded (composite).
    // Unfortunately, we may falsely detect composite even with an S-video monitor,
    // so the registry setting is necessary to override our detection.
    // Brooktree reg CE: D7  D6  D5  D4  D3  D2  D1  D0
    //                   MUX D   MUX C   MUX  B  MUX  A 
    // MUX n:   00 = output Video 0 on DAC n
    //          01 =              1
    //          10 =              2
    //          11 =              3
    // Our default init is 18 -- DAC A = mode 0, DAC B = mode 2, DAC C = mode 1
    // DAC A is always set to composite out (mode 0), which has a value of 0.
    switch (pDev->Dac.TVoutput)
    {
        case NV_CFG_VIDEO_OUTPUT_FORMAT_AUTOSELECT:
            if ((Data & BT_MONSTAT) == BT_MONSTAT_C)    // Stat A, B, C
            {
                // Set composite out on B if DAC C only is loaded.
                // Set DAC C to output composite.
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
                // mode 2 on DAC B,  mode 0 on DAC C
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_COMP | BT_OUT_MUX_C_COMP));
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            else
            {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
                // mode 2 on DAC B, mode 1 on DAC C
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL));    
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            break;
        case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_COMPOSITE:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_COMP | BT_OUT_MUX_C_COMP));   
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_SVIDEO:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL));    
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        default:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
    }

    // If no head is using TV, blank image.
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
        if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
            break;
    if (i == pDev->Dac.HalInfo.NumCrtcs)
        dacDisableTV(pDev, Head);

    return (status);
} // end of dacProgramBrooktree

//****************************************************************************************
//
//  Program the Chrontel device for a display mode
//  args:       internal TV mode
//  returns:    status word
static RM_STATUS dacProgramChrontel(PHWINFO pDev, U032 Head)
{    
    RM_STATUS status;
    U016    i;
    U008    *strptr, FsciReg, read;
    U032    hRes, vRes;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
   
    if (pDev->Dac.EncoderType == NV_ENCODER_NONE) 
    {
        // Used to check for known Chrontel types. Checking in dacinit now, this is probably useless.
        return ERR_I2C_UNKNOWN;
    }
    status = RM_OK;
    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence
    // Chrontel 7007 wants bit 7 of the register address set (on others it's a don't care).
        
    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // power up
    dacEnableTV(pDev, Head);
    
    // send an init string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    strptr = (U008 *)&CH_Init;     // send init sequence
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C

    // get a pointer to the string to write to the I2C controller
    status = dacGetI2CModeString(pDev, Head, hRes, vRes, &strptr);
    if (status)
    {
        // could not get the encoder string for this mode.
        return ERR_I2C_MODE;
    }
            
    // send a timing string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
//        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, " ", *strptr);
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C

    // send default flicker filter, brightness, and contrast
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr = (U008 *)&CH_FBC;
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    
    // Set register 21 for PAL/NTSC, and reg 3 for mode 24 (800x600 NTSC)
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    
    // Reg 3 bit 7 set for mode 24 only. (Flicker filter used in 7/10 scaling modes)
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); // 
    
    switch (pDev->Dac.TVStandard) // not supporting scaling on PAL. What happens on NTSC unscaled modes?
    {
        case NTSC_J:
        case NTSC_M:
            if ((hRes == 800) || (hRes == 720) || ((hRes == 640) && (vRes == 480)))
            {
                // 800x600 & 640x480 modes use programmed FSCI values (subcarrier frequency), others use subcarrier free-run
                // set carrier free-run bit in reg 6 and clear ACIV bit in reg 21

                // set carrier free-run bit
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
                read |= CH_CFR;                                             // set carrier freerun
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
                
                // Clear ACIV bit            
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); 
                
                if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 800) // mode 24 needs this bit set. What about modes 22 & 23?
                {
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x80); // 
                
                    strptr = (U008 *)&CH_FSCI_800x600;
                    FsciReg = CH_REG_18; // starting at reg 0x18
                    for (i=0; i<numFSCIbytes; i++) 
                    {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // reg
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  // FSCI value
                    }
                }
                if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 720) // mode 23
                {
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x80); // 
                
                    strptr = (U008 *)&CH_FSCI_720x576;
                    FsciReg = CH_REG_18; // starting at reg 0x18
                    for (i=0; i<numFSCIbytes; i++) 
                    {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // reg
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  // FSCI value
                    }
                }
                if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) // write FSCI
                {
                    strptr = (U008 *)&CH_FSCI_640x480;
                    FsciReg = CH_REG_18; // starting at reg 0x18
                    for (i=0; i<numFSCIbytes; i++) 
                    {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // 
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++); // 
                    }
                }
            }
            else    // Other NTSC modes use subcarrier free run
            {
                // set ACIV 
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, 0x01); // reg 21 bit 0 = 1 -> automatically increment subcarrier
                i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);                       // end state for I2C

                // clear carrier free-run bit when in ACIV mode
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head,  pDev->Dac.TVOutPortID, &read,1);
                i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);                       // 
                read &= ~CH_CFR;                                            // clear carrier freerun
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, read);  
            }
            break;
        case PAL_NC:
            // set carrier free-run bit
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
            read |= CH_CFR;                                             // set carrier freerun
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  

            // Clear ACIV bit            
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); 
            switch (hRes) 
            {
                case 640:
                case 320:
                    strptr = (U008 *)&CH_FSCI_640x480NC;
                break;
                case 720:
                    strptr = (U008 *)&CH_FSCI_720x576NC;
                break;
                case 800:
                case 400:
                    strptr = (U008 *)&CH_FSCI_800x600NC;
                break;
                default:
                    strptr = (U008 *)&CH_FSCI_640x480NC;    // 512x384 will fit in 640x480
            }
            FsciReg = CH_REG_18; // starting at reg 0x18
            for (i=0; i<numFSCIbytes; i++) 
            {
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // 
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++); // 
            }
            break;
        default:
        {
            // set ACIV 
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x01); // reg 21 bit 0 = 1 -> automatically increment subcarrier
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C

            // clear carrier free-run bit when in ACIV mode
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
            read &= ~CH_CFR;                                            // clear carrier freerun
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        }
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    
    // Set gain of DAC. Read/modify/write reg 4. NTSC-M and PAL-M use one level, all others use another level.
    switch (pDev->Dac.TVStandard) 
    {
        case NTSC_M:
        case PAL_M:
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            read &= CH_GAIN;                                            // set GAIN bits
            read |= CH_GAIN_NTSC;
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            break;
        }
        default:
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            read &= CH_GAIN;                                            // set GAIN bits
            read |= CH_GAIN_PAL;
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        }
    }
    // Default TV standards (in Chrontel reg 0) is 00 (PAL) or 01 (NTSC). There are 2 bits, so 4 combinations.
    // PAL B, D, G, H, I, N, NC = 00
    // NTSC-M                   = 01
    // PAL-M                    = 10
    // NTSC-J                   = 11
    
    // Set special TV standards
    if (pDev->Dac.TVStandard == NTSC_J) 
    {
        // NTSC-J should have reg 0[4:3] = 11
        // Read/Modify/Write reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        read |= CH_NTSC_J;                                          // set NTSC-J bits
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        
        // Brightness range for NTSC-J is wider
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_09); // reg 9
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_BL_J);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    
    }
    if (pDev->Dac.TVStandard == PAL_M) 
    {
        // PAL-M should have reg 0[4:3] = 10. 
        // Read/Modify/Write reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        read &= 0xe7;                                               // mask bits 4:3
        read |= CH_PAL_M;                                           // set PAL_M bits
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    }

    return (status);
} // end of dacProgramChrontel

//****************************************************************************************
RM_STATUS dacSendEncoderString(PHWINFO pDev, U032 Head, U008 *strptr, U016 len)
{
RM_STATUS status;
U016 i;

    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    for (i=0; i<len; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    return (status);
}

//****************************************************************************************
//
//  Program the Philips device for a display mode
//  args:       internal TV mode
//  returns:    status word
static RM_STATUS dacProgramPhilips(PHWINFO pDev, U032 Head)
{    
    RM_STATUS status;
    U032    hRes, vRes;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // Send the init strings
    // Each string is a block of consecutive registers, some blocks are unique to the TV standard.
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init0, Ph_Gen_Init0_Len);
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init1, Ph_Gen_Init1_Len);
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init2, Ph_Gen_Init2_Len);

    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
        case NTSC_J:
            // Do NTSC init
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_Init0, Ph_NTSC_Init0_Len);
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_Init1, Ph_NTSC_Init1_Len);
            // Program the resolution    
            switch (hRes)
            {
                case 320:
                case 640:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_640, Ph_NTSC_Res_Len);
                    break;        
                case 400:
                case 800:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_800, Ph_NTSC_Res_Len);
                    break;
                default:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_640, Ph_NTSC_Res_Len);
            }            
            break;        
        break;

        case PAL_M:
        case PAL_A:
        case PAL_N:
        case PAL_NC:
            // Do PAL init
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_Init0, Ph_PAL_Init0_Len);
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_Init1, Ph_PAL_Init1_Len);
            // Program the resolution    
            switch (hRes)
            {
                case 320:
                case 640:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_640, Ph_PAL_Res_Len);
                    break;        
                case 400:
                case 800:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_800, Ph_PAL_Res_Len);
                    break;
                default:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_640, Ph_PAL_Res_Len);
            }            
            break;
        break;
    }
    return (status);
} // end of dacProgramPhilips

//*************************** Exported functions *****************************************
//
//  Program the I2C device for a display mode
//  returns:    status word
RM_STATUS dacSetupTVEncoder(PHWINFO pDev, U032 Head)   
{
    RM_STATUS status;

    // Identify which part: Chrontel or Brooktree?
    // ID was done at dacInit.
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_NONE:
            status = ERR_I2C_UNKNOWN;
            break;                        
        case TV_ENCODER_BROOKTREE:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramBrooktree(pDev, Head);
            break;
        case TV_ENCODER_CHRONTEL:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramChrontel(pDev, Head);
            break;                        
        case TV_ENCODER_PHILIPS:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramPhilips(pDev, Head);
            break;                        
        default:
            status = ERR_I2C_UNKNOWN;
            break;                        
    }
    return (status);
}

RM_STATUS dacAdjustCRTC_CH(PHWINFO pDev, U032 Head)
{
    RM_STATUS status;
    U008    data, hbeAdjust;
    U016    data16;
    TV_ADJUST * adjustEntry;

    // Look up the array of CRTC adjustments for Chrontel
    status = dacGetTVAdjustTableEntry(pDev,Head,
                                      pDev->Framebuffer.HalInfo.HorizDisplayWidth,
                                      pDev->Framebuffer.HalInfo.VertDisplayWidth,
                                      &adjustEntry);
    if (status)
    {
        // did not find a match.
        return status;
    }
    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
        case NTSC_J:
        case PAL_M:
            if (pDev->Framebuffer.HalInfo.VertDisplayWidth != 576) {
            CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04, Head);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, adjustEntry->CR07, Head);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, adjustEntry->CR08, Head);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, adjustEntry->CR12, Head);
            if (IsNV4(pDev))    // NV4 timing is slightly different
            {
                if (pDev->Framebuffer.HalInfo.VertDisplayWidth == 240) 
                    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x60, Head);
                if  (pDev->Framebuffer.HalInfo.VertDisplayWidth == 300)
                    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x40, Head);
            }
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);      // read pixel format
            data |= adjustEntry->CR28;        // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((adjustEntry->SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
            }
            break;

        case PAL_A:
        case PAL_N:
        case PAL_NC:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04, Head);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, adjustEntry->CR07, Head);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, adjustEntry->CR08, Head);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, adjustEntry->CR12, Head);
            if (IsNV4(pDev))    // NV4 timing is slightly different
            {
                if ((pDev->Framebuffer.HalInfo.VertDisplayWidth == 200) ||
                    (pDev->Framebuffer.HalInfo.VertDisplayWidth == 240) ||
                    (pDev->Framebuffer.HalInfo.VertDisplayWidth == 300) ||
                    (pDev->Framebuffer.HalInfo.VertDisplayWidth == 384))
                    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x20, Head);
                if (pDev->Framebuffer.HalInfo.VertDisplayWidth == 480)
                    CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04 + 1, Head);
            }
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);      // read pixel format
            data |= adjustEntry->CR28;           // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((adjustEntry->SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
            break;
    }
    if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 320)
    {
        // adjust HBE = HT. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0
        pDev->Framebuffer.CursorAdjust = 8;
    }
    else
    {
        if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 400)
        {
            // 400x300
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);          // get CR28
            data &= ~0x38;
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (5<<3), Head); // bits[5:3] shift 5 pixels right        
            pDev->Framebuffer.CursorAdjust = 0;
            if (pDev->Dac.TVStandard == NTSC)   // PAL 400x300 requires special case for HBE for cursor position
                hbeAdjust = 4;
            else                
                hbeAdjust = 2;
        }
        else
        {
            pDev->Framebuffer.CursorAdjust = 5;
            hbeAdjust = 4;
        }
        // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
        CRTC_RD(NV_CIO_CRE_HEB__INDEX, data, Head);           // MS bit HT (CR2D)            
        if (data & 1)
            data16 |= 0x100;
        data16 += hbeAdjust;                            // HT effective
    
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0

        CRTC_RD(NV_CIO_CR_HRE_INDEX, data, Head);             // CR05
        data &= ~0x80;                                  // lose the HBE bit
        if (data16 & 0x20)
            data |= 0x80;
        CRTC_WR(NV_CIO_CR_HRE_INDEX, data, Head);             // HBE 5
                            
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, data, Head);            // CR25
        data &= ~0x10;
        if (data16 & 0x40)
            data |= 0x10;
        CRTC_WR(NV_CIO_CRE_LSR_INDEX, data, Head);            // HBE 6
    }
    // adjust normally scanline doubled modes which are not doubled for TV
    // (512x384 and 480x360)
    if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 512 ||   // 512x384
        pDev->Framebuffer.HalInfo.HorizDisplayWidth == 480)     // 480x360
    {
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40, Head);
    }
    if (!IsNV4(pDev))
        pDev->Framebuffer.CursorAdjust = 0; // cursor adjust not needed 

    return status;
}

RM_STATUS dacAdjustCRTC_BT(PHWINFO pDev, U032 Head)
{
RM_STATUS status = RM_OK;
U008    tvmode, data;
U016    data16;

        // Use the "TV mode number" lookup method
        tvmode = dacGetTVmode(pDev, Head);

        // adjust normally scanline doubled modes which are not doubled for TV
        if ((tvmode == TV_MODE_512x384) | (tvmode == TV_MODE_480x360))
            CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40, Head);

        if (tvmode <= TV_MODE_400x300)
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes

        // Horizontal adjustment is very simple: HT = HDE + 2, HRS = HDE + 1
        CRTC_RD(NV_CIO_CR_HDE_INDEX, data, Head);           // get HDE
        CRTC_WR(NV_CIO_CR_HRS_INDEX, data + 1, Head);       // write HRS
        if (tvmode == TV_MODE_400x300)  // 400x300 is a special case
            data += 1;
        else
            data += 2;
        CRTC_WR(NV_CIO_CR_HDT_INDEX, data, Head);   // write HT=DE+2
        
        // NV10 makes us do some more special casing. The reason is that the video overlay
        // syncs to the CRTC differntly. Instead of using display end, it syncs off the blank
        // signal, so we have to make an adjustment to HBE.
        // We'll also add offsets via PVIDEO_POINT_OUT (see class63 for NV10).
        if (IsNV10orBetter(pDev)) 
        {
            if (tvmode == TV_MODE_640x480)
            {
                CRTC_WR(NV_CIO_CR_HBE_INDEX, 0x95, Head);       // write HBE
                CRTC_WR(NV_CIO_CR_HRE_INDEX, 0x1F, Head);       // write HBE msb
            }
            if (tvmode == TV_MODE_800x600)
            {
                CRTC_WR(NV_CIO_CR_HBE_INDEX, 0x89, Head);       // write HBE
                CRTC_WR(NV_CIO_CR_HRE_INDEX, 0x9A, Head);       // write HBE msb
            }
        }
        // Vertical total must be adjusted per resolution
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
            case PAL_M:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_NTSC[ tvmode ], Head);
                break;              
            case PAL_A:
            case PAL_N:
            case PAL_NC:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_PAL[ tvmode ], Head);
                break;
            default:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_NTSC[ 0 ], Head);    // default to NTSC_M
        }
        if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
        {
            if (tvmode == TV_MODE_640x480)
            {
                // Adjust CRTC vertical
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x18, Head);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xF6, Head);
            }
            if (tvmode == TV_MODE_800x600)
            {
                // Adjust CRTC vertical
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xB6, Head);
            }
            if (tvmode == TV_MODE_1024x768)
            {
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x83, Head);
            }
        }
        if (tvmode == TV_MODE_480x360)  // a special case
        {
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xe806);     // VT
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xb207);     // extra bits
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x9010);     // VRS
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x6712);     // VDE
        }
        if (tvmode == TV_MODE_512x384)  // another special case
        {
            // On a monitor, the vertical is 768, scan doubled.
            // On the TV, we want 384.
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x7f12);     // VDE
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xb707);     // extra bits
        }
        // NV4 has a hw bug which requires adjustment to the cursor position
        if (IsNV4(pDev))
        {
            // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
            CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
            CRTC_RD(NV_CIO_CRE_HEB__INDEX, data, Head);           // MS bit HT (CR2D)            
            if (data & 1)
                data16 |= 0x100;
            data16 += 4;                                    // HT effective

            CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
            data &= ~0x1f;                                  // lose the HBE bits
            data |= (U008) data16 & 0x1F;
            CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0

            CRTC_RD(NV_CIO_CR_HRE_INDEX, data, Head);             // CR05
            data &= ~0x80;                                  // lose the HBE bit
            if (data16 & 0x20)
                data |= 0x80;
            CRTC_WR(NV_CIO_CR_HRE_INDEX, data, Head);             // HBE 5
                            
            CRTC_RD(NV_CIO_CRE_LSR_INDEX, data, Head);            // CR25
            data &= ~0x10;
            if (data16 & 0x40)
                data |= 0x10;
            CRTC_WR(NV_CIO_CRE_LSR_INDEX, data, Head);            // HBE 6
            switch (tvmode)
            {
                // modes which are shoehorned in to 640x400 need a horiz cursor adjustment
                case TV_MODE_512x384:
                case TV_MODE_480x360:
                // likewise 640 modes
                case TV_MODE_640x400:
                case TV_MODE_640x480:
                case TV_MODE_800x600:
                    pDev->Framebuffer.CursorAdjust = 5;
                    break;          
                default:
                    pDev->Framebuffer.CursorAdjust = 0;
            }
        }
        return status;
} 


RM_STATUS dacAdjustCRTC_PH(PHWINFO pDev, U032 Head)
{
    RM_STATUS status = RM_OK;

    // No tables. No formula. 
    switch (pDev->Framebuffer.HalInfo.HorizDisplayWidth)
    {
        case 320:
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x27, Head);   // CR0
            break;
        case 400:
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes
            break;
        case 640:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x52, Head);   // CR4
            break;
        case 800:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x6A, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x68, Head);   // CR4
            break;
        default:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x52, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x30, Head); // CR6
            break;
    }
    switch (pDev->Framebuffer.HalInfo.VertDisplayWidth)
    {
        case 200:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDE, Head); // CR6
            break;
        case 400:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDC, Head); // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head); // CR10 moves display down a few lines
            break;
        case 240:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x2C, Head); // CR6
            break;
        case 480:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x30, Head); // CR6
            break;
        case 600:
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xAC, Head); // CR6
            break;
    }
    switch (pDev->Dac.TVStandard )
    {
        case NTSC_M:
        case NTSC_J:
            break;        
        case PAL_M:
        case PAL_A:
        case PAL_N:
        case PAL_NC:
            if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 800)
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xa8, Head); // CR6
            break;    
    }
    return status;
}

RM_STATUS dacAdjustCRTCForTV(PHWINFO pDev, U032 Head)
{
    U008    data;

    // slave the CRTC clock to the encoder
    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x20, Head);     // if TV, we can fix low water mark at 20.
    CRTC_RD(0x33, data, Head);
    data &= 0xfe;       // slave to the TV encoder
    CRTC_WR(0x33, data, Head);

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
    data |= 0x80;       // slave mode
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

    //  fix up CRTC timing per encoder
    //  NOTE: Brooktree and Chrontel have incompatible CRTC and encoder tables.
    //  Until this is resolved, this code is going to be ugly.
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            dacAdjustCRTC_CH(pDev, Head);
            break;
        case TV_ENCODER_BROOKTREE: 
            dacAdjustCRTC_BT(pDev, Head);
            break;
        case TV_ENCODER_PHILIPS:
            dacAdjustCRTC_PH(pDev, Head);
            break;
        default:
            return RM_ERROR;
    }        
    // Fix the video scalar vertical on NV4. Also allows full range of cursor movement.
    if(IsNV4(pDev))
    {
        // adjust VBE = VT. This adjusts the position of the video scalar window.
        CRTC_RD(NV_CIO_CR_VDT_INDEX, data, Head);             // CR6
        // 7 bits of CR16 are used
        CRTC_WR(NV_CIO_CR_VBE_INDEX, data, Head);             // CR16
    }
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);              // get CR28
    data &= ~0x38;
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);              // clear the pixel shift 

    if (pDev->Framebuffer.HalInfo.HorizDisplayWidth <= 400)    // if clock doubling
    {
        // Clock doubled mode
//        DAC_REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, 0x01030700, Head);   
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB2);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB1);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB2);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB1);
        }
    }
    else
    {
        // Normal clock mode
//        DAC_REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, 0x10030700, Head);
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB1);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB1);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB1);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB1);
        }
    }
    // Set source of PCLK and VSCLK to be TV encoder
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _BOTH);
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _BOTH);
    }
    // setup the DAC as the master
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _MASTER, Head);
    return RM_OK;
} // end of dacProgramTV

// Chrontel and Brooktree tables are incompatible
// Until we have a uniform way to deal with this, we'll use the "mode number"
// method for Brooktree (ala release 2) and the table lookup for Chrontel.
// This function is for Brooktree only.
U008 dacGetTVmode(PHWINFO pDev, U032 Head)
{
U032    hRes, vRes;
U008    TVmode;
PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

        // Get resolution
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        
        // Assign a mode number based on the resolution
        switch (hRes)
        {
            case 320:
                if (vRes == 200)
                    TVmode = TV_MODE_320x200;
                else
                    TVmode = TV_MODE_320x240;
                break;
            case 400:
                TVmode = TV_MODE_400x300;
                break;
            case 480:
                TVmode = TV_MODE_480x360;
                break;
            case 512:
                TVmode = TV_MODE_512x384;
                break;
            case 640:
                if (vRes == 400)
                    TVmode = TV_MODE_640x400;
                else
                    TVmode = TV_MODE_640x480;
                break;
            case 800:
                TVmode = TV_MODE_800x600;
                break;
            case 720:
            case 704:
                TVmode = TV_MODE_DVD;
                break;
            case 1024:
                TVmode = TV_MODE_1024x768;
                break;
            default:
                TVmode = TV_MODE_640x480;
                break;
        }
        return TVmode;
}

//  Return the default register values for position, brightness, contrast and flicker filter.
VOID dacGetDefaultTVPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    EncoderId,
    U008    Default,
    U032    *encoderParms
)
{
    U008    Cr07, Cr25;
    U032    Hrs, Hre, Vrs, Vre;
    U008    TVmode;
    U032    hRes, vRes;
    U008   *strptr;
    RM_STATUS status;
        
    if (EncoderId & TV_ENCODER_BROOKTREE)
    {
        PARAMS_BROOKTREE *regsBt;
        BT_MODE_REGS *pReg;
        BT_INIT_REGS *pRegI;

        // Get default parameters from tables
        TVmode = dacGetTVmode(pDev, Head);
        regsBt = (PARAMS_BROOKTREE *)encoderParms;

        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
                strptr = (U008 *)Bt_NM[TVmode];
                break;
            case NTSC_J:
                strptr = (U008 *)Bt_NJ[TVmode];
                break;
            case PAL_NC:
                strptr = (U008 *)Bt_NC[TVmode];
                break;
            case PAL_A:
                strptr = (U008 *)Bt_PA[TVmode];
                break;
            case PAL_M:
                strptr = (U008 *)Bt_PM[TVmode];
                break;
            case PAL_N:
                strptr = (U008 *)Bt_PN[TVmode];
                break;
            default:
                strptr = (U008 *)Bt_NM[TVmode];
            break;
        }
        pReg = (BT_MODE_REGS *) strptr;
        regsBt->reg0x80 = pReg->reg0x80;
        regsBt->reg0x82 = pReg->reg0x82;
        regsBt->reg0x92 = pReg->reg0x92;
        regsBt->reg0x98 = pReg->reg0x98;
        regsBt->reg0x9A = pReg->reg0x9A;
        if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
            pRegI = (BT_INIT_REGS *) &BT871_Init;
        else
            pRegI = (BT_INIT_REGS *) &BT_Init;
        regsBt->reg0xC8 = pRegI->reg0xC8;
        regsBt->reg0xCA = pRegI->reg0xCA;
        regsBt->reg0xCC = pRegI->reg0xCC;

        // Construct Horizontal Retrace Start, End, and Vertical Retrace Start, End
        CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);

        // Construct Hrs
        CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);

        // Construct Hre
        CRTC_RD(NV_CIO_CR_HRE_INDEX, Hre, Head);
        Hre = Hrs + ( ((short)Hre - (short)Hrs) & BITS0_4 );

        // Construct Vrs
        CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
        if (Cr25 & BIT2)
            Vrs |= BIT10;
        if (Cr07 & BIT7)
            Vrs |= BIT9;
        if (Cr07 & BIT2)
            Vrs |= BIT8;

        // Construct Vre
        CRTC_RD(NV_CIO_CR_VRE_INDEX, Vre, Head);
        Vre = Vrs + ( ((short)Vre - (short)Vrs) & BITS0_3 );

        regsBt->HRetraceStart = Hrs;        
        regsBt->HRetraceEnd = Hre;      
        regsBt->VRetraceStart = Vrs;        
        regsBt->VRetraceEnd = Vre;      
    }
    if (EncoderId & TV_ENCODER_CHRONTEL)
    {
        PARAMS_CHRONTEL *regsCh;
        PCH_string  pReg;

        regsCh = (PARAMS_CHRONTEL *)encoderParms;

        hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
        vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;
        status = dacGetI2CModeString(pDev, Head, hRes, vRes, &strptr);
        pReg = (PCH_string) strptr;
        if (status)
        {
            regsCh->reg0x0A = 0;
            regsCh->reg0x0B = 0;
        }
        else
        {
            regsCh->reg0x0A = pReg->data0x0A;
            regsCh->reg0x0B = pReg->data0x0B;
        }
        regsCh->reg0x08 = 0x00;
        regsCh->reg0x09 = 0x7f;
        regsCh->reg0x11 = 0x03;
        if (EncoderId == NV_ENCODER_CHRONTEL_7003)
            regsCh->reg0x01 = 0x03;
        else
            regsCh->reg0x01 = 0x29;
    }
}
//  Write TV encoder positioning registers, as well as contrast, brightness, flicker filter
//  For Brooktree positioning, we must change the CRTC's also.
VOID dacSetTVPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    *encoderParms
)
{
    U008 Adr, Data, Device, lock;
    NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Parms = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *) encoderParms;

    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    if (TV_ENCODER_FAMILY(Parms->Encoder_ID) == TV_ENCODER_BROOKTREE)
    {
        // Write CRTC values (we can use the monitor position function)
        dacSetMonitorPosition(pDev, Head, Parms->u.regsBt.HRetraceStart, Parms->u.regsBt.HRetraceEnd,
                                Parms->u.regsBt.VRetraceStart, Parms->u.regsBt.VRetraceEnd);

        Data = Parms->u.regsBt.reg0x80;
        Adr = 0x80;
        Device = (U008)(pDev->Dac.EncoderID >> 1);
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x82;
        Adr = 0x82;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x92;
        Adr = 0x92;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x98;
        Adr = 0x98;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x9A;
        Adr = 0x9a;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xC8;
        Adr = 0xc8;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xCA;
        Adr = 0xca;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xCC;
        Adr = 0xcc;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
    } else if (TV_ENCODER_FAMILY(Parms->Encoder_ID) == TV_ENCODER_CHRONTEL)
    {
        // Chrontel is positioned completely thru the encoder
        Data = Parms->u.regsCh.reg0x01;
        Adr = 0x01;
        Device = (U008)(pDev->Dac.EncoderID >> 1);
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x08;
        Adr = 0x08;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x09;
        Adr = 0x09;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x0A;
        Adr = 0x0A;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x0B;
        Adr = 0x0B;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x11;
        Adr = 0x11;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
    }
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}


//  Return the default TV mode stored in the bios.
RM_STATUS dacGetBiosDefaultTVType
(
    PHWINFO pDev,
    U032    *biostvdefault
)
{
 
   U008  data, lock;
   U032  Head = 0;  // BIOS knows only about head 0

   lock = ReadCRTCLock(pDev, Head);

   CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);

   CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data, Head); 

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

   *biostvdefault = data & 0x07;

   return(RM_OK);
}
        
//  Detect TV encoder 
//  Find the encoder ID (i2c address) and the type (maker and version) and save in the pDev dac structure.
VOID    dacDetectEncoder
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    lock, ack, read, retry;

    // see if we have a TV encoder, and what type it is.
    // Identify which part: Chrontel or Brooktree? There are 2 possible ID's for each part
    // Unlock CRTC extended regs
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);

    if (IsNV4(pDev) && Head == 0)   // TV and CRT share the i2c port
        EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);   // this will stop the CRT from driving DDC1 data on the bus

    i2cInit(pDev, Head, pDev->Dac.TVOutPortID);

    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x8A);     // is it Brooktree?
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }
    if (ack == 0) { // We got a response, so this must be our device
        pDev->Dac.EncoderID = 0x8A;
        pDev->Dac.EncoderType = TV_ENCODER_BROOKTREE;
    } else {    // Not address 8A, try alternate
        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x88); // Brooktree alt address
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        }
        if (ack == 0) { // We got a response, so this must be our device
            pDev->Dac.EncoderID = 0x88;
            // Differentiate between Brooktree and Philips
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1C); // Philips ID reg
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID); // Start w/o Stop = Restart
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            if (ack) 
                pDev->Dac.EncoderType = TV_ENCODER_BROOKTREE;
            else
            {
                pDev->Dac.EncoderType = TV_ENCODER_PHILIPS; // generic ID
                switch (read) 
                {
                    case 0x02:
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7102;
                        break;    
                    case 0x03:
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7103;
                        break;    
                }
                // If there is a decoder on the chip, then it is considered to be a 7108 or 7109
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x40); // 7114 decoder address    
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                if (ack == 0) 
                {
                    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7102) 
                    {
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7108;
                    }
                    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7103) 
                    {
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7109;
                    }
                }
            }
        } else {    // Not Brooktree
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xEA); // is it Chrontel?
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            if (ack == 0) { // We got a response, so this must be our device
                pDev->Dac.EncoderID = 0xEA;
                pDev->Dac.EncoderType = TV_ENCODER_CHRONTEL;
            } else {    // Try alternate Chrontel address
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xEC); // try Chrontel alt address
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
                if (ack == 0) { // We got a response, so this must be our device
                    pDev->Dac.EncoderID = 0xEC;
                    pDev->Dac.EncoderType = TV_ENCODER_CHRONTEL;
                } else {
                    pDev->Dac.EncoderType = NV_ENCODER_NONE;
                }
            }
        }
    }

    // if the part responded to the Chrontel address, check subaddress
    // we may have another Chrontel part (7002?)
    if (pDev->Dac.EncoderType == TV_ENCODER_CHRONTEL)
    {
        // See what BIOS booted to.
        if (dacGetBiosDisplayType(pDev, Head) == DISPLAY_TYPE_TV)  // H
            // Temporarily set DisplayType to TV. This prevents the BIOS from hanging when
            // it gets called to do a modeset, because TVConnectStatus will turn off the encoder
            // if its not the current display. The correct display type will be set later.
            // If the VCLK is coming from the encoder, we must not turn it off.

            SETDISPLAYTYPE(pDev, Head, DISPLAY_TYPE_TV);

        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        }
        if ((ack != 0) || (i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x25))) // 25 = version register
        {
            pDev->Dac.EncoderType = NV_ENCODER_NONE;                    
        }
        else
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            if (ack)    // if read failed, the reg doesn't exist, probably 7002
            {
                pDev->Dac.EncoderType = NV_ENCODER_NONE; 
            }
            else
            {
                switch (read & 0xFF)
                {
                    case 0x00:  // 7003 according to spec
                    case 0x01:  // 7003 observed
                    case 0x02:  // 7003B
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7003;
                        break;
                    case 0x30:  // 7004A  From Chrontel, their data sheets are incorrect.
                    case 0x31:  // 7004B
                    case 0x32:  // 7004C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7004;
                        break;
                    case 0x38:  // 7005A
                    case 0x39:  // 7005B
                    case 0x3a:  // 7005C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7005;
                        break;
                    case 0x28:  // 7006A
                    case 0x29:  // 7006B
                    case 0x2A:  // 7006C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7006;
                        break;
                    case 0x50:  // 7007
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7007;
                        break;
                    case 0x40:  // 7008
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7008;
                        break;
                    default:    // 7002 should return FF
                        pDev->Dac.EncoderType = NV_ENCODER_NONE;
                        break;
                }
            }
        }
    }

    // if Brooktree, identify which variety
    if (pDev->Dac.EncoderType == TV_ENCODER_BROOKTREE)
    {
        // Select ETSTAT 0 to read back the ID (868 or 869)
        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        }
        if (ack == 0) {
            ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);   // subaddress
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x01);   // set estat (estat 0 + en_out)
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        if (ack == 0) {
            // Do the readback
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));     // start readback
            }
            if (ack == 0) {
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        }

        if (ack) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Error in I2C while identifying TV encoder\n\r");
            pDev->Dac.EncoderType = NV_ENCODER_NONE;                    
        } else {
            // Check upper 3 bits: 000 if 868, 001 if 869
            switch (read & 0xe0) {
                case 0:
                    pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_868;
                    break;
                case 0x20:
                    pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_869;
                    break;
                case 0x60:
                    pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_871;
                    break;
                default:
                    pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_868;
            }
        }
    }                
      
    //
    // Relock if necessary
    //
    RestoreLock(pDev, Head, lock);            
}

VOID
dacDisableTV
(
    PHWINFO pDev,
    U032 Head
)
{
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        EnableHead(pDev, Head);
        AssocDDC(pDev, Head);
    }
    
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // power down to blank screen
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                    // start state for I2C
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E);      // PM register 
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_OFF);         // power down (+ reset high)  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
            break;
        case TV_ENCODER_BROOKTREE:
            // Turn DAC off
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_OFF);    // DAC OFF
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        case TV_ENCODER_PHILIPS:
            dacTVReadModifyWrite(pDev, Head, PH_STDCTL, PH_DAC_OFF, PH_DAC_POWER);
            break;
        case TV_ENCODER_NONE:
        default:
            // what can we do?
            break;
    }
            
    // Leave Head 0 enabled (in Win9x, the BIOS always expects head 0 to be enabled, so in situations such as shutdown
    // or DOS full screen, we can hang if leave it pointing to head 1.
    if (IsNV11(pDev)) 
    {
        if ((pDev->Chip.BiosRevision & 0xFF0000FF) < 0x03000020)
            EnableHead(pDev, 0);    
    }

}

VOID
dacEnableTV
(
    PHWINFO pDev,
    U032 Head
)
{
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        EnableHead(pDev, Head);
        AssocDDC(pDev, Head);
    }
    
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // power up DAC
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                // start state for I2C
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E);  // PM register 
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_ON);      // power on (+ reset high)  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                 // end state for I2C
            break;
        case TV_ENCODER_BROOKTREE:
            // Turn DAC on
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        case TV_ENCODER_PHILIPS:
            dacTVReadModifyWrite(pDev, Head, PH_STDCTL, PH_DAC_ON, PH_DAC_POWER);
            break;
        case TV_ENCODER_NONE:
        default:
            // what can we do?
            break;
    }
            
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\dacmode.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC Mode Control ***************************\
*                                                                           *
* Module: DACMODE.C                                                         *
*   The DAC mode control management is updated here.                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include <bios.h>   //For hotkey defs.  Can remove once those are put in nv_ref.h


//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
U008 CompatColors[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
                        0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F};
                         
//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
U008 GrayColors[] = {0x00, 0x05, 0x08, 0x0B, 0x0E, 0x11, 0x14, 0x18,
                      0x1C, 0x20, 0x24, 0x28, 0x2D, 0x32, 0x38, 0x3F};
                                                                              
//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
U008 FixupColors[] = {0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28,
                       0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F};
                                                                       
//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
U008 IntenseTable[] =
{
    0x00, 0x10, 0x1F, 0x2F, 0x3F,
    0x1F, 0x27, 0x2F, 0x37, 0x3F,
    0x2D, 0x31, 0x36, 0x3A, 0x3F,
                                
    0x00, 0x07, 0x0E, 0x15, 0x1C,
    0x0E, 0x11, 0x15, 0x18, 0x1C,
    0x14, 0x16, 0x18, 0x1A, 0x1C,
                                
    0x00, 0x04, 0x08, 0x0C, 0x10,
    0x08, 0x0A, 0x0C, 0x0E, 0x10,
    0x0B, 0x0C, 0x0D, 0x0F, 0x10
};                              

//
// KJK I suspect this could be removed (or at least shortened) since we only used
//      one of the mode settings
//

//------------------------------------------------------------------------
//  Basic VGA mode default settings. This setup is used initially in all 
//  mode sets.
//
VGATBL   VGATable =
{
    // U008   columns;
    // U008   rows;
    // U008   char_height;
    // U016   RegenLenght;
    // SEQ    seq_regs;              // SR1-4
    // U008   PT_Misc;               // Misc Register
    // CRTC   crtc_regs;             // CR0-18
    // U008   PT_ATC[20];            // Attribute Controller
    // GR     gr_regs;               // GR0-8

    // Basic CRTC Table for Packed Pixel Graphics Modes.
     0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},               // Seq
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,    // CR0-18
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,    // Attr
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00,
     0x0F, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,    // GR
     0x05, 0x0F, 0xFF}
};    

/*************************** Helper functions *******************************/
//
//       dacWriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
static VOID dacWriteColor(PHWINFO pDev, U032 head, U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write
    
    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component
        
        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;
    
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, color, head);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}        
        
//
//       dacWriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
static VOID dacWriteColor2(PHWINFO pDev, U032 head, U016 red, U016 green, U016 blue, U016 tblidx)
{
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red], head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green], head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue], head);

    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       dacLoadColorDACTable - Load the DAC for the 16-color modes
//
static VOID dacLoadColorDACTable(PHWINFO pDev, U032 head)
{
    U008  i;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
    ////WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        dacWriteColor(pDev, head, i);
        
}
    
//
//       dacLoadColor256DAC - Load the DAC for the 256-color modes
//
static VOID dacLoadColor256DAC(PHWINFO pDev, U032 head)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
    ////WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        dacWriteColor(pDev, head, CompatColors[i]);
    
    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }                                                
        
    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //
    
    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {                       
    
        // I know these could probably be a function, but for now...
        // (this is getting tedious).
        
        // Traverse(blue, red);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            red++;                                          
        } while (red < blue);
        
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            blue--;
        } while (blue);
        
        // Traverse(red, green);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            green++;
        } while (green < red);
                         
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            red--;
        } while (red);
                 
            
        // Traverse(green, blue);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            blue++;
        } while (blue < green);
                         
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            green--;
        } while (green);
    }                
             
    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, 0x00, head);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);
}

//
//       dacLoadIdentityDAC - Load the DAC with a gamma ramp
//
static VOID dacLoadIdentityDAC(PHWINFO pDev, U032 head)
{
    U016  i;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
                                                  
    for (i = 0; i < 256; i++)
    {           
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        
    }                                     
}

//
// Program the default video palette
//
static VOID dacLoadPalette
(
    PHWINFO pDev,
    U032    Head,
    U032    PixelDepth
)
{
    U008 i;
    U008 *pal = (U008 *)&(VGATable.PT_ATC); // default packed pixel palette
    volatile U008 scratch8;
    
    scratch8 = REG_RD08(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    
    for (i = 0; i < 20; i++)
    {
        ATR_WR(i, *pal++, Head);               
        
        ////WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        ////WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }
                                                
    scratch8 = REG_RD08(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);        // Reset ATC FlipFlop
    
//    DAC_WR08(NV_PRMCIO_ARX, 0x14);   // Select AR14
//    DAC_WR08(NV_PRMCIO_ARX, 0x00);   // Zero it!
    ATR_WR(0x14, 0, Head);                 // Write 0 to AR14
    DAC_REG_WR08(NV_USER_DAC_PIXEL_MASK, 0xFF, Head);      // Write DAC Mask

    ////WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    ////WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!
    ////WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask

#ifdef MACOS9
// We don't write the palette on the Mac; its already been set
//   to their own style of LUT and these default just cause flashing
#else
    switch(PixelDepth)
    {
        case    4:          // 4bpp - Planar -- CAN'T HAPPEN IN WINDOWS DRIVER
            dacLoadColorDACTable(pDev, Head);
            break;

        case    8:          // 8bpp - Packed
            dacLoadColor256DAC(pDev, Head);
            break;

        case    16:         // 16bpp - Packed
        case    15:         // 16bpp - Packed
        case    24:
        case    32:
        default:
            dacLoadIdentityDAC(pDev, Head);
            break;
    }
#endif // ! MACOS9
}

static VOID dacLoadIndexRange(PHWINFO pDev, U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;
    
    // Program <addr> register from <st_idx> to <st_idx + count>, using data from <regs>
    for (i = 0; i < count; i++)
    {               
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }               
}                                  



//
// Program the default sequencer/graphics controller parameters
// PRMVIO for head 2 is accessed by setting CR44.
//
static VOID dacProgramSeq
(
    PHWINFO pDev,
    U032    Head
)
{
    U016  wv;
    
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset
    
    REG_WR08(NV_PRMVIO_MISC__WRITE, VGATable.PT_Misc);
                                                   
    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    dacLoadIndexRange(pDev, NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(VGATable.seq_regs));
                                            
    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset
                                  
    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    dacLoadIndexRange(pDev, NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(VGATable.gr_regs));

    //
    // Common area of OEMSetRegs()
    //
    
    // User select MNP for VPLL, enable CPU access to FB, enable CGA I/O space.
    REG_WR08(NV_PRMVIO_MISC__WRITE, 0x2B);
                                                                  
    wv = 0x01;
    wv <<= 8;
    wv |= 0x01;
    WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01
    
}

//
// Program the CRTC timing (plus PRAMDAC_GENERAL_CONTROL and MISC OUTPUT sync polarities)
//
static VOID dacProgramCRTC
(
    PHWINFO pDev,
    U032    Head,
    U032    HorizontalVisible,        // in pixels
    U032    HorizontalBlankStart,     // in pixels
    U032    HorizontalRetraceStart,   // in pixels
    U032    HorizontalRetraceEnd,     // in pixels
    U032    HorizontalBlankEnd,       // in pixels
    U032    HorizontalTotal,          // in pixels
    U032    VerticalVisible,          // in lines
    U032    VerticalBlankStart,       // in lines
    U032    VerticalRetraceStart,     // in lines
    U032    VerticalRetraceEnd,       // in lines
    U032    VerticalBlankEnd,         // in lines
    U032    VerticalTotal,            // in lines
    U032    PixelDepth,
    U032    PixelClock,
    U032    HorizontalSyncPolarity,
    U032    VerticalSyncPolarity,
    U032    DoubleScannedMode
)
{
    U032 logicalwidth;
    
    U032 ramDacControl;
    U008 val08;
    U016 LC;

    // Here is how these timing values map to nv registers.
    // 
    // HorizontalTotal[8]           -> cr2D[0]  (# of characters - 5)
    // HorizontalTotal[7:0]         -> cr0[7:0] (# of characters - 5)
    // HorizontalVisible[8]         -> cr2D[1]  (in characters - 1)
    // HorizontalVisible[7:0]       -> cr1[7:0] (in characters - 1)
    // HorizontalBlankStart[8]      -> cr2D[2]  (in characters - 1)
    // HorizontalBlankStart[7:0]    -> cr2[7:0] (in characters - 1)
    // HorizontalBlankEnd[6]        -> cr25[4]
    // HorizontalBlankEnd[5]        -> cr5[7]
    // HorizontalBlankEnd[4:0]      -> cr3[4:0]
    // HorizontalRetraceStart[8]    -> cr2D[3]  (in characters + 1)
    // HorizontalRetraceStart[7:0]  -> cr4[7:0] (in characters + 1)
    // HorizontalRetraceEnd         -> cr5[4:0] (RetraceStart + pulseWidth = value programmed in this register)
    // VerticalVisible[10]          -> cr25[1]
    // VerticalVisible[9]           -> cr7[6]
    // VerticalVisible[8]           -> cr7[1]
    // VerticalVisible[7:0]         -> cr12[7:0]
    // VerticalBlankStart[10]       -> cr25[3]
    // VerticalBlankStart[9]        -> cr9[5]
    // VerticalBlankStart[8]        -> cr7[3]
    // VerticalBlankStart[7:0]      -> cr15[7:0]
    // VerticalRetraceStart[10]     -> cr25[2]
    // VerticalRetraceStart[9]      -> cr7[7]
    // VerticalRetraceStart[8]      -> cr7[2]
    // VerticalRetraceStart[7:0]    -> cr10[7:0]
    // VerticalRetraceEnd           -> cr11[3:0] (RetraceStart + pulseWidth = value programmed in this register)
    // VerticalBlankEnd             -> cr16
    // VerticalTotal[10]            -> cr25[0]
    // VerticalTotal[9]             -> cr7[5]
    // VerticalTotal[8]             -> cr7[0]
    // VerticalTotal[7:0]           -> cr6[7:0] (#of scanlines - 2)
    // PixelDepth                   -> cr13 (logical display width)
    //                              -> NV_PRAMDAC_GENERAL_CONTROL
    //                              -> cr28[1:0]
    // PixelClock                   -> NV_PRAMDAC_VPLL_COEFF
    // HorizontalSyncPolarity       -> NV_PRMVIO_MISC__WRITE[6]
    // VerticalSyncPolarity         -> NV_PRMVIO_MISC__WRITE[7]
    // DoubleScannedMode            -> cr9[7]
    //

    // Program up the basic registers first
    //
    
    //
    // Although the VGA spec is not clear on this, there is a single implicit line delay in the VRS and VRE
    // signals, so preadjust these values.
    //
    VerticalRetraceStart--;
    VerticalRetraceEnd--;
    
    // Line compare register is used to split the screen in half. We don't support this feature.
    // So the Line Compare register value is always 0x3ff.
    LC = 0x3ff;

    if (DoubleScannedMode)
    {
        // The verticalVisible and verticalBlankStart need to be doubled. 
        // The rest of the vertical timing modes are already doubled in the table.
        VerticalVisible *= 2;
        VerticalBlankStart *= 2;
    }

    //
    // CR0 (Horizontal Total) 
    //  Total number of horizontal characters in a scan line - 5
    //  Maximum horizontal resolution is 260 * 8 * (0.8), where (0.8) is visible %
    //
    CRTC_WR(NV_CIO_CR_HDT_INDEX, (U008)(HorizontalTotal >> 3) - 5, Head);
    
    //
    // CR1 (Horizontal Display End)
    //  Total number of displayed characters in a scan line - 1
    //
    CRTC_WR(NV_CIO_CR_HDE_INDEX, (U008)(HorizontalVisible >> 3) - 1, Head);
                   
    //
    // CR2 (Horizontal Blanking Start)
    //  Location where the horizontal blanking will start (in characters)
    //
    CRTC_WR(NV_CIO_CR_HBS_INDEX, (U008)((HorizontalBlankStart >> 3) - 1), Head);                   
        
    //
    // CR3 (Horizontal Blanking End)
    //  [7:7] CR (must be 1)
    //  [6:5] Display skew control (should be 0)
    //  [4:0] least significant 5 bits of Horizontal blanking end value (in characters).
    //
    CRTC_WR(NV_CIO_CR_HBE_INDEX, (U008)(((HorizontalBlankEnd >> 3) - 1) & 0x1F) | BIT(7), Head);
                   
    //
    // CR4 (Horizontal Retrace Start)
    //  Character position where the horizontal Retrace becomes active
    //
    CRTC_WR(NV_CIO_CR_HRS_INDEX, (U008)(HorizontalRetraceStart >> 3) + 1, Head);
                   
    //
    // CR5 (Horizontal Retrace End)
    //  [7:7] Bit6 of HBE (CR3)
    //  [6:5] Display skew control (should be 0)
    //  [4:0] Location of the end of the horizontal retrace period (in characters)
    //
    CRTC_WR(NV_CIO_CR_HRE_INDEX, ((U008)(((HorizontalRetraceEnd >> 3) + 1) & 0x1f))
                               | ((((HorizontalBlankEnd >> 3) - 1) & BIT(5)) ? BIT(7) : 0), Head);

    //
    // CR6 (Vertical Total)
    //  Total number of vertical scan lines on the monitor - 2
    //
    CRTC_WR(NV_CIO_CR_VDT_INDEX, (U008)((VerticalTotal - 2) & 0xFF), Head);
                   
    //
    // CR7 (Overflow Register)
    //  [7:7] Bit9 of VRS (CR10)
    //  [6:6] Bit9 of VDE (CR12)
    //  [5:5] Bit9 of VTR (CR6)
    //  [4:4] Bit8 of LC (CR18) 
    //  [3:3] Bit8 of VBS (CR15)
    //  [2:2] Bit8 of VRS (CR10)
    //  [1:1] Bit8 of VDE (CR12)
    //  [0:0] Bit8 of VTR (CR6)
    //
    CRTC_WR(NV_CIO_CR_OVL_INDEX, ((VerticalRetraceStart & BIT(9))     ? BIT(7) : 0x00)
                               | (((VerticalVisible - 1) & BIT(9))    ? BIT(6) : 0x00) 
                               | (((VerticalTotal - 2) & BIT(9))      ? BIT(5) : 0x00)
                               | ((LC & BIT(8))                       ? BIT(4) : 0x00)
                               | (((VerticalBlankStart - 1) & BIT(8)) ? BIT(3) : 0x00)
                               | ((VerticalRetraceStart & BIT(8))     ? BIT(2) : 0x00)
                               | (((VerticalVisible - 1) & BIT(8))    ? BIT(1) : 0x00)
                               | (((VerticalTotal - 2) & BIT(8))      ? BIT(0) : 0x00), Head);
                   
    //
    // CR8 (Screen A preset row scan)
    //  Should be set to 0 for us.
    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0, Head);

    //
    // CR9 (Character Cell Height register)
    //  [7:7] Scan double mode
    //  [6:6] Bit9 of LC (CR18) 
    //  [5:5] Bit9 of VBS (CR15)
    //  [4:0] Scan lines per character row - 1
    //
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, ((DoubleScannedMode)                 ? BIT(7) : 0x00)
                                   | ((LC & BIT(9))                       ? BIT(6) : 0x00)
                                   | (((VerticalBlankStart - 1) & BIT(9)) ? BIT(5) : 0x00), Head);
                 
    //
    // CR0C/CR0D (Start Address)
    //
    CRTC_WR(NV_CIO_CR_SA_HI_INDEX, 0, Head);                 
    CRTC_WR(NV_CIO_CR_SA_LO_INDEX, 0, Head);                 
                 
    //
    // CR10 (Vertical Retrace Start)
    //  Line position of the vertical Retrace start
    //
    CRTC_WR(NV_CIO_CR_VRS_INDEX, (U008)(VerticalRetraceStart & 0xFF), Head);
                   
    //
    // CR11 (Vertical Retrace End)
    //  [7:7] WriteProtect for CR0-7
    //  [6:6] Reserved (Bandwidth)
    //  [5:5] Vertical Interrupts (0)
    //  [4:4] Clear Vertical Interrupt (0)
    //  [3:0] Vertical Retrace End Width
    //
    CRTC_WR(NV_CIO_CR_VRE_INDEX, (U008)(VerticalRetraceEnd & 0x0f), Head); 
                               
    //
    // CR12 (Vertical Display End)
    //  Total number of displayed lines - 1
    //
    CRTC_WR(NV_CIO_CR_VDE_INDEX, (U008)((VerticalVisible - 1) & 0xFF), Head);
    
    //
    // CR13 (Logical Display Width)
    //  Display Pitch
    //  The value written to CR13/CR19 is the number 8-byte chunks
    //
    logicalwidth = pDev->Dac.DisplayPitch >> 3;
    CRTC_WR(NV_CIO_CR_OFFSET_INDEX, logicalwidth & 0xFF, Head);
    
    //
    // CR14 (Underline Location)
    //  Double Word mode
    //  Bit 6 is set in some VGA modes to change CRTC addressing
    //
    CRTC_WR(NV_CIO_CR_ULINE_INDEX, 0, Head);
    
    //
    // CR14 (Underline Location)
    //  Double Word mode
    //  Bit 6 is set in some VGA modes to change CRTC addressing into framebuffer
    //
    CRTC_WR(NV_CIO_CR_ULINE_INDEX, 0, Head);
    
    //
    // CR15 (Vertical Blank Start)
    //  Scan line value where the vertical blanking begins
    //
    CRTC_WR(NV_CIO_CR_VBS_INDEX, (U008)((VerticalBlankStart - 1) & 0xFF), Head);
    
    //
    // CR16 (Vertical Blank End)
    //  Scan line value where the vertical blanking Ends
    //
    CRTC_WR(NV_CIO_CR_VBE_INDEX, (U008)((VerticalBlankEnd - 1) & 0xFF), Head);

    //
    // CR17 (Mode register)
    //  bit 7 - retrace enable, bits 1,0 - memory addressing
    CRTC_RD(NV_CIO_CR_MODE_INDEX, val08, Head);
    CRTC_WR(NV_CIO_CR_MODE_INDEX, val08 | BIT(7) | BIT(1) | BIT(0), Head);

    //
    // CR18 (Line Compare Register)
    //  Bits 7:0 of the line compare value
    //  This is useful only when we want to split the screen. We just program this to 0x3ff
    //
    CRTC_WR(NV_CIO_CR_LCOMP_INDEX, (U008)(LC & 0xFF), Head);

    //
    // CR19 (Repaint control register 0)
    //  [7:5] Bits 10:8 of CRTC Offset register (CR13)
    //
    CRTC_WR(NV_CIO_CRE_RPC0_INDEX, (U008)(((logicalwidth & 0x700) >> 8) << 5), Head);

    //
    // CR1a (Repaint control register 1)
    //  [2] large screen bit. 
    //  NOTE: The manual says bit 2 should be set to 1 for modes < 1280x1024 and 
    //        0 for modes >= 1280x1024. However, that is not correct according to Peter Tong.
    //        It should be set to 0 for all non-vga modes (CR28).
    //          Safer to follow the original meaning of this bit.
    //  The rest of the bits are constant for all modes.
    //
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, ((VerticalVisible < 1024) && (HorizontalVisible < 1280)) ? 0x3c : 0x38, Head);

    //
    // CR1c (Enhancement Register)
    //  This is a constant 0x1c for us.
    if (IsNV11(pDev)) {
        CRTC_WR(NV_CIO_CRE_ENH_INDEX, 0x3c, Head);
    } else {
        CRTC_WR(NV_CIO_CRE_ENH_INDEX, 0x1c, Head);
    }

    // Cr25 (Overflow register)
    //  [5:5] Bit 11 of CRTC offset register (this is 0)
    //  [4:4] Bit 6 of Horizontal Blanking End 
    //  [3:3] Bit 10 of Vertical Blank Start
    //  [2:2] Bit 10 of Vertical Retrace Start
    //  [1:1] Bit 10 of Vertical Display End
    //  [0:0] Bit 10 of Vertical Total
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, ((((HorizontalBlankEnd >> 3) - 1) & BIT(6)) ? BIT(4) : 0x00)
                                | (((VerticalBlankStart - 1) & BIT(10))       ? BIT(3) : 0x00)
                                | ((VerticalRetraceStart & BIT(10))           ? BIT(2) : 0x00)
                                | (((VerticalVisible - 1) & BIT(10))          ? BIT(1) : 0x00) 
                                | (((VerticalTotal - 2) & BIT(10))            ? BIT(0) : 0x00), Head);

    // 
    // CR28 (Pixel Format Register)
    //  [1:0] Pixel depth encoded as:
    //        0 - VGA
    //        1 - 8bpp
    //        2 - 16bpp
    //        3 - 32bpp

    // Also set PRAMDAC_GENERAL_CONTROL register. ALT_MODE field depends on the pixel depth. The rest
    // of the fields are the same for all pixel depths.
    
    ramDacControl = DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIXMIX,      _ON) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _VGA_STATE,   _SEL) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BLK_PEDSTL,  _OFF) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _TERMINATION, _37OHM) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC,         _8BITS) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _DAC_SLEEP,   _DIS) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PALETTE_CLK, _EN);
        
    switch (PixelDepth)
    {
        case 8:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _NOTSEL);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_8BPP, Head);    
            break;                
        
        case 15:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _15);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_16BPP, Head);    
            break;                
        
        case 16:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _16);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_16BPP, Head);    
            break;                
        
        case 24:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _24);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_32BPP, Head);    
            break;                
        
        case 32:        
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _30);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_32BPP, Head);    
            break;                
    } // switch on pixel depth       

    DAC_REG_WR32(NV_PRAMDAC_GENERAL_CONTROL, ramDacControl, Head);

    // 
    // cr2D (Horizontal Extra Bits Register)
    //  [5] Bit 23 of start address field (This is 0 for us)
    //  [4] Bit 8 of interlace half field start (This is 0 for us)
    //  [3] Bit 8 of Horizontal Retrace Start
    //  [2] Bit 8 of Horizontal Blank Start
    //  [1] Bit 8 of Horizontal Display End
    //  [0] Bit 8 of Horizontal Total
    CRTC_WR(NV_CIO_CRE_HEB__INDEX, ((((HorizontalRetraceStart >> 3) + 1) & BIT(8)) ? BIT(3) : 0x00)
                                 | ((((HorizontalBlankStart >> 3) - 1) & BIT(8))   ? BIT(2) : 0x00)
                                 | ((((HorizontalVisible >> 3) - 1) & BIT(8)) ? BIT(1) : 0x00) 
                                 | ((((HorizontalTotal >> 3) - 5) & BIT(8))  ? BIT(0) : 0x00), Head);

    // 0x3c2 (Misc output register)
    // Program the sync polarities.
    // [7] Vertical Sync Polarity:   0 - active High, 1 - active low 
    // [6] Horizontal Sync Polarity: 0 - active High, 1 - active low 
    val08 = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x3f); // just take bits 5:0
    val08 |= (HorizontalSyncPolarity) ? BIT(6) : 0;
    val08 |= (VerticalSyncPolarity)   ? BIT(7) : 0;
    REG_WR08(NV_PRMVIO_MISC__WRITE, val08);
} // end of dacProgramCustomCRTC


// This is the entry point for non-multi-head-aware modeset methods.
RM_STATUS dacSetMode
(
    PHWINFO pDev,
    U032 head
)
{
    VIDEO_LUT_CURSOR_DAC_OBJECT DacObj;
    // Copy the parameters from the pDev into a local Dac object and call new multi-head aware function
    // (The Dac[] array is for multiple buffers, not multiple Dacs)
    DacObj.HalObject.Dac[0].VisibleImageWidth           = pDev->Dac.HorizontalVisible;
    DacObj.HalObject.Dac[0].HorizontalBlankStart        = pDev->Dac.HorizontalBlankStart;
    DacObj.HalObject.Dac[0].HorizontalSyncStart         = pDev->Dac.HorizontalRetraceStart;
    DacObj.HalObject.Dac[0].HorizontalSyncWidth         = pDev->Dac.HorizontalRetraceEnd - pDev->Dac.HorizontalRetraceStart;
    DacObj.HalObject.Dac[0].HorizontalBlankWidth        = pDev->Dac.HorizontalBlankEnd - pDev->Dac.HorizontalBlankStart;
    DacObj.HalObject.Dac[0].TotalWidth                  = pDev->Dac.HorizontalTotal;
    DacObj.HalObject.Dac[0].VisibleImageHeight          = pDev->Dac.VerticalVisible;
    DacObj.HalObject.Dac[0].VerticalBlankStart          = pDev->Dac.VerticalBlankStart;
    DacObj.HalObject.Dac[0].VerticalSyncStart           = pDev->Dac.VerticalRetraceStart;
    DacObj.HalObject.Dac[0].VerticalSyncHeight          = pDev->Dac.VerticalRetraceEnd - pDev->Dac.VerticalRetraceStart;
    DacObj.HalObject.Dac[0].VerticalBlankHeight         = pDev->Dac.VerticalBlankEnd - pDev->Dac.VerticalBlankStart;
    DacObj.HalObject.Dac[0].TotalHeight                 = pDev->Dac.VerticalTotal;
    DacObj.HalObject.Dac[0].PixelDepth                  = pDev->Dac.PixelDepth;
    DacObj.HalObject.Dac[0].PixelClock                  = pDev->Dac.HalInfo.PixelClock;
    DacObj.HalObject.Dac[0].Format.HorizontalSyncPolarity    = pDev->Dac.HorizontalSyncPolarity;
    DacObj.HalObject.Dac[0].Format.VerticalSyncPolarity      = pDev->Dac.VerticalSyncPolarity;
    DacObj.HalObject.Dac[0].Format.DoubleScanMode       = pDev->Dac.DoubleScannedMode;
    DacObj.HalObject.Head = head;
    DacObj.DisplayType = GETDISPLAYTYPE(pDev, head);
    return dacSetModeMulti(pDev, &DacObj);   // call modeset for head 0
}

/***************************** exported functions **********************************/

// Dac HSYNC & VSYNC control
//
// The Mac needs to be able to individually control these for its power management
//

// XXX couldn't find a #define for these 2 bits...
#define HSYNCBIT   BIT(7)
#define VSYNCBIT   BIT(6)

RM_STATUS dacGetSyncState(
    PHWINFO pDev,
    U032    Head,
    U032   *pHsync,
    U032   *pVsync
)
{
    U008 data08;
    U008 lock;
    
    lock = UnlockCRTC(pDev, Head);
    
    if(GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
	   	
	   	if(dacIsFlatPanelOn(pDev,Head))
	   	{
	   		//if there was a bit 4 present, it implies *enabled*
	   		*pHsync=1;
	   		*pVsync=1;
	   	}
	   	else
	   	{
	   		*pHsync=0;
	   		*pVsync=0;
	   	}
	}
	else
	{
    
    	CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
    	*pHsync = ! (data08 & HSYNCBIT);
    	*pVsync = ! (data08 & VSYNCBIT);
    }
    
    RestoreLock(pDev, Head, lock);
    	
    return RM_OK;
}

RM_STATUS dacSetSyncState(
    PHWINFO pDev,
    U032    Head,
    U032    Hsync,
    U032    Vsync
)
{
    U008 data08;
    U008 lock;
    
    #ifdef DEBUG
    extern int cur_debuglevel;
    int old_debuglevel;
    
    old_debuglevel=cur_debuglevel;
    cur_debuglevel=DEBUGLEVEL_TRACEINFO;
    #endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"SetSyncState on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
    #ifdef DEBUG
    if((!Hsync)||(!Vsync))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"Shutoff of sync requested.");
    }
    #endif
	
	lock = UnlockCRTC(pDev, Head);
	
    if(GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
	   	if((!Hsync)||(!Vsync))
	   	{
	   	    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"Specifically the flatpanel.");
	   	    
      		//power off flat panel
	   		dacPowerOffMobilePanel(pDev,Head);
	   		
	   		//kill PWM
	   		dacZeroPWMController(pDev);
	   	}
	   	else
	   	{
	   		//power on the flat panel
	   		dacPowerOnMobilePanel(pDev,Head);
	   		
	   		//restore PWM
	   		dacSetPWMController(pDev);

	   	}
	}
	else
	{
		
	    
		// read current value
	    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);

	    // clear both
	    data08 &= ~(HSYNCBIT | VSYNCBIT);

	    // set to 1 if no sync
	    if ( ! Hsync)
	        data08 |= HSYNCBIT;
	    if ( ! Vsync)
	        data08 |= VSYNCBIT;

	    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);
	}
	
	RestoreLock(pDev, Head, lock);
	
#ifdef DEBUG
 	cur_debuglevel=old_debuglevel;
#endif
	
    return RM_OK;
}
#undef HSYNCBIT
#undef VSYNCBIT


//
// Program the dac video parameters
//
//  Note that the video parameters have already been deposited in pDev.  This allows us to go
//  through multiple load/unload pairs (like DOS boxes) while still maintaining the original
//  video mode parameters.  It also makes it easier for an applet (like the control panel)
//  to tweak one value, then force an unload/load to make it affective.
//
RM_STATUS dacSetModeMulti(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    RM_STATUS status = RM_OK;
    U016      data,save_sr1 = 0;
    U032      data32;
    U008      shadow,data08, i, cr3Bmod;
    volatile U032 scratch;
    
    // Extract parameters from the VIDEO_LUT_CURSOR_DAC object.
    U032      HorizontalVisible         = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    U032      HorizontalBlankStart      = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
    U032      HorizontalRetraceStart    = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
    U032      HorizontalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
    U032      HorizontalBlankEnd        = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
    U032      HorizontalTotal           = pVidLutCurDac->HalObject.Dac[0].TotalWidth;
    U032      VerticalVisible           = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    U032      VerticalBlankStart        = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
    U032      VerticalRetraceStart      = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
    U032      VerticalRetraceEnd        = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
    U032      VerticalBlankEnd          = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);
    U032      VerticalTotal             = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    U032      PixelDepth                = pVidLutCurDac->HalObject.Dac[0].PixelDepth;
    U032      PixelClock                = pVidLutCurDac->HalObject.Dac[0].PixelClock;
    U032      HorizontalSyncPolarity    = pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity;
    U032      VerticalSyncPolarity      = pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity;
    U032      DoubleScannedMode         = pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode;
    U032      Head                      = pVidLutCurDac->HalObject.Head;
    
    //
    // Validate this mode is valid for the amount of framebuffer present
    // in this specific device.
    // Watch out for pixel depth of 15; add 1 to ensure it divides by 8 and give correct #bytes
    if ((HorizontalVisible * VerticalVisible * ((PixelDepth+1) >> 3)) > 
        pDev->Framebuffer.HalInfo.RamSize)
            return RM_ERROR;

    //
    // There is a bug in NV hardware where the hardware cursor will not clip correctly
    // if a border is defined in the display timings (blank start != visible end).  
    // Borders are only defined in two specific DMT modes.
    //
    // To fix this, set the blank starts to match the visible totals and remove the 
    // implicit borders.
    //
    // Remove this code when the hardware gets fixed.  Since this bug has been in the 
    // hardware since 1994, don't expect a fix soon.
    //
    HorizontalBlankStart = HorizontalVisible;
    HorizontalBlankEnd   = HorizontalTotal;
    VerticalBlankStart   = VerticalVisible;
    VerticalBlankEnd     = VerticalTotal;

    //
    // Set display type.  We can't rely on the caller to actually
    // have specified an allowable valid type.  As one last check,
    // consult the allowed mask.  Don't reset the DisplayType field,
    // but continue on with the modeset just to be safe...
    //
    if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(pVidLutCurDac->DisplayType)) != 0)
        SETDISPLAYTYPE(pDev, Head, pVidLutCurDac->DisplayType);

    //
    // Now set monitor type.
    //
    switch (pVidLutCurDac->DisplayType)
    {
        case DISPLAY_TYPE_MONITOR:
            SETMONITORTYPE(pDev, Head, MONITOR_TYPE_VGA);
            break;
        case DISPLAY_TYPE_TV:
            switch (pVidLutCurDac->TVStandard)
            {
                case NTSC_M:
                case NTSC_J:
                    SETMONITORTYPE(pDev, Head, MONITOR_TYPE_NTSC);
                    break;
                case PAL_A:
                case PAL_M:
                case PAL_N:
                case PAL_NC:
                    SETMONITORTYPE(pDev, Head, MONITOR_TYPE_PAL);
                    break;
            }
            break;
        case DISPLAY_TYPE_DUALSURFACE:
            break;
        case DISPLAY_TYPE_FLAT_PANEL:        
            SETMONITORTYPE(pDev, Head, MONITOR_TYPE_FLAT_PANEL); 
            break;
        default:
            break;
    }

    //
    // Set TV standard.
    //
    pDev->Dac.TVStandard = pVidLutCurDac->TVStandard;

    //
    // We are about to set the new mode. Do any os specific actions necessary at this point.
    // This includes any registry overrides that may affect the new mode.
    // Specifically, determine what type of display device (CRT, FP, or TV), and if TV,
    // what format, and if FP, parse EDID to get timings.
    osPreModeSet(pDev, Head);

    DBG_PRINT_STRING (DEBUGLEVEL_TRACEINFO, "Setting mode \n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "    H Res:", pDev->Framebuffer.HalInfo.HorizDisplayWidth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "    V Res:", pDev->Framebuffer.HalInfo.VertDisplayWidth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Bit Depth:", PixelDepth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  Refresh:", pDev->Framebuffer.HalInfo.RefreshRate);

    // Set the requested refresh rate
    pVidLutCurDac->RefreshRate = (PixelClock * 10000) /
                                 (HorizontalTotal * VerticalTotal);

    //
    // Update tiling configuration.
    //
    nvHalFbControl(pDev, FB_CONTROL_TILING_CONFIGURE);

    //
    // Check for a change to nvclk/mclk values.
    //
    // Since we don't go through a STATE_LOAD as part of a mode switch, this is
    // where we'll program these clocks. The values are only interesting to the
    // arbitration code below, so anytime before that should be good.
    //
    // Since we also haven't done a STATE_UNLOAD, we're assuming this SW method
    // in the host FIFO has allowed enough of the chip to idle, so we can change
    // the clocks. In limited testing, this seems to work.
    //
    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_NVPLL)
    {
        // Program NVCLK
        status = dacProgramNVClk(pDev);
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_NVPLL;
    }

    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_MPLL)
    {
        // Program MCLK
        status = dacProgramMClk(pDev);
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_MPLL;
    }

    //
    // Enable full CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);

    // If this is for CRTC2, set CRTC access bit and PRAMDAC address
    // This access bit controls accesses to Sequencer and Graphics Controller (C03xx).
    // CRTC and Attribute Controller must be accessed at different addresses for each head
    // (6103xx/6033xx), since there is only one bus.
    if (IsNV11(pDev))
    {
        EnableHead(pDev, Head);
        if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        {
            AssocTV(pDev, Head);
            AssocDDC(pDev, Head);
        }
        if (Head == CRTC2)
        {
            REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
            data08 = REG_RD08(NV_PRMVIO_MISC__READ);
            REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);      // unlock head 2
        }            

        //
        // If there's been no modeset on the other head, disable the sequencer
        // allowing this head more FB bandwidth. When a modeset does occur,
        // dacProgramSeq will reset SR1 to the proper value.
        //
        if (pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == NULL)
            dacDisableImage(pDev, Head^1);
    }

    // Disable flat panel syncs
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _DISABLE, Head); // 
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _DISABLE, Head); // 

    CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7
    
    CRTC_RD(0x21, shadow, Head);      // read shadow lock
    data08 = shadow | 0xfa;     // enable HDE, VDE, and 8/9 dot chars too, for NV5.
    CRTC_WR(0x21, data08, Head);
      
    // Set H and V retrace start to a large value to prevent possible lock-up.
    // This is because if the CRTC is slaved to an external device (the TV encoder),
    // it will stall waiting for retrace start to sync up with the external clock. 
    // When we switch from TV to CRT, we may get stuck in this stall. Setting retrace 
    // start to a large value guarantees this won't happen.
    CRTC_WR(NV_CIO_CR_HRS_INDEX, 0xff, Head);
    CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xff, Head);

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        U008 i;

        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, data, Head);         // read scanline double
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, (data &= ~0x80), Head);   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        // Use a time-out in case the bit is stuck.
        for (i=0; i<17; i++)    // max time it can take is 16.7 ms (actually less)
        {
            if (DAC_REG_RD32(NV_PCRTC_RASTER, Head) & DRF_DEF(_PCRTC, _RASTER, _VERT_BLANK, _ACTIVE))
                break;      
            tmrDelay(pDev, 1000000);    // wait 1 ms
        }
        for (i=0; i<17; i++)    // max time it can take is 16.7 ms
        {
            if (!(DAC_REG_RD32(NV_PCRTC_RASTER, Head) & DRF_DEF(_PCRTC, _RASTER, _VERT_BLANK, _ACTIVE)))
                break;
            tmrDelay(pDev, 1000000);    // wait 1 ms
        }
    
        // shadow = CR21
        shadow &= ~0x40;  // shadow the scanline double bit
        CRTC_WR(0x21, (shadow |= 0xA8), Head); // allow horiz & vert write-thru

        // de-couple vertical sync from flat panel while setting mode
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head); 
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

        // power off the panel until the mode is all setup
        if (pDev->Power.MobileOperation)
        {
            dacPowerOffMobilePanel(pDev, Head);
        }
    }
    else
    {
        //
        // We aren't driving DFP on this head, so we need to make sure to flush the overlay
        // clocking in the chip so it's not accidently left pointing at the DFP clocks.
        //
        // If we're not careful, the fp_newline signal inside the chip may still be driven
        // from fpclk, even though we aren't actively using fpclk.  This will result in
        // the overlay video engine not sending output data
        //
        // Here's the HW description of the bug
        //
        // This is a hardware bug that exists in NV10 and subsequent designs: 
        //  *  the video scaler relies on an a signal from the flat panel timing logic, fp_newline
        //  *  when the CRTC is not slaved to the FP, fp_newline should remain 1, however, this is 
        //     not always true
        //  *  if the FP timing has been previously programmed, and the CRTC is un-slaved from the 
        //     FP timing, fp_newline will continue to toggle as if the CRTC were still slaved to the FP.
        //  * also,  if the FPCLK is powered down at a moment when fp_newline is 0, fp_newline will 
        //    remain 0 until FPCLK is powered back up
        //  * fp_newline can be made to remain 1 by doing these steps before unslaving the CRTC from 
        //    the FP timing
        //    1.) disable vertical FP scaling
        //    2.) wait until the next frame
        //    3.) FPCLK and FP syncs must be enabled during this time (steps 1 and 2), i.e., 
        //        NV_PRAMDAC_FP_TG_CONTROL bits 1 and 5 must both be 0.
        //    4.) un-slave CRTC to FP timing
        //    5.) FPCLK and FP H- and V- syncs may now be disabled if desired
        // 
        U032 savedPowerState;

        // Temporarily turn on the FPCLK
        savedPowerState = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);

        // Set the fp to centered with valid sync's 
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _NEG, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _NEG, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);

        tmrDelay(pDev, 35000000);   // this sucks; wait for one vsync to toggle, but
                                    // since the fpclk may not have valid timings
                                    // now, just wait manually for two

        // Turn FPCLK back off again
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, savedPowerState, Head);
    }

    // Program the TV encoder if any.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        status = dacSetupTVEncoder(pDev, Head); 
        if (status)
        {
            switch (status)
            {
                case ERR_I2C_MODE:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Can't program the TV encoder for this mode.\n");
                    break;
                case ERR_I2C_COMM:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: I2C error programming mode\n");
                    break;
                case ERR_I2C_UNKNOWN:
                    DBG_PRINT_STRING (DEBUGLEVEL_ERRORS, "NVRM: No TV Encoder detected\n");
                    break;
            }                
            if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)      // if flat panel, leave it that way.
                SETDISPLAYTYPE(pDev, Head, DISPLAY_TYPE_MONITOR);  // No encoder set up for monitor
        }
    }

    //
    // Disable the visible screen
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);               // Turn off screen at AR
    ////WritePriv08(NV_PRMCIO_ARX, 0x00);        // Turn off screen at AR
        
    //
    // FullCPUOn()
    //
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    data |= 0x2000;                             // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit

    //
    // Set the sequencer & graphics controller values that are common for all packed-pixel
    // graphics modes.
    //            
    dacProgramSeq(pDev, Head);
    //
    // Program the CRTC & SR values for this particular mode.
    //
    dacProgramCRTC(pDev, Head,
                         HorizontalVisible,
                         HorizontalBlankStart,
                         HorizontalRetraceStart,
                         HorizontalRetraceEnd,
                         HorizontalBlankEnd,
                         HorizontalTotal,
                         VerticalVisible,
                         VerticalBlankStart,
                         VerticalRetraceStart,
                         VerticalRetraceEnd,
                         VerticalBlankEnd,
                         VerticalTotal,
                         PixelDepth,
                         PixelClock,
                         HorizontalSyncPolarity,
                         VerticalSyncPolarity,
                         DoubleScannedMode);

    // Set the flat panel timing registers (PRAMDAC_FP).
    // We must program the DAC before we load the palette, because the DAC is driving the 
    // VGA clock.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        U032 fpMode, fpMaxX, fpMaxY;
        BOOL fpConnect;
        BOOL fpNative;
   
// TO DO: do not use the registry for NT
#ifndef NTRM
        status = dacGetFlatPanelInfo(pDev, Head, &fpMode, &fpMaxX, &fpMaxY, &fpConnect, &fpNative,
                                     TRUE /* from registry */);
#else
        status = dacGetFlatPanelInfo
        (
            pDev, 
            Head, 
            &fpMode, 
            &fpMaxX, 
            &fpMaxY, 
            &fpConnect, 
            &fpNative,
            FALSE           /* NOT from registry for NT */
        );
#endif

        // if Native mode requested, make sure this monitor supports it
        if ((fpMode == NV_CFGEX_GET_FLATPANEL_INFO_NATIVE) && (!fpNative))
            fpMode = NV_CFGEX_GET_FLATPANEL_INFO_SCALED;    // no, then do scaled
        status = dacSetFlatPanelMode(pDev, Head, pVidLutCurDac, fpMode, FALSE /* don't commit changes */);
    }
    else
    {
        //
        // If we aren't driving the panel through this head, or
        // (or the other head) turn it off.
        // 
        if (pDev->Power.MobileOperation)
        {
            if ((pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == NULL) ||
                (((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac))->DisplayType != DISPLAY_TYPE_FLAT_PANEL))
            {
                dacPowerOffMobilePanel(pDev, Head);
            }
        }
    }

    // If using an analog CRT with the external DAC, program the PRAMDAC_FP register to generate timing
    if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) && (Head == 1))
    {
        U032 fpMode, fpMaxX, fpMaxY;
        BOOL fpConnect;
        BOOL fpNative;
   
        status = dacGetFlatPanelInfo(pDev, Head, &fpMode, &fpMaxX, &fpMaxY, &fpConnect, &fpNative, FALSE ); /* NOT from registry */
        status = dacSetFlatPanelMode(pDev, Head, pVidLutCurDac, NV_CFGEX_GET_FLATPANEL_INFO_NATIVE, FALSE);
        dacAdjustCRTCForFlatPanel(pDev, Head, pVidLutCurDac);
    }
    
    // This code is necessary to fix a bug found where the memory controller would hang if a delay
    // was NOT inserted before turning on the display after programming the pixel clock PLL's.
    // Only required for SMA mode.
    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            save_sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data = save_sr1;
            data |= 0x2000;                             // Full Bandwidth bit ON
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit
        }
    }

    //
    // Program the new VPLL clock rate
    // If this is a flat panel, or flat panel engine is driving the analog monitor, we should not change the clocks
    if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL) && (Head != 1))
    {
        dacProgramPClk(pDev, Head, PixelClock);
    }

    //
    // Native modes require a divide-by-2 clock ratio
    //                                    
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _NONE);   // assume no TV for now
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);  // assume no TV for now
    }
    pDev->Framebuffer.CursorAdjust = 0;   // default to no adjustment of cursor position
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        dacAdjustCRTCForTV(pDev, Head);              // CRTC tweaks for TV
    }
    else    
    {
        // Not TV, if flat panel, we may need to adjust CRTC's
        if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
            dacAdjustCRTCForFlatPanel(pDev, Head, pVidLutCurDac);
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG);
        }
    }        
    
    //
    // Load default palette values. Do this after clock is running, else we hang.
    //
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        // Set NEWPIX before programming palette to prevent hang on some systems (i.e. VIA).
        // This prevents the PCLK from being held off. Stopping PCLK is done to allow the pixel
        // stream to sync with the flat panel controller, but is also causes the palette to stop 
        // responding, causing bus retries. The VIA chipset doesn't like a lot of bus retries, 
        // and may eventually hang the bus.
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);           
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);  // set NEWPIX
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);
    }

    dacLoadPalette(pDev, Head, PixelDepth);

    // Restore normal clocking (flat panel can hold off)
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);           
        data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16); // set to normal mode
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);
    }

    if(!IsNV0A(pDev)){
        //
        // FullCpuOff()
        //
        data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
        data &= 0xDFFF;                             // Full Bandwidth bit OFF
        WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
    }else{
        if(pDev->Framebuffer.HalInfo.RamType != BUFFER_CRUSH_UMA){
            data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data &= 0xDFFF;                             // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
        }
    }
    
    //
    // ATCOn()
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x20);               // Turn off screen at AR
    ////WritePriv08(NV_PRMCIO_ARX, 0x20);        // Turn off screen at AR
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
      
    // make sure test modes are off, else screen may be blanked
    DAC_REG_WR32(NV_PRAMDAC_TEST_CONTROL, 0, Head); // make sure test modes are off!

    // Enable active display, blank all non-active displays
    //  (TV is blanked in encoder-specific function).
    // + in mobile case, update BIOS's record of enabled displays
    cr3Bmod = 0;
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
            if (Head == 0) // if normal VGA (internal DAC) 
            {
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);  // CRT on
                //
                // We need to be careful about powering down the TMDS
                // transmitter on NV11 because we can lose a flat
                // panel connected to the second crtc (head 1).
                //
                // XXX doing this on the P11 kills the FP on head 1.
                // commenting it out doesn't seem to break anything on the Mac....
                
#ifndef MACOS
                if (IsNV11(pDev))
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _FPCLK, Head);     // FPCLK off only;leave TMDS going for secondary crtc
                else
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);      // FPCLK/TMDS both off
#endif       
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, (data08 & ~0x02), Head);  // clear CR33[1] (BIOS flag)
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & 0x3F, Head);
                
                // make sure that head 0 is NOT driving FP output
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, data08 & ~0x10, Head);    // Bit 4 = 0
                
                dacSetCursorBlink(pDev, Head, 0); // set cursor blink rate for DOS
            }
            else // PRAMDAC_FP is driving analog
            {
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT off
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & ~0x40, Head);
                
                // make head 0 drive FP output
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, data08 | 0x10, Head);    // Bit 4 = FP 2
                
                dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS
            }

            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            //Update BIOS's record of enabled displays

            cr3Bmod = 0x20;
            break;                              
        case DISPLAY_TYPE_TV:
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT offs
            //
            // We need to be careful about powering down the TMDS
            // transmitter on NV11 because we can lose a flat
            // panel connected to the second crtc (head 1).  This wouldn't
            // be an issue if we could 
            //
            if (IsNV11(pDev))
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _FPCLK, Head);     // FPCLK off only;leave TMDS going for secondary crtc
            else
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);      // FPCLK/TMDS both off
            CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
            CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & ~0x40, Head);
            dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS

            //Update BIOS's record of enabled displays
            cr3Bmod = 0x40;
            break;                              
        case DISPLAY_TYPE_FLAT_PANEL:
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT off
            CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
            CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & ~0x40, Head);
            CRTC_RD(0x33, data08, Head);
            CRTC_WR(0x33, data08 | 0x10, Head);    // Bit 4 = FP 2
            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            // Need to actually power on the panel as well
            if (pDev->Power.MobileOperation)
                dacPowerOnMobilePanel(pDev, Head);
            dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS

            //Update BIOS's record of enabled displays
            if (Head == 1) {
                cr3Bmod = 0x10;    //internal LCD
            } else {
                cr3Bmod = 0x80;    //external DFP
            }
            break;                              
    }

    //Update BIOS's record of enabled displays
    if (pDev->Power.MobileOperation &&  pDev->HotKeys.enabled) {
        CRTC_RD(0x3B, data08, Head);
        CRTC_WR(0x3B, (data08 & 0x0F) | cr3Bmod, Head);
    }

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        shadow &= ~0x80;          // shadow Horiz only
        CRTC_WR(0x21, shadow, Head);    // restore the shadow lock
    }

    //Fix for Crush. TV and Flat Panel share some registers. We must
    //set the mux to pick the correct display.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL) 
    {
        if (IsNV0A(pDev)) 
        {
            data32 = 0x00000005;
            DAC_REG_WR32(NV_PRAMDAC_TV_SETUP, data32, Head); 
        }
    }    
    //
    // For NV4, change the default flip functionality to end of vsync, not start
    //
    // BUG BUG BUG:  There is a hardware bug in NV4/NV5 relating to this particular
    // register.  You must access another register in this general area before
    // accessing PCRTC_CONFIG
    //
    data32 = DAC_REG_RD32(NV_PCRTC_START, Head);
    DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA, Head);
    
    //
    // Update arb settings for each mode set
    //

    nvHalDacUpdateArbSettings(pDev, (VOID*) &pVidLutCurDac->HalObject);

    // Save the retrace start/end values (display position default)
    dacSaveMonitorDefaultPosition(pDev, Head);

    // We have successfully set a new mode. Do any os specific actions.
    // This includes any registry settings that should take effect at a mode set.
    osPostModeSet(pDev, Head);

    //
    // Determine if it's possible to support a video overlay in this resolution
    //

    //LPL: will later either add a new multichip function for multi-display,
    // or expand the parameter list on the existing fn.  For now, this hack
    // minimizes the changes to other files.
    nvHalDacValidateArbSettings(pDev, 
                                PixelDepth, 
                                1, 0, 
                                (PixelClock * 10000),
                                &(pDev->Video.OverlayAllowed));


    REG_WR08(NV_PRMCIO_CRX__COLOR, 0x991F & 0xFF); 
    REG_WR08(NV_PRMCIO_CRX__COLOR+1, (0x991F >> 8) & 0xFF);
    ////OEMDisableExtensions();         // Lock the registers

    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            tmrDelay(pDev,/*U032 nsec*/100000000);
            save_sr1 &= 0xDFFF;                         // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, save_sr1);      // Set bit            
        }
    }

    //
    // If we're on an NV11, be sure to restore VGA accesses
    // to the primary (head 0) device.
    //
    if (IsNV11(pDev) && Head != 0)
    {
        if ((pDev->Chip.BiosRevision & 0xFF0000FF) < 0x03000020)
            EnableHead(pDev, 0);
        //REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
        //data08 = REG_RD08(NV_PRMVIO_MISC__READ);
        //REG_WR08(NV_PRMVIO_MISC__WRITE, data08 & ~1);   // enable CGA I/O space
    }


    return RM_OK;
} // end of dacSetMode
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nvx\drivers\resman\kernel\dac\nv\edid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* EDID Functions *****************************
*                                                                           *
* Module: EDID.C                                                            *
*   All EDID related fuctions are in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>
#include <i2c.h>
#include <tmr.h>
#include <edid.h>
#include "nvhw.h"
#include <dac.h>
#include <devinit.h>
#include <vga.h>


U032 getI2CPort(PHWINFO pDev, U032 Head, U032 dispType )
{
    if (IsNV11(pDev)) 
    {
        // We have to know what the mappings of ports to display devices are.
        // Until we can get this from the BIOS, assume the following:
        switch (dispType)
        {
            case DISPLAY_TYPE_MONITOR:
            case DISPLAY_TYPE_DUALSURFACE:
                if (Head == 0) 
                    return pDev->Dac.CRTPortID; // VGA Head 0 use port 0
                else
                    return pDev->Dac.CRT2PortID; // DVI Head 1 use port 1
            case DISPLAY_TYPE_FLAT_PANEL:
                if (Head == 0) 
                    return pDev->Dac.DFPPortID; // DVI Head 0
                else
                    return pDev->Dac.DFP2PortID; // DVI Head 1
            case DISPLAY_TYPE_TV:
                return pDev->Dac.TVOutPortID;
            default:
                return NV_I2C_PORT_PRIMARY;
        }
    }
    else
    {
        // TODO: Use Head as an index into the Dac array
        switch (dispType)
        {
            case DISPLAY_TYPE_MONITOR:
            case DISPLAY_TYPE_DUALSURFACE:
                return pDev->Dac.CRTPortID;
            case DISPLAY_TYPE_FLAT_PANEL:
                return pDev->Dac.DFPPortID;
            case DISPLAY_TYPE_TV:
                return pDev->Dac.TVOutPortID;
            default:
                return NV_I2C_PORT_PRIMARY;
        }
    }
}

static U032 edidTranslateI2CPort(PHWINFO pDev, U008 I2CReadPort)
{
    switch (I2CReadPort)
    {
        case I2C_PHYSICAL_PORT_A_STATUS:
            return NV_I2C_PORT_PRIMARY;
        case I2C_PHYSICAL_PORT_B_STATUS:
            return NV_I2C_PORT_SECONDARY;
        case I2C_PHYSICAL_PORT_C_STATUS:
            return NV_I2C_PORT_TERTIARY;
        default:
            return NV_I2C_PORT_PRIMARY;
    }
}

static U032 edidTranslateDisplayType(U032 displayType)
{
    switch (displayType)
    {
        case DCB_DEV_REC_TYPE_CRT:
        {
            return DISPLAY_TYPE_MONITOR;
        }
        case DCB_DEV_REC_TYPE_TV:
        {
            return DISPLAY_TYPE_TV;
        }
        case DCB_DEV_REC_TYPE_DD_SLINK:
        case DCB_DEV_REC_TYPE_DD_DLINK:
        {
            return DISPLAY_TYPE_FLAT_PANEL;
        }
        default:
            return DISPLAY_TYPE_NONE;
    }
}

static RM_STATUS getDefaultEDIDFromBIOS(PHWINFO, U032, U032);

// Get the monitor to stop driving the DDC bus (DDC1)
// This may only stop the CRT momentarily; we must send a valid DDC2 address
// to be sure it stops permanently.
RM_STATUS StopDDC1(PHWINFO pDev, U032 Head, U032 dispType)
{
U032	i2cPortId = 0;	
U016	status = 1, i;
U008	Data;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    i2cHardwareInit(pDev, Head, i2cPortId);
    tmrDelay(pDev, 15000);
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
    SetSCLLine(pDev, Head, i2cPortId);       // clock high
    SetSDALine(pDev, Head, i2cPortId);       // data high
    for (i=0; i<16; i++)	// give it 16 times
    {
        tmrDelay(pDev, 15000);
        ReadSDA(pDev, Head, i2cPortId, &Data);
        if(Data)        	// SDA = 1?
        {
            status=0;
            break;
        }
    }
    tmrDelay(pDev, 10000);
    i2cStop(pDev, Head, i2cPortId);
    
    // Leave it with clock low (problem with ViewSonic monitors)
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
	
    if (status)
        return (RM_ERROR);
    return (RM_OK);
}

//****************************************************************************************
/*	Determine if monitor is DDC, and in doing so, get it ready to read the EDID or VDIF
	This means get it in DDC2 mode and send the address. Try addresses A0 and A2.
*/
RM_STATUS IsMonitorDDC(PHWINFO pDev, U032 Head, U032 dispType, U008 *dispAddr)
{
    RM_STATUS status;
    U008	Adr, Data;
    U032    i2cPortId;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    // NV11 can drive a CRT on either head; earlier devices only on port 0.
    if (IsNV11(pDev) || (i2cPortId == 0))  
    {
        StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
    }

    // now monitor is in DDC2 mode; we can talk to it
    // send address 0 (start of EDID), no other data
    Adr = 0;
    *dispAddr = DDC_CRT_ADR1;
    if (dispType == DISPLAY_TYPE_MONITOR) {
        status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   // if it fails, its not DDC
    }
    else if (dispType == DISPLAY_TYPE_FLAT_PANEL)
    {
        // if flat panel, device address can be A0, A2, or A6 (50/51/53 shifted left)
	    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   
        if (status)
        {
            *dispAddr = DDC_CRT_ADR2;
		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data);  
            if (status)
            {
                *dispAddr = DDC_CRT_ADR3;
    		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data);  
            }
        }
    }
    else
    {
        // not a DDC device
        status = RM_ERROR;
    }
    return status;
}

U032 edidGetVersion(PHWINFO pDev, U032 Head)
{
    U008 i, index = 0;

    // check for version 1
    if (pDev->Dac.CrtcInfo[Head].EDID[0]	== 0x00)
    {
        for (i=1; i<8; i++)
            if (pDev->Dac.CrtcInfo[Head].EDID[i] == 0xff)
                index = i;
            else 
                break;
        if (pDev->Dac.CrtcInfo[Head].EDID[index+1]	== 0x00)
            return 1;		
    }	
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_VERSION_NUMBER_INDEX] & 0xf0) == 0x20)
        return 2;

    return 0;	// Invalid or unknown EDID
}

//****************************************************************************************
/*	Checksum an EDID
 */
static BOOL EDIDCheckSumOk(
    PHWINFO pDev, 
    U032    Head, 
    U008   *edid,
    U032    length
)
{
    U032 j;
    int  chksum;

    // This is version 1 header
    // checksum the block
    chksum = 0;

    for (j=0; j<length; j++)
        chksum += *edid++;
 
    return ((U008) chksum) == 0;
}

//****************************************************************************************
/*	Read EDID
    Read the EDID of the specified device into the caller's buffer
    The device is specified by the DWORD which is a bit map of up to 8 CRT's, 8 DFP's, and 8 TV's.
*/
RM_STATUS edidReadDevEDID(PHWINFO pDev, U032 device, U008 *pEdid)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortID, Head, dispType;
	U008 	dispAddr;



    status = dacGetDisplayInfo(pDev, device, &Head, &dispType, 0, 0);

    if (status != RM_OK)
    {
        return status;
    }

    dispType = edidTranslateDisplayType(dispType);

    if (dispType == DISPLAY_TYPE_NONE)
    {
        status = RM_ERROR;
        return status;
    }
    //
    // Look for EDID overrides for mobile operation
    //
    if (dispType == DISPLAY_TYPE_FLAT_PANEL && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pEdid);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    i2cPortID = getI2CPort(pDev, Head, dispType);

	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, pEdid);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pEdid[0] == 0 && pEdid[1] == 0xff &&
                pEdid[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pEdid, 128))
            	    goto done;
            }
            else if ((pEdid[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, 
                                 &(pEdid[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pEdid, 256))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave
        for (j=0; j< 10; j++) 
        {
            i2cStart(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
            i2cStop(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
	if (status == RM_OK)
	    return RM_OK;

#ifdef MACOS
    // one last chance to get an EDID
    status = getDefaultEDIDFromBIOS(pDev, Head, dispType);
#endif
#endif // defined IKOS

    return status;
}


//****************************************************************************************
/*	Read EDID
	dispType is the display we want to read, not necessarily the current device.
    This will alwasy return RM_OK, since we'll get the BIOS default EDID if none if found,
    UNLESS this if for mobile?
*/
RM_STATUS EDIDRead(PHWINFO pDev, U032 Head, U032 dispType)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortId;
	U008 	dispAddr;

    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
    
    //
    // Look for EDID overrides for mobile operation
    //
    if ((dispType == DISPLAY_TYPE_FLAT_PANEL) && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0 && pDev->Dac.CrtcInfo[Head].EDID[1] == 0xff &&
                pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 128))
            	    goto done;
            }
            else if ((pDev->Dac.CrtcInfo[Head].EDID[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, 
                                 &(pDev->Dac.CrtcInfo[Head].EDID[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 256))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave (may be hung up and not responding)
        for (j=0; j< 20; j++) 
        {
            i2cStart(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);      // 20 us
            i2cStop(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);
            // one last desparate measure 
            StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
            tmrDelay(pDev, 2000000);    // 2 ms
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
	if (status == RM_OK)
	    return RM_OK;

#ifdef MACOS
    // one last chance to get an EDID
    status = getDefaultEDIDFromBIOS(pDev, Head, dispType);
#endif
#endif // defined IKOS

    return status;
}

//****************************************************************************************
/*	See if a device has an EDID 
	dispType is the display we want to read, not necessarily the current device.
*/
RM_STATUS EDIDDetect(PHWINFO pDev, U032 Head, U032 dispType)
{
#ifndef IKOS    // This is just too painfully slow
    int	    i;
    RM_STATUS    status;
    U008    block_ID, lock;
    U032    i2cPortId;
	U008 	dispAddr;
    U008    EdidBuffer[128];

    lock = ReadCRTCLock(pDev, Head);	// Unlock the registers

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
	// See if device supports DDC and which address it uses
    if (IsMonitorDDC(pDev, Head, dispType, &dispAddr) != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        return RM_ERROR;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block (at least 0x50 bytes to get version 2 display technology byte).
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 0x50, EdidBuffer);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2,
            if (EdidBuffer[0] == 0 && EdidBuffer[1] == 0xff &&
                EdidBuffer[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
                // This is version 1 header, get video input definition
                if (EdidBuffer[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))     // digital device?
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else if ((EdidBuffer[0] >> 4) == 2)
            {
                // This is a version 2 header.
                if ((EdidBuffer[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0) // analog device?
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else
            {
                // Unknown edid header.
                status = RM_ERROR;
            }
    	} // Successfully read the first 128 byte block.
    } // retry
done:    
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);

	return status;
#else   // defined IKOS
    return RM_ERROR;
#endif  // IKOS
}

static RM_STATUS getDefaultEDIDFromBIOS(
    PHWINFO pDev,
    U032    Head,
    U032    dispType
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 offset;
    BMP_Control_Block bmpCtrlBlk;

#ifdef MACOS

    U032 edid_len;               //012345
    char edid_registry_name[16] = "EDID,x";

    // on the Mac, a fallback EDID could be in the registry (published by fcode)
    // Check here before falling back to the BIOS image
    // If it is in the registry
    // XXX this could be generic, I guess.
    
    edid_len = sizeof(pDev->Dac.CrtcInfo[Head].EDID);
    edid_registry_name[5] = 'A' + Head;     // "EDID,A" or "EDID,B"
    
	if ((RM_OK == osReadRegistryBinary(pDev, "", edid_registry_name, pDev->Dac.CrtcInfo[Head].EDID, &edid_len)))
	{
    	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, edid_len))
        {
        	// Ok, it looks good so far, but is it the right "type" (fp or crt)
        	// Can't be too careful, you know....
        	BOOL analog_display;
        	BOOL expected_analog;

        	analog_display  = edidIsAnalogDisplay(pDev, Head);
        	expected_analog = dispType == DISPLAY_TYPE_MONITOR;
        	
        	if (analog_display != expected_analog)
        	{
	            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: found 'canned' EDID; but wrong type\n");
        	    return RM_ERROR;
        	}
        	
	        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: using 'canned' EDID from registry\n");
    	    return RM_OK;
    	}
	}
#endif //  MACOS

    rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);

    if (rmStatus == RM_OK) 
    {
        // we only care about version 5 bmp tables
        switch ( bmpCtrlBlk.CTL_Version )
        {
            case BMP_INIT_TABLE_VER_0:
            case BMP_INIT_TABLE_VER_1:
            case BMP_INIT_TABLE_VER_2:
            case BMP_INIT_TABLE_VER_3:
            case BMP_INIT_TABLE_VER_4:
                 break;
            case BMP_INIT_TABLE_VER_5:
            {
               BMP_Struc_Rev5 bmp_InitTableInfo ;
               rmStatus = BiosReadStructure(pDev,
                                            (U008 *) &bmp_InitTableInfo,
                                            offset,
                                            (U032 *) 0,
                                            BMP_INIT5_FMT);
               if (rmStatus == RM_OK) 
               {
                   rmStatus = BiosReadBytes(pDev,
                                            pDev->Dac.CrtcInfo[Head].EDID,
                                            bmp_InitTableInfo.BMP_LCDEDID,
                                            EDID_V1_SIZE);
               }
               break;
            }
            default:
                rmStatus = RM_ERROR;
        }
    }

    return rmStatus;
}


//****************************************************************************************
/*	Read VDIF
	VDIF follows after last EDID block, so to read a VDIF block we need to get the
	number of EDID blocks (*128) and add the VDIF block (*64)
*/
RM_STATUS ReadVDIF(PHWINFO pDev, U032 Head, U032 dispType, U008 *buffer, U008 device, U008 address)
{
    int     i;
    RM_STATUS  status;
    U008    Adr;
    U032    i2cPortId;

// FILL IN THIS !!!

    // get number of EDID blocks

    // calc VDIF block address

    // read VDIF
    i2cPortId = getI2CPort(pDev, Head, dispType);
    status = RM_OK;       /* macosX's version of gcc thinks 'status' may not be init before use */
    for (i=0; i<DDC_RETRIES; i++)
    {
        // send a write command and read back a block (NOTE: the device address is shifted up in our function, so 50->A0)
        status = i2cRead(pDev, Head, i2cPortId, 0x50, 0, &Adr, 128, buffer);
        if (status == RM_OK)
            break;		
    }

    return (status);
}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
static BOOL EDIDIsValid
(
    PHWINFO pDev,
    U008    **edidPtr,
    U032    *version,
    U032    *revision,
    U032    Head
)
{
    U008 *edid;


    edid = pDev->Dac.CrtcInfo[Head].EDID;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
BOOL edidLogicalEDIDIsValid
(
    U008    **edidPtr,
    U032    *version,
    U032    *revision
)
{
    U008 *edid;


    edid = *edidPtr;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

static RM_STATUS EDIDV1Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // version 1
    if (*bufLen < EDID_V1_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V1_SIZE;

	osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

static RM_STATUS EDIDV2Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // Version 2
    if (*bufLen < EDID_V2_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V2_SIZE;
    
    osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

// This function copies the edid from the pDev into the buffer passed.
// Currently only version 1 edid header is supported.
RM_STATUS EDIDCopy
(
    PHWINFO pDev,
    U008    *buffer,
    U032    *bufLen,
    U032    Head
)
{
    U032 edidVersion, edidRevision;
    U008 *edid;

    if (!EDIDIsValid(pDev, &edid, &edidVersion, &edidRevision, Head)) // verify EDID and get a pointer to it
    {
        // edid not valid
        *bufLen = 0;
        return RM_ERROR;
    }

    if (edidVersion == 1)
    {
        return EDIDV1Copy (pDev, edid, buffer, bufLen);
    }
    else if (edidVersion == 2)
    {
        return EDIDV2Copy (pDev, edid, buffer, bufLen);
    }

    // Unknown edid header.
    *bufLen = 0;
    return RM_ERROR;
} // end of EDIDCopy

#if 0 // no one calling this, so turn it off 
static RM_STATUS EDIDV1GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032      i, j, tmpHRes, tmpVRes = ~0, tmpRefresh;

    *maxRefreshRate = 0;
    // Get the max from the established timing section
    switch (hRes)
    {
        case 720:
            if (vRes == 400)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x40)
                {
                    // Supports 720x400 @ 88Hz.
                    *maxRefreshRate = 88;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x80)
                {
                    // supports 720x400 @ 70Hz
                    *maxRefreshRate = 70;
                }

            }
            break;
        case 640:
            if (vRes == 480)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x04)
                {
                    // Supports 640x480 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x08)
                {
                    // supports 640x480 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x10)
                {
                    // supports 640x480 @ 67Hz
                    *maxRefreshRate = 67;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x20)
                {
                    // supports 640x480 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 800:
            if (vRes == 600)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x40)
                {
                    // Supports 800x600 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x80)
                {
                    // supports 800x600 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x01)
                {
                    // supports 800x600 @ 60Hz
                    *maxRefreshRate = 60;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x02)
                {
                    // supports 800x600 @ 56Hz
                    *maxRefreshRate = 56;
                }
            }
            break;
        case 832:
            if (vRes == 624)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x20)
                {
                    // Supports 832x624 @ 75Hz.
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1024:
            if (vRes == 768)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x10)
                {
                    // Supports 1024x768 @ 87Hz
                    *maxRefreshRate = 87;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x02)
                {
                    // supports 1024x768 @ 75Hz
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x04)
                {
                    // supports 1024x768 @ 70Hz
                    *maxRefreshRate = 70;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x08)
                {
                    // supports 1024x768 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 1280:
            if (vRes == 1024)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x01)
                {
                    // Supports 1280x1024 @ 75Hz
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1152:
            if (vRes == 870)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_3_INDEX] & 0x80)
                {
                    // Supports 1152x870 @ 75Hz 
                    *maxRefreshRate = 75;
                }
            }
            break;
        default:
            break;
    } // switch on hRes


    // Now check the standard timings to see if there is a higher refresh rate specified.
   	for (i = 0; i < 8; i++)
	{
		if (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i * 2)] != 0x01)
		{
			// there is a standard timing specification.
			tmpHRes = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2)] + 31) * 8;
			tmpRefresh = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0x3f) + 60;
			switch ((edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0xc0) >> 6)
			{
			case 0x0:
				// aspect ratio 1:1
				tmpVRes = tmpHRes;
				break;
			case 0x1:
				// aspect ratio 4:3
				tmpVRes = (tmpHRes * 3) / 4;
				break;
			case 0x2:
				// aspect ratio 5:4
				tmpVRes = (tmpHRes * 4) / 5;
				break;
			case 0x3:
				// aspect ratio 16:9
				tmpVRes = (tmpHRes * 9) / 16;
				break;
			}

            // Check if this standard timing matches the resolution we want.
            if (tmpHRes == hRes && tmpVRes == vRes)
            {
                // Resolution matches. 
                // If this refresh rate is > than the one found in established timings, use it.
                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            }
		} // A valid standard timing spec
	} // iterate over all 8 standard timings

    // Now check the detailed timing specification for a macting resolution.
	for (i = 0; i < 4; i++)
	{
		int startIndex = EDID_V1_DETAILED_TIMINGS_START_INDEX + (i * EDID_V1_DETAILED_TIMINGS_SIZE);
		if (edid[startIndex] == 0 && edid[startIndex + 1] == 0)
		{
			// This is a Monitor descriptor instead of a detailed timing descriptor.
			switch (edid[startIndex + 3])
			{
                case 0xFA:
                    // Descriptor contains 6 additional standard timing identifications
                    for (j = 0; j < 6; j++)
                    {
                        if (edid[startIndex + 5 + (j * 2)] != 0x01)
                        {
                            // there is a standard timing specification.
                            tmpHRes = (edid[startIndex + 5 + (j*2)] + 31) * 8;
                            tmpRefresh = (edid[startIndex + 5 + (j*2) + 1] & 0x3f) + 60;
                            switch ((edid[startIndex + 5 + (j*2) + 1] & 0xc0) >> 6)
                            {
                            case 0x0:
                                // aspect ratio 1:1
                                tmpVRes = tmpHRes;
                                break;
                            case 0x1:
                                // aspect ratio 4:3
                                tmpVRes = (tmpHRes * 3) / 4;
                                break;
                            case 0x2:
                                // aspect ratio 5:4
                                tmpVRes = (tmpHRes * 4) / 5;
                                break;
                            case 0x3:
                                // aspect ratio 16:9
                                tmpVRes = (tmpHRes * 9) / 16;
                                break;
                            } // switch on aspect ratio

                            // Check if this standard timing matches the resolution we want.
                            if (tmpHRes == hRes && tmpVRes == vRes)
                            {
                                // Resolution matches. 
                                // If this refresh rate is > than the one found in established timings, use it.
                                if (tmpRefresh > *maxRefreshRate)
                                {
                                    *maxRefreshRate = tmpRefresh;
                                }
                            }
                        } // a valid standard timing spec
                    } // iterate over the 6 additional standard timings
                    break;
                default:
                    break;
			}
		} // monitor descriptor.
		else
		{
			// This is a detailed timing descriptor.
            // The detailed timing specification does not include the refresh rate.
			U032 pixelClock;
			U032 hActive, vActive, hBlank, vBlank;
			U032 hTotal, vTotal;


			hActive = edid[startIndex + 2] | ((edid[startIndex + 4] & 0xf0) << 4);
			vActive = edid[startIndex + 5] | ((edid[startIndex + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[startIndex] | (edid[startIndex + 1] << 8);
                hBlank  = edid[startIndex + 3] | ((edid[startIndex + 4] & 0x0f) << 8);
                vBlank  = edid[startIndex + 6] | ((edid[startIndex + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
		} // This is a detailed timing spec
	} // parse detailed section

    return RM_OK;
}

static RM_STATUS EDIDV2GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032 lumTabSize, numLumTables;
    U032 numFreqRanges, numDetailedRanges, numTimingCodes, numDetailedTimings;
    U032 detailedTimingIndex, timingCodesIndex;
    U008 timingMap1, timingMap2;
    U032 index, i;

    // We need to look in the 4-byte timing codes section and the detailed timing section for
    // the given resolution.

    // The way the 127 byte detailed information is used is given by reading bytes 0x7e and 0x7f.
    // The size and the order of the 127 byte timing section that start at byte 0x80 is:
    // x*A + 8*B + 27*c + 4*D + 18*E where
    // A = number of luminance tables (0 or 1), (given by byte 0x7e bit 5)
    // x = size of the luminance table (given by the first byte of the table itself)
    // B = number of frequency rages listed (0-7), (given by bits 4-2 of byte 0x7e)
    // C = number of detailed rage limits (0-3), (given by (bits 1-0 of byte 0x7e)
    // D = number of timing codes (0-31), (given by bits 7-3 of byte 0x7f)
    // E = number of detailed timing descriptions (0-7) (given by bits 2-0 of byte 0x7f)
    timingMap1 = edid[EDID_V2_TIMING_MAP1_INDEX];
    timingMap2 = edid[EDID_V2_TIMING_MAP2_INDEX];
    numLumTables       = (timingMap1 & 0x20) >> 5; // Bit 5
    numFreqRanges      = (timingMap1 & 0x1C) >> 2; // Bits 4-2
    numDetailedRanges  = (timingMap1 & 0x03);      // Bits 1-0
    numTimingCodes     = (timingMap2 & 0xf8) >> 3; // Bits 7-3
    numDetailedTimings = (timingMap2 & 0x07);      // Bits 2-0
    if (numLumTables != 0)
    {
        // Calculate the size of the lum table by reading byte 0x80
        U032 numLumValues;

        numLumValues = edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x1f; // bits 4-0
        if (edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x80)
        {
            // size of lum table is ((3 * numLumValues) + 1) bytes
            lumTabSize = 3 * numLumValues + 1;
        }
        else
        {
            // size of lum table is (numLumValues + 1) bytes
            lumTabSize = numLumValues + 1;
        }
    }
    else
        lumTabSize = 0;

    timingCodesIndex = EDID_V2_TIMING_SECTION_START_INDEX 
                       + lumTabSize 
                       + (8 * numFreqRanges)
                       + (27 * numDetailedRanges);
    detailedTimingIndex = timingCodesIndex + (8 * numTimingCodes);

    *maxRefreshRate = 0;

    {
        // Look in the timing codes section.
        U032 hActive;
        U032 aspectRatio;
        U032 vActive;
        for (i = 0; i < numTimingCodes; i++)
        {
            index = timingCodesIndex + (4 * i);
            hActive = (edid[index] * 16) + 256;
            aspectRatio = edid[index + 2];
            // Aspect ratio is stored in terms of N:100.
			// This is not very useful because we don't get the standard vertical values.
			// So we will use the standard aspect ratios whenever we can.
			switch (aspectRatio)
			{
			case 133:
				// 4:3
				vActive = (hActive * 3) / 4;
				break;
			case 125:
				// 5:4
				vActive = (hActive * 4) / 5;
				break;
			case 177:
				// 16:9
				vActive = (hActive * 9) / 16;
				break;
			default:
                vActive = (hActive * 100) / aspectRatio;
				break;
			}
            if (hActive == hRes && vActive == vRes)
            {
                // This is the needed resolution.
                if (edid[index + 3] > *maxRefreshRate)
                {
                    *maxRefreshRate = edid[index + 3];
                }
            } // resolution matches
        } // loop over all the timing codes
    } // look in timing codes

    {
        // look in the detailed timing section
        // The detailed timing specification does not include the refresh rate.
        U032 pixelClock;
        U032 hActive, vActive, hBlank, vBlank;
        U032 hTotal, vTotal;
        U032 tmpRefresh;

        for (i = 0; i < numDetailedTimings; i++)
        {
            index = detailedTimingIndex + (18 * i);
            hActive = edid[index + 2] | ((edid[index + 4] & 0xf0) << 4);
            vActive = edid[index + 5] | ((edid[index + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[index] | (edid[index + 1] << 8);
                hBlank  = edid[index + 3] | ((edid[index + 4] & 0x0f) << 8);
                vBlank  = edid[index + 6] | ((edid[index + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
        } // loop over all the detailed timing specs
    } // look in detailed timing section

    return RM_OK;
}
#endif  // #if 0; no one calling this puppy


// EDID Version 1.3
// Super set of 1.2, allows range limits descriptor to define coeficients for secondary GTF curve,
// and mandates a certain set of monitor descriptors.
RM_STATUS ParseEDID13(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

// EDID Version 1.2
RM_STATUS ParseEDID12(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

//	Parse a detailed timing block in the current EDID
//	The EDID has been saved in the global device data structure (nvInfo).
//	When native mode is requested, it is necessary to find the correct detailed timing;
//  otherwise fpParseEDID will be used to get timing info.
U032 edidParseDetailedTimingBlock(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
	switch (pDev->Dac.CrtcInfo[Head].EdidVersion)
	{
		case EDID_VERSION_10:
		case EDID_VERSION_11:
		case EDID_VERSION_12:
		case EDID_VERSION_13:
			return edidParseDetailed1(pDev, block, fpTim, Head);
		case EDID_VERSION_20:
			return edidParseDetailed2(pDev, block, fpTim, Head);
	}

	return(0);
}

//	Parse a specific detailed timing block for EDID version 1.x
//  Detailed timings are at a fixed offset from the start of the buffer.
U032 edidParseDetailed1(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyn